(async ()=>{
    const proxyMarker = Symbol("Comlink.proxy");
    const createEndpoint = Symbol("Comlink.endpoint");
    const releaseProxy = Symbol("Comlink.releaseProxy");
    const finalizer = Symbol("Comlink.finalizer");
    const throwMarker = Symbol("Comlink.thrown");
    const isObject$1 = (val)=>typeof val === "object" && val !== null || typeof val === "function";
    const proxyTransferHandler = {
        canHandle: (val)=>isObject$1(val) && val[proxyMarker],
        serialize (obj) {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port1);
            return [
                port2,
                [
                    port2
                ]
            ];
        },
        deserialize (port) {
            port.start();
            return wrap(port);
        }
    };
    const throwTransferHandler = {
        canHandle: (value)=>isObject$1(value) && throwMarker in value,
        serialize ({ value }) {
            let serialized;
            if (value instanceof Error) {
                serialized = {
                    isError: true,
                    value: {
                        message: value.message,
                        name: value.name,
                        stack: value.stack
                    }
                };
            } else {
                serialized = {
                    isError: false,
                    value
                };
            }
            return [
                serialized,
                []
            ];
        },
        deserialize (serialized) {
            if (serialized.isError) {
                throw Object.assign(new Error(serialized.value.message), serialized.value);
            }
            throw serialized.value;
        }
    };
    const transferHandlers = new Map([
        [
            "proxy",
            proxyTransferHandler
        ],
        [
            "throw",
            throwTransferHandler
        ]
    ]);
    function isAllowedOrigin(allowedOrigins, origin) {
        for (const allowedOrigin of allowedOrigins){
            if (origin === allowedOrigin || allowedOrigin === "*") {
                return true;
            }
            if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
                return true;
            }
        }
        return false;
    }
    function expose(obj, ep = globalThis, allowedOrigins = [
        "*"
    ]) {
        ep.addEventListener("message", function callback(ev) {
            if (!ev || !ev.data) {
                return;
            }
            if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
                console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
                return;
            }
            const { id, type, path } = Object.assign({
                path: []
            }, ev.data);
            const argumentList = (ev.data.argumentList || []).map(fromWireValue);
            let returnValue;
            try {
                const parent = path.slice(0, -1).reduce((obj2, prop)=>obj2[prop], obj);
                const rawValue = path.reduce((obj2, prop)=>obj2[prop], obj);
                switch(type){
                    case "GET":
                        {
                            returnValue = rawValue;
                        }
                        break;
                    case "SET":
                        {
                            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                            returnValue = true;
                        }
                        break;
                    case "APPLY":
                        {
                            returnValue = rawValue.apply(parent, argumentList);
                        }
                        break;
                    case "CONSTRUCT":
                        {
                            const value = new rawValue(...argumentList);
                            returnValue = proxy(value);
                        }
                        break;
                    case "ENDPOINT":
                        {
                            const { port1, port2 } = new MessageChannel();
                            expose(obj, port2);
                            returnValue = transfer(port1, [
                                port1
                            ]);
                        }
                        break;
                    case "RELEASE":
                        {
                            returnValue = void 0;
                        }
                        break;
                    default:
                        return;
                }
            } catch (value) {
                returnValue = {
                    value,
                    [throwMarker]: 0
                };
            }
            Promise.resolve(returnValue).catch((value)=>{
                return {
                    value,
                    [throwMarker]: 0
                };
            }).then((returnValue2)=>{
                const [wireValue, transferables] = toWireValue(returnValue2);
                ep.postMessage(Object.assign(Object.assign({}, wireValue), {
                    id
                }), transferables);
                if (type === "RELEASE") {
                    ep.removeEventListener("message", callback);
                    closeEndPoint(ep);
                    if (finalizer in obj && typeof obj[finalizer] === "function") {
                        obj[finalizer]();
                    }
                }
            }).catch((error)=>{
                const [wireValue, transferables] = toWireValue({
                    value: new TypeError("Unserializable return value"),
                    [throwMarker]: 0
                });
                ep.postMessage(Object.assign(Object.assign({}, wireValue), {
                    id
                }), transferables);
            });
        });
        if (ep.start) {
            ep.start();
        }
    }
    function isMessagePort(endpoint) {
        return endpoint.constructor.name === "MessagePort";
    }
    function closeEndPoint(endpoint) {
        if (isMessagePort(endpoint)) endpoint.close();
    }
    function wrap(ep, target) {
        const pendingListeners = new Map();
        ep.addEventListener("message", function handleMessage(ev) {
            const { data } = ev;
            if (!data || !data.id) {
                return;
            }
            const resolver = pendingListeners.get(data.id);
            if (!resolver) {
                return;
            }
            try {
                resolver(data);
            } finally{
                pendingListeners.delete(data.id);
            }
        });
        return createProxy(ep, pendingListeners, [], target);
    }
    function throwIfProxyReleased(isReleased) {
        if (isReleased) {
            throw new Error("Proxy has been released and is not useable");
        }
    }
    function releaseEndpoint(ep) {
        return requestResponseMessage(ep, new Map(), {
            type: "RELEASE"
        }).then(()=>{
            closeEndPoint(ep);
        });
    }
    const proxyCounter = new WeakMap();
    const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep)=>{
        const newCount = (proxyCounter.get(ep) || 0) - 1;
        proxyCounter.set(ep, newCount);
        if (newCount === 0) {
            releaseEndpoint(ep);
        }
    });
    function registerProxy(proxy2, ep) {
        const newCount = (proxyCounter.get(ep) || 0) + 1;
        proxyCounter.set(ep, newCount);
        if (proxyFinalizers) {
            proxyFinalizers.register(proxy2, ep, proxy2);
        }
    }
    function unregisterProxy(proxy2) {
        if (proxyFinalizers) {
            proxyFinalizers.unregister(proxy2);
        }
    }
    function createProxy(ep, pendingListeners, path = [], target = function() {}) {
        let isProxyReleased = false;
        const proxy2 = new Proxy(target, {
            get (_target, prop) {
                throwIfProxyReleased(isProxyReleased);
                if (prop === releaseProxy) {
                    return ()=>{
                        unregisterProxy(proxy2);
                        releaseEndpoint(ep);
                        pendingListeners.clear();
                        isProxyReleased = true;
                    };
                }
                if (prop === "then") {
                    if (path.length === 0) {
                        return {
                            then: ()=>proxy2
                        };
                    }
                    const r = requestResponseMessage(ep, pendingListeners, {
                        type: "GET",
                        path: path.map((p)=>p.toString())
                    }).then(fromWireValue);
                    return r.then.bind(r);
                }
                return createProxy(ep, pendingListeners, [
                    ...path,
                    prop
                ]);
            },
            set (_target, prop, rawValue) {
                throwIfProxyReleased(isProxyReleased);
                const [value, transferables] = toWireValue(rawValue);
                return requestResponseMessage(ep, pendingListeners, {
                    type: "SET",
                    path: [
                        ...path,
                        prop
                    ].map((p)=>p.toString()),
                    value
                }, transferables).then(fromWireValue);
            },
            apply (_target, _thisArg, rawArgumentList) {
                throwIfProxyReleased(isProxyReleased);
                const last = path[path.length - 1];
                if (last === createEndpoint) {
                    return requestResponseMessage(ep, pendingListeners, {
                        type: "ENDPOINT"
                    }).then(fromWireValue);
                }
                if (last === "bind") {
                    return createProxy(ep, pendingListeners, path.slice(0, -1));
                }
                const [argumentList, transferables] = processArguments(rawArgumentList);
                return requestResponseMessage(ep, pendingListeners, {
                    type: "APPLY",
                    path: path.map((p)=>p.toString()),
                    argumentList
                }, transferables).then(fromWireValue);
            },
            construct (_target, rawArgumentList) {
                throwIfProxyReleased(isProxyReleased);
                const [argumentList, transferables] = processArguments(rawArgumentList);
                return requestResponseMessage(ep, pendingListeners, {
                    type: "CONSTRUCT",
                    path: path.map((p)=>p.toString()),
                    argumentList
                }, transferables).then(fromWireValue);
            }
        });
        registerProxy(proxy2, ep);
        return proxy2;
    }
    function myFlat(arr) {
        return Array.prototype.concat.apply([], arr);
    }
    function processArguments(argumentList) {
        const processed = argumentList.map(toWireValue);
        return [
            processed.map((v)=>v[0]),
            myFlat(processed.map((v)=>v[1]))
        ];
    }
    const transferCache = new WeakMap();
    function transfer(obj, transfers) {
        transferCache.set(obj, transfers);
        return obj;
    }
    function proxy(obj) {
        return Object.assign(obj, {
            [proxyMarker]: true
        });
    }
    function toWireValue(value) {
        for (const [name, handler] of transferHandlers){
            if (handler.canHandle(value)) {
                const [serializedValue, transferables] = handler.serialize(value);
                return [
                    {
                        type: "HANDLER",
                        name,
                        value: serializedValue
                    },
                    transferables
                ];
            }
        }
        return [
            {
                type: "RAW",
                value
            },
            transferCache.get(value) || []
        ];
    }
    function fromWireValue(value) {
        switch(value.type){
            case "HANDLER":
                return transferHandlers.get(value.name).deserialize(value.value);
            case "RAW":
                return value.value;
        }
    }
    function requestResponseMessage(ep, pendingListeners, msg, transfers) {
        return new Promise((resolve)=>{
            const id = generateUUID();
            pendingListeners.set(id, resolve);
            if (ep.start) {
                ep.start();
            }
            ep.postMessage(Object.assign({
                id
            }, msg), transfers);
        });
    }
    function generateUUID() {
        return new Array(4).fill(0).map(()=>Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
    }
    const CHUNK = 8192;
    function uint8ToBase64(bytes) {
        const parts = [];
        for(let i = 0; i < bytes.length; i += CHUNK){
            parts.push(String.fromCharCode.apply(null, Array.from(bytes.subarray(i, i + CHUNK))));
        }
        return btoa(parts.join(""));
    }
    function base64ToUint8(base64) {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for(let i = 0; i < binary.length; i++){
            bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
    }
    function uint8ToHex(bytes) {
        const hex = new Array(bytes.length);
        for(let i = 0; i < bytes.length; i++){
            hex[i] = bytes[i].toString(16).padStart(2, "0");
        }
        return hex.join("");
    }
    function uint8ToBinaryString(bytes) {
        const parts = [];
        for(let i = 0; i < bytes.length; i += CHUNK){
            parts.push(String.fromCharCode.apply(null, Array.from(bytes.subarray(i, i + CHUNK))));
        }
        return parts.join("");
    }
    function createNodeError(code, syscall, path, message) {
        const errno = {
            ENOENT: -2,
            ENOTDIR: -20,
            EISDIR: -21,
            EEXIST: -17,
            ENOTEMPTY: -39
        };
        const messages = {
            ENOENT: "no such file or directory",
            ENOTDIR: "not a directory",
            EISDIR: "is a directory",
            EEXIST: "file already exists",
            ENOTEMPTY: "directory not empty"
        };
        const err = new Error(`${code}: ${messages[code]}, ${syscall} '${path}'`);
        err.code = code;
        err.errno = errno[code];
        err.syscall = syscall;
        err.path = path;
        return err;
    }
    class VirtualFS {
        root;
        encoder = new TextEncoder();
        decoder = new TextDecoder();
        watchers = new Map();
        eventListeners = new Map();
        constructor(){
            this.root = {
                type: "directory",
                children: new Map(),
                mtime: Date.now()
            };
        }
        on(event, listener) {
            if (!this.eventListeners.has(event)) {
                this.eventListeners.set(event, new Set());
            }
            this.eventListeners.get(event).add(listener);
            return this;
        }
        off(event, listener) {
            const listeners = this.eventListeners.get(event);
            if (listeners) {
                listeners.delete(listener);
            }
            return this;
        }
        emit(event, ...args) {
            const listeners = this.eventListeners.get(event);
            if (listeners) {
                for (const listener of listeners){
                    try {
                        listener(...args);
                    } catch (err) {
                        console.error("Error in VFS event listener:", err);
                    }
                }
            }
        }
        toSnapshot() {
            const files = [];
            this.serializeNode("/", this.root, files);
            return {
                files
            };
        }
        serializeNode(path, node, files) {
            if (node.type === "file") {
                let content = "";
                if (node.content && node.content.length > 0) {
                    content = uint8ToBase64(node.content);
                }
                files.push({
                    path,
                    type: "file",
                    content
                });
            } else if (node.type === "directory") {
                files.push({
                    path,
                    type: "directory"
                });
                if (node.children) {
                    for (const [name, child] of node.children){
                        const childPath = path === "/" ? `/${name}` : `${path}/${name}`;
                        this.serializeNode(childPath, child, files);
                    }
                }
            }
        }
        static fromSnapshot(snapshot) {
            const vfs = new VirtualFS();
            const sortedFiles = snapshot.files.map((entry, i)=>({
                    entry,
                    depth: entry.path.split("/").length,
                    i
                })).sort((a, b)=>a.depth - b.depth || a.i - b.i).map((x)=>x.entry);
            for (const entry of sortedFiles){
                if (entry.path === "/") continue;
                if (entry.type === "directory") {
                    vfs.mkdirSync(entry.path, {
                        recursive: true
                    });
                } else if (entry.type === "file") {
                    let content;
                    if (entry.content) {
                        content = base64ToUint8(entry.content);
                    } else {
                        content = new Uint8Array(0);
                    }
                    const parentPath = entry.path.substring(0, entry.path.lastIndexOf("/")) || "/";
                    if (parentPath !== "/" && !vfs.existsSync(parentPath)) {
                        vfs.mkdirSync(parentPath, {
                            recursive: true
                        });
                    }
                    vfs.writeFileSyncInternal(entry.path, content, false);
                }
            }
            return vfs;
        }
        writeFileSyncInternal(path, data, emitEvent) {
            const normalized = this.normalizePath(path);
            const parentPath = this.getParentPath(normalized);
            const basename = this.getBasename(normalized);
            if (!basename) {
                throw new Error(`EISDIR: illegal operation on a directory, '${path}'`);
            }
            const parent = this.ensureDirectory(parentPath);
            const existed = parent.children.has(basename);
            const content = typeof data === "string" ? this.encoder.encode(data) : data;
            parent.children.set(basename, {
                type: "file",
                content,
                mtime: Date.now()
            });
            if (emitEvent) {
                this.notifyWatchers(normalized, existed ? "change" : "rename");
                this.emit("change", normalized, typeof data === "string" ? data : this.decoder.decode(data));
            }
        }
        normalizePath(path) {
            if (!path.startsWith("/")) {
                path = "/" + path;
            }
            const parts = path.split("/").filter(Boolean);
            const resolved = [];
            for (const part of parts){
                if (part === "..") {
                    resolved.pop();
                } else if (part !== ".") {
                    resolved.push(part);
                }
            }
            return "/" + resolved.join("/");
        }
        getPathSegments(path) {
            return this.normalizePath(path).split("/").filter(Boolean);
        }
        getParentPath(path) {
            const normalized = this.normalizePath(path);
            const lastSlash = normalized.lastIndexOf("/");
            return lastSlash <= 0 ? "/" : normalized.slice(0, lastSlash);
        }
        getBasename(path) {
            const normalized = this.normalizePath(path);
            const lastSlash = normalized.lastIndexOf("/");
            return normalized.slice(lastSlash + 1);
        }
        getNode(path) {
            const segments = this.getPathSegments(path);
            let current = this.root;
            for (const segment of segments){
                if (current.type !== "directory" || !current.children) {
                    return void 0;
                }
                const child = current.children.get(segment);
                if (!child) {
                    return void 0;
                }
                current = child;
            }
            return current;
        }
        ensureDirectory(path) {
            const segments = this.getPathSegments(path);
            let current = this.root;
            for (const segment of segments){
                if (!current.children) {
                    current.children = new Map();
                }
                let child = current.children.get(segment);
                if (!child) {
                    child = {
                        type: "directory",
                        children: new Map(),
                        mtime: Date.now()
                    };
                    current.children.set(segment, child);
                } else if (child.type !== "directory") {
                    throw new Error(`ENOTDIR: not a directory, '${path}'`);
                }
                current = child;
            }
            return current;
        }
        existsSync(path) {
            return this.getNode(path) !== void 0;
        }
        statSync(path) {
            const node = this.getNode(path);
            if (!node) {
                throw createNodeError("ENOENT", "stat", path);
            }
            const size = node.type === "file" ? node.content?.length || 0 : 0;
            const mtime = node.mtime;
            return {
                isFile: ()=>node.type === "file",
                isDirectory: ()=>node.type === "directory",
                isSymbolicLink: ()=>false,
                isBlockDevice: ()=>false,
                isCharacterDevice: ()=>false,
                isFIFO: ()=>false,
                isSocket: ()=>false,
                size,
                mode: node.type === "directory" ? 493 : 420,
                mtime: new Date(mtime),
                atime: new Date(mtime),
                ctime: new Date(mtime),
                birthtime: new Date(mtime),
                mtimeMs: mtime,
                atimeMs: mtime,
                ctimeMs: mtime,
                birthtimeMs: mtime,
                nlink: 1,
                uid: 1e3,
                gid: 1e3,
                dev: 0,
                ino: 0,
                rdev: 0,
                blksize: 4096,
                blocks: Math.ceil(size / 512)
            };
        }
        lstatSync(path) {
            return this.statSync(path);
        }
        readFileSync(path, encoding) {
            const node = this.getNode(path);
            if (!node) {
                throw createNodeError("ENOENT", "open", path);
            }
            if (node.type !== "file") {
                throw createNodeError("EISDIR", "read", path);
            }
            const content = node.content || new Uint8Array(0);
            if (encoding === "utf8" || encoding === "utf-8") {
                return this.decoder.decode(content);
            }
            return content;
        }
        writeFileSync(path, data) {
            this.writeFileSyncInternal(path, data, true);
        }
        mkdirSync(path, options) {
            const normalized = this.normalizePath(path);
            if (options?.recursive) {
                this.ensureDirectory(normalized);
                return;
            }
            const parentPath = this.getParentPath(normalized);
            const basename = this.getBasename(normalized);
            if (!basename) {
                return;
            }
            const parent = this.getNode(parentPath);
            if (!parent) {
                throw createNodeError("ENOENT", "mkdir", parentPath);
            }
            if (parent.type !== "directory") {
                throw createNodeError("ENOTDIR", "mkdir", parentPath);
            }
            if (parent.children.has(basename)) {
                throw createNodeError("EEXIST", "mkdir", path);
            }
            parent.children.set(basename, {
                type: "directory",
                children: new Map(),
                mtime: Date.now()
            });
        }
        readdirSync(path) {
            const node = this.getNode(path);
            if (!node) {
                throw createNodeError("ENOENT", "scandir", path);
            }
            if (node.type !== "directory") {
                throw createNodeError("ENOTDIR", "scandir", path);
            }
            return Array.from(node.children.keys());
        }
        unlinkSync(path) {
            const normalized = this.normalizePath(path);
            const parentPath = this.getParentPath(normalized);
            const basename = this.getBasename(normalized);
            const parent = this.getNode(parentPath);
            if (!parent || parent.type !== "directory") {
                throw createNodeError("ENOENT", "unlink", path);
            }
            const node = parent.children.get(basename);
            if (!node) {
                throw createNodeError("ENOENT", "unlink", path);
            }
            if (node.type !== "file") {
                throw createNodeError("EISDIR", "unlink", path);
            }
            parent.children.delete(basename);
            this.notifyWatchers(normalized, "rename");
            this.emit("delete", normalized);
        }
        rmdirSync(path) {
            const normalized = this.normalizePath(path);
            const parentPath = this.getParentPath(normalized);
            const basename = this.getBasename(normalized);
            if (!basename) {
                throw new Error(`EPERM: operation not permitted, '${path}'`);
            }
            const parent = this.getNode(parentPath);
            if (!parent || parent.type !== "directory") {
                throw createNodeError("ENOENT", "rmdir", path);
            }
            const node = parent.children.get(basename);
            if (!node) {
                throw createNodeError("ENOENT", "rmdir", path);
            }
            if (node.type !== "directory") {
                throw createNodeError("ENOTDIR", "rmdir", path);
            }
            if (node.children.size > 0) {
                throw createNodeError("ENOTEMPTY", "rmdir", path);
            }
            parent.children.delete(basename);
        }
        renameSync(oldPath, newPath) {
            const normalizedOld = this.normalizePath(oldPath);
            const normalizedNew = this.normalizePath(newPath);
            const oldParentPath = this.getParentPath(normalizedOld);
            const oldBasename = this.getBasename(normalizedOld);
            const newParentPath = this.getParentPath(normalizedNew);
            const newBasename = this.getBasename(normalizedNew);
            const oldParent = this.getNode(oldParentPath);
            if (!oldParent || oldParent.type !== "directory") {
                throw createNodeError("ENOENT", "rename", oldPath);
            }
            const node = oldParent.children.get(oldBasename);
            if (!node) {
                throw createNodeError("ENOENT", "rename", oldPath);
            }
            const newParent = this.ensureDirectory(newParentPath);
            oldParent.children.delete(oldBasename);
            newParent.children.set(newBasename, node);
            this.notifyWatchers(normalizedOld, "rename");
            this.notifyWatchers(normalizedNew, "rename");
        }
        readFile(path, optionsOrCallback, callback) {
            const actualCallback = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
            const options = typeof optionsOrCallback === "object" ? optionsOrCallback : void 0;
            try {
                const data = options?.encoding ? this.readFileSync(path, options.encoding) : this.readFileSync(path);
                if (actualCallback) {
                    setTimeout(()=>actualCallback(null, data), 0);
                }
            } catch (err) {
                if (actualCallback) {
                    setTimeout(()=>actualCallback(err), 0);
                }
            }
        }
        stat(path, callback) {
            try {
                const stats = this.statSync(path);
                setTimeout(()=>callback(null, stats), 0);
            } catch (err) {
                setTimeout(()=>callback(err), 0);
            }
        }
        lstat(path, callback) {
            this.stat(path, callback);
        }
        readdir(path, optionsOrCallback, callback) {
            const actualCallback = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
            try {
                const files = this.readdirSync(path);
                if (actualCallback) {
                    setTimeout(()=>actualCallback(null, files), 0);
                }
            } catch (err) {
                if (actualCallback) {
                    setTimeout(()=>actualCallback(err), 0);
                }
            }
        }
        realpath(path, callback) {
            try {
                const resolved = this.realpathSync(path);
                setTimeout(()=>callback(null, resolved), 0);
            } catch (err) {
                setTimeout(()=>callback(err), 0);
            }
        }
        realpathSync(path) {
            const normalized = this.normalizePath(path);
            if (!this.existsSync(normalized)) {
                throw createNodeError("ENOENT", "realpath", path);
            }
            return normalized;
        }
        watch(filename, optionsOrListener, listener) {
            const normalized = this.normalizePath(filename);
            let options = {};
            let actualListener;
            if (typeof optionsOrListener === "function") {
                actualListener = optionsOrListener;
            } else if (optionsOrListener) {
                options = optionsOrListener;
                actualListener = listener;
            } else {
                actualListener = listener;
            }
            const entry = {
                listener: actualListener || (()=>{}),
                recursive: options.recursive || false,
                closed: false
            };
            if (!this.watchers.has(normalized)) {
                this.watchers.set(normalized, new Set());
            }
            this.watchers.get(normalized).add(entry);
            const watcher = {
                close: ()=>{
                    entry.closed = true;
                    const watcherSet = this.watchers.get(normalized);
                    if (watcherSet) {
                        watcherSet.delete(entry);
                        if (watcherSet.size === 0) {
                            this.watchers.delete(normalized);
                        }
                    }
                },
                ref: ()=>watcher,
                unref: ()=>watcher
            };
            return watcher;
        }
        notifyWatchers(path, eventType) {
            const normalized = this.normalizePath(path);
            const basename = this.getBasename(normalized);
            const directWatchers = this.watchers.get(normalized);
            if (directWatchers) {
                for (const entry of directWatchers){
                    if (!entry.closed) {
                        try {
                            entry.listener(eventType, basename);
                        } catch (err) {
                            console.error("Error in file watcher:", err);
                        }
                    }
                }
            }
            let currentPath = this.getParentPath(normalized);
            let relativePath = basename;
            while(currentPath){
                const parentWatchers = this.watchers.get(currentPath);
                if (parentWatchers) {
                    for (const entry of parentWatchers){
                        if (!entry.closed) {
                            const isDirectChild = this.getParentPath(normalized) === currentPath;
                            if (entry.recursive || isDirectChild) {
                                try {
                                    entry.listener(eventType, relativePath);
                                } catch (err) {
                                    console.error("Error in file watcher:", err);
                                }
                            }
                        }
                    }
                }
                if (currentPath === "/") break;
                relativePath = this.getBasename(currentPath) + "/" + relativePath;
                currentPath = this.getParentPath(currentPath);
            }
        }
        accessSync(path, mode) {
            if (!this.existsSync(path)) {
                throw createNodeError("ENOENT", "access", path);
            }
        }
        access(path, modeOrCallback, callback) {
            const actualCallback = typeof modeOrCallback === "function" ? modeOrCallback : callback;
            try {
                this.accessSync(path);
                if (actualCallback) setTimeout(()=>actualCallback(null), 0);
            } catch (err) {
                if (actualCallback) setTimeout(()=>actualCallback(err), 0);
            }
        }
        copyFileSync(src, dest) {
            const content = this.readFileSync(src);
            this.writeFileSync(dest, content);
        }
        createReadStream(path) {
            const self = this;
            const listeners = {};
            const stream = {
                on (event, cb) {
                    if (!listeners[event]) listeners[event] = [];
                    listeners[event].push(cb);
                    return stream;
                },
                pipe (dest) {
                    return dest;
                }
            };
            setTimeout(()=>{
                try {
                    const data = self.readFileSync(path);
                    listeners["data"]?.forEach((cb)=>cb(data));
                    listeners["end"]?.forEach((cb)=>cb());
                } catch (err) {
                    listeners["error"]?.forEach((cb)=>cb(err));
                }
            }, 0);
            return stream;
        }
        createWriteStream(path) {
            const self = this;
            const chunks = [];
            const listeners = {};
            const encoder = new TextEncoder();
            return {
                write (data) {
                    const chunk = typeof data === "string" ? encoder.encode(data) : data;
                    chunks.push(chunk);
                    return true;
                },
                end (data) {
                    if (data) {
                        const chunk = typeof data === "string" ? encoder.encode(data) : data;
                        chunks.push(chunk);
                    }
                    const totalLength = chunks.reduce((sum, chunk)=>sum + chunk.length, 0);
                    const combined = new Uint8Array(totalLength);
                    let offset = 0;
                    for (const chunk of chunks){
                        combined.set(chunk, offset);
                        offset += chunk.length;
                    }
                    self.writeFileSync(path, combined);
                    listeners["finish"]?.forEach((cb)=>cb());
                    listeners["close"]?.forEach((cb)=>cb());
                },
                on (event, cb) {
                    if (!listeners[event]) listeners[event] = [];
                    listeners[event].push(cb);
                    return this;
                }
            };
        }
    }
    function simpleHash(str) {
        let hash = 0;
        for(let i = 0; i < str.length; i++){
            hash = (hash << 5) - hash + str.charCodeAt(i);
            hash |= 0;
        }
        return hash.toString(36);
    }
    const _decoder$2 = new TextDecoder();
    const _encoder$1 = new TextEncoder();
    class Dirent {
        name;
        _isDirectory;
        _isFile;
        constructor(name, isDirectory, isFile){
            this.name = name;
            this._isDirectory = isDirectory;
            this._isFile = isFile;
        }
        isDirectory() {
            return this._isDirectory;
        }
        isFile() {
            return this._isFile;
        }
        isBlockDevice() {
            return false;
        }
        isCharacterDevice() {
            return false;
        }
        isFIFO() {
            return false;
        }
        isSocket() {
            return false;
        }
        isSymbolicLink() {
            return false;
        }
    }
    function createBuffer(data) {
        const buffer = data;
        Object.defineProperty(buffer, "toString", {
            value: function(encoding) {
                if (encoding === "utf8" || encoding === "utf-8" || !encoding) {
                    return _decoder$2.decode(this);
                }
                if (encoding === "base64") {
                    return uint8ToBase64(this);
                }
                if (encoding === "hex") {
                    return uint8ToHex(this);
                }
                throw new Error(`Unsupported encoding: ${encoding}`);
            },
            writable: true,
            configurable: true
        });
        return buffer;
    }
    const pathRemaps = [
        {
            from: "/convex/",
            to: "/project/convex/"
        }
    ];
    function remapPath(path) {
        if (path.includes("vfs:")) {
            const cleanPath = path.replace(/vfs:/g, "");
            if (!remapPath.logged) remapPath.logged = new Set();
            if (!remapPath.logged.has(path)) {
                console.log(`[fs] Stripping vfs: prefix: ${path} -> ${cleanPath}`);
                remapPath.logged.add(path);
            }
            path = cleanPath;
        }
        for (const remap of pathRemaps){
            if (path === remap.from.slice(0, -1) || path.startsWith(remap.from)) {
                const remapped = remap.to + path.slice(remap.from.length);
                if (!remapPath.logged) remapPath.logged = new Set();
                if (!remapPath.logged.has(path)) {
                    console.log(`[fs] Remapping path: ${path} -> ${remapped}`);
                    remapPath.logged.add(path);
                }
                return remapped;
            }
        }
        return path;
    }
    remapPath.logged = new Set();
    function toPath(pathLike, getCwd) {
        let path;
        if (typeof pathLike === "string") {
            path = pathLike;
        } else if (pathLike instanceof URL) {
            if (pathLike.protocol === "file:") {
                path = decodeURIComponent(pathLike.pathname);
            } else {
                throw new Error(`Unsupported URL protocol: ${pathLike.protocol}`);
            }
        } else if (Buffer.isBuffer(pathLike)) {
            path = pathLike.toString("utf8");
        } else if (pathLike && typeof pathLike === "object" && "toString" in pathLike) {
            path = String(pathLike);
        } else {
            throw new TypeError(`Path must be a string, URL, or Buffer. Received: ${typeof pathLike}`);
        }
        if (!path.startsWith("/") && getCwd) {
            const cwd = getCwd();
            path = cwd.endsWith("/") ? cwd + path : cwd + "/" + path;
        }
        path = remapPath(path);
        return path;
    }
    const fdMap = new Map();
    let nextFd = 3;
    const callTracker = {
        statSync: new Map(),
        readdirSync: new Map(),
        lastReset: Date.now()
    };
    function trackCall(method, path) {
        const now = Date.now();
        if (now - callTracker.lastReset > 500) {
            callTracker.statSync.clear();
            callTracker.readdirSync.clear();
            callTracker.lastReset = now;
        }
        const map = callTracker[method];
        const count = (map.get(path) || 0) + 1;
        map.set(path, count);
        if (count === 10 && path.includes("_generated")) {
            console.warn(`[fs] ${method} called ${count}x on ${path}`);
            const err = new Error();
            console.log(`[fs] Stack at ${count} calls:`, err.stack?.split("\n").slice(1, 10).join("\n"));
        }
        if (count === 50) {
            console.warn(`[fs] Potential infinite loop: ${method} called ${count}+ times on ${path}`);
        }
    }
    function createFsShim(vfs, getCwd) {
        const resolvePath = (pathLike)=>toPath(pathLike, getCwd);
        const constants = {
            F_OK: 0,
            R_OK: 4,
            W_OK: 2,
            X_OK: 1
        };
        const promises = {
            readFile (pathLike, encodingOrOptions) {
                return new Promise((resolve, reject)=>{
                    try {
                        const path = resolvePath(pathLike);
                        let encoding;
                        if (typeof encodingOrOptions === "string") {
                            encoding = encodingOrOptions;
                        } else if (encodingOrOptions?.encoding) {
                            encoding = encodingOrOptions.encoding;
                        }
                        if (encoding === "utf8" || encoding === "utf-8") {
                            resolve(vfs.readFileSync(path, "utf8"));
                        } else {
                            resolve(createBuffer(vfs.readFileSync(path)));
                        }
                    } catch (err) {
                        reject(err);
                    }
                });
            },
            writeFile (pathLike, data) {
                return new Promise((resolve, reject)=>{
                    try {
                        vfs.writeFileSync(resolvePath(pathLike), data);
                        resolve();
                    } catch (err) {
                        reject(err);
                    }
                });
            },
            stat (pathLike) {
                return new Promise((resolve, reject)=>{
                    try {
                        const path = typeof pathLike === "string" ? pathLike : resolvePath(pathLike);
                        resolve(vfs.statSync(path));
                    } catch (err) {
                        reject(err);
                    }
                });
            },
            lstat (pathLike) {
                return this.stat(resolvePath(pathLike));
            },
            readdir (pathLike) {
                return new Promise((resolve, reject)=>{
                    try {
                        resolve(vfs.readdirSync(resolvePath(pathLike)));
                    } catch (err) {
                        reject(err);
                    }
                });
            },
            mkdir (pathLike, options) {
                return new Promise((resolve, reject)=>{
                    try {
                        vfs.mkdirSync(resolvePath(pathLike), options);
                        resolve();
                    } catch (err) {
                        reject(err);
                    }
                });
            },
            unlink (pathLike) {
                return new Promise((resolve, reject)=>{
                    try {
                        vfs.unlinkSync(resolvePath(pathLike));
                        resolve();
                    } catch (err) {
                        reject(err);
                    }
                });
            },
            rmdir (path) {
                return new Promise((resolve, reject)=>{
                    try {
                        vfs.rmdirSync(path);
                        resolve();
                    } catch (err) {
                        reject(err);
                    }
                });
            },
            rename (oldPath, newPath) {
                return new Promise((resolve, reject)=>{
                    try {
                        vfs.renameSync(oldPath, newPath);
                        resolve();
                    } catch (err) {
                        reject(err);
                    }
                });
            },
            access (path, mode) {
                return new Promise((resolve, reject)=>{
                    try {
                        vfs.accessSync(path, mode);
                        resolve();
                    } catch (err) {
                        reject(err);
                    }
                });
            },
            realpath (path) {
                return new Promise((resolve, reject)=>{
                    try {
                        resolve(vfs.realpathSync(path));
                    } catch (err) {
                        reject(err);
                    }
                });
            },
            copyFile (src, dest) {
                return new Promise((resolve, reject)=>{
                    try {
                        vfs.copyFileSync(src, dest);
                        resolve();
                    } catch (err) {
                        reject(err);
                    }
                });
            }
        };
        return {
            readFileSync (pathLike, encodingOrOptions) {
                const path = resolvePath(pathLike);
                let encoding;
                if (typeof encodingOrOptions === "string") {
                    encoding = encodingOrOptions;
                } else if (encodingOrOptions?.encoding) {
                    encoding = encodingOrOptions.encoding;
                }
                if (encoding === "utf8" || encoding === "utf-8") {
                    return vfs.readFileSync(path, "utf8");
                }
                const data = vfs.readFileSync(path);
                return createBuffer(data);
            },
            writeFileSync (pathLike, data) {
                if (typeof pathLike === "number") {
                    const fd = pathLike;
                    const entry = fdMap.get(fd);
                    if (!entry) {
                        const err = new Error(`EBADF: bad file descriptor, write`);
                        err.code = "EBADF";
                        err.errno = -9;
                        throw err;
                    }
                    const bytes = typeof data === "string" ? _encoder$1.encode(data) : data;
                    entry.content = new Uint8Array(bytes);
                    entry.position = bytes.length;
                    return;
                }
                const path = resolvePath(pathLike);
                if (path.includes("convex") || path.includes("_generated")) {
                    console.log("[fs] writeFileSync:", path);
                }
                vfs.writeFileSync(path, data);
            },
            existsSync (pathLike) {
                return vfs.existsSync(resolvePath(pathLike));
            },
            mkdirSync (pathLike, options) {
                const path = resolvePath(pathLike);
                if (path.includes("convex") || path.includes("_generated")) {
                    console.log("[fs] mkdirSync:", path, options);
                }
                vfs.mkdirSync(path, options);
            },
            readdirSync (pathLike, options) {
                const path = resolvePath(pathLike);
                trackCall("readdirSync", path);
                const entries = vfs.readdirSync(path);
                const opts = typeof options === "string" ? {} : options;
                if (opts?.withFileTypes) {
                    const dirents = entries.map((name)=>{
                        const entryPath = path.endsWith("/") ? path + name : path + "/" + name;
                        let isDir = false;
                        let isFile = false;
                        try {
                            const stat = vfs.statSync(entryPath);
                            isDir = stat.isDirectory();
                            isFile = stat.isFile();
                        } catch  {
                            isFile = true;
                        }
                        return new Dirent(name, isDir, isFile);
                    });
                    if (path.includes("_generated")) {
                        console.log(`[fs] readdirSync(${path}, withFileTypes) -> [${dirents.map((d)=>d.name).join(", ")}]`);
                    }
                    return dirents;
                }
                if (path.includes("_generated")) {
                    console.log(`[fs] readdirSync(${path}) -> [${entries.join(", ")}]`);
                }
                return entries;
            },
            statSync (pathLike) {
                const origPath = typeof pathLike === "string" ? pathLike : String(pathLike);
                const path = resolvePath(pathLike);
                trackCall("statSync", path);
                const result = vfs.statSync(path);
                if (path.includes("_generated")) {
                    const wasRemapped = origPath !== path;
                    console.log(`[fs] statSync(${origPath}${wasRemapped ? " -> " + path : ""}) -> isDir: ${result.isDirectory()}`);
                }
                return result;
            },
            lstatSync (pathLike) {
                return vfs.lstatSync(resolvePath(pathLike));
            },
            fstatSync (fd) {
                const entry = fdMap.get(fd);
                if (!entry) {
                    const err = new Error(`EBADF: bad file descriptor, fstat`);
                    err.code = "EBADF";
                    err.errno = -9;
                    throw err;
                }
                return vfs.statSync(entry.path);
            },
            openSync (pathLike, flags, _mode) {
                const path = resolvePath(pathLike);
                const flagStr = typeof flags === "number" ? "r" : flags;
                const exists = vfs.existsSync(path);
                const isWriteMode = flagStr.includes("w") || flagStr.includes("a");
                const isReadMode = flagStr.includes("r") && !flagStr.includes("+");
                if (!exists && isReadMode) {
                    const err = new Error(`ENOENT: no such file or directory, open '${path}'`);
                    err.code = "ENOENT";
                    err.errno = -2;
                    err.path = path;
                    throw err;
                }
                let content;
                if (exists && !flagStr.includes("w")) {
                    content = vfs.readFileSync(path);
                } else {
                    content = new Uint8Array(0);
                    if (isWriteMode) {
                        const parentPath = path.substring(0, path.lastIndexOf("/")) || "/";
                        if (!vfs.existsSync(parentPath)) {
                            vfs.mkdirSync(parentPath, {
                                recursive: true
                            });
                        }
                    }
                }
                const fd = nextFd++;
                fdMap.set(fd, {
                    path,
                    position: flagStr.includes("a") ? content.length : 0,
                    flags: flagStr,
                    content: new Uint8Array(content)
                });
                return fd;
            },
            closeSync (fd) {
                const entry = fdMap.get(fd);
                if (!entry) {
                    return;
                }
                if (entry.flags.includes("w") || entry.flags.includes("a") || entry.flags.includes("+")) {
                    vfs.writeFileSync(entry.path, entry.content);
                }
                fdMap.delete(fd);
            },
            readSync (fd, buffer, offset, length, position) {
                const entry = fdMap.get(fd);
                if (!entry) {
                    const err = new Error(`EBADF: bad file descriptor, read`);
                    err.code = "EBADF";
                    err.errno = -9;
                    throw err;
                }
                const readPos = position !== null ? position : entry.position;
                const bytesToRead = Math.min(length, entry.content.length - readPos);
                if (bytesToRead <= 0) {
                    return 0;
                }
                for(let i = 0; i < bytesToRead; i++){
                    buffer[offset + i] = entry.content[readPos + i];
                }
                if (position === null) {
                    entry.position += bytesToRead;
                }
                return bytesToRead;
            },
            writeSync (fd, buffer, offset, length, position) {
                const entry = fdMap.get(fd);
                if (!entry) {
                    const err = new Error(`EBADF: bad file descriptor, write`);
                    err.code = "EBADF";
                    err.errno = -9;
                    throw err;
                }
                let data;
                if (typeof buffer === "string") {
                    data = _encoder$1.encode(buffer);
                    offset = 0;
                    length = data.length;
                } else {
                    data = buffer;
                    offset = offset ?? 0;
                    length = length ?? data.length - offset;
                }
                const writePos = position !== null && position !== void 0 ? position : entry.position;
                const endPos = writePos + length;
                if (endPos > entry.content.length) {
                    const newContent = new Uint8Array(endPos);
                    newContent.set(entry.content);
                    entry.content = newContent;
                }
                for(let i = 0; i < length; i++){
                    entry.content[writePos + i] = data[offset + i];
                }
                if (position === null || position === void 0) {
                    entry.position = endPos;
                }
                return length;
            },
            ftruncateSync (fd, len = 0) {
                const entry = fdMap.get(fd);
                if (!entry) {
                    const err = new Error(`EBADF: bad file descriptor, ftruncate`);
                    err.code = "EBADF";
                    err.errno = -9;
                    throw err;
                }
                if (len < entry.content.length) {
                    entry.content = entry.content.slice(0, len);
                } else if (len > entry.content.length) {
                    const newContent = new Uint8Array(len);
                    newContent.set(entry.content);
                    entry.content = newContent;
                }
            },
            fsyncSync (_fd) {},
            fdatasyncSync (_fd) {},
            mkdtempSync (prefix) {
                const suffix = Math.random().toString(36).slice(2, 8);
                const tempDir = `${prefix}${suffix}`;
                const resolvedPath = resolvePath(tempDir);
                vfs.mkdirSync(resolvedPath, {
                    recursive: true
                });
                return resolvedPath;
            },
            rmSync (pathLike, options) {
                const path = resolvePath(pathLike);
                if (!vfs.existsSync(path)) {
                    if (options?.force) return;
                    throw createNodeError("ENOENT", "rm", path);
                }
                const stats = vfs.statSync(path);
                if (stats.isDirectory()) {
                    if (options?.recursive) {
                        const entries = vfs.readdirSync(path);
                        for (const entry of entries){
                            const entryPath = path.endsWith("/") ? path + entry : path + "/" + entry;
                            this.rmSync(entryPath, options);
                        }
                        vfs.rmdirSync(path);
                    } else {
                        throw createNodeError("EISDIR", "rm", path);
                    }
                } else {
                    vfs.unlinkSync(path);
                }
            },
            unlinkSync (pathLike) {
                const path = resolvePath(pathLike);
                if (path.includes("_generated")) {
                    console.log(`[fs] unlinkSync(${path})`);
                }
                vfs.unlinkSync(path);
            },
            rmdirSync (pathLike) {
                vfs.rmdirSync(resolvePath(pathLike));
            },
            renameSync (oldPathLike, newPathLike) {
                vfs.renameSync(resolvePath(oldPathLike), resolvePath(newPathLike));
            },
            realpathSync (pathLike) {
                return vfs.realpathSync(resolvePath(pathLike));
            },
            accessSync (pathLike, _mode) {
                vfs.accessSync(resolvePath(pathLike));
            },
            copyFileSync (srcLike, destLike) {
                const src = resolvePath(srcLike);
                const dest = resolvePath(destLike);
                const data = vfs.readFileSync(src);
                vfs.writeFileSync(dest, data);
            },
            watch (pathLike, optionsOrListener, listener) {
                return vfs.watch(resolvePath(pathLike), optionsOrListener, listener);
            },
            readFile (pathLike, optionsOrCallback, callback) {
                const path = resolvePath(pathLike);
                vfs.readFile(path, optionsOrCallback, callback);
            },
            stat (pathLike, callback) {
                vfs.stat(resolvePath(pathLike), callback);
            },
            lstat (pathLike, callback) {
                vfs.lstat(resolvePath(pathLike), callback);
            },
            readdir (pathLike, optionsOrCallback, callback) {
                vfs.readdir(resolvePath(pathLike), optionsOrCallback, callback);
            },
            realpath (pathLike, callback) {
                vfs.realpath(resolvePath(pathLike), callback);
            },
            access (pathLike, modeOrCallback, callback) {
                vfs.access(resolvePath(pathLike), modeOrCallback, callback);
            },
            createReadStream (pathLike) {
                return vfs.createReadStream(resolvePath(pathLike));
            },
            createWriteStream (pathLike) {
                return vfs.createWriteStream(resolvePath(pathLike));
            },
            promises,
            constants
        };
    }
    const sep$1 = "/";
    const delimiter = ":";
    function normalize(path) {
        if (!path) return ".";
        const isAbsolute2 = path.startsWith("/");
        const parts = path.split("/").filter(Boolean);
        const resolved = [];
        for (const part of parts){
            if (part === "..") {
                if (resolved.length > 0 && resolved[resolved.length - 1] !== "..") {
                    resolved.pop();
                } else if (!isAbsolute2) {
                    resolved.push("..");
                }
            } else if (part !== ".") {
                resolved.push(part);
            }
        }
        let result = resolved.join("/");
        if (isAbsolute2) {
            result = "/" + result;
        }
        return result || ".";
    }
    function join$1(...paths) {
        if (paths.length === 0) return ".";
        return normalize(paths.filter(Boolean).join("/"));
    }
    function resolve$2(...paths) {
        let resolvedPath = "";
        for(let i = paths.length - 1; i >= 0 && !resolvedPath.startsWith("/"); i--){
            const path = paths[i];
            if (!path) continue;
            resolvedPath = path + (resolvedPath ? "/" + resolvedPath : "");
        }
        if (!resolvedPath.startsWith("/")) {
            const cwd = typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/";
            resolvedPath = cwd + (resolvedPath ? "/" + resolvedPath : "");
        }
        return normalize(resolvedPath);
    }
    function isAbsolute(path) {
        return path.startsWith("/");
    }
    function dirname(path) {
        if (!path) return ".";
        const normalized = normalize(path);
        const lastSlash = normalized.lastIndexOf("/");
        if (lastSlash === -1) return ".";
        if (lastSlash === 0) return "/";
        return normalized.slice(0, lastSlash);
    }
    function basename(path, ext) {
        if (!path) return "";
        const normalized = normalize(path);
        let base = normalized.slice(normalized.lastIndexOf("/") + 1);
        if (ext && base.endsWith(ext)) {
            base = base.slice(0, -ext.length);
        }
        return base;
    }
    function extname(path) {
        const base = basename(path);
        const dotIndex = base.lastIndexOf(".");
        if (dotIndex <= 0) return "";
        return base.slice(dotIndex);
    }
    function relative(from, to) {
        from = resolve$2(from);
        to = resolve$2(to);
        if (from === to) return "";
        const fromParts = from.split("/").filter(Boolean);
        const toParts = to.split("/").filter(Boolean);
        let commonLength = 0;
        for(let i = 0; i < Math.min(fromParts.length, toParts.length); i++){
            if (fromParts[i] !== toParts[i]) break;
            commonLength++;
        }
        const upCount = fromParts.length - commonLength;
        const remainingPath = toParts.slice(commonLength);
        const result = [
            ...Array(upCount).fill(".."),
            ...remainingPath
        ];
        return result.join("/") || ".";
    }
    function parse$2(path) {
        const normalized = normalize(path);
        const isAbs = isAbsolute(normalized);
        const dir = dirname(normalized);
        const base = basename(normalized);
        const ext = extname(normalized);
        const name = base.slice(0, base.length - ext.length);
        return {
            root: isAbs ? "/" : "",
            dir,
            base,
            ext,
            name
        };
    }
    function format$2(pathObject) {
        const dir = pathObject.dir || pathObject.root || "";
        const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
        if (!dir) return base;
        if (dir === pathObject.root) return dir + base;
        return dir + "/" + base;
    }
    const posix = {
        sep: sep$1,
        delimiter,
        normalize,
        join: join$1,
        resolve: resolve$2,
        isAbsolute,
        dirname,
        basename,
        extname,
        relative,
        parse: parse$2,
        format: format$2
    };
    var path$1 = {
        sep: sep$1,
        delimiter,
        normalize,
        join: join$1,
        resolve: resolve$2,
        isAbsolute,
        dirname,
        basename,
        extname,
        relative,
        parse: parse$2,
        format: format$2,
        posix
    };
    var pathShim = Object.freeze({
        __proto__: null,
        basename: basename,
        default: path$1,
        delimiter: delimiter,
        dirname: dirname,
        extname: extname,
        format: format$2,
        isAbsolute: isAbsolute,
        join: join$1,
        normalize: normalize,
        parse: parse$2,
        posix: posix,
        relative: relative,
        resolve: resolve$2,
        sep: sep$1
    });
    const kEvents = Symbol("events");
    const kMaxListeners = Symbol("maxListeners");
    class EventEmitter {
        [kEvents];
        [kMaxListeners];
        _getEvents() {
            const self = this;
            if (!self[kEvents]) {
                self[kEvents] = new Map();
            }
            return self[kEvents];
        }
        on(event, listener) {
            return this.addListener(event, listener);
        }
        addListener(event, listener) {
            const events2 = this._getEvents();
            if (!events2.has(event)) {
                events2.set(event, []);
            }
            events2.get(event).push(listener);
            return this;
        }
        once(event, listener) {
            const onceWrapper = (...args)=>{
                this.removeListener(event, onceWrapper);
                listener.apply(this, args);
            };
            return this.addListener(event, onceWrapper);
        }
        off(event, listener) {
            return this.removeListener(event, listener);
        }
        removeListener(event, listener) {
            const events2 = this._getEvents();
            const listeners = events2.get(event);
            if (listeners) {
                const index = listeners.indexOf(listener);
                if (index !== -1) {
                    listeners.splice(index, 1);
                }
            }
            return this;
        }
        removeAllListeners(event) {
            const events2 = this._getEvents();
            if (event) {
                events2.delete(event);
            } else {
                events2.clear();
            }
            return this;
        }
        emit(event, ...args) {
            const events2 = this._getEvents();
            const listeners = events2.get(event);
            if (!listeners || listeners.length === 0) {
                if (event === "error") {
                    const err = args[0];
                    if (err instanceof Error) {
                        throw err;
                    }
                    throw new Error("Unhandled error event");
                }
                return false;
            }
            for (const listener of [
                ...listeners
            ]){
                try {
                    listener.apply(this, args);
                } catch (err) {
                    console.error("Error in event listener:", err);
                }
            }
            return true;
        }
        listeners(event) {
            const events2 = this._getEvents();
            return [
                ...events2.get(event) || []
            ];
        }
        rawListeners(event) {
            return this.listeners(event);
        }
        listenerCount(event) {
            const events2 = this._getEvents();
            return events2.get(event)?.length || 0;
        }
        eventNames() {
            const events2 = this._getEvents();
            return [
                ...events2.keys()
            ];
        }
        setMaxListeners(n) {
            this[kMaxListeners] = n;
            return this;
        }
        getMaxListeners() {
            return this[kMaxListeners] || 10;
        }
        prependListener(event, listener) {
            const events2 = this._getEvents();
            if (!events2.has(event)) {
                events2.set(event, []);
            }
            events2.get(event).unshift(listener);
            return this;
        }
        prependOnceListener(event, listener) {
            const onceWrapper = (...args)=>{
                this.removeListener(event, onceWrapper);
                listener.apply(this, args);
            };
            return this.prependListener(event, onceWrapper);
        }
        static listenerCount(emitter, event) {
            return emitter.listenerCount(event);
        }
    }
    const events = EventEmitter;
    events.EventEmitter = EventEmitter;
    events.once = async (emitter, event)=>{
        return new Promise((resolve, reject)=>{
            const onEvent = (...args)=>{
                emitter.removeListener("error", onError);
                resolve(args);
            };
            const onError = (...args)=>{
                emitter.removeListener(event, onEvent);
                reject(args[0]);
            };
            emitter.once(event, onEvent);
            emitter.once("error", onError);
        });
    };
    events.on = (emitter, event)=>{
        const iterator = {
            async next () {
                return new Promise((resolve)=>{
                    emitter.once(event, (...args)=>resolve({
                            value: args,
                            done: false
                        }));
                });
            },
            [Symbol.asyncIterator] () {
                return this;
            }
        };
        return iterator;
    };
    events.getEventListeners = (emitter, event)=>emitter.listeners(event);
    events.listenerCount = (emitter, event)=>emitter.listenerCount(event);
    function createProcessStream(isWritable, writeImpl) {
        const emitter = new EventEmitter();
        const stream = {
            isTTY: false,
            on (event, listener) {
                emitter.on(event, listener);
                return stream;
            },
            once (event, listener) {
                emitter.once(event, listener);
                return stream;
            },
            off (event, listener) {
                emitter.off(event, listener);
                return stream;
            },
            emit (event, ...args) {
                return emitter.emit(event, ...args);
            },
            addListener (event, listener) {
                emitter.addListener(event, listener);
                return stream;
            },
            removeListener (event, listener) {
                emitter.removeListener(event, listener);
                return stream;
            },
            removeAllListeners (event) {
                emitter.removeAllListeners(event);
                return stream;
            },
            setMaxListeners (n) {
                emitter.setMaxListeners(n);
                return stream;
            },
            pause () {
                return stream;
            },
            resume () {
                return stream;
            },
            setEncoding (_encoding) {
                return stream;
            },
            write (_data, _encoding, callback) {
                if (callback) queueMicrotask(callback);
                return true;
            },
            end (_data, callback) {
                if (callback) queueMicrotask(callback);
            },
            read () {
                return null;
            },
            setRawMode (_mode) {
                return stream;
            }
        };
        if (isWritable && writeImpl) {
            stream.write = (data, _encoding, callback)=>{
                const result = writeImpl(typeof data === "string" ? data : data.toString());
                if (callback) queueMicrotask(callback);
                return result;
            };
        }
        return stream;
    }
    function createProcess(options) {
        let currentDir = options?.cwd || "/";
        const env = {
            NODE_ENV: "development",
            PATH: "/usr/local/bin:/usr/bin:/bin",
            HOME: "/",
            ...options?.env
        };
        const emitter = new EventEmitter();
        const startTime = Date.now();
        const proc = {
            env,
            cwd () {
                if (!proc._cwdCallCount) proc._cwdCallCount = 0;
                proc._cwdCallCount++;
                if (proc._cwdCallCount <= 5 || proc._cwdCallCount % 100 === 0) {
                    console.log(`[process] cwd() called (${proc._cwdCallCount}x), returning:`, currentDir);
                }
                return currentDir;
            },
            chdir (directory) {
                console.log("[process] chdir called:", directory, "from:", currentDir);
                if (!directory.startsWith("/")) {
                    directory = currentDir + "/" + directory;
                }
                currentDir = directory;
                console.log("[process] chdir result:", currentDir);
            },
            platform: "linux",
            version: "v20.0.0",
            versions: {
                node: "20.0.0",
                v8: "11.3.244.8",
                uv: "1.44.2"
            },
            argv: [
                "node",
                "/index.js"
            ],
            argv0: "node",
            execPath: "/usr/local/bin/node",
            execArgv: [],
            pid: 1,
            ppid: 0,
            exit (code = 0) {
                emitter.emit("exit", code);
                if (options?.onExit) {
                    options.onExit(code);
                }
                throw new Error(`Process exited with code ${code}`);
            },
            nextTick (callback, ...args) {
                queueMicrotask(()=>callback(...args));
            },
            stdout: createProcessStream(true, (data)=>{
                console.log(data);
                return true;
            }),
            stderr: createProcessStream(true, (data)=>{
                console.error(data);
                return true;
            }),
            stdin: createProcessStream(false),
            hrtime: Object.assign(function hrtime(time) {
                const now = performance.now();
                const seconds = Math.floor(now / 1e3);
                const nanoseconds = Math.floor(now % 1e3 * 1e6);
                if (time) {
                    const diffSeconds = seconds - time[0];
                    const diffNanos = nanoseconds - time[1];
                    return [
                        diffSeconds,
                        diffNanos
                    ];
                }
                return [
                    seconds,
                    nanoseconds
                ];
            }, {
                bigint: ()=>BigInt(Math.floor(performance.now() * 1e6))
            }),
            memoryUsage () {
                return {
                    rss: 50 * 1024 * 1024,
                    heapTotal: 30 * 1024 * 1024,
                    heapUsed: 20 * 1024 * 1024,
                    external: 1 * 1024 * 1024,
                    arrayBuffers: 0
                };
            },
            uptime () {
                return (Date.now() - startTime) / 1e3;
            },
            cpuUsage () {
                return {
                    user: 0,
                    system: 0
                };
            },
            on (event, listener) {
                emitter.on(event, listener);
                return proc;
            },
            once (event, listener) {
                emitter.once(event, listener);
                return proc;
            },
            off (event, listener) {
                emitter.off(event, listener);
                return proc;
            },
            emit (event, ...args) {
                return emitter.emit(event, ...args);
            },
            addListener (event, listener) {
                emitter.addListener(event, listener);
                return proc;
            },
            removeListener (event, listener) {
                emitter.removeListener(event, listener);
                return proc;
            },
            removeAllListeners (event) {
                emitter.removeAllListeners(event);
                return proc;
            },
            listeners (event) {
                return emitter.listeners(event);
            },
            listenerCount (event) {
                return emitter.listenerCount(event);
            },
            prependListener (event, listener) {
                emitter.prependListener(event, listener);
                return proc;
            },
            prependOnceListener (event, listener) {
                emitter.prependOnceListener(event, listener);
                return proc;
            },
            eventNames () {
                return emitter.eventNames();
            },
            setMaxListeners (n) {
                emitter.setMaxListeners(n);
                return proc;
            },
            getMaxListeners () {
                return emitter.getMaxListeners();
            }
        };
        return proc;
    }
    createProcess();
    const _encoder = new TextEncoder();
    const _decoder$1 = new TextDecoder("utf-8");
    class Readable extends EventEmitter {
        _buffer = [];
        _ended = false;
        _flowing = false;
        _endEmitted = false;
        readable = true;
        readableEnded = false;
        readableFlowing = null;
        constructor(){
            super();
        }
        _addListenerInternal(event, listener) {
            EventEmitter.prototype.addListener.call(this, event, listener);
            return this;
        }
        on(event, listener) {
            this._addListenerInternal(event, listener);
            if (event === "data" && !this._flowing) {
                queueMicrotask(()=>{
                    if (this.listenerCount("data") > 0 && !this._flowing) {
                        this.resume();
                    }
                });
            }
            return this;
        }
        addListener(event, listener) {
            return this.on(event, listener);
        }
        push(chunk) {
            if (chunk === null) {
                this._ended = true;
                this.readableEnded = true;
                this.readable = false;
                if (this._flowing && this._buffer.length === 0 && !this._endEmitted) {
                    this._endEmitted = true;
                    queueMicrotask(()=>this.emit("end"));
                }
                return false;
            }
            const buffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
            this._buffer.push(buffer);
            if (this._flowing) {
                queueMicrotask(()=>{
                    this._flushBuffer();
                });
            }
            return true;
        }
        _flushBuffer() {
            while(this._buffer.length > 0 && this._flowing){
                const data = this._buffer.shift();
                this.emit("data", data);
            }
            if (this._ended && this._buffer.length === 0 && !this._endEmitted) {
                this._endEmitted = true;
                this.emit("end");
            }
        }
        read(size) {
            if (this._buffer.length === 0) {
                return null;
            }
            if (size === void 0) {
                const result = Buffer.concat(this._buffer);
                this._buffer = [];
                return result;
            }
            const chunks = [];
            let remaining = size;
            while(remaining > 0 && this._buffer.length > 0){
                const chunk = this._buffer[0];
                if (chunk.length <= remaining) {
                    chunks.push(this._buffer.shift());
                    remaining -= chunk.length;
                } else {
                    chunks.push(chunk.slice(0, remaining));
                    this._buffer[0] = chunk.slice(remaining);
                    remaining = 0;
                }
            }
            return chunks.length > 0 ? Buffer.concat(chunks) : null;
        }
        resume() {
            this._flowing = true;
            this.readableFlowing = true;
            this._flushBuffer();
            return this;
        }
        pause() {
            this._flowing = false;
            this.readableFlowing = false;
            return this;
        }
        pipe(destination) {
            this.on("data", (chunk)=>{
                destination.write(chunk);
            });
            this.on("end", ()=>{
                destination.end();
            });
            this.resume();
            return destination;
        }
        unpipe(destination) {
            this.removeAllListeners("data");
            this.removeAllListeners("end");
            return this;
        }
        setEncoding(encoding) {
            return this;
        }
        destroy(error) {
            this._buffer = [];
            this._ended = true;
            this.readable = false;
            if (error) {
                this.emit("error", error);
            }
            this.emit("close");
            return this;
        }
        static from(iterable, options) {
            const readable = new Readable();
            (async ()=>{
                try {
                    for await (const chunk of iterable){
                        if (chunk !== null && chunk !== void 0) {
                            const data = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
                            readable.push(data);
                        }
                    }
                    readable.push(null);
                } catch (err) {
                    readable.destroy(err);
                }
            })();
            return readable;
        }
    }
    class Writable extends EventEmitter {
        _chunks = [];
        _ended = false;
        writable = true;
        writableEnded = false;
        writableFinished = false;
        constructor(){
            super();
        }
        write(chunk, encodingOrCallback, callback) {
            if (this._ended) {
                const error = new Error("write after end");
                if (typeof encodingOrCallback === "function") {
                    encodingOrCallback(error);
                } else if (callback) {
                    callback(error);
                }
                return false;
            }
            const buffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
            this._chunks.push(buffer);
            const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
            if (cb) {
                queueMicrotask(()=>cb(null));
            }
            return true;
        }
        end(chunkOrCallback, encodingOrCallback, callback) {
            if (typeof chunkOrCallback === "function") {
                callback = chunkOrCallback;
            } else if (chunkOrCallback !== void 0) {
                this.write(chunkOrCallback);
            }
            if (typeof encodingOrCallback === "function") {
                callback = encodingOrCallback;
            }
            this._ended = true;
            this.writable = false;
            this.writableEnded = true;
            queueMicrotask(()=>{
                this.writableFinished = true;
                this.emit("finish");
                if (callback) {
                    callback();
                }
            });
            return this;
        }
        getBuffer() {
            return Buffer.concat(this._chunks);
        }
        getBufferAsString(encoding = "utf8") {
            return this.getBuffer().toString(encoding);
        }
        destroy(error) {
            this._chunks = [];
            this._ended = true;
            this.writable = false;
            if (error) {
                this.emit("error", error);
            }
            this.emit("close");
            return this;
        }
        cork() {}
        uncork() {}
        setDefaultEncoding(encoding) {
            return this;
        }
    }
    class Duplex extends Readable {
        _writeChunks = [];
        _writeEnded = false;
        writable = true;
        writableEnded = false;
        writableFinished = false;
        write(chunk, encodingOrCallback, callback) {
            if (this._writeEnded) {
                return false;
            }
            const buffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
            this._writeChunks.push(buffer);
            const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
            if (cb) {
                queueMicrotask(()=>cb(null));
            }
            return true;
        }
        end(chunkOrCallback, encodingOrCallback, callback) {
            if (typeof chunkOrCallback === "function") {
                callback = chunkOrCallback;
            } else if (chunkOrCallback !== void 0) {
                this.write(chunkOrCallback);
            }
            this._writeEnded = true;
            this.writable = false;
            this.writableEnded = true;
            queueMicrotask(()=>{
                this.writableFinished = true;
                this.emit("finish");
                if (callback) {
                    callback();
                }
            });
            return this;
        }
    }
    class PassThrough extends Duplex {
        constructor(){
            super();
        }
        write(chunk, encodingOrCallback, callback) {
            const buffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
            this.push(buffer);
            const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
            if (cb) {
                queueMicrotask(()=>cb(null));
            }
            return true;
        }
    }
    class Transform extends Duplex {
        constructor(){
            super();
        }
        _transform(chunk, encoding, callback) {
            callback(null, chunk);
        }
        _flush(callback) {
            callback(null);
        }
        write(chunk, encodingOrCallback, callback) {
            const buffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
            const encoding = typeof encodingOrCallback === "string" ? encodingOrCallback : "utf8";
            const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
            this._transform(buffer, encoding, (error, data)=>{
                if (error) {
                    if (cb) cb(error);
                    return;
                }
                if (data) {
                    this.push(data);
                }
                if (cb) cb(null);
            });
            return true;
        }
        end(chunkOrCallback, encodingOrCallback, callback) {
            this._flush((error, data)=>{
                if (data) {
                    this.push(data);
                }
            });
            return super.end(chunkOrCallback, encodingOrCallback, callback);
        }
    }
    class Stream extends EventEmitter {
        pipe(destination) {
            return destination;
        }
    }
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    Stream.from = Readable.from;
    const promises$2 = {
        pipeline: async (...streams)=>{
            return Promise.resolve();
        },
        finished: async (stream)=>{
            return Promise.resolve();
        }
    };
    function pipeline(...args) {
        const callback = args[args.length - 1];
        if (typeof callback === "function") {
            setTimeout(()=>callback(), 0);
        }
        return args[args.length - 2] || args[0];
    }
    function finished(stream, callback) {
        setTimeout(()=>callback(), 0);
        return ()=>{};
    }
    class BufferPolyfill extends Uint8Array {
        static BYTES_PER_ELEMENT = 1;
        static from(value, encodingOrMapfn, thisArg) {
            if (typeof encodingOrMapfn === "function") {
                const arrayLike = value;
                const mapped = Array.from(arrayLike, encodingOrMapfn, thisArg);
                return new BufferPolyfill(mapped);
            }
            const data = value;
            const encoding = encodingOrMapfn;
            if (Array.isArray(data)) {
                return new BufferPolyfill(data);
            }
            if (typeof data === "string") {
                const enc = (encoding || "utf8").toLowerCase();
                if (enc === "base64" || enc === "base64url") {
                    let base64 = data;
                    if (enc === "base64url") {
                        base64 = data.replace(/-/g, "+").replace(/_/g, "/");
                        while(base64.length % 4 !== 0){
                            base64 += "=";
                        }
                    }
                    const binary = atob(base64);
                    const bytes2 = new Uint8Array(binary.length);
                    for(let i = 0; i < binary.length; i++){
                        bytes2[i] = binary.charCodeAt(i);
                    }
                    return new BufferPolyfill(bytes2);
                }
                if (enc === "hex") {
                    const bytes2 = new Uint8Array(data.length / 2);
                    for(let i = 0; i < data.length; i += 2){
                        bytes2[i / 2] = parseInt(data.slice(i, i + 2), 16);
                    }
                    return new BufferPolyfill(bytes2);
                }
                if (enc === "latin1" || enc === "binary") {
                    const bytes2 = new Uint8Array(data.length);
                    for(let i = 0; i < data.length; i++){
                        bytes2[i] = data.charCodeAt(i) & 255;
                    }
                    return new BufferPolyfill(bytes2);
                }
                const bytes = _encoder.encode(data);
                return new BufferPolyfill(bytes);
            }
            if (data instanceof ArrayBuffer) {
                return new BufferPolyfill(data);
            }
            return new BufferPolyfill(data);
        }
        static alloc(size, fill) {
            const buffer = new BufferPolyfill(size);
            if (fill !== void 0) {
                buffer.fill(fill);
            }
            return buffer;
        }
        static allocUnsafe(size) {
            return new BufferPolyfill(size);
        }
        static allocUnsafeSlow(size) {
            return new BufferPolyfill(size);
        }
        static concat(buffers) {
            const totalLength = buffers.reduce((sum, buf)=>sum + buf.length, 0);
            const result = new BufferPolyfill(totalLength);
            let offset = 0;
            for (const buf of buffers){
                result.set(buf, offset);
                offset += buf.length;
            }
            return result;
        }
        static isBuffer(obj) {
            return obj instanceof BufferPolyfill || obj instanceof Uint8Array;
        }
        static isEncoding(encoding) {
            return [
                "utf8",
                "utf-8",
                "ascii",
                "latin1",
                "binary",
                "base64",
                "base64url",
                "hex"
            ].includes(encoding.toLowerCase());
        }
        static byteLength(string, encoding) {
            const enc = (encoding || "utf8").toLowerCase();
            if (enc === "base64" || enc === "base64url") {
                const base64 = string.replace(/[=]/g, "");
                return Math.floor(base64.length * 3 / 4);
            }
            if (enc === "hex") {
                return string.length / 2;
            }
            return _encoder.encode(string).length;
        }
        toString(encoding = "utf8") {
            const enc = (encoding || "utf8").toLowerCase();
            if (enc === "base64") {
                return uint8ToBase64(this);
            }
            if (enc === "base64url") {
                return uint8ToBase64(this).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
            }
            if (enc === "hex") {
                return uint8ToHex(this);
            }
            if (enc === "latin1" || enc === "binary") {
                return uint8ToBinaryString(this);
            }
            return _decoder$1.decode(this);
        }
        slice(start, end) {
            return new BufferPolyfill(super.slice(start, end));
        }
        subarray(start, end) {
            return new BufferPolyfill(super.subarray(start, end));
        }
        write(string, offset) {
            const bytes = _encoder.encode(string);
            this.set(bytes, offset || 0);
            return bytes.length;
        }
        copy(target, targetStart, sourceStart, sourceEnd) {
            const src = this.subarray(sourceStart || 0, sourceEnd);
            target.set(src, targetStart || 0);
            return src.length;
        }
        compare(otherBuffer) {
            const len = Math.min(this.length, otherBuffer.length);
            for(let i = 0; i < len; i++){
                if (this[i] < otherBuffer[i]) return -1;
                if (this[i] > otherBuffer[i]) return 1;
            }
            if (this.length < otherBuffer.length) return -1;
            if (this.length > otherBuffer.length) return 1;
            return 0;
        }
        equals(otherBuffer) {
            return this.compare(otherBuffer) === 0;
        }
        toJSON() {
            return {
                type: "Buffer",
                data: Array.from(this)
            };
        }
        hasOwnProperty(prop) {
            return Object.prototype.hasOwnProperty.call(this, prop);
        }
        readUInt8(offset) {
            return this[offset];
        }
        readUInt16BE(offset) {
            return this[offset] << 8 | this[offset + 1];
        }
        readUInt16LE(offset) {
            return this[offset] | this[offset + 1] << 8;
        }
        readUInt32BE(offset) {
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        }
        readUInt32LE(offset) {
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        }
        writeUInt8(value, offset) {
            this[offset] = value & 255;
            return offset + 1;
        }
        writeUInt16BE(value, offset) {
            this[offset] = value >> 8 & 255;
            this[offset + 1] = value & 255;
            return offset + 2;
        }
        writeUInt16LE(value, offset) {
            this[offset] = value & 255;
            this[offset + 1] = value >> 8 & 255;
            return offset + 2;
        }
        writeUInt32BE(value, offset) {
            this[offset] = value >> 24 & 255;
            this[offset + 1] = value >> 16 & 255;
            this[offset + 2] = value >> 8 & 255;
            this[offset + 3] = value & 255;
            return offset + 4;
        }
        writeUInt32LE(value, offset) {
            this[offset] = value & 255;
            this[offset + 1] = value >> 8 & 255;
            this[offset + 2] = value >> 16 & 255;
            this[offset + 3] = value >> 24 & 255;
            return offset + 4;
        }
        readUint8(offset) {
            return this.readUInt8(offset);
        }
        readUint16BE(offset) {
            return this.readUInt16BE(offset);
        }
        readUint16LE(offset) {
            return this.readUInt16LE(offset);
        }
        readUint32BE(offset) {
            return this.readUInt32BE(offset);
        }
        readUint32LE(offset) {
            return this.readUInt32LE(offset);
        }
        writeUint8(value, offset) {
            return this.writeUInt8(value, offset);
        }
        writeUint16BE(value, offset) {
            return this.writeUInt16BE(value, offset);
        }
        writeUint16LE(value, offset) {
            return this.writeUInt16LE(value, offset);
        }
        writeUint32BE(value, offset) {
            return this.writeUInt32BE(value, offset);
        }
        writeUint32LE(value, offset) {
            return this.writeUInt32LE(value, offset);
        }
        readInt8(offset) {
            const val = this[offset];
            return val & 128 ? val - 256 : val;
        }
        readInt16BE(offset) {
            const val = this.readUInt16BE(offset);
            return val & 32768 ? val - 65536 : val;
        }
        readInt16LE(offset) {
            const val = this.readUInt16LE(offset);
            return val & 32768 ? val - 65536 : val;
        }
        readInt32BE(offset) {
            const val = this.readUInt32BE(offset);
            return val | 0;
        }
        readInt32LE(offset) {
            const val = this.readUInt32LE(offset);
            return val | 0;
        }
        writeInt8(value, offset) {
            this[offset] = value & 255;
            return offset + 1;
        }
        writeInt16BE(value, offset) {
            return this.writeUInt16BE(value & 65535, offset);
        }
        writeInt16LE(value, offset) {
            return this.writeUInt16LE(value & 65535, offset);
        }
        writeInt32BE(value, offset) {
            return this.writeUInt32BE(value >>> 0, offset);
        }
        writeInt32LE(value, offset) {
            return this.writeUInt32LE(value >>> 0, offset);
        }
        readBigUInt64LE(offset) {
            const lo = BigInt(this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24) & 0xffffffffn;
            const hi = BigInt(this[offset + 4] | this[offset + 5] << 8 | this[offset + 6] << 16 | this[offset + 7] << 24) & 0xffffffffn;
            return lo | hi << 32n;
        }
        readBigUInt64BE(offset) {
            const hi = BigInt(this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]) & 0xffffffffn;
            const lo = BigInt(this[offset + 4] << 24 | this[offset + 5] << 16 | this[offset + 6] << 8 | this[offset + 7]) & 0xffffffffn;
            return lo | hi << 32n;
        }
        readBigInt64LE(offset) {
            const val = this.readBigUInt64LE(offset);
            if (val >= 0x8000000000000000n) {
                return val - 0x10000000000000000n;
            }
            return val;
        }
        readBigInt64BE(offset) {
            const val = this.readBigUInt64BE(offset);
            if (val >= 0x8000000000000000n) {
                return val - 0x10000000000000000n;
            }
            return val;
        }
        writeBigUInt64LE(value, offset) {
            const lo = value & 0xffffffffn;
            const hi = value >> 32n & 0xffffffffn;
            this[offset] = Number(lo & 0xffn);
            this[offset + 1] = Number(lo >> 8n & 0xffn);
            this[offset + 2] = Number(lo >> 16n & 0xffn);
            this[offset + 3] = Number(lo >> 24n & 0xffn);
            this[offset + 4] = Number(hi & 0xffn);
            this[offset + 5] = Number(hi >> 8n & 0xffn);
            this[offset + 6] = Number(hi >> 16n & 0xffn);
            this[offset + 7] = Number(hi >> 24n & 0xffn);
            return offset + 8;
        }
        writeBigUInt64BE(value, offset) {
            const lo = value & 0xffffffffn;
            const hi = value >> 32n & 0xffffffffn;
            this[offset] = Number(hi >> 24n & 0xffn);
            this[offset + 1] = Number(hi >> 16n & 0xffn);
            this[offset + 2] = Number(hi >> 8n & 0xffn);
            this[offset + 3] = Number(hi & 0xffn);
            this[offset + 4] = Number(lo >> 24n & 0xffn);
            this[offset + 5] = Number(lo >> 16n & 0xffn);
            this[offset + 6] = Number(lo >> 8n & 0xffn);
            this[offset + 7] = Number(lo & 0xffn);
            return offset + 8;
        }
        writeBigInt64LE(value, offset) {
            const unsigned = value < 0n ? value + 0x10000000000000000n : value;
            return this.writeBigUInt64LE(unsigned, offset);
        }
        writeBigInt64BE(value, offset) {
            const unsigned = value < 0n ? value + 0x10000000000000000n : value;
            return this.writeBigUInt64BE(unsigned, offset);
        }
        readBigUint64LE(offset) {
            return this.readBigUInt64LE(offset);
        }
        readBigUint64BE(offset) {
            return this.readBigUInt64BE(offset);
        }
        writeBigUint64LE(value, offset) {
            return this.writeBigUInt64LE(value, offset);
        }
        writeBigUint64BE(value, offset) {
            return this.writeBigUInt64BE(value, offset);
        }
        readFloatLE(offset) {
            const view = new DataView(this.buffer, this.byteOffset + offset, 4);
            return view.getFloat32(0, true);
        }
        readFloatBE(offset) {
            const view = new DataView(this.buffer, this.byteOffset + offset, 4);
            return view.getFloat32(0, false);
        }
        readDoubleLE(offset) {
            const view = new DataView(this.buffer, this.byteOffset + offset, 8);
            return view.getFloat64(0, true);
        }
        readDoubleBE(offset) {
            const view = new DataView(this.buffer, this.byteOffset + offset, 8);
            return view.getFloat64(0, false);
        }
        writeFloatLE(value, offset) {
            const view = new DataView(this.buffer, this.byteOffset + offset, 4);
            view.setFloat32(0, value, true);
            return offset + 4;
        }
        writeFloatBE(value, offset) {
            const view = new DataView(this.buffer, this.byteOffset + offset, 4);
            view.setFloat32(0, value, false);
            return offset + 4;
        }
        writeDoubleLE(value, offset) {
            const view = new DataView(this.buffer, this.byteOffset + offset, 8);
            view.setFloat64(0, value, true);
            return offset + 8;
        }
        writeDoubleBE(value, offset) {
            const view = new DataView(this.buffer, this.byteOffset + offset, 8);
            view.setFloat64(0, value, false);
            return offset + 8;
        }
        readUIntLE(offset, byteLength) {
            let val = 0;
            let mul = 1;
            for(let i = 0; i < byteLength; i++){
                val += this[offset + i] * mul;
                mul *= 256;
            }
            return val;
        }
        readUintLE(offset, byteLength) {
            return this.readUIntLE(offset, byteLength);
        }
        readUIntBE(offset, byteLength) {
            let val = 0;
            let mul = 1;
            for(let i = byteLength - 1; i >= 0; i--){
                val += this[offset + i] * mul;
                mul *= 256;
            }
            return val;
        }
        readUintBE(offset, byteLength) {
            return this.readUIntBE(offset, byteLength);
        }
        readIntLE(offset, byteLength) {
            let val = this.readUIntLE(offset, byteLength);
            const limit = Math.pow(2, byteLength * 8 - 1);
            if (val >= limit) {
                val -= Math.pow(2, byteLength * 8);
            }
            return val;
        }
        readIntBE(offset, byteLength) {
            let val = this.readUIntBE(offset, byteLength);
            const limit = Math.pow(2, byteLength * 8 - 1);
            if (val >= limit) {
                val -= Math.pow(2, byteLength * 8);
            }
            return val;
        }
        writeUIntLE(value, offset, byteLength) {
            let val = value;
            for(let i = 0; i < byteLength; i++){
                this[offset + i] = val & 255;
                val = Math.floor(val / 256);
            }
            return offset + byteLength;
        }
        writeUintLE(value, offset, byteLength) {
            return this.writeUIntLE(value, offset, byteLength);
        }
        writeUIntBE(value, offset, byteLength) {
            let val = value;
            for(let i = byteLength - 1; i >= 0; i--){
                this[offset + i] = val & 255;
                val = Math.floor(val / 256);
            }
            return offset + byteLength;
        }
        writeUintBE(value, offset, byteLength) {
            return this.writeUIntBE(value, offset, byteLength);
        }
        writeIntLE(value, offset, byteLength) {
            let val = value;
            if (val < 0) {
                val += Math.pow(2, byteLength * 8);
            }
            return this.writeUIntLE(val, offset, byteLength);
        }
        writeIntBE(value, offset, byteLength) {
            let val = value;
            if (val < 0) {
                val += Math.pow(2, byteLength * 8);
            }
            return this.writeUIntBE(val, offset, byteLength);
        }
        swap16() {
            const len = this.length;
            if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            }
            for(let i = 0; i < len; i += 2){
                const a = this[i];
                this[i] = this[i + 1];
                this[i + 1] = a;
            }
            return this;
        }
        swap32() {
            const len = this.length;
            if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            }
            for(let i = 0; i < len; i += 4){
                const a = this[i];
                const b = this[i + 1];
                this[i] = this[i + 3];
                this[i + 1] = this[i + 2];
                this[i + 2] = b;
                this[i + 3] = a;
            }
            return this;
        }
        swap64() {
            const len = this.length;
            if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            }
            for(let i = 0; i < len; i += 8){
                const a = this[i];
                const b = this[i + 1];
                const c = this[i + 2];
                const d = this[i + 3];
                this[i] = this[i + 7];
                this[i + 1] = this[i + 6];
                this[i + 2] = this[i + 5];
                this[i + 3] = this[i + 4];
                this[i + 4] = d;
                this[i + 5] = c;
                this[i + 6] = b;
                this[i + 7] = a;
            }
            return this;
        }
    }
    if (typeof globalThis.Buffer === "undefined") {
        globalThis.Buffer = BufferPolyfill;
    }
    Stream.pipeline = pipeline;
    Stream.finished = finished;
    Stream.promises = promises$2;
    let Socket$1 = class Socket extends Duplex {
        _connecting = false;
        _connected = false;
        _destroyed = false;
        _remoteAddress = "";
        _remotePort = 0;
        _localAddress = "127.0.0.1";
        _localPort = 0;
        localAddress = "127.0.0.1";
        localPort = 0;
        remoteAddress;
        remotePort;
        remoteFamily;
        connecting = false;
        destroyed = false;
        readyState = "closed";
        constructor(options){
            super();
        }
        connect(portOrOptions, hostOrCallback, callback) {
            let port;
            let host = "127.0.0.1";
            let cb;
            if (typeof portOrOptions === "number") {
                port = portOrOptions;
                if (typeof hostOrCallback === "string") {
                    host = hostOrCallback;
                    cb = callback;
                } else {
                    cb = hostOrCallback;
                }
            } else {
                port = portOrOptions.port;
                host = portOrOptions.host || "127.0.0.1";
                cb = typeof hostOrCallback === "function" ? hostOrCallback : callback;
            }
            this._connecting = true;
            this.connecting = true;
            this._remoteAddress = host;
            this._remotePort = port;
            this.remoteAddress = host;
            this.remotePort = port;
            this.remoteFamily = "IPv4";
            this.readyState = "opening";
            queueMicrotask(()=>{
                this._connecting = false;
                this._connected = true;
                this.connecting = false;
                this.readyState = "open";
                this.emit("connect");
                if (cb) cb();
            });
            return this;
        }
        address() {
            if (!this._connected) return null;
            return {
                address: this._localAddress,
                family: "IPv4",
                port: this._localPort
            };
        }
        setEncoding(encoding) {
            return this;
        }
        setTimeout(timeout, callback) {
            if (callback) {
                this.once("timeout", callback);
            }
            return this;
        }
        setNoDelay(noDelay) {
            return this;
        }
        setKeepAlive(enable, initialDelay) {
            return this;
        }
        ref() {
            return this;
        }
        unref() {
            return this;
        }
        destroy(error) {
            if (this._destroyed) return this;
            this._destroyed = true;
            this._connected = false;
            this.destroyed = true;
            this.readyState = "closed";
            if (error) {
                this.emit("error", error);
            }
            queueMicrotask(()=>{
                this.emit("close", !!error);
            });
            return this;
        }
        _receiveData(data) {
            const buffer = typeof data === "string" ? BufferPolyfill.from(data) : data;
            this.push(buffer);
        }
        _receiveEnd() {
            this.push(null);
        }
    };
    let Server$3 = class Server extends EventEmitter {
        _listening = false;
        _address = null;
        _connections = new Set();
        _maxConnections = Infinity;
        listening = false;
        maxConnections;
        constructor(optionsOrConnectionListener, connectionListener){
            super();
            let listener;
            if (typeof optionsOrConnectionListener === "function") {
                listener = optionsOrConnectionListener;
            } else {
                listener = connectionListener;
            }
            if (listener) {
                this.on("connection", listener);
            }
        }
        listen(portOrOptions, hostOrCallback, backlogOrCallback, callback) {
            let port = 0;
            let host = "0.0.0.0";
            let cb;
            if (typeof portOrOptions === "number") {
                port = portOrOptions;
                if (typeof hostOrCallback === "string") {
                    host = hostOrCallback;
                    if (typeof backlogOrCallback === "function") {
                        cb = backlogOrCallback;
                    } else {
                        cb = callback;
                    }
                } else if (typeof hostOrCallback === "function") {
                    cb = hostOrCallback;
                } else if (typeof hostOrCallback === "number") {
                    cb = typeof backlogOrCallback === "function" ? backlogOrCallback : callback;
                } else {
                    if (typeof backlogOrCallback === "function") {
                        cb = backlogOrCallback;
                    } else if (typeof callback === "function") {
                        cb = callback;
                    }
                }
            } else if (portOrOptions) {
                port = portOrOptions.port || 0;
                host = portOrOptions.host || "0.0.0.0";
                cb = typeof hostOrCallback === "function" ? hostOrCallback : callback;
            }
            if (port === 0) {
                port = 3e3 + Math.floor(Math.random() * 1e3);
            }
            this._address = {
                address: host,
                family: "IPv4",
                port
            };
            this._listening = true;
            this.listening = true;
            queueMicrotask(()=>{
                this.emit("listening");
                if (cb) cb();
            });
            return this;
        }
        address() {
            return this._address;
        }
        close(callback) {
            this._listening = false;
            this.listening = false;
            for (const socket of this._connections){
                socket.destroy();
            }
            this._connections.clear();
            queueMicrotask(()=>{
                this.emit("close");
                if (callback) callback();
            });
            return this;
        }
        getConnections(callback) {
            callback(null, this._connections.size);
        }
        ref() {
            return this;
        }
        unref() {
            return this;
        }
        _handleConnection(socket) {
            if (!this._listening) {
                socket.destroy();
                return;
            }
            this._connections.add(socket);
            socket.on("close", ()=>{
                this._connections.delete(socket);
            });
            this.emit("connection", socket);
        }
    };
    function createServer$3(optionsOrConnectionListener, connectionListener) {
        return new Server$3(optionsOrConnectionListener, connectionListener);
    }
    function createConnection(portOrOptions, hostOrCallback, callback) {
        const socket = new Socket$1();
        return socket.connect(portOrOptions, hostOrCallback, callback);
    }
    const connect$2 = createConnection;
    function isIP(input) {
        if (/^(\d{1,3}\.){3}\d{1,3}$/.test(input)) {
            return 4;
        }
        if (/^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/.test(input)) {
            return 6;
        }
        return 0;
    }
    function isIPv4(input) {
        return isIP(input) === 4;
    }
    function isIPv6(input) {
        return isIP(input) === 6;
    }
    var net = {
        Socket: Socket$1,
        Server: Server$3,
        createServer: createServer$3,
        createConnection,
        connect: connect$2,
        isIP,
        isIPv4,
        isIPv6
    };
    var netShim = Object.freeze({
        __proto__: null,
        Server: Server$3,
        Socket: Socket$1,
        connect: connect$2,
        createConnection: createConnection,
        createServer: createServer$3,
        default: net,
        isIP: isIP,
        isIPv4: isIPv4,
        isIPv6: isIPv6
    });
    function randomBytes(size) {
        const array = new Uint8Array(size);
        crypto.getRandomValues(array);
        return BufferPolyfill.from(array);
    }
    function randomFillSync(buffer, offset, size) {
        const start = offset || 0;
        const len = size !== void 0 ? size : buffer.length - start;
        const view = new Uint8Array(buffer.buffer, buffer.byteOffset + start, len);
        crypto.getRandomValues(view);
        return buffer;
    }
    function randomUUID() {
        return crypto.randomUUID();
    }
    function randomInt(min, max) {
        if (max === void 0) {
            max = min;
            min = 0;
        }
        const range = max - min;
        const array = new Uint32Array(1);
        crypto.getRandomValues(array);
        return min + array[0] % range;
    }
    function getRandomValues(array) {
        return crypto.getRandomValues(array);
    }
    function createHash(algorithm) {
        return new Hash(algorithm);
    }
    class Hash {
        algorithm;
        data = [];
        constructor(algorithm){
            this.algorithm = normalizeHashAlgorithm(algorithm);
        }
        update(data, encoding) {
            let buffer;
            if (typeof data === "string") {
                if (encoding === "base64") {
                    buffer = BufferPolyfill.from(atob(data));
                } else {
                    buffer = BufferPolyfill.from(data);
                }
            } else {
                buffer = data;
            }
            this.data.push(buffer);
            return this;
        }
        async digestAsync(encoding) {
            const combined = concatBuffers(this.data);
            const dataBuffer = new Uint8Array(combined).buffer;
            const hashBuffer = await crypto.subtle.digest(this.algorithm, dataBuffer);
            return encodeResult(new Uint8Array(hashBuffer), encoding);
        }
        digest(encoding) {
            const combined = concatBuffers(this.data);
            const hash = syncHash(combined, this.algorithm);
            return encodeResult(hash, encoding);
        }
    }
    function createHmac(algorithm, key) {
        return new Hmac(algorithm, key);
    }
    class Hmac {
        algorithm;
        key;
        data = [];
        constructor(algorithm, key){
            this.algorithm = normalizeHashAlgorithm(algorithm);
            this.key = typeof key === "string" ? BufferPolyfill.from(key) : key;
        }
        update(data, encoding) {
            const buffer = typeof data === "string" ? BufferPolyfill.from(data) : data;
            this.data.push(buffer);
            return this;
        }
        async digestAsync(encoding) {
            const combined = concatBuffers(this.data);
            const keyBuffer = new Uint8Array(this.key).buffer;
            const dataBuffer = new Uint8Array(combined).buffer;
            const cryptoKey = await crypto.subtle.importKey("raw", keyBuffer, {
                name: "HMAC",
                hash: this.algorithm
            }, false, [
                "sign"
            ]);
            const signature = await crypto.subtle.sign("HMAC", cryptoKey, dataBuffer);
            return encodeResult(new Uint8Array(signature), encoding);
        }
        digest(encoding) {
            const combined = concatBuffers(this.data);
            const hash = syncHmac(combined, this.key, this.algorithm);
            return encodeResult(hash, encoding);
        }
    }
    async function pbkdf2Async(password, salt, iterations, keylen, digest) {
        const passwordBuffer = typeof password === "string" ? BufferPolyfill.from(password) : password instanceof Uint8Array ? password : BufferPolyfill.from(password);
        const saltBuffer = typeof salt === "string" ? BufferPolyfill.from(salt) : salt instanceof Uint8Array ? salt : BufferPolyfill.from(salt);
        const passwordArrayBuffer = new Uint8Array(passwordBuffer).buffer;
        const saltArrayBuffer = new Uint8Array(saltBuffer).buffer;
        const key = await crypto.subtle.importKey("raw", passwordArrayBuffer, "PBKDF2", false, [
            "deriveBits"
        ]);
        const derivedBits = await crypto.subtle.deriveBits({
            name: "PBKDF2",
            salt: saltArrayBuffer,
            iterations,
            hash: normalizeHashAlgorithm(digest)
        }, key, keylen * 8);
        return BufferPolyfill.from(derivedBits);
    }
    function pbkdf2(password, salt, iterations, keylen, digest, callback) {
        pbkdf2Async(password, salt, iterations, keylen, digest).then((key)=>callback(null, key)).catch((err)=>callback(err, BufferPolyfill.alloc(0)));
    }
    function pbkdf2Sync(password, salt, iterations, keylen, digest) {
        const passwordBuffer = typeof password === "string" ? BufferPolyfill.from(password) : password;
        const saltBuffer = typeof salt === "string" ? BufferPolyfill.from(salt) : salt;
        const hashAlg = normalizeHashAlgorithm(digest);
        let hashLen;
        if (hashAlg.includes("512")) {
            hashLen = 64;
        } else if (hashAlg.includes("384")) {
            hashLen = 48;
        } else if (hashAlg.includes("1") || hashAlg === "SHA-1") {
            hashLen = 20;
        } else {
            hashLen = 32;
        }
        const numBlocks = Math.ceil(keylen / hashLen);
        const derivedKey = new Uint8Array(numBlocks * hashLen);
        for(let blockNum = 1; blockNum <= numBlocks; blockNum++){
            const blockNumBuf = new Uint8Array(4);
            blockNumBuf[0] = blockNum >>> 24 & 255;
            blockNumBuf[1] = blockNum >>> 16 & 255;
            blockNumBuf[2] = blockNum >>> 8 & 255;
            blockNumBuf[3] = blockNum & 255;
            const saltWithBlock = new Uint8Array(saltBuffer.length + 4);
            saltWithBlock.set(saltBuffer);
            saltWithBlock.set(blockNumBuf, saltBuffer.length);
            let u = syncHmac(saltWithBlock, passwordBuffer, hashAlg);
            const block = new Uint8Array(u);
            for(let i = 1; i < iterations; i++){
                u = syncHmac(u, passwordBuffer, hashAlg);
                for(let j = 0; j < block.length; j++){
                    block[j] ^= u[j];
                }
            }
            derivedKey.set(block, (blockNum - 1) * hashLen);
        }
        return BufferPolyfill.from(derivedKey.slice(0, keylen));
    }
    function sign(algorithm, data, key, callback) {
        const keyInfo = extractKeyInfo(key);
        const alg = algorithm || keyInfo.algorithm;
        if (!alg) {
            const error = new Error("Algorithm must be specified");
            if (callback) {
                callback(error, null);
                return;
            }
            throw error;
        }
        if (callback) {
            signAsync(alg, data, keyInfo).then((sig)=>callback(null, sig)).catch((err)=>callback(err, null));
            return;
        }
        const result = signSync(alg, data, keyInfo);
        return result;
    }
    function verify(algorithm, data, key, signature, callback) {
        const keyInfo = extractKeyInfo(key);
        const alg = algorithm || keyInfo.algorithm;
        if (!alg) {
            const error = new Error("Algorithm must be specified");
            if (callback) {
                callback(error, false);
                return;
            }
            throw error;
        }
        if (callback) {
            verifyAsync(alg, data, keyInfo, signature).then((result)=>callback(null, result)).catch((err)=>callback(err, false));
            return;
        }
        return verifySync(alg, data, keyInfo, signature);
    }
    function createSign(algorithm) {
        return new Sign(algorithm);
    }
    function createVerify(algorithm) {
        return new Verify(algorithm);
    }
    class Sign extends EventEmitter {
        algorithm;
        data = [];
        constructor(algorithm){
            super();
            this.algorithm = algorithm;
        }
        update(data, encoding) {
            const buffer = typeof data === "string" ? BufferPolyfill.from(data) : data;
            this.data.push(buffer);
            return this;
        }
        sign(privateKey, outputEncoding) {
            const combined = concatBuffers(this.data);
            const keyInfo = extractKeyInfo(privateKey);
            const signature = signSync(this.algorithm, combined, keyInfo);
            if (outputEncoding === "base64") {
                return btoa(String.fromCharCode(...signature));
            }
            if (outputEncoding === "hex") {
                return Array.from(signature).map((b)=>b.toString(16).padStart(2, "0")).join("");
            }
            return signature;
        }
    }
    class Verify extends EventEmitter {
        algorithm;
        data = [];
        constructor(algorithm){
            super();
            this.algorithm = algorithm;
        }
        update(data, encoding) {
            const buffer = typeof data === "string" ? BufferPolyfill.from(data) : data;
            this.data.push(buffer);
            return this;
        }
        verify(publicKey, signature, signatureEncoding) {
            const combined = concatBuffers(this.data);
            const keyInfo = extractKeyInfo(publicKey);
            let sig;
            if (typeof signature === "string") {
                if (signatureEncoding === "base64") {
                    sig = BufferPolyfill.from(atob(signature));
                } else if (signatureEncoding === "hex") {
                    sig = BufferPolyfill.from(signature.match(/.{2}/g).map((byte)=>parseInt(byte, 16)));
                } else {
                    sig = BufferPolyfill.from(signature);
                }
            } else {
                sig = signature;
            }
            return verifySync(this.algorithm, combined, keyInfo, sig);
        }
    }
    class KeyObject {
        _keyData;
        _type;
        _algorithm;
        constructor(type, keyData, algorithm){
            this._type = type;
            this._keyData = keyData;
            this._algorithm = algorithm;
        }
        get type() {
            return this._type;
        }
        get asymmetricKeyType() {
            if (this._type === "secret") return void 0;
            if (this._algorithm?.includes("RSA")) return "rsa";
            if (this._algorithm?.includes("EC") || this._algorithm?.includes("ES")) return "ec";
            if (this._algorithm?.includes("Ed")) return "ed25519";
            return void 0;
        }
        get symmetricKeySize() {
            if (this._type !== "secret") return void 0;
            if (this._keyData instanceof Uint8Array) {
                return this._keyData.length * 8;
            }
            return void 0;
        }
        export(options) {
            if (this._keyData instanceof Uint8Array) {
                return BufferPolyfill.from(this._keyData);
            }
            throw new Error("Cannot export CryptoKey synchronously");
        }
    }
    function createSecretKey(key, encoding) {
        const keyBuffer = typeof key === "string" ? BufferPolyfill.from(key, encoding) : key;
        return new KeyObject("secret", keyBuffer);
    }
    function createPublicKey(key) {
        const keyInfo = extractKeyInfo(key);
        return new KeyObject("public", keyInfo.keyData, keyInfo.algorithm);
    }
    function createPrivateKey(key) {
        const keyInfo = extractKeyInfo(key);
        return new KeyObject("private", keyInfo.keyData, keyInfo.algorithm);
    }
    function timingSafeEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        let result = 0;
        for(let i = 0; i < a.length; i++){
            result |= a[i] ^ b[i];
        }
        return result === 0;
    }
    function getCiphers$1() {
        return [
            "aes-128-cbc",
            "aes-256-cbc",
            "aes-128-gcm",
            "aes-256-gcm"
        ];
    }
    function getHashes() {
        return [
            "sha1",
            "sha256",
            "sha384",
            "sha512"
        ];
    }
    const constants$5 = {
        SSL_OP_ALL: 0,
        RSA_PKCS1_PADDING: 1,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_PKCS1_PSS_PADDING: 6
    };
    function normalizeHashAlgorithm(alg) {
        const normalized = alg.toUpperCase().replace(/[^A-Z0-9]/g, "");
        switch(normalized){
            case "SHA1":
                return "SHA-1";
            case "SHA256":
                return "SHA-256";
            case "SHA384":
                return "SHA-384";
            case "SHA512":
                return "SHA-512";
            case "MD5":
                return "MD5";
            default:
                return alg;
        }
    }
    function getWebCryptoAlgorithm(nodeAlgorithm) {
        const alg = nodeAlgorithm.toUpperCase().replace(/[^A-Z0-9]/g, "");
        if (alg.includes("RSA")) {
            if (alg.includes("PSS")) {
                const hash2 = alg.match(/SHA(\d+)/)?.[0] || "SHA-256";
                return {
                    name: "RSA-PSS",
                    hash: `SHA-${hash2.replace("SHA", "")}`
                };
            }
            const hash = alg.match(/SHA(\d+)/)?.[0] || "SHA-256";
            return {
                name: "RSASSA-PKCS1-v1_5",
                hash: `SHA-${hash.replace("SHA", "")}`
            };
        }
        if (alg.startsWith("ES") || alg.includes("ECDSA")) {
            const bits = alg.match(/\d+/)?.[0] || "256";
            const hash = bits === "512" ? "SHA-512" : bits === "384" ? "SHA-384" : "SHA-256";
            return {
                name: "ECDSA",
                hash
            };
        }
        if (alg.includes("ED25519") || alg === "EDDSA") {
            return {
                name: "Ed25519"
            };
        }
        if (alg.includes("HS") || alg.includes("HMAC")) {
            const bits = alg.match(/\d+/)?.[0] || "256";
            return {
                name: "HMAC",
                hash: `SHA-${bits}`
            };
        }
        return {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-256"
        };
    }
    function extractKeyInfo(key) {
        if (key instanceof KeyObject) {
            return {
                keyData: key._keyData,
                algorithm: key._algorithm,
                type: key._type,
                format: "raw"
            };
        }
        if (typeof key === "object" && "key" in key) {
            return extractKeyInfo(key.key);
        }
        const keyStr = typeof key === "string" ? key : key.toString();
        if (keyStr.includes("-----BEGIN")) {
            const isPrivate = keyStr.includes("PRIVATE");
            const isPublic = keyStr.includes("PUBLIC");
            const base64 = keyStr.replace(/-----BEGIN [^-]+-----/, "").replace(/-----END [^-]+-----/, "").replace(/\s/g, "");
            const keyData2 = BufferPolyfill.from(atob(base64));
            let algorithm;
            if (keyStr.includes("RSA")) algorithm = "RSA-SHA256";
            else if (keyStr.includes("EC")) algorithm = "ES256";
            else if (keyStr.includes("ED25519")) algorithm = "Ed25519";
            return {
                keyData: keyData2,
                algorithm,
                type: isPrivate ? "private" : isPublic ? "public" : "secret",
                format: "pem"
            };
        }
        const keyData = typeof key === "string" ? BufferPolyfill.from(key) : key;
        return {
            keyData,
            type: "secret",
            format: "raw"
        };
    }
    function concatBuffers(buffers) {
        const totalLength = buffers.reduce((acc, arr)=>acc + arr.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const buf of buffers){
            result.set(buf, offset);
            offset += buf.length;
        }
        return result;
    }
    function encodeResult(data, encoding) {
        if (encoding === "hex") {
            return Array.from(data).map((b)=>b.toString(16).padStart(2, "0")).join("");
        }
        if (encoding === "base64") {
            return btoa(String.fromCharCode(...data));
        }
        return BufferPolyfill.from(data);
    }
    function syncHash(data, algorithm) {
        let size;
        if (algorithm.includes("512")) {
            size = 64;
        } else if (algorithm.includes("384")) {
            size = 48;
        } else if (algorithm.includes("1") || algorithm === "SHA-1") {
            size = 20;
        } else {
            size = 32;
        }
        const result = new Uint8Array(size);
        let h1 = 3735928559;
        let h2 = 1103547991;
        for(let i = 0; i < data.length; i++){
            h1 = Math.imul(h1 ^ data[i], 2654435761);
            h2 = Math.imul(h2 ^ data[i], 1597334677);
        }
        h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
        h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
        for(let i = 0; i < size; i++){
            const mix = i < size / 2 ? h1 : h2;
            result[i] = mix >>> i % 4 * 8 & 255;
            h1 = Math.imul(h1, 1103515245) + 12345;
            h2 = Math.imul(h2, 1103515245) + 12345;
        }
        return result;
    }
    function syncHmac(data, key, algorithm) {
        const combined = new Uint8Array(key.length + data.length);
        combined.set(key, 0);
        combined.set(data, key.length);
        return syncHash(combined, algorithm);
    }
    async function signAsync(algorithm, data, keyInfo) {
        const webCryptoAlg = getWebCryptoAlgorithm(algorithm);
        try {
            const cryptoKey = await importKey(keyInfo, webCryptoAlg, [
                "sign"
            ]);
            const signatureAlg = webCryptoAlg.hash ? {
                name: webCryptoAlg.name,
                hash: webCryptoAlg.hash
            } : {
                name: webCryptoAlg.name
            };
            const dataBuffer = new Uint8Array(data).buffer;
            const signature = await crypto.subtle.sign(signatureAlg, cryptoKey, dataBuffer);
            return BufferPolyfill.from(signature);
        } catch (error) {
            console.warn("WebCrypto sign failed, using fallback:", error);
            return signSync(algorithm, data, keyInfo);
        }
    }
    async function verifyAsync(algorithm, data, keyInfo, signature) {
        const webCryptoAlg = getWebCryptoAlgorithm(algorithm);
        try {
            const cryptoKey = await importKey(keyInfo, webCryptoAlg, [
                "verify"
            ]);
            const verifyAlg = webCryptoAlg.hash ? {
                name: webCryptoAlg.name,
                hash: webCryptoAlg.hash
            } : {
                name: webCryptoAlg.name
            };
            const sigBuffer = new Uint8Array(signature).buffer;
            const dataBuffer = new Uint8Array(data).buffer;
            return await crypto.subtle.verify(verifyAlg, cryptoKey, sigBuffer, dataBuffer);
        } catch (error) {
            console.warn("WebCrypto verify failed, using fallback:", error);
            return verifySync(algorithm, data, keyInfo, signature);
        }
    }
    function signSync(algorithm, data, keyInfo) {
        const keyData = keyInfo.keyData instanceof Uint8Array ? keyInfo.keyData : new Uint8Array(0);
        const combined = new Uint8Array(keyData.length + data.length);
        combined.set(keyData, 0);
        combined.set(data, keyData.length);
        const hash = syncHash(combined, algorithm);
        return BufferPolyfill.from(hash);
    }
    function verifySync(algorithm, data, keyInfo, signature) {
        const expectedSig = signSync(algorithm, data, keyInfo);
        return timingSafeEqual(BufferPolyfill.from(signature), expectedSig);
    }
    async function importKey(keyInfo, algorithm, usages) {
        if (keyInfo.keyData instanceof CryptoKey) {
            return keyInfo.keyData;
        }
        const keyData = keyInfo.keyData;
        const keyBuffer = new Uint8Array(keyData).buffer;
        if (keyInfo.format === "pem") {
            const format = keyInfo.type === "private" ? "pkcs8" : "spki";
            const importAlg = algorithm.name === "ECDSA" ? {
                name: "ECDSA",
                namedCurve: "P-256"
            } : algorithm.name === "Ed25519" ? {
                name: "Ed25519"
            } : {
                name: algorithm.name,
                hash: algorithm.hash || "SHA-256"
            };
            return await crypto.subtle.importKey(format, keyBuffer, importAlg, true, usages);
        }
        if (keyInfo.type === "secret") {
            return await crypto.subtle.importKey("raw", keyBuffer, {
                name: algorithm.name,
                hash: algorithm.hash
            }, true, usages);
        }
        throw new Error(`Unsupported key format: ${keyInfo.format}`);
    }
    var crypto$1 = {
        randomBytes,
        randomFillSync,
        randomUUID,
        randomInt,
        getRandomValues,
        createHash,
        createHmac,
        createSign,
        createVerify,
        sign,
        verify,
        pbkdf2,
        pbkdf2Sync,
        timingSafeEqual,
        getCiphers: getCiphers$1,
        getHashes,
        constants: constants$5,
        KeyObject,
        createSecretKey,
        createPublicKey,
        createPrivateKey
    };
    var cryptoShim = Object.freeze({
        __proto__: null,
        KeyObject: KeyObject,
        constants: constants$5,
        createHash: createHash,
        createHmac: createHmac,
        createPrivateKey: createPrivateKey,
        createPublicKey: createPublicKey,
        createSecretKey: createSecretKey,
        createSign: createSign,
        createVerify: createVerify,
        default: crypto$1,
        getCiphers: getCiphers$1,
        getHashes: getHashes,
        getRandomValues: getRandomValues,
        pbkdf2: pbkdf2,
        pbkdf2Sync: pbkdf2Sync,
        randomBytes: randomBytes,
        randomFillSync: randomFillSync,
        randomInt: randomInt,
        randomUUID: randomUUID,
        sign: sign,
        timingSafeEqual: timingSafeEqual,
        verify: verify
    });
    const _isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    const _BrowserWebSocket = _isBrowser && typeof globalThis.WebSocket === "function" ? globalThis.WebSocket : null;
    class IncomingMessage extends Readable {
        httpVersion = "1.1";
        httpVersionMajor = 1;
        httpVersionMinor = 1;
        complete = false;
        headers = {};
        rawHeaders = [];
        trailers = {};
        rawTrailers = [];
        method;
        url;
        statusCode;
        statusMessage;
        socket;
        _body = null;
        constructor(socket){
            super();
            this.socket = socket || new Socket$1();
        }
        setTimeout(msecs, callback) {
            if (callback) {
                this.once("timeout", callback);
            }
            return this;
        }
        destroy(error) {
            super.destroy(error);
            return this;
        }
        _setBody(body) {
            if (body === null) {
                this._body = null;
            } else {
                this._body = typeof body === "string" ? BufferPolyfill.from(body) : body;
            }
            if (this._body) {
                this.push(this._body);
            }
            this.push(null);
            this.complete = true;
        }
        static fromRequest(method, url, headers, body) {
            const msg = new IncomingMessage();
            msg.method = method;
            msg.url = url;
            msg.headers = {
                ...headers
            };
            for (const [key, value] of Object.entries(headers)){
                msg.rawHeaders.push(key, value);
            }
            if (body) {
                msg._setBody(body);
            } else {
                msg.push(null);
                msg.complete = true;
            }
            return msg;
        }
    }
    class ServerResponse extends Writable {
        statusCode = 200;
        statusMessage = "OK";
        headersSent = false;
        finished = false;
        sendDate = true;
        socket;
        _headers = new Map();
        _body = [];
        _resolve;
        constructor(req){
            super();
            this.socket = req.socket;
        }
        _setResolver(resolve) {
            this._resolve = resolve;
        }
        setHeader(name, value) {
            if (this.headersSent) {
                throw new Error("Cannot set headers after they are sent");
            }
            this._headers.set(name.toLowerCase(), String(value));
            return this;
        }
        getHeader(name) {
            return this._headers.get(name.toLowerCase());
        }
        getHeaders() {
            const headers = {};
            for (const [key, value] of this._headers){
                headers[key] = value;
            }
            return headers;
        }
        getHeaderNames() {
            return [
                ...this._headers.keys()
            ];
        }
        hasHeader(name) {
            return this._headers.has(name.toLowerCase());
        }
        removeHeader(name) {
            if (this.headersSent) {
                throw new Error("Cannot remove headers after they are sent");
            }
            this._headers.delete(name.toLowerCase());
        }
        writeHead(statusCode, statusMessageOrHeaders, headers) {
            this.statusCode = statusCode;
            if (typeof statusMessageOrHeaders === "string") {
                this.statusMessage = statusMessageOrHeaders;
                if (headers) {
                    for (const [key, value] of Object.entries(headers)){
                        this.setHeader(key, value);
                    }
                }
            } else if (statusMessageOrHeaders) {
                for (const [key, value] of Object.entries(statusMessageOrHeaders)){
                    this.setHeader(key, value);
                }
            }
            return this;
        }
        write(chunk, encodingOrCallback, callback) {
            this.headersSent = true;
            const buffer = typeof chunk === "string" ? BufferPolyfill.from(chunk) : chunk;
            this._body.push(buffer);
            const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
            if (cb) {
                queueMicrotask(()=>cb(null));
            }
            return true;
        }
        end(chunkOrCallback, encodingOrCallback, callback) {
            if (typeof chunkOrCallback === "function") {
                callback = chunkOrCallback;
            } else if (chunkOrCallback !== void 0) {
                this.write(chunkOrCallback);
            }
            if (typeof encodingOrCallback === "function") {
                callback = encodingOrCallback;
            }
            this.headersSent = true;
            this.finished = true;
            if (this._resolve) {
                const headers = {};
                for (const [key, value] of this._headers){
                    headers[key] = Array.isArray(value) ? value.join(", ") : value;
                }
                this._resolve({
                    statusCode: this.statusCode,
                    statusMessage: this.statusMessage,
                    headers,
                    body: BufferPolyfill.concat(this._body)
                });
            }
            queueMicrotask(()=>{
                this.emit("finish");
                if (callback) callback();
            });
            return this;
        }
        send(data) {
            if (typeof data === "object" && !BufferPolyfill.isBuffer(data)) {
                this.setHeader("Content-Type", "application/json");
                data = JSON.stringify(data);
            }
            if (!this.hasHeader("Content-Type")) {
                this.setHeader("Content-Type", "text/html");
            }
            this.write(typeof data === "string" ? data : data);
            return this.end();
        }
        json(data) {
            this.setHeader("Content-Type", "application/json");
            return this.end(JSON.stringify(data));
        }
        status(code) {
            this.statusCode = code;
            return this;
        }
        redirect(urlOrStatus, url) {
            if (typeof urlOrStatus === "number") {
                this.statusCode = urlOrStatus;
                this.setHeader("Location", url);
            } else {
                this.statusCode = 302;
                this.setHeader("Location", urlOrStatus);
            }
            this.end();
        }
        _getBody() {
            return BufferPolyfill.concat(this._body);
        }
        _getBodyAsString() {
            return this._getBody().toString("utf8");
        }
    }
    let Server$2 = class Server extends EventEmitter {
        _netServer;
        _requestListener;
        _pendingRequests = new Map();
        listening = false;
        maxHeadersCount = null;
        timeout = 0;
        keepAliveTimeout = 5e3;
        headersTimeout = 6e4;
        requestTimeout = 0;
        constructor(requestListener){
            super();
            this._requestListener = requestListener;
            this._netServer = new Server$3();
            this._netServer.on("listening", ()=>{
                this.listening = true;
                this.emit("listening");
            });
            this._netServer.on("close", ()=>{
                this.listening = false;
                this.emit("close");
            });
            this._netServer.on("error", (err)=>{
                this.emit("error", err);
            });
        }
        listen(portOrOptions, hostOrCallback, callback) {
            let port;
            let host;
            let cb;
            if (typeof portOrOptions === "number") {
                port = portOrOptions;
                if (typeof hostOrCallback === "string") {
                    host = hostOrCallback;
                    cb = callback;
                } else {
                    cb = hostOrCallback;
                }
            } else if (portOrOptions) {
                port = portOrOptions.port;
                host = portOrOptions.host;
                cb = typeof hostOrCallback === "function" ? hostOrCallback : callback;
            }
            const originalCb = cb;
            const self = this;
            cb = function() {
                const addr = self._netServer.address();
                if (addr) {
                    _registerServer(addr.port, self);
                }
                if (originalCb) originalCb();
            };
            this._netServer.listen(port, host, cb);
            return this;
        }
        close(callback) {
            const addr = this._netServer.address();
            if (addr) {
                _unregisterServer(addr.port);
            }
            this._netServer.close(callback);
            return this;
        }
        address() {
            return this._netServer.address();
        }
        setTimeout(msecs, callback) {
            this.timeout = msecs || 0;
            if (callback) {
                this.on("timeout", callback);
            }
            return this;
        }
        ref() {
            this._netServer.ref();
            return this;
        }
        unref() {
            this._netServer.unref();
            return this;
        }
        async handleRequest(method, url, headers, body) {
            return new Promise((resolve, reject)=>{
                const req = IncomingMessage.fromRequest(method, url, headers, body);
                const res = new ServerResponse(req);
                res._setResolver(resolve);
                const timeoutId = this.timeout ? setTimeout(()=>{
                    reject(new Error("Request timeout"));
                }, this.timeout) : null;
                res.on("finish", ()=>{
                    if (timeoutId) clearTimeout(timeoutId);
                });
                try {
                    this.emit("request", req, res);
                    if (this._requestListener) {
                        this._requestListener(req, res);
                    }
                } catch (error) {
                    if (timeoutId) clearTimeout(timeoutId);
                    reject(error);
                }
            });
        }
    };
    function createServer$2(requestListener) {
        return new Server$2(requestListener);
    }
    const STATUS_CODES = {
        100: "Continue",
        101: "Switching Protocols",
        200: "OK",
        201: "Created",
        202: "Accepted",
        204: "No Content",
        301: "Moved Permanently",
        302: "Found",
        304: "Not Modified",
        400: "Bad Request",
        401: "Unauthorized",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        408: "Request Timeout",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable"
    };
    const METHODS = [
        "GET",
        "POST",
        "PUT",
        "DELETE",
        "PATCH",
        "HEAD",
        "OPTIONS",
        "CONNECT",
        "TRACE"
    ];
    function getCorsProxy() {
        if (typeof localStorage !== "undefined") {
            return localStorage.getItem("__corsProxyUrl") || null;
        }
        return null;
    }
    class ClientRequest extends Writable {
        method;
        path;
        headers;
        _options;
        _protocol;
        _bodyChunks = [];
        _aborted = false;
        _timeout = null;
        _timeoutId = null;
        _requestEnded = false;
        constructor(options, protocol = "http"){
            super();
            this._options = options;
            this._protocol = protocol;
            this.method = options.method || "GET";
            this.path = options.path || "/";
            this.headers = {};
            if (options.headers) {
                for (const [key, value] of Object.entries(options.headers)){
                    this.headers[key.toLowerCase()] = Array.isArray(value) ? value.join(", ") : value;
                }
            }
        }
        setHeader(name, value) {
            this.headers[name.toLowerCase()] = value;
        }
        getHeader(name) {
            return this.headers[name.toLowerCase()];
        }
        removeHeader(name) {
            delete this.headers[name.toLowerCase()];
        }
        write(chunk, encodingOrCallback, callback) {
            const buffer = typeof chunk === "string" ? BufferPolyfill.from(chunk) : chunk;
            this._bodyChunks.push(buffer);
            const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
            if (cb) {
                queueMicrotask(()=>cb(null));
            }
            return true;
        }
        end(dataOrCallback, encodingOrCallback, callback) {
            if (this._requestEnded) return this;
            this._requestEnded = true;
            let finalCallback = callback;
            if (typeof dataOrCallback === "function") {
                finalCallback = dataOrCallback;
            } else if (dataOrCallback !== void 0) {
                this.write(dataOrCallback);
            }
            if (typeof encodingOrCallback === "function") {
                finalCallback = encodingOrCallback;
            }
            this._performRequest().then(()=>{
                if (finalCallback) finalCallback();
            }).catch((error)=>{
                this.emit("error", error);
            });
            return this;
        }
        abort() {
            this._aborted = true;
            if (this._timeoutId) {
                clearTimeout(this._timeoutId);
            }
            this.emit("abort");
        }
        setTimeout(ms, callback) {
            this._timeout = ms;
            if (callback) {
                this.once("timeout", callback);
            }
            return this;
        }
        async _performRequest() {
            if (this._aborted) return;
            try {
                const protocol = this._protocol === "https" ? "https:" : "http:";
                let hostname = this._options.hostname || "";
                let port = this._options.port ? `:${this._options.port}` : "";
                if (!hostname && this._options.host) {
                    const hostParts = this._options.host.split(":");
                    hostname = hostParts[0];
                    if (!port && hostParts[1]) {
                        port = `:${hostParts[1]}`;
                    }
                }
                if (!hostname) hostname = "localhost";
                const path = this._options.path || "/";
                const url = `${protocol}//${hostname}${port}${path}`;
                if (this.headers["upgrade"]?.toLowerCase() === "websocket") {
                    this._handleWebSocketUpgrade(url);
                    return;
                }
                const corsProxy = getCorsProxy();
                const fetchUrl = corsProxy ? corsProxy + encodeURIComponent(url) : url;
                const fetchOptions = {
                    method: this.method,
                    headers: this.headers
                };
                if (this._bodyChunks.length > 0 && this.method !== "GET" && this.method !== "HEAD") {
                    fetchOptions.body = BufferPolyfill.concat(this._bodyChunks);
                }
                const controller = new AbortController();
                fetchOptions.signal = controller.signal;
                if (this._timeout) {
                    this._timeoutId = setTimeout(()=>{
                        controller.abort();
                        this.emit("timeout");
                    }, this._timeout);
                }
                const response = await fetch(fetchUrl, fetchOptions);
                if (this._timeoutId) {
                    clearTimeout(this._timeoutId);
                    this._timeoutId = null;
                }
                if (this._aborted) return;
                const incomingMessage = await this._responseToIncomingMessage(response);
                this.emit("response", incomingMessage);
            } catch (error) {
                if (this._timeoutId) {
                    clearTimeout(this._timeoutId);
                }
                if (this._aborted) return;
                if (error instanceof Error && error.name === "AbortError") {
                    return;
                }
                this.emit("error", error);
            }
        }
        async _responseToIncomingMessage(response) {
            const msg = new IncomingMessage();
            msg.statusCode = response.status;
            msg.statusMessage = response.statusText || STATUS_CODES[response.status] || "";
            response.headers.forEach((value, key)=>{
                msg.headers[key.toLowerCase()] = value;
                msg.rawHeaders.push(key, value);
            });
            const body = await response.arrayBuffer();
            msg._setBody(BufferPolyfill.from(body));
            return msg;
        }
        _handleWebSocketUpgrade(url) {
            const wsUrl = url.replace(/^https:/, "wss:").replace(/^http:/, "ws:");
            const wsKey = this.headers["sec-websocket-key"] || "";
            const NativeWS = _BrowserWebSocket;
            if (!NativeWS) {
                setTimeout(()=>{
                    this.emit("error", new TypeError("Failed to fetch"));
                }, 0);
                return;
            }
            const GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
            const acceptValue = createHash("sha1").update(wsKey + GUID).digest("base64");
            let nativeWs;
            try {
                nativeWs = new NativeWS(wsUrl);
                nativeWs.binaryType = "arraybuffer";
            } catch (e) {
                setTimeout(()=>{
                    this.emit("error", e instanceof Error ? e : new Error(String(e)));
                }, 0);
                return;
            }
            const socket = new Socket$1();
            if (typeof socket.cork !== "function") socket.cork = ()=>{};
            if (typeof socket.uncork !== "function") socket.uncork = ()=>{};
            socket._readableState = {
                endEmitted: false
            };
            socket._writableState = {
                finished: false,
                errorEmitted: false
            };
            let writeBuffer = new Uint8Array(0);
            socket.write = (chunk, encodingOrCallback, callback)=>{
                const data = typeof chunk === "string" ? BufferPolyfill.from(chunk) : new Uint8Array(chunk);
                const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
                const newBuf = new Uint8Array(writeBuffer.length + data.length);
                newBuf.set(writeBuffer, 0);
                newBuf.set(data, writeBuffer.length);
                writeBuffer = newBuf;
                while(writeBuffer.length >= 2){
                    const parsed = _parseWsFrame(writeBuffer);
                    if (!parsed) break;
                    const { opcode, payload, totalLength } = parsed;
                    writeBuffer = writeBuffer.slice(totalLength);
                    if (nativeWs.readyState !== NativeWS.OPEN) continue;
                    if (opcode === 8) {
                        nativeWs.close();
                    } else if (opcode === 9) {
                        nativeWs.send(payload);
                    } else if (opcode === 10) ;
                    else if (opcode === 1) {
                        const text = new TextDecoder().decode(payload);
                        nativeWs.send(text);
                    } else if (opcode === 2) {
                        nativeWs.send(payload);
                    }
                }
                if (cb) queueMicrotask(()=>cb(null));
                return true;
            };
            nativeWs.onopen = ()=>{
                const response = new IncomingMessage(socket);
                response.statusCode = 101;
                response.statusMessage = "Switching Protocols";
                response.headers = {
                    "upgrade": "websocket",
                    "connection": "Upgrade",
                    "sec-websocket-accept": acceptValue
                };
                response.complete = true;
                response.push(null);
                this.emit("upgrade", response, socket, BufferPolyfill.alloc(0));
            };
            nativeWs.onmessage = (event)=>{
                let payload;
                let opcode;
                if (typeof event.data === "string") {
                    payload = new TextEncoder().encode(event.data);
                    opcode = 1;
                } else if (event.data instanceof ArrayBuffer) {
                    payload = new Uint8Array(event.data);
                    opcode = 2;
                } else {
                    return;
                }
                const frame = _createWsFrame(opcode, payload, false);
                socket._receiveData(BufferPolyfill.from(frame));
            };
            nativeWs.onclose = (event)=>{
                const code = event.code || 1e3;
                const closePayload = new Uint8Array(2);
                closePayload[0] = code >> 8 & 255;
                closePayload[1] = code & 255;
                const frame = _createWsFrame(8, closePayload, false);
                socket._receiveData(BufferPolyfill.from(frame));
                setTimeout(()=>{
                    socket._readableState.endEmitted = true;
                    socket._receiveEnd();
                    socket.emit("close", false);
                }, 10);
            };
            nativeWs.onerror = ()=>{
                socket.emit("error", new Error("WebSocket connection error"));
                socket.destroy();
            };
            const origDestroy = socket.destroy.bind(socket);
            socket.destroy = (error)=>{
                if (nativeWs.readyState === NativeWS.OPEN || nativeWs.readyState === NativeWS.CONNECTING) {
                    nativeWs.close();
                }
                return origDestroy(error);
            };
        }
    }
    function parseRequestArgs(urlOrOptions, optionsOrCallback, callback) {
        let options;
        let cb = callback;
        if (typeof urlOrOptions === "string" || urlOrOptions instanceof URL) {
            const parsed = new URL(urlOrOptions.toString());
            options = {
                hostname: parsed.hostname,
                port: parsed.port ? parseInt(parsed.port) : void 0,
                path: parsed.pathname + parsed.search,
                method: "GET"
            };
            if (typeof optionsOrCallback === "function") {
                cb = optionsOrCallback;
            } else if (optionsOrCallback) {
                options = {
                    ...options,
                    ...optionsOrCallback
                };
            }
        } else {
            options = urlOrOptions;
            if (typeof optionsOrCallback === "function") {
                cb = optionsOrCallback;
            }
        }
        return {
            options,
            callback: cb
        };
    }
    function request$1(urlOrOptions, optionsOrCallback, callback) {
        const { options, callback: cb } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
        const req = new ClientRequest(options, "http");
        if (cb) {
            req.once("response", cb);
        }
        return req;
    }
    function get$1(urlOrOptions, optionsOrCallback, callback) {
        const { options, callback: cb } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
        const req = new ClientRequest({
            ...options,
            method: "GET"
        }, "http");
        if (cb) {
            req.once("response", cb);
        }
        req.end();
        return req;
    }
    function _createClientRequest(urlOrOptions, optionsOrCallback, callback, protocol) {
        const { options, callback: cb } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
        const req = new ClientRequest(options, protocol);
        if (cb) {
            req.once("response", cb);
        }
        return req;
    }
    const serverRegistry = new Map();
    let onServerListenCallback = null;
    let onServerCloseCallback = null;
    function _registerServer(port, server) {
        serverRegistry.set(port, server);
        if (onServerListenCallback) {
            onServerListenCallback(port, server);
        }
    }
    function _unregisterServer(port) {
        serverRegistry.delete(port);
        if (onServerCloseCallback) {
            onServerCloseCallback(port);
        }
    }
    function getServer(port) {
        return serverRegistry.get(port);
    }
    function getAllServers() {
        return new Map(serverRegistry);
    }
    function setServerListenCallback(callback) {
        onServerListenCallback = callback;
    }
    function setServerCloseCallback(callback) {
        onServerCloseCallback = callback;
    }
    class Agent extends EventEmitter {
        maxSockets;
        maxFreeSockets;
        maxTotalSockets;
        sockets;
        freeSockets;
        requests;
        options;
        constructor(opts){
            super();
            this.options = opts || {};
            this.maxSockets = opts?.maxSockets ?? Infinity;
            this.maxFreeSockets = opts?.maxFreeSockets ?? 256;
            this.maxTotalSockets = opts?.maxTotalSockets ?? Infinity;
            this.sockets = {};
            this.freeSockets = {};
            this.requests = {};
        }
        createConnection(_options, callback) {
            const socket = new Socket$1();
            if (callback) {
                callback(null, socket);
            }
            return socket;
        }
        getName(options) {
            const host = options.host || "localhost";
            const port = options.port || 80;
            return `${host}:${port}:${options.localAddress || ""}`;
        }
        addRequest(_req, _options) {}
        destroy() {
            this.sockets = {};
            this.freeSockets = {};
            this.requests = {};
        }
    }
    const globalAgent = new Agent();
    function _parseWsFrame(data) {
        if (data.length < 2) return null;
        const opcode = data[0] & 15;
        const masked = (data[1] & 128) !== 0;
        let payloadLength = data[1] & 127;
        let offset = 2;
        if (payloadLength === 126) {
            if (data.length < 4) return null;
            payloadLength = data[2] << 8 | data[3];
            offset = 4;
        } else if (payloadLength === 127) {
            if (data.length < 10) return null;
            payloadLength = data[6] << 24 | data[7] << 16 | data[8] << 8 | data[9];
            offset = 10;
        }
        if (masked) {
            if (data.length < offset + 4 + payloadLength) return null;
            const maskKey = data.slice(offset, offset + 4);
            offset += 4;
            const payload = new Uint8Array(payloadLength);
            for(let i = 0; i < payloadLength; i++){
                payload[i] = data[offset + i] ^ maskKey[i % 4];
            }
            return {
                opcode,
                payload,
                totalLength: offset + payloadLength
            };
        } else {
            if (data.length < offset + payloadLength) return null;
            const payload = data.slice(offset, offset + payloadLength);
            return {
                opcode,
                payload,
                totalLength: offset + payloadLength
            };
        }
    }
    function _createWsFrame(opcode, payload, masked) {
        const length = payload.length;
        let headerSize = 2;
        if (length > 125 && length <= 65535) {
            headerSize += 2;
        } else if (length > 65535) {
            headerSize += 8;
        }
        if (masked) {
            headerSize += 4;
        }
        const frame = new Uint8Array(headerSize + length);
        frame[0] = 128 | opcode;
        let offset = 2;
        if (length <= 125) {
            frame[1] = (masked ? 128 : 0) | length;
        } else if (length <= 65535) {
            frame[1] = (masked ? 128 : 0) | 126;
            frame[2] = length >> 8 & 255;
            frame[3] = length & 255;
            offset = 4;
        } else {
            frame[1] = (masked ? 128 : 0) | 127;
            frame[2] = 0;
            frame[3] = 0;
            frame[4] = 0;
            frame[5] = 0;
            frame[6] = length >> 24 & 255;
            frame[7] = length >> 16 & 255;
            frame[8] = length >> 8 & 255;
            frame[9] = length & 255;
            offset = 10;
        }
        if (masked) {
            const maskKey = new Uint8Array(4);
            if (typeof crypto !== "undefined" && crypto.getRandomValues) {
                crypto.getRandomValues(maskKey);
            } else {
                for(let i = 0; i < 4; i++)maskKey[i] = Math.floor(Math.random() * 256);
            }
            frame.set(maskKey, offset);
            offset += 4;
            for(let i = 0; i < length; i++){
                frame[offset + i] = payload[i] ^ maskKey[i % 4];
            }
        } else {
            frame.set(payload, offset);
        }
        return frame;
    }
    var http = {
        Server: Server$2,
        IncomingMessage,
        ServerResponse,
        ClientRequest,
        createServer: createServer$2,
        request: request$1,
        get: get$1,
        STATUS_CODES,
        METHODS,
        getServer,
        getAllServers,
        setServerListenCallback,
        setServerCloseCallback,
        _createClientRequest,
        Agent,
        globalAgent,
        _parseWsFrame,
        _createWsFrame
    };
    var httpShim = Object.freeze({
        __proto__: null,
        Agent: Agent,
        ClientRequest: ClientRequest,
        IncomingMessage: IncomingMessage,
        METHODS: METHODS,
        STATUS_CODES: STATUS_CODES,
        Server: Server$2,
        ServerResponse: ServerResponse,
        _createClientRequest: _createClientRequest,
        _createWsFrame: _createWsFrame,
        _parseWsFrame: _parseWsFrame,
        _registerServer: _registerServer,
        _unregisterServer: _unregisterServer,
        createServer: createServer$2,
        default: http,
        get: get$1,
        getAllServers: getAllServers,
        getServer: getServer,
        globalAgent: globalAgent,
        request: request$1,
        setServerCloseCallback: setServerCloseCallback,
        setServerListenCallback: setServerListenCallback
    });
    function request(urlOrOptions, optionsOrCallback, callback) {
        return _createClientRequest(urlOrOptions, optionsOrCallback, callback, "https");
    }
    function get(urlOrOptions, optionsOrCallback, callback) {
        const req = _createClientRequest(urlOrOptions, optionsOrCallback, callback, "https");
        req.end();
        return req;
    }
    var https = {
        Server: Server$2,
        IncomingMessage,
        ServerResponse,
        ClientRequest,
        createServer: createServer$2,
        request,
        get,
        STATUS_CODES,
        METHODS,
        getServer,
        getAllServers,
        setServerListenCallback,
        setServerCloseCallback,
        Agent,
        globalAgent
    };
    var httpsShim = Object.freeze({
        __proto__: null,
        Agent: Agent,
        ClientRequest: ClientRequest,
        IncomingMessage: IncomingMessage,
        METHODS: METHODS,
        STATUS_CODES: STATUS_CODES,
        Server: Server$2,
        ServerResponse: ServerResponse,
        createServer: createServer$2,
        default: https,
        get: get,
        getAllServers: getAllServers,
        getServer: getServer,
        globalAgent: globalAgent,
        request: request,
        setServerCloseCallback: setServerCloseCallback,
        setServerListenCallback: setServerListenCallback
    });
    function parse$1(urlString, parseQueryString = false, slashesDenoteHost = false) {
        try {
            const url = new URL$1(urlString, "http://localhost");
            const result = {
                protocol: url.protocol,
                slashes: url.protocol.endsWith(":"),
                auth: url.username ? `${url.username}:${url.password}` : null,
                host: url.host,
                port: url.port || null,
                hostname: url.hostname,
                hash: url.hash || null,
                search: url.search || null,
                query: parseQueryString ? Object.fromEntries(url.searchParams) : url.search?.slice(1) || null,
                pathname: url.pathname,
                path: url.pathname + url.search,
                href: url.href
            };
            return result;
        } catch  {
            return {
                protocol: null,
                slashes: null,
                auth: null,
                host: null,
                port: null,
                hostname: null,
                hash: null,
                search: null,
                query: null,
                pathname: urlString,
                path: urlString,
                href: urlString
            };
        }
    }
    function format$1(urlObject) {
        if (urlObject.href) {
            return urlObject.href;
        }
        let result = "";
        if (urlObject.protocol) {
            result += urlObject.protocol;
            if (!urlObject.protocol.endsWith(":")) {
                result += ":";
            }
        }
        if (urlObject.slashes || urlObject.protocol === "http:" || urlObject.protocol === "https:") {
            result += "//";
        }
        if (urlObject.auth) {
            result += urlObject.auth + "@";
        }
        if (urlObject.hostname) {
            result += urlObject.hostname;
        } else if (urlObject.host) {
            result += urlObject.host;
        }
        if (urlObject.port) {
            result += ":" + urlObject.port;
        }
        if (urlObject.pathname) {
            result += urlObject.pathname;
        }
        if (urlObject.search) {
            result += urlObject.search;
        } else if (urlObject.query) {
            if (typeof urlObject.query === "string") {
                result += "?" + urlObject.query;
            } else {
                const params = new URLSearchParams();
                for (const [key, value] of Object.entries(urlObject.query)){
                    if (Array.isArray(value)) {
                        for (const v of value){
                            params.append(key, v);
                        }
                    } else {
                        params.set(key, value);
                    }
                }
                const search = params.toString();
                if (search) {
                    result += "?" + search;
                }
            }
        }
        if (urlObject.hash) {
            result += urlObject.hash;
        }
        return result;
    }
    function resolve$1(from, to) {
        try {
            return new URL$1(to, from).href;
        } catch  {
            return to;
        }
    }
    const URL$1 = globalThis.URL;
    const URLSearchParams = globalThis.URLSearchParams;
    function fileURLToPath(url) {
        const urlObj = typeof url === "string" ? new globalThis.URL(url) : url;
        if (urlObj.protocol !== "file:") {
            throw new TypeError("The URL must be of scheme file");
        }
        return decodeURIComponent(urlObj.pathname);
    }
    function pathToFileURL(path) {
        const encoded = encodeURIComponent(path).replace(/%2F/g, "/");
        return new globalThis.URL("file://" + encoded);
    }
    var url$1 = {
        parse: parse$1,
        format: format$1,
        resolve: resolve$1,
        URL: URL$1,
        URLSearchParams,
        fileURLToPath,
        pathToFileURL
    };
    var urlShim = Object.freeze({
        __proto__: null,
        URL: URL$1,
        URLSearchParams: URLSearchParams,
        default: url$1,
        fileURLToPath: fileURLToPath,
        format: format$1,
        parse: parse$1,
        pathToFileURL: pathToFileURL,
        resolve: resolve$1
    });
    function parse(str, sep = "&", eq = "=", options) {
        const result = {};
        if (!str || typeof str !== "string") {
            return result;
        }
        const maxKeys = options?.maxKeys || 1e3;
        const pairs = str.split(sep).slice(0, maxKeys > 0 ? maxKeys : void 0);
        for (const pair of pairs){
            const idx = pair.indexOf(eq);
            let key;
            let value;
            if (idx >= 0) {
                key = decodeURIComponent(pair.slice(0, idx).replace(/\+/g, " "));
                value = decodeURIComponent(pair.slice(idx + 1).replace(/\+/g, " "));
            } else {
                key = decodeURIComponent(pair.replace(/\+/g, " "));
                value = "";
            }
            if (key in result) {
                const existing = result[key];
                if (Array.isArray(existing)) {
                    existing.push(value);
                } else {
                    result[key] = [
                        existing,
                        value
                    ];
                }
            } else {
                result[key] = value;
            }
        }
        return result;
    }
    function stringify(obj, sep = "&", eq = "=") {
        if (!obj || typeof obj !== "object") {
            return "";
        }
        const pairs = [];
        for (const [key, value] of Object.entries(obj)){
            if (value === void 0) continue;
            const encodedKey = encodeURIComponent(key);
            if (Array.isArray(value)) {
                for (const v of value){
                    pairs.push(`${encodedKey}${eq}${encodeURIComponent(String(v))}`);
                }
            } else {
                pairs.push(`${encodedKey}${eq}${encodeURIComponent(String(value))}`);
            }
        }
        return pairs.join(sep);
    }
    function escape$1(str) {
        return encodeURIComponent(str);
    }
    function unescape$1(str) {
        return decodeURIComponent(str.replace(/\+/g, " "));
    }
    const encode = stringify;
    const decode = parse;
    var querystring = {
        parse,
        stringify,
        escape: escape$1,
        unescape: unescape$1,
        encode,
        decode
    };
    var querystringShim = Object.freeze({
        __proto__: null,
        decode: decode,
        default: querystring,
        encode: encode,
        escape: escape$1,
        parse: parse,
        stringify: stringify,
        unescape: unescape$1
    });
    var define_process_env_default$2 = {};
    function format(fmt, ...args) {
        if (typeof fmt !== "string") {
            return args.map((arg)=>inspect(arg)).join(" ");
        }
        let i = 0;
        return fmt.replace(/%[sdjifoO%]/g, (match)=>{
            if (match === "%%") return "%";
            if (i >= args.length) return match;
            const arg = args[i++];
            switch(match){
                case "%s":
                    return String(arg);
                case "%d":
                case "%i":
                    return String(parseInt(String(arg), 10));
                case "%f":
                    return String(parseFloat(String(arg)));
                case "%j":
                    try {
                        return JSON.stringify(arg);
                    } catch  {
                        return "[Circular]";
                    }
                case "%o":
                case "%O":
                    return inspect(arg);
                default:
                    return match;
            }
        });
    }
    function inspect(obj, options) {
        const seen = new WeakSet();
        const depth = options?.depth ?? 2;
        function inspectValue(value, currentDepth) {
            if (value === null) return "null";
            if (value === void 0) return "undefined";
            const type = typeof value;
            if (type === "string") {
                return `'${value}'`;
            }
            if (type === "number" || type === "boolean" || type === "bigint") {
                return String(value);
            }
            if (type === "symbol") {
                return value.toString();
            }
            if (type === "function") {
                const name = value.name || "anonymous";
                return `[Function: ${name}]`;
            }
            if (type !== "object") {
                return String(value);
            }
            if (seen.has(value)) {
                return "[Circular]";
            }
            seen.add(value);
            if (currentDepth > depth) {
                return Array.isArray(value) ? "[Array]" : "[Object]";
            }
            if (Array.isArray(value)) {
                if (value.length === 0) return "[]";
                const items = value.map((v)=>inspectValue(v, currentDepth + 1));
                return `[ ${items.join(", ")} ]`;
            }
            if (value instanceof Date) {
                return value.toISOString();
            }
            if (value instanceof RegExp) {
                return value.toString();
            }
            if (value instanceof Error) {
                return `${value.name}: ${value.message}`;
            }
            if (value instanceof Map) {
                const entries2 = [
                    ...value.entries()
                ].map(([k, v])=>`${inspectValue(k, currentDepth + 1)} => ${inspectValue(v, currentDepth + 1)}`);
                return `Map(${value.size}) { ${entries2.join(", ")} }`;
            }
            if (value instanceof Set) {
                const items = [
                    ...value
                ].map((v)=>inspectValue(v, currentDepth + 1));
                return `Set(${value.size}) { ${items.join(", ")} }`;
            }
            const keys = Object.keys(value);
            if (keys.length === 0) return "{}";
            const entries = keys.map((key)=>{
                const val = value[key];
                return `${key}: ${inspectValue(val, currentDepth + 1)}`;
            });
            return `{ ${entries.join(", ")} }`;
        }
        return inspectValue(obj, 0);
    }
    function inherits(ctor, superCtor) {
        if (ctor === void 0 || ctor === null) {
            throw new TypeError("inherits: ctor must be a function");
        }
        if (superCtor === void 0 || superCtor === null) {
            return;
        }
        if (superCtor.prototype === void 0) {
            return;
        }
        ctor.super_ = superCtor;
        Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
    }
    function deprecate(fn, msg, code) {
        let warned = false;
        const deprecated = function(...args) {
            if (!warned) {
                console.warn(`DeprecationWarning: ${msg}${code ? ` (${code})` : ""}`);
                warned = true;
            }
            return fn.apply(this, args);
        };
        return deprecated;
    }
    function promisify(fn) {
        return (...args)=>{
            return new Promise((resolve, reject)=>{
                fn(...args, (err, result)=>{
                    if (err) {
                        reject(err);
                    } else {
                        resolve(result);
                    }
                });
            });
        };
    }
    function callbackify(fn) {
        return (...args)=>{
            const callback = args.pop();
            fn(...args).then((result)=>callback(null, result)).catch((err)=>callback(err, void 0));
        };
    }
    function isArray(value) {
        return Array.isArray(value);
    }
    function isBoolean(value) {
        return typeof value === "boolean";
    }
    function isNull(value) {
        return value === null;
    }
    function isNullOrUndefined(value) {
        return value === null || value === void 0;
    }
    function isNumber(value) {
        return typeof value === "number";
    }
    function isString(value) {
        return typeof value === "string";
    }
    function isUndefined(value) {
        return value === void 0;
    }
    function isRegExp(value) {
        return value instanceof RegExp;
    }
    function isObject(value) {
        return typeof value === "object" && value !== null;
    }
    function isDate(value) {
        return value instanceof Date;
    }
    function isError(value) {
        return value instanceof Error;
    }
    function isFunction(value) {
        return typeof value === "function";
    }
    function isPrimitive(value) {
        return value === null || typeof value !== "object" && typeof value !== "function";
    }
    function isBuffer(value) {
        return value instanceof Uint8Array;
    }
    function debuglog(section) {
        const nodeDebug = typeof process !== "undefined" && define_process_env_default$2?.NODE_DEBUG || "";
        const enabled = nodeDebug.toLowerCase().includes(section.toLowerCase());
        if (enabled) {
            return (...args)=>{
                console.error(`${section.toUpperCase()} ${process?.pid || 0}:`, ...args);
            };
        }
        return ()=>{};
    }
    const debug = debuglog;
    const types$1 = {
        isArray,
        isBoolean,
        isNull,
        isNullOrUndefined,
        isNumber,
        isString,
        isUndefined,
        isRegExp,
        isObject,
        isDate,
        isError,
        isFunction,
        isPrimitive,
        isBuffer
    };
    const TextEncoder$1 = globalThis.TextEncoder;
    const TextDecoder$1 = globalThis.TextDecoder;
    var util = {
        format,
        inspect,
        inherits,
        deprecate,
        promisify,
        callbackify,
        debuglog,
        debug,
        isArray,
        isBoolean,
        isNull,
        isNullOrUndefined,
        isNumber,
        isString,
        isUndefined,
        isRegExp,
        isObject,
        isDate,
        isError,
        isFunction,
        isPrimitive,
        isBuffer,
        types: types$1,
        TextEncoder: TextEncoder$1,
        TextDecoder: TextDecoder$1
    };
    var utilShim = Object.freeze({
        __proto__: null,
        TextDecoder: TextDecoder$1,
        TextEncoder: TextEncoder$1,
        callbackify: callbackify,
        debug: debug,
        debuglog: debuglog,
        default: util,
        deprecate: deprecate,
        format: format,
        inherits: inherits,
        inspect: inspect,
        isArray: isArray,
        isBoolean: isBoolean,
        isBuffer: isBuffer,
        isDate: isDate,
        isError: isError,
        isFunction: isFunction,
        isNull: isNull,
        isNullOrUndefined: isNullOrUndefined,
        isNumber: isNumber,
        isObject: isObject,
        isPrimitive: isPrimitive,
        isRegExp: isRegExp,
        isString: isString,
        isUndefined: isUndefined,
        promisify: promisify,
        types: types$1
    });
    class ReadStream extends Readable {
        isTTY = false;
        isRaw = false;
        setRawMode(mode) {
            this.isRaw = mode;
            return this;
        }
    }
    class WriteStream extends Writable {
        isTTY = false;
        columns = 80;
        rows = 24;
        clearLine(dir, callback) {
            if (callback) callback();
            return true;
        }
        clearScreenDown(callback) {
            if (callback) callback();
            return true;
        }
        cursorTo(x, y, callback) {
            if (callback) callback();
            return true;
        }
        moveCursor(dx, dy, callback) {
            if (callback) callback();
            return true;
        }
        getColorDepth(env) {
            return 1;
        }
        hasColors(count, env) {
            return false;
        }
        getWindowSize() {
            return [
                this.columns,
                this.rows
            ];
        }
    }
    function isatty(fd) {
        return false;
    }
    var tty = {
        ReadStream,
        WriteStream,
        isatty
    };
    var ttyShim = Object.freeze({
        __proto__: null,
        ReadStream: ReadStream,
        WriteStream: WriteStream,
        default: tty,
        isatty: isatty
    });
    function hostname() {
        return "localhost";
    }
    function platform() {
        return "linux";
    }
    function arch() {
        return "x64";
    }
    function type() {
        return "Linux";
    }
    function release() {
        return "5.10.0";
    }
    function version$1() {
        return "#1 SMP";
    }
    function machine() {
        return "x86_64";
    }
    function tmpdir() {
        return "/tmp";
    }
    function homedir() {
        return "/home/user";
    }
    function cpus() {
        const cpu = {
            model: "Virtual CPU",
            speed: 2400,
            times: {
                user: 0,
                nice: 0,
                sys: 0,
                idle: 0,
                irq: 0
            }
        };
        return [
            cpu,
            cpu
        ];
    }
    function totalmem() {
        return 4 * 1024 * 1024 * 1024;
    }
    function freemem() {
        return 2 * 1024 * 1024 * 1024;
    }
    function uptime() {
        return Math.floor(performance.now() / 1e3);
    }
    function loadavg() {
        return [
            0.5,
            0.5,
            0.5
        ];
    }
    function networkInterfaces() {
        return {
            lo: [
                {
                    address: "127.0.0.1",
                    netmask: "255.0.0.0",
                    family: "IPv4",
                    mac: "00:00:00:00:00:00",
                    internal: true,
                    cidr: "127.0.0.1/8"
                }
            ]
        };
    }
    function userInfo() {
        return {
            username: "user",
            uid: 1e3,
            gid: 1e3,
            shell: "/bin/bash",
            homedir: "/home/user"
        };
    }
    function endianness() {
        return "LE";
    }
    function getPriority(pid) {
        return 0;
    }
    function setPriority(pid, priority) {}
    const EOL = "\n";
    const constants$4 = {
        signals: {
            SIGHUP: 1,
            SIGINT: 2,
            SIGQUIT: 3,
            SIGILL: 4,
            SIGTRAP: 5,
            SIGABRT: 6,
            SIGBUS: 7,
            SIGFPE: 8,
            SIGKILL: 9,
            SIGUSR1: 10,
            SIGSEGV: 11,
            SIGUSR2: 12,
            SIGPIPE: 13,
            SIGALRM: 14,
            SIGTERM: 15,
            SIGCHLD: 17,
            SIGCONT: 18,
            SIGSTOP: 19,
            SIGTSTP: 20,
            SIGTTIN: 21,
            SIGTTOU: 22,
            SIGURG: 23,
            SIGXCPU: 24,
            SIGXFSZ: 25,
            SIGVTALRM: 26,
            SIGPROF: 27,
            SIGWINCH: 28,
            SIGIO: 29,
            SIGPWR: 30,
            SIGSYS: 31
        },
        errno: {},
        priority: {
            PRIORITY_LOW: 19,
            PRIORITY_BELOW_NORMAL: 10,
            PRIORITY_NORMAL: 0,
            PRIORITY_ABOVE_NORMAL: -7,
            PRIORITY_HIGH: -14,
            PRIORITY_HIGHEST: -20
        }
    };
    const devNull = "/dev/null";
    var os$1 = {
        hostname,
        platform,
        arch,
        type,
        release,
        version: version$1,
        machine,
        tmpdir,
        homedir,
        cpus,
        totalmem,
        freemem,
        uptime,
        loadavg,
        networkInterfaces,
        userInfo,
        endianness,
        getPriority,
        setPriority,
        EOL,
        constants: constants$4,
        devNull
    };
    var osShim = Object.freeze({
        __proto__: null,
        EOL: EOL,
        arch: arch,
        constants: constants$4,
        cpus: cpus,
        default: os$1,
        devNull: devNull,
        endianness: endianness,
        freemem: freemem,
        getPriority: getPriority,
        homedir: homedir,
        hostname: hostname,
        loadavg: loadavg,
        machine: machine,
        networkInterfaces: networkInterfaces,
        platform: platform,
        release: release,
        setPriority: setPriority,
        tmpdir: tmpdir,
        totalmem: totalmem,
        type: type,
        uptime: uptime,
        userInfo: userInfo,
        version: version$1
    });
    const Z_FIXED$1 = 4;
    const Z_BINARY = 0;
    const Z_TEXT = 1;
    const Z_UNKNOWN$1 = 2;
    function zero$1(buf) {
        let len = buf.length;
        while(--len >= 0){
            buf[len] = 0;
        }
    }
    const STORED_BLOCK = 0;
    const STATIC_TREES = 1;
    const DYN_TREES = 2;
    const MIN_MATCH$1 = 3;
    const MAX_MATCH$1 = 258;
    const LENGTH_CODES$1 = 29;
    const LITERALS$1 = 256;
    const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
    const D_CODES$1 = 30;
    const BL_CODES$1 = 19;
    const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
    const MAX_BITS$1 = 15;
    const Buf_size = 16;
    const MAX_BL_BITS = 7;
    const END_BLOCK = 256;
    const REP_3_6 = 16;
    const REPZ_3_10 = 17;
    const REPZ_11_138 = 18;
    const extra_lbits = (new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0
    ]));
    const extra_dbits = (new Uint8Array([
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13
    ]));
    const extra_blbits = (new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        3,
        7
    ]));
    const bl_order = new Uint8Array([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
    ]);
    const DIST_CODE_LEN = 512;
    const static_ltree = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    const static_dtree = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    const _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    const base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    const base_dist = new Array(D_CODES$1);
    zero$1(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
    }
    let static_l_desc;
    let static_d_desc;
    let static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
    }
    const d_code = (dist)=>{
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    const put_short = (s, w)=>{
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    const send_bits = (s, value, length)=>{
        if (s.bi_valid > Buf_size - length) {
            s.bi_buf |= value << s.bi_valid & 65535;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> Buf_size - s.bi_valid;
            s.bi_valid += length - Buf_size;
        } else {
            s.bi_buf |= value << s.bi_valid & 65535;
            s.bi_valid += length;
        }
    };
    const send_code = (s, c, tree)=>{
        send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    };
    const bi_reverse = (code, len)=>{
        let res = 0;
        do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
        }while (--len > 0);
        return res >>> 1;
    };
    const bi_flush = (s)=>{
        if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 255;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
        }
    };
    const gen_bitlen = (s, desc)=>{
        const tree = desc.dyn_tree;
        const max_code = desc.max_code;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const extra = desc.stat_desc.extra_bits;
        const base = desc.stat_desc.extra_base;
        const max_length = desc.stat_desc.max_length;
        let h;
        let n, m;
        let bits;
        let xbits;
        let f;
        let overflow = 0;
        for(bits = 0; bits <= MAX_BITS$1; bits++){
            s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for(h = s.heap_max + 1; h < HEAP_SIZE$1; h++){
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
                bits = max_length;
                overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > max_code) {
                continue;
            }
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
                xbits = extra[n - base];
            }
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
                s.static_len += f * (stree[n * 2 + 1] + xbits);
            }
        }
        if (overflow === 0) {
            return;
        }
        do {
            bits = max_length - 1;
            while(s.bl_count[bits] === 0){
                bits--;
            }
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
        }while (overflow > 0);
        for(bits = max_length; bits !== 0; bits--){
            n = s.bl_count[bits];
            while(n !== 0){
                m = s.heap[--h];
                if (m > max_code) {
                    continue;
                }
                if (tree[m * 2 + 1] !== bits) {
                    s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                    tree[m * 2 + 1] = bits;
                }
                n--;
            }
        }
    };
    const gen_codes = (tree, max_code, bl_count)=>{
        const next_code = new Array(MAX_BITS$1 + 1);
        let code = 0;
        let bits;
        let n;
        for(bits = 1; bits <= MAX_BITS$1; bits++){
            code = code + bl_count[bits - 1] << 1;
            next_code[bits] = code;
        }
        for(n = 0; n <= max_code; n++){
            let len = tree[n * 2 + 1];
            if (len === 0) {
                continue;
            }
            tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
    };
    const tr_static_init = ()=>{
        let n;
        let bits;
        let length;
        let code;
        let dist;
        const bl_count = new Array(MAX_BITS$1 + 1);
        length = 0;
        for(code = 0; code < LENGTH_CODES$1 - 1; code++){
            base_length[code] = length;
            for(n = 0; n < 1 << extra_lbits[code]; n++){
                _length_code[length++] = code;
            }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for(code = 0; code < 16; code++){
            base_dist[code] = dist;
            for(n = 0; n < 1 << extra_dbits[code]; n++){
                _dist_code[dist++] = code;
            }
        }
        dist >>= 7;
        for(; code < D_CODES$1; code++){
            base_dist[code] = dist << 7;
            for(n = 0; n < 1 << extra_dbits[code] - 7; n++){
                _dist_code[256 + dist++] = code;
            }
        }
        for(bits = 0; bits <= MAX_BITS$1; bits++){
            bl_count[bits] = 0;
        }
        n = 0;
        while(n <= 143){
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
        }
        while(n <= 255){
            static_ltree[n * 2 + 1] = 9;
            n++;
            bl_count[9]++;
        }
        while(n <= 279){
            static_ltree[n * 2 + 1] = 7;
            n++;
            bl_count[7]++;
        }
        while(n <= 287){
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
        for(n = 0; n < D_CODES$1; n++){
            static_dtree[n * 2 + 1] = 5;
            static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
    };
    const init_block = (s)=>{
        let n;
        for(n = 0; n < L_CODES$1; n++){
            s.dyn_ltree[n * 2] = 0;
        }
        for(n = 0; n < D_CODES$1; n++){
            s.dyn_dtree[n * 2] = 0;
        }
        for(n = 0; n < BL_CODES$1; n++){
            s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.sym_next = s.matches = 0;
    };
    const bi_windup = (s)=>{
        if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
            s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
    };
    const smaller = (tree, n, m, depth)=>{
        const _n2 = n * 2;
        const _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    const pqdownheap = (s, tree, k)=>{
        const v = s.heap[k];
        let j = k << 1;
        while(j <= s.heap_len){
            if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                j++;
            }
            if (smaller(tree, v, s.heap[j], s.depth)) {
                break;
            }
            s.heap[k] = s.heap[j];
            k = j;
            j <<= 1;
        }
        s.heap[k] = v;
    };
    const compress_block = (s, ltree, dtree)=>{
        let dist;
        let lc;
        let sx = 0;
        let code;
        let extra;
        if (s.sym_next !== 0) {
            do {
                dist = s.pending_buf[s.sym_buf + sx++] & 255;
                dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
                lc = s.pending_buf[s.sym_buf + sx++];
                if (dist === 0) {
                    send_code(s, lc, ltree);
                } else {
                    code = _length_code[lc];
                    send_code(s, code + LITERALS$1 + 1, ltree);
                    extra = extra_lbits[code];
                    if (extra !== 0) {
                        lc -= base_length[code];
                        send_bits(s, lc, extra);
                    }
                    dist--;
                    code = d_code(dist);
                    send_code(s, code, dtree);
                    extra = extra_dbits[code];
                    if (extra !== 0) {
                        dist -= base_dist[code];
                        send_bits(s, dist, extra);
                    }
                }
            }while (sx < s.sym_next);
        }
        send_code(s, END_BLOCK, ltree);
    };
    const build_tree = (s, desc)=>{
        const tree = desc.dyn_tree;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const elems = desc.stat_desc.elems;
        let n, m;
        let max_code = -1;
        let node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE$1;
        for(n = 0; n < elems; n++){
            if (tree[n * 2] !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;
            } else {
                tree[n * 2 + 1] = 0;
            }
        }
        while(s.heap_len < 2){
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (has_stree) {
                s.static_len -= stree[node * 2 + 1];
            }
        }
        desc.max_code = max_code;
        for(n = s.heap_len >> 1; n >= 1; n--){
            pqdownheap(s, tree, n);
        }
        node = elems;
        do {
            n = s.heap[1];
            s.heap[1] = s.heap[s.heap_len--];
            pqdownheap(s, tree, 1);
            m = s.heap[1];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[1] = node++;
            pqdownheap(s, tree, 1);
        }while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
    };
    const scan_tree = (s, tree, max_code)=>{
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for(n = 0; n <= max_code; n++){
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
                continue;
            } else if (count < min_count) {
                s.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                    s.bl_tree[curlen * 2]++;
                }
                s.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
                s.bl_tree[REPZ_3_10 * 2]++;
            } else {
                s.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    };
    const send_tree = (s, tree, max_code)=>{
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        for(n = 0; n <= max_code; n++){
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
                continue;
            } else if (count < min_count) {
                do {
                    send_code(s, curlen, s.bl_tree);
                }while (--count !== 0);
            } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                    send_code(s, curlen, s.bl_tree);
                    count--;
                }
                send_code(s, REP_3_6, s.bl_tree);
                send_bits(s, count - 3, 2);
            } else if (count <= 10) {
                send_code(s, REPZ_3_10, s.bl_tree);
                send_bits(s, count - 3, 3);
            } else {
                send_code(s, REPZ_11_138, s.bl_tree);
                send_bits(s, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    };
    const build_bl_tree = (s)=>{
        let max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for(max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--){
            if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                break;
            }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
    };
    const send_all_trees = (s, lcodes, dcodes, blcodes)=>{
        let rank2;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for(rank2 = 0; rank2 < blcodes; rank2++){
            send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    const detect_data_type = (s)=>{
        let block_mask = 4093624447;
        let n;
        for(n = 0; n <= 31; n++, block_mask >>>= 1){
            if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                return Z_BINARY;
            }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
        }
        for(n = 32; n < LITERALS$1; n++){
            if (s.dyn_ltree[n * 2] !== 0) {
                return Z_TEXT;
            }
        }
        return Z_BINARY;
    };
    let static_init_done = false;
    const _tr_init$1 = (s)=>{
        if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
    };
    const _tr_stored_block$1 = (s, buf, stored_len, last)=>{
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        bi_windup(s);
        put_short(s, stored_len);
        put_short(s, ~stored_len);
        if (stored_len) {
            s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
        }
        s.pending += stored_len;
    };
    const _tr_align$1 = (s)=>{
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
    };
    const _tr_flush_block$1 = (s, buf, stored_len, last)=>{
        let opt_lenb, static_lenb;
        let max_blindex = 0;
        if (s.level > 0) {
            if (s.strm.data_type === Z_UNKNOWN$1) {
                s.strm.data_type = detect_data_type(s);
            }
            build_tree(s, s.l_desc);
            build_tree(s, s.d_desc);
            max_blindex = build_bl_tree(s);
            opt_lenb = s.opt_len + 3 + 7 >>> 3;
            static_lenb = s.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
                opt_lenb = static_lenb;
            }
        } else {
            opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
            _tr_stored_block$1(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
            send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);
        } else {
            send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
            bi_windup(s);
        }
    };
    const _tr_tally$1 = (s, dist, lc)=>{
        s.pending_buf[s.sym_buf + s.sym_next++] = dist;
        s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
        s.pending_buf[s.sym_buf + s.sym_next++] = lc;
        if (dist === 0) {
            s.dyn_ltree[lc * 2]++;
        } else {
            s.matches++;
            dist--;
            s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
            s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.sym_next === s.sym_end;
    };
    var _tr_init_1 = _tr_init$1;
    var _tr_stored_block_1 = _tr_stored_block$1;
    var _tr_flush_block_1 = _tr_flush_block$1;
    var _tr_tally_1 = _tr_tally$1;
    var _tr_align_1 = _tr_align$1;
    var trees = {
        _tr_init: _tr_init_1,
        _tr_stored_block: _tr_stored_block_1,
        _tr_flush_block: _tr_flush_block_1,
        _tr_tally: _tr_tally_1,
        _tr_align: _tr_align_1
    };
    const adler32 = (adler, buf, len, pos)=>{
        let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while(len !== 0){
            n = len > 2e3 ? 2e3 : len;
            len -= n;
            do {
                s1 = s1 + buf[pos++] | 0;
                s2 = s2 + s1 | 0;
            }while (--n);
            s1 %= 65521;
            s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
    };
    var adler32_1 = adler32;
    const makeTable = ()=>{
        let c, table = [];
        for(var n = 0; n < 256; n++){
            c = n;
            for(var k = 0; k < 8; k++){
                c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            }
            table[n] = c;
        }
        return table;
    };
    const crcTable = new Uint32Array(makeTable());
    const crc32 = (crc, buf, len, pos)=>{
        const t = crcTable;
        const end = pos + len;
        crc ^= -1;
        for(let i = pos; i < end; i++){
            crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
    };
    var crc32_1 = crc32;
    var messages = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
    };
    var constants$2$1 = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
    };
    const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
    const { Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1, Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED: Z_DEFLATED$2 } = constants$2$1;
    const MAX_MEM_LEVEL = 9;
    const MAX_WBITS$1 = 15;
    const DEF_MEM_LEVEL = 8;
    const LENGTH_CODES = 29;
    const LITERALS = 256;
    const L_CODES = LITERALS + 1 + LENGTH_CODES;
    const D_CODES = 30;
    const BL_CODES = 19;
    const HEAP_SIZE = 2 * L_CODES + 1;
    const MAX_BITS = 15;
    const MIN_MATCH = 3;
    const MAX_MATCH = 258;
    const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    const PRESET_DICT = 32;
    const INIT_STATE = 42;
    const GZIP_STATE = 57;
    const EXTRA_STATE = 69;
    const NAME_STATE = 73;
    const COMMENT_STATE = 91;
    const HCRC_STATE = 103;
    const BUSY_STATE = 113;
    const FINISH_STATE = 666;
    const BS_NEED_MORE = 1;
    const BS_BLOCK_DONE = 2;
    const BS_FINISH_STARTED = 3;
    const BS_FINISH_DONE = 4;
    const OS_CODE = 3;
    const err = (strm, errorCode)=>{
        strm.msg = messages[errorCode];
        return errorCode;
    };
    const rank = (f)=>{
        return f * 2 - (f > 4 ? 9 : 0);
    };
    const zero = (buf)=>{
        let len = buf.length;
        while(--len >= 0){
            buf[len] = 0;
        }
    };
    const slide_hash = (s)=>{
        let n, m;
        let p;
        let wsize = s.w_size;
        n = s.hash_size;
        p = n;
        do {
            m = s.head[--p];
            s.head[p] = m >= wsize ? m - wsize : 0;
        }while (--n);
        n = wsize;
        p = n;
        do {
            m = s.prev[--p];
            s.prev[p] = m >= wsize ? m - wsize : 0;
        }while (--n);
    };
    let HASH_ZLIB = (s, prev, data)=>(prev << s.hash_shift ^ data) & s.hash_mask;
    let HASH = HASH_ZLIB;
    const flush_pending = (strm)=>{
        const s = strm.state;
        let len = s.pending;
        if (len > strm.avail_out) {
            len = strm.avail_out;
        }
        if (len === 0) {
            return;
        }
        strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
            s.pending_out = 0;
        }
    };
    const flush_block_only = (s, last)=>{
        _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
    };
    const put_byte = (s, b)=>{
        s.pending_buf[s.pending++] = b;
    };
    const putShortMSB = (s, b)=>{
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
    };
    const read_buf = (strm, buf, start, size)=>{
        let len = strm.avail_in;
        if (len > size) {
            len = size;
        }
        if (len === 0) {
            return 0;
        }
        strm.avail_in -= len;
        buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
        if (strm.state.wrap === 1) {
            strm.adler = adler32_1(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
            strm.adler = crc32_1(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
    };
    const longest_match = (s, cur_match)=>{
        let chain_length = s.max_chain_length;
        let scan = s.strstart;
        let match;
        let len;
        let best_len = s.prev_length;
        let nice_match = s.nice_match;
        const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        const _win = s.window;
        const wmask = s.w_mask;
        const prev = s.prev;
        const strend = s.strstart + MAX_MATCH;
        let scan_end1 = _win[scan + best_len - 1];
        let scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
            nice_match = s.lookahead;
        }
        do {
            match = cur_match;
            if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                continue;
            }
            scan += 2;
            match++;
            do {}while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
                s.match_start = cur_match;
                best_len = len;
                if (len >= nice_match) {
                    break;
                }
                scan_end1 = _win[scan + best_len - 1];
                scan_end = _win[scan + best_len];
            }
        }while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
            return best_len;
        }
        return s.lookahead;
    };
    const fill_window = (s)=>{
        const _w_size = s.w_size;
        let n, more, str;
        do {
            more = s.window_size - s.lookahead - s.strstart;
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
                s.match_start -= _w_size;
                s.strstart -= _w_size;
                s.block_start -= _w_size;
                if (s.insert > s.strstart) {
                    s.insert = s.strstart;
                }
                slide_hash(s);
                more += _w_size;
            }
            if (s.strm.avail_in === 0) {
                break;
            }
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;
            if (s.lookahead + s.insert >= MIN_MATCH) {
                str = s.strstart - s.insert;
                s.ins_h = s.window[str];
                s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
                while(s.insert){
                    s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = str;
                    str++;
                    s.insert--;
                    if (s.lookahead + s.insert < MIN_MATCH) {
                        break;
                    }
                }
            }
        }while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    const deflate_stored = (s, flush)=>{
        let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
        let len, left, have, last = 0;
        let used = s.strm.avail_in;
        do {
            len = 65535;
            have = s.bi_valid + 42 >> 3;
            if (s.strm.avail_out < have) {
                break;
            }
            have = s.strm.avail_out - have;
            left = s.strstart - s.block_start;
            if (len > left + s.strm.avail_in) {
                len = left + s.strm.avail_in;
            }
            if (len > have) {
                len = have;
            }
            if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
                break;
            }
            last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
            _tr_stored_block(s, 0, 0, last);
            s.pending_buf[s.pending - 4] = len;
            s.pending_buf[s.pending - 3] = len >> 8;
            s.pending_buf[s.pending - 2] = ~len;
            s.pending_buf[s.pending - 1] = ~len >> 8;
            flush_pending(s.strm);
            if (left) {
                if (left > len) {
                    left = len;
                }
                s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
                s.strm.next_out += left;
                s.strm.avail_out -= left;
                s.strm.total_out += left;
                s.block_start += left;
                len -= left;
            }
            if (len) {
                read_buf(s.strm, s.strm.output, s.strm.next_out, len);
                s.strm.next_out += len;
                s.strm.avail_out -= len;
                s.strm.total_out += len;
            }
        }while (last === 0);
        used -= s.strm.avail_in;
        if (used) {
            if (used >= s.w_size) {
                s.matches = 2;
                s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
                s.strstart = s.w_size;
                s.insert = s.strstart;
            } else {
                if (s.window_size - s.strstart <= used) {
                    s.strstart -= s.w_size;
                    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
                    if (s.matches < 2) {
                        s.matches++;
                    }
                    if (s.insert > s.strstart) {
                        s.insert = s.strstart;
                    }
                }
                s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
                s.strstart += used;
                s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
            }
            s.block_start = s.strstart;
        }
        if (s.high_water < s.strstart) {
            s.high_water = s.strstart;
        }
        if (last) {
            return BS_FINISH_DONE;
        }
        if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
            return BS_BLOCK_DONE;
        }
        have = s.window_size - s.strstart;
        if (s.strm.avail_in > have && s.block_start >= s.w_size) {
            s.block_start -= s.w_size;
            s.strstart -= s.w_size;
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
                s.matches++;
            }
            have += s.w_size;
            if (s.insert > s.strstart) {
                s.insert = s.strstart;
            }
        }
        if (have > s.strm.avail_in) {
            have = s.strm.avail_in;
        }
        if (have) {
            read_buf(s.strm, s.window, s.strstart, have);
            s.strstart += have;
            s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
        }
        if (s.high_water < s.strstart) {
            s.high_water = s.strstart;
        }
        have = s.bi_valid + 42 >> 3;
        have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
        min_block = have > s.w_size ? s.w_size : have;
        left = s.strstart - s.block_start;
        if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
            len = left > have ? have : left;
            last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
            _tr_stored_block(s, s.block_start, len, last);
            s.block_start += len;
            flush_pending(s.strm);
        }
        return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    const deflate_fast = (s, flush)=>{
        let hash_head;
        let bflush;
        for(;;){
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
            }
            if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
            }
            if (s.match_length >= MIN_MATCH) {
                bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                    s.match_length--;
                    do {
                        s.strstart++;
                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                    }while (--s.match_length !== 0);
                    s.strstart++;
                } else {
                    s.strstart += s.match_length;
                    s.match_length = 0;
                    s.ins_h = s.window[s.strstart];
                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
                }
            } else {
                bflush = _tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    const deflate_slow = (s, flush)=>{
        let hash_head;
        let bflush;
        let max_insert;
        for(;;){
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
            }
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
                if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                    s.match_length = MIN_MATCH - 1;
                }
            }
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                max_insert = s.strstart + s.lookahead - MIN_MATCH;
                bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                s.lookahead -= s.prev_length - 1;
                s.prev_length -= 2;
                do {
                    if (++s.strstart <= max_insert) {
                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                    }
                }while (--s.prev_length !== 0);
                s.match_available = 0;
                s.match_length = MIN_MATCH - 1;
                s.strstart++;
                if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
            } else if (s.match_available) {
                bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
                if (bflush) {
                    flush_block_only(s, false);
                }
                s.strstart++;
                s.lookahead--;
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            } else {
                s.match_available = 1;
                s.strstart++;
                s.lookahead--;
            }
        }
        if (s.match_available) {
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
            s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    const deflate_rle = (s, flush)=>{
        let bflush;
        let prev;
        let scan, strend;
        const _win = s.window;
        for(;;){
            if (s.lookahead <= MAX_MATCH) {
                fill_window(s);
                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                scan = s.strstart - 1;
                prev = _win[scan];
                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                    strend = s.strstart + MAX_MATCH;
                    do {}while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                    s.match_length = MAX_MATCH - (strend - scan);
                    if (s.match_length > s.lookahead) {
                        s.match_length = s.lookahead;
                    }
                }
            }
            if (s.match_length >= MIN_MATCH) {
                bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                s.strstart += s.match_length;
                s.match_length = 0;
            } else {
                bflush = _tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    const deflate_huff = (s, flush)=>{
        let bflush;
        for(;;){
            if (s.lookahead === 0) {
                fill_window(s);
                if (s.lookahead === 0) {
                    if (flush === Z_NO_FLUSH$2) {
                        return BS_NEED_MORE;
                    }
                    break;
                }
            }
            s.match_length = 0;
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
    }
    const configuration_table = [
        new Config(0, 0, 0, 0, deflate_stored),
        new Config(4, 4, 8, 4, deflate_fast),
        new Config(4, 5, 16, 8, deflate_fast),
        new Config(4, 6, 32, 32, deflate_fast),
        new Config(4, 4, 16, 16, deflate_slow),
        new Config(8, 16, 32, 32, deflate_slow),
        new Config(8, 16, 128, 128, deflate_slow),
        new Config(8, 32, 128, 256, deflate_slow),
        new Config(32, 128, 258, 1024, deflate_slow),
        new Config(32, 258, 258, 4096, deflate_slow)
    ];
    const lm_init = (s)=>{
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
    };
    function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED$2;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
        this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
        this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new Uint16Array(MAX_BITS + 1);
        this.heap = new Uint16Array(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new Uint16Array(2 * L_CODES + 1);
        zero(this.depth);
        this.sym_buf = 0;
        this.lit_bufsize = 0;
        this.sym_next = 0;
        this.sym_end = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
    }
    const deflateStateCheck = (strm)=>{
        if (!strm) {
            return 1;
        }
        const s = strm.state;
        if (!s || s.strm !== strm || s.status !== INIT_STATE && s.status !== GZIP_STATE && s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
            return 1;
        }
        return 0;
    };
    const deflateResetKeep = (strm)=>{
        if (deflateStateCheck(strm)) {
            return err(strm, Z_STREAM_ERROR$2);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        const s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
            s.wrap = -s.wrap;
        }
        s.status = s.wrap === 2 ? GZIP_STATE : (s.wrap ? INIT_STATE : BUSY_STATE);
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = -2;
        _tr_init(s);
        return Z_OK$3;
    };
    const deflateReset = (strm)=>{
        const ret = deflateResetKeep(strm);
        if (ret === Z_OK$3) {
            lm_init(strm.state);
        }
        return ret;
    };
    const deflateSetHeader = (strm, head)=>{
        if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
            return Z_STREAM_ERROR$2;
        }
        strm.state.gzhead = head;
        return Z_OK$3;
    };
    const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy)=>{
        if (!strm) {
            return Z_STREAM_ERROR$2;
        }
        let wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION$1) {
            level = 6;
        }
        if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
        } else if (windowBits > 15) {
            wrap = 2;
            windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
            return err(strm, Z_STREAM_ERROR$2);
        }
        if (windowBits === 8) {
            windowBits = 9;
        }
        const s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.status = INIT_STATE;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new Uint8Array(s.w_size * 2);
        s.head = new Uint16Array(s.hash_size);
        s.prev = new Uint16Array(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new Uint8Array(s.pending_buf_size);
        s.sym_buf = s.lit_bufsize;
        s.sym_end = (s.lit_bufsize - 1) * 3;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
    };
    const deflateInit = (strm, level)=>{
        return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
    };
    const deflate$2 = (strm, flush)=>{
        if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
        }
        const s = strm.state;
        if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
        }
        const old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
            return err(strm, Z_BUF_ERROR$1);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR$1);
        }
        if (s.status === INIT_STATE && s.wrap === 0) {
            s.status = BUSY_STATE;
        }
        if (s.status === INIT_STATE) {
            let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
            let level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                level_flags = 0;
            } else if (s.level < 6) {
                level_flags = 1;
            } else if (s.level === 6) {
                level_flags = 2;
            } else {
                level_flags = 3;
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
                header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 65535);
            }
            strm.adler = 1;
            s.status = BUSY_STATE;
            flush_pending(strm);
            if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        }
        if (s.status === GZIP_STATE) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, OS_CODE);
                s.status = BUSY_STATE;
                flush_pending(strm);
                if (s.pending !== 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                }
            } else {
                put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
                put_byte(s, s.gzhead.time & 255);
                put_byte(s, s.gzhead.time >> 8 & 255);
                put_byte(s, s.gzhead.time >> 16 & 255);
                put_byte(s, s.gzhead.time >> 24 & 255);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, s.gzhead.os & 255);
                if (s.gzhead.extra && s.gzhead.extra.length) {
                    put_byte(s, s.gzhead.extra.length & 255);
                    put_byte(s, s.gzhead.extra.length >> 8 & 255);
                }
                if (s.gzhead.hcrc) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
                }
                s.gzindex = 0;
                s.status = EXTRA_STATE;
            }
        }
        if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra) {
                let beg = s.pending;
                let left = (s.gzhead.extra.length & 65535) - s.gzindex;
                while(s.pending + left > s.pending_buf_size){
                    let copy = s.pending_buf_size - s.pending;
                    s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
                    s.pending = s.pending_buf_size;
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    s.gzindex += copy;
                    flush_pending(strm);
                    if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                    }
                    beg = 0;
                    left -= copy;
                }
                let gzhead_extra = new Uint8Array(s.gzhead.extra);
                s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
                s.pending += left;
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                s.gzindex = 0;
            }
            s.status = NAME_STATE;
        }
        if (s.status === NAME_STATE) {
            if (s.gzhead.name) {
                let beg = s.pending;
                let val;
                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        if (s.pending !== 0) {
                            s.last_flush = -1;
                            return Z_OK$3;
                        }
                        beg = 0;
                    }
                    if (s.gzindex < s.gzhead.name.length) {
                        val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                }while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                s.gzindex = 0;
            }
            s.status = COMMENT_STATE;
        }
        if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment) {
                let beg = s.pending;
                let val;
                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        if (s.pending !== 0) {
                            s.last_flush = -1;
                            return Z_OK$3;
                        }
                        beg = 0;
                    }
                    if (s.gzindex < s.gzhead.comment.length) {
                        val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                }while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
            }
            s.status = HCRC_STATE;
        }
        if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
                if (s.pending + 2 > s.pending_buf_size) {
                    flush_pending(strm);
                    if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                    }
                }
                put_byte(s, strm.adler & 255);
                put_byte(s, strm.adler >> 8 & 255);
                strm.adler = 0;
            }
            s.status = BUSY_STATE;
            flush_pending(strm);
            if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
            let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                }
                return Z_OK$3;
            }
            if (bstate === BS_BLOCK_DONE) {
                if (flush === Z_PARTIAL_FLUSH) {
                    _tr_align(s);
                } else if (flush !== Z_BLOCK$1) {
                    _tr_stored_block(s, 0, 0, false);
                    if (flush === Z_FULL_FLUSH$1) {
                        zero(s.head);
                        if (s.lookahead === 0) {
                            s.strstart = 0;
                            s.block_start = 0;
                            s.insert = 0;
                        }
                    }
                }
                flush_pending(strm);
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                }
            }
        }
        if (flush !== Z_FINISH$3) {
            return Z_OK$3;
        }
        if (s.wrap <= 0) {
            return Z_STREAM_END$3;
        }
        if (s.wrap === 2) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            put_byte(s, strm.adler >> 16 & 255);
            put_byte(s, strm.adler >> 24 & 255);
            put_byte(s, strm.total_in & 255);
            put_byte(s, strm.total_in >> 8 & 255);
            put_byte(s, strm.total_in >> 16 & 255);
            put_byte(s, strm.total_in >> 24 & 255);
        } else {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
            s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
    };
    const deflateEnd = (strm)=>{
        if (deflateStateCheck(strm)) {
            return Z_STREAM_ERROR$2;
        }
        const status = strm.state.status;
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
    };
    const deflateSetDictionary = (strm, dictionary)=>{
        let dictLength = dictionary.length;
        if (deflateStateCheck(strm)) {
            return Z_STREAM_ERROR$2;
        }
        const s = strm.state;
        const wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
            return Z_STREAM_ERROR$2;
        }
        if (wrap === 1) {
            strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
            if (wrap === 0) {
                zero(s.head);
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
            }
            let tmpDict = new Uint8Array(s.w_size);
            tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
            dictionary = tmpDict;
            dictLength = s.w_size;
        }
        const avail = strm.avail_in;
        const next = strm.next_in;
        const input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while(s.lookahead >= MIN_MATCH){
            let str = s.strstart;
            let n = s.lookahead - (MIN_MATCH - 1);
            do {
                s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
            }while (--n);
            s.strstart = str;
            s.lookahead = MIN_MATCH - 1;
            fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK$3;
    };
    var deflateInit_1 = deflateInit;
    var deflateInit2_1 = deflateInit2;
    var deflateReset_1 = deflateReset;
    var deflateResetKeep_1 = deflateResetKeep;
    var deflateSetHeader_1 = deflateSetHeader;
    var deflate_2$1 = deflate$2;
    var deflateEnd_1 = deflateEnd;
    var deflateSetDictionary_1 = deflateSetDictionary;
    var deflateInfo = "pako deflate (from Nodeca project)";
    var deflate_1$2 = {
        deflateInit: deflateInit_1,
        deflateInit2: deflateInit2_1,
        deflateReset: deflateReset_1,
        deflateResetKeep: deflateResetKeep_1,
        deflateSetHeader: deflateSetHeader_1,
        deflate: deflate_2$1,
        deflateEnd: deflateEnd_1,
        deflateSetDictionary: deflateSetDictionary_1,
        deflateInfo
    };
    const _has = (obj, key)=>{
        return Object.prototype.hasOwnProperty.call(obj, key);
    };
    var assign = function(obj) {
        const sources = Array.prototype.slice.call(arguments, 1);
        while(sources.length){
            const source = sources.shift();
            if (!source) {
                continue;
            }
            if (typeof source !== "object") {
                throw new TypeError(source + "must be non-object");
            }
            for(const p in source){
                if (_has(source, p)) {
                    obj[p] = source[p];
                }
            }
        }
        return obj;
    };
    var flattenChunks = (chunks)=>{
        let len = 0;
        for(let i = 0, l = chunks.length; i < l; i++){
            len += chunks[i].length;
        }
        const result = new Uint8Array(len);
        for(let i = 0, pos = 0, l = chunks.length; i < l; i++){
            let chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
        }
        return result;
    };
    var common = {
        assign,
        flattenChunks
    };
    let STR_APPLY_UIA_OK = true;
    try {
        String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
        STR_APPLY_UIA_OK = false;
    }
    const _utf8len = new Uint8Array(256);
    for(let q = 0; q < 256; q++){
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = (str)=>{
        if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
            return new TextEncoder().encode(str);
        }
        let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
        for(m_pos = 0; m_pos < str_len; m_pos++){
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                    m_pos++;
                }
            }
            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new Uint8Array(buf_len);
        for(i = 0, m_pos = 0; i < buf_len; m_pos++){
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                    m_pos++;
                }
            }
            if (c < 128) {
                buf[i++] = c;
            } else if (c < 2048) {
                buf[i++] = 192 | c >>> 6;
                buf[i++] = 128 | c & 63;
            } else if (c < 65536) {
                buf[i++] = 224 | c >>> 12;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
            } else {
                buf[i++] = 240 | c >>> 18;
                buf[i++] = 128 | c >>> 12 & 63;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
            }
        }
        return buf;
    };
    const buf2binstring = (buf, len)=>{
        if (len < 65534) {
            if (buf.subarray && STR_APPLY_UIA_OK) {
                return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
            }
        }
        let result = "";
        for(let i = 0; i < len; i++){
            result += String.fromCharCode(buf[i]);
        }
        return result;
    };
    var buf2string = (buf, max)=>{
        const len = max || buf.length;
        if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
            return new TextDecoder().decode(buf.subarray(0, max));
        }
        let i, out;
        const utf16buf = new Array(len * 2);
        for(out = 0, i = 0; i < len;){
            let c = buf[i++];
            if (c < 128) {
                utf16buf[out++] = c;
                continue;
            }
            let c_len = _utf8len[c];
            if (c_len > 4) {
                utf16buf[out++] = 65533;
                i += c_len - 1;
                continue;
            }
            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while(c_len > 1 && i < len){
                c = c << 6 | buf[i++] & 63;
                c_len--;
            }
            if (c_len > 1) {
                utf16buf[out++] = 65533;
                continue;
            }
            if (c < 65536) {
                utf16buf[out++] = c;
            } else {
                c -= 65536;
                utf16buf[out++] = 55296 | c >> 10 & 1023;
                utf16buf[out++] = 56320 | c & 1023;
            }
        }
        return buf2binstring(utf16buf, out);
    };
    var utf8border = (buf, max)=>{
        max = max || buf.length;
        if (max > buf.length) {
            max = buf.length;
        }
        let pos = max - 1;
        while(pos >= 0 && (buf[pos] & 192) === 128){
            pos--;
        }
        if (pos < 0) {
            return max;
        }
        if (pos === 0) {
            return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    var strings = {
        string2buf,
        buf2string,
        utf8border
    };
    function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
    }
    var zstream = ZStream;
    const toString$1 = Object.prototype.toString;
    const { Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2, Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED: Z_DEFLATED$1 } = constants$2$1;
    function Deflate$1(options) {
        this.options = common.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED$1,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY
        }, options || {});
        let opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new zstream();
        this.strm.avail_out = 0;
        let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
        if (status !== Z_OK$2) {
            throw new Error(messages[status]);
        }
        if (opt.header) {
            deflate_1$2.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
            let dict;
            if (typeof opt.dictionary === "string") {
                dict = strings.string2buf(opt.dictionary);
            } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
                dict = new Uint8Array(opt.dictionary);
            } else {
                dict = opt.dictionary;
            }
            status = deflate_1$2.deflateSetDictionary(this.strm, dict);
            if (status !== Z_OK$2) {
                throw new Error(messages[status]);
            }
            this._dict_set = true;
        }
    }
    Deflate$1.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        let status, _flush_mode;
        if (this.ended) {
            return false;
        }
        if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
        else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
        if (typeof data === "string") {
            strm.input = strings.string2buf(data);
        } else if (toString$1.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for(;;){
            if (strm.avail_out === 0) {
                strm.output = new Uint8Array(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }
            if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
                this.onData(strm.output.subarray(0, strm.next_out));
                strm.avail_out = 0;
                continue;
            }
            status = deflate_1$2.deflate(strm, _flush_mode);
            if (status === Z_STREAM_END$2) {
                if (strm.next_out > 0) {
                    this.onData(strm.output.subarray(0, strm.next_out));
                }
                status = deflate_1$2.deflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return status === Z_OK$2;
            }
            if (strm.avail_out === 0) {
                this.onData(strm.output);
                continue;
            }
            if (_flush_mode > 0 && strm.next_out > 0) {
                this.onData(strm.output.subarray(0, strm.next_out));
                strm.avail_out = 0;
                continue;
            }
            if (strm.avail_in === 0) break;
        }
        return true;
    };
    Deflate$1.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
    };
    Deflate$1.prototype.onEnd = function(status) {
        if (status === Z_OK$2) {
            this.result = common.flattenChunks(this.chunks);
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };
    function deflate$1(input, options) {
        const deflator = new Deflate$1(options);
        deflator.push(input, true);
        if (deflator.err) {
            throw deflator.msg || messages[deflator.err];
        }
        return deflator.result;
    }
    function deflateRaw$1(input, options) {
        options = options || {};
        options.raw = true;
        return deflate$1(input, options);
    }
    function gzip$1(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate$1(input, options);
    }
    var Deflate_1$1 = Deflate$1;
    var deflate_2 = deflate$1;
    var deflateRaw_1$1 = deflateRaw$1;
    var gzip_1$1 = gzip$1;
    var deflate_1$1 = {
        Deflate: Deflate_1$1,
        deflate: deflate_2,
        deflateRaw: deflateRaw_1$1,
        gzip: gzip_1$1
    };
    const BAD$1 = 16209;
    const TYPE$1 = 16191;
    var inffast = function inflate_fast(strm, start) {
        let _in;
        let last;
        let _out;
        let beg;
        let end;
        let dmax;
        let wsize;
        let whave;
        let wnext;
        let s_window;
        let hold;
        let bits;
        let lcode;
        let dcode;
        let lmask;
        let dmask;
        let here;
        let op;
        let len;
        let dist;
        let from;
        let from_source;
        let input, output;
        const state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top: do {
            if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
            }
            here = lcode[hold & lmask];
            dolen: for(;;){
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                    output[_out++] = here & 65535;
                } else if (op & 16) {
                    len = here & 65535;
                    op &= 15;
                    if (op) {
                        if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                        }
                        len += hold & (1 << op) - 1;
                        hold >>>= op;
                        bits -= op;
                    }
                    if (bits < 15) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        hold += input[_in++] << bits;
                        bits += 8;
                    }
                    here = dcode[hold & dmask];
                    dodist: for(;;){
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op & 16) {
                            dist = here & 65535;
                            op &= 15;
                            if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                                if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                }
                            }
                            dist += hold & (1 << op) - 1;
                            if (dist > dmax) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD$1;
                                break top;
                            }
                            hold >>>= op;
                            bits -= op;
                            op = _out - beg;
                            if (dist > op) {
                                op = dist - op;
                                if (op > whave) {
                                    if (state.sane) {
                                        strm.msg = "invalid distance too far back";
                                        state.mode = BAD$1;
                                        break top;
                                    }
                                }
                                from = 0;
                                from_source = s_window;
                                if (wnext === 0) {
                                    from += wsize - op;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        }while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                } else if (wnext < op) {
                                    from += wsize + wnext - op;
                                    op -= wnext;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        }while (--op);
                                        from = 0;
                                        if (wnext < len) {
                                            op = wnext;
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++];
                                            }while (--op);
                                            from = _out - dist;
                                            from_source = output;
                                        }
                                    }
                                } else {
                                    from += wnext - op;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        }while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                }
                                while(len > 2){
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    len -= 3;
                                }
                                if (len) {
                                    output[_out++] = from_source[from++];
                                    if (len > 1) {
                                        output[_out++] = from_source[from++];
                                    }
                                }
                            } else {
                                from = _out - dist;
                                do {
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    len -= 3;
                                }while (len > 2);
                                if (len) {
                                    output[_out++] = output[from++];
                                    if (len > 1) {
                                        output[_out++] = output[from++];
                                    }
                                }
                            }
                        } else if ((op & 64) === 0) {
                            here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                            continue dodist;
                        } else {
                            strm.msg = "invalid distance code";
                            state.mode = BAD$1;
                            break top;
                        }
                        break;
                    }
                } else if ((op & 64) === 0) {
                    here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dolen;
                } else if (op & 32) {
                    state.mode = TYPE$1;
                    break top;
                } else {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD$1;
                    break top;
                }
                break;
            }
        }while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
    };
    const MAXBITS = 15;
    const ENOUGH_LENS$1 = 852;
    const ENOUGH_DISTS$1 = 592;
    const CODES$1 = 0;
    const LENS$1 = 1;
    const DISTS$1 = 2;
    const lbase = new Uint16Array([
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
    ]);
    const lext = new Uint8Array([
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
    ]);
    const dbase = new Uint16Array([
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
    ]);
    const dext = new Uint8Array([
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
    ]);
    const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts)=>{
        const bits = opts.bits;
        let len = 0;
        let sym = 0;
        let min = 0, max = 0;
        let root = 0;
        let curr = 0;
        let drop = 0;
        let left = 0;
        let used = 0;
        let huff = 0;
        let incr;
        let fill;
        let low;
        let mask;
        let next;
        let base = null;
        let match;
        const count = new Uint16Array(MAXBITS + 1);
        const offs = new Uint16Array(MAXBITS + 1);
        let extra = null;
        let here_bits, here_op, here_val;
        for(len = 0; len <= MAXBITS; len++){
            count[len] = 0;
        }
        for(sym = 0; sym < codes; sym++){
            count[lens[lens_index + sym]]++;
        }
        root = bits;
        for(max = MAXBITS; max >= 1; max--){
            if (count[max] !== 0) {
                break;
            }
        }
        if (root > max) {
            root = max;
        }
        if (max === 0) {
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            opts.bits = 1;
            return 0;
        }
        for(min = 1; min < max; min++){
            if (count[min] !== 0) {
                break;
            }
        }
        if (root < min) {
            root = min;
        }
        left = 1;
        for(len = 1; len <= MAXBITS; len++){
            left <<= 1;
            left -= count[len];
            if (left < 0) {
                return -1;
            }
        }
        if (left > 0 && (type === CODES$1 || max !== 1)) {
            return -1;
        }
        offs[1] = 0;
        for(len = 1; len < MAXBITS; len++){
            offs[len + 1] = offs[len] + count[len];
        }
        for(sym = 0; sym < codes; sym++){
            if (lens[lens_index + sym] !== 0) {
                work[offs[lens[lens_index + sym]]++] = sym;
            }
        }
        if (type === CODES$1) {
            base = extra = work;
            match = 20;
        } else if (type === LENS$1) {
            base = lbase;
            extra = lext;
            match = 257;
        } else {
            base = dbase;
            extra = dext;
            match = 0;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
            return 1;
        }
        for(;;){
            here_bits = len - drop;
            if (work[sym] + 1 < match) {
                here_op = 0;
                here_val = work[sym];
            } else if (work[sym] >= match) {
                here_op = extra[work[sym] - match];
                here_val = base[work[sym] - match];
            } else {
                here_op = 32 + 64;
                here_val = 0;
            }
            incr = 1 << len - drop;
            fill = 1 << curr;
            min = fill;
            do {
                fill -= incr;
                table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
            }while (fill !== 0);
            incr = 1 << len - 1;
            while(huff & incr){
                incr >>= 1;
            }
            if (incr !== 0) {
                huff &= incr - 1;
                huff += incr;
            } else {
                huff = 0;
            }
            sym++;
            if (--count[len] === 0) {
                if (len === max) {
                    break;
                }
                len = lens[lens_index + work[sym]];
            }
            if (len > root && (huff & mask) !== low) {
                if (drop === 0) {
                    drop = root;
                }
                next += min;
                curr = len - drop;
                left = 1 << curr;
                while(curr + drop < max){
                    left -= count[curr + drop];
                    if (left <= 0) {
                        break;
                    }
                    curr++;
                    left <<= 1;
                }
                used += 1 << curr;
                if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
                    return 1;
                }
                low = huff & mask;
                table[low] = root << 24 | curr << 16 | next - table_index | 0;
            }
        }
        if (huff !== 0) {
            table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
    };
    var inftrees = inflate_table;
    const CODES = 0;
    const LENS = 1;
    const DISTS = 2;
    const { Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED } = constants$2$1;
    const HEAD = 16180;
    const FLAGS = 16181;
    const TIME = 16182;
    const OS$1 = 16183;
    const EXLEN = 16184;
    const EXTRA = 16185;
    const NAME = 16186;
    const COMMENT = 16187;
    const HCRC = 16188;
    const DICTID = 16189;
    const DICT = 16190;
    const TYPE = 16191;
    const TYPEDO = 16192;
    const STORED = 16193;
    const COPY_ = 16194;
    const COPY = 16195;
    const TABLE = 16196;
    const LENLENS = 16197;
    const CODELENS = 16198;
    const LEN_ = 16199;
    const LEN = 16200;
    const LENEXT = 16201;
    const DIST = 16202;
    const DISTEXT = 16203;
    const MATCH = 16204;
    const LIT = 16205;
    const CHECK = 16206;
    const LENGTH = 16207;
    const DONE = 16208;
    const BAD = 16209;
    const MEM = 16210;
    const SYNC = 16211;
    const ENOUGH_LENS = 852;
    const ENOUGH_DISTS = 592;
    const MAX_WBITS = 15;
    const DEF_WBITS = MAX_WBITS;
    const zswap32 = (q)=>{
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    };
    function InflateState() {
        this.strm = null;
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new Uint16Array(320);
        this.work = new Uint16Array(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
    }
    const inflateStateCheck = (strm)=>{
        if (!strm) {
            return 1;
        }
        const state = strm.state;
        if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
            return 1;
        }
        return 0;
    };
    const inflateResetKeep = (strm)=>{
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
            strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.flags = -1;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
        state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK$1;
    };
    const inflateReset = (strm)=>{
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
    };
    const inflateReset2 = (strm, windowBits)=>{
        let wrap;
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
        } else {
            wrap = (windowBits >> 4) + 5;
            if (windowBits < 48) {
                windowBits &= 15;
            }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR$1;
        }
        if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
    };
    const inflateInit2 = (strm, windowBits)=>{
        if (!strm) {
            return Z_STREAM_ERROR$1;
        }
        const state = new InflateState();
        strm.state = state;
        state.strm = strm;
        state.window = null;
        state.mode = HEAD;
        const ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK$1) {
            strm.state = null;
        }
        return ret;
    };
    const inflateInit = (strm)=>{
        return inflateInit2(strm, DEF_WBITS);
    };
    let virgin = true;
    let lenfix, distfix;
    const fixedtables = (state)=>{
        if (virgin) {
            lenfix = new Int32Array(512);
            distfix = new Int32Array(32);
            let sym = 0;
            while(sym < 144){
                state.lens[sym++] = 8;
            }
            while(sym < 256){
                state.lens[sym++] = 9;
            }
            while(sym < 280){
                state.lens[sym++] = 7;
            }
            while(sym < 288){
                state.lens[sym++] = 8;
            }
            inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                bits: 9
            });
            sym = 0;
            while(sym < 32){
                state.lens[sym++] = 5;
            }
            inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                bits: 5
            });
            virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
    };
    const updatewindow = (strm, src, end, copy)=>{
        let dist;
        const state = strm.state;
        if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            state.window = new Uint8Array(state.wsize);
        }
        if (copy >= state.wsize) {
            state.window.set(src.subarray(end - state.wsize, end), 0);
            state.wnext = 0;
            state.whave = state.wsize;
        } else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
                dist = copy;
            }
            state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
            copy -= dist;
            if (copy) {
                state.window.set(src.subarray(end - copy, end), 0);
                state.wnext = copy;
                state.whave = state.wsize;
            } else {
                state.wnext += dist;
                if (state.wnext === state.wsize) {
                    state.wnext = 0;
                }
                if (state.whave < state.wsize) {
                    state.whave += dist;
                }
            }
        }
        return 0;
    };
    const inflate$2 = (strm, flush)=>{
        let state;
        let input, output;
        let next;
        let put;
        let have, left;
        let hold;
        let bits;
        let _in, _out;
        let copy;
        let from;
        let from_source;
        let here = 0;
        let here_bits, here_op, here_val;
        let last_bits, last_op, last_val;
        let len;
        let ret;
        const hbuf = new Uint8Array(4);
        let opts;
        let n;
        const order = (new Uint8Array([
            16,
            17,
            18,
            0,
            8,
            7,
            9,
            6,
            10,
            5,
            11,
            4,
            12,
            3,
            13,
            2,
            14,
            1,
            15
        ]));
        if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
            return Z_STREAM_ERROR$1;
        }
        state = strm.state;
        if (state.mode === TYPE) {
            state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK$1;
        inf_leave: for(;;){
            switch(state.mode){
                case HEAD:
                    if (state.wrap === 0) {
                        state.mode = TYPEDO;
                        break;
                    }
                    while(bits < 16){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.wrap & 2 && hold === 35615) {
                        if (state.wbits === 0) {
                            state.wbits = 15;
                        }
                        state.check = 0;
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state.check = crc32_1(state.check, hbuf, 2, 0);
                        hold = 0;
                        bits = 0;
                        state.mode = FLAGS;
                        break;
                    }
                    if (state.head) {
                        state.head.done = false;
                    }
                    if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                        strm.msg = "incorrect header check";
                        state.mode = BAD;
                        break;
                    }
                    if ((hold & 15) !== Z_DEFLATED) {
                        strm.msg = "unknown compression method";
                        state.mode = BAD;
                        break;
                    }
                    hold >>>= 4;
                    bits -= 4;
                    len = (hold & 15) + 8;
                    if (state.wbits === 0) {
                        state.wbits = len;
                    }
                    if (len > 15 || len > state.wbits) {
                        strm.msg = "invalid window size";
                        state.mode = BAD;
                        break;
                    }
                    state.dmax = 1 << state.wbits;
                    state.flags = 0;
                    strm.adler = state.check = 1;
                    state.mode = hold & 512 ? DICTID : TYPE;
                    hold = 0;
                    bits = 0;
                    break;
                case FLAGS:
                    while(bits < 16){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.flags = hold;
                    if ((state.flags & 255) !== Z_DEFLATED) {
                        strm.msg = "unknown compression method";
                        state.mode = BAD;
                        break;
                    }
                    if (state.flags & 57344) {
                        strm.msg = "unknown header flags set";
                        state.mode = BAD;
                        break;
                    }
                    if (state.head) {
                        state.head.text = hold >> 8 & 1;
                    }
                    if (state.flags & 512 && state.wrap & 4) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state.check = crc32_1(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                    state.mode = TIME;
                case TIME:
                    while(bits < 32){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.head) {
                        state.head.time = hold;
                    }
                    if (state.flags & 512 && state.wrap & 4) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        hbuf[2] = hold >>> 16 & 255;
                        hbuf[3] = hold >>> 24 & 255;
                        state.check = crc32_1(state.check, hbuf, 4, 0);
                    }
                    hold = 0;
                    bits = 0;
                    state.mode = OS$1;
                case OS$1:
                    while(bits < 16){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.head) {
                        state.head.xflags = hold & 255;
                        state.head.os = hold >> 8;
                    }
                    if (state.flags & 512 && state.wrap & 4) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state.check = crc32_1(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                    state.mode = EXLEN;
                case EXLEN:
                    if (state.flags & 1024) {
                        while(bits < 16){
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        state.length = hold;
                        if (state.head) {
                            state.head.extra_len = hold;
                        }
                        if (state.flags & 512 && state.wrap & 4) {
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            state.check = crc32_1(state.check, hbuf, 2, 0);
                        }
                        hold = 0;
                        bits = 0;
                    } else if (state.head) {
                        state.head.extra = null;
                    }
                    state.mode = EXTRA;
                case EXTRA:
                    if (state.flags & 1024) {
                        copy = state.length;
                        if (copy > have) {
                            copy = have;
                        }
                        if (copy) {
                            if (state.head) {
                                len = state.head.extra_len - state.length;
                                if (!state.head.extra) {
                                    state.head.extra = new Uint8Array(state.head.extra_len);
                                }
                                state.head.extra.set(input.subarray(next, next + copy), len);
                            }
                            if (state.flags & 512 && state.wrap & 4) {
                                state.check = crc32_1(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            state.length -= copy;
                        }
                        if (state.length) {
                            break inf_leave;
                        }
                    }
                    state.length = 0;
                    state.mode = NAME;
                case NAME:
                    if (state.flags & 2048) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        copy = 0;
                        do {
                            len = input[next + copy++];
                            if (state.head && len && state.length < 65536) {
                                state.head.name += String.fromCharCode(len);
                            }
                        }while (len && copy < have);
                        if (state.flags & 512 && state.wrap & 4) {
                            state.check = crc32_1(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        if (len) {
                            break inf_leave;
                        }
                    } else if (state.head) {
                        state.head.name = null;
                    }
                    state.length = 0;
                    state.mode = COMMENT;
                case COMMENT:
                    if (state.flags & 4096) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        copy = 0;
                        do {
                            len = input[next + copy++];
                            if (state.head && len && state.length < 65536) {
                                state.head.comment += String.fromCharCode(len);
                            }
                        }while (len && copy < have);
                        if (state.flags & 512 && state.wrap & 4) {
                            state.check = crc32_1(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        if (len) {
                            break inf_leave;
                        }
                    } else if (state.head) {
                        state.head.comment = null;
                    }
                    state.mode = HCRC;
                case HCRC:
                    if (state.flags & 512) {
                        while(bits < 16){
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if (state.wrap & 4 && hold !== (state.check & 65535)) {
                            strm.msg = "header crc mismatch";
                            state.mode = BAD;
                            break;
                        }
                        hold = 0;
                        bits = 0;
                    }
                    if (state.head) {
                        state.head.hcrc = state.flags >> 9 & 1;
                        state.head.done = true;
                    }
                    strm.adler = state.check = 0;
                    state.mode = TYPE;
                    break;
                case DICTID:
                    while(bits < 32){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    strm.adler = state.check = zswap32(hold);
                    hold = 0;
                    bits = 0;
                    state.mode = DICT;
                case DICT:
                    if (state.havedict === 0) {
                        strm.next_out = put;
                        strm.avail_out = left;
                        strm.next_in = next;
                        strm.avail_in = have;
                        state.hold = hold;
                        state.bits = bits;
                        return Z_NEED_DICT$1;
                    }
                    strm.adler = state.check = 1;
                    state.mode = TYPE;
                case TYPE:
                    if (flush === Z_BLOCK || flush === Z_TREES) {
                        break inf_leave;
                    }
                case TYPEDO:
                    if (state.last) {
                        hold >>>= bits & 7;
                        bits -= bits & 7;
                        state.mode = CHECK;
                        break;
                    }
                    while(bits < 3){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.last = hold & 1;
                    hold >>>= 1;
                    bits -= 1;
                    switch(hold & 3){
                        case 0:
                            state.mode = STORED;
                            break;
                        case 1:
                            fixedtables(state);
                            state.mode = LEN_;
                            if (flush === Z_TREES) {
                                hold >>>= 2;
                                bits -= 2;
                                break inf_leave;
                            }
                            break;
                        case 2:
                            state.mode = TABLE;
                            break;
                        case 3:
                            strm.msg = "invalid block type";
                            state.mode = BAD;
                    }
                    hold >>>= 2;
                    bits -= 2;
                    break;
                case STORED:
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    while(bits < 32){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                        strm.msg = "invalid stored block lengths";
                        state.mode = BAD;
                        break;
                    }
                    state.length = hold & 65535;
                    hold = 0;
                    bits = 0;
                    state.mode = COPY_;
                    if (flush === Z_TREES) {
                        break inf_leave;
                    }
                case COPY_:
                    state.mode = COPY;
                case COPY:
                    copy = state.length;
                    if (copy) {
                        if (copy > have) {
                            copy = have;
                        }
                        if (copy > left) {
                            copy = left;
                        }
                        if (copy === 0) {
                            break inf_leave;
                        }
                        output.set(input.subarray(next, next + copy), put);
                        have -= copy;
                        next += copy;
                        left -= copy;
                        put += copy;
                        state.length -= copy;
                        break;
                    }
                    state.mode = TYPE;
                    break;
                case TABLE:
                    while(bits < 14){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.nlen = (hold & 31) + 257;
                    hold >>>= 5;
                    bits -= 5;
                    state.ndist = (hold & 31) + 1;
                    hold >>>= 5;
                    bits -= 5;
                    state.ncode = (hold & 15) + 4;
                    hold >>>= 4;
                    bits -= 4;
                    if (state.nlen > 286 || state.ndist > 30) {
                        strm.msg = "too many length or distance symbols";
                        state.mode = BAD;
                        break;
                    }
                    state.have = 0;
                    state.mode = LENLENS;
                case LENLENS:
                    while(state.have < state.ncode){
                        while(bits < 3){
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        state.lens[order[state.have++]] = hold & 7;
                        hold >>>= 3;
                        bits -= 3;
                    }
                    while(state.have < 19){
                        state.lens[order[state.have++]] = 0;
                    }
                    state.lencode = state.lendyn;
                    state.lenbits = 7;
                    opts = {
                        bits: state.lenbits
                    };
                    ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                    state.lenbits = opts.bits;
                    if (ret) {
                        strm.msg = "invalid code lengths set";
                        state.mode = BAD;
                        break;
                    }
                    state.have = 0;
                    state.mode = CODELENS;
                case CODELENS:
                    while(state.have < state.nlen + state.ndist){
                        for(;;){
                            here = state.lencode[hold & (1 << state.lenbits) - 1];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (here_bits <= bits) {
                                break;
                            }
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if (here_val < 16) {
                            hold >>>= here_bits;
                            bits -= here_bits;
                            state.lens[state.have++] = here_val;
                        } else {
                            if (here_val === 16) {
                                n = here_bits + 2;
                                while(bits < n){
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                hold >>>= here_bits;
                                bits -= here_bits;
                                if (state.have === 0) {
                                    strm.msg = "invalid bit length repeat";
                                    state.mode = BAD;
                                    break;
                                }
                                len = state.lens[state.have - 1];
                                copy = 3 + (hold & 3);
                                hold >>>= 2;
                                bits -= 2;
                            } else if (here_val === 17) {
                                n = here_bits + 3;
                                while(bits < n){
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                hold >>>= here_bits;
                                bits -= here_bits;
                                len = 0;
                                copy = 3 + (hold & 7);
                                hold >>>= 3;
                                bits -= 3;
                            } else {
                                n = here_bits + 7;
                                while(bits < n){
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                hold >>>= here_bits;
                                bits -= here_bits;
                                len = 0;
                                copy = 11 + (hold & 127);
                                hold >>>= 7;
                                bits -= 7;
                            }
                            if (state.have + copy > state.nlen + state.ndist) {
                                strm.msg = "invalid bit length repeat";
                                state.mode = BAD;
                                break;
                            }
                            while(copy--){
                                state.lens[state.have++] = len;
                            }
                        }
                    }
                    if (state.mode === BAD) {
                        break;
                    }
                    if (state.lens[256] === 0) {
                        strm.msg = "invalid code -- missing end-of-block";
                        state.mode = BAD;
                        break;
                    }
                    state.lenbits = 9;
                    opts = {
                        bits: state.lenbits
                    };
                    ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                    state.lenbits = opts.bits;
                    if (ret) {
                        strm.msg = "invalid literal/lengths set";
                        state.mode = BAD;
                        break;
                    }
                    state.distbits = 6;
                    state.distcode = state.distdyn;
                    opts = {
                        bits: state.distbits
                    };
                    ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                    state.distbits = opts.bits;
                    if (ret) {
                        strm.msg = "invalid distances set";
                        state.mode = BAD;
                        break;
                    }
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                        break inf_leave;
                    }
                case LEN_:
                    state.mode = LEN;
                case LEN:
                    if (have >= 6 && left >= 258) {
                        strm.next_out = put;
                        strm.avail_out = left;
                        strm.next_in = next;
                        strm.avail_in = have;
                        state.hold = hold;
                        state.bits = bits;
                        inffast(strm, _out);
                        put = strm.next_out;
                        output = strm.output;
                        left = strm.avail_out;
                        next = strm.next_in;
                        input = strm.input;
                        have = strm.avail_in;
                        hold = state.hold;
                        bits = state.bits;
                        if (state.mode === TYPE) {
                            state.back = -1;
                        }
                        break;
                    }
                    state.back = 0;
                    for(;;){
                        here = state.lencode[hold & (1 << state.lenbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (here_op && (here_op & 240) === 0) {
                        last_bits = here_bits;
                        last_op = here_op;
                        last_val = here_val;
                        for(;;){
                            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (last_bits + here_bits <= bits) {
                                break;
                            }
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        hold >>>= last_bits;
                        bits -= last_bits;
                        state.back += last_bits;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.back += here_bits;
                    state.length = here_val;
                    if (here_op === 0) {
                        state.mode = LIT;
                        break;
                    }
                    if (here_op & 32) {
                        state.back = -1;
                        state.mode = TYPE;
                        break;
                    }
                    if (here_op & 64) {
                        strm.msg = "invalid literal/length code";
                        state.mode = BAD;
                        break;
                    }
                    state.extra = here_op & 15;
                    state.mode = LENEXT;
                case LENEXT:
                    if (state.extra) {
                        n = state.extra;
                        while(bits < n){
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        state.length += hold & (1 << state.extra) - 1;
                        hold >>>= state.extra;
                        bits -= state.extra;
                        state.back += state.extra;
                    }
                    state.was = state.length;
                    state.mode = DIST;
                case DIST:
                    for(;;){
                        here = state.distcode[hold & (1 << state.distbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if ((here_op & 240) === 0) {
                        last_bits = here_bits;
                        last_op = here_op;
                        last_val = here_val;
                        for(;;){
                            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (last_bits + here_bits <= bits) {
                                break;
                            }
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        hold >>>= last_bits;
                        bits -= last_bits;
                        state.back += last_bits;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.back += here_bits;
                    if (here_op & 64) {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break;
                    }
                    state.offset = here_val;
                    state.extra = here_op & 15;
                    state.mode = DISTEXT;
                case DISTEXT:
                    if (state.extra) {
                        n = state.extra;
                        while(bits < n){
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        state.offset += hold & (1 << state.extra) - 1;
                        hold >>>= state.extra;
                        bits -= state.extra;
                        state.back += state.extra;
                    }
                    if (state.offset > state.dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break;
                    }
                    state.mode = MATCH;
                case MATCH:
                    if (left === 0) {
                        break inf_leave;
                    }
                    copy = _out - left;
                    if (state.offset > copy) {
                        copy = state.offset - copy;
                        if (copy > state.whave) {
                            if (state.sane) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD;
                                break;
                            }
                        }
                        if (copy > state.wnext) {
                            copy -= state.wnext;
                            from = state.wsize - copy;
                        } else {
                            from = state.wnext - copy;
                        }
                        if (copy > state.length) {
                            copy = state.length;
                        }
                        from_source = state.window;
                    } else {
                        from_source = output;
                        from = put - state.offset;
                        copy = state.length;
                    }
                    if (copy > left) {
                        copy = left;
                    }
                    left -= copy;
                    state.length -= copy;
                    do {
                        output[put++] = from_source[from++];
                    }while (--copy);
                    if (state.length === 0) {
                        state.mode = LEN;
                    }
                    break;
                case LIT:
                    if (left === 0) {
                        break inf_leave;
                    }
                    output[put++] = state.length;
                    left--;
                    state.mode = LEN;
                    break;
                case CHECK:
                    if (state.wrap) {
                        while(bits < 32){
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold |= input[next++] << bits;
                            bits += 8;
                        }
                        _out -= left;
                        strm.total_out += _out;
                        state.total += _out;
                        if (state.wrap & 4 && _out) {
                            strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
                        }
                        _out = left;
                        if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                            strm.msg = "incorrect data check";
                            state.mode = BAD;
                            break;
                        }
                        hold = 0;
                        bits = 0;
                    }
                    state.mode = LENGTH;
                case LENGTH:
                    if (state.wrap && state.flags) {
                        while(bits < 32){
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                            strm.msg = "incorrect length check";
                            state.mode = BAD;
                            break;
                        }
                        hold = 0;
                        bits = 0;
                    }
                    state.mode = DONE;
                case DONE:
                    ret = Z_STREAM_END$1;
                    break inf_leave;
                case BAD:
                    ret = Z_DATA_ERROR$1;
                    break inf_leave;
                case MEM:
                    return Z_MEM_ERROR$1;
                case SYNC:
                default:
                    return Z_STREAM_ERROR$1;
            }
        }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap & 4 && _out) {
            strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
            ret = Z_BUF_ERROR;
        }
        return ret;
    };
    const inflateEnd = (strm)=>{
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        let state = strm.state;
        if (state.window) {
            state.window = null;
        }
        strm.state = null;
        return Z_OK$1;
    };
    const inflateGetHeader = (strm, head)=>{
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        if ((state.wrap & 2) === 0) {
            return Z_STREAM_ERROR$1;
        }
        state.head = head;
        head.done = false;
        return Z_OK$1;
    };
    const inflateSetDictionary = (strm, dictionary)=>{
        const dictLength = dictionary.length;
        let state;
        let dictid;
        let ret;
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
            return Z_STREAM_ERROR$1;
        }
        if (state.mode === DICT) {
            dictid = 1;
            dictid = adler32_1(dictid, dictionary, dictLength, 0);
            if (dictid !== state.check) {
                return Z_DATA_ERROR$1;
            }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
            state.mode = MEM;
            return Z_MEM_ERROR$1;
        }
        state.havedict = 1;
        return Z_OK$1;
    };
    var inflateReset_1 = inflateReset;
    var inflateReset2_1 = inflateReset2;
    var inflateResetKeep_1 = inflateResetKeep;
    var inflateInit_1 = inflateInit;
    var inflateInit2_1 = inflateInit2;
    var inflate_2$1 = inflate$2;
    var inflateEnd_1 = inflateEnd;
    var inflateGetHeader_1 = inflateGetHeader;
    var inflateSetDictionary_1 = inflateSetDictionary;
    var inflateInfo = "pako inflate (from Nodeca project)";
    var inflate_1$2 = {
        inflateReset: inflateReset_1,
        inflateReset2: inflateReset2_1,
        inflateResetKeep: inflateResetKeep_1,
        inflateInit: inflateInit_1,
        inflateInit2: inflateInit2_1,
        inflate: inflate_2$1,
        inflateEnd: inflateEnd_1,
        inflateGetHeader: inflateGetHeader_1,
        inflateSetDictionary: inflateSetDictionary_1,
        inflateInfo
    };
    function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
    }
    var gzheader = GZheader;
    const toString = Object.prototype.toString;
    const { Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR } = constants$2$1;
    function Inflate$1(options) {
        this.options = common.assign({
            chunkSize: 1024 * 64,
            windowBits: 15,
            to: ""
        }, options || {});
        const opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) {
                opt.windowBits = -15;
            }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
            opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
            if ((opt.windowBits & 15) === 0) {
                opt.windowBits |= 15;
            }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new zstream();
        this.strm.avail_out = 0;
        let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
        if (status !== Z_OK) {
            throw new Error(messages[status]);
        }
        this.header = new gzheader();
        inflate_1$2.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
            if (typeof opt.dictionary === "string") {
                opt.dictionary = strings.string2buf(opt.dictionary);
            } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
                opt.dictionary = new Uint8Array(opt.dictionary);
            }
            if (opt.raw) {
                status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
                if (status !== Z_OK) {
                    throw new Error(messages[status]);
                }
            }
        }
    }
    Inflate$1.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        const dictionary = this.options.dictionary;
        let status, _flush_mode, last_avail_out;
        if (this.ended) return false;
        if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
        else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for(;;){
            if (strm.avail_out === 0) {
                strm.output = new Uint8Array(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }
            status = inflate_1$2.inflate(strm, _flush_mode);
            if (status === Z_NEED_DICT && dictionary) {
                status = inflate_1$2.inflateSetDictionary(strm, dictionary);
                if (status === Z_OK) {
                    status = inflate_1$2.inflate(strm, _flush_mode);
                } else if (status === Z_DATA_ERROR) {
                    status = Z_NEED_DICT;
                }
            }
            while(strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0){
                inflate_1$2.inflateReset(strm);
                status = inflate_1$2.inflate(strm, _flush_mode);
            }
            switch(status){
                case Z_STREAM_ERROR:
                case Z_DATA_ERROR:
                case Z_NEED_DICT:
                case Z_MEM_ERROR:
                    this.onEnd(status);
                    this.ended = true;
                    return false;
            }
            last_avail_out = strm.avail_out;
            if (strm.next_out) {
                if (strm.avail_out === 0 || status === Z_STREAM_END) {
                    if (this.options.to === "string") {
                        let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                        let tail = strm.next_out - next_out_utf8;
                        let utf8str = strings.buf2string(strm.output, next_out_utf8);
                        strm.next_out = tail;
                        strm.avail_out = chunkSize - tail;
                        if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                        this.onData(utf8str);
                    } else {
                        this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                    }
                }
            }
            if (status === Z_OK && last_avail_out === 0) continue;
            if (status === Z_STREAM_END) {
                status = inflate_1$2.inflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return true;
            }
            if (strm.avail_in === 0) break;
        }
        return true;
    };
    Inflate$1.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
    };
    Inflate$1.prototype.onEnd = function(status) {
        if (status === Z_OK) {
            if (this.options.to === "string") {
                this.result = this.chunks.join("");
            } else {
                this.result = common.flattenChunks(this.chunks);
            }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };
    function inflate$1(input, options) {
        const inflator = new Inflate$1(options);
        inflator.push(input);
        if (inflator.err) throw inflator.msg || messages[inflator.err];
        return inflator.result;
    }
    function inflateRaw$1(input, options) {
        options = options || {};
        options.raw = true;
        return inflate$1(input, options);
    }
    var Inflate_1$1 = Inflate$1;
    var inflate_2 = inflate$1;
    var inflateRaw_1$1 = inflateRaw$1;
    var ungzip$1 = inflate$1;
    var inflate_1$1 = {
        Inflate: Inflate_1$1,
        inflate: inflate_2,
        inflateRaw: inflateRaw_1$1,
        ungzip: ungzip$1
    };
    const { Deflate, deflate: deflate$3, deflateRaw: deflateRaw$2, gzip: gzip$2 } = deflate_1$1;
    const { Inflate, inflate: inflate$3, inflateRaw: inflateRaw$2, ungzip } = inflate_1$1;
    var Deflate_1 = Deflate;
    var deflate_1 = deflate$3;
    var deflateRaw_1 = deflateRaw$2;
    var gzip_1 = gzip$2;
    var Inflate_1 = Inflate;
    var inflate_1 = inflate$3;
    var inflateRaw_1 = inflateRaw$2;
    var ungzip_1 = ungzip;
    var constants_1 = constants$2$1;
    var pako = {
        Deflate: Deflate_1,
        deflate: deflate_1,
        deflateRaw: deflateRaw_1,
        gzip: gzip_1,
        Inflate: Inflate_1,
        inflate: inflate_1,
        inflateRaw: inflateRaw_1,
        ungzip: ungzip_1,
        constants: constants_1
    };
    let brotliModule = null;
    let brotliLoadPromise = null;
    async function loadBrotli() {
        if (brotliModule) return brotliModule;
        if (!brotliLoadPromise) {
            brotliLoadPromise = (async ()=>{
                try {
                    const brotliWasmModule = await Promise.resolve().then(function() {
                        return index_web$1;
                    });
                    brotliModule = await brotliWasmModule.default;
                    console.log("[zlib] brotli-wasm loaded successfully");
                    return brotliModule;
                } catch (error) {
                    console.error("[zlib] Failed to load brotli-wasm:", error);
                    return null;
                }
            })();
        }
        return brotliLoadPromise;
    }
    function gzip(buffer, callback) {
        try {
            const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
            const result = pako.gzip(input);
            callback(null, BufferPolyfill.from(result));
        } catch (error) {
            callback(error, BufferPolyfill.alloc(0));
        }
    }
    function gunzip(buffer, callback) {
        try {
            const result = pako.ungzip(buffer);
            callback(null, BufferPolyfill.from(result));
        } catch (error) {
            callback(error, BufferPolyfill.alloc(0));
        }
    }
    function deflate(buffer, callback) {
        try {
            const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
            const result = pako.deflate(input);
            callback(null, BufferPolyfill.from(result));
        } catch (error) {
            callback(error, BufferPolyfill.alloc(0));
        }
    }
    function inflate(buffer, callback) {
        try {
            const result = pako.inflate(buffer);
            callback(null, BufferPolyfill.from(result));
        } catch (error) {
            callback(error, BufferPolyfill.alloc(0));
        }
    }
    function deflateRaw(buffer, callback) {
        try {
            const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
            const result = pako.deflateRaw(input);
            callback(null, BufferPolyfill.from(result));
        } catch (error) {
            callback(error, BufferPolyfill.alloc(0));
        }
    }
    function inflateRaw(buffer, callback) {
        try {
            const result = pako.inflateRaw(buffer);
            callback(null, BufferPolyfill.from(result));
        } catch (error) {
            callback(error, BufferPolyfill.alloc(0));
        }
    }
    function brotliCompress(buffer, options, callback) {
        if (typeof options === "function") {
            callback = options;
        }
        loadBrotli().then((brotli)=>{
            if (!brotli) {
                callback(new Error("Brotli WASM failed to load"), BufferPolyfill.alloc(0));
                return;
            }
            try {
                const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
                const result = brotli.compress(new Uint8Array(input));
                callback(null, BufferPolyfill.from(result));
            } catch (error) {
                callback(error, BufferPolyfill.alloc(0));
            }
        }).catch((error)=>{
            callback(error, BufferPolyfill.alloc(0));
        });
    }
    function brotliDecompress(buffer, options, callback) {
        if (typeof options === "function") {
            callback = options;
        }
        loadBrotli().then((brotli)=>{
            if (!brotli) {
                callback(new Error("Brotli WASM failed to load"), BufferPolyfill.alloc(0));
                return;
            }
            try {
                const result = brotli.decompress(new Uint8Array(buffer));
                callback(null, BufferPolyfill.from(result));
            } catch (error) {
                callback(error, BufferPolyfill.alloc(0));
            }
        }).catch((error)=>{
            callback(error, BufferPolyfill.alloc(0));
        });
    }
    function brotliCompressSync(buffer, _options) {
        if (!brotliModule) {
            throw new Error("Brotli WASM not loaded. Call brotliCompress first to initialize.");
        }
        const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
        return BufferPolyfill.from(brotliModule.compress(new Uint8Array(input)));
    }
    function brotliDecompressSync(buffer, _options) {
        if (!brotliModule) {
            throw new Error("Brotli WASM not loaded. Call brotliDecompress first to initialize.");
        }
        return BufferPolyfill.from(brotliModule.decompress(new Uint8Array(buffer)));
    }
    function gzipSync(buffer) {
        const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
        return BufferPolyfill.from(pako.gzip(input));
    }
    function gunzipSync(buffer) {
        return BufferPolyfill.from(pako.ungzip(buffer));
    }
    function deflateSync(buffer) {
        const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
        return BufferPolyfill.from(pako.deflate(input));
    }
    function inflateSync(buffer) {
        return BufferPolyfill.from(pako.inflate(buffer));
    }
    function deflateRawSync(buffer) {
        const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
        return BufferPolyfill.from(pako.deflateRaw(input));
    }
    function inflateRawSync(buffer) {
        return BufferPolyfill.from(pako.inflateRaw(buffer));
    }
    const constants$3 = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_VERSION_ERROR: -6,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        ZLIB_VERNUM: 4784,
        Z_MIN_WINDOWBITS: 8,
        Z_MAX_WINDOWBITS: 15,
        Z_DEFAULT_WINDOWBITS: 15,
        Z_MIN_CHUNK: 64,
        Z_MAX_CHUNK: Infinity,
        Z_DEFAULT_CHUNK: 16384,
        Z_MIN_MEMLEVEL: 1,
        Z_MAX_MEMLEVEL: 9,
        Z_DEFAULT_MEMLEVEL: 8,
        Z_MIN_LEVEL: -1,
        Z_MAX_LEVEL: 9,
        Z_DEFAULT_LEVEL: -1,
        BROTLI_DECODE: 0,
        BROTLI_ENCODE: 1,
        BROTLI_OPERATION_PROCESS: 0,
        BROTLI_OPERATION_FLUSH: 1,
        BROTLI_OPERATION_FINISH: 2,
        BROTLI_OPERATION_EMIT_METADATA: 3,
        BROTLI_PARAM_MODE: 0,
        BROTLI_MODE_GENERIC: 0,
        BROTLI_MODE_TEXT: 1,
        BROTLI_MODE_FONT: 2,
        BROTLI_PARAM_QUALITY: 1,
        BROTLI_MIN_QUALITY: 0,
        BROTLI_MAX_QUALITY: 11,
        BROTLI_DEFAULT_QUALITY: 11,
        BROTLI_PARAM_LGWIN: 2,
        BROTLI_MIN_WINDOW_BITS: 10,
        BROTLI_MAX_WINDOW_BITS: 24,
        BROTLI_DEFAULT_WINDOW: 22,
        BROTLI_PARAM_LGBLOCK: 3,
        BROTLI_MIN_INPUT_BLOCK_BITS: 16,
        BROTLI_MAX_INPUT_BLOCK_BITS: 24
    };
    var zlib = {
        gzip,
        gunzip,
        deflate,
        inflate,
        deflateRaw,
        inflateRaw,
        gzipSync,
        gunzipSync,
        deflateSync,
        inflateSync,
        deflateRawSync,
        inflateRawSync,
        brotliCompress,
        brotliDecompress,
        brotliCompressSync,
        brotliDecompressSync,
        constants: constants$3
    };
    var zlibShim = Object.freeze({
        __proto__: null,
        brotliCompress: brotliCompress,
        brotliCompressSync: brotliCompressSync,
        brotliDecompress: brotliDecompress,
        brotliDecompressSync: brotliDecompressSync,
        constants: constants$3,
        default: zlib,
        deflate: deflate,
        deflateRaw: deflateRaw,
        deflateRawSync: deflateRawSync,
        deflateSync: deflateSync,
        gunzip: gunzip,
        gunzipSync: gunzipSync,
        gzip: gzip,
        gzipSync: gzipSync,
        inflate: inflate,
        inflateRaw: inflateRaw,
        inflateRawSync: inflateRawSync,
        inflateSync: inflateSync
    });
    function lookup(hostname, optionsOrCallback, callback) {
        const cb = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
        const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {};
        setImmediate(()=>{
            if (hostname === "localhost" || hostname === "127.0.0.1") {
                if (options.all) {
                    cb(null, [
                        {
                            address: "127.0.0.1",
                            family: 4
                        }
                    ]);
                } else {
                    cb(null, "127.0.0.1", 4);
                }
            } else {
                if (options.all) {
                    cb(null, [
                        {
                            address: "0.0.0.0",
                            family: 4
                        }
                    ]);
                } else {
                    cb(null, "0.0.0.0", 4);
                }
            }
        });
    }
    function resolve(hostname, callback) {
        setImmediate(()=>{
            callback(null, [
                "0.0.0.0"
            ]);
        });
    }
    function resolve4(hostname, callback) {
        resolve(hostname, callback);
    }
    function resolve6(hostname, callback) {
        setImmediate(()=>{
            callback(null, [
                "::1"
            ]);
        });
    }
    function reverse(ip, callback) {
        setImmediate(()=>{
            callback(null, [
                "localhost"
            ]);
        });
    }
    function setServers(_servers) {}
    function getServers() {
        return [];
    }
    function setDefaultResultOrder(_order) {}
    function getDefaultResultOrder() {
        return "verbatim";
    }
    const promises$1 = {
        lookup: (hostname, options)=>{
            return new Promise((resolve2, reject)=>{
                if (options?.all) {
                    lookup(hostname, options, (err, addresses)=>{
                        if (err) reject(err);
                        else resolve2(addresses || []);
                    });
                    return;
                }
                lookup(hostname, options || {}, (err, address, family)=>{
                    if (err) reject(err);
                    else resolve2({
                        address,
                        family
                    });
                });
            });
        },
        resolve: (hostname)=>{
            return new Promise((promiseResolve, promiseReject)=>{
                resolve(hostname, (err, addresses)=>{
                    if (err) promiseReject(err);
                    else promiseResolve(addresses || []);
                });
            });
        },
        resolve4: (hostname)=>promises$1.resolve(hostname),
        resolve6: (hostname)=>{
            return new Promise((resolve2)=>{
                resolve2([
                    "::1"
                ]);
            });
        },
        reverse: (ip)=>{
            return new Promise((resolve2)=>{
                resolve2([
                    "localhost"
                ]);
            });
        },
        setServers: (_servers)=>{},
        getServers: ()=>[]
    };
    const ADDRCONFIG = 0;
    const V4MAPPED = 0;
    const ALL = 0;
    var dns = {
        lookup,
        resolve,
        resolve4,
        resolve6,
        reverse,
        setServers,
        getServers,
        setDefaultResultOrder,
        getDefaultResultOrder,
        promises: promises$1,
        ADDRCONFIG,
        V4MAPPED,
        ALL
    };
    var dnsShim = Object.freeze({
        __proto__: null,
        ADDRCONFIG: ADDRCONFIG,
        ALL: ALL,
        V4MAPPED: V4MAPPED,
        default: dns,
        getDefaultResultOrder: getDefaultResultOrder,
        getServers: getServers,
        lookup: lookup,
        promises: promises$1,
        resolve: resolve,
        resolve4: resolve4,
        resolve6: resolve6,
        reverse: reverse,
        setDefaultResultOrder: setDefaultResultOrder,
        setServers: setServers
    });
    const Buffer$1 = BufferPolyfill;
    const SlowBuffer = BufferPolyfill;
    const kMaxLength = 2147483647;
    const INSPECT_MAX_BYTES = 50;
    const constants$2 = {
        MAX_LENGTH: kMaxLength,
        MAX_STRING_LENGTH: 536870888
    };
    function transcode(source, _fromEnc, _toEnc) {
        return Buffer$1.from(source);
    }
    function resolveObjectURL(id) {
        return void 0;
    }
    function atob$1(data) {
        return globalThis.atob(data);
    }
    function btoa$1(data) {
        return globalThis.btoa(data);
    }
    const bufferModule = {
        Buffer: Buffer$1,
        SlowBuffer,
        kMaxLength,
        INSPECT_MAX_BYTES,
        constants: constants$2,
        transcode,
        resolveObjectURL,
        atob: atob$1,
        btoa: btoa$1
    };
    Object.defineProperty(bufferModule, "hasOwnProperty", {
        value: Object.prototype.hasOwnProperty,
        enumerable: false,
        configurable: true,
        writable: true
    });
    var sprintf = {};
    (function(exports$1) {
        !function() {
            var re = {
                not_type: /[^T]/,
                not_primitive: /[^v]/,
                number: /[diefg]/,
                numeric_arg: /[bcdiefguxX]/,
                json: /[j]/,
                text: /^[^\x25]+/,
                modulo: /^\x25{2}/,
                placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
                key: /^([a-z_][a-z_\d]*)/i,
                key_access: /^\.([a-z_][a-z_\d]*)/i,
                index_access: /^\[(\d+)\]/,
                sign: /^[+-]/
            };
            function sprintf(key) {
                return sprintf_format(sprintf_parse(key), arguments);
            }
            function vsprintf(fmt, argv) {
                return sprintf.apply(null, [
                    fmt
                ].concat(argv || []));
            }
            function sprintf_format(parse_tree, argv) {
                var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
                for(i = 0; i < tree_length; i++){
                    if (typeof parse_tree[i] === "string") {
                        output += parse_tree[i];
                    } else if (typeof parse_tree[i] === "object") {
                        ph = parse_tree[i];
                        if (ph.keys) {
                            arg = argv[cursor];
                            for(k = 0; k < ph.keys.length; k++){
                                if (arg == void 0) {
                                    throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                                }
                                arg = arg[ph.keys[k]];
                            }
                        } else if (ph.param_no) {
                            arg = argv[ph.param_no];
                        } else {
                            arg = argv[cursor++];
                        }
                        if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                            arg = arg();
                        }
                        if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
                            throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
                        }
                        if (re.number.test(ph.type)) {
                            is_positive = arg >= 0;
                        }
                        switch(ph.type){
                            case "b":
                                arg = parseInt(arg, 10).toString(2);
                                break;
                            case "c":
                                arg = String.fromCharCode(parseInt(arg, 10));
                                break;
                            case "d":
                            case "i":
                                arg = parseInt(arg, 10);
                                break;
                            case "j":
                                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                                break;
                            case "e":
                                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                                break;
                            case "f":
                                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                                break;
                            case "g":
                                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                                break;
                            case "o":
                                arg = (parseInt(arg, 10) >>> 0).toString(8);
                                break;
                            case "s":
                                arg = String(arg);
                                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                                break;
                            case "t":
                                arg = String(!!arg);
                                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                                break;
                            case "T":
                                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                                break;
                            case "u":
                                arg = parseInt(arg, 10) >>> 0;
                                break;
                            case "v":
                                arg = arg.valueOf();
                                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                                break;
                            case "x":
                                arg = (parseInt(arg, 10) >>> 0).toString(16);
                                break;
                            case "X":
                                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                                break;
                        }
                        if (re.json.test(ph.type)) {
                            output += arg;
                        } else {
                            if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                                sign = is_positive ? "+" : "-";
                                arg = arg.toString().replace(re.sign, "");
                            } else {
                                sign = "";
                            }
                            pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
                            pad_length = ph.width - (sign + arg).length;
                            pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
                            output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
                        }
                    }
                }
                return output;
            }
            var sprintf_cache = Object.create(null);
            function sprintf_parse(fmt) {
                if (sprintf_cache[fmt]) {
                    return sprintf_cache[fmt];
                }
                var _fmt = fmt, match, parse_tree = [], arg_names = 0;
                while(_fmt){
                    if ((match = re.text.exec(_fmt)) !== null) {
                        parse_tree.push(match[0]);
                    } else if ((match = re.modulo.exec(_fmt)) !== null) {
                        parse_tree.push("%");
                    } else if ((match = re.placeholder.exec(_fmt)) !== null) {
                        if (match[2]) {
                            arg_names |= 1;
                            var field_list = [], replacement_field = match[2], field_match = [];
                            if ((field_match = re.key.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                                while((replacement_field = replacement_field.substring(field_match[0].length)) !== ""){
                                    if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                        field_list.push(field_match[1]);
                                    } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                        field_list.push(field_match[1]);
                                    } else {
                                        throw new SyntaxError("[sprintf] failed to parse named argument key");
                                    }
                                }
                            } else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key");
                            }
                            match[2] = field_list;
                        } else {
                            arg_names |= 2;
                        }
                        if (arg_names === 3) {
                            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
                        }
                        parse_tree.push({
                            placeholder: match[0],
                            param_no: match[1],
                            keys: match[2],
                            sign: match[3],
                            pad_char: match[4],
                            align: match[5],
                            width: match[6],
                            precision: match[7],
                            type: match[8]
                        });
                    } else {
                        throw new SyntaxError("[sprintf] unexpected placeholder");
                    }
                    _fmt = _fmt.substring(match[0].length);
                }
                return sprintf_cache[fmt] = parse_tree;
            }
            {
                exports$1["sprintf"] = sprintf;
                exports$1["vsprintf"] = vsprintf;
            }
            if (typeof window !== "undefined") {
                window["sprintf"] = sprintf;
                window["vsprintf"] = vsprintf;
            }
        }();
    }(sprintf));
    const balanced = (a, b, str)=>{
        const ma = a instanceof RegExp ? maybeMatch(a, str) : a;
        const mb = b instanceof RegExp ? maybeMatch(b, str) : b;
        const r = ma !== null && mb != null && range(ma, mb, str);
        return (r && {
            start: r[0],
            end: r[1],
            pre: str.slice(0, r[0]),
            body: str.slice(r[0] + ma.length, r[1]),
            post: str.slice(r[1] + mb.length)
        });
    };
    const maybeMatch = (reg, str)=>{
        const m = str.match(reg);
        return m ? m[0] : null;
    };
    const range = (a, b, str)=>{
        let begs, beg, left, right = undefined, result;
        let ai = str.indexOf(a);
        let bi = str.indexOf(b, ai + 1);
        let i = ai;
        if (ai >= 0 && bi > 0) {
            if (a === b) {
                return [
                    ai,
                    bi
                ];
            }
            begs = [];
            left = str.length;
            while(i >= 0 && !result){
                if (i === ai) {
                    begs.push(i);
                    ai = str.indexOf(a, i + 1);
                } else if (begs.length === 1) {
                    const r = begs.pop();
                    if (r !== undefined) result = [
                        r,
                        bi
                    ];
                } else {
                    beg = begs.pop();
                    if (beg !== undefined && beg < left) {
                        left = beg;
                        right = bi;
                    }
                    bi = str.indexOf(b, i + 1);
                }
                i = ai < bi && ai >= 0 ? ai : bi;
            }
            if (begs.length && right !== undefined) {
                result = [
                    left,
                    right
                ];
            }
        }
        return result;
    };
    const escSlash = '\0SLASH' + Math.random() + '\0';
    const escOpen = '\0OPEN' + Math.random() + '\0';
    const escClose = '\0CLOSE' + Math.random() + '\0';
    const escComma = '\0COMMA' + Math.random() + '\0';
    const escPeriod = '\0PERIOD' + Math.random() + '\0';
    const escSlashPattern = new RegExp(escSlash, 'g');
    const escOpenPattern = new RegExp(escOpen, 'g');
    const escClosePattern = new RegExp(escClose, 'g');
    const escCommaPattern = new RegExp(escComma, 'g');
    const escPeriodPattern = new RegExp(escPeriod, 'g');
    const slashPattern = /\\\\/g;
    const openPattern = /\\{/g;
    const closePattern = /\\}/g;
    const commaPattern = /\\,/g;
    const periodPattern = /\\./g;
    function numeric(str) {
        return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
        return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
    }
    function unescapeBraces(str) {
        return str.replace(escSlashPattern, '\\').replace(escOpenPattern, '{').replace(escClosePattern, '}').replace(escCommaPattern, ',').replace(escPeriodPattern, '.');
    }
    function parseCommaParts(str) {
        if (!str) {
            return [
                ''
            ];
        }
        const parts = [];
        const m = balanced('{', '}', str);
        if (!m) {
            return str.split(',');
        }
        const { pre, body, post } = m;
        const p = pre.split(',');
        p[p.length - 1] += '{' + body + '}';
        const postParts = parseCommaParts(post);
        if (post.length) {
            p[p.length - 1] += postParts.shift();
            p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
    }
    function expand(str) {
        if (!str) {
            return [];
        }
        if (str.slice(0, 2) === '{}') {
            str = '\\{\\}' + str.slice(2);
        }
        return expand_(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
        return '{' + str + '}';
    }
    function isPadded(el) {
        return /^-?0\d/.test(el);
    }
    function lte(i, y) {
        return i <= y;
    }
    function gte(i, y) {
        return i >= y;
    }
    function expand_(str, isTop) {
        const expansions = [];
        const m = balanced('{', '}', str);
        if (!m) return [
            str
        ];
        const pre = m.pre;
        const post = m.post.length ? expand_(m.post, false) : [
            ''
        ];
        if (/\$$/.test(m.pre)) {
            for(let k = 0; k < post.length; k++){
                const expansion = pre + '{' + m.body + '}' + post[k];
                expansions.push(expansion);
            }
        } else {
            const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
            const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
            const isSequence = isNumericSequence || isAlphaSequence;
            const isOptions = m.body.indexOf(',') >= 0;
            if (!isSequence && !isOptions) {
                if (m.post.match(/,(?!,).*\}/)) {
                    str = m.pre + '{' + m.body + escClose + m.post;
                    return expand_(str);
                }
                return [
                    str
                ];
            }
            let n;
            if (isSequence) {
                n = m.body.split(/\.\./);
            } else {
                n = parseCommaParts(m.body);
                if (n.length === 1 && n[0] !== undefined) {
                    n = expand_(n[0], false).map(embrace);
                    if (n.length === 1) {
                        return post.map((p)=>m.pre + n[0] + p);
                    }
                }
            }
            let N;
            if (isSequence && n[0] !== undefined && n[1] !== undefined) {
                const x = numeric(n[0]);
                const y = numeric(n[1]);
                const width = Math.max(n[0].length, n[1].length);
                let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;
                let test = lte;
                const reverse = y < x;
                if (reverse) {
                    incr *= -1;
                    test = gte;
                }
                const pad = n.some(isPadded);
                N = [];
                for(let i = x; test(i, y); i += incr){
                    let c;
                    if (isAlphaSequence) {
                        c = String.fromCharCode(i);
                        if (c === '\\') {
                            c = '';
                        }
                    } else {
                        c = String(i);
                        if (pad) {
                            const need = width - c.length;
                            if (need > 0) {
                                const z = new Array(need + 1).join('0');
                                if (i < 0) {
                                    c = '-' + z + c.slice(1);
                                } else {
                                    c = z + c;
                                }
                            }
                        }
                    }
                    N.push(c);
                }
            } else {
                N = [];
                for(let j = 0; j < n.length; j++){
                    N.push.apply(N, expand_(n[j], false));
                }
            }
            for(let j = 0; j < N.length; j++){
                for(let k = 0; k < post.length; k++){
                    const expansion = pre + N[j] + post[k];
                    if (!isTop || isSequence || expansion) {
                        expansions.push(expansion);
                    }
                }
            }
        }
        return expansions;
    }
    const MAX_PATTERN_LENGTH = 1024 * 64;
    const assertValidPattern = (pattern)=>{
        if (typeof pattern !== 'string') {
            throw new TypeError('invalid pattern');
        }
        if (pattern.length > MAX_PATTERN_LENGTH) {
            throw new TypeError('pattern is too long');
        }
    };
    const posixClasses = {
        '[:alnum:]': [
            '\\p{L}\\p{Nl}\\p{Nd}',
            true
        ],
        '[:alpha:]': [
            '\\p{L}\\p{Nl}',
            true
        ],
        '[:ascii:]': [
            '\\x' + '00-\\x' + '7f',
            false
        ],
        '[:blank:]': [
            '\\p{Zs}\\t',
            true
        ],
        '[:cntrl:]': [
            '\\p{Cc}',
            true
        ],
        '[:digit:]': [
            '\\p{Nd}',
            true
        ],
        '[:graph:]': [
            '\\p{Z}\\p{C}',
            true,
            true
        ],
        '[:lower:]': [
            '\\p{Ll}',
            true
        ],
        '[:print:]': [
            '\\p{C}',
            true
        ],
        '[:punct:]': [
            '\\p{P}',
            true
        ],
        '[:space:]': [
            '\\p{Z}\\t\\r\\n\\v\\f',
            true
        ],
        '[:upper:]': [
            '\\p{Lu}',
            true
        ],
        '[:word:]': [
            '\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}',
            true
        ],
        '[:xdigit:]': [
            'A-Fa-f0-9',
            false
        ]
    };
    const braceEscape = (s)=>s.replace(/[[\]\\-]/g, '\\$&');
    const regexpEscape = (s)=>s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    const rangesToString = (ranges)=>ranges.join('');
    const parseClass = (glob, position)=>{
        const pos = position;
        if (glob.charAt(pos) !== '[') {
            throw new Error('not in a brace expression');
        }
        const ranges = [];
        const negs = [];
        let i = pos + 1;
        let sawStart = false;
        let uflag = false;
        let escaping = false;
        let negate = false;
        let endPos = pos;
        let rangeStart = '';
        WHILE: while(i < glob.length){
            const c = glob.charAt(i);
            if ((c === '!' || c === '^') && i === pos + 1) {
                negate = true;
                i++;
                continue;
            }
            if (c === ']' && sawStart && !escaping) {
                endPos = i + 1;
                break;
            }
            sawStart = true;
            if (c === '\\') {
                if (!escaping) {
                    escaping = true;
                    i++;
                    continue;
                }
            }
            if (c === '[' && !escaping) {
                for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)){
                    if (glob.startsWith(cls, i)) {
                        if (rangeStart) {
                            return [
                                '$.',
                                false,
                                glob.length - pos,
                                true
                            ];
                        }
                        i += cls.length;
                        if (neg) negs.push(unip);
                        else ranges.push(unip);
                        uflag = uflag || u;
                        continue WHILE;
                    }
                }
            }
            escaping = false;
            if (rangeStart) {
                if (c > rangeStart) {
                    ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
                } else if (c === rangeStart) {
                    ranges.push(braceEscape(c));
                }
                rangeStart = '';
                i++;
                continue;
            }
            if (glob.startsWith('-]', i + 1)) {
                ranges.push(braceEscape(c + '-'));
                i += 2;
                continue;
            }
            if (glob.startsWith('-', i + 1)) {
                rangeStart = c;
                i += 2;
                continue;
            }
            ranges.push(braceEscape(c));
            i++;
        }
        if (endPos < i) {
            return [
                '',
                false,
                0,
                false
            ];
        }
        if (!ranges.length && !negs.length) {
            return [
                '$.',
                false,
                glob.length - pos,
                true
            ];
        }
        if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
            const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
            return [
                regexpEscape(r),
                false,
                endPos - pos,
                false
            ];
        }
        const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
        const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
        const comb = ranges.length && negs.length ? '(' + sranges + '|' + snegs + ')' : ranges.length ? sranges : snegs;
        return [
            comb,
            uflag,
            endPos - pos,
            true
        ];
    };
    const unescape = (s, { windowsPathsNoEscape = false, magicalBraces = true } = {})=>{
        if (magicalBraces) {
            return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, '$1') : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1');
        }
        return windowsPathsNoEscape ? s.replace(/\[([^\/\\{}])\]/g, '$1') : s.replace(/((?!\\).|^)\[([^\/\\{}])\]/g, '$1$2').replace(/\\([^\/{}])/g, '$1');
    };
    const types = new Set([
        '!',
        '?',
        '+',
        '*',
        '@'
    ]);
    const isExtglobType = (c)=>types.has(c);
    const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
    const startNoDot = '(?!\\.)';
    const addPatternStart = new Set([
        '[',
        '.'
    ]);
    const justDots = new Set([
        '..',
        '.'
    ]);
    const reSpecials = new Set('().*{}+?[]^$\\!');
    const regExpEscape$1 = (s)=>s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    const qmark$1 = '[^/]';
    const star$1 = qmark$1 + '*?';
    const starNoEmpty = qmark$1 + '+?';
    class AST {
        type;
        #root;
        #hasMagic;
        #uflag = false;
        #parts = [];
        #parent;
        #parentIndex;
        #negs;
        #filledNegs = false;
        #options;
        #toString;
        #emptyExt = false;
        constructor(type, parent, options = {}){
            this.type = type;
            if (type) this.#hasMagic = true;
            this.#parent = parent;
            this.#root = this.#parent ? this.#parent.#root : this;
            this.#options = this.#root === this ? options : this.#root.#options;
            this.#negs = this.#root === this ? [] : this.#root.#negs;
            if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this);
            this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
        }
        get hasMagic() {
            if (this.#hasMagic !== undefined) return this.#hasMagic;
            for (const p of this.#parts){
                if (typeof p === 'string') continue;
                if (p.type || p.hasMagic) return (this.#hasMagic = true);
            }
            return this.#hasMagic;
        }
        toString() {
            if (this.#toString !== undefined) return this.#toString;
            if (!this.type) {
                return (this.#toString = this.#parts.map((p)=>String(p)).join(''));
            } else {
                return (this.#toString = this.type + '(' + this.#parts.map((p)=>String(p)).join('|') + ')');
            }
        }
        #fillNegs() {
            if (this !== this.#root) throw new Error('should only call on root');
            if (this.#filledNegs) return this;
            this.toString();
            this.#filledNegs = true;
            let n;
            while((n = this.#negs.pop())){
                if (n.type !== '!') continue;
                let p = n;
                let pp = p.#parent;
                while(pp){
                    for(let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++){
                        for (const part of n.#parts){
                            if (typeof part === 'string') {
                                throw new Error('string part in extglob AST??');
                            }
                            part.copyIn(pp.#parts[i]);
                        }
                    }
                    p = pp;
                    pp = p.#parent;
                }
            }
            return this;
        }
        push(...parts) {
            for (const p of parts){
                if (p === '') continue;
                if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                    throw new Error('invalid part: ' + p);
                }
                this.#parts.push(p);
            }
        }
        toJSON() {
            const ret = this.type === null ? this.#parts.slice().map((p)=>(typeof p === 'string' ? p : p.toJSON())) : [
                this.type,
                ...this.#parts.map((p)=>p.toJSON())
            ];
            if (this.isStart() && !this.type) ret.unshift([]);
            if (this.isEnd() && (this === this.#root || (this.#root.#filledNegs && this.#parent?.type === '!'))) {
                ret.push({});
            }
            return ret;
        }
        isStart() {
            if (this.#root === this) return true;
            if (!this.#parent?.isStart()) return false;
            if (this.#parentIndex === 0) return true;
            const p = this.#parent;
            for(let i = 0; i < this.#parentIndex; i++){
                const pp = p.#parts[i];
                if (!(pp instanceof AST && pp.type === '!')) {
                    return false;
                }
            }
            return true;
        }
        isEnd() {
            if (this.#root === this) return true;
            if (this.#parent?.type === '!') return true;
            if (!this.#parent?.isEnd()) return false;
            if (!this.type) return this.#parent?.isEnd();
            const pl = this.#parent ? this.#parent.#parts.length : 0;
            return this.#parentIndex === pl - 1;
        }
        copyIn(part) {
            if (typeof part === 'string') this.push(part);
            else this.push(part.clone(this));
        }
        clone(parent) {
            const c = new AST(this.type, parent);
            for (const p of this.#parts){
                c.copyIn(p);
            }
            return c;
        }
        static #parseAST(str, ast, pos, opt) {
            let escaping = false;
            let inBrace = false;
            let braceStart = -1;
            let braceNeg = false;
            if (ast.type === null) {
                let i = pos;
                let acc = '';
                while(i < str.length){
                    const c = str.charAt(i++);
                    if (escaping || c === '\\') {
                        escaping = !escaping;
                        acc += c;
                        continue;
                    }
                    if (inBrace) {
                        if (i === braceStart + 1) {
                            if (c === '^' || c === '!') {
                                braceNeg = true;
                            }
                        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                            inBrace = false;
                        }
                        acc += c;
                        continue;
                    } else if (c === '[') {
                        inBrace = true;
                        braceStart = i;
                        braceNeg = false;
                        acc += c;
                        continue;
                    }
                    if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                        ast.push(acc);
                        acc = '';
                        const ext = new AST(c, ast);
                        i = AST.#parseAST(str, ext, i, opt);
                        ast.push(ext);
                        continue;
                    }
                    acc += c;
                }
                ast.push(acc);
                return i;
            }
            let i = pos + 1;
            let part = new AST(null, ast);
            const parts = [];
            let acc = '';
            while(i < str.length){
                const c = str.charAt(i++);
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                } else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (isExtglobType(c) && str.charAt(i) === '(') {
                    part.push(acc);
                    acc = '';
                    const ext = new AST(c, part);
                    part.push(ext);
                    i = AST.#parseAST(str, ext, i, opt);
                    continue;
                }
                if (c === '|') {
                    part.push(acc);
                    acc = '';
                    parts.push(part);
                    part = new AST(null, ast);
                    continue;
                }
                if (c === ')') {
                    if (acc === '' && ast.#parts.length === 0) {
                        ast.#emptyExt = true;
                    }
                    part.push(acc);
                    acc = '';
                    ast.push(...parts, part);
                    return i;
                }
                acc += c;
            }
            ast.type = null;
            ast.#hasMagic = undefined;
            ast.#parts = [
                str.substring(pos - 1)
            ];
            return i;
        }
        static fromGlob(pattern, options = {}) {
            const ast = new AST(null, undefined, options);
            AST.#parseAST(pattern, ast, 0, options);
            return ast;
        }
        toMMPattern() {
            if (this !== this.#root) return this.#root.toMMPattern();
            const glob = this.toString();
            const [re, body, hasMagic, uflag] = this.toRegExpSource();
            const anyMagic = hasMagic || this.#hasMagic || (this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase());
            if (!anyMagic) {
                return body;
            }
            const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
            return Object.assign(new RegExp(`^${re}$`, flags), {
                _src: re,
                _glob: glob
            });
        }
        get options() {
            return this.#options;
        }
        toRegExpSource(allowDot) {
            const dot = allowDot ?? !!this.#options.dot;
            if (this.#root === this) this.#fillNegs();
            if (!this.type) {
                const noEmpty = this.isStart() && this.isEnd() && !this.#parts.some((s)=>typeof s !== 'string');
                const src = this.#parts.map((p)=>{
                    const [re, _, hasMagic, uflag] = typeof p === 'string' ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
                    this.#hasMagic = this.#hasMagic || hasMagic;
                    this.#uflag = this.#uflag || uflag;
                    return re;
                }).join('');
                let start = '';
                if (this.isStart()) {
                    if (typeof this.#parts[0] === 'string') {
                        const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                        if (!dotTravAllowed) {
                            const aps = addPatternStart;
                            const needNoTrav = (dot && aps.has(src.charAt(0))) || (src.startsWith('\\.') && aps.has(src.charAt(2))) || (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                        }
                    }
                }
                let end = '';
                if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === '!') {
                    end = '(?:$|\\/)';
                }
                const final = start + src + end;
                return [
                    final,
                    unescape(src),
                    (this.#hasMagic = !!this.#hasMagic),
                    this.#uflag
                ];
            }
            const repeated = this.type === '*' || this.type === '+';
            const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
            let body = this.#partsToRegExp(dot);
            if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
                const s = this.toString();
                this.#parts = [
                    s
                ];
                this.type = null;
                this.#hasMagic = undefined;
                return [
                    s,
                    unescape(this.toString()),
                    false,
                    false
                ];
            }
            let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? '' : this.#partsToRegExp(true);
            if (bodyDotAllowed === body) {
                bodyDotAllowed = '';
            }
            if (bodyDotAllowed) {
                body = `(?:${body})(?:${bodyDotAllowed})*?`;
            }
            let final = '';
            if (this.type === '!' && this.#emptyExt) {
                final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
            } else {
                const close = this.type === '!' ? '))' + (this.isStart() && !dot && !allowDot ? startNoDot : '') + star$1 + ')' : this.type === '@' ? ')' : this.type === '?' ? ')?' : this.type === '+' && bodyDotAllowed ? ')' : this.type === '*' && bodyDotAllowed ? `)?` : `)${this.type}`;
                final = start + body + close;
            }
            return [
                final,
                unescape(body),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag
            ];
        }
        #partsToRegExp(dot) {
            return this.#parts.map((p)=>{
                if (typeof p === 'string') {
                    throw new Error('string type in extglob ast??');
                }
                const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
                this.#uflag = this.#uflag || uflag;
                return re;
            }).filter((p)=>!(this.isStart() && this.isEnd()) || !!p).join('|');
        }
        static #parseGlob(glob, hasMagic, noEmpty = false) {
            let escaping = false;
            let re = '';
            let uflag = false;
            for(let i = 0; i < glob.length; i++){
                const c = glob.charAt(i);
                if (escaping) {
                    escaping = false;
                    re += (reSpecials.has(c) ? '\\' : '') + c;
                    continue;
                }
                if (c === '\\') {
                    if (i === glob.length - 1) {
                        re += '\\\\';
                    } else {
                        escaping = true;
                    }
                    continue;
                }
                if (c === '[') {
                    const [src, needUflag, consumed, magic] = parseClass(glob, i);
                    if (consumed) {
                        re += src;
                        uflag = uflag || needUflag;
                        i += consumed - 1;
                        hasMagic = hasMagic || magic;
                        continue;
                    }
                }
                if (c === '*') {
                    re += noEmpty && glob === '*' ? starNoEmpty : star$1;
                    hasMagic = true;
                    continue;
                }
                if (c === '?') {
                    re += qmark$1;
                    hasMagic = true;
                    continue;
                }
                re += regExpEscape$1(c);
            }
            return [
                re,
                unescape(glob),
                !!hasMagic,
                uflag
            ];
        }
    }
    const escape = (s, { windowsPathsNoEscape = false, magicalBraces = false } = {})=>{
        if (magicalBraces) {
            return windowsPathsNoEscape ? s.replace(/[?*()[\]{}]/g, '[$&]') : s.replace(/[?*()[\]\\{}]/g, '\\$&');
        }
        return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, '[$&]') : s.replace(/[?*()[\]\\]/g, '\\$&');
    };
    var define_process_env_default$1 = {};
    const minimatch = (p, pattern, options = {})=>{
        assertValidPattern(pattern);
        if (!options.nocomment && pattern.charAt(0) === "#") {
            return false;
        }
        return new Minimatch(pattern, options).match(p);
    };
    const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
    const starDotExtTest = (ext2)=>(f)=>!f.startsWith(".") && f.endsWith(ext2);
    const starDotExtTestDot = (ext2)=>(f)=>f.endsWith(ext2);
    const starDotExtTestNocase = (ext2)=>{
        ext2 = ext2.toLowerCase();
        return (f)=>!f.startsWith(".") && f.toLowerCase().endsWith(ext2);
    };
    const starDotExtTestNocaseDot = (ext2)=>{
        ext2 = ext2.toLowerCase();
        return (f)=>f.toLowerCase().endsWith(ext2);
    };
    const starDotStarRE = /^\*+\.\*+$/;
    const starDotStarTest = (f)=>!f.startsWith(".") && f.includes(".");
    const starDotStarTestDot = (f)=>f !== "." && f !== ".." && f.includes(".");
    const dotStarRE = /^\.\*+$/;
    const dotStarTest = (f)=>f !== "." && f !== ".." && f.startsWith(".");
    const starRE = /^\*+$/;
    const starTest = (f)=>f.length !== 0 && !f.startsWith(".");
    const starTestDot = (f)=>f.length !== 0 && f !== "." && f !== "..";
    const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
    const qmarksTestNocase = ([$0, ext2 = ""])=>{
        const noext = qmarksTestNoExt([
            $0
        ]);
        if (!ext2) return noext;
        ext2 = ext2.toLowerCase();
        return (f)=>noext(f) && f.toLowerCase().endsWith(ext2);
    };
    const qmarksTestNocaseDot = ([$0, ext2 = ""])=>{
        const noext = qmarksTestNoExtDot([
            $0
        ]);
        if (!ext2) return noext;
        ext2 = ext2.toLowerCase();
        return (f)=>noext(f) && f.toLowerCase().endsWith(ext2);
    };
    const qmarksTestDot = ([$0, ext2 = ""])=>{
        const noext = qmarksTestNoExtDot([
            $0
        ]);
        return !ext2 ? noext : (f)=>noext(f) && f.endsWith(ext2);
    };
    const qmarksTest = ([$0, ext2 = ""])=>{
        const noext = qmarksTestNoExt([
            $0
        ]);
        return !ext2 ? noext : (f)=>noext(f) && f.endsWith(ext2);
    };
    const qmarksTestNoExt = ([$0])=>{
        const len = $0.length;
        return (f)=>f.length === len && !f.startsWith(".");
    };
    const qmarksTestNoExtDot = ([$0])=>{
        const len = $0.length;
        return (f)=>f.length === len && f !== "." && f !== "..";
    };
    const defaultPlatform = typeof process === "object" && process ? typeof define_process_env_default$1 === "object" && define_process_env_default$1 && define_process_env_default$1.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
    const path = {
        win32: {
            sep: "\\"
        },
        posix: {
            sep: "/"
        }
    };
    const sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
    minimatch.sep = sep;
    const GLOBSTAR = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR;
    const qmark = "[^/]";
    const star = qmark + "*?";
    const twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    const twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    const filter = (pattern, options = {})=>(p)=>minimatch(p, pattern, options);
    minimatch.filter = filter;
    const ext = (a, b = {})=>Object.assign({}, a, b);
    const defaults = (def)=>{
        if (!def || typeof def !== "object" || !Object.keys(def).length) {
            return minimatch;
        }
        const orig = minimatch;
        const m = (p, pattern, options = {})=>orig(p, pattern, ext(def, options));
        return Object.assign(m, {
            Minimatch: class Minimatch extends orig.Minimatch {
                constructor(pattern, options = {}){
                    super(pattern, ext(def, options));
                }
                static defaults(options) {
                    return orig.defaults(ext(def, options)).Minimatch;
                }
            },
            AST: class AST extends orig.AST {
                constructor(type, parent, options = {}){
                    super(type, parent, ext(def, options));
                }
                static fromGlob(pattern, options = {}) {
                    return orig.AST.fromGlob(pattern, ext(def, options));
                }
            },
            unescape: (s, options = {})=>orig.unescape(s, ext(def, options)),
            escape: (s, options = {})=>orig.escape(s, ext(def, options)),
            filter: (pattern, options = {})=>orig.filter(pattern, ext(def, options)),
            defaults: (options)=>orig.defaults(ext(def, options)),
            makeRe: (pattern, options = {})=>orig.makeRe(pattern, ext(def, options)),
            braceExpand: (pattern, options = {})=>orig.braceExpand(pattern, ext(def, options)),
            match: (list, pattern, options = {})=>orig.match(list, pattern, ext(def, options)),
            sep: orig.sep,
            GLOBSTAR
        });
    };
    minimatch.defaults = defaults;
    const braceExpand = (pattern, options = {})=>{
        assertValidPattern(pattern);
        if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
            return [
                pattern
            ];
        }
        return expand(pattern);
    };
    minimatch.braceExpand = braceExpand;
    const makeRe = (pattern, options = {})=>new Minimatch(pattern, options).makeRe();
    minimatch.makeRe = makeRe;
    const match = (list, pattern, options = {})=>{
        const mm = new Minimatch(pattern, options);
        list = list.filter((f)=>mm.match(f));
        if (mm.options.nonull && !list.length) {
            list.push(pattern);
        }
        return list;
    };
    minimatch.match = match;
    const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
    const regExpEscape = (s)=>s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    class Minimatch {
        options;
        set;
        pattern;
        windowsPathsNoEscape;
        nonegate;
        negate;
        comment;
        empty;
        preserveMultipleSlashes;
        partial;
        globSet;
        globParts;
        nocase;
        isWindows;
        platform;
        windowsNoMagicRoot;
        regexp;
        constructor(pattern, options = {}){
            assertValidPattern(pattern);
            options = options || {};
            this.options = options;
            this.pattern = pattern;
            this.platform = options.platform || defaultPlatform;
            this.isWindows = this.platform === "win32";
            this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
            if (this.windowsPathsNoEscape) {
                this.pattern = this.pattern.replace(/\\/g, "/");
            }
            this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
            this.regexp = null;
            this.negate = false;
            this.nonegate = !!options.nonegate;
            this.comment = false;
            this.empty = false;
            this.partial = !!options.partial;
            this.nocase = !!this.options.nocase;
            this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
            this.globSet = [];
            this.globParts = [];
            this.set = [];
            this.make();
        }
        hasMagic() {
            if (this.options.magicalBraces && this.set.length > 1) {
                return true;
            }
            for (const pattern of this.set){
                for (const part of pattern){
                    if (typeof part !== "string") return true;
                }
            }
            return false;
        }
        debug(..._) {}
        make() {
            const pattern = this.pattern;
            const options = this.options;
            if (!options.nocomment && pattern.charAt(0) === "#") {
                this.comment = true;
                return;
            }
            if (!pattern) {
                this.empty = true;
                return;
            }
            this.parseNegate();
            this.globSet = [
                ...new Set(this.braceExpand())
            ];
            if (options.debug) {
                this.debug = (...args)=>console.error(...args);
            }
            this.debug(this.pattern, this.globSet);
            const rawGlobParts = this.globSet.map((s)=>this.slashSplit(s));
            this.globParts = this.preprocess(rawGlobParts);
            this.debug(this.pattern, this.globParts);
            let set = this.globParts.map((s, _, __)=>{
                if (this.isWindows && this.windowsNoMagicRoot) {
                    const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
                    const isDrive = /^[a-z]:/i.test(s[0]);
                    if (isUNC) {
                        return [
                            ...s.slice(0, 4),
                            ...s.slice(4).map((ss)=>this.parse(ss))
                        ];
                    } else if (isDrive) {
                        return [
                            s[0],
                            ...s.slice(1).map((ss)=>this.parse(ss))
                        ];
                    }
                }
                return s.map((ss)=>this.parse(ss));
            });
            this.debug(this.pattern, set);
            this.set = set.filter((s)=>s.indexOf(false) === -1);
            if (this.isWindows) {
                for(let i = 0; i < this.set.length; i++){
                    const p = this.set[i];
                    if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
                        p[2] = "?";
                    }
                }
            }
            this.debug(this.pattern, this.set);
        }
        preprocess(globParts) {
            if (this.options.noglobstar) {
                for(let i = 0; i < globParts.length; i++){
                    for(let j = 0; j < globParts[i].length; j++){
                        if (globParts[i][j] === "**") {
                            globParts[i][j] = "*";
                        }
                    }
                }
            }
            const { optimizationLevel = 1 } = this.options;
            if (optimizationLevel >= 2) {
                globParts = this.firstPhasePreProcess(globParts);
                globParts = this.secondPhasePreProcess(globParts);
            } else if (optimizationLevel >= 1) {
                globParts = this.levelOneOptimize(globParts);
            } else {
                globParts = this.adjascentGlobstarOptimize(globParts);
            }
            return globParts;
        }
        adjascentGlobstarOptimize(globParts) {
            return globParts.map((parts)=>{
                let gs = -1;
                while(-1 !== (gs = parts.indexOf("**", gs + 1))){
                    let i = gs;
                    while(parts[i + 1] === "**"){
                        i++;
                    }
                    if (i !== gs) {
                        parts.splice(gs, i - gs);
                    }
                }
                return parts;
            });
        }
        levelOneOptimize(globParts) {
            return globParts.map((parts)=>{
                parts = parts.reduce((set, part)=>{
                    const prev = set[set.length - 1];
                    if (part === "**" && prev === "**") {
                        return set;
                    }
                    if (part === "..") {
                        if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                            set.pop();
                            return set;
                        }
                    }
                    set.push(part);
                    return set;
                }, []);
                return parts.length === 0 ? [
                    ""
                ] : parts;
            });
        }
        levelTwoFileOptimize(parts) {
            if (!Array.isArray(parts)) {
                parts = this.slashSplit(parts);
            }
            let didSomething = false;
            do {
                didSomething = false;
                if (!this.preserveMultipleSlashes) {
                    for(let i = 1; i < parts.length - 1; i++){
                        const p = parts[i];
                        if (i === 1 && p === "" && parts[0] === "") continue;
                        if (p === "." || p === "") {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                let dd = 0;
                while(-1 !== (dd = parts.indexOf("..", dd + 1))){
                    const p = parts[dd - 1];
                    if (p && p !== "." && p !== ".." && p !== "**") {
                        didSomething = true;
                        parts.splice(dd - 1, 2);
                        dd -= 2;
                    }
                }
            }while (didSomething);
            return parts.length === 0 ? [
                ""
            ] : parts;
        }
        firstPhasePreProcess(globParts) {
            let didSomething = false;
            do {
                didSomething = false;
                for (let parts of globParts){
                    let gs = -1;
                    while(-1 !== (gs = parts.indexOf("**", gs + 1))){
                        let gss = gs;
                        while(parts[gss + 1] === "**"){
                            gss++;
                        }
                        if (gss > gs) {
                            parts.splice(gs + 1, gss - gs);
                        }
                        let next = parts[gs + 1];
                        const p = parts[gs + 2];
                        const p2 = parts[gs + 3];
                        if (next !== "..") continue;
                        if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
                            continue;
                        }
                        didSomething = true;
                        parts.splice(gs, 1);
                        const other = parts.slice(0);
                        other[gs] = "**";
                        globParts.push(other);
                        gs--;
                    }
                    if (!this.preserveMultipleSlashes) {
                        for(let i = 1; i < parts.length - 1; i++){
                            const p = parts[i];
                            if (i === 1 && p === "" && parts[0] === "") continue;
                            if (p === "." || p === "") {
                                didSomething = true;
                                parts.splice(i, 1);
                                i--;
                            }
                        }
                        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                            didSomething = true;
                            parts.pop();
                        }
                    }
                    let dd = 0;
                    while(-1 !== (dd = parts.indexOf("..", dd + 1))){
                        const p = parts[dd - 1];
                        if (p && p !== "." && p !== ".." && p !== "**") {
                            didSomething = true;
                            const needDot = dd === 1 && parts[dd + 1] === "**";
                            const splin = needDot ? [
                                "."
                            ] : [];
                            parts.splice(dd - 1, 2, ...splin);
                            if (parts.length === 0) parts.push("");
                            dd -= 2;
                        }
                    }
                }
            }while (didSomething);
            return globParts;
        }
        secondPhasePreProcess(globParts) {
            for(let i = 0; i < globParts.length - 1; i++){
                for(let j = i + 1; j < globParts.length; j++){
                    const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                    if (matched) {
                        globParts[i] = [];
                        globParts[j] = matched;
                        break;
                    }
                }
            }
            return globParts.filter((gs)=>gs.length);
        }
        partsMatch(a, b, emptyGSMatch = false) {
            let ai = 0;
            let bi = 0;
            let result = [];
            let which = "";
            while(ai < a.length && bi < b.length){
                if (a[ai] === b[bi]) {
                    result.push(which === "b" ? b[bi] : a[ai]);
                    ai++;
                    bi++;
                } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
                    result.push(a[ai]);
                    ai++;
                } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
                    result.push(b[bi]);
                    bi++;
                } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
                    if (which === "b") return false;
                    which = "a";
                    result.push(a[ai]);
                    ai++;
                    bi++;
                } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
                    if (which === "a") return false;
                    which = "b";
                    result.push(b[bi]);
                    ai++;
                    bi++;
                } else {
                    return false;
                }
            }
            return a.length === b.length && result;
        }
        parseNegate() {
            if (this.nonegate) return;
            const pattern = this.pattern;
            let negate = false;
            let negateOffset = 0;
            for(let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++){
                negate = !negate;
                negateOffset++;
            }
            if (negateOffset) this.pattern = pattern.slice(negateOffset);
            this.negate = negate;
        }
        matchOne(file, pattern, partial = false) {
            const options = this.options;
            if (this.isWindows) {
                const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
                const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
                const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
                const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
                const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
                const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
                if (typeof fdi === "number" && typeof pdi === "number") {
                    const [fd, pd] = [
                        file[fdi],
                        pattern[pdi]
                    ];
                    if (fd.toLowerCase() === pd.toLowerCase()) {
                        pattern[pdi] = fd;
                        if (pdi > fdi) {
                            pattern = pattern.slice(pdi);
                        } else if (fdi > pdi) {
                            file = file.slice(fdi);
                        }
                    }
                }
            }
            const { optimizationLevel = 1 } = this.options;
            if (optimizationLevel >= 2) {
                file = this.levelTwoFileOptimize(file);
            }
            this.debug("matchOne", this, {
                file,
                pattern
            });
            this.debug("matchOne", file.length, pattern.length);
            for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){
                this.debug("matchOne loop");
                var p = pattern[pi];
                var f = file[fi];
                this.debug(pattern, p, f);
                if (p === false) {
                    return false;
                }
                if (p === GLOBSTAR) {
                    this.debug("GLOBSTAR", [
                        pattern,
                        p,
                        f
                    ]);
                    var fr = fi;
                    var pr = pi + 1;
                    if (pr === pl) {
                        this.debug("** at the end");
                        for(; fi < fl; fi++){
                            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
                        }
                        return true;
                    }
                    while(fr < fl){
                        var swallowee = file[fr];
                        this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
                        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                            this.debug("globstar found match!", fr, fl, swallowee);
                            return true;
                        } else {
                            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                                this.debug("dot detected!", file, fr, pattern, pr);
                                break;
                            }
                            this.debug("globstar swallow a segment, and continue");
                            fr++;
                        }
                    }
                    if (partial) {
                        this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
                        if (fr === fl) {
                            return true;
                        }
                    }
                    return false;
                }
                let hit;
                if (typeof p === "string") {
                    hit = f === p;
                    this.debug("string match", p, f, hit);
                } else {
                    hit = p.test(f);
                    this.debug("pattern match", p, f, hit);
                }
                if (!hit) return false;
            }
            if (fi === fl && pi === pl) {
                return true;
            } else if (fi === fl) {
                return partial;
            } else if (pi === pl) {
                return fi === fl - 1 && file[fi] === "";
            } else {
                throw new Error("wtf?");
            }
        }
        braceExpand() {
            return braceExpand(this.pattern, this.options);
        }
        parse(pattern) {
            assertValidPattern(pattern);
            const options = this.options;
            if (pattern === "**") return GLOBSTAR;
            if (pattern === "") return "";
            let m;
            let fastTest = null;
            if (m = pattern.match(starRE)) {
                fastTest = options.dot ? starTestDot : starTest;
            } else if (m = pattern.match(starDotExtRE)) {
                fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
            } else if (m = pattern.match(qmarksRE)) {
                fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
            } else if (m = pattern.match(starDotStarRE)) {
                fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
            } else if (m = pattern.match(dotStarRE)) {
                fastTest = dotStarTest;
            }
            const re = AST.fromGlob(pattern, this.options).toMMPattern();
            if (fastTest && typeof re === "object") {
                Reflect.defineProperty(re, "test", {
                    value: fastTest
                });
            }
            return re;
        }
        makeRe() {
            if (this.regexp || this.regexp === false) return this.regexp;
            const set = this.set;
            if (!set.length) {
                this.regexp = false;
                return this.regexp;
            }
            const options = this.options;
            const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
            const flags = new Set(options.nocase ? [
                "i"
            ] : []);
            let re = set.map((pattern)=>{
                const pp = pattern.map((p)=>{
                    if (p instanceof RegExp) {
                        for (const f of p.flags.split(""))flags.add(f);
                    }
                    return typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
                });
                pp.forEach((p, i)=>{
                    const next = pp[i + 1];
                    const prev = pp[i - 1];
                    if (p !== GLOBSTAR || prev === GLOBSTAR) {
                        return;
                    }
                    if (prev === void 0) {
                        if (next !== void 0 && next !== GLOBSTAR) {
                            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
                        } else {
                            pp[i] = twoStar;
                        }
                    } else if (next === void 0) {
                        pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + ")?";
                    } else if (next !== GLOBSTAR) {
                        pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
                        pp[i + 1] = GLOBSTAR;
                    }
                });
                const filtered = pp.filter((p)=>p !== GLOBSTAR);
                if (this.partial && filtered.length >= 1) {
                    const prefixes = [];
                    for(let i = 1; i <= filtered.length; i++){
                        prefixes.push(filtered.slice(0, i).join("/"));
                    }
                    return "(?:" + prefixes.join("|") + ")";
                }
                return filtered.join("/");
            }).join("|");
            const [open, close] = set.length > 1 ? [
                "(?:",
                ")"
            ] : [
                "",
                ""
            ];
            re = "^" + open + re + close + "$";
            if (this.partial) {
                re = "^(?:\\/|" + open + re.slice(1, -1) + close + ")$";
            }
            if (this.negate) re = "^(?!" + re + ").+$";
            try {
                this.regexp = new RegExp(re, [
                    ...flags
                ].join(""));
            } catch (ex) {
                this.regexp = false;
            }
            return this.regexp;
        }
        slashSplit(p) {
            if (this.preserveMultipleSlashes) {
                return p.split("/");
            } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
                return [
                    "",
                    ...p.split(/\/+/)
                ];
            } else {
                return p.split(/\/+/);
            }
        }
        match(f, partial = this.partial) {
            this.debug("match", f, this.pattern);
            if (this.comment) {
                return false;
            }
            if (this.empty) {
                return f === "";
            }
            if (f === "/" && partial) {
                return true;
            }
            const options = this.options;
            if (this.isWindows) {
                f = f.split("\\").join("/");
            }
            const ff = this.slashSplit(f);
            this.debug(this.pattern, "split", ff);
            const set = this.set;
            this.debug(this.pattern, "set", set);
            let filename = ff[ff.length - 1];
            if (!filename) {
                for(let i = ff.length - 2; !filename && i >= 0; i--){
                    filename = ff[i];
                }
            }
            for(let i = 0; i < set.length; i++){
                const pattern = set[i];
                let file = ff;
                if (options.matchBase && pattern.length === 1) {
                    file = [
                        filename
                    ];
                }
                const hit = this.matchOne(file, pattern, partial);
                if (hit) {
                    if (options.flipNegate) {
                        return true;
                    }
                    return !this.negate;
                }
            }
            if (options.flipNegate) {
                return false;
            }
            return this.negate;
        }
        static defaults(def) {
            return minimatch.defaults(def).Minimatch;
        }
    }
    minimatch.AST = AST;
    minimatch.Minimatch = Minimatch;
    minimatch.escape = escape;
    minimatch.unescape = unescape;
    class Diff {
        diff(oldStr, newStr, options = {}) {
            let callback;
            if (typeof options === 'function') {
                callback = options;
                options = {};
            } else if ('callback' in options) {
                callback = options.callback;
            }
            const oldString = this.castInput(oldStr, options);
            const newString = this.castInput(newStr, options);
            const oldTokens = this.removeEmpty(this.tokenize(oldString, options));
            const newTokens = this.removeEmpty(this.tokenize(newString, options));
            return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
        }
        diffWithOptionsObj(oldTokens, newTokens, options, callback) {
            var _a;
            const done = (value)=>{
                value = this.postProcess(value, options);
                if (callback) {
                    setTimeout(function() {
                        callback(value);
                    }, 0);
                    return undefined;
                } else {
                    return value;
                }
            };
            const newLen = newTokens.length, oldLen = oldTokens.length;
            let editLength = 1;
            let maxEditLength = newLen + oldLen;
            if (options.maxEditLength != null) {
                maxEditLength = Math.min(maxEditLength, options.maxEditLength);
            }
            const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;
            const abortAfterTimestamp = Date.now() + maxExecutionTime;
            const bestPath = [
                {
                    oldPos: -1,
                    lastComponent: undefined
                }
            ];
            let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
            if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
                return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
            }
            let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
            const execEditLength = ()=>{
                for(let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2){
                    let basePath;
                    const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
                    if (removePath) {
                        bestPath[diagonalPath - 1] = undefined;
                    }
                    let canAdd = false;
                    if (addPath) {
                        const addPathNewPos = addPath.oldPos - diagonalPath;
                        canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
                    }
                    const canRemove = removePath && removePath.oldPos + 1 < oldLen;
                    if (!canAdd && !canRemove) {
                        bestPath[diagonalPath] = undefined;
                        continue;
                    }
                    if (!canRemove || (canAdd && removePath.oldPos < addPath.oldPos)) {
                        basePath = this.addToPath(addPath, true, false, 0, options);
                    } else {
                        basePath = this.addToPath(removePath, false, true, 1, options);
                    }
                    newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);
                    if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
                        return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
                    } else {
                        bestPath[diagonalPath] = basePath;
                        if (basePath.oldPos + 1 >= oldLen) {
                            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
                        }
                        if (newPos + 1 >= newLen) {
                            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
                        }
                    }
                }
                editLength++;
            };
            if (callback) {
                (function exec() {
                    setTimeout(function() {
                        if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
                            return callback(undefined);
                        }
                        if (!execEditLength()) {
                            exec();
                        }
                    }, 0);
                }());
            } else {
                while(editLength <= maxEditLength && Date.now() <= abortAfterTimestamp){
                    const ret = execEditLength();
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
        addToPath(path, added, removed, oldPosInc, options) {
            const last = path.lastComponent;
            if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
                return {
                    oldPos: path.oldPos + oldPosInc,
                    lastComponent: {
                        count: last.count + 1,
                        added: added,
                        removed: removed,
                        previousComponent: last.previousComponent
                    }
                };
            } else {
                return {
                    oldPos: path.oldPos + oldPosInc,
                    lastComponent: {
                        count: 1,
                        added: added,
                        removed: removed,
                        previousComponent: last
                    }
                };
            }
        }
        extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
            const newLen = newTokens.length, oldLen = oldTokens.length;
            let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
            while(newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)){
                newPos++;
                oldPos++;
                commonCount++;
                if (options.oneChangePerToken) {
                    basePath.lastComponent = {
                        count: 1,
                        previousComponent: basePath.lastComponent,
                        added: false,
                        removed: false
                    };
                }
            }
            if (commonCount && !options.oneChangePerToken) {
                basePath.lastComponent = {
                    count: commonCount,
                    previousComponent: basePath.lastComponent,
                    added: false,
                    removed: false
                };
            }
            basePath.oldPos = oldPos;
            return newPos;
        }
        equals(left, right, options) {
            if (options.comparator) {
                return options.comparator(left, right);
            } else {
                return left === right || (!!options.ignoreCase && left.toLowerCase() === right.toLowerCase());
            }
        }
        removeEmpty(array) {
            const ret = [];
            for(let i = 0; i < array.length; i++){
                if (array[i]) {
                    ret.push(array[i]);
                }
            }
            return ret;
        }
        castInput(value, options) {
            return value;
        }
        tokenize(value, options) {
            return Array.from(value);
        }
        join(chars) {
            return chars.join('');
        }
        postProcess(changeObjects, options) {
            return changeObjects;
        }
        get useLongestToken() {
            return false;
        }
        buildValues(lastComponent, newTokens, oldTokens) {
            const components = [];
            let nextComponent;
            while(lastComponent){
                components.push(lastComponent);
                nextComponent = lastComponent.previousComponent;
                delete lastComponent.previousComponent;
                lastComponent = nextComponent;
            }
            components.reverse();
            const componentLen = components.length;
            let componentPos = 0, newPos = 0, oldPos = 0;
            for(; componentPos < componentLen; componentPos++){
                const component = components[componentPos];
                if (!component.removed) {
                    if (!component.added && this.useLongestToken) {
                        let value = newTokens.slice(newPos, newPos + component.count);
                        value = value.map(function(value, i) {
                            const oldValue = oldTokens[oldPos + i];
                            return oldValue.length > value.length ? oldValue : value;
                        });
                        component.value = this.join(value);
                    } else {
                        component.value = this.join(newTokens.slice(newPos, newPos + component.count));
                    }
                    newPos += component.count;
                    if (!component.added) {
                        oldPos += component.count;
                    }
                } else {
                    component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
                    oldPos += component.count;
                }
            }
            return components;
        }
    }
    class LineDiff extends Diff {
        constructor(){
            super(...arguments);
            this.tokenize = tokenize;
        }
        equals(left, right, options) {
            if (options.ignoreWhitespace) {
                if (!options.newlineIsToken || !left.includes('\n')) {
                    left = left.trim();
                }
                if (!options.newlineIsToken || !right.includes('\n')) {
                    right = right.trim();
                }
            } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
                if (left.endsWith('\n')) {
                    left = left.slice(0, -1);
                }
                if (right.endsWith('\n')) {
                    right = right.slice(0, -1);
                }
            }
            return super.equals(left, right, options);
        }
    }
    const lineDiff = new LineDiff();
    function diffLines(oldStr, newStr, options) {
        return lineDiff.diff(oldStr, newStr, options);
    }
    function tokenize(value, options) {
        if (options.stripTrailingCr) {
            value = value.replace(/\r\n/g, '\n');
        }
        const retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
        if (!linesAndNewlines[linesAndNewlines.length - 1]) {
            linesAndNewlines.pop();
        }
        for(let i = 0; i < linesAndNewlines.length; i++){
            const line = linesAndNewlines[i];
            if (i % 2 && !options.newlineIsToken) {
                retLines[retLines.length - 1] += line;
            } else {
                retLines.push(line);
            }
        }
        return retLines;
    }
    const INCLUDE_HEADERS = {
        includeIndex: true,
        includeUnderline: true,
        includeFileHeaders: true
    };
    function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        let optionsObj;
        if (!options) {
            optionsObj = {};
        } else if (typeof options === 'function') {
            optionsObj = {
                callback: options
            };
        } else {
            optionsObj = options;
        }
        if (typeof optionsObj.context === 'undefined') {
            optionsObj.context = 4;
        }
        const context = optionsObj.context;
        if (optionsObj.newlineIsToken) {
            throw new Error('newlineIsToken may not be used with patch-generation functions, only with diffing functions');
        }
        if (!optionsObj.callback) {
            return diffLinesResultToPatch(diffLines(oldStr, newStr, optionsObj));
        } else {
            const { callback } = optionsObj;
            diffLines(oldStr, newStr, Object.assign(Object.assign({}, optionsObj), {
                callback: (diff)=>{
                    const patch = diffLinesResultToPatch(diff);
                    callback(patch);
                }
            }));
        }
        function diffLinesResultToPatch(diff) {
            if (!diff) {
                return;
            }
            diff.push({
                value: '',
                lines: []
            });
            function contextLines(lines) {
                return lines.map(function(entry) {
                    return ' ' + entry;
                });
            }
            const hunks = [];
            let oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
            for(let i = 0; i < diff.length; i++){
                const current = diff[i], lines = current.lines || splitLines(current.value);
                current.lines = lines;
                if (current.added || current.removed) {
                    if (!oldRangeStart) {
                        const prev = diff[i - 1];
                        oldRangeStart = oldLine;
                        newRangeStart = newLine;
                        if (prev) {
                            curRange = context > 0 ? contextLines(prev.lines.slice(-context)) : [];
                            oldRangeStart -= curRange.length;
                            newRangeStart -= curRange.length;
                        }
                    }
                    for (const line of lines){
                        curRange.push((current.added ? '+' : '-') + line);
                    }
                    if (current.added) {
                        newLine += lines.length;
                    } else {
                        oldLine += lines.length;
                    }
                } else {
                    if (oldRangeStart) {
                        if (lines.length <= context * 2 && i < diff.length - 2) {
                            for (const line of contextLines(lines)){
                                curRange.push(line);
                            }
                        } else {
                            const contextSize = Math.min(lines.length, context);
                            for (const line of contextLines(lines.slice(0, contextSize))){
                                curRange.push(line);
                            }
                            const hunk = {
                                oldStart: oldRangeStart,
                                oldLines: (oldLine - oldRangeStart + contextSize),
                                newStart: newRangeStart,
                                newLines: (newLine - newRangeStart + contextSize),
                                lines: curRange
                            };
                            hunks.push(hunk);
                            oldRangeStart = 0;
                            newRangeStart = 0;
                            curRange = [];
                        }
                    }
                    oldLine += lines.length;
                    newLine += lines.length;
                }
            }
            for (const hunk of hunks){
                for(let i = 0; i < hunk.lines.length; i++){
                    if (hunk.lines[i].endsWith('\n')) {
                        hunk.lines[i] = hunk.lines[i].slice(0, -1);
                    } else {
                        hunk.lines.splice(i + 1, 0, '\\ No newline at end of file');
                        i++;
                    }
                }
            }
            return {
                oldFileName: oldFileName,
                newFileName: newFileName,
                oldHeader: oldHeader,
                newHeader: newHeader,
                hunks: hunks
            };
        }
    }
    function formatPatch(patch, headerOptions) {
        if (!headerOptions) {
            headerOptions = INCLUDE_HEADERS;
        }
        if (Array.isArray(patch)) {
            if (patch.length > 1 && !headerOptions.includeFileHeaders) {
                throw new Error('Cannot omit file headers on a multi-file patch. ' + '(The result would be unparseable; how would a tool trying to apply ' + 'the patch know which changes are to which file?)');
            }
            return patch.map((p)=>formatPatch(p, headerOptions)).join('\n');
        }
        const ret = [];
        if (headerOptions.includeIndex && patch.oldFileName == patch.newFileName) {
            ret.push('Index: ' + patch.oldFileName);
        }
        if (headerOptions.includeUnderline) {
            ret.push('===================================================================');
        }
        if (headerOptions.includeFileHeaders) {
            ret.push('--- ' + patch.oldFileName + (typeof patch.oldHeader === 'undefined' ? '' : '\t' + patch.oldHeader));
            ret.push('+++ ' + patch.newFileName + (typeof patch.newHeader === 'undefined' ? '' : '\t' + patch.newHeader));
        }
        for(let i = 0; i < patch.hunks.length; i++){
            const hunk = patch.hunks[i];
            if (hunk.oldLines === 0) {
                hunk.oldStart -= 1;
            }
            if (hunk.newLines === 0) {
                hunk.newStart -= 1;
            }
            ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
            for (const line of hunk.lines){
                ret.push(line);
            }
        }
        return ret.join('\n') + '\n';
    }
    function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        if (typeof options === 'function') {
            options = {
                callback: options
            };
        }
        if (!(options === null || options === void 0 ? void 0 : options.callback)) {
            const patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
            if (!patchObj) {
                return;
            }
            return formatPatch(patchObj, options === null || options === void 0 ? void 0 : options.headerOptions);
        } else {
            const { callback } = options;
            structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, Object.assign(Object.assign({}, options), {
                callback: (patchObj)=>{
                    if (!patchObj) {
                        callback(undefined);
                    } else {
                        callback(formatPatch(patchObj, options.headerOptions));
                    }
                }
            }));
        }
    }
    function splitLines(text) {
        const hasTrailingNl = text.endsWith('\n');
        const result = text.split('\n').map((line)=>line + '\n');
        if (hasTrailingNl) {
            result.pop();
        } else {
            result.push(result.pop().slice(0, -1));
        }
        return result;
    }
    function extend(destination) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (source.hasOwnProperty(key)) destination[key] = source[key];
            }
        }
        return destination;
    }
    function repeat(character, count) {
        return Array(count + 1).join(character);
    }
    function trimLeadingNewlines(string) {
        return string.replace(/^\n*/, '');
    }
    function trimTrailingNewlines(string) {
        var indexEnd = string.length;
        while(indexEnd > 0 && string[indexEnd - 1] === '\n')indexEnd--;
        return string.substring(0, indexEnd);
    }
    function trimNewlines(string) {
        return trimTrailingNewlines(trimLeadingNewlines(string));
    }
    var blockElements = [
        'ADDRESS',
        'ARTICLE',
        'ASIDE',
        'AUDIO',
        'BLOCKQUOTE',
        'BODY',
        'CANVAS',
        'CENTER',
        'DD',
        'DIR',
        'DIV',
        'DL',
        'DT',
        'FIELDSET',
        'FIGCAPTION',
        'FIGURE',
        'FOOTER',
        'FORM',
        'FRAMESET',
        'H1',
        'H2',
        'H3',
        'H4',
        'H5',
        'H6',
        'HEADER',
        'HGROUP',
        'HR',
        'HTML',
        'ISINDEX',
        'LI',
        'MAIN',
        'MENU',
        'NAV',
        'NOFRAMES',
        'NOSCRIPT',
        'OL',
        'OUTPUT',
        'P',
        'PRE',
        'SECTION',
        'TABLE',
        'TBODY',
        'TD',
        'TFOOT',
        'TH',
        'THEAD',
        'TR',
        'UL'
    ];
    function isBlock(node) {
        return is$1(node, blockElements);
    }
    var voidElements = [
        'AREA',
        'BASE',
        'BR',
        'COL',
        'COMMAND',
        'EMBED',
        'HR',
        'IMG',
        'INPUT',
        'KEYGEN',
        'LINK',
        'META',
        'PARAM',
        'SOURCE',
        'TRACK',
        'WBR'
    ];
    function isVoid(node) {
        return is$1(node, voidElements);
    }
    function hasVoid(node) {
        return has(node, voidElements);
    }
    var meaningfulWhenBlankElements = [
        'A',
        'TABLE',
        'THEAD',
        'TBODY',
        'TFOOT',
        'TH',
        'TD',
        'IFRAME',
        'SCRIPT',
        'AUDIO',
        'VIDEO'
    ];
    function isMeaningfulWhenBlank(node) {
        return is$1(node, meaningfulWhenBlankElements);
    }
    function hasMeaningfulWhenBlank(node) {
        return has(node, meaningfulWhenBlankElements);
    }
    function is$1(node, tagNames) {
        return tagNames.indexOf(node.nodeName) >= 0;
    }
    function has(node, tagNames) {
        return (node.getElementsByTagName && tagNames.some(function(tagName) {
            return node.getElementsByTagName(tagName).length;
        }));
    }
    var rules = {};
    rules.paragraph = {
        filter: 'p',
        replacement: function(content) {
            return '\n\n' + content + '\n\n';
        }
    };
    rules.lineBreak = {
        filter: 'br',
        replacement: function(content, node, options) {
            return options.br + '\n';
        }
    };
    rules.heading = {
        filter: [
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6'
        ],
        replacement: function(content, node, options) {
            var hLevel = Number(node.nodeName.charAt(1));
            if (options.headingStyle === 'setext' && hLevel < 3) {
                var underline = repeat((hLevel === 1 ? '=' : '-'), content.length);
                return ('\n\n' + content + '\n' + underline + '\n\n');
            } else {
                return '\n\n' + repeat('#', hLevel) + ' ' + content + '\n\n';
            }
        }
    };
    rules.blockquote = {
        filter: 'blockquote',
        replacement: function(content) {
            content = trimNewlines(content).replace(/^/gm, '> ');
            return '\n\n' + content + '\n\n';
        }
    };
    rules.list = {
        filter: [
            'ul',
            'ol'
        ],
        replacement: function(content, node) {
            var parent = node.parentNode;
            if (parent.nodeName === 'LI' && parent.lastElementChild === node) {
                return '\n' + content;
            } else {
                return '\n\n' + content + '\n\n';
            }
        }
    };
    rules.listItem = {
        filter: 'li',
        replacement: function(content, node, options) {
            var prefix = options.bulletListMarker + '   ';
            var parent = node.parentNode;
            if (parent.nodeName === 'OL') {
                var start = parent.getAttribute('start');
                var index = Array.prototype.indexOf.call(parent.children, node);
                prefix = (start ? Number(start) + index : index + 1) + '.  ';
            }
            var isParagraph = /\n$/.test(content);
            content = trimNewlines(content) + (isParagraph ? '\n' : '');
            content = content.replace(/\n/gm, '\n' + ' '.repeat(prefix.length));
            return (prefix + content + (node.nextSibling ? '\n' : ''));
        }
    };
    rules.indentedCodeBlock = {
        filter: function(node, options) {
            return (options.codeBlockStyle === 'indented' && node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE');
        },
        replacement: function(content, node, options) {
            return ('\n\n    ' + node.firstChild.textContent.replace(/\n/g, '\n    ') + '\n\n');
        }
    };
    rules.fencedCodeBlock = {
        filter: function(node, options) {
            return (options.codeBlockStyle === 'fenced' && node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE');
        },
        replacement: function(content, node, options) {
            var className = node.firstChild.getAttribute('class') || '';
            var language = (className.match(/language-(\S+)/) || [
                null,
                ''
            ])[1];
            var code = node.firstChild.textContent;
            var fenceChar = options.fence.charAt(0);
            var fenceSize = 3;
            var fenceInCodeRegex = new RegExp('^' + fenceChar + '{3,}', 'gm');
            var match;
            while((match = fenceInCodeRegex.exec(code))){
                if (match[0].length >= fenceSize) {
                    fenceSize = match[0].length + 1;
                }
            }
            var fence = repeat(fenceChar, fenceSize);
            return ('\n\n' + fence + language + '\n' + code.replace(/\n$/, '') + '\n' + fence + '\n\n');
        }
    };
    rules.horizontalRule = {
        filter: 'hr',
        replacement: function(content, node, options) {
            return '\n\n' + options.hr + '\n\n';
        }
    };
    rules.inlineLink = {
        filter: function(node, options) {
            return (options.linkStyle === 'inlined' && node.nodeName === 'A' && node.getAttribute('href'));
        },
        replacement: function(content, node) {
            var href = node.getAttribute('href');
            if (href) href = href.replace(/([()])/g, '\\$1');
            var title = cleanAttribute(node.getAttribute('title'));
            if (title) title = ' "' + title.replace(/"/g, '\\"') + '"';
            return '[' + content + '](' + href + title + ')';
        }
    };
    rules.referenceLink = {
        filter: function(node, options) {
            return (options.linkStyle === 'referenced' && node.nodeName === 'A' && node.getAttribute('href'));
        },
        replacement: function(content, node, options) {
            var href = node.getAttribute('href');
            var title = cleanAttribute(node.getAttribute('title'));
            if (title) title = ' "' + title + '"';
            var replacement;
            var reference;
            switch(options.linkReferenceStyle){
                case 'collapsed':
                    replacement = '[' + content + '][]';
                    reference = '[' + content + ']: ' + href + title;
                    break;
                case 'shortcut':
                    replacement = '[' + content + ']';
                    reference = '[' + content + ']: ' + href + title;
                    break;
                default:
                    var id = this.references.length + 1;
                    replacement = '[' + content + '][' + id + ']';
                    reference = '[' + id + ']: ' + href + title;
            }
            this.references.push(reference);
            return replacement;
        },
        references: [],
        append: function(options) {
            var references = '';
            if (this.references.length) {
                references = '\n\n' + this.references.join('\n') + '\n\n';
                this.references = [];
            }
            return references;
        }
    };
    rules.emphasis = {
        filter: [
            'em',
            'i'
        ],
        replacement: function(content, node, options) {
            if (!content.trim()) return '';
            return options.emDelimiter + content + options.emDelimiter;
        }
    };
    rules.strong = {
        filter: [
            'strong',
            'b'
        ],
        replacement: function(content, node, options) {
            if (!content.trim()) return '';
            return options.strongDelimiter + content + options.strongDelimiter;
        }
    };
    rules.code = {
        filter: function(node) {
            var hasSiblings = node.previousSibling || node.nextSibling;
            var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings;
            return node.nodeName === 'CODE' && !isCodeBlock;
        },
        replacement: function(content) {
            if (!content) return '';
            content = content.replace(/\r?\n|\r/g, ' ');
            var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? ' ' : '';
            var delimiter = '`';
            var matches = content.match(/`+/gm) || [];
            while(matches.indexOf(delimiter) !== -1)delimiter = delimiter + '`';
            return delimiter + extraSpace + content + extraSpace + delimiter;
        }
    };
    rules.image = {
        filter: 'img',
        replacement: function(content, node) {
            var alt = cleanAttribute(node.getAttribute('alt'));
            var src = node.getAttribute('src') || '';
            var title = cleanAttribute(node.getAttribute('title'));
            var titlePart = title ? ' "' + title + '"' : '';
            return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : '';
        }
    };
    function cleanAttribute(attribute) {
        return attribute ? attribute.replace(/(\n+\s*)+/g, '\n') : '';
    }
    function Rules(options) {
        this.options = options;
        this._keep = [];
        this._remove = [];
        this.blankRule = {
            replacement: options.blankReplacement
        };
        this.keepReplacement = options.keepReplacement;
        this.defaultRule = {
            replacement: options.defaultReplacement
        };
        this.array = [];
        for(var key in options.rules)this.array.push(options.rules[key]);
    }
    Rules.prototype = {
        add: function(key, rule) {
            this.array.unshift(rule);
        },
        keep: function(filter) {
            this._keep.unshift({
                filter: filter,
                replacement: this.keepReplacement
            });
        },
        remove: function(filter) {
            this._remove.unshift({
                filter: filter,
                replacement: function() {
                    return '';
                }
            });
        },
        forNode: function(node) {
            if (node.isBlank) return this.blankRule;
            var rule;
            if ((rule = findRule(this.array, node, this.options))) return rule;
            if ((rule = findRule(this._keep, node, this.options))) return rule;
            if ((rule = findRule(this._remove, node, this.options))) return rule;
            return this.defaultRule;
        },
        forEach: function(fn) {
            for(var i = 0; i < this.array.length; i++)fn(this.array[i], i);
        }
    };
    function findRule(rules, node, options) {
        for(var i = 0; i < rules.length; i++){
            var rule = rules[i];
            if (filterValue(rule, node, options)) return rule;
        }
        return void 0;
    }
    function filterValue(rule, node, options) {
        var filter = rule.filter;
        if (typeof filter === 'string') {
            if (filter === node.nodeName.toLowerCase()) return true;
        } else if (Array.isArray(filter)) {
            if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true;
        } else if (typeof filter === 'function') {
            if (filter.call(rule, node, options)) return true;
        } else {
            throw new TypeError('`filter` needs to be a string, array, or function');
        }
    }
    function collapseWhitespace(options) {
        var element = options.element;
        var isBlock = options.isBlock;
        var isVoid = options.isVoid;
        var isPre = options.isPre || function(node) {
            return node.nodeName === 'PRE';
        };
        if (!element.firstChild || isPre(element)) return;
        var prevText = null;
        var keepLeadingWs = false;
        var prev = null;
        var node = next(prev, element, isPre);
        while(node !== element){
            if (node.nodeType === 3 || node.nodeType === 4) {
                var text = node.data.replace(/[ \r\n\t]+/g, ' ');
                if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === ' ') {
                    text = text.substr(1);
                }
                if (!text) {
                    node = remove(node);
                    continue;
                }
                node.data = text;
                prevText = node;
            } else if (node.nodeType === 1) {
                if (isBlock(node) || node.nodeName === 'BR') {
                    if (prevText) {
                        prevText.data = prevText.data.replace(/ $/, '');
                    }
                    prevText = null;
                    keepLeadingWs = false;
                } else if (isVoid(node) || isPre(node)) {
                    prevText = null;
                    keepLeadingWs = true;
                } else if (prevText) {
                    keepLeadingWs = false;
                }
            } else {
                node = remove(node);
                continue;
            }
            var nextNode = next(prev, node, isPre);
            prev = node;
            node = nextNode;
        }
        if (prevText) {
            prevText.data = prevText.data.replace(/ $/, '');
            if (!prevText.data) {
                remove(prevText);
            }
        }
    }
    function remove(node) {
        var next = node.nextSibling || node.parentNode;
        node.parentNode.removeChild(node);
        return next;
    }
    function next(prev, current, isPre) {
        if ((prev && prev.parentNode === current) || isPre(current)) {
            return current.nextSibling || current.parentNode;
        }
        return current.firstChild || current.nextSibling || current.parentNode;
    }
    var root = (typeof window !== 'undefined' ? window : {});
    function canParseHTMLNatively() {
        var Parser = root.DOMParser;
        var canParse = false;
        try {
            if (new Parser().parseFromString('', 'text/html')) {
                canParse = true;
            }
        } catch (e) {}
        return canParse;
    }
    function createHTMLParser() {
        var Parser = function() {};
        {
            if (shouldUseActiveX()) {
                Parser.prototype.parseFromString = function(string) {
                    var doc = new window.ActiveXObject('htmlfile');
                    doc.designMode = 'on';
                    doc.open();
                    doc.write(string);
                    doc.close();
                    return doc;
                };
            } else {
                Parser.prototype.parseFromString = function(string) {
                    var doc = document.implementation.createHTMLDocument('');
                    doc.open();
                    doc.write(string);
                    doc.close();
                    return doc;
                };
            }
        }
        return Parser;
    }
    function shouldUseActiveX() {
        var useActiveX = false;
        try {
            document.implementation.createHTMLDocument('').open();
        } catch (e) {
            if (root.ActiveXObject) useActiveX = true;
        }
        return useActiveX;
    }
    var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
    function RootNode(input, options) {
        var root;
        if (typeof input === 'string') {
            var doc = htmlParser().parseFromString('<x-turndown id="turndown-root">' + input + '</x-turndown>', 'text/html');
            root = doc.getElementById('turndown-root');
        } else {
            root = input.cloneNode(true);
        }
        collapseWhitespace({
            element: root,
            isBlock: isBlock,
            isVoid: isVoid,
            isPre: options.preformattedCode ? isPreOrCode : null
        });
        return root;
    }
    var _htmlParser;
    function htmlParser() {
        _htmlParser = _htmlParser || new HTMLParser();
        return _htmlParser;
    }
    function isPreOrCode(node) {
        return node.nodeName === 'PRE' || node.nodeName === 'CODE';
    }
    function Node(node, options) {
        node.isBlock = isBlock(node);
        node.isCode = node.nodeName === 'CODE' || node.parentNode.isCode;
        node.isBlank = isBlank(node);
        node.flankingWhitespace = flankingWhitespace(node, options);
        return node;
    }
    function isBlank(node) {
        return (!isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node));
    }
    function flankingWhitespace(node, options) {
        if (node.isBlock || (options.preformattedCode && node.isCode)) {
            return {
                leading: '',
                trailing: ''
            };
        }
        var edges = edgeWhitespace(node.textContent);
        if (edges.leadingAscii && isFlankedByWhitespace('left', node, options)) {
            edges.leading = edges.leadingNonAscii;
        }
        if (edges.trailingAscii && isFlankedByWhitespace('right', node, options)) {
            edges.trailing = edges.trailingNonAscii;
        }
        return {
            leading: edges.leading,
            trailing: edges.trailing
        };
    }
    function edgeWhitespace(string) {
        var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
        return {
            leading: m[1],
            leadingAscii: m[2],
            leadingNonAscii: m[3],
            trailing: m[4],
            trailingNonAscii: m[5],
            trailingAscii: m[6]
        };
    }
    function isFlankedByWhitespace(side, node, options) {
        var sibling;
        var regExp;
        var isFlanked;
        if (side === 'left') {
            sibling = node.previousSibling;
            regExp = / $/;
        } else {
            sibling = node.nextSibling;
            regExp = /^ /;
        }
        if (sibling) {
            if (sibling.nodeType === 3) {
                isFlanked = regExp.test(sibling.nodeValue);
            } else if (options.preformattedCode && sibling.nodeName === 'CODE') {
                isFlanked = false;
            } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
                isFlanked = regExp.test(sibling.textContent);
            }
        }
        return isFlanked;
    }
    var reduce = Array.prototype.reduce;
    var escapes = [
        [
            /\\/g,
            '\\\\'
        ],
        [
            /\*/g,
            '\\*'
        ],
        [
            /^-/g,
            '\\-'
        ],
        [
            /^\+ /g,
            '\\+ '
        ],
        [
            /^(=+)/g,
            '\\$1'
        ],
        [
            /^(#{1,6}) /g,
            '\\$1 '
        ],
        [
            /`/g,
            '\\`'
        ],
        [
            /^~~~/g,
            '\\~~~'
        ],
        [
            /\[/g,
            '\\['
        ],
        [
            /\]/g,
            '\\]'
        ],
        [
            /^>/g,
            '\\>'
        ],
        [
            /_/g,
            '\\_'
        ],
        [
            /^(\d+)\. /g,
            '$1\\. '
        ]
    ];
    function TurndownService(options) {
        if (!(this instanceof TurndownService)) return new TurndownService(options);
        var defaults = {
            rules: rules,
            headingStyle: 'setext',
            hr: '* * *',
            bulletListMarker: '*',
            codeBlockStyle: 'indented',
            fence: '```',
            emDelimiter: '_',
            strongDelimiter: '**',
            linkStyle: 'inlined',
            linkReferenceStyle: 'full',
            br: '  ',
            preformattedCode: false,
            blankReplacement: function(content, node) {
                return node.isBlock ? '\n\n' : '';
            },
            keepReplacement: function(content, node) {
                return node.isBlock ? '\n\n' + node.outerHTML + '\n\n' : node.outerHTML;
            },
            defaultReplacement: function(content, node) {
                return node.isBlock ? '\n\n' + content + '\n\n' : content;
            }
        };
        this.options = extend({}, defaults, options);
        this.rules = new Rules(this.options);
    }
    TurndownService.prototype = {
        turndown: function(input) {
            if (!canConvert(input)) {
                throw new TypeError(input + ' is not a string, or an element/document/fragment node.');
            }
            if (input === '') return '';
            var output = process$1.call(this, new RootNode(input, this.options));
            return postProcess.call(this, output);
        },
        use: function(plugin) {
            if (Array.isArray(plugin)) {
                for(var i = 0; i < plugin.length; i++)this.use(plugin[i]);
            } else if (typeof plugin === 'function') {
                plugin(this);
            } else {
                throw new TypeError('plugin must be a Function or an Array of Functions');
            }
            return this;
        },
        addRule: function(key, rule) {
            this.rules.add(key, rule);
            return this;
        },
        keep: function(filter) {
            this.rules.keep(filter);
            return this;
        },
        remove: function(filter) {
            this.rules.remove(filter);
            return this;
        },
        escape: function(string) {
            return escapes.reduce(function(accumulator, escape) {
                return accumulator.replace(escape[0], escape[1]);
            }, string);
        }
    };
    function process$1(parentNode) {
        var self = this;
        return reduce.call(parentNode.childNodes, function(output, node) {
            node = new Node(node, self.options);
            var replacement = '';
            if (node.nodeType === 3) {
                replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
            } else if (node.nodeType === 1) {
                replacement = replacementForNode.call(self, node);
            }
            return join(output, replacement);
        }, '');
    }
    function postProcess(output) {
        var self = this;
        this.rules.forEach(function(rule) {
            if (typeof rule.append === 'function') {
                output = join(output, rule.append(self.options));
            }
        });
        return output.replace(/^[\t\r\n]+/, '').replace(/[\t\r\n\s]+$/, '');
    }
    function replacementForNode(node) {
        var rule = this.rules.forNode(node);
        var content = process$1.call(this, node);
        var whitespace = node.flankingWhitespace;
        if (whitespace.leading || whitespace.trailing) content = content.trim();
        return (whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing);
    }
    function join(output, replacement) {
        var s1 = trimTrailingNewlines(output);
        var s2 = trimLeadingNewlines(replacement);
        var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
        var separator = '\n\n'.substring(0, nls);
        return s1 + separator + s2;
    }
    function canConvert(input) {
        return (input != null && (typeof input === 'string' || (input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11))));
    }
    var define_process_env_default = {};
    var qy = Object.create;
    var Wi = Object.defineProperty;
    var Gy = Object.getOwnPropertyDescriptor;
    var Zy = Object.getOwnPropertyNames;
    var Qy = Object.getPrototypeOf, Ky = Object.prototype.hasOwnProperty;
    var v = (e, t)=>()=>(e && (t = e(e = 0)), t);
    var Kr = (e, t)=>()=>(t || e((t = {
                exports: {}
            }).exports, t), t.exports), V = (e, t)=>{
        for(var n in t)Wi(e, n, {
            get: t[n],
            enumerable: true
        });
    }, Xy = (e, t, n, r)=>{
        if (t && typeof t == "object" || typeof t == "function") for (let s of Zy(t))!Ky.call(e, s) && s !== n && Wi(e, s, {
            get: ()=>t[s],
            enumerable: !(r = Gy(t, s)) || r.enumerable
        });
        return e;
    };
    var Kl = (e, t, n)=>(n = e != null ? qy(Qy(e)) : {}, Xy(Wi(n, "default", {
            value: e,
            enumerable: true
        }), e));
    var Xl = {};
    V(Xl, {
        echoCommand: ()=>Yy
    });
    function Jy(e) {
        let t = "", n = 0;
        for(; n < e.length;)if (e[n] === "\\") {
            if (n + 1 >= e.length) {
                t += "\\";
                break;
            }
            let r = e[n + 1];
            switch(r){
                case "\\":
                    t += "\\", n += 2;
                    break;
                case "n":
                    t += `
`, n += 2;
                    break;
                case "t":
                    t += "	", n += 2;
                    break;
                case "r":
                    t += "\r", n += 2;
                    break;
                case "a":
                    t += "\x07", n += 2;
                    break;
                case "b":
                    t += "\b", n += 2;
                    break;
                case "f":
                    t += "\f", n += 2;
                    break;
                case "v":
                    t += "\v", n += 2;
                    break;
                case "e":
                case "E":
                    t += "\x1B", n += 2;
                    break;
                case "c":
                    return {
                        output: t,
                        stop: true
                    };
                case "0":
                    {
                        let s = "", i = n + 2;
                        for(; i < e.length && i < n + 5 && /[0-7]/.test(e[i]);)s += e[i], i++;
                        if (s.length === 0) t += "\0";
                        else {
                            let o = parseInt(s, 8) % 256;
                            t += String.fromCharCode(o);
                        }
                        n = i;
                        break;
                    }
                case "x":
                    {
                        let s = "", i = n + 2;
                        for(; i < e.length && i < n + 4 && /[0-9a-fA-F]/.test(e[i]);)s += e[i], i++;
                        if (s.length === 0) t += "\\x", n += 2;
                        else {
                            let o = parseInt(s, 16);
                            t += String.fromCharCode(o), n = i;
                        }
                        break;
                    }
                case "u":
                    {
                        let s = "", i = n + 2;
                        for(; i < e.length && i < n + 6 && /[0-9a-fA-F]/.test(e[i]);)s += e[i], i++;
                        if (s.length === 0) t += "\\u", n += 2;
                        else {
                            let o = parseInt(s, 16);
                            t += String.fromCodePoint(o), n = i;
                        }
                        break;
                    }
                case "U":
                    {
                        let s = "", i = n + 2;
                        for(; i < e.length && i < n + 10 && /[0-9a-fA-F]/.test(e[i]);)s += e[i], i++;
                        if (s.length === 0) t += "\\U", n += 2;
                        else {
                            let o = parseInt(s, 16);
                            try {
                                t += String.fromCodePoint(o);
                            } catch  {
                                t += `\\U${s}`;
                            }
                            n = i;
                        }
                        break;
                    }
                default:
                    t += `\\${r}`, n += 2;
            }
        } else t += e[n], n++;
        return {
            output: t,
            stop: false
        };
    }
    var Yy, Jl = v(()=>{
        Yy = {
            name: "echo",
            async execute (e, t) {
                let n = false, r = t.xpgEcho ?? false, s = 0;
                for(; s < e.length;){
                    let o = e[s];
                    if (o === "-n") n = true, s++;
                    else if (o === "-e") r = true, s++;
                    else if (o === "-E") r = false, s++;
                    else if (o === "-ne" || o === "-en") n = true, r = true, s++;
                    else break;
                }
                let i = e.slice(s).join(" ");
                if (r) {
                    let o = Jy(i);
                    if (i = o.output, o.stop) return {
                        stdout: i,
                        stderr: "",
                        exitCode: 0
                    };
                }
                return n || (i += `
`), {
                    stdout: i,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    function F(e) {
        let t = `${e.name} - ${e.summary}

`;
        if (t += `Usage: ${e.usage}
`, e.description) {
            if (t += `
Description:
`, typeof e.description == "string") for (let n of e.description.split(`
`))t += n ? `  ${n}
` : `
`;
            else if (e.description.length > 0) for (let n of e.description)t += n ? `  ${n}
` : `
`;
        }
        if (e.options && e.options.length > 0) {
            t += `
Options:
`;
            for (let n of e.options)t += `  ${n}
`;
        }
        if (e.examples && e.examples.length > 0) {
            t += `
Examples:
`;
            for (let n of e.examples)t += `  ${n}
`;
        }
        if (e.notes && e.notes.length > 0) {
            t += `
Notes:
`;
            for (let n of e.notes)t += `  ${n}
`;
        }
        return {
            stdout: t,
            stderr: "",
            exitCode: 0
        };
    }
    function _(e) {
        return e.includes("--help");
    }
    function G(e, t) {
        return {
            stdout: "",
            stderr: t.startsWith("--") ? `${e}: unrecognized option '${t}'
` : `${e}: invalid option -- '${t.replace(/^-/, "")}'
`,
            exitCode: 1
        };
    }
    var X = v(()=>{});
    function fe(e, t, n) {
        let r = new Map(), s = new Map();
        for (let [l, c] of Object.entries(n)){
            let u = {
                name: l,
                type: c.type
            };
            c.short && r.set(c.short, u), c.long && s.set(c.long, u);
        }
        let i = {};
        for (let [l, c] of Object.entries(n))c.default !== void 0 ? i[l] = c.default : c.type === "boolean" && (i[l] = false);
        let o = [], a = false;
        for(let l = 0; l < t.length; l++){
            let c = t[l];
            if (a || !c.startsWith("-") || c === "-") {
                o.push(c);
                continue;
            }
            if (c === "--") {
                a = true;
                continue;
            }
            if (c.startsWith("--")) {
                let u = c.indexOf("="), f, p;
                u !== -1 ? (f = c.slice(2, u), p = c.slice(u + 1)) : f = c.slice(2);
                let d = s.get(f);
                if (!d) return {
                    ok: false,
                    error: G(e, c)
                };
                let { name: m, type: h } = d;
                if (h === "boolean") i[m] = true;
                else {
                    if (p === void 0) {
                        if (l + 1 >= t.length) return {
                            ok: false,
                            error: {
                                stdout: "",
                                stderr: `${e}: option '--${f}' requires an argument
`,
                                exitCode: 1
                            }
                        };
                        p = t[++l];
                    }
                    i[m] = h === "number" ? parseInt(p, 10) : p;
                }
            } else {
                let u = c.slice(1);
                for(let f = 0; f < u.length; f++){
                    let p = u[f], d = r.get(p);
                    if (!d) return {
                        ok: false,
                        error: G(e, `-${p}`)
                    };
                    let { name: m, type: h } = d;
                    if (h === "boolean") i[m] = true;
                    else {
                        let g;
                        if (f + 1 < u.length) g = u.slice(f + 1);
                        else if (l + 1 < t.length) g = t[++l];
                        else return {
                            ok: false,
                            error: {
                                stdout: "",
                                stderr: `${e}: option requires an argument -- '${p}'
`,
                                exitCode: 1
                            }
                        };
                        i[m] = h === "number" ? parseInt(g, 10) : g;
                        break;
                    }
                }
            }
        }
        return {
            ok: true,
            result: {
                flags: i,
                positional: o
            }
        };
    }
    var Oe = v(()=>{
        X();
    });
    var Pn = v(()=>{});
    async function fn(e, t, n) {
        let { cmdName: r, allowStdinMarker: s = true, stopOnError: i = false, batchSize: o = 100 } = n;
        if (t.length === 0) return {
            files: [
                {
                    filename: "",
                    content: e.stdin
                }
            ],
            stderr: "",
            exitCode: 0
        };
        let a = [], l = "", c = 0;
        for(let u = 0; u < t.length; u += o){
            let f = t.slice(u, u + o), p = await Promise.all(f.map(async (d)=>{
                if (s && d === "-") return {
                    filename: "-",
                    content: e.stdin,
                    error: null
                };
                try {
                    let m = e.fs.resolvePath(e.cwd, d), h = await e.fs.readFile(m, "binary");
                    return {
                        filename: d,
                        content: h,
                        error: null
                    };
                } catch  {
                    return {
                        filename: d,
                        content: "",
                        error: `${r}: ${d}: No such file or directory
`
                    };
                }
            }));
            for (let d of p)if (d.error) {
                if (l += d.error, c = 1, i) return {
                    files: a,
                    stderr: l,
                    exitCode: c
                };
            } else a.push({
                filename: d.filename,
                content: d.content
            });
        }
        return {
            files: a,
            stderr: l,
            exitCode: c
        };
    }
    async function Tn(e, t, n) {
        let r = await fn(e, t, {
            ...n,
            stopOnError: true
        });
        return r.exitCode !== 0 ? {
            ok: false,
            error: {
                stdout: "",
                stderr: r.stderr,
                exitCode: r.exitCode
            }
        } : {
            ok: true,
            content: r.files.map((i)=>i.content).join("")
        };
    }
    var pn = v(()=>{
        Pn();
    });
    var Yl = {};
    V(Yl, {
        catCommand: ()=>nb
    });
    function rb(e, t) {
        let n = e.split(`
`), r = e.endsWith(`
`), s = r ? n.slice(0, -1) : n;
        return {
            content: s.map((o, a)=>`${String(t + a).padStart(6, " ")}	${o}`).join(`
`) + (r ? `
` : ""),
            nextLineNumber: t + s.length
        };
    }
    var eb, tb, nb, ec = v(()=>{
        Oe();
        pn();
        X();
        eb = {
            name: "cat",
            summary: "concatenate files and print on the standard output",
            usage: "cat [OPTION]... [FILE]...",
            options: [
                "-n, --number           number all output lines",
                "    --help             display this help and exit"
            ]
        }, tb = {
            number: {
                short: "n",
                long: "number",
                type: "boolean"
            }
        }, nb = {
            name: "cat",
            async execute (e, t) {
                if (_(e)) return F(eb);
                let n = fe("cat", e, tb);
                if (!n.ok) return n.error;
                let r = n.result.flags.number, s = n.result.positional, i = await fn(t, s, {
                    cmdName: "cat",
                    allowStdinMarker: true,
                    stopOnError: false
                }), o = "", a = 1;
                for (let { content: l } of i.files)if (r) {
                    let c = rb(l, a);
                    o += c.content, a = c.nextLineNumber;
                } else o += l;
                return {
                    stdout: o,
                    stderr: i.stderr,
                    exitCode: i.exitCode
                };
            }
        };
    });
    function Ne(e) {
        return e instanceof Error ? e.message : String(e);
    }
    var wt = v(()=>{});
    function Xr(e, t, n) {
        let r = e;
        n >= 0 && r.length > n && (r = r.slice(0, n));
        let s = Math.abs(t);
        return s > r.length && (t < 0 ? r = r.padEnd(s, " ") : r = r.padStart(s, " ")), r;
    }
    function tc(e, t) {
        let n = t, r = 0, s = -1, i = false;
        for(n < e.length && e[n] === "-" && (i = true, n++); n < e.length && /\d/.test(e[n]);)r = r * 10 + parseInt(e[n], 10), n++;
        if (n < e.length && e[n] === ".") for(n++, s = 0; n < e.length && /\d/.test(e[n]);)s = s * 10 + parseInt(e[n], 10), n++;
        return i && r > 0 && (r = -r), [
            r,
            s,
            n - t
        ];
    }
    function Jr(e) {
        let t = "", n = 0;
        for(; n < e.length;)if (e[n] === "\\" && n + 1 < e.length) switch(e[n + 1]){
            case "n":
                t += `
`, n += 2;
                break;
            case "t":
                t += "	", n += 2;
                break;
            case "r":
                t += "\r", n += 2;
                break;
            case "\\":
                t += "\\", n += 2;
                break;
            case "a":
                t += "\x07", n += 2;
                break;
            case "b":
                t += "\b", n += 2;
                break;
            case "f":
                t += "\f", n += 2;
                break;
            case "v":
                t += "\v", n += 2;
                break;
            case "e":
            case "E":
                t += "\x1B", n += 2;
                break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
                {
                    let s = "", i = n + 1;
                    for(; i < e.length && i < n + 4 && /[0-7]/.test(e[i]);)s += e[i], i++;
                    t += String.fromCharCode(parseInt(s, 8)), n = i;
                    break;
                }
            case "x":
                {
                    let s = [], i = n;
                    for(; i + 3 < e.length && e[i] === "\\" && e[i + 1] === "x" && /[0-9a-fA-F]{2}/.test(e.slice(i + 2, i + 4));)s.push(parseInt(e.slice(i + 2, i + 4), 16)), i += 4;
                    if (s.length > 0) {
                        try {
                            let o = new TextDecoder("utf-8", {
                                fatal: true
                            });
                            t += o.decode(new Uint8Array(s));
                        } catch  {
                            for (let o of s)t += String.fromCharCode(o);
                        }
                        n = i;
                    } else t += e[n], n++;
                    break;
                }
            case "u":
                {
                    let s = "", i = n + 2;
                    for(; i < e.length && i < n + 6 && /[0-9a-fA-F]/.test(e[i]);)s += e[i], i++;
                    s ? (t += String.fromCodePoint(parseInt(s, 16)), n = i) : (t += "\\u", n += 2);
                    break;
                }
            case "U":
                {
                    let s = "", i = n + 2;
                    for(; i < e.length && i < n + 10 && /[0-9a-fA-F]/.test(e[i]);)s += e[i], i++;
                    s ? (t += String.fromCodePoint(parseInt(s, 16)), n = i) : (t += "\\U", n += 2);
                    break;
                }
            default:
                t += e[n], n++;
        }
        else t += e[n], n++;
        return t;
    }
    var Bi = v(()=>{});
    function sc(e, t, n) {
        let r = new Date(t * 1e3), s = "", i = 0;
        for(; i < e.length;)if (e[i] === "%" && i + 1 < e.length) {
            let o = e[i + 1], a = ib(r, o, n);
            a !== null ? (s += a, i += 2) : (s += e[i], i++);
        } else s += e[i], i++;
        return s;
    }
    function sb(e, t) {
        let n = {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            weekday: "short",
            hour12: false,
            timeZone: t
        };
        try {
            let s = new Intl.DateTimeFormat("en-US", n).formatToParts(e), i = (l)=>s.find((c)=>c.type === l)?.value ?? "", o = {
                Sun: 0,
                Mon: 1,
                Tue: 2,
                Wed: 3,
                Thu: 4,
                Fri: 5,
                Sat: 6
            }, a = i("weekday");
            return {
                year: Number.parseInt(i("year"), 10) || e.getFullYear(),
                month: Number.parseInt(i("month"), 10) || e.getMonth() + 1,
                day: Number.parseInt(i("day"), 10) || e.getDate(),
                hour: Number.parseInt(i("hour"), 10) || e.getHours(),
                minute: Number.parseInt(i("minute"), 10) || e.getMinutes(),
                second: Number.parseInt(i("second"), 10) || e.getSeconds(),
                weekday: o[a] ?? e.getDay()
            };
        } catch  {
            return {
                year: e.getFullYear(),
                month: e.getMonth() + 1,
                day: e.getDate(),
                hour: e.getHours(),
                minute: e.getMinutes(),
                second: e.getSeconds(),
                weekday: e.getDay()
            };
        }
    }
    function ib(e, t, n) {
        let r = sb(e, n), s = (l, c = 2)=>String(l).padStart(c, "0"), i = ic(r.year, r.month, r.day), o = nc(r.year, r.month, r.day, r.weekday, 0), a = nc(r.year, r.month, r.day, r.weekday, 1);
        switch(t){
            case "a":
                return [
                    "Sun",
                    "Mon",
                    "Tue",
                    "Wed",
                    "Thu",
                    "Fri",
                    "Sat"
                ][r.weekday];
            case "A":
                return [
                    "Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday"
                ][r.weekday];
            case "b":
            case "h":
                return [
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec"
                ][r.month - 1];
            case "B":
                return [
                    "January",
                    "February",
                    "March",
                    "April",
                    "May",
                    "June",
                    "July",
                    "August",
                    "September",
                    "October",
                    "November",
                    "December"
                ][r.month - 1];
            case "c":
                return `${[
                    "Sun",
                    "Mon",
                    "Tue",
                    "Wed",
                    "Thu",
                    "Fri",
                    "Sat"
                ][r.weekday]} ${[
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec"
                ][r.month - 1]} ${String(r.day).padStart(2, " ")} ${s(r.hour)}:${s(r.minute)}:${s(r.second)} ${r.year}`;
            case "C":
                return s(Math.floor(r.year / 100));
            case "d":
                return s(r.day);
            case "D":
                return `${s(r.month)}/${s(r.day)}/${s(r.year % 100)}`;
            case "e":
                return String(r.day).padStart(2, " ");
            case "F":
                return `${r.year}-${s(r.month)}-${s(r.day)}`;
            case "g":
                return s(rc(r.year, r.month, r.day) % 100);
            case "G":
                return String(rc(r.year, r.month, r.day));
            case "H":
                return s(r.hour);
            case "I":
                return s(r.hour % 12 || 12);
            case "j":
                return String(i).padStart(3, "0");
            case "k":
                return String(r.hour).padStart(2, " ");
            case "l":
                return String(r.hour % 12 || 12).padStart(2, " ");
            case "m":
                return s(r.month);
            case "M":
                return s(r.minute);
            case "n":
                return `
`;
            case "N":
                return "000000000";
            case "p":
                return r.hour < 12 ? "AM" : "PM";
            case "P":
                return r.hour < 12 ? "am" : "pm";
            case "r":
                return `${s(r.hour % 12 || 12)}:${s(r.minute)}:${s(r.second)} ${r.hour < 12 ? "AM" : "PM"}`;
            case "R":
                return `${s(r.hour)}:${s(r.minute)}`;
            case "s":
                return String(Math.floor(e.getTime() / 1e3));
            case "S":
                return s(r.second);
            case "t":
                return "	";
            case "T":
                return `${s(r.hour)}:${s(r.minute)}:${s(r.second)}`;
            case "u":
                return String(r.weekday === 0 ? 7 : r.weekday);
            case "U":
                return s(o);
            case "V":
                return s(lb(r.year, r.month, r.day));
            case "w":
                return String(r.weekday);
            case "W":
                return s(a);
            case "x":
                return `${s(r.month)}/${s(r.day)}/${s(r.year % 100)}`;
            case "X":
                return `${s(r.hour)}:${s(r.minute)}:${s(r.second)}`;
            case "y":
                return s(r.year % 100);
            case "Y":
                return String(r.year);
            case "z":
                return ob(e, n);
            case "Z":
                return ab(e, n);
            case "%":
                return "%";
            default:
                return null;
        }
    }
    function ob(e, t) {
        if (!t) {
            let o = -e.getTimezoneOffset(), a = o >= 0 ? "+" : "-", l = Math.floor(Math.abs(o) / 60), c = Math.abs(o) % 60;
            return `${a}${String(l).padStart(2, "0")}${String(c).padStart(2, "0")}`;
        }
        try {
            let l = new Intl.DateTimeFormat("en-US", {
                timeZone: t,
                timeZoneName: "longOffset"
            }).formatToParts(e).find((c)=>c.type === "timeZoneName");
            if (l) {
                let c = l.value.match(/GMT([+-])(\d{2}):(\d{2})/);
                if (c) return `${c[1]}${c[2]}${c[3]}`;
                if (l.value === "GMT" || l.value === "UTC") return "+0000";
            }
        } catch  {}
        let n = -e.getTimezoneOffset(), r = n >= 0 ? "+" : "-", s = Math.floor(Math.abs(n) / 60), i = Math.abs(n) % 60;
        return `${r}${String(s).padStart(2, "0")}${String(i).padStart(2, "0")}`;
    }
    function ab(e, t) {
        try {
            return new Intl.DateTimeFormat("en-US", {
                timeZone: t,
                timeZoneName: "short"
            }).formatToParts(e).find((i)=>i.type === "timeZoneName")?.value ?? "UTC";
        } catch  {
            return "UTC";
        }
    }
    function ic(e, t, n) {
        let r = [
            31,
            28,
            31,
            30,
            31,
            30,
            31,
            31,
            30,
            31,
            30,
            31
        ];
        (e % 4 === 0 && e % 100 !== 0 || e % 400 === 0) && (r[1] = 29);
        let i = n;
        for(let o = 0; o < t - 1; o++)i += r[o];
        return i;
    }
    function nc(e, t, n, r, s) {
        let i = ic(e, t, n), l = (new Date(e, 0, 1).getDay() - s + 7) % 7, c = (r - s + 7) % 7, u = i - 1 + l;
        return Math.floor((u - c + 7) / 7);
    }
    function lb(e, t, n) {
        let r = new Date(e, t - 1, n, 12, 0, 0);
        r.setDate(r.getDate() + 3 - (r.getDay() + 6) % 7);
        let s = new Date(r.getFullYear(), 0, 4);
        s.setDate(s.getDate() + 3 - (s.getDay() + 6) % 7);
        let i = r.getTime() - s.getTime();
        return 1 + Math.round(i / (10080 * 60 * 1e3));
    }
    function rc(e, t, n) {
        let r = new Date(e, t - 1, n, 12, 0, 0);
        return r.setDate(r.getDate() + 3 - (r.getDay() + 6) % 7), r.getFullYear();
    }
    var oc = v(()=>{});
    var lc = {};
    V(lc, {
        printfCommand: ()=>fb
    });
    function cb(e) {
        let t = "", n = 0;
        for(; n < e.length;){
            let r = e[n];
            if (r < 128) {
                t += String.fromCharCode(r), n++;
                continue;
            }
            if ((r & 224) === 192) {
                if (n + 1 < e.length && (e[n + 1] & 192) === 128 && r >= 194) {
                    let s = (r & 31) << 6 | e[n + 1] & 63;
                    t += String.fromCharCode(s), n += 2;
                    continue;
                }
                t += String.fromCharCode(r), n++;
                continue;
            }
            if ((r & 240) === 224) {
                if (n + 2 < e.length && (e[n + 1] & 192) === 128 && (e[n + 2] & 192) === 128) {
                    if (r === 224 && e[n + 1] < 160) {
                        t += String.fromCharCode(r), n++;
                        continue;
                    }
                    let s = (r & 15) << 12 | (e[n + 1] & 63) << 6 | e[n + 2] & 63;
                    if (s >= 55296 && s <= 57343) {
                        t += String.fromCharCode(r), n++;
                        continue;
                    }
                    t += String.fromCharCode(s), n += 3;
                    continue;
                }
                t += String.fromCharCode(r), n++;
                continue;
            }
            if ((r & 248) === 240 && r <= 244) {
                if (n + 3 < e.length && (e[n + 1] & 192) === 128 && (e[n + 2] & 192) === 128 && (e[n + 3] & 192) === 128) {
                    if (r === 240 && e[n + 1] < 144) {
                        t += String.fromCharCode(r), n++;
                        continue;
                    }
                    let s = (r & 7) << 18 | (e[n + 1] & 63) << 12 | (e[n + 2] & 63) << 6 | e[n + 3] & 63;
                    if (s > 1114111) {
                        t += String.fromCharCode(r), n++;
                        continue;
                    }
                    t += String.fromCodePoint(s), n += 4;
                    continue;
                }
                t += String.fromCharCode(r), n++;
                continue;
            }
            t += String.fromCharCode(r), n++;
        }
        return t;
    }
    function pb(e, t, n, r) {
        let s = "", i = 0, o = 0, a = false, l = "";
        for(; i < e.length;)if (e[i] === "%" && i + 1 < e.length) {
            let c = i;
            if (i++, e[i] === "%") {
                s += "%", i++;
                continue;
            }
            let u = e.slice(c).match(/^%(-?\d*)(?:\.(\d+))?\(([^)]*)\)T/);
            if (u) {
                let C = u[1] ? parseInt(u[1], 10) : 0, A = u[2] ? parseInt(u[2], 10) : -1, I = u[3], O = u[0], L = t[n + o] || "";
                o++;
                let D;
                L === "" || L === "-1" || L === "-2" ? D = Math.floor(Date.now() / 1e3) : D = parseInt(L, 10) || 0;
                let $ = sc(I, D, r);
                if (A >= 0 && $.length > A && ($ = $.slice(0, A)), C !== 0) {
                    let N = Math.abs(C);
                    $.length < N && (C < 0 ? $ = $.padEnd(N, " ") : $ = $.padStart(N, " "));
                }
                s += $, i = c + O.length;
                continue;
            }
            for(; i < e.length && "+-0 #'".includes(e[i]);)i++;
            let f = false;
            if (e[i] === "*") f = true, i++;
            else for(; i < e.length && /\d/.test(e[i]);)i++;
            let p = false;
            if (e[i] === ".") if (i++, e[i] === "*") p = true, i++;
            else for(; i < e.length && /\d/.test(e[i]);)i++;
            i < e.length && "hlL".includes(e[i]) && i++;
            let d = e[i] || "";
            i++;
            let h = e.slice(c, i);
            if (f) {
                let C = parseInt(t[n + o] || "0", 10);
                o++, h = h.replace("*", String(C));
            }
            if (p) {
                let C = parseInt(t[n + o] || "0", 10);
                o++, h = h.replace(".*", `.${C}`);
            }
            let g = t[n + o] || "";
            o++;
            let { value: b, parseError: y, parseErrMsg: w, stopped: E } = db(h, d, g);
            if (s += b, y && (a = true, w && (l = w)), E) return {
                result: s,
                argsConsumed: o,
                error: a,
                errMsg: l,
                stopped: true
            };
        } else s += e[i], i++;
        return {
            result: s,
            argsConsumed: o,
            error: a,
            errMsg: l,
            stopped: false
        };
    }
    function db(e, t, n) {
        let r = false, s = "";
        switch(t){
            case "d":
            case "i":
                {
                    let i = Yr(n);
                    return r = It, r && (s = `printf: ${n}: invalid number
`), {
                        value: ac(e, i),
                        parseError: r,
                        parseErrMsg: s
                    };
                }
            case "o":
                {
                    let i = Yr(n);
                    return r = It, r && (s = `printf: ${n}: invalid number
`), {
                        value: hb(e, i),
                        parseError: r,
                        parseErrMsg: s
                    };
                }
            case "u":
                {
                    let i = Yr(n);
                    r = It, r && (s = `printf: ${n}: invalid number
`);
                    let o = i < 0 ? i >>> 0 : i;
                    return {
                        value: ac(e.replace("u", "d"), o),
                        parseError: r,
                        parseErrMsg: s
                    };
                }
            case "x":
            case "X":
                {
                    let i = Yr(n);
                    return r = It, r && (s = `printf: ${n}: invalid number
`), {
                        value: mb(e, i),
                        parseError: r,
                        parseErrMsg: s
                    };
                }
            case "e":
            case "E":
            case "f":
            case "F":
            case "g":
            case "G":
                {
                    let i = parseFloat(n) || 0;
                    return {
                        value: wb(e, t, i),
                        parseError: false,
                        parseErrMsg: ""
                    };
                }
            case "c":
                {
                    if (n === "") return {
                        value: "",
                        parseError: false,
                        parseErrMsg: ""
                    };
                    let a = new TextEncoder().encode(n)[0];
                    return {
                        value: String.fromCharCode(a),
                        parseError: false,
                        parseErrMsg: ""
                    };
                }
            case "s":
                return {
                    value: yb(e, n),
                    parseError: false,
                    parseErrMsg: ""
                };
            case "q":
                return {
                    value: bb(e, n),
                    parseError: false,
                    parseErrMsg: ""
                };
            case "b":
                {
                    let i = xb(n);
                    return {
                        value: i.value,
                        parseError: false,
                        parseErrMsg: "",
                        stopped: i.stopped
                    };
                }
            default:
                try {
                    return {
                        value: sprintf.sprintf(e, n),
                        parseError: false,
                        parseErrMsg: ""
                    };
                } catch  {
                    return {
                        value: "",
                        parseError: true,
                        parseErrMsg: `printf: [sprintf] unexpected placeholder
`
                    };
                }
        }
    }
    function Yr(e) {
        It = false;
        let t = e.trimStart(), n = t !== t.trimEnd();
        if (e = t.trimEnd(), e.startsWith("'") && e.length >= 2 || e.startsWith('"') && e.length >= 2) return e.charCodeAt(1);
        if (e.startsWith("\\'") && e.length >= 3 || e.startsWith('\\"') && e.length >= 3) return e.charCodeAt(2);
        if (e.startsWith("+") && (e = e.slice(1)), e.startsWith("0x") || e.startsWith("0X")) {
            let r = parseInt(e, 16);
            return Number.isNaN(r) ? (It = true, 0) : (n && (It = true), r);
        }
        if (e.startsWith("0") && e.length > 1 && /^-?0[0-7]+$/.test(e)) return n && (It = true), parseInt(e, 8) || 0;
        if (/^\d+#/.test(e)) {
            It = true;
            let r = e.match(/^(\d+)#/);
            return r ? parseInt(r[1], 10) : 0;
        }
        if (e !== "" && !/^-?\d+$/.test(e)) {
            It = true;
            let r = parseInt(e, 10);
            return Number.isNaN(r) ? 0 : r;
        }
        return n && (It = true), parseInt(e, 10) || 0;
    }
    function ac(e, t) {
        let n = e.match(/^%([- +#0']*)(\d*)(\.(\d*))?[diu]$/);
        if (!n) return sprintf.sprintf(e.replace(/\.\d*/, ""), t);
        let r = n[1] || "", s = n[2] ? parseInt(n[2], 10) : 0, i = n[3] !== void 0 ? n[4] ? parseInt(n[4], 10) : 0 : -1, o = t < 0, a = Math.abs(t), l = String(a);
        i >= 0 && (l = l.padStart(i, "0"));
        let c = "";
        o ? c = "-" : r.includes("+") ? c = "+" : r.includes(" ") && (c = " ");
        let u = c + l;
        return s > u.length && (r.includes("-") ? u = u.padEnd(s, " ") : r.includes("0") && i < 0 ? u = c + l.padStart(s - c.length, "0") : u = u.padStart(s, " ")), u;
    }
    function hb(e, t) {
        let n = e.match(/^%([- +#0']*)(\d*)(\.(\d*))?o$/);
        if (!n) return sprintf.sprintf(e, t);
        let r = n[1] || "", s = n[2] ? parseInt(n[2], 10) : 0, i = n[3] !== void 0 ? n[4] ? parseInt(n[4], 10) : 0 : -1, o = Math.abs(t).toString(8);
        i >= 0 && (o = o.padStart(i, "0")), r.includes("#") && !o.startsWith("0") && (o = `0${o}`);
        let a = o;
        return s > a.length && (r.includes("-") ? a = a.padEnd(s, " ") : r.includes("0") && i < 0 ? a = a.padStart(s, "0") : a = a.padStart(s, " ")), a;
    }
    function mb(e, t) {
        let n = e.includes("X"), r = e.match(/^%([- +#0']*)(\d*)(\.(\d*))?[xX]$/);
        if (!r) return sprintf.sprintf(e, t);
        let s = r[1] || "", i = r[2] ? parseInt(r[2], 10) : 0, o = r[3] !== void 0 ? r[4] ? parseInt(r[4], 10) : 0 : -1, a = Math.abs(t).toString(16);
        n && (a = a.toUpperCase()), o >= 0 && (a = a.padStart(o, "0"));
        let l = "";
        s.includes("#") && t !== 0 && (l = n ? "0X" : "0x");
        let c = l + a;
        return i > c.length && (s.includes("-") ? c = c.padEnd(i, " ") : s.includes("0") && o < 0 ? c = l + a.padStart(i - l.length, "0") : c = c.padStart(i, " ")), c;
    }
    function gb(e) {
        if (e === "") return "''";
        if (/^[a-zA-Z0-9_./-]+$/.test(e)) return e;
        if (/[\x00-\x1f\x7f-\xff]/.test(e)) {
            let r = "$'";
            for (let s of e){
                let i = s.charCodeAt(0);
                s === "'" ? r += "\\'" : s === "\\" ? r += "\\\\" : s === `
` ? r += "\\n" : s === "	" ? r += "\\t" : s === "\r" ? r += "\\r" : s === "\x07" ? r += "\\a" : s === "\b" ? r += "\\b" : s === "\f" ? r += "\\f" : s === "\v" ? r += "\\v" : s === "\x1B" ? r += "\\E" : i < 32 || i >= 127 && i <= 255 ? r += `\\${i.toString(8).padStart(3, "0")}` : s === '"' ? r += '\\"' : r += s;
            }
            return r += "'", r;
        }
        let n = "";
        for (let r of e)" 	|&;<>()$`\\\"'*?[#~=%!{}".includes(r) ? n += `\\${r}` : n += r;
        return n;
    }
    function yb(e, t) {
        let n = e.match(/^%(-?)(\d*)(\.(\d*))?s$/);
        if (!n) return sprintf.sprintf(e.replace(/0+(?=\d)/, ""), t);
        let r = n[1] === "-", s = n[2] ? parseInt(n[2], 10) : 0, i = n[3] !== void 0 ? n[4] ? parseInt(n[4], 10) : 0 : -1, o = r ? -s : s;
        return Xr(t, o, i);
    }
    function bb(e, t) {
        let n = gb(t), r = e.match(/^%(-?)(\d*)q$/);
        if (!r) return n;
        let s = r[1] === "-", i = r[2] ? parseInt(r[2], 10) : 0, o = n;
        return i > o.length && (s ? o = o.padEnd(i, " ") : o = o.padStart(i, " ")), o;
    }
    function wb(e, t, n) {
        let r = e.match(/^%([- +#0']*)(\d*)(\.(\d*))?[eEfFgG]$/);
        if (!r) return sprintf.sprintf(e, n);
        let s = r[1] || "", i = r[2] ? parseInt(r[2], 10) : 0, o = r[3] !== void 0 ? r[4] ? parseInt(r[4], 10) : 0 : 6, a, l = t.toLowerCase();
        if (l === "e" ? (a = n.toExponential(o), a = a.replace(/e([+-])(\d)$/, "e$10$2"), t === "E" && (a = a.toUpperCase())) : l === "f" ? (a = n.toFixed(o), s.includes("#") && o === 0 && !a.includes(".") && (a += ".")) : l === "g" ? (a = n.toPrecision(o || 1), s.includes("#") || (a = a.replace(/\.?0+$/, ""), a = a.replace(/\.?0+e/, "e")), a = a.replace(/e([+-])(\d)$/, "e$10$2"), t === "G" && (a = a.toUpperCase())) : a = n.toString(), n >= 0 && (s.includes("+") ? a = `+${a}` : s.includes(" ") && (a = ` ${a}`)), i > a.length) if (s.includes("-")) a = a.padEnd(i, " ");
        else if (s.includes("0")) {
            let c = a.match(/^[+ -]/)?.[0] || "", u = c ? a.slice(1) : a;
            a = c + u.padStart(i - c.length, "0");
        } else a = a.padStart(i, " ");
        return a;
    }
    function xb(e) {
        let t = "", n = 0;
        for(; n < e.length;)if (e[n] === "\\" && n + 1 < e.length) switch(e[n + 1]){
            case "n":
                t += `
`, n += 2;
                break;
            case "t":
                t += "	", n += 2;
                break;
            case "r":
                t += "\r", n += 2;
                break;
            case "\\":
                t += "\\", n += 2;
                break;
            case "a":
                t += "\x07", n += 2;
                break;
            case "b":
                t += "\b", n += 2;
                break;
            case "f":
                t += "\f", n += 2;
                break;
            case "v":
                t += "\v", n += 2;
                break;
            case "c":
                return {
                    value: t,
                    stopped: true
                };
            case "x":
                {
                    let s = [], i = n;
                    for(; i + 1 < e.length && e[i] === "\\" && e[i + 1] === "x";){
                        let o = "", a = i + 2;
                        for(; a < e.length && a < i + 4 && /[0-9a-fA-F]/.test(e[a]);)o += e[a], a++;
                        if (o) s.push(parseInt(o, 16)), i = a;
                        else break;
                    }
                    s.length > 0 ? (t += cb(s), n = i) : (t += "\\x", n += 2);
                    break;
                }
            case "u":
                {
                    let s = "", i = n + 2;
                    for(; i < e.length && i < n + 6 && /[0-9a-fA-F]/.test(e[i]);)s += e[i], i++;
                    s ? (t += String.fromCodePoint(parseInt(s, 16)), n = i) : (t += "\\u", n += 2);
                    break;
                }
            case "0":
                {
                    let s = "", i = n + 2;
                    for(; i < e.length && i < n + 5 && /[0-7]/.test(e[i]);)s += e[i], i++;
                    s ? t += String.fromCharCode(parseInt(s, 8)) : t += "\0", n = i;
                    break;
                }
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
                {
                    let s = "", i = n + 1;
                    for(; i < e.length && i < n + 4 && /[0-7]/.test(e[i]);)s += e[i], i++;
                    t += String.fromCharCode(parseInt(s, 8)), n = i;
                    break;
                }
            default:
                t += e[n], n++;
        }
        else t += e[n], n++;
        return {
            value: t,
            stopped: false
        };
    }
    var ub, fb, It, cc = v(()=>{
        wt();
        X();
        Bi();
        oc();
        ub = {
            name: "printf",
            summary: "format and print data",
            usage: "printf [-v var] FORMAT [ARGUMENT...]",
            options: [
                "    -v var     assign the output to shell variable VAR rather than display it",
                "    --help     display this help and exit"
            ],
            notes: [
                "FORMAT controls the output like in C printf.",
                "Escape sequences: \\n (newline), \\t (tab), \\\\ (backslash)",
                "Format specifiers: %s (string), %d (integer), %f (float), %x (hex), %o (octal), %% (literal %)",
                "Width and precision: %10s (width 10), %.2f (2 decimal places), %010d (zero-padded)",
                "Flags: %- (left-justify), %+ (show sign), %0 (zero-pad)"
            ]
        }, fb = {
            name: "printf",
            async execute (e, t) {
                if (_(e)) return F(ub);
                if (e.length === 0) return {
                    stdout: "",
                    stderr: `printf: usage: printf format [arguments]
`,
                    exitCode: 2
                };
                let n = null, r = 0;
                for(; r < e.length;){
                    let o = e[r];
                    if (o === "--") {
                        r++;
                        break;
                    }
                    if (o === "-v") {
                        if (r + 1 >= e.length) return {
                            stdout: "",
                            stderr: `printf: -v: option requires an argument
`,
                            exitCode: 1
                        };
                        if (n = e[r + 1], !/^[a-zA-Z_][a-zA-Z0-9_]*(\[[^\]]+\])?$/.test(n)) return {
                            stdout: "",
                            stderr: `printf: \`${n}': not a valid identifier
`,
                            exitCode: 2
                        };
                        r += 2;
                    } else {
                        if (o.startsWith("-") && o !== "-") break;
                        break;
                    }
                }
                if (r >= e.length) return {
                    stdout: "",
                    stderr: `printf: usage: printf format [arguments]
`,
                    exitCode: 1
                };
                let s = e[r], i = e.slice(r + 1);
                try {
                    let o = Jr(s), a = "", l = 0, c = false, u = "", f = t.env.TZ;
                    do {
                        let { result: p, argsConsumed: d, error: m, errMsg: h, stopped: g } = pb(o, i, l, f);
                        if (a += p, l += d, m && (c = true, h && (u = h)), g) break;
                    }while (l < i.length && l > 0);
                    if (l === 0 && i.length > 0, n) {
                        let p = n.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(['"]?)(.+?)\2\]$/);
                        if (p) {
                            let d = p[1], m = p[3];
                            m = m.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (h, g)=>t.env[g] ?? ""), t.env[`${d}_${m}`] = a;
                        } else t.env[n] = a;
                        return {
                            stdout: "",
                            stderr: u,
                            exitCode: c ? 1 : 0
                        };
                    }
                    return {
                        stdout: a,
                        stderr: u,
                        exitCode: c ? 1 : 0
                    };
                } catch (o) {
                    return {
                        stdout: "",
                        stderr: `printf: ${Ne(o)}
`,
                        exitCode: 1
                    };
                }
            }
        };
        It = false;
    });
    var pc = {};
    V(pc, {
        lsCommand: ()=>Ab
    });
    function es(e) {
        if (e < 1024) return String(e);
        if (e < 1024 * 1024) {
            let n = e / 1024;
            return n < 10 ? `${n.toFixed(1)}K` : `${Math.round(n)}K`;
        }
        if (e < 1024 * 1024 * 1024) {
            let n = e / 1048576;
            return n < 10 ? `${n.toFixed(1)}M` : `${Math.round(n)}M`;
        }
        let t = e / (1024 * 1024 * 1024);
        return t < 10 ? `${t.toFixed(1)}G` : `${Math.round(t)}G`;
    }
    function ts(e) {
        let n = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ][e.getMonth()], r = String(e.getDate()).padStart(2, " "), s = new Date(), i = new Date(s.getTime() - 4320 * 60 * 60 * 1e3);
        if (e > i) {
            let a = String(e.getHours()).padStart(2, "0"), l = String(e.getMinutes()).padStart(2, "0");
            return `${n} ${r} ${a}:${l}`;
        }
        let o = e.getFullYear();
        return `${n} ${r}  ${o}`;
    }
    async function Cb(e, t, n, r, s, i = false, o = false, a = false) {
        let l = n || r, c = t.fs.getAllPaths(), u = t.fs.resolvePath(t.cwd, "."), f = [];
        for (let p of c){
            let d = p.startsWith(u) && p.slice(u.length + 1) || p;
            if (minimatch(d, e) || minimatch(p, e)) {
                let m = d.split("/").pop() || d;
                if (!l && m.startsWith(".")) continue;
                f.push(d || p);
            }
        }
        if (f.length === 0) return {
            stdout: "",
            stderr: `ls: ${e}: No such file or directory
`,
            exitCode: 2
        };
        if (a) {
            let p = [];
            for (let d of f){
                let m = t.fs.resolvePath(t.cwd, d);
                try {
                    let h = await t.fs.stat(m);
                    p.push({
                        path: d,
                        size: h.size ?? 0
                    });
                } catch  {
                    p.push({
                        path: d,
                        size: 0
                    });
                }
            }
            p.sort((d, m)=>m.size - d.size), f.length = 0, f.push(...p.map((d)=>d.path));
        } else f.sort();
        if (i && f.reverse(), s) {
            let p = [];
            for (let d of f){
                let m = t.fs.resolvePath(t.cwd, d);
                try {
                    let h = await t.fs.stat(m), g = h.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", b = h.isDirectory ? "/" : "", y = h.size ?? 0, w = o ? es(y).padStart(5) : String(y).padStart(5), E = h.mtime ?? new Date(0), C = ts(E);
                    p.push(`${g} 1 user user ${w} ${C} ${d}${b}`);
                } catch  {
                    p.push(`-rw-r--r-- 1 user user     0 Jan  1 00:00 ${d}`);
                }
            }
            return {
                stdout: `${p.join(`
`)}
`,
                stderr: "",
                exitCode: 0
            };
        }
        return {
            stdout: `${f.join(`
`)}
`,
            stderr: "",
            exitCode: 0
        };
    }
    async function fc(e, t, n, r, s, i, o, a = false, l = false, c = false, u = false) {
        let f = n || r, p = t.fs.resolvePath(t.cwd, e);
        try {
            let d = await t.fs.stat(p);
            if (!d.isDirectory) {
                if (s) {
                    let g = d.size ?? 0, b = l ? es(g).padStart(5) : String(g).padStart(5), y = d.mtime ?? new Date(0), w = ts(y);
                    return {
                        stdout: `-rw-r--r-- 1 user user ${b} ${w} ${e}
`,
                        stderr: "",
                        exitCode: 0
                    };
                }
                return {
                    stdout: `${e}
`,
                    stderr: "",
                    exitCode: 0
                };
            }
            let m = await t.fs.readdir(p);
            if (f || (m = m.filter((g)=>!g.startsWith("."))), c) {
                let g = [];
                for (let b of m){
                    let y = p === "/" ? `/${b}` : `${p}/${b}`;
                    try {
                        let w = await t.fs.stat(y);
                        g.push({
                            name: b,
                            size: w.size ?? 0
                        });
                    } catch  {
                        g.push({
                            name: b,
                            size: 0
                        });
                    }
                }
                g.sort((b, y)=>y.size - b.size), m = g.map((b)=>b.name);
            } else m.sort();
            n && (m = [
                ".",
                "..",
                ...m
            ]), a && m.reverse();
            let h = "";
            if ((i || o) && (h += `${e}:
`), s) {
                h += `total ${m.length}
`;
                let g = m.filter((E)=>E === "." || E === ".."), b = m.filter((E)=>E !== "." && E !== "..");
                for (let E of g)h += `drwxr-xr-x 1 user user     0 Jan  1 00:00 ${E}
`;
                let y = [];
                for(let E = 0; E < b.length; E += 100){
                    let C = b.slice(E, E + 100), A = await Promise.all(C.map(async (I)=>{
                        let O = p === "/" ? `/${I}` : `${p}/${I}`;
                        try {
                            let L = await t.fs.stat(O), D = L.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", $ = L.isDirectory ? "/" : "", N = L.size ?? 0, P = l ? es(N).padStart(5) : String(N).padStart(5), k = L.mtime ?? new Date(0), R = ts(k);
                            return {
                                name: I,
                                line: `${D} 1 user user ${P} ${R} ${I}${$}
`
                            };
                        } catch  {
                            return {
                                name: I,
                                line: `-rw-r--r-- 1 user user     0 Jan  1 00:00 ${I}
`
                            };
                        }
                    }));
                    y.push(...A);
                }
                let w = new Map(b.map((E, C)=>[
                        E,
                        C
                    ]));
                y.sort((E, C)=>(w.get(E.name) ?? 0) - (w.get(C.name) ?? 0));
                for (let { line: E } of y)h += E;
            } else h += m.join(`
`) + (m.length ? `
` : "");
            if (i) {
                let g = m.filter((w)=>w !== "." && w !== ".."), b = [];
                if (t.fs.readdirWithFileTypes) b = (await t.fs.readdirWithFileTypes(p)).filter((E)=>E.isDirectory && g.includes(E.name)).map((E)=>({
                        name: E.name,
                        isDirectory: true
                    }));
                else for(let w = 0; w < g.length; w += 100){
                    let E = g.slice(w, w + 100), C = await Promise.all(E.map(async (A)=>{
                        let I = p === "/" ? `/${A}` : `${p}/${A}`;
                        try {
                            let O = await t.fs.stat(I);
                            return {
                                name: A,
                                isDirectory: O.isDirectory
                            };
                        } catch  {
                            return {
                                name: A,
                                isDirectory: false
                            };
                        }
                    }));
                    b.push(...C.filter((A)=>A.isDirectory));
                }
                b.sort((w, E)=>w.name.localeCompare(E.name)), a && b.reverse();
                let y = [];
                for(let w = 0; w < b.length; w += 100){
                    let E = b.slice(w, w + 100), C = await Promise.all(E.map(async (A)=>{
                        let I = e === "." ? `./${A.name}` : `${e}/${A.name}`, O = await fc(I, t, n, r, s, i, false, a, l, c, true);
                        return {
                            name: A.name,
                            result: O
                        };
                    }));
                    y.push(...C);
                }
                y.sort((w, E)=>w.name.localeCompare(E.name)), a && y.reverse();
                for (let { result: w } of y)h += `
`, h += w.stdout;
            }
            return {
                stdout: h,
                stderr: "",
                exitCode: 0
            };
        } catch  {
            return {
                stdout: "",
                stderr: `ls: ${e}: No such file or directory
`,
                exitCode: 2
            };
        }
    }
    var Eb, Sb, Ab, dc = v(()=>{
        Oe();
        Pn();
        X();
        Eb = {
            name: "ls",
            summary: "list directory contents",
            usage: "ls [OPTION]... [FILE]...",
            options: [
                "-a, --all            do not ignore entries starting with .",
                "-A, --almost-all     do not list . and ..",
                "-d, --directory      list directories themselves, not their contents",
                "-h, --human-readable with -l, print sizes like 1K 234M 2G etc.",
                "-l                   use a long listing format",
                "-r, --reverse        reverse order while sorting",
                "-R, --recursive      list subdirectories recursively",
                "-S                   sort by file size, largest first",
                "-t                   sort by time, newest first",
                "-1                   list one file per line",
                "    --help           display this help and exit"
            ]
        }, Sb = {
            showAll: {
                short: "a",
                long: "all",
                type: "boolean"
            },
            showAlmostAll: {
                short: "A",
                long: "almost-all",
                type: "boolean"
            },
            longFormat: {
                short: "l",
                type: "boolean"
            },
            humanReadable: {
                short: "h",
                long: "human-readable",
                type: "boolean"
            },
            recursive: {
                short: "R",
                long: "recursive",
                type: "boolean"
            },
            reverse: {
                short: "r",
                long: "reverse",
                type: "boolean"
            },
            sortBySize: {
                short: "S",
                type: "boolean"
            },
            directoryOnly: {
                short: "d",
                long: "directory",
                type: "boolean"
            },
            sortByTime: {
                short: "t",
                type: "boolean"
            },
            onePerLine: {
                short: "1",
                type: "boolean"
            }
        }, Ab = {
            name: "ls",
            async execute (e, t) {
                if (_(e)) return F(Eb);
                let n = fe("ls", e, Sb);
                if (!n.ok) return n.error;
                let r = n.result.flags.showAll, s = n.result.flags.showAlmostAll, i = n.result.flags.longFormat, o = n.result.flags.humanReadable, a = n.result.flags.recursive, l = n.result.flags.reverse, c = n.result.flags.sortBySize, u = n.result.flags.directoryOnly;
                n.result.flags.sortByTime;
                n.result.flags.onePerLine;
                let p = n.result.positional;
                p.length === 0 && p.push(".");
                let d = "", m = "", h = 0;
                for(let g = 0; g < p.length; g++){
                    let b = p[g];
                    if (g > 0 && d && !d.endsWith(`

`) && (d += `
`), u) {
                        let y = t.fs.resolvePath(t.cwd, b);
                        try {
                            let w = await t.fs.stat(y);
                            if (i) {
                                let E = w.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", C = w.isDirectory ? "/" : "", A = w.size ?? 0, I = o ? es(A).padStart(5) : String(A).padStart(5), O = w.mtime ?? new Date(0), L = ts(O);
                                d += `${E} 1 user user ${I} ${L} ${b}${C}
`;
                            } else d += `${b}
`;
                        } catch  {
                            m += `ls: cannot access '${b}': No such file or directory
`, h = 2;
                        }
                        continue;
                    }
                    if (b.includes("*") || b.includes("?") || b.includes("[")) {
                        let y = await Cb(b, t, r, s, i, l, o, c);
                        d += y.stdout, m += y.stderr, y.exitCode !== 0 && (h = y.exitCode);
                    } else {
                        let y = await fc(b, t, r, s, i, a, p.length > 1, l, o, c);
                        d += y.stdout, m += y.stderr, y.exitCode !== 0 && (h = y.exitCode);
                    }
                }
                return {
                    stdout: d,
                    stderr: m,
                    exitCode: h
                };
            }
        };
    });
    var hc = {};
    V(hc, {
        mkdirCommand: ()=>kb
    });
    var Nb, kb, mc = v(()=>{
        wt();
        Oe();
        Nb = {
            recursive: {
                short: "p",
                long: "parents",
                type: "boolean"
            },
            verbose: {
                short: "v",
                long: "verbose",
                type: "boolean"
            }
        }, kb = {
            name: "mkdir",
            async execute (e, t) {
                let n = fe("mkdir", e, Nb);
                if (!n.ok) return n.error;
                let r = n.result.flags.recursive, s = n.result.flags.verbose, i = n.result.positional;
                if (i.length === 0) return {
                    stdout: "",
                    stderr: `mkdir: missing operand
`,
                    exitCode: 1
                };
                let o = "", a = "", l = 0;
                for (let c of i)try {
                    let u = t.fs.resolvePath(t.cwd, c);
                    await t.fs.mkdir(u, {
                        recursive: r
                    }), s && (o += `mkdir: created directory '${c}'
`);
                } catch (u) {
                    let f = Ne(u);
                    f.includes("ENOENT") || f.includes("no such file") ? a += `mkdir: cannot create directory '${c}': No such file or directory
` : f.includes("EEXIST") || f.includes("already exists") ? a += `mkdir: cannot create directory '${c}': File exists
` : a += `mkdir: cannot create directory '${c}': ${f}
`, l = 1;
                }
                return {
                    stdout: o,
                    stderr: a,
                    exitCode: l
                };
            }
        };
    });
    var bc = {};
    V(bc, {
        rmdirCommand: ()=>Ib
    });
    async function Rb(e, t, n, r) {
        let s = "", i = "", a = e.fs.resolvePath(e.cwd, t), l = await gc(e, a, t, r);
        if (s += l.stdout, i += l.stderr, l.exitCode !== 0) return {
            stdout: s,
            stderr: i,
            exitCode: l.exitCode
        };
        if (n) {
            let c = a, u = t;
            for(;;){
                let f = yc(c), p = yc(u);
                if (f === c || f === "/" || f === "." || p === "." || p === "") break;
                let d = await gc(e, f, p, r);
                if (s += d.stdout, d.exitCode !== 0) break;
                c = f, u = p;
            }
        }
        return {
            stdout: s,
            stderr: i,
            exitCode: 0
        };
    }
    async function gc(e, t, n, r) {
        try {
            if (!await e.fs.exists(t)) return {
                stdout: "",
                stderr: `rmdir: failed to remove '${n}': No such file or directory
`,
                exitCode: 1
            };
            if (!(await e.fs.stat(t)).isDirectory) return {
                stdout: "",
                stderr: `rmdir: failed to remove '${n}': Not a directory
`,
                exitCode: 1
            };
            if ((await e.fs.readdir(t)).length > 0) return {
                stdout: "",
                stderr: `rmdir: failed to remove '${n}': Directory not empty
`,
                exitCode: 1
            };
            await e.fs.rm(t, {
                recursive: false,
                force: false
            });
            let a = "";
            return r && (a = `rmdir: removing directory, '${n}'
`), {
                stdout: a,
                stderr: "",
                exitCode: 0
            };
        } catch (s) {
            let i = Ne(s);
            return {
                stdout: "",
                stderr: `rmdir: failed to remove '${n}': ${i}
`,
                exitCode: 1
            };
        }
    }
    function yc(e) {
        let t = e.replace(/\/+$/, ""), n = t.lastIndexOf("/");
        return n === -1 ? "." : n === 0 ? "/" : t.substring(0, n);
    }
    var vb, $b, Ib, wc = v(()=>{
        wt();
        Oe();
        vb = `Usage: rmdir [-pv] DIRECTORY...
Remove empty directories.

Options:
  -p, --parents   Remove DIRECTORY and its ancestors
  -v, --verbose   Output a diagnostic for every directory processed`, $b = {
            parents: {
                short: "p",
                long: "parents",
                type: "boolean"
            },
            verbose: {
                short: "v",
                long: "verbose",
                type: "boolean"
            },
            help: {
                long: "help",
                type: "boolean"
            }
        }, Ib = {
            name: "rmdir",
            async execute (e, t) {
                let n = fe("rmdir", e, $b);
                if (!n.ok) return n.error;
                if (n.result.flags.help) return {
                    stdout: `${vb}
`,
                    stderr: "",
                    exitCode: 0
                };
                let r = n.result.flags.parents, s = n.result.flags.verbose, i = n.result.positional;
                if (i.length === 0) return {
                    stdout: "",
                    stderr: `rmdir: missing operand
`,
                    exitCode: 1
                };
                let o = "", a = "", l = 0;
                for (let c of i){
                    let u = await Rb(t, c, r, s);
                    o += u.stdout, a += u.stderr, u.exitCode !== 0 && (l = u.exitCode);
                }
                return {
                    stdout: o,
                    stderr: a,
                    exitCode: l
                };
            }
        };
    });
    var xc = {};
    V(xc, {
        touchCommand: ()=>Tb
    });
    function Pb(e) {
        let t = e.replace(/\//g, "-"), n = new Date(t);
        if (!Number.isNaN(n.getTime())) return n;
        let r = t.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (r) {
            let [, i, o, a] = r;
            if (n = new Date(Number.parseInt(i, 10), Number.parseInt(o, 10) - 1, Number.parseInt(a, 10)), !Number.isNaN(n.getTime())) return n;
        }
        let s = t.match(/^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})$/);
        if (s) {
            let [, i, o, a, l, c, u] = s;
            if (n = new Date(Number.parseInt(i, 10), Number.parseInt(o, 10) - 1, Number.parseInt(a, 10), Number.parseInt(l, 10), Number.parseInt(c, 10), Number.parseInt(u, 10)), !Number.isNaN(n.getTime())) return n;
        }
        return null;
    }
    var Tb, Ec = v(()=>{
        wt();
        X();
        Tb = {
            name: "touch",
            async execute (e, t) {
                let n = [], r = null, s = false;
                for(let l = 0; l < e.length; l++){
                    let c = e[l];
                    if (c === "--") {
                        n.push(...e.slice(l + 1));
                        break;
                    } else if (c === "-d" || c === "--date") {
                        if (l + 1 >= e.length) return {
                            stdout: "",
                            stderr: `touch: option requires an argument -- 'd'
`,
                            exitCode: 1
                        };
                        r = e[++l];
                    } else if (c.startsWith("--date=")) r = c.slice(7);
                    else if (c === "-c" || c === "--no-create") s = true;
                    else if (c === "-a" || c === "-m" || c === "-r" || c === "-t") (c === "-r" || c === "-t") && l++;
                    else {
                        if (c.startsWith("--")) return G("touch", c);
                        if (c.startsWith("-") && c.length > 1) {
                            let u = false;
                            for (let f of c.slice(1))if (f === "c") s = true;
                            else if (!(f === "a" || f === "m")) if (f === "d") {
                                if (l + 1 >= e.length) return {
                                    stdout: "",
                                    stderr: `touch: option requires an argument -- 'd'
`,
                                    exitCode: 1
                                };
                                r = e[++l], u = true;
                                break;
                            } else if (f === "r" || f === "t") {
                                l++, u = true;
                                break;
                            } else return G("touch", `-${f}`);
                            if (u) continue;
                        } else n.push(c);
                    }
                }
                if (n.length === 0) return {
                    stdout: "",
                    stderr: `touch: missing file operand
`,
                    exitCode: 1
                };
                let i = null;
                if (r !== null && (i = Pb(r), i === null)) return {
                    stdout: "",
                    stderr: `touch: invalid date format '${r}'
`,
                    exitCode: 1
                };
                let o = "", a = 0;
                for (let l of n)try {
                    let c = t.fs.resolvePath(t.cwd, l);
                    if (!await t.fs.exists(c)) {
                        if (s) continue;
                        await t.fs.writeFile(c, "");
                    }
                    let f = i ?? new Date();
                    await t.fs.utimes(c, f, f);
                } catch (c) {
                    o += `touch: cannot touch '${l}': ${Ne(c)}
`, a = 1;
                }
                return {
                    stdout: "",
                    stderr: o,
                    exitCode: a
                };
            }
        };
    });
    var Sc = {};
    V(Sc, {
        rmCommand: ()=>Db
    });
    var Ob, Db, Ac = v(()=>{
        wt();
        Oe();
        Ob = {
            recursive: {
                short: "r",
                long: "recursive",
                type: "boolean"
            },
            recursiveUpper: {
                short: "R",
                type: "boolean"
            },
            force: {
                short: "f",
                long: "force",
                type: "boolean"
            },
            verbose: {
                short: "v",
                long: "verbose",
                type: "boolean"
            }
        }, Db = {
            name: "rm",
            async execute (e, t) {
                let n = fe("rm", e, Ob);
                if (!n.ok) return n.error;
                let r = n.result.flags.recursive || n.result.flags.recursiveUpper, s = n.result.flags.force, i = n.result.flags.verbose, o = n.result.positional;
                if (o.length === 0) return s ? {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                } : {
                    stdout: "",
                    stderr: `rm: missing operand
`,
                    exitCode: 1
                };
                let a = "", l = "", c = 0;
                for (let u of o)try {
                    let f = t.fs.resolvePath(t.cwd, u);
                    if ((await t.fs.stat(f)).isDirectory && !r) {
                        l += `rm: cannot remove '${u}': Is a directory
`, c = 1;
                        continue;
                    }
                    await t.fs.rm(f, {
                        recursive: r,
                        force: s
                    }), i && (a += `removed '${u}'
`);
                } catch (f) {
                    if (!s) {
                        let p = Ne(f);
                        p.includes("ENOENT") || p.includes("no such file") ? l += `rm: cannot remove '${u}': No such file or directory
` : p.includes("ENOTEMPTY") || p.includes("not empty") ? l += `rm: cannot remove '${u}': Directory not empty
` : l += `rm: cannot remove '${u}': ${p}
`, c = 1;
                    }
                }
                return {
                    stdout: a,
                    stderr: l,
                    exitCode: c
                };
            }
        };
    });
    var Cc = {};
    V(Cc, {
        cpCommand: ()=>Lb
    });
    var Fb, _b, Lb, Nc = v(()=>{
        wt();
        Oe();
        X();
        Fb = {
            name: "cp",
            summary: "copy files and directories",
            usage: "cp [OPTION]... SOURCE... DEST",
            options: [
                "-r, -R, --recursive  copy directories recursively",
                "-n, --no-clobber     do not overwrite an existing file",
                "-p, --preserve       preserve file attributes",
                "-v, --verbose        explain what is being done",
                "    --help           display this help and exit"
            ]
        }, _b = {
            recursive: {
                short: "r",
                long: "recursive",
                type: "boolean"
            },
            recursiveUpper: {
                short: "R",
                type: "boolean"
            },
            noClobber: {
                short: "n",
                long: "no-clobber",
                type: "boolean"
            },
            preserve: {
                short: "p",
                long: "preserve",
                type: "boolean"
            },
            verbose: {
                short: "v",
                long: "verbose",
                type: "boolean"
            }
        }, Lb = {
            name: "cp",
            async execute (e, t) {
                if (_(e)) return F(Fb);
                let n = fe("cp", e, _b);
                if (!n.ok) return n.error;
                let r = n.result.flags.recursive || n.result.flags.recursiveUpper, s = n.result.flags.noClobber;
                n.result.flags.preserve;
                let o = n.result.flags.verbose, a = n.result.positional;
                if (a.length < 2) return {
                    stdout: "",
                    stderr: `cp: missing destination file operand
`,
                    exitCode: 1
                };
                let l = a.pop() ?? "", c = a, u = t.fs.resolvePath(t.cwd, l), f = "", p = "", d = 0, m = false;
                try {
                    m = (await t.fs.stat(u)).isDirectory;
                } catch  {}
                if (c.length > 1 && !m) return {
                    stdout: "",
                    stderr: `cp: target '${l}' is not a directory
`,
                    exitCode: 1
                };
                for (let h of c)try {
                    let g = t.fs.resolvePath(t.cwd, h), b = await t.fs.stat(g), y = u;
                    if (m) {
                        let w = h.split("/").pop() || h;
                        y = u === "/" ? `/${w}` : `${u}/${w}`;
                    }
                    if (b.isDirectory && !r) {
                        p += `cp: -r not specified; omitting directory '${h}'
`, d = 1;
                        continue;
                    }
                    if (s) try {
                        await t.fs.stat(y);
                        continue;
                    } catch  {}
                    await t.fs.cp(g, y, {
                        recursive: r
                    }), o && (f += `'${h}' -> '${y}'
`);
                } catch (g) {
                    let b = Ne(g);
                    b.includes("ENOENT") || b.includes("no such file") ? p += `cp: cannot stat '${h}': No such file or directory
` : p += `cp: cannot copy '${h}': ${b}
`, d = 1;
                }
                return {
                    stdout: f,
                    stderr: p,
                    exitCode: d
                };
            }
        };
    });
    var kc = {};
    V(kc, {
        mvCommand: ()=>Bb
    });
    var Mb, Wb, Bb, vc = v(()=>{
        wt();
        Oe();
        X();
        Mb = {
            name: "mv",
            summary: "move (rename) files",
            usage: "mv [OPTION]... SOURCE... DEST",
            options: [
                "-f, --force       do not prompt before overwriting",
                "-n, --no-clobber  do not overwrite an existing file",
                "-v, --verbose     explain what is being done",
                "    --help        display this help and exit"
            ]
        }, Wb = {
            force: {
                short: "f",
                long: "force",
                type: "boolean"
            },
            noClobber: {
                short: "n",
                long: "no-clobber",
                type: "boolean"
            },
            verbose: {
                short: "v",
                long: "verbose",
                type: "boolean"
            }
        }, Bb = {
            name: "mv",
            async execute (e, t) {
                if (_(e)) return F(Mb);
                let n = fe("mv", e, Wb);
                if (!n.ok) return n.error;
                n.result.flags.force;
                let s = n.result.flags.noClobber, i = n.result.flags.verbose, o = n.result.positional;
                if (o.length < 2) return {
                    stdout: "",
                    stderr: `mv: missing destination file operand
`,
                    exitCode: 1
                };
                let a = o.pop() ?? "", l = o, c = t.fs.resolvePath(t.cwd, a), u = "", f = "", p = 0, d = false;
                try {
                    d = (await t.fs.stat(c)).isDirectory;
                } catch  {}
                if (l.length > 1 && !d) return {
                    stdout: "",
                    stderr: `mv: target '${a}' is not a directory
`,
                    exitCode: 1
                };
                for (let m of l)try {
                    let h = t.fs.resolvePath(t.cwd, m), g = c;
                    if (d) {
                        let b = m.split("/").pop() || m;
                        g = c === "/" ? `/${b}` : `${c}/${b}`;
                    }
                    if (s) try {
                        await t.fs.stat(g);
                        continue;
                    } catch  {}
                    if (await t.fs.mv(h, g), i) {
                        let b = d ? `${a}/${m.split("/").pop() || m}` : a;
                        u += `renamed '${m}' -> '${b}'
`;
                    }
                } catch (h) {
                    let g = Ne(h);
                    g.includes("ENOENT") || g.includes("no such file") ? f += `mv: cannot stat '${m}': No such file or directory
` : f += `mv: cannot move '${m}': ${g}
`, p = 1;
                }
                return {
                    stdout: u,
                    stderr: f,
                    exitCode: p
                };
            }
        };
    });
    var $c = {};
    V($c, {
        lnCommand: ()=>zb
    });
    var Ub, zb, Ic = v(()=>{
        X();
        Ub = {
            name: "ln",
            summary: "make links between files",
            usage: "ln [OPTIONS] TARGET LINK_NAME",
            options: [
                "-s      create a symbolic link instead of a hard link",
                "-f      remove existing destination files",
                "-n      treat LINK_NAME as a normal file if it is a symbolic link to a directory",
                "-v      print name of each linked file",
                "    --help display this help and exit"
            ]
        }, zb = {
            name: "ln",
            async execute (e, t) {
                if (_(e)) return F(Ub);
                let n = false, r = false, s = false, i = 0;
                for(; i < e.length && e[i].startsWith("-");){
                    let f = e[i];
                    if (f === "-s" || f === "--symbolic") n = true, i++;
                    else if (f === "-f" || f === "--force") r = true, i++;
                    else if (f === "-v" || f === "--verbose") s = true, i++;
                    else if (f === "-n" || f === "--no-dereference") i++;
                    else if (/^-[sfvn]+$/.test(f)) f.includes("s") && (n = true), f.includes("f") && (r = true), f.includes("v") && (s = true), i++;
                    else if (f === "--") {
                        i++;
                        break;
                    } else return {
                        stdout: "",
                        stderr: `ln: invalid option -- '${f.slice(1)}'
`,
                        exitCode: 1
                    };
                }
                let o = e.slice(i);
                if (o.length < 2) return {
                    stdout: "",
                    stderr: `ln: missing file operand
`,
                    exitCode: 1
                };
                let a = o[0], l = o[1], c = t.fs.resolvePath(t.cwd, l);
                if (await t.fs.exists(c)) if (r) try {
                    await t.fs.rm(c, {
                        force: true
                    });
                } catch  {
                    return {
                        stdout: "",
                        stderr: `ln: cannot remove '${l}': Permission denied
`,
                        exitCode: 1
                    };
                }
                else return {
                    stdout: "",
                    stderr: `ln: failed to create ${n ? "symbolic " : ""}link '${l}': File exists
`,
                    exitCode: 1
                };
                try {
                    if (n) await t.fs.symlink(a, c);
                    else {
                        let f = t.fs.resolvePath(t.cwd, a);
                        if (!await t.fs.exists(f)) return {
                            stdout: "",
                            stderr: `ln: failed to access '${a}': No such file or directory
`,
                            exitCode: 1
                        };
                        await t.fs.link(f, c);
                    }
                } catch (f) {
                    let p = f;
                    return p.message.includes("EPERM") ? {
                        stdout: "",
                        stderr: `ln: '${a}': hard link not allowed for directory
`,
                        exitCode: 1
                    } : {
                        stdout: "",
                        stderr: `ln: ${p.message}
`,
                        exitCode: 1
                    };
                }
                let u = "";
                return s && (u = `'${l}' -> '${a}'
`), {
                    stdout: u,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var Pc = {};
    V(Pc, {
        chmodCommand: ()=>Hb
    });
    async function Rc(e, t, n, r, s) {
        let i = "", o = await e.fs.readdir(t);
        for (let a of o){
            let l = t === "/" ? `/${a}` : `${t}/${a}`, c;
            if (n !== void 0) c = n;
            else if (r !== void 0) {
                let f = await e.fs.stat(l);
                c = Ui(r, f.mode);
            } else c = 420;
            await e.fs.chmod(l, c), s && (i += `mode of '${l}' changed to ${c.toString(8).padStart(4, "0")}
`), (await e.fs.stat(l)).isDirectory && (i += await Rc(e, l, n, r, s));
        }
        return i;
    }
    function Ui(e, t = 420) {
        if (/^[0-7]+$/.test(e)) return parseInt(e, 8);
        let n = t & 4095, r = e.split(",");
        for (let s of r){
            let i = s.match(/^([ugoa]*)([+\-=])([rwxXst]*)$/);
            if (!i) throw new Error(`Invalid mode: ${e}`);
            let o = i[1] || "a", a = i[2], l = i[3];
            (o === "a" || o === "") && (o = "ugo");
            let c = 0;
            l.includes("r") && (c |= 4), l.includes("w") && (c |= 2), (l.includes("x") || l.includes("X")) && (c |= 1);
            let u = 0;
            l.includes("s") && (o.includes("u") && (u |= 2048), o.includes("g") && (u |= 1024)), l.includes("t") && (u |= 512);
            for (let f of o){
                let p = 0;
                f === "u" ? p = 6 : f === "g" ? p = 3 : f === "o" && (p = 0);
                let d = c << p;
                a === "+" ? n |= d : a === "-" ? n &= ~d : a === "=" && (n &= ~(7 << p), n |= d);
            }
            a === "+" ? n |= u : a === "-" ? n &= ~u : a === "=" && (l.includes("s") && (o.includes("u") && (n &= -2049, n |= u & 2048), o.includes("g") && (n &= -1025, n |= u & 1024)), l.includes("t") && (n &= -513, n |= u & 512));
        }
        return n;
    }
    var jb, Hb, Tc = v(()=>{
        X();
        jb = {
            name: "chmod",
            summary: "change file mode bits",
            usage: "chmod [OPTIONS] MODE FILE...",
            options: [
                "-R      change files recursively",
                "-v      output a diagnostic for every file processed",
                "    --help display this help and exit"
            ]
        }, Hb = {
            name: "chmod",
            async execute (e, t) {
                if (_(e)) return F(jb);
                if (e.length < 2) return {
                    stdout: "",
                    stderr: `chmod: missing operand
`,
                    exitCode: 1
                };
                let n = false, r = false, s = 0;
                for(; s < e.length && e[s].startsWith("-");){
                    let p = e[s];
                    if (p === "-R" || p === "--recursive") n = true, s++;
                    else if (p === "-v" || p === "--verbose") r = true, s++;
                    else if (p === "--") {
                        s++;
                        break;
                    } else {
                        if (/^[+-]?[rwxugo]+/.test(p) || /^\d+$/.test(p)) break;
                        if (/^-[Rv]+$/.test(p)) {
                            p.includes("R") && (n = true), p.includes("v") && (r = true), s++;
                            continue;
                        }
                        return {
                            stdout: "",
                            stderr: `chmod: invalid option -- '${p.slice(1)}'
`,
                            exitCode: 1
                        };
                    }
                }
                if (e.length - s < 2) return {
                    stdout: "",
                    stderr: `chmod: missing operand
`,
                    exitCode: 1
                };
                let i = e[s], o = e.slice(s + 1), a = /^[0-7]+$/.test(i), l;
                if (a) l = parseInt(i, 8);
                else try {
                    Ui(i, 420);
                } catch  {
                    return {
                        stdout: "",
                        stderr: `chmod: invalid mode: '${i}'
`,
                        exitCode: 1
                    };
                }
                let c = "", u = "", f = false;
                for (let p of o){
                    let d = t.fs.resolvePath(t.cwd, p);
                    try {
                        let m;
                        if (a && l !== void 0) m = l;
                        else {
                            let h = await t.fs.stat(d);
                            m = Ui(i, h.mode);
                        }
                        if (await t.fs.chmod(d, m), r && (c += `mode of '${p}' changed to ${m.toString(8).padStart(4, "0")}
`), n && (await t.fs.stat(d)).isDirectory) {
                            let g = await Rc(t, d, a ? l : void 0, a ? void 0 : i, r);
                            c += g;
                        }
                    } catch  {
                        u += `chmod: cannot access '${p}': No such file or directory
`, f = true;
                    }
                }
                return {
                    stdout: c,
                    stderr: u,
                    exitCode: f ? 1 : 0
                };
            }
        };
    });
    var Oc = {};
    V(Oc, {
        pwdCommand: ()=>Vb
    });
    var Vb, Dc = v(()=>{
        Vb = {
            name: "pwd",
            async execute (e, t) {
                let n = false;
                for (let s of e)if (s === "-P") n = true;
                else if (s === "-L") n = false;
                else {
                    if (s === "--") break;
                    s.startsWith("-");
                }
                let r = t.cwd;
                if (n) try {
                    r = await t.fs.realpath(t.cwd);
                } catch  {}
                return {
                    stdout: `${r}
`,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var Fc = {};
    V(Fc, {
        readlinkCommand: ()=>Gb
    });
    var qb, Gb, _c = v(()=>{
        X();
        qb = {
            name: "readlink",
            summary: "print resolved symbolic links or canonical file names",
            usage: "readlink [OPTIONS] FILE...",
            options: [
                "-f      canonicalize by following every symlink in every component of the given name recursively",
                "    --help display this help and exit"
            ]
        }, Gb = {
            name: "readlink",
            async execute (e, t) {
                if (_(e)) return F(qb);
                let n = false, r = 0;
                for(; r < e.length && e[r].startsWith("-");){
                    let a = e[r];
                    if (a === "-f" || a === "--canonicalize") n = true, r++;
                    else if (a === "--") {
                        r++;
                        break;
                    } else return {
                        stdout: "",
                        stderr: `readlink: invalid option -- '${a.slice(1)}'
`,
                        exitCode: 1
                    };
                }
                let s = e.slice(r);
                if (s.length === 0) return {
                    stdout: "",
                    stderr: `readlink: missing operand
`,
                    exitCode: 1
                };
                let i = "", o = false;
                for (let a of s){
                    let l = t.fs.resolvePath(t.cwd, a);
                    try {
                        if (n) {
                            let c = l, u = new Set();
                            for(; !u.has(c);){
                                u.add(c);
                                try {
                                    let f = await t.fs.readlink(c);
                                    if (f.startsWith("/")) c = f;
                                    else {
                                        let p = c.substring(0, c.lastIndexOf("/")) || "/";
                                        c = t.fs.resolvePath(p, f);
                                    }
                                } catch  {
                                    break;
                                }
                            }
                            i += `${c}
`;
                        } else {
                            let c = await t.fs.readlink(l);
                            i += `${c}
`;
                        }
                    } catch  {
                        n ? i += `${l}
` : o = true;
                    }
                }
                return {
                    stdout: i,
                    stderr: "",
                    exitCode: o ? 1 : 0
                };
            }
        };
    });
    function ns(e, t) {
        let n = 10, r = null, s = false, i = false, o = false, a = [];
        for(let l = 0; l < e.length; l++){
            let c = e[l];
            if (c === "-n" && l + 1 < e.length) {
                let u = e[++l];
                t === "tail" && u.startsWith("+") ? (o = true, n = parseInt(u.slice(1), 10)) : n = parseInt(u, 10);
            } else if (t === "tail" && c.startsWith("-n+")) o = true, n = parseInt(c.slice(3), 10);
            else if (c.startsWith("-n")) n = parseInt(c.slice(2), 10);
            else if (c === "-c" && l + 1 < e.length) r = parseInt(e[++l], 10);
            else if (c.startsWith("-c")) r = parseInt(c.slice(2), 10);
            else if (c.startsWith("--bytes=")) r = parseInt(c.slice(8), 10);
            else if (c.startsWith("--lines=")) n = parseInt(c.slice(8), 10);
            else if (c === "-q" || c === "--quiet" || c === "--silent") s = true;
            else if (c === "-v" || c === "--verbose") i = true;
            else if (c.match(/^-\d+$/)) n = parseInt(c.slice(1), 10);
            else {
                if (c.startsWith("--")) return {
                    ok: false,
                    error: G(t, c)
                };
                if (c.startsWith("-") && c !== "-") return {
                    ok: false,
                    error: G(t, c)
                };
                a.push(c);
            }
        }
        return r !== null && (Number.isNaN(r) || r < 0) ? {
            ok: false,
            error: {
                stdout: "",
                stderr: `${t}: invalid number of bytes
`,
                exitCode: 1
            }
        } : Number.isNaN(n) || n < 0 ? {
            ok: false,
            error: {
                stdout: "",
                stderr: `${t}: invalid number of lines
`,
                exitCode: 1
            }
        } : {
            ok: true,
            options: {
                lines: n,
                bytes: r,
                quiet: s,
                verbose: i,
                files: a,
                fromLine: o
            }
        };
    }
    async function rs(e, t, n, r) {
        let { quiet: s, verbose: i, files: o } = t;
        if (o.length === 0) return {
            stdout: r(e.stdin),
            stderr: "",
            exitCode: 0
        };
        let a = "", l = "", c = 0, u = i || !s && o.length > 1, f = 0;
        for(let p = 0; p < o.length; p++){
            let d = o[p];
            try {
                let m = e.fs.resolvePath(e.cwd, d), h = await e.fs.readFile(m);
                u && (f > 0 && (a += `
`), a += `==> ${d} <==
`), a += r(h), f++;
            } catch  {
                l += `${n}: ${d}: No such file or directory
`, c = 1;
            }
        }
        return {
            stdout: a,
            stderr: l,
            exitCode: c
        };
    }
    function Lc(e, t, n) {
        if (n !== null) return e.slice(0, n);
        if (t === 0) return "";
        let r = 0, s = 0, i = e.length;
        for(; r < i && s < t;){
            let o = e.indexOf(`
`, r);
            if (o === -1) return `${e}
`;
            s++, r = o + 1;
        }
        return r > 0 ? e.slice(0, r) : "";
    }
    function Mc(e, t, n, r) {
        if (n !== null) return e.slice(-n);
        let s = e.length;
        if (s === 0) return "";
        if (r) {
            let l = 0, c = 1;
            for(; l < s && c < t;){
                let f = e.indexOf(`
`, l);
                if (f === -1) break;
                c++, l = f + 1;
            }
            let u = e.slice(l);
            return u.endsWith(`
`) ? u : `${u}
`;
        }
        if (t === 0) return "";
        let i = s - 1;
        e[i] === `
` && i--;
        let o = 0;
        for(; i >= 0 && o < t;){
            if (e[i] === `
` && (o++, o === t)) {
                i++;
                break;
            }
            i--;
        }
        i < 0 && (i = 0);
        let a = e.slice(i);
        return e[s - 1] === `
` ? a : `${a}
`;
    }
    var zi = v(()=>{
        X();
    });
    var Wc = {};
    V(Wc, {
        headCommand: ()=>Qb
    });
    var Zb, Qb, Bc = v(()=>{
        X();
        zi();
        Zb = {
            name: "head",
            summary: "output the first part of files",
            usage: "head [OPTION]... [FILE]...",
            options: [
                "-c, --bytes=NUM    print the first NUM bytes",
                "-n, --lines=NUM    print the first NUM lines (default 10)",
                "-q, --quiet        never print headers giving file names",
                "-v, --verbose      always print headers giving file names",
                "    --help         display this help and exit"
            ]
        }, Qb = {
            name: "head",
            async execute (e, t) {
                if (_(e)) return F(Zb);
                let n = ns(e, "head");
                if (!n.ok) return n.error;
                let { lines: r, bytes: s } = n.options;
                return rs(t, n.options, "head", (i)=>Lc(i, r, s));
            }
        };
    });
    var Uc = {};
    V(Uc, {
        tailCommand: ()=>Xb
    });
    var Kb, Xb, zc = v(()=>{
        zi();
        X();
        Kb = {
            name: "tail",
            summary: "output the last part of files",
            usage: "tail [OPTION]... [FILE]...",
            options: [
                "-c, --bytes=NUM    print the last NUM bytes",
                "-n, --lines=NUM    print the last NUM lines (default 10)",
                "-n +NUM            print starting from line NUM",
                "-q, --quiet        never print headers giving file names",
                "-v, --verbose      always print headers giving file names",
                "    --help         display this help and exit"
            ]
        }, Xb = {
            name: "tail",
            async execute (e, t) {
                if (_(e)) return F(Kb);
                let n = ns(e, "tail");
                if (!n.ok) return n.error;
                let { lines: r, bytes: s, fromLine: i } = n.options;
                return rs(t, n.options, "tail", (o)=>Mc(o, r, s, i ?? false));
            }
        };
    });
    var Hc = {};
    V(Hc, {
        wcCommand: ()=>ew
    });
    function jc(e) {
        let t = e.length, n = 0, r = 0, s = false;
        for(let i = 0; i < t; i++){
            let o = e[i];
            o === `
` ? (n++, s && (r++, s = false)) : o === " " || o === "	" || o === "\r" ? s && (r++, s = false) : s = true;
        }
        return s && r++, {
            lines: n,
            words: r,
            chars: t
        };
    }
    function ji(e, t, n, r, s, i) {
        let o = [];
        t && o.push(String(e.lines).padStart(i)), n && o.push(String(e.words).padStart(i)), r && o.push(String(e.chars).padStart(i));
        let a = o.join(" ");
        return s && (a += ` ${s}`), a;
    }
    var Jb, Yb, ew, Vc = v(()=>{
        Oe();
        pn();
        X();
        Jb = {
            name: "wc",
            summary: "print newline, word, and byte counts for each file",
            usage: "wc [OPTION]... [FILE]...",
            options: [
                "-c, --bytes      print the byte counts",
                "-m, --chars      print the character counts",
                "-l, --lines      print the newline counts",
                "-w, --words      print the word counts",
                "    --help       display this help and exit"
            ]
        }, Yb = {
            lines: {
                short: "l",
                long: "lines",
                type: "boolean"
            },
            words: {
                short: "w",
                long: "words",
                type: "boolean"
            },
            bytes: {
                short: "c",
                long: "bytes",
                type: "boolean"
            },
            chars: {
                short: "m",
                long: "chars",
                type: "boolean"
            }
        }, ew = {
            name: "wc",
            async execute (e, t) {
                if (_(e)) return F(Jb);
                let n = fe("wc", e, Yb);
                if (!n.ok) return n.error;
                let { lines: r, words: s } = n.result.flags, i = n.result.flags.bytes || n.result.flags.chars, o = n.result.positional;
                !r && !s && !i && (r = s = i = true);
                let a = await fn(t, o, {
                    cmdName: "wc",
                    stopOnError: false
                });
                if (o.length === 0) {
                    let b = jc(a.files[0].content);
                    return {
                        stdout: `${ji(b, r, s, i, "", 0)}
`,
                        stderr: "",
                        exitCode: 0
                    };
                }
                let l = [], c = 0, u = 0, f = 0;
                for (let { filename: b, content: y } of a.files){
                    let w = jc(y);
                    c += w.lines, u += w.words, f += w.chars, l.push({
                        filename: b,
                        stats: w
                    });
                }
                let p = o.length > 1 ? c : Math.max(...l.map((b)=>b.stats.lines)), d = o.length > 1 ? u : Math.max(...l.map((b)=>b.stats.words)), m = o.length > 1 ? f : Math.max(...l.map((b)=>b.stats.chars)), h = o.length > 1 ? 3 : 0;
                r && (h = Math.max(h, String(p).length)), s && (h = Math.max(h, String(d).length)), i && (h = Math.max(h, String(m).length));
                let g = "";
                for (let { filename: b, stats: y } of l)g += `${ji(y, r, s, i, b, h)}
`;
                return o.length > 1 && (g += `${ji({
                    lines: c,
                    words: u,
                    chars: f
                }, r, s, i, "total", h)}
`), {
                    stdout: g,
                    stderr: a.stderr,
                    exitCode: a.exitCode
                };
            }
        };
    });
    var Gc = {};
    V(Gc, {
        statCommand: ()=>rw
    });
    function qc(e, t) {
        let n = t ? "d" : "-", r = [
            e & 256 ? "r" : "-",
            e & 128 ? "w" : "-",
            e & 64 ? "x" : "-",
            e & 32 ? "r" : "-",
            e & 16 ? "w" : "-",
            e & 8 ? "x" : "-",
            e & 4 ? "r" : "-",
            e & 2 ? "w" : "-",
            e & 1 ? "x" : "-"
        ];
        return n + r.join("");
    }
    var tw, nw, rw, Zc = v(()=>{
        Oe();
        X();
        tw = {
            name: "stat",
            summary: "display file or file system status",
            usage: "stat [OPTION]... FILE...",
            options: [
                "-c FORMAT   use the specified FORMAT instead of the default",
                "    --help  display this help and exit"
            ]
        }, nw = {
            format: {
                short: "c",
                type: "string"
            }
        }, rw = {
            name: "stat",
            async execute (e, t) {
                if (_(e)) return F(tw);
                let n = fe("stat", e, nw);
                if (!n.ok) return n.error;
                let r = n.result.flags.format ?? null, s = n.result.positional;
                if (s.length === 0) return {
                    stdout: "",
                    stderr: `stat: missing operand
`,
                    exitCode: 1
                };
                let i = "", o = "", a = false;
                for (let l of s){
                    let c = t.fs.resolvePath(t.cwd, l);
                    try {
                        let u = await t.fs.stat(c);
                        if (r) {
                            let f = r, p = u.mode.toString(8), d = qc(u.mode, u.isDirectory);
                            f = f.replace(/%n/g, l), f = f.replace(/%N/g, `'${l}'`), f = f.replace(/%s/g, String(u.size)), f = f.replace(/%F/g, u.isDirectory ? "directory" : "regular file"), f = f.replace(/%a/g, p), f = f.replace(/%A/g, d), f = f.replace(/%u/g, "1000"), f = f.replace(/%U/g, "user"), f = f.replace(/%g/g, "1000"), f = f.replace(/%G/g, "group"), i += `${f}
`;
                        } else {
                            let f = u.mode.toString(8).padStart(4, "0"), p = qc(u.mode, u.isDirectory);
                            i += `  File: ${l}
`, i += `  Size: ${u.size}		Blocks: ${Math.ceil(u.size / 512)}
`, i += `Access: (${f}/${p})
`, i += `Modify: ${u.mtime.toISOString()}
`;
                        }
                    } catch  {
                        o += `stat: cannot stat '${l}': No such file or directory
`, a = true;
                    }
                }
                return {
                    stdout: i,
                    stderr: o,
                    exitCode: a ? 1 : 0
                };
            }
        };
    });
    function Ye(e, t, n) {
        let r = typeof n == "boolean" ? {
            ignoreCase: n
        } : n ?? {}, s = t;
        r.stripQuotes && (s.startsWith('"') && s.endsWith('"') || s.startsWith("'") && s.endsWith("'")) && (s = s.slice(1, -1));
        let i = r.ignoreCase ? `i:${s}` : s, o = Qc.get(i);
        return o || (o = sw(s, r.ignoreCase), Qc.set(i, o)), o.test(e);
    }
    function sw(e, t) {
        let n = "^";
        for(let r = 0; r < e.length; r++){
            let s = e[r];
            if (s === "*") n += ".*";
            else if (s === "?") n += ".";
            else if (s === "[") {
                let i = r + 1;
                for(; i < e.length && e[i] !== "]";)i++;
                n += e.slice(r, i + 1), r = i;
            } else s === "." || s === "+" || s === "^" || s === "$" || s === "{" || s === "}" || s === "(" || s === ")" || s === "|" || s === "\\" ? n += `\\${s}` : n += s;
        }
        return n += "$", new RegExp(n, t ? "i" : "");
    }
    var Qc, Hi = v(()=>{
        Qc = new Map();
    });
    function Kc(e, t) {
        return e.replace(/\$(&|\d+|<([^>]+)>)/g, (n, r, s)=>{
            if (r === "&") return t[0];
            if (s !== void 0) return t.groups?.[s] ?? "";
            let i = parseInt(r, 10);
            return t[i] ?? "";
        });
    }
    function Dn(e, t, n = {}) {
        let { invertMatch: r = false, showLineNumbers: s = false, countOnly: i = false, countMatches: o = false, filename: a = "", onlyMatching: l = false, beforeContext: c = 0, afterContext: u = 0, maxCount: f = 0, contextSeparator: p = "--", showColumn: d = false, vimgrep: m = false, showByteOffset: h = false, replace: g = null, passthru: b = false, multiline: y = false, kResetGroup: w } = n;
        if (y) return iw(e, t, {
            invertMatch: r,
            showLineNumbers: s,
            countOnly: i,
            countMatches: o,
            filename: a,
            onlyMatching: l,
            beforeContext: c,
            afterContext: u,
            maxCount: f,
            contextSeparator: p,
            showColumn: d,
            showByteOffset: h,
            replace: g,
            kResetGroup: w
        });
        let E = e.split(`
`), C = E.length, A = C > 0 && E[C - 1] === "" ? C - 1 : C;
        if (i || o) {
            let N = 0, P = (o || l) && !r;
            for(let R = 0; R < A; R++)if (t.lastIndex = 0, P) for(let T = t.exec(E[R]); T !== null; T = t.exec(E[R]))N++, T[0].length === 0 && t.lastIndex++;
            else t.test(E[R]) !== r && N++;
            return {
                output: `${a ? `${a}:${N}` : String(N)}
`,
                matched: N > 0,
                matchCount: N
            };
        }
        if (c === 0 && u === 0 && !b) {
            let N = [], P = false, k = 0, R = 0;
            for(let T = 0; T < A && !(f > 0 && k >= f); T++){
                let Y = E[T];
                if (t.lastIndex = 0, t.test(Y) !== r) if (P = true, k++, l) {
                    t.lastIndex = 0;
                    for(let K = t.exec(Y); K !== null; K = t.exec(Y)){
                        let B = w !== void 0 ? K[w] ?? "" : K[0], q = g !== null ? Kc(g, K) : B, be = a ? `${a}:` : "";
                        h && (be += `${R + K.index}:`), s && (be += `${T + 1}:`), d && (be += `${K.index + 1}:`), N.push(be + q), K[0].length === 0 && t.lastIndex++;
                    }
                } else if (m) {
                    t.lastIndex = 0;
                    for(let K = t.exec(Y); K !== null; K = t.exec(Y)){
                        let B = a ? `${a}:` : "";
                        h && (B += `${R + K.index}:`), s && (B += `${T + 1}:`), d && (B += `${K.index + 1}:`), N.push(B + Y), K[0].length === 0 && t.lastIndex++;
                    }
                } else {
                    t.lastIndex = 0;
                    let K = t.exec(Y), B = K ? K.index + 1 : 1, q = Y;
                    g !== null && (t.lastIndex = 0, q = Y.replace(t, (...ee)=>{
                        if (ee[0].length === 0) return "";
                        let U = ee, ye = ee[ee.length - 1];
                        return typeof ye == "object" && ye !== null ? (U.groups = ye, U.input = ee[ee.length - 2], U.index = ee[ee.length - 3]) : (U.input = ee[ee.length - 1], U.index = ee[ee.length - 2]), Kc(g, U);
                    }));
                    let be = a ? `${a}:` : "";
                    h && (be += `${R + (K ? K.index : 0)}:`), s && (be += `${T + 1}:`), d && (be += `${B}:`), N.push(be + q);
                }
                R += Y.length + 1;
            }
            return {
                output: N.length > 0 ? `${N.join(`
`)}
` : "",
                matched: P,
                matchCount: k
            };
        }
        if (b) {
            let N = [], P = false, k = 0;
            for(let R = 0; R < A; R++){
                let T = E[R];
                t.lastIndex = 0;
                let ie = t.test(T) !== r;
                ie && (P = true, k++);
                let K = ie ? ":" : "-", B = a ? `${a}${K}` : "";
                s && (B += `${R + 1}${K}`), N.push(B + T);
            }
            return {
                output: N.length > 0 ? `${N.join(`
`)}
` : "",
                matched: P,
                matchCount: k
            };
        }
        let I = [], O = 0, L = new Set(), D = -1, $ = [];
        for(let N = 0; N < A && !(f > 0 && O >= f); N++)t.lastIndex = 0, t.test(E[N]) !== r && ($.push(N), O++);
        for (let N of $){
            let P = Math.max(0, N - c);
            D >= 0 && P > D + 1 && I.push(p);
            for(let R = P; R < N; R++)if (!L.has(R)) {
                L.add(R), D = R;
                let T = E[R];
                s && (T = `${R + 1}-${T}`), a && (T = `${a}-${T}`), I.push(T);
            }
            if (!L.has(N)) {
                L.add(N), D = N;
                let R = E[N];
                if (l) {
                    t.lastIndex = 0;
                    for(let T = t.exec(R); T !== null; T = t.exec(R)){
                        let Y = w !== void 0 ? T[w] ?? "" : T[0], ie = g !== null ? g : Y, K = a ? `${a}:` : "";
                        s && (K += `${N + 1}:`), d && (K += `${T.index + 1}:`), I.push(K + ie), T[0].length === 0 && t.lastIndex++;
                    }
                } else {
                    let T = R;
                    s && (T = `${N + 1}:${T}`), a && (T = `${a}:${T}`), I.push(T);
                }
            }
            let k = Math.min(A - 1, N + u);
            for(let R = N + 1; R <= k; R++)if (!L.has(R)) {
                L.add(R), D = R;
                let T = E[R];
                s && (T = `${R + 1}-${T}`), a && (T = `${a}-${T}`), I.push(T);
            }
        }
        return {
            output: I.length > 0 ? `${I.join(`
`)}
` : "",
            matched: O > 0,
            matchCount: O
        };
    }
    function iw(e, t, n) {
        let { invertMatch: r, showLineNumbers: s, countOnly: i, countMatches: o, filename: a, onlyMatching: l, beforeContext: c, afterContext: u, maxCount: f, contextSeparator: p, showColumn: d, showByteOffset: m, replace: h, kResetGroup: g } = n, b = e.split(`
`), y = b.length, w = y > 0 && b[y - 1] === "" ? y - 1 : y, E = [
            0
        ];
        for(let $ = 0; $ < e.length; $++)e[$] === `
` && E.push($ + 1);
        let C = ($)=>{
            let N = 0;
            for(let P = 0; P < E.length && !(E[P] > $); P++)N = P;
            return N;
        }, A = ($)=>{
            let N = C($);
            return $ - E[N] + 1;
        }, I = [];
        t.lastIndex = 0;
        for(let $ = t.exec(e); $ !== null && !(f > 0 && I.length >= f); $ = t.exec(e)){
            let N = C($.index), P = C($.index + Math.max(0, $[0].length - 1)), k = g !== void 0 ? $[g] ?? "" : $[0];
            I.push({
                startLine: N,
                endLine: P,
                byteOffset: $.index,
                column: A($.index),
                matchText: k
            }), $[0].length === 0 && t.lastIndex++;
        }
        if (i || o) {
            let $;
            if (o) $ = r ? 0 : I.length;
            else {
                let P = new Set();
                for (let k of I)for(let R = k.startLine; R <= k.endLine; R++)P.add(R);
                $ = r ? w - P.size : P.size;
            }
            return {
                output: `${a ? `${a}:${$}` : String($)}
`,
                matched: $ > 0,
                matchCount: $
            };
        }
        if (r) {
            let $ = new Set();
            for (let P of I)for(let k = P.startLine; k <= P.endLine; k++)$.add(k);
            let N = [];
            for(let P = 0; P < w; P++)if (!$.has(P)) {
                let k = b[P];
                s && (k = `${P + 1}:${k}`), a && (k = `${a}:${k}`), N.push(k);
            }
            return {
                output: N.length > 0 ? `${N.join(`
`)}
` : "",
                matched: N.length > 0,
                matchCount: N.length
            };
        }
        if (I.length === 0) return {
            output: "",
            matched: false,
            matchCount: 0
        };
        let O = new Set(), L = -1, D = [];
        for (let $ of I){
            let N = Math.max(0, $.startLine - c), P = Math.min(w - 1, $.endLine + u);
            L >= 0 && N > L + 1 && D.push(p);
            for(let k = N; k < $.startLine; k++)if (!O.has(k)) {
                O.add(k), L = k;
                let R = b[k];
                s && (R = `${k + 1}-${R}`), a && (R = `${a}-${R}`), D.push(R);
            }
            if (l) {
                let k = h !== null ? h : $.matchText, R = a ? `${a}:` : "";
                m && (R += `${$.byteOffset}:`), s && (R += `${$.startLine + 1}:`), d && (R += `${$.column}:`), D.push(R + k);
                for(let T = $.startLine; T <= $.endLine; T++)O.add(T), L = T;
            } else for(let k = $.startLine; k <= $.endLine && k < w; k++)if (!O.has(k)) {
                O.add(k), L = k;
                let R = b[k];
                h !== null && k === $.startLine && (t.lastIndex = 0, R = R.replace(t, h));
                let T = a ? `${a}:` : "";
                m && k === $.startLine && (T += `${$.byteOffset}:`), s && (T += `${k + 1}:`), d && k === $.startLine && (T += `${$.column}:`), D.push(T + R);
            }
            for(let k = $.endLine + 1; k <= P; k++)if (!O.has(k)) {
                O.add(k), L = k;
                let R = b[k];
                s && (R = `${k + 1}-${R}`), a && (R = `${a}-${R}`), D.push(R);
            }
        }
        return {
            output: D.length > 0 ? `${D.join(`
`)}
` : "",
            matched: true,
            matchCount: I.length
        };
    }
    var Xc = v(()=>{});
    function Jc(e) {
        let t = "", n = 0;
        for(; n < e.length;){
            if (e.slice(n, n + 7) === "[[:<:]]") {
                t += "(?<![\\w])", n += 7;
                continue;
            }
            if (e.slice(n, n + 7) === "[[:>:]]") {
                t += "(?![\\w])", n += 7;
                continue;
            }
            if (e[n] === "[") {
                let r = "[";
                for(n++, n < e.length && (e[n] === "^" || e[n] === "!") && (r += "^", n++), n < e.length && e[n] === "]" && (r += "\\]", n++); n < e.length && e[n] !== "]";){
                    if (e[n] === "[" && n + 1 < e.length && e[n + 1] === ":") {
                        let s = e.indexOf(":]", n + 2);
                        if (s !== -1) {
                            let i = e.slice(n + 2, s), o = ow[i];
                            if (o) {
                                r += o, n = s + 2;
                                continue;
                            }
                        }
                    }
                    if (e[n] === "\\" && n + 1 < e.length) {
                        r += e[n] + e[n + 1], n += 2;
                        continue;
                    }
                    r += e[n], n++;
                }
                n < e.length && e[n] === "]" && (r += "]", n++), t += r;
                continue;
            }
            if (e[n] === "\\" && n + 1 < e.length) {
                t += e[n] + e[n + 1], n += 2;
                continue;
            }
            t += e[n], n++;
        }
        return t;
    }
    function hr(e, t) {
        let n, r;
        switch(t.mode){
            case "fixed":
                n = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                break;
            case "extended":
            case "perl":
                {
                    if (n = Jc(e), n = n.replace(/\(\?P<([^>]+)>/g, "(?<$1>"), t.mode === "perl") {
                        n = aw(n), n = lw(n), n = cw(n);
                        let o = dw(n);
                        n = o.pattern, r = o.kResetGroup;
                    }
                    break;
                }
            default:
                n = Jc(e), n = gw(n);
                break;
        }
        t.wholeWord && (n = `(?<![\\w])(?:${n})(?![\\w])`), t.lineRegexp && (n = `^${n}$`);
        let s = /\\u\{[0-9A-Fa-f]+\}/.test(n), i = "g" + (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.multilineDotall ? "s" : "") + (s ? "u" : "");
        return {
            regex: new RegExp(n, i),
            kResetGroup: r
        };
    }
    function aw(e) {
        let t = "", n = 0;
        for(; n < e.length;)if (e[n] === "\\" && n + 1 < e.length && e[n + 1] === "Q") {
            n += 2;
            let r = "";
            for(; n < e.length;){
                if (e[n] === "\\" && n + 1 < e.length && e[n + 1] === "E") {
                    n += 2;
                    break;
                }
                r += e[n], n++;
            }
            t += r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        } else t += e[n], n++;
        return t;
    }
    function lw(e) {
        return e.replace(/\\x\{([0-9A-Fa-f]+)\}/g, "\\u{$1}");
    }
    function cw(e) {
        let t = "", n = 0;
        for(; n < e.length;){
            if (e[n] === "(" && n + 1 < e.length && e[n + 1] === "?") {
                let r = e.slice(n).match(/^\(\?([imsx]*)(-[imsx]*)?(:|$|\))/);
                if (r) {
                    let s = r[1] || "";
                    r[2] || "";
                    let o = r[3];
                    if (o === ":") {
                        let a = n + r[0].length - 1, l = uw(e, n);
                        if (l !== -1) {
                            let c = e.slice(a + 1, l), u = fw(c, s);
                            t += `(?:${u})`, n = l + 1;
                            continue;
                        }
                    } else if (o === ")" || o === "") {
                        n += r[0].length;
                        continue;
                    }
                }
            }
            t += e[n], n++;
        }
        return t;
    }
    function uw(e, t) {
        let n = 0, r = t;
        for(; r < e.length;){
            if (e[r] === "\\") {
                r += 2;
                continue;
            }
            if (e[r] === "[") {
                for(r++; r < e.length && e[r] !== "]";)e[r] === "\\" && r++, r++;
                r++;
                continue;
            }
            if (e[r] === "(") n++;
            else if (e[r] === ")" && (n--, n === 0)) return r;
            r++;
        }
        return -1;
    }
    function fw(e, t, n) {
        let r = e;
        return t.includes("i") && (r = pw(r)), r;
    }
    function pw(e) {
        let t = "", n = 0;
        for(; n < e.length;){
            let r = e[n];
            if (r === "\\") {
                n + 1 < e.length ? (t += r + e[n + 1], n += 2) : (t += r, n++);
                continue;
            }
            if (r === "[") {
                t += r, n++, n < e.length && e[n] === "^" && (t += e[n], n++);
                let s = [];
                for(; n < e.length && e[n] !== "]";)if (e[n] === "\\") s.push(e[n]), n++, n < e.length && (s.push(e[n]), n++);
                else if (e[n] === "-" && s.length > 0 && n + 1 < e.length && e[n + 1] !== "]") {
                    let i = s[s.length - 1], o = e[n + 1];
                    s.push("-"), s.push(o), /[a-z]/.test(i) && /[a-z]/.test(o) ? (s.push(i.toUpperCase()), s.push("-"), s.push(o.toUpperCase())) : /[A-Z]/.test(i) && /[A-Z]/.test(o) && (s.push(i.toLowerCase()), s.push("-"), s.push(o.toLowerCase())), n += 2;
                } else {
                    let i = e[n];
                    if (s.push(i), /[a-zA-Z]/.test(i)) {
                        let o = i === i.toLowerCase() ? i.toUpperCase() : i.toLowerCase();
                        s.includes(o) || s.push(o);
                    }
                    n++;
                }
                t += s.join(""), n < e.length && (t += e[n], n++);
                continue;
            }
            if (/[a-zA-Z]/.test(r)) {
                let s = r.toLowerCase(), i = r.toUpperCase();
                t += `[${i}${s}]`;
            } else t += r;
            n++;
        }
        return t;
    }
    function dw(e) {
        let t = hw(e);
        if (t === -1) return {
            pattern: e
        };
        let n = e.slice(0, t), r = e.slice(t + 2), s = mw(n);
        return {
            pattern: `(?:${n})(${r})`,
            kResetGroup: s + 1
        };
    }
    function hw(e) {
        let t = 0;
        for(; t < e.length - 1;)if (e[t] === "\\") {
            if (e[t + 1] === "K") {
                let n = 0, r = t - 1;
                for(; r >= 0 && e[r] === "\\";)n++, r--;
                if (n % 2 === 0) return t;
            }
            t += 2;
        } else t++;
        return -1;
    }
    function mw(e) {
        let t = 0, n = 0;
        for(; n < e.length;){
            if (e[n] === "\\") {
                n += 2;
                continue;
            }
            if (e[n] === "[") {
                for(n++; n < e.length && e[n] !== "]";)e[n] === "\\" && n++, n++;
                n++;
                continue;
            }
            if (e[n] === "(") if (n + 1 < e.length && e[n + 1] === "?") {
                if (n + 2 < e.length) {
                    let r = e[n + 2];
                    if (r === ":" || r === "=" || r === "!") {
                        n++;
                        continue;
                    }
                    if (r === "<" && n + 3 < e.length) {
                        let s = e[n + 3];
                        if (s === "=" || s === "!") {
                            n++;
                            continue;
                        }
                        t++, n++;
                        continue;
                    }
                }
            } else t++;
            n++;
        }
        return t;
    }
    function Vi(e) {
        let t = e.replace(/\$\{0\}|\$0(?![0-9])/g, "$$&");
        return t = t.replace(/\$\{([^0-9}][^}]*)\}/g, "$$<$1>"), t = t.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)(?![>0-9])/g, "$$<$1>"), t;
    }
    function gw(e) {
        let t = "", n = 0, r = true;
        for(; n < e.length;){
            let i = e[n];
            if (i === "[") {
                for(t += i, n++, n < e.length && (e[n] === "^" || e[n] === "!") && (t += e[n], n++), n < e.length && e[n] === "]" && (t += e[n], n++); n < e.length && e[n] !== "]";)e[n] === "\\" && n + 1 < e.length ? (t += e[n] + e[n + 1], n += 2) : (t += e[n], n++);
                n < e.length && e[n] === "]" && (t += e[n], n++), r = false;
                continue;
            }
            if (i === "\\" && n + 1 < e.length) {
                let o = e[n + 1];
                if (o === "|") {
                    t += "|", n += 2, r = true;
                    continue;
                }
                if (o === "(") {
                    t += "(", n += 2, r = true;
                    continue;
                }
                if (o === ")") {
                    t += ")", n += 2, r = false;
                    continue;
                }
                if (o === "{") {
                    let l = e.slice(n).match(/^\\{(\d+)(,(\d*)?)?\\}/);
                    if (l) {
                        let c = l[1], u = l[2] !== void 0, f = l[3] || "";
                        u ? t += `{${c},${f}}` : t += `{${c}}`, n += l[0].length, r = false;
                        continue;
                    }
                    t += "\\{", n += 2, r = false;
                    continue;
                }
                if (o === "}") {
                    t += "\\}", n += 2, r = false;
                    continue;
                }
                t += i + o, n += 2, r = false;
                continue;
            }
            if (i === "*" && r) {
                t += "\\*", n++;
                continue;
            }
            if (i === "^") {
                if (r) {
                    t += "^", n++;
                    continue;
                }
                t += "\\^", n++;
                continue;
            }
            if (i === "$") {
                let o = n === e.length - 1, a = n + 2 < e.length && e[n + 1] === "\\" && e[n + 2] === ")";
                o || a ? t += "$" : t += "\\$", n++, r = false;
                continue;
            }
            i === "+" || i === "?" || i === "|" || i === "(" || i === ")" || i === "{" || i === "}" ? t += `\\${i}` : t += i, n++, r = false;
        }
        return t;
    }
    var ow, Yc = v(()=>{
        ow = {
            alpha: "a-zA-Z",
            digit: "0-9",
            alnum: "a-zA-Z0-9",
            lower: "a-z",
            upper: "A-Z",
            xdigit: "0-9A-Fa-f",
            space: " \\t\\n\\r\\f\\v",
            blank: " \\t",
            punct: "!-/:-@\\[-`{-~",
            graph: "!-~",
            print: " -~",
            cntrl: "\\x00-\\x1F\\x7F",
            ascii: "\\x00-\\x7F",
            word: "a-zA-Z0-9_"
        };
    });
    var qi = v(()=>{
        Xc();
        Yc();
    });
    var is = {};
    V(is, {
        egrepCommand: ()=>xw,
        fgrepCommand: ()=>ww,
        grepCommand: ()=>Gi
    });
    async function eu(e, t, n, r) {
        let s = n.fs.resolvePath(n.cwd, e);
        try {
            if (!(await n.fs.stat(s)).isDirectory) {
                let a = e.split("/").pop() || "";
                if (t) {
                    let l = t.replace(/^\//, "");
                    Ye(a, l, {
                        stripQuotes: true
                    }) && r.push(e);
                }
                return;
            }
            let o = await n.fs.readdir(s);
            for (let a of o){
                let l = e === "." ? a : `${e}/${a}`, c = n.fs.resolvePath(n.cwd, l);
                if ((await n.fs.stat(c)).isDirectory) await eu(l, t, n, r);
                else if (t) {
                    let f = t.replace(/^\//, "");
                    Ye(a, f, {
                        stripQuotes: true
                    }) && r.push(l);
                }
            }
        } catch  {}
    }
    async function bw(e, t) {
        let n = [], r = e.lastIndexOf("/"), s, i;
        if (r === -1 ? (s = t.cwd, i = e) : (s = e.slice(0, r) || "/", i = e.slice(r + 1)), e.includes("**")) {
            let a = [], l = e.split("**"), c = l[0].replace(/\/$/, "") || ".", u = l[1] || "";
            return await eu(c, u, t, a), a.map((f)=>({
                    path: f
                }));
        }
        let o = t.fs.resolvePath(t.cwd, s);
        try {
            if (t.fs.readdirWithFileTypes) {
                let a = await t.fs.readdirWithFileTypes(o);
                for (let l of a)if (Ye(l.name, i, {
                    stripQuotes: true
                })) {
                    let c = r === -1 ? l.name : `${s}/${l.name}`;
                    n.push({
                        path: c,
                        isFile: l.isFile
                    });
                }
            } else {
                let a = await t.fs.readdir(o);
                for (let l of a)if (Ye(l, i, {
                    stripQuotes: true
                })) {
                    let c = r === -1 ? l : `${s}/${l}`;
                    n.push({
                        path: c
                    });
                }
            }
        } catch  {}
        return n.sort((a, l)=>a.path.localeCompare(l.path));
    }
    async function ss(e, t, n = [], r = [], s = [], i) {
        let o = t.fs.resolvePath(t.cwd, e), a = [];
        try {
            let l, c;
            if (i !== void 0) l = i, c = !i;
            else {
                let f = await t.fs.stat(o);
                l = f.isFile, c = f.isDirectory;
            }
            if (l) {
                let f = e.split("/").pop() || e;
                return r.length > 0 && r.some((p)=>Ye(f, p, {
                        stripQuotes: true
                    })) ? [] : n.length > 0 && !n.some((p)=>Ye(f, p, {
                        stripQuotes: true
                    })) ? [] : [
                    {
                        path: e,
                        isFile: true
                    }
                ];
            }
            if (!c) return [];
            let u = e.split("/").pop() || e;
            if (s.length > 0 && s.some((f)=>Ye(u, f, {
                    stripQuotes: true
                }))) return [];
            if (t.fs.readdirWithFileTypes) {
                let f = await t.fs.readdirWithFileTypes(o);
                for (let p of f){
                    if (p.name.startsWith(".")) continue;
                    let d = e === "." ? p.name : `${e}/${p.name}`, m = await ss(d, t, n, r, s, p.isFile);
                    a.push(...m);
                }
            } else {
                let f = await t.fs.readdir(o);
                for (let p of f){
                    if (p.startsWith(".")) continue;
                    let d = e === "." ? p : `${e}/${p}`, m = await ss(d, t, n, r, s);
                    a.push(...m);
                }
            }
        } catch  {}
        return a;
    }
    var yw, Gi, ww, xw, os = v(()=>{
        Hi();
        X();
        qi();
        yw = {
            name: "grep",
            summary: "print lines that match patterns",
            usage: "grep [OPTION]... PATTERN [FILE]...",
            options: [
                "-E, --extended-regexp    PATTERN is an extended regular expression",
                "-P, --perl-regexp        PATTERN is a Perl regular expression",
                "-F, --fixed-strings      PATTERN is a set of newline-separated strings",
                "-i, --ignore-case        ignore case distinctions",
                "-v, --invert-match       select non-matching lines",
                "-w, --word-regexp        match only whole words",
                "-x, --line-regexp        match only whole lines",
                "-c, --count              print only a count of matching lines",
                "-l, --files-with-matches print only names of files with matches",
                "-L, --files-without-match print names of files with no matches",
                "-m NUM, --max-count=NUM  stop after NUM matches",
                "-n, --line-number        print line number with output lines",
                "-h, --no-filename        suppress the file name prefix on output",
                "-o, --only-matching      show only nonempty parts of lines that match",
                "-q, --quiet, --silent    suppress all normal output",
                "-r, -R, --recursive      search directories recursively",
                "-A NUM                   print NUM lines of trailing context",
                "-B NUM                   print NUM lines of leading context",
                "-C NUM                   print NUM lines of context",
                "-e PATTERN               use PATTERN for matching",
                "    --include=GLOB       search only files matching GLOB",
                "    --exclude=GLOB       skip files matching GLOB",
                "    --exclude-dir=DIR    skip directories matching DIR",
                "    --help               display this help and exit"
            ]
        }, Gi = {
            name: "grep",
            async execute (e, t) {
                if (_(e)) return F(yw);
                let n = false, r = false, s = false, i = false, o = false, a = false, l = false, c = false, u = false, f = false, p = false, d = false, m = false, h = false, g = false, b = 0, y = 0, w = 0, E = [], C = [], A = [], I = null, O = [];
                for(let B = 0; B < e.length; B++){
                    let q = e[B];
                    if (q.startsWith("-") && q !== "-") {
                        if (q === "-e" && B + 1 < e.length) {
                            I = e[++B];
                            continue;
                        }
                        if (q.startsWith("--include=")) {
                            E.push(q.slice(10));
                            continue;
                        }
                        if (q.startsWith("--exclude=")) {
                            C.push(q.slice(10));
                            continue;
                        }
                        if (q.startsWith("--exclude-dir=")) {
                            A.push(q.slice(14));
                            continue;
                        }
                        if (q.startsWith("--max-count=")) {
                            b = parseInt(q.slice(12), 10);
                            continue;
                        }
                        let be = q.match(/^-m(\d+)$/);
                        if (be) {
                            b = parseInt(be[1], 10);
                            continue;
                        }
                        if (q === "-m" && B + 1 < e.length) {
                            b = parseInt(e[++B], 10);
                            continue;
                        }
                        let ee = q.match(/^-([ABC])(\d+)$/);
                        if (ee) {
                            let U = parseInt(ee[2], 10);
                            ee[1] === "A" ? w = U : ee[1] === "B" ? y = U : ee[1] === "C" && (y = U, w = U);
                            continue;
                        }
                        if ((q === "-A" || q === "-B" || q === "-C") && B + 1 < e.length) {
                            let U = parseInt(e[++B], 10);
                            q === "-A" ? w = U : q === "-B" ? y = U : (y = U, w = U);
                            continue;
                        }
                        let ge = q.startsWith("--") ? [
                            q
                        ] : q.slice(1).split("");
                        for (let U of ge)if (U === "i" || U === "--ignore-case") n = true;
                        else if (U === "n" || U === "--line-number") r = true;
                        else if (U === "v" || U === "--invert-match") s = true;
                        else if (U === "c" || U === "--count") i = true;
                        else if (U === "l" || U === "--files-with-matches") o = true;
                        else if (U === "L" || U === "--files-without-match") a = true;
                        else if (U === "r" || U === "R" || U === "--recursive") l = true;
                        else if (U === "w" || U === "--word-regexp") c = true;
                        else if (U === "x" || U === "--line-regexp") u = true;
                        else if (U === "E" || U === "--extended-regexp") f = true;
                        else if (U === "P" || U === "--perl-regexp") p = true;
                        else if (U === "F" || U === "--fixed-strings") d = true;
                        else if (U === "o" || U === "--only-matching") m = true;
                        else if (U === "h" || U === "--no-filename") h = true;
                        else if (U === "q" || U === "--quiet" || U === "--silent") g = true;
                        else {
                            if (U.startsWith("--")) return G("grep", U);
                            if (U.length === 1) return G("grep", `-${U}`);
                        }
                    } else I === null ? I = q : O.push(q);
                }
                if (I === null) return {
                    stdout: "",
                    stderr: `grep: missing pattern
`,
                    exitCode: 2
                };
                let L = d ? "fixed" : f ? "extended" : p ? "perl" : "basic", D, $;
                try {
                    let B = hr(I, {
                        mode: L,
                        ignoreCase: n,
                        wholeWord: c,
                        lineRegexp: u
                    });
                    D = B.regex, $ = B.kResetGroup;
                } catch  {
                    return {
                        stdout: "",
                        stderr: `grep: invalid regular expression: ${I}
`,
                        exitCode: 2
                    };
                }
                if (O.length === 0 && t.stdin !== void 0) {
                    let B = Dn(t.stdin, D, {
                        invertMatch: s,
                        showLineNumbers: r,
                        countOnly: i,
                        filename: "",
                        onlyMatching: m,
                        beforeContext: y,
                        afterContext: w,
                        maxCount: b,
                        kResetGroup: $
                    });
                    return g ? {
                        stdout: "",
                        stderr: "",
                        exitCode: B.matched ? 0 : 1
                    } : {
                        stdout: B.output,
                        stderr: "",
                        exitCode: B.matched ? 0 : 1
                    };
                }
                if (O.length === 0) return {
                    stdout: "",
                    stderr: `grep: no input files
`,
                    exitCode: 2
                };
                let N = "", P = "", k = false, R = false, T = [];
                for (let B of O)if (B.includes("*") || B.includes("?") || B.includes("[")) {
                    let q = await bw(B, t);
                    if (l) for (let be of q){
                        let ee = await ss(be.path, t, E, C, A, be.isFile);
                        T.push(...ee);
                    }
                    else T.push(...q);
                } else if (l) {
                    let q = await ss(B, t, E, C, A);
                    T.push(...q);
                } else T.push({
                    path: B
                });
                let Y = (T.length > 1 || l) && !h, ie = 50;
                for(let B = 0; B < T.length; B += ie){
                    let q = T.slice(B, B + ie), be = await Promise.all(q.map(async (ee)=>{
                        let ge = ee.path, U = ge.split("/").pop() || ge;
                        if (C.length > 0 && !l && C.some((ye)=>Ye(U, ye, {
                                stripQuotes: true
                            })) || E.length > 0 && !l && !E.some((ye)=>Ye(U, ye, {
                                stripQuotes: true
                            }))) return null;
                        try {
                            let ye = t.fs.resolvePath(t.cwd, ge), Ce = false;
                            if (ee.isFile === void 0 ? Ce = (await t.fs.stat(ye)).isDirectory : Ce = !ee.isFile, Ce) return l ? null : {
                                error: `grep: ${ge}: Is a directory
`
                            };
                            let Re = await t.fs.readFile(ye), Me = Dn(Re, D, {
                                invertMatch: s,
                                showLineNumbers: r,
                                countOnly: i,
                                filename: Y ? ge : "",
                                onlyMatching: m,
                                beforeContext: y,
                                afterContext: w,
                                maxCount: b,
                                kResetGroup: $
                            });
                            return {
                                file: ge,
                                result: Me
                            };
                        } catch  {
                            return {
                                error: `grep: ${ge}: No such file or directory
`
                            };
                        }
                    }));
                    for (let ee of be){
                        if (ee === null) continue;
                        if ("error" in ee && ee.error) {
                            P += ee.error, ee.error.includes("Is a directory") || (R = true);
                            continue;
                        }
                        if (!("file" in ee) || !ee.result) continue;
                        let { file: ge, result: U } = ee;
                        if (U.matched) {
                            if (k = true, g) return {
                                stdout: "",
                                stderr: "",
                                exitCode: 0
                            };
                            o ? N += `${ge}
` : a || (N += U.output);
                        } else a ? N += `${ge}
` : i && !o && (N += U.output);
                    }
                }
                let K;
                return R ? K = 2 : a ? K = N.length > 0 ? 0 : 1 : K = k ? 0 : 1, g ? {
                    stdout: "",
                    stderr: "",
                    exitCode: K
                } : {
                    stdout: N,
                    stderr: P,
                    exitCode: K
                };
            }
        };
        ww = {
            name: "fgrep",
            async execute (e, t) {
                return Gi.execute([
                    "-F",
                    ...e
                ], t);
            }
        }, xw = {
            name: "egrep",
            async execute (e, t) {
                return Gi.execute([
                    "-E",
                    ...e
                ], t);
            }
        };
    });
    function nu() {
        let e = [];
        for (let [t, n] of Object.entries(tu).sort()){
            let r = [];
            for (let s of n.extensions)r.push(`*${s}`);
            for (let s of n.globs)r.push(s);
            e.push(`${t}: ${r.join(", ")}`);
        }
        return `${e.join(`
`)}
`;
    }
    var tu, mr, Zi = v(()=>{
        tu = {
            js: {
                extensions: [
                    ".js",
                    ".mjs",
                    ".cjs",
                    ".jsx"
                ],
                globs: []
            },
            ts: {
                extensions: [
                    ".ts",
                    ".tsx",
                    ".mts",
                    ".cts"
                ],
                globs: []
            },
            html: {
                extensions: [
                    ".html",
                    ".htm",
                    ".xhtml"
                ],
                globs: []
            },
            css: {
                extensions: [
                    ".css",
                    ".scss",
                    ".sass",
                    ".less"
                ],
                globs: []
            },
            json: {
                extensions: [
                    ".json",
                    ".jsonc",
                    ".json5"
                ],
                globs: []
            },
            xml: {
                extensions: [
                    ".xml",
                    ".xsl",
                    ".xslt"
                ],
                globs: []
            },
            c: {
                extensions: [
                    ".c",
                    ".h"
                ],
                globs: []
            },
            cpp: {
                extensions: [
                    ".cpp",
                    ".cc",
                    ".cxx",
                    ".hpp",
                    ".hh",
                    ".hxx",
                    ".h"
                ],
                globs: []
            },
            rust: {
                extensions: [
                    ".rs"
                ],
                globs: []
            },
            go: {
                extensions: [
                    ".go"
                ],
                globs: []
            },
            zig: {
                extensions: [
                    ".zig"
                ],
                globs: []
            },
            java: {
                extensions: [
                    ".java"
                ],
                globs: []
            },
            kotlin: {
                extensions: [
                    ".kt",
                    ".kts"
                ],
                globs: []
            },
            scala: {
                extensions: [
                    ".scala",
                    ".sc"
                ],
                globs: []
            },
            clojure: {
                extensions: [
                    ".clj",
                    ".cljc",
                    ".cljs",
                    ".edn"
                ],
                globs: []
            },
            py: {
                extensions: [
                    ".py",
                    ".pyi",
                    ".pyw"
                ],
                globs: []
            },
            rb: {
                extensions: [
                    ".rb",
                    ".rake",
                    ".gemspec"
                ],
                globs: [
                    "Rakefile",
                    "Gemfile"
                ]
            },
            php: {
                extensions: [
                    ".php",
                    ".phtml",
                    ".php3",
                    ".php4",
                    ".php5"
                ],
                globs: []
            },
            perl: {
                extensions: [
                    ".pl",
                    ".pm",
                    ".pod",
                    ".t"
                ],
                globs: []
            },
            lua: {
                extensions: [
                    ".lua"
                ],
                globs: []
            },
            sh: {
                extensions: [
                    ".sh",
                    ".bash",
                    ".zsh",
                    ".fish"
                ],
                globs: [
                    ".bashrc",
                    ".zshrc",
                    ".profile"
                ]
            },
            bat: {
                extensions: [
                    ".bat",
                    ".cmd"
                ],
                globs: []
            },
            ps: {
                extensions: [
                    ".ps1",
                    ".psm1",
                    ".psd1"
                ],
                globs: []
            },
            yaml: {
                extensions: [
                    ".yaml",
                    ".yml"
                ],
                globs: []
            },
            toml: {
                extensions: [
                    ".toml"
                ],
                globs: [
                    "Cargo.toml",
                    "pyproject.toml"
                ]
            },
            ini: {
                extensions: [
                    ".ini",
                    ".cfg",
                    ".conf"
                ],
                globs: []
            },
            csv: {
                extensions: [
                    ".csv",
                    ".tsv"
                ],
                globs: []
            },
            md: {
                extensions: [
                    ".md",
                    ".mdx",
                    ".markdown",
                    ".mdown",
                    ".mkd"
                ],
                globs: []
            },
            markdown: {
                extensions: [
                    ".md",
                    ".mdx",
                    ".markdown",
                    ".mdown",
                    ".mkd"
                ],
                globs: []
            },
            rst: {
                extensions: [
                    ".rst"
                ],
                globs: []
            },
            txt: {
                extensions: [
                    ".txt",
                    ".text"
                ],
                globs: []
            },
            tex: {
                extensions: [
                    ".tex",
                    ".ltx",
                    ".sty",
                    ".cls"
                ],
                globs: []
            },
            sql: {
                extensions: [
                    ".sql"
                ],
                globs: []
            },
            graphql: {
                extensions: [
                    ".graphql",
                    ".gql"
                ],
                globs: []
            },
            proto: {
                extensions: [
                    ".proto"
                ],
                globs: []
            },
            make: {
                extensions: [
                    ".mk",
                    ".mak"
                ],
                globs: [
                    "Makefile",
                    "GNUmakefile",
                    "makefile"
                ]
            },
            docker: {
                extensions: [],
                globs: [
                    "Dockerfile",
                    "Dockerfile.*",
                    "*.dockerfile"
                ]
            },
            tf: {
                extensions: [
                    ".tf",
                    ".tfvars"
                ],
                globs: []
            }
        }, mr = class {
            types;
            constructor(){
                this.types = new Map(Object.entries(tu).map(([t, n])=>[
                        t,
                        {
                            extensions: [
                                ...n.extensions
                            ],
                            globs: [
                                ...n.globs
                            ]
                        }
                    ]));
            }
            addType(t) {
                let n = t.indexOf(":");
                if (n === -1) return;
                let r = t.slice(0, n), s = t.slice(n + 1);
                if (s.startsWith("include:")) {
                    let i = s.slice(8), o = this.types.get(i);
                    if (o) {
                        let a = this.types.get(r) || {
                            extensions: [],
                            globs: []
                        };
                        a.extensions.push(...o.extensions), a.globs.push(...o.globs), this.types.set(r, a);
                    }
                } else {
                    let i = this.types.get(r) || {
                        extensions: [],
                        globs: []
                    };
                    if (s.startsWith("*.") && !s.slice(2).includes("*")) {
                        let o = s.slice(1);
                        i.extensions.includes(o) || i.extensions.push(o);
                    } else i.globs.includes(s) || i.globs.push(s);
                    this.types.set(r, i);
                }
            }
            clearType(t) {
                let n = this.types.get(t);
                n && (n.extensions = [], n.globs = []);
            }
            getType(t) {
                return this.types.get(t);
            }
            getAllTypes() {
                return this.types;
            }
            matchesType(t, n) {
                let r = t.toLowerCase();
                for (let s of n){
                    if (s === "all") {
                        if (this.matchesAnyType(t)) return true;
                        continue;
                    }
                    let i = this.types.get(s);
                    if (i) {
                        for (let o of i.extensions)if (r.endsWith(o)) return true;
                        for (let o of i.globs)if (o.includes("*")) {
                            let a = o.replace(/\./g, "\\.").replace(/\*/g, ".*");
                            if (new RegExp(`^${a}$`, "i").test(t)) return true;
                        } else if (r === o.toLowerCase()) return true;
                    }
                }
                return false;
            }
            matchesAnyType(t) {
                let n = t.toLowerCase();
                for (let r of this.types.values()){
                    for (let s of r.extensions)if (n.endsWith(s)) return true;
                    for (let s of r.globs)if (s.includes("*")) {
                        let i = s.replace(/\./g, "\\.").replace(/\*/g, ".*");
                        if (new RegExp(`^${i}$`, "i").test(t)) return true;
                    } else if (n === s.toLowerCase()) return true;
                }
                return false;
            }
        };
    });
    function ru() {
        return {
            ignoreCase: false,
            caseSensitive: false,
            smartCase: true,
            fixedStrings: false,
            wordRegexp: false,
            lineRegexp: false,
            invertMatch: false,
            multiline: false,
            multilineDotall: false,
            patterns: [],
            patternFiles: [],
            count: false,
            countMatches: false,
            files: false,
            filesWithMatches: false,
            filesWithoutMatch: false,
            stats: false,
            onlyMatching: false,
            maxCount: 0,
            lineNumber: true,
            noFilename: false,
            withFilename: false,
            nullSeparator: false,
            byteOffset: false,
            column: false,
            vimgrep: false,
            replace: null,
            afterContext: 0,
            beforeContext: 0,
            contextSeparator: "--",
            quiet: false,
            heading: false,
            passthru: false,
            includeZero: false,
            sort: "path",
            json: false,
            globs: [],
            iglobs: [],
            globCaseInsensitive: false,
            types: [],
            typesNot: [],
            typeAdd: [],
            typeClear: [],
            hidden: false,
            noIgnore: false,
            noIgnoreDot: false,
            noIgnoreVcs: false,
            ignoreFiles: [],
            maxDepth: 1 / 0,
            maxFilesize: 0,
            followSymlinks: false,
            searchZip: false,
            searchBinary: false,
            preprocessor: null,
            preprocessorGlobs: []
        };
    }
    var su = v(()=>{});
    function Ew(e) {
        let t = e.match(/^(\d+)([KMG])?$/i);
        if (!t) return 0;
        let n = parseInt(t[1], 10);
        switch((t[2] || "").toUpperCase()){
            case "K":
                return n * 1024;
            case "M":
                return n * 1024 * 1024;
            case "G":
                return n * 1024 * 1024 * 1024;
            default:
                return n;
        }
    }
    function Sw(e) {
        return /^\d+[KMG]?$/i.test(e) ? null : {
            stdout: "",
            stderr: `rg: invalid --max-filesize value: ${e}
`,
            exitCode: 1
        };
    }
    function iu(e) {
        return null;
    }
    function Nw(e) {
        e.hidden ? e.searchBinary = true : e.noIgnore ? e.hidden = true : e.noIgnore = true;
    }
    function kw(e, t, n) {
        let r = e[t];
        for (let s of ou){
            if (r.startsWith(`--${s.long}=`)) {
                let i = r.slice(`--${s.long}=`.length), o = as(n, s, i);
                return o ? {
                    newIndex: t,
                    error: o
                } : {
                    newIndex: t
                };
            }
            if (s.short && r.startsWith(`-${s.short}`) && r.length > 2) {
                let i = r.slice(2), o = as(n, s, i);
                return o ? {
                    newIndex: t,
                    error: o
                } : {
                    newIndex: t
                };
            }
            if (s.short && r === `-${s.short}` || r === `--${s.long}`) {
                if (t + 1 >= e.length) return null;
                let i = e[t + 1], o = as(n, s, i);
                return o ? {
                    newIndex: t + 1,
                    error: o
                } : {
                    newIndex: t + 1
                };
            }
        }
        return null;
    }
    function vw(e) {
        return ou.find((t)=>t.short === e);
    }
    function as(e, t, n) {
        if (t.validate) {
            let s = t.validate(n);
            if (s) return s;
        }
        let r = t.parse ? t.parse(n) : n;
        t.multi ? e[t.target].push(r) : e[t.target] = r;
    }
    function $w(e, t) {
        let n = e[t];
        if (n === "--sort" && t + 1 < e.length) {
            let r = e[t + 1];
            if (r === "path" || r === "none") return {
                value: r,
                newIndex: t + 1
            };
        }
        if (n.startsWith("--sort=")) {
            let r = n.slice(7);
            if (r === "path" || r === "none") return {
                value: r,
                newIndex: t
            };
        }
        return null;
    }
    function Iw(e, t) {
        let n = e[t], r = n.match(/^-([ABC])(\d+)$/);
        return r ? {
            flag: r[1],
            value: parseInt(r[2], 10),
            newIndex: t
        } : (n === "-A" || n === "-B" || n === "-C") && t + 1 < e.length ? {
            flag: n[1],
            value: parseInt(e[t + 1], 10),
            newIndex: t + 1
        } : null;
    }
    function Rw(e) {
        let t = e.match(/^-m(\d+)$/);
        return t ? parseInt(t[1], 10) : null;
    }
    function au(e) {
        let t = ru(), n = null, r = [], s = -1, i = -1, o = -1, a = false;
        for(let l = 0; l < e.length; l++){
            let c = e[l];
            if (c.startsWith("-") && c !== "-") {
                let u = Iw(e, l);
                if (u) {
                    let { flag: g, value: b, newIndex: y } = u;
                    g === "A" ? s = Math.max(s, b) : g === "B" ? i = Math.max(i, b) : o = b, l = y;
                    continue;
                }
                let f = Rw(c);
                if (f !== null) {
                    t.maxCount = f;
                    continue;
                }
                let p = kw(e, l, t);
                if (p) {
                    if (p.error) return {
                        success: false,
                        error: p.error
                    };
                    l = p.newIndex;
                    continue;
                }
                let d = $w(e, l);
                if (d) {
                    t.sort = d.value, l = d.newIndex;
                    continue;
                }
                let m = c.startsWith("--") ? [
                    c
                ] : c.slice(1).split("");
                for (let g of m){
                    if (Cw.has(g)) {
                        t.lineNumber = true, a = true;
                        continue;
                    }
                    if (g === "u" || g === "--unrestricted") {
                        Nw(t);
                        continue;
                    }
                    if (g === "P" || g === "--pcre2") return {
                        success: false,
                        error: {
                            stdout: "",
                            stderr: `rg: PCRE2 is not supported. Use standard regex syntax instead.
`,
                            exitCode: 1
                        }
                    };
                    if (g.length === 1) {
                        let y = vw(g);
                        if (y) {
                            if (l + 1 >= e.length) return {
                                success: false,
                                error: G("rg", `-${g}`)
                            };
                            let w = as(t, y, e[l + 1]);
                            if (w) return {
                                success: false,
                                error: w
                            };
                            l++;
                            continue;
                        }
                    }
                    let b = Aw[g];
                    if (b) {
                        b(t);
                        continue;
                    }
                    if (g.startsWith("--")) return {
                        success: false,
                        error: G("rg", g)
                    };
                    if (g.length === 1) return {
                        success: false,
                        error: G("rg", `-${g}`)
                    };
                }
            } else n === null && t.patterns.length === 0 && t.patternFiles.length === 0 ? n = c : r.push(c);
        }
        return (s >= 0 || o >= 0) && (t.afterContext = Math.max(s >= 0 ? s : 0, o >= 0 ? o : 0)), (i >= 0 || o >= 0) && (t.beforeContext = Math.max(i >= 0 ? i : 0, o >= 0 ? o : 0)), n !== null && t.patterns.push(n), (t.column || t.vimgrep) && (a = true), {
            success: true,
            options: t,
            paths: r,
            explicitLineNumbers: a
        };
    }
    var ou, Aw, Cw, lu = v(()=>{
        X();
        su();
        ou = [
            {
                short: "g",
                long: "glob",
                target: "globs",
                multi: true
            },
            {
                long: "iglob",
                target: "iglobs",
                multi: true
            },
            {
                short: "t",
                long: "type",
                target: "types",
                multi: true,
                validate: iu
            },
            {
                short: "T",
                long: "type-not",
                target: "typesNot",
                multi: true,
                validate: iu
            },
            {
                long: "type-add",
                target: "typeAdd",
                multi: true
            },
            {
                long: "type-clear",
                target: "typeClear",
                multi: true
            },
            {
                short: "m",
                long: "max-count",
                target: "maxCount",
                parse: parseInt
            },
            {
                short: "e",
                long: "regexp",
                target: "patterns",
                multi: true
            },
            {
                short: "f",
                long: "file",
                target: "patternFiles",
                multi: true
            },
            {
                short: "r",
                long: "replace",
                target: "replace"
            },
            {
                short: "d",
                long: "max-depth",
                target: "maxDepth",
                parse: parseInt
            },
            {
                long: "max-filesize",
                target: "maxFilesize",
                parse: Ew,
                validate: Sw
            },
            {
                long: "context-separator",
                target: "contextSeparator"
            },
            {
                short: "j",
                long: "threads",
                target: "maxDepth",
                parse: ()=>1 / 0
            },
            {
                long: "ignore-file",
                target: "ignoreFiles",
                multi: true
            },
            {
                long: "pre",
                target: "preprocessor"
            },
            {
                long: "pre-glob",
                target: "preprocessorGlobs",
                multi: true
            }
        ], Aw = {
            i: (e)=>{
                e.ignoreCase = true, e.caseSensitive = false, e.smartCase = false;
            },
            "--ignore-case": (e)=>{
                e.ignoreCase = true, e.caseSensitive = false, e.smartCase = false;
            },
            s: (e)=>{
                e.caseSensitive = true, e.ignoreCase = false, e.smartCase = false;
            },
            "--case-sensitive": (e)=>{
                e.caseSensitive = true, e.ignoreCase = false, e.smartCase = false;
            },
            S: (e)=>{
                e.smartCase = true, e.ignoreCase = false, e.caseSensitive = false;
            },
            "--smart-case": (e)=>{
                e.smartCase = true, e.ignoreCase = false, e.caseSensitive = false;
            },
            F: (e)=>{
                e.fixedStrings = true;
            },
            "--fixed-strings": (e)=>{
                e.fixedStrings = true;
            },
            w: (e)=>{
                e.wordRegexp = true;
            },
            "--word-regexp": (e)=>{
                e.wordRegexp = true;
            },
            x: (e)=>{
                e.lineRegexp = true;
            },
            "--line-regexp": (e)=>{
                e.lineRegexp = true;
            },
            v: (e)=>{
                e.invertMatch = true;
            },
            "--invert-match": (e)=>{
                e.invertMatch = true;
            },
            U: (e)=>{
                e.multiline = true;
            },
            "--multiline": (e)=>{
                e.multiline = true;
            },
            "--multiline-dotall": (e)=>{
                e.multilineDotall = true, e.multiline = true;
            },
            c: (e)=>{
                e.count = true;
            },
            "--count": (e)=>{
                e.count = true;
            },
            "--count-matches": (e)=>{
                e.countMatches = true;
            },
            l: (e)=>{
                e.filesWithMatches = true;
            },
            "--files": (e)=>{
                e.files = true;
            },
            "--files-with-matches": (e)=>{
                e.filesWithMatches = true;
            },
            "--files-without-match": (e)=>{
                e.filesWithoutMatch = true;
            },
            "--stats": (e)=>{
                e.stats = true;
            },
            o: (e)=>{
                e.onlyMatching = true;
            },
            "--only-matching": (e)=>{
                e.onlyMatching = true;
            },
            q: (e)=>{
                e.quiet = true;
            },
            "--quiet": (e)=>{
                e.quiet = true;
            },
            N: (e)=>{
                e.lineNumber = false;
            },
            "--no-line-number": (e)=>{
                e.lineNumber = false;
            },
            H: (e)=>{
                e.withFilename = true;
            },
            "--with-filename": (e)=>{
                e.withFilename = true;
            },
            I: (e)=>{
                e.noFilename = true;
            },
            "--no-filename": (e)=>{
                e.noFilename = true;
            },
            0: (e)=>{
                e.nullSeparator = true;
            },
            "--null": (e)=>{
                e.nullSeparator = true;
            },
            b: (e)=>{
                e.byteOffset = true;
            },
            "--byte-offset": (e)=>{
                e.byteOffset = true;
            },
            "--column": (e)=>{
                e.column = true, e.lineNumber = true;
            },
            "--no-column": (e)=>{
                e.column = false;
            },
            "--vimgrep": (e)=>{
                e.vimgrep = true, e.column = true, e.lineNumber = true;
            },
            "--json": (e)=>{
                e.json = true;
            },
            "--hidden": (e)=>{
                e.hidden = true;
            },
            "--no-ignore": (e)=>{
                e.noIgnore = true;
            },
            "--no-ignore-dot": (e)=>{
                e.noIgnoreDot = true;
            },
            "--no-ignore-vcs": (e)=>{
                e.noIgnoreVcs = true;
            },
            L: (e)=>{
                e.followSymlinks = true;
            },
            "--follow": (e)=>{
                e.followSymlinks = true;
            },
            z: (e)=>{
                e.searchZip = true;
            },
            "--search-zip": (e)=>{
                e.searchZip = true;
            },
            a: (e)=>{
                e.searchBinary = true;
            },
            "--text": (e)=>{
                e.searchBinary = true;
            },
            "--heading": (e)=>{
                e.heading = true;
            },
            "--passthru": (e)=>{
                e.passthru = true;
            },
            "--include-zero": (e)=>{
                e.includeZero = true;
            },
            "--glob-case-insensitive": (e)=>{
                e.globCaseInsensitive = true;
            }
        }, Cw = new Set([
            "n",
            "--line-number"
        ]);
    });
    async function Qi(e, t, n = false, r = false, s = []) {
        let i = new yr(e, t, n, r);
        await i.load(t);
        for (let o of s)try {
            let a = e.resolvePath(t, o), l = await e.readFile(a);
            i.addPatternsFromContent(l, t);
        } catch  {}
        return i;
    }
    var gr, yr, cu = v(()=>{
        gr = class {
            patterns = [];
            basePath;
            constructor(t = "/"){
                this.basePath = t;
            }
            parse(t) {
                let n = t.split(`
`);
                for (let r of n){
                    let s = r.replace(/\s+$/, "");
                    if (!s || s.startsWith("#")) continue;
                    let i = false;
                    s.startsWith("!") && (i = true, s = s.slice(1));
                    let o = false;
                    s.endsWith("/") && (o = true, s = s.slice(0, -1));
                    let a = false;
                    s.startsWith("/") ? (a = true, s = s.slice(1)) : s.includes("/") && !s.startsWith("**/") && (a = true);
                    let l = this.patternToRegex(s, a);
                    this.patterns.push({
                        pattern: r,
                        regex: l,
                        negated: i,
                        directoryOnly: o,
                        rooted: a
                    });
                }
            }
            patternToRegex(t, n) {
                let r = "";
                n ? r = "^" : r = "(?:^|/)";
                let s = 0;
                for(; s < t.length;){
                    let i = t[s];
                    if (i === "*") t[s + 1] === "*" ? t[s + 2] === "/" ? (r += "(?:.*/)?", s += 3) : (s + 2 >= t.length, r += ".*", s += 2) : (r += "[^/]*", s++);
                    else if (i === "?") r += "[^/]", s++;
                    else if (i === "[") {
                        let o = s + 1;
                        for(o < t.length && t[o] === "!" && o++, o < t.length && t[o] === "]" && o++; o < t.length && t[o] !== "]";)o++;
                        if (o < t.length) {
                            let a = t.slice(s, o + 1);
                            a.startsWith("[!") && (a = `[^${a.slice(2)}`), r += a, s = o + 1;
                        } else r += "\\[", s++;
                    } else i === "/" ? (r += "/", s++) : (r += i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), s++);
                }
                return r += "(?:/.*)?$", new RegExp(r);
            }
            matches(t, n) {
                let r = t.replace(/^\.\//, "");
                r = r.replace(/^\//, "");
                let s = false;
                for (let i of this.patterns)i.directoryOnly && !n || i.regex.test(r) && (s = !i.negated);
                return s;
            }
            isWhitelisted(t, n) {
                let r = t.replace(/^\.\//, "");
                r = r.replace(/^\//, "");
                for (let s of this.patterns)if (!(s.directoryOnly && !n) && s.negated && s.regex.test(r)) return true;
                return false;
            }
            getBasePath() {
                return this.basePath;
            }
        }, yr = class {
            parsers = [];
            fs;
            skipDotIgnore;
            skipVcsIgnore;
            loadedDirs = new Set();
            constructor(t, n, r = false, s = false){
                this.fs = t, this.skipDotIgnore = r, this.skipVcsIgnore = s;
            }
            async load(t) {
                let n = [], r = t;
                for(;;){
                    n.unshift(r);
                    let i = this.fs.resolvePath(r, "..");
                    if (i === r) break;
                    r = i;
                }
                let s = [];
                this.skipVcsIgnore || s.push(".gitignore"), this.skipDotIgnore || s.push(".rgignore", ".ignore");
                for (let i of n){
                    this.loadedDirs.add(i);
                    for (let o of s){
                        let a = this.fs.resolvePath(i, o);
                        try {
                            let l = await this.fs.readFile(a), c = new gr(i);
                            c.parse(l), this.parsers.push(c);
                        } catch  {}
                    }
                }
            }
            async loadForDirectory(t) {
                if (this.loadedDirs.has(t)) return;
                this.loadedDirs.add(t);
                let n = [];
                this.skipVcsIgnore || n.push(".gitignore"), this.skipDotIgnore || n.push(".rgignore", ".ignore");
                for (let r of n){
                    let s = this.fs.resolvePath(t, r);
                    try {
                        let i = await this.fs.readFile(s), o = new gr(t);
                        o.parse(i), this.parsers.push(o);
                    } catch  {}
                }
            }
            addPatternsFromContent(t, n) {
                let r = new gr(n);
                r.parse(t), this.parsers.push(r);
            }
            matches(t, n) {
                for (let r of this.parsers){
                    let s = r.getBasePath();
                    if (!t.startsWith(s)) continue;
                    let i = t.slice(s.length).replace(/^\//, "");
                    if (r.matches(i, n)) return true;
                }
                return false;
            }
            isWhitelisted(t, n) {
                for (let r of this.parsers){
                    let s = r.getBasePath();
                    if (!t.startsWith(s)) continue;
                    let i = t.slice(s.length).replace(/^\//, "");
                    if (r.isWhitelisted(i, n)) return true;
                }
                return false;
            }
            static isCommonIgnored(t) {
                return (new Set([
                    "node_modules",
                    ".git",
                    ".svn",
                    ".hg",
                    "__pycache__",
                    ".pytest_cache",
                    ".mypy_cache",
                    "venv",
                    ".venv",
                    ".next",
                    ".nuxt",
                    ".cargo"
                ])).has(t);
            }
        };
    });
    function Tw(e) {
        return e.length >= 2 && e[0] === 31 && e[1] === 139;
    }
    function Ow(e) {
        let t = false;
        for(let n = 0; n < e.length; n++){
            let r = e[n];
            r === "[" && !t ? t = true : r === "]" && t && (t = false);
        }
        return t ? `rg: glob '${e}' has an unclosed character class` : null;
    }
    async function uu(e) {
        let { ctx: t, options: n, paths: r, explicitLineNumbers: s } = e;
        for (let g of n.globs){
            let b = g.startsWith("!") ? g.slice(1) : g, y = Ow(b);
            if (y) return {
                stdout: "",
                stderr: `${y}
`,
                exitCode: 1
            };
        }
        if (n.files) {
            let g = [
                ...n.patterns,
                ...r
            ];
            return _w(t, g, n);
        }
        let i = [
            ...n.patterns
        ];
        for (let g of n.patternFiles)try {
            let b;
            if (g === "-") b = t.stdin;
            else {
                let w = t.fs.resolvePath(t.cwd, g);
                b = await t.fs.readFile(w);
            }
            let y = b.split(`
`).filter((w)=>w.length > 0);
            i.push(...y);
        } catch  {
            return {
                stdout: "",
                stderr: `rg: ${g}: No such file or directory
`,
                exitCode: 2
            };
        }
        if (i.length === 0) return n.patternFiles.length > 0 ? {
            stdout: "",
            stderr: "",
            exitCode: 1
        } : {
            stdout: "",
            stderr: `rg: no pattern given
`,
            exitCode: 2
        };
        let o = r.length === 0 ? [
            "."
        ] : r, a = Dw(n, i), l, c;
        try {
            let g = Fw(i, n, a);
            l = g.regex, c = g.kResetGroup;
        } catch  {
            return {
                stdout: "",
                stderr: `rg: invalid regex: ${i.join(", ")}
`,
                exitCode: 2
            };
        }
        let u = null;
        n.noIgnore || (u = await Qi(t.fs, t.cwd, n.noIgnoreDot, n.noIgnoreVcs, n.ignoreFiles));
        let f = new mr();
        for (let g of n.typeClear)f.clearType(g);
        for (let g of n.typeAdd)f.addType(g);
        let { files: p, singleExplicitFile: d } = await fu(t, o, n, u, f);
        if (p.length === 0) return {
            stdout: "",
            stderr: "",
            exitCode: 1
        };
        let m = !n.noFilename && (n.withFilename || !d || p.length > 1), h = n.lineNumber;
        return s || (d && p.length === 1 && (h = false), n.onlyMatching && (h = false)), Ww(t, p, l, n, m, h, c);
    }
    function Dw(e, t) {
        return e.caseSensitive ? false : e.ignoreCase ? true : e.smartCase ? !t.some((n)=>/[A-Z]/.test(n)) : false;
    }
    function Fw(e, t, n) {
        let r;
        return e.length === 1 ? r = e[0] : r = e.map((s)=>t.fixedStrings ? s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") : `(?:${s})`).join("|"), hr(r, {
            mode: t.fixedStrings && e.length === 1 ? "fixed" : "perl",
            ignoreCase: n,
            wholeWord: t.wordRegexp,
            lineRegexp: t.lineRegexp,
            multiline: t.multiline,
            multilineDotall: t.multilineDotall
        });
    }
    async function fu(e, t, n, r, s) {
        let i = [], o = 0, a = 0;
        for (let c of t){
            let u = e.fs.resolvePath(e.cwd, c);
            try {
                let f = await e.fs.stat(u);
                if (f.isFile) {
                    if (o++, n.maxFilesize > 0 && f.size > n.maxFilesize) continue;
                    du(c, n, r, u, s) && i.push(c);
                } else f.isDirectory && (a++, await pu(e, c, u, 0, n, r, s, i));
            } catch  {}
        }
        return {
            files: n.sort === "path" ? i.sort() : i,
            singleExplicitFile: o === 1 && a === 0
        };
    }
    async function pu(e, t, n, r, s, i, o, a) {
        if (!(r >= s.maxDepth)) {
            i && await i.loadForDirectory(n);
            try {
                let l = e.fs.readdirWithFileTypes ? await e.fs.readdirWithFileTypes(n) : (await e.fs.readdir(n)).map((c)=>({
                        name: c,
                        isFile: void 0
                    }));
                for (let c of l){
                    let u = c.name;
                    if (!s.noIgnore && yr.isCommonIgnored(u)) continue;
                    let f = u.startsWith("."), p = t === "." ? u : t === "./" ? `./${u}` : t.endsWith("/") ? `${t}${u}` : `${t}/${u}`, d = e.fs.resolvePath(n, u), m, h, g = false;
                    if (c.isFile !== void 0 && "isDirectory" in c) {
                        let w = c;
                        if (g = w.isSymbolicLink === true, g && !s.followSymlinks) continue;
                        if (g && s.followSymlinks) try {
                            let E = await e.fs.stat(d);
                            m = E.isFile, h = E.isDirectory;
                        } catch  {
                            continue;
                        }
                        else m = w.isFile, h = w.isDirectory;
                    } else try {
                        let w = e.fs.lstat ? await e.fs.lstat(d) : await e.fs.stat(d);
                        if (g = w.isSymbolicLink === true, g && !s.followSymlinks) continue;
                        let E = g && s.followSymlinks ? await e.fs.stat(d) : w;
                        m = E.isFile, h = E.isDirectory;
                    } catch  {
                        continue;
                    }
                    if (!i?.matches(d, h) && !(f && !s.hidden && !i?.isWhitelisted(d, h))) {
                        if (h) await pu(e, p, d, r + 1, s, i, o, a);
                        else if (m) {
                            if (s.maxFilesize > 0) try {
                                if ((await e.fs.stat(d)).size > s.maxFilesize) continue;
                            } catch  {
                                continue;
                            }
                            du(p, s, i, d, o) && a.push(p);
                        }
                    }
                }
            } catch  {}
        }
    }
    function du(e, t, n, r, s) {
        let i = e.split("/").pop() || e;
        if (n?.matches(r, false) || t.types.length > 0 && !s.matchesType(i, t.types) || t.typesNot.length > 0 && s.matchesType(i, t.typesNot)) return false;
        if (t.globs.length > 0) {
            let o = t.globCaseInsensitive, a = t.globs.filter((c)=>!c.startsWith("!")), l = t.globs.filter((c)=>c.startsWith("!")).map((c)=>c.slice(1));
            if (a.length > 0) {
                let c = false;
                for (let u of a)if (Rt(i, u, o) || Rt(e, u, o)) {
                    c = true;
                    break;
                }
                if (!c) return false;
            }
            for (let c of l)if (c.startsWith("/")) {
                let u = c.slice(1);
                if (Rt(e, u, o)) return false;
            } else if (Rt(i, c, o) || Rt(e, c, o)) return false;
        }
        if (t.iglobs.length > 0) {
            let o = t.iglobs.filter((l)=>!l.startsWith("!")), a = t.iglobs.filter((l)=>l.startsWith("!")).map((l)=>l.slice(1));
            if (o.length > 0) {
                let l = false;
                for (let c of o)if (Rt(i, c, true) || Rt(e, c, true)) {
                    l = true;
                    break;
                }
                if (!l) return false;
            }
            for (let l of a)if (l.startsWith("/")) {
                let c = l.slice(1);
                if (Rt(e, c, true)) return false;
            } else if (Rt(i, l, true) || Rt(e, l, true)) return false;
        }
        return true;
    }
    function Rt(e, t, n = false) {
        let r = "^";
        for(let s = 0; s < t.length; s++){
            let i = t[s];
            if (i === "*") t[s + 1] === "*" ? (r += ".*", s++) : r += "[^/]*";
            else if (i === "?") r += "[^/]";
            else if (i === "[") {
                let o = s + 1;
                for(o < t.length && t[o] === "!" && o++, o < t.length && t[o] === "]" && o++; o < t.length && t[o] !== "]";)o++;
                if (o < t.length) {
                    let a = t.slice(s, o + 1);
                    a.startsWith("[!") && (a = `[^${a.slice(2)}`), r += a, s = o;
                } else r += "\\[";
            } else r += i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        return r += "$", new RegExp(r, n ? "i" : "").test(e);
    }
    async function _w(e, t, n) {
        let r = null;
        n.noIgnore || (r = await Qi(e.fs, e.cwd, n.noIgnoreDot, n.noIgnoreVcs, n.ignoreFiles));
        let s = new mr();
        for (let c of n.typeClear)s.clearType(c);
        for (let c of n.typeAdd)s.addType(c);
        let i = t.length === 0 ? [
            "."
        ] : t, { files: o } = await fu(e, i, n, r, s);
        if (o.length === 0) return {
            stdout: "",
            stderr: "",
            exitCode: 1
        };
        if (n.quiet) return {
            stdout: "",
            stderr: "",
            exitCode: 0
        };
        let a = n.nullSeparator ? "\0" : `
`;
        return {
            stdout: o.map((c)=>c + a).join(""),
            stderr: "",
            exitCode: 0
        };
    }
    function Lw(e, t) {
        if (t.length === 0) return true;
        for (let n of t)if (Rt(e, n, false)) return true;
        return false;
    }
    async function Mw(e, t, n, r) {
        try {
            if (r.preprocessor && e.exec) {
                let o = n.split("/").pop() || n;
                if (Lw(o, r.preprocessorGlobs)) {
                    let a = await e.exec(`${r.preprocessor} "${t}"`, {
                        cwd: e.cwd
                    });
                    if (a.exitCode === 0 && a.stdout) {
                        let l = a.stdout.slice(0, 8192);
                        return {
                            content: a.stdout,
                            isBinary: l.includes("\0")
                        };
                    }
                }
            }
            if (r.searchZip && n.endsWith(".gz")) {
                let o = await e.fs.readFileBuffer(t);
                if (Tw(o)) try {
                    let a = gunzipSync(o), l = new TextDecoder().decode(a), c = l.slice(0, 8192);
                    return {
                        content: l,
                        isBinary: c.includes("\0")
                    };
                } catch  {
                    return null;
                }
            }
            let s = await e.fs.readFile(t), i = s.slice(0, 8192);
            return {
                content: s,
                isBinary: i.includes("\0")
            };
        } catch  {
            return null;
        }
    }
    async function Ww(e, t, n, r, s, i, o) {
        let a = "", l = false, c = [], u = 0, f = 0, p = 0, d = 50;
        e: for(let g = 0; g < t.length; g += d){
            let b = t.slice(g, g + d), y = await Promise.all(b.map(async (w)=>{
                let E = e.fs.resolvePath(e.cwd, w), C = await Mw(e, E, w, r);
                if (!C) return null;
                let { content: A, isBinary: I } = C;
                if (p += A.length, I && !r.searchBinary) return null;
                let O = s && !r.heading ? w : "", L = Dn(A, n, {
                    invertMatch: r.invertMatch,
                    showLineNumbers: i,
                    countOnly: r.count,
                    countMatches: r.countMatches,
                    filename: O,
                    onlyMatching: r.onlyMatching,
                    beforeContext: r.beforeContext,
                    afterContext: r.afterContext,
                    maxCount: r.maxCount,
                    contextSeparator: r.contextSeparator,
                    showColumn: r.column,
                    vimgrep: r.vimgrep,
                    showByteOffset: r.byteOffset,
                    replace: r.replace !== null ? Vi(r.replace) : null,
                    passthru: r.passthru,
                    multiline: r.multiline,
                    kResetGroup: o
                });
                return r.json && L.matched ? {
                    file: w,
                    result: L,
                    content: A,
                    isBinary: false
                } : {
                    file: w,
                    result: L
                };
            }));
            for (let w of y){
                if (!w) continue;
                let { file: E, result: C } = w;
                if (C.matched) {
                    if (l = true, f++, u += C.matchCount, r.quiet && !r.json) break e;
                    if (r.json && !r.quiet) {
                        let A = w.content || "";
                        c.push(JSON.stringify({
                            type: "begin",
                            data: {
                                path: {
                                    text: E
                                }
                            }
                        }));
                        let I = A.split(`
`);
                        n.lastIndex = 0;
                        let O = 0;
                        for(let L = 0; L < I.length; L++){
                            let D = I[L];
                            n.lastIndex = 0;
                            let $ = [];
                            for(let N = n.exec(D); N !== null; N = n.exec(D)){
                                let P = {
                                    match: {
                                        text: N[0]
                                    },
                                    start: N.index,
                                    end: N.index + N[0].length
                                };
                                r.replace !== null && (P.replacement = {
                                    text: r.replace
                                }), $.push(P), N[0].length === 0 && n.lastIndex++;
                            }
                            if ($.length > 0) {
                                let N = {
                                    type: "match",
                                    data: {
                                        path: {
                                            text: E
                                        },
                                        lines: {
                                            text: `${D}
`
                                        },
                                        line_number: L + 1,
                                        absolute_offset: O,
                                        submatches: $
                                    }
                                };
                                c.push(JSON.stringify(N));
                            }
                            O += D.length + 1;
                        }
                        c.push(JSON.stringify({
                            type: "end",
                            data: {
                                path: {
                                    text: E
                                },
                                binary_offset: null,
                                stats: {
                                    elapsed: {
                                        secs: 0,
                                        nanos: 0,
                                        human: "0s"
                                    },
                                    searches: 1,
                                    searches_with_match: 1,
                                    bytes_searched: A.length,
                                    bytes_printed: 0,
                                    matched_lines: C.matchCount,
                                    matches: C.matchCount
                                }
                            }
                        }));
                    } else if (r.filesWithMatches) {
                        let A = r.nullSeparator ? "\0" : `
`;
                        a += `${E}${A}`;
                    } else r.filesWithoutMatch || (r.heading && !r.noFilename && (a += `${E}
`), a += C.output);
                } else if (r.filesWithoutMatch) {
                    let A = r.nullSeparator ? "\0" : `
`;
                    a += `${E}${A}`;
                } else r.includeZero && (r.count || r.countMatches) && (a += C.output);
            }
        }
        r.json && (c.push(JSON.stringify({
            type: "summary",
            data: {
                elapsed_total: {
                    secs: 0,
                    nanos: 0,
                    human: "0s"
                },
                stats: {
                    elapsed: {
                        secs: 0,
                        nanos: 0,
                        human: "0s"
                    },
                    searches: t.length,
                    searches_with_match: f,
                    bytes_searched: p,
                    bytes_printed: 0,
                    matched_lines: u,
                    matches: u
                }
            }
        })), a = `${c.join(`
`)}
`);
        let m = r.quiet && !r.json ? "" : a;
        if (r.stats && !r.json) {
            let g = [
                "",
                `${u} matches`,
                `${u} matched lines`,
                `${f} files contained matches`,
                `${t.length} files searched`,
                `${p} bytes searched`
            ].join(`
`);
            m += `${g}
`;
        }
        let h;
        return r.filesWithoutMatch ? h = a.length > 0 ? 0 : 1 : h = l ? 0 : 1, {
            stdout: m,
            stderr: "",
            exitCode: h
        };
    }
    var hu = v(()=>{
        qi();
        Zi();
        cu();
    });
    var mu = {};
    V(mu, {
        rgCommand: ()=>Uw
    });
    var Bw, Uw, gu = v(()=>{
        X();
        Zi();
        lu();
        hu();
        Bw = {
            name: "rg",
            summary: "recursively search for a pattern",
            usage: "rg [OPTIONS] PATTERN [PATH ...]",
            description: `rg (ripgrep) recursively searches directories for a regex pattern.
Unlike grep, rg is recursive by default and respects .gitignore files.

EXAMPLES:
  rg foo                    Search for 'foo' in current directory
  rg foo src/               Search in src/ directory
  rg -i foo                 Case-insensitive search
  rg -w foo                 Match whole words only
  rg -t js foo              Search only JavaScript files
  rg -g '*.ts' foo          Search files matching glob
  rg --hidden foo           Include hidden files
  rg -l foo                 List files with matches only`,
            options: [
                "-e, --regexp PATTERN    search for PATTERN (can be used multiple times)",
                "-f, --file FILE         read patterns from FILE, one per line",
                "-i, --ignore-case       case-insensitive search",
                "-s, --case-sensitive    case-sensitive search (overrides smart-case)",
                "-S, --smart-case        smart case (default: case-insensitive unless pattern has uppercase)",
                "-F, --fixed-strings     treat pattern as literal string",
                "-w, --word-regexp       match whole words only",
                "-x, --line-regexp       match whole lines only",
                "-v, --invert-match      select non-matching lines",
                "-r, --replace TEXT      replace matches with TEXT",
                "-c, --count             print count of matching lines per file",
                "    --count-matches     print count of individual matches per file",
                "-l, --files-with-matches print only file names with matches",
                "    --files-without-match print file names without matches",
                "    --files             list files that would be searched",
                "-o, --only-matching     print only matching parts",
                "-m, --max-count NUM     stop after NUM matches per file",
                "-q, --quiet             suppress output, exit 0 on match",
                "    --stats             print search statistics",
                "-n, --line-number       print line numbers (default: on)",
                "-N, --no-line-number    do not print line numbers",
                "-I, --no-filename       suppress the prefixing of file names",
                "-0, --null              use NUL as filename separator",
                "-b, --byte-offset       show byte offset of each match",
                "    --column            show column number of first match",
                "    --vimgrep           show results in vimgrep format",
                "    --json              show results in JSON Lines format",
                "-A NUM                  print NUM lines after each match",
                "-B NUM                  print NUM lines before each match",
                "-C NUM                  print NUM lines before and after each match",
                "    --context-separator SEP  separator for context groups (default: --)",
                "-U, --multiline         match patterns across lines",
                "-z, --search-zip        search in compressed files (gzip only)",
                "-g, --glob GLOB         include files matching GLOB",
                "-t, --type TYPE         only search files of TYPE (e.g., js, py, ts)",
                "-T, --type-not TYPE     exclude files of TYPE",
                "-L, --follow            follow symbolic links",
                "-u, --unrestricted      reduce filtering (-u: no ignore, -uu: +hidden, -uuu: +binary)",
                "-a, --text              search binary files as text",
                "    --hidden            search hidden files and directories",
                "    --no-ignore         don't respect .gitignore/.ignore files",
                "-d, --max-depth NUM     maximum search depth",
                "    --sort TYPE         sort files (path, none)",
                "    --heading           show file path above matches",
                "    --passthru          print all lines (non-matches use - separator)",
                "    --include-zero      include files with 0 matches in count output",
                "    --type-list         list all available file types",
                "    --help              display this help and exit"
            ]
        }, Uw = {
            name: "rg",
            async execute (e, t) {
                if (_(e)) return F(Bw);
                if (e.includes("--type-list")) return {
                    stdout: nu(),
                    stderr: "",
                    exitCode: 0
                };
                let n = au(e);
                return n.success ? uu({
                    ctx: t,
                    options: n.options,
                    paths: n.paths,
                    explicitLineNumbers: n.explicitLineNumbers
                }) : n.error;
            }
        };
    });
    function ls(e) {
        return e instanceof Qe || e instanceof Ke || e instanceof Ve;
    }
    var et, Qe, Ke, Ve, lt, tt, ae, Ee, nt, _t, Fn, ne, Lt, xt, de = v(()=>{
        et = class extends Error {
            stdout;
            stderr;
            constructor(t, n = "", r = ""){
                super(t), this.stdout = n, this.stderr = r;
            }
            prependOutput(t, n) {
                this.stdout = t + this.stdout, this.stderr = n + this.stderr;
            }
        }, Qe = class extends et {
            levels;
            name = "BreakError";
            constructor(t = 1, n = "", r = ""){
                super("break", n, r), this.levels = t;
            }
        }, Ke = class extends et {
            levels;
            name = "ContinueError";
            constructor(t = 1, n = "", r = ""){
                super("continue", n, r), this.levels = t;
            }
        }, Ve = class extends et {
            exitCode;
            name = "ReturnError";
            constructor(t = 0, n = "", r = ""){
                super("return", n, r), this.exitCode = t;
            }
        }, lt = class extends et {
            exitCode;
            name = "ErrexitError";
            constructor(t, n = "", r = ""){
                super(`errexit: command exited with status ${t}`, n, r), this.exitCode = t;
            }
        }, tt = class extends et {
            varName;
            name = "NounsetError";
            constructor(t, n = ""){
                super(`${t}: unbound variable`, n, `bash: ${t}: unbound variable
`), this.varName = t;
            }
        }, ae = class extends et {
            exitCode;
            name = "ExitError";
            constructor(t, n = "", r = ""){
                super("exit", n, r), this.exitCode = t;
            }
        }, Ee = class extends et {
            name = "ArithmeticError";
            fatal;
            constructor(t, n = "", r = "", s = false){
                super(t, n, r), this.stderr = r || `bash: ${t}
`, this.fatal = s;
            }
        }, nt = class extends et {
            name = "BadSubstitutionError";
            constructor(t, n = "", r = ""){
                super(t, n, r), this.stderr = r || `bash: ${t}: bad substitution
`;
            }
        }, _t = class extends et {
            name = "GlobError";
            constructor(t, n = "", r = ""){
                super(`no match: ${t}`, n, r), this.stderr = r || `bash: no match: ${t}
`;
            }
        }, Fn = class extends et {
            name = "BraceExpansionError";
            constructor(t, n = "", r = ""){
                super(t, n, r), this.stderr = r || `bash: ${t}
`;
            }
        }, ne = class extends et {
            limitType;
            name = "ExecutionLimitError";
            static EXIT_CODE = 126;
            constructor(t, n, r = "", s = ""){
                super(t, r, s), this.limitType = n, this.stderr = s || `bash: ${t}
`;
            }
        }, Lt = class extends et {
            name = "SubshellExitError";
            constructor(t = "", n = ""){
                super("subshell exit", t, n);
            }
        };
        xt = class extends et {
            exitCode;
            name = "PosixFatalError";
            constructor(t, n = "", r = ""){
                super("posix fatal error", n, r), this.exitCode = t;
            }
        };
    });
    function Xi(e) {
        let t = "", n = 0, r = false;
        for(; n < e.length;){
            if (e[n] === "[" && !r) {
                if (e[n + 1] === "[" && e[n + 2] === ":") {
                    let s = e.indexOf(":]]", n + 3);
                    if (s !== -1) {
                        let i = e.slice(n + 3, s), o = Ki[i];
                        if (o) {
                            t += `[${o}]`, n = s + 3;
                            continue;
                        }
                    }
                }
                if (e[n + 1] === "^" && e[n + 2] === "[" && e[n + 3] === ":") {
                    let s = e.indexOf(":]]", n + 4);
                    if (s !== -1) {
                        let i = e.slice(n + 4, s), o = Ki[i];
                        if (o) {
                            t += `[^${o}]`, n = s + 3;
                            continue;
                        }
                    }
                }
                t += "[", n++, r = true, n < e.length && e[n] === "^" && (t += "^", n++), n < e.length && e[n] === "]" && (t += "\\]", n++);
                continue;
            }
            if (r) {
                if (e[n] === "]") {
                    t += "]", n++, r = false;
                    continue;
                }
                if (e[n] === "[" && e[n + 1] === ":") {
                    let s = e.indexOf(":]", n + 2);
                    if (s !== -1) {
                        let i = e.slice(n + 2, s), o = Ki[i];
                        if (o) {
                            t += o, n = s + 2;
                            continue;
                        }
                    }
                }
                if (e[n] === "\\" && n + 1 < e.length) {
                    t += e[n] + e[n + 1], n += 2;
                    continue;
                }
                t += e[n], n++;
                continue;
            }
            if (e[n] === "\\" && n + 1 < e.length) {
                let s = e[n + 1];
                if (s === "+" || s === "?" || s === "|") {
                    t += s, n += 2;
                    continue;
                }
                if (s === "(" || s === ")") {
                    t += s, n += 2;
                    continue;
                }
                if (s === "{" || s === "}") {
                    t += s, n += 2;
                    continue;
                }
                if (s === "t") {
                    t += "	", n += 2;
                    continue;
                }
                if (s === "n") {
                    t += `
`, n += 2;
                    continue;
                }
                if (s === "r") {
                    t += "\r", n += 2;
                    continue;
                }
                t += e[n] + s, n += 2;
                continue;
            }
            if (e[n] === "+" || e[n] === "?" || e[n] === "|" || e[n] === "(" || e[n] === ")") {
                t += `\\${e[n]}`, n++;
                continue;
            }
            if (e[n] === "^" && !(t === "" || t.endsWith("("))) {
                t += "\\^", n++;
                continue;
            }
            if (e[n] === "$") {
                let s = n === e.length - 1, i = n + 2 < e.length && e[n + 1] === "\\" && e[n + 2] === ")";
                if (!s && !i) {
                    t += "\\$", n++;
                    continue;
                }
            }
            t += e[n], n++;
        }
        return t;
    }
    function Ji(e) {
        let t = "", n = false;
        for(let r = 0; r < e.length; r++)e[r] === "[" && !n ? (n = true, t += "[", r++, r < e.length && e[r] === "^" && (t += "^", r++), r < e.length && e[r] === "]" && (t += "]", r++), r--) : e[r] === "]" && n ? (n = false, t += "]") : !n && e[r] === "{" && e[r + 1] === "," ? (t += "{0,", r++) : t += e[r];
        return t;
    }
    function yu(e) {
        let t = "";
        for(let n = 0; n < e.length; n++){
            let r = e[n], s = r.charCodeAt(0);
            r === "\\" ? t += "\\\\" : r === "	" ? t += "\\t" : r === `
` ? t += `$
` : r === "\r" ? t += "\\r" : r === "\x07" ? t += "\\a" : r === "\b" ? t += "\\b" : r === "\f" ? t += "\\f" : r === "\v" ? t += "\\v" : s < 32 || s >= 127 ? t += `\\${s.toString(8).padStart(3, "0")}` : t += r;
        }
        return `${t}$`;
    }
    var Ki, bu = v(()=>{
        Ki = {
            alnum: "a-zA-Z0-9",
            alpha: "a-zA-Z",
            ascii: "\\x00-\\x7F",
            blank: " \\t",
            cntrl: "\\x00-\\x1F\\x7F",
            digit: "0-9",
            graph: "!-~",
            lower: "a-z",
            print: " -~",
            punct: "!-/:-@\\[-`{-~",
            space: " \\t\\n\\r\\f\\v",
            upper: "A-Z",
            word: "a-zA-Z0-9_",
            xdigit: "0-9A-Fa-f"
        };
    });
    function wu(e, t, n) {
        return {
            patternSpace: "",
            holdSpace: "",
            lineNumber: 0,
            totalLines: e,
            deleted: false,
            printed: false,
            quit: false,
            quitSilent: false,
            exitCode: void 0,
            errorMessage: void 0,
            appendBuffer: [],
            substitutionMade: false,
            lineNumberOutput: [],
            nCommandOutput: [],
            restartCycle: false,
            inDRestartedCycle: false,
            currentFilename: t,
            pendingFileReads: [],
            pendingFileWrites: [],
            pendingExecute: void 0,
            rangeStates: n || new Map(),
            linesConsumedInCycle: 0
        };
    }
    function jw(e) {
        return typeof e == "object" && "first" in e && "step" in e;
    }
    function Hw(e) {
        return typeof e == "object" && "offset" in e;
    }
    function _n(e, t, n, r, s) {
        if (e === "$") return t === n;
        if (typeof e == "number") return t === e;
        if (jw(e)) {
            let { first: i, step: o } = e;
            return o === 0 ? t === i : (t - i) % o === 0 && t >= i;
        }
        if (typeof e == "object" && "pattern" in e) try {
            let i = e.pattern;
            i === "" && s?.lastPattern ? i = s.lastPattern : i !== "" && s && (s.lastPattern = i);
            let o = Ji(Xi(i));
            return new RegExp(o).test(r);
        } catch  {
            return false;
        }
        return false;
    }
    function Yi(e) {
        let t = (n)=>n === void 0 ? "undefined" : n === "$" ? "$" : typeof n == "number" ? String(n) : "pattern" in n ? `/${n.pattern}/` : "first" in n ? `${n.first}~${n.step}` : "unknown";
        return `${t(e.start)},${t(e.end)}`;
    }
    function Vw(e, t, n, r, s, i) {
        if (!e || !e.start && !e.end) return true;
        let o = e.start, a = e.end;
        if (o !== void 0 && a === void 0) return _n(o, t, n, r, i);
        if (o !== void 0 && a !== void 0) {
            let l = typeof o == "object" && "pattern" in o, c = typeof a == "object" && "pattern" in a, u = Hw(a);
            if (u && s) {
                let p = Yi(e), d = s.get(p);
                if (d || (d = {
                    active: false
                }, s.set(p, d)), d.active) {
                    let m = d.startLine || t;
                    return t >= m + a.offset && (d.active = false, s.set(p, d)), true;
                } else return _n(o, t, n, r, i) ? (d.active = true, d.startLine = t, s.set(p, d), a.offset === 0 && (d.active = false, s.set(p, d)), true) : false;
            }
            if (!l && !c && !u) {
                let p = typeof o == "number" ? o : o === "$" ? n : 1, d = typeof a == "number" ? a : n;
                if (p <= d) return t >= p && t <= d;
                if (s) {
                    let m = Yi(e), h = s.get(m);
                    return h || (h = {
                        active: false
                    }, s.set(m, h)), !h.completed && t >= p ? (h.completed = true, s.set(m, h), true) : false;
                }
                return false;
            }
            if (s) {
                let p = Yi(e), d = s.get(p);
                if (d || (d = {
                    active: false
                }, s.set(p, d)), d.active) return _n(a, t, n, r, i) && (d.active = false, typeof o == "number" && (d.completed = true), s.set(p, d)), true;
                {
                    if (d.completed) return false;
                    let m = false;
                    return typeof o == "number" ? m = t >= o : m = _n(o, t, n, r, i), m ? (d.active = true, d.startLine = t, s.set(p, d), _n(a, t, n, r, i) && (d.active = false, typeof o == "number" && (d.completed = true), s.set(p, d)), true) : false;
                }
            }
            return _n(o, t, n, r, i);
        }
        return true;
    }
    function dn(e, t, n, r, s, i) {
        let o = Vw(e, t, n, r, s, i);
        return e?.negated ? !o : o;
    }
    function qw(e, t, n, r) {
        let s = "", i = 0, o = false;
        for(; i <= e.length;){
            t.lastIndex = i;
            let a = t.exec(e);
            if (!a) {
                s += e.slice(i);
                break;
            }
            if (a.index !== i) {
                s += e.slice(i, a.index), i = a.index, o = false;
                continue;
            }
            let l = a[0], c = a.slice(1);
            if (o && l.length === 0) {
                if (i < e.length) s += e[i], i++;
                else break;
                o = false;
                continue;
            }
            if (s += r(l, c), o = false, l.length === 0) if (i < e.length) s += e[i], i++;
            else break;
            else i += l.length, o = true;
        }
        return s;
    }
    function eo(e, t, n) {
        let r = "", s = 0;
        for(; s < e.length;){
            if (e[s] === "\\" && s + 1 < e.length) {
                let i = e[s + 1];
                if (i === "&") {
                    r += "&", s += 2;
                    continue;
                }
                if (i === "n") {
                    r += `
`, s += 2;
                    continue;
                }
                if (i === "t") {
                    r += "	", s += 2;
                    continue;
                }
                if (i === "r") {
                    r += "\r", s += 2;
                    continue;
                }
                let o = parseInt(i, 10);
                if (o === 0) {
                    r += t, s += 2;
                    continue;
                }
                if (o >= 1 && o <= 9) {
                    r += n[o - 1] || "", s += 2;
                    continue;
                }
                r += i, s += 2;
                continue;
            }
            if (e[s] === "&") {
                r += t, s++;
                continue;
            }
            r += e[s], s++;
        }
        return r;
    }
    function Gw(e, t) {
        let { lineNumber: n, totalLines: r, patternSpace: s } = t;
        if (e.type !== "label" && dn(e.address, n, r, s, t.rangeStates, t)) switch(e.type){
            case "substitute":
                {
                    let i = e, o = "";
                    i.global && (o += "g"), i.ignoreCase && (o += "i");
                    let a = i.pattern;
                    a === "" && t.lastPattern ? a = t.lastPattern : a !== "" && (t.lastPattern = a);
                    let l = Ji(i.extendedRegex ? a : Xi(a));
                    try {
                        let c = new RegExp(l, o), u = c.test(t.patternSpace);
                        if (c.lastIndex = 0, u) {
                            if (t.substitutionMade = true, i.nthOccurrence && i.nthOccurrence > 0 && !i.global) {
                                let f = 0, p = i.nthOccurrence;
                                t.patternSpace = t.patternSpace.replace(new RegExp(l, `g${i.ignoreCase ? "i" : ""}`), (d, ...m)=>{
                                    if (f++, f === p) {
                                        let h = m.slice(0, -2);
                                        return eo(i.replacement, d, h);
                                    }
                                    return d;
                                });
                            } else i.global ? t.patternSpace = qw(t.patternSpace, new RegExp(l, `g${i.ignoreCase ? "i" : ""}`), i.replacement, (f, p)=>eo(i.replacement, f, p)) : t.patternSpace = t.patternSpace.replace(c, (f, ...p)=>{
                                let d = p.slice(0, -2);
                                return eo(i.replacement, f, d);
                            });
                            i.printOnMatch && t.lineNumberOutput.push(t.patternSpace);
                        }
                    } catch  {}
                    break;
                }
            case "print":
                t.lineNumberOutput.push(t.patternSpace);
                break;
            case "printFirstLine":
                {
                    let i = t.patternSpace.indexOf(`
`);
                    i !== -1 ? t.lineNumberOutput.push(t.patternSpace.slice(0, i)) : t.lineNumberOutput.push(t.patternSpace);
                    break;
                }
            case "delete":
                t.deleted = true;
                break;
            case "deleteFirstLine":
                {
                    let i = t.patternSpace.indexOf(`
`);
                    i !== -1 ? (t.patternSpace = t.patternSpace.slice(i + 1), t.restartCycle = true, t.inDRestartedCycle = true) : t.deleted = true;
                    break;
                }
            case "zap":
                t.patternSpace = "";
                break;
            case "append":
                t.appendBuffer.push(e.text);
                break;
            case "insert":
                t.appendBuffer.unshift(`__INSERT__${e.text}`);
                break;
            case "change":
                t.deleted = true, t.changedText = e.text;
                break;
            case "hold":
                t.holdSpace = t.patternSpace;
                break;
            case "holdAppend":
                t.holdSpace ? t.holdSpace += `
${t.patternSpace}` : t.holdSpace = t.patternSpace;
                break;
            case "get":
                t.patternSpace = t.holdSpace;
                break;
            case "getAppend":
                t.patternSpace += `
${t.holdSpace}`;
                break;
            case "exchange":
                {
                    let i = t.patternSpace;
                    t.patternSpace = t.holdSpace, t.holdSpace = i;
                    break;
                }
            case "next":
                t.printed = true;
                break;
            case "quit":
                t.quit = true, e.exitCode !== void 0 && (t.exitCode = e.exitCode);
                break;
            case "quitSilent":
                t.quit = true, t.quitSilent = true, e.exitCode !== void 0 && (t.exitCode = e.exitCode);
                break;
            case "list":
                {
                    let i = yu(t.patternSpace);
                    t.lineNumberOutput.push(i);
                    break;
                }
            case "printFilename":
                t.currentFilename && t.lineNumberOutput.push(t.currentFilename);
                break;
            case "version":
                {
                    let i = [
                        4,
                        8,
                        0
                    ];
                    if (e.minVersion) {
                        let o = e.minVersion.split("."), a = [], l = false;
                        for (let c of o){
                            let u = parseInt(c, 10);
                            if (Number.isNaN(u) || u < 0) {
                                t.quit = true, t.exitCode = 1, t.errorMessage = `sed: invalid version string: ${e.minVersion}`, l = true;
                                break;
                            }
                            a.push(u);
                        }
                        if (!l) {
                            for(; a.length < 3;)a.push(0);
                            for(let c = 0; c < 3; c++){
                                if (a[c] > i[c]) {
                                    t.quit = true, t.exitCode = 1, t.errorMessage = `sed: this is not GNU sed version ${e.minVersion}`;
                                    break;
                                }
                                if (a[c] < i[c]) break;
                            }
                        }
                    }
                    break;
                }
            case "readFile":
                t.pendingFileReads.push({
                    filename: e.filename,
                    wholeFile: true
                });
                break;
            case "readFileLine":
                t.pendingFileReads.push({
                    filename: e.filename,
                    wholeFile: false
                });
                break;
            case "writeFile":
                t.pendingFileWrites.push({
                    filename: e.filename,
                    content: `${t.patternSpace}
`
                });
                break;
            case "writeFirstLine":
                {
                    let i = t.patternSpace.indexOf(`
`), o = i !== -1 ? t.patternSpace.slice(0, i) : t.patternSpace;
                    t.pendingFileWrites.push({
                        filename: e.filename,
                        content: `${o}
`
                    });
                    break;
                }
            case "execute":
                e.command ? t.pendingExecute = {
                    command: e.command,
                    replacePattern: false
                } : t.pendingExecute = {
                    command: t.patternSpace,
                    replacePattern: true
                };
                break;
            case "transliterate":
                t.patternSpace = Zw(t.patternSpace, e);
                break;
            case "lineNumber":
                t.lineNumberOutput.push(String(t.lineNumber));
                break;
        }
    }
    function Zw(e, t) {
        let n = "";
        for (let r of e){
            let s = t.source.indexOf(r);
            s !== -1 ? n += t.dest[s] : n += r;
        }
        return n;
    }
    function to(e, t, n, r) {
        let s = new Map();
        for(let l = 0; l < e.length; l++){
            let c = e[l];
            c.type === "label" && s.set(c.name, l);
        }
        let i = r?.maxIterations ?? zw, o = 0, a = 0;
        for(; a < e.length;){
            if (o++, o > i) throw new ne(`sed: command execution exceeded maximum iterations (${i})`, "iterations");
            if (t.deleted || t.quit || t.quitSilent || t.restartCycle) break;
            let l = e[a];
            if (l.type === "next") {
                if (dn(l.address, t.lineNumber, t.totalLines, t.patternSpace, t.rangeStates, t)) if (t.nCommandOutput.push(t.patternSpace), n && n.currentLineIndex + t.linesConsumedInCycle + 1 < n.lines.length) {
                    t.linesConsumedInCycle++;
                    let c = n.lines[n.currentLineIndex + t.linesConsumedInCycle];
                    t.patternSpace = c, t.lineNumber = n.currentLineIndex + t.linesConsumedInCycle + 1, t.substitutionMade = false;
                } else {
                    t.quit = true, t.deleted = true;
                    break;
                }
                a++;
                continue;
            }
            if (l.type === "nextAppend") {
                if (dn(l.address, t.lineNumber, t.totalLines, t.patternSpace, t.rangeStates, t)) if (n && n.currentLineIndex + t.linesConsumedInCycle + 1 < n.lines.length) {
                    t.linesConsumedInCycle++;
                    let c = n.lines[n.currentLineIndex + t.linesConsumedInCycle];
                    t.patternSpace += `
${c}`, t.lineNumber = n.currentLineIndex + t.linesConsumedInCycle + 1;
                } else {
                    t.quit = true;
                    break;
                }
                a++;
                continue;
            }
            if (l.type === "branch") {
                let c = l;
                if (dn(c.address, t.lineNumber, t.totalLines, t.patternSpace, t.rangeStates, t)) {
                    if (c.label) {
                        let u = s.get(c.label);
                        if (u !== void 0) {
                            a = u;
                            continue;
                        }
                        t.branchRequest = c.label;
                        break;
                    }
                    break;
                }
                a++;
                continue;
            }
            if (l.type === "branchOnSubst") {
                let c = l;
                if (dn(c.address, t.lineNumber, t.totalLines, t.patternSpace, t.rangeStates, t) && t.substitutionMade) {
                    if (t.substitutionMade = false, c.label) {
                        let u = s.get(c.label);
                        if (u !== void 0) {
                            a = u;
                            continue;
                        }
                        t.branchRequest = c.label;
                        break;
                    }
                    break;
                }
                a++;
                continue;
            }
            if (l.type === "branchOnNoSubst") {
                let c = l;
                if (dn(c.address, t.lineNumber, t.totalLines, t.patternSpace, t.rangeStates, t) && !t.substitutionMade) {
                    if (c.label) {
                        let u = s.get(c.label);
                        if (u !== void 0) {
                            a = u;
                            continue;
                        }
                        t.branchRequest = c.label;
                        break;
                    }
                    break;
                }
                a++;
                continue;
            }
            if (l.type === "group") {
                let c = l;
                if (dn(c.address, t.lineNumber, t.totalLines, t.patternSpace, t.rangeStates, t) && (to(c.commands, t, n, r), t.branchRequest)) {
                    let u = s.get(t.branchRequest);
                    if (u !== void 0) {
                        t.branchRequest = void 0, a = u;
                        continue;
                    }
                    break;
                }
                a++;
                continue;
            }
            Gw(l, t), a++;
        }
        return t.linesConsumedInCycle;
    }
    var zw, xu = v(()=>{
        de();
        bu();
        zw = 1e4;
    });
    var Z, cs, Eu = v(()=>{
        (function(e) {
            e.NUMBER = "NUMBER", e.DOLLAR = "DOLLAR", e.PATTERN = "PATTERN", e.STEP = "STEP", e.RELATIVE_OFFSET = "RELATIVE_OFFSET", e.LBRACE = "LBRACE", e.RBRACE = "RBRACE", e.SEMICOLON = "SEMICOLON", e.NEWLINE = "NEWLINE", e.COMMA = "COMMA", e.NEGATION = "NEGATION", e.COMMAND = "COMMAND", e.SUBSTITUTE = "SUBSTITUTE", e.TRANSLITERATE = "TRANSLITERATE", e.LABEL_DEF = "LABEL_DEF", e.BRANCH = "BRANCH", e.BRANCH_ON_SUBST = "BRANCH_ON_SUBST", e.BRANCH_ON_NO_SUBST = "BRANCH_ON_NO_SUBST", e.TEXT_CMD = "TEXT_CMD", e.FILE_READ = "FILE_READ", e.FILE_READ_LINE = "FILE_READ_LINE", e.FILE_WRITE = "FILE_WRITE", e.FILE_WRITE_LINE = "FILE_WRITE_LINE", e.EXECUTE = "EXECUTE", e.VERSION = "VERSION", e.EOF = "EOF", e.ERROR = "ERROR";
        })(Z || (Z = {}));
        cs = class {
            input;
            pos = 0;
            line = 1;
            column = 1;
            constructor(t){
                this.input = t;
            }
            tokenize() {
                let t = [];
                for(; this.pos < this.input.length;){
                    let n = this.nextToken();
                    n && t.push(n);
                }
                return t.push(this.makeToken(Z.EOF, "")), t;
            }
            makeToken(t, n, r) {
                return {
                    type: t,
                    value: n,
                    line: this.line,
                    column: this.column,
                    ...r
                };
            }
            peek(t = 0) {
                return this.input[this.pos + t] || "";
            }
            advance() {
                let t = this.input[this.pos++] || "";
                return t === `
` ? (this.line++, this.column = 1) : this.column++, t;
            }
            readEscapedString(t) {
                let n = "";
                for(; this.pos < this.input.length && this.peek() !== t;)if (this.peek() === "\\") {
                    this.advance();
                    let r = this.advance();
                    r === "n" ? n += `
` : r === "t" ? n += "	" : n += r;
                } else {
                    if (this.peek() === `
`) return null;
                    n += this.advance();
                }
                return n;
            }
            skipWhitespace() {
                for(; this.pos < this.input.length;){
                    let t = this.peek();
                    if (t === " " || t === "	" || t === "\r") this.advance();
                    else if (t === "#") for(; this.pos < this.input.length && this.peek() !== `
`;)this.advance();
                    else break;
                }
            }
            nextToken() {
                if (this.skipWhitespace(), this.pos >= this.input.length) return null;
                let t = this.line, n = this.column, r = this.peek();
                return r === `
` ? (this.advance(), {
                    type: Z.NEWLINE,
                    value: `
`,
                    line: t,
                    column: n
                }) : r === ";" ? (this.advance(), {
                    type: Z.SEMICOLON,
                    value: ";",
                    line: t,
                    column: n
                }) : r === "{" ? (this.advance(), {
                    type: Z.LBRACE,
                    value: "{",
                    line: t,
                    column: n
                }) : r === "}" ? (this.advance(), {
                    type: Z.RBRACE,
                    value: "}",
                    line: t,
                    column: n
                }) : r === "," ? (this.advance(), {
                    type: Z.COMMA,
                    value: ",",
                    line: t,
                    column: n
                }) : r === "!" ? (this.advance(), {
                    type: Z.NEGATION,
                    value: "!",
                    line: t,
                    column: n
                }) : r === "$" ? (this.advance(), {
                    type: Z.DOLLAR,
                    value: "$",
                    line: t,
                    column: n
                }) : this.isDigit(r) ? this.readNumber() : r === "+" && this.isDigit(this.input[this.pos + 1] || "") ? this.readRelativeOffset() : r === "/" ? this.readPattern() : r === ":" ? this.readLabelDef() : this.readCommand();
            }
            readNumber() {
                let t = this.line, n = this.column, r = "";
                for(; this.isDigit(this.peek());)r += this.advance();
                if (this.peek() === "~") {
                    this.advance();
                    let s = "";
                    for(; this.isDigit(this.peek());)s += this.advance();
                    let i = parseInt(r, 10), o = parseInt(s, 10) || 0;
                    return {
                        type: Z.STEP,
                        value: `${i}~${o}`,
                        first: i,
                        step: o,
                        line: t,
                        column: n
                    };
                }
                return {
                    type: Z.NUMBER,
                    value: parseInt(r, 10),
                    line: t,
                    column: n
                };
            }
            readRelativeOffset() {
                let t = this.line, n = this.column;
                this.advance();
                let r = "";
                for(; this.isDigit(this.peek());)r += this.advance();
                let s = parseInt(r, 10) || 0;
                return {
                    type: Z.RELATIVE_OFFSET,
                    value: `+${s}`,
                    offset: s,
                    line: t,
                    column: n
                };
            }
            readPattern() {
                let t = this.line, n = this.column;
                this.advance();
                let r = "", s = false;
                for(; this.pos < this.input.length;){
                    let i = this.peek();
                    if (i === "/" && !s) break;
                    if (i === "\\") r += this.advance(), this.pos < this.input.length && this.peek() !== `
` && (r += this.advance());
                    else {
                        if (i === `
`) break;
                        i === "[" && !s ? (s = true, r += this.advance(), this.peek() === "^" && (r += this.advance()), this.peek() === "]" && (r += this.advance())) : i === "]" && s ? (s = false, r += this.advance()) : r += this.advance();
                    }
                }
                return this.peek() === "/" && this.advance(), {
                    type: Z.PATTERN,
                    value: r,
                    pattern: r,
                    line: t,
                    column: n
                };
            }
            readLabelDef() {
                let t = this.line, n = this.column;
                for(this.advance(); this.peek() === " " || this.peek() === "	";)this.advance();
                let r = "";
                for(; this.pos < this.input.length;){
                    let s = this.peek();
                    if (s === " " || s === "	" || s === `
` || s === ";" || s === "}" || s === "{") break;
                    r += this.advance();
                }
                return {
                    type: Z.LABEL_DEF,
                    value: r,
                    label: r,
                    line: t,
                    column: n
                };
            }
            readCommand() {
                let t = this.line, n = this.column, r = this.advance();
                switch(r){
                    case "s":
                        return this.readSubstitute(t, n);
                    case "y":
                        return this.readTransliterate(t, n);
                    case "a":
                    case "i":
                    case "c":
                        return this.readTextCommand(r, t, n);
                    case "b":
                        return this.readBranch(Z.BRANCH, "b", t, n);
                    case "t":
                        return this.readBranch(Z.BRANCH_ON_SUBST, "t", t, n);
                    case "T":
                        return this.readBranch(Z.BRANCH_ON_NO_SUBST, "T", t, n);
                    case "r":
                        return this.readFileCommand(Z.FILE_READ, "r", t, n);
                    case "R":
                        return this.readFileCommand(Z.FILE_READ_LINE, "R", t, n);
                    case "w":
                        return this.readFileCommand(Z.FILE_WRITE, "w", t, n);
                    case "W":
                        return this.readFileCommand(Z.FILE_WRITE_LINE, "W", t, n);
                    case "e":
                        return this.readExecute(t, n);
                    case "p":
                    case "P":
                    case "d":
                    case "D":
                    case "h":
                    case "H":
                    case "g":
                    case "G":
                    case "x":
                    case "n":
                    case "N":
                    case "q":
                    case "Q":
                    case "z":
                    case "=":
                    case "l":
                    case "F":
                        return {
                            type: Z.COMMAND,
                            value: r,
                            line: t,
                            column: n
                        };
                    case "v":
                        return this.readVersion(t, n);
                    default:
                        return {
                            type: Z.ERROR,
                            value: r,
                            line: t,
                            column: n
                        };
                }
            }
            readSubstitute(t, n) {
                let r = this.advance();
                if (!r || r === `
`) return {
                    type: Z.ERROR,
                    value: "s",
                    line: t,
                    column: n
                };
                let s = "", i = false;
                for(; this.pos < this.input.length;){
                    let l = this.peek();
                    if (l === r && !i) break;
                    if (l === "\\") this.advance(), this.pos < this.input.length && this.peek() !== `
` ? this.peek() === r && !i ? s += this.advance() : (s += "\\", s += this.advance()) : s += "\\";
                    else {
                        if (l === `
`) break;
                        l === "[" && !i ? (i = true, s += this.advance(), this.peek() === "^" && (s += this.advance()), this.peek() === "]" && (s += this.advance())) : l === "]" && i ? (i = false, s += this.advance()) : s += this.advance();
                    }
                }
                if (this.peek() !== r) return {
                    type: Z.ERROR,
                    value: "unterminated substitution pattern",
                    line: t,
                    column: n
                };
                this.advance();
                let o = "";
                for(; this.pos < this.input.length && this.peek() !== r;)if (this.peek() === "\\") if (this.advance(), this.pos < this.input.length) {
                    let l = this.peek();
                    l === "\\" ? (this.advance(), this.pos < this.input.length && this.peek() === `
` ? (o += `
`, this.advance()) : o += "\\") : l === `
` ? (o += `
`, this.advance()) : o += `\\${this.advance()}`;
                } else o += "\\";
                else {
                    if (this.peek() === `
`) break;
                    o += this.advance();
                }
                this.peek() === r && this.advance();
                let a = "";
                for(; this.pos < this.input.length;){
                    let l = this.peek();
                    if (l === "g" || l === "i" || l === "p" || l === "I" || this.isDigit(l)) a += this.advance();
                    else break;
                }
                return {
                    type: Z.SUBSTITUTE,
                    value: `s${r}${s}${r}${o}${r}${a}`,
                    pattern: s,
                    replacement: o,
                    flags: a,
                    line: t,
                    column: n
                };
            }
            readTransliterate(t, n) {
                let r = this.advance();
                if (!r || r === `
`) return {
                    type: Z.ERROR,
                    value: "y",
                    line: t,
                    column: n
                };
                let s = this.readEscapedString(r);
                if (s === null || this.peek() !== r) return {
                    type: Z.ERROR,
                    value: "unterminated transliteration source",
                    line: t,
                    column: n
                };
                this.advance();
                let i = this.readEscapedString(r);
                if (i === null || this.peek() !== r) return {
                    type: Z.ERROR,
                    value: "unterminated transliteration dest",
                    line: t,
                    column: n
                };
                this.advance();
                let o = this.peek();
                for(; o === " " || o === "	";)this.advance(), o = this.peek();
                return o !== "" && o !== ";" && o !== `
` && o !== "}" ? {
                    type: Z.ERROR,
                    value: "extra text at the end of a transform command",
                    line: t,
                    column: n
                } : {
                    type: Z.TRANSLITERATE,
                    value: `y${r}${s}${r}${i}${r}`,
                    source: s,
                    dest: i,
                    line: t,
                    column: n
                };
            }
            readTextCommand(t, n, r) {
                let s = false;
                this.peek() === "\\" && this.pos + 1 < this.input.length && (this.input[this.pos + 1] === `
` || this.input[this.pos + 1] === " " || this.input[this.pos + 1] === "	") && (s = true, this.advance()), (this.peek() === " " || this.peek() === "	") && this.advance(), this.peek() === "\\" && this.pos + 1 < this.input.length && (this.input[this.pos + 1] === " " || this.input[this.pos + 1] === "	") && this.advance(), s && this.peek() === `
` && this.advance();
                let i = "";
                for(; this.pos < this.input.length;){
                    let o = this.peek();
                    if (o === `
`) {
                        if (i.endsWith("\\")) {
                            i = `${i.slice(0, -1)}
`, this.advance();
                            continue;
                        }
                        break;
                    }
                    if (o === "\\" && this.pos + 1 < this.input.length) {
                        let a = this.input[this.pos + 1];
                        if (a === "n") {
                            i += `
`, this.advance(), this.advance();
                            continue;
                        }
                        if (a === "t") {
                            i += "	", this.advance(), this.advance();
                            continue;
                        }
                        if (a === "r") {
                            i += "\r", this.advance(), this.advance();
                            continue;
                        }
                    }
                    i += this.advance();
                }
                return {
                    type: Z.TEXT_CMD,
                    value: t,
                    text: i,
                    line: n,
                    column: r
                };
            }
            readBranch(t, n, r, s) {
                for(; this.peek() === " " || this.peek() === "	";)this.advance();
                let i = "";
                for(; this.pos < this.input.length;){
                    let o = this.peek();
                    if (o === " " || o === "	" || o === `
` || o === ";" || o === "}" || o === "{") break;
                    i += this.advance();
                }
                return {
                    type: t,
                    value: n,
                    label: i || void 0,
                    line: r,
                    column: s
                };
            }
            readVersion(t, n) {
                for(; this.peek() === " " || this.peek() === "	";)this.advance();
                let r = "";
                for(; this.pos < this.input.length;){
                    let s = this.peek();
                    if (s === " " || s === "	" || s === `
` || s === ";" || s === "}" || s === "{") break;
                    r += this.advance();
                }
                return {
                    type: Z.VERSION,
                    value: "v",
                    label: r || void 0,
                    line: t,
                    column: n
                };
            }
            readFileCommand(t, n, r, s) {
                for(; this.peek() === " " || this.peek() === "	";)this.advance();
                let i = "";
                for(; this.pos < this.input.length;){
                    let o = this.peek();
                    if (o === `
` || o === ";") break;
                    i += this.advance();
                }
                return {
                    type: t,
                    value: n,
                    filename: i.trim(),
                    line: r,
                    column: s
                };
            }
            readExecute(t, n) {
                for(; this.peek() === " " || this.peek() === "	";)this.advance();
                let r = "";
                for(; this.pos < this.input.length;){
                    let s = this.peek();
                    if (s === `
` || s === ";") break;
                    r += this.advance();
                }
                return {
                    type: Z.EXECUTE,
                    value: "e",
                    command: r.trim() || void 0,
                    line: t,
                    column: n
                };
            }
            isDigit(t) {
                return t >= "0" && t <= "9";
            }
        };
    });
    function Su(e, t = false) {
        let n = false, r = false, s = [];
        for(let l = 0; l < e.length; l++){
            let c = e[l];
            if (s.length === 0 && l === 0) {
                let u = c.match(/^#([nr]+)\s*(?:\n|$)/i);
                if (u) {
                    let f = u[1].toLowerCase();
                    f.includes("n") && (n = true), f.includes("r") && (r = true), c = c.slice(u[0].length);
                }
            }
            if (s.length > 0 && s[s.length - 1].endsWith("\\")) {
                let u = s[s.length - 1];
                s[s.length - 1] = `${u}
${c}`;
            } else s.push(c);
        }
        let i = s.join(`
`), a = new no([
            i
        ], t || r).parse();
        if (!a.error && a.commands.length > 0) {
            let l = Qw(a.commands);
            if (l) return {
                commands: [],
                error: l,
                silentMode: n,
                extendedRegexMode: r
            };
        }
        return {
            ...a,
            silentMode: n,
            extendedRegexMode: r
        };
    }
    function Qw(e) {
        let t = new Set();
        Au(e, t);
        let n = Cu(e, t);
        if (n) return `undefined label '${n}'`;
    }
    function Au(e, t) {
        for (let n of e)n.type === "label" ? t.add(n.name) : n.type === "group" && Au(n.commands, t);
    }
    function Cu(e, t) {
        for (let n of e){
            if ((n.type === "branch" || n.type === "branchOnSubst" || n.type === "branchOnNoSubst") && n.label && !t.has(n.label)) return n.label;
            if (n.type === "group") {
                let r = Cu(n.commands, t);
                if (r) return r;
            }
        }
    }
    var no, Nu = v(()=>{
        Eu();
        no = class {
            scripts;
            tokens = [];
            pos = 0;
            extendedRegex = false;
            constructor(t, n = false){
                this.scripts = t, this.extendedRegex = n;
            }
            parse() {
                let t = [];
                for (let n of this.scripts){
                    let r = new cs(n);
                    for(this.tokens = r.tokenize(), this.pos = 0; !this.isAtEnd();){
                        if (this.check(Z.NEWLINE) || this.check(Z.SEMICOLON)) {
                            this.advance();
                            continue;
                        }
                        let s = this.parseCommand();
                        if (s.error) return {
                            commands: [],
                            error: s.error
                        };
                        s.command && t.push(s.command);
                    }
                }
                return {
                    commands: t
                };
            }
            parseCommand() {
                let t = this.parseAddressRange();
                if (t?.error) return {
                    command: null,
                    error: t.error
                };
                let n = t?.address;
                for(this.check(Z.NEGATION) && (this.advance(), n && (n.negated = true)); this.check(Z.NEWLINE) || this.check(Z.SEMICOLON);)this.advance();
                if (this.isAtEnd()) return n && (n.start !== void 0 || n.end !== void 0) ? {
                    command: null,
                    error: "command expected"
                } : {
                    command: null
                };
                let r = this.peek();
                switch(r.type){
                    case Z.COMMAND:
                        return this.parseSimpleCommand(r, n);
                    case Z.SUBSTITUTE:
                        return this.parseSubstituteFromToken(r, n);
                    case Z.TRANSLITERATE:
                        return this.parseTransliterateFromToken(r, n);
                    case Z.LABEL_DEF:
                        return this.advance(), {
                            command: {
                                type: "label",
                                name: r.label || ""
                            }
                        };
                    case Z.BRANCH:
                        return this.advance(), {
                            command: {
                                type: "branch",
                                address: n,
                                label: r.label
                            }
                        };
                    case Z.BRANCH_ON_SUBST:
                        return this.advance(), {
                            command: {
                                type: "branchOnSubst",
                                address: n,
                                label: r.label
                            }
                        };
                    case Z.BRANCH_ON_NO_SUBST:
                        return this.advance(), {
                            command: {
                                type: "branchOnNoSubst",
                                address: n,
                                label: r.label
                            }
                        };
                    case Z.TEXT_CMD:
                        return this.advance(), this.parseTextCommand(r, n);
                    case Z.FILE_READ:
                        return this.advance(), {
                            command: {
                                type: "readFile",
                                address: n,
                                filename: r.filename || ""
                            }
                        };
                    case Z.FILE_READ_LINE:
                        return this.advance(), {
                            command: {
                                type: "readFileLine",
                                address: n,
                                filename: r.filename || ""
                            }
                        };
                    case Z.FILE_WRITE:
                        return this.advance(), {
                            command: {
                                type: "writeFile",
                                address: n,
                                filename: r.filename || ""
                            }
                        };
                    case Z.FILE_WRITE_LINE:
                        return this.advance(), {
                            command: {
                                type: "writeFirstLine",
                                address: n,
                                filename: r.filename || ""
                            }
                        };
                    case Z.EXECUTE:
                        return this.advance(), {
                            command: {
                                type: "execute",
                                address: n,
                                command: r.command
                            }
                        };
                    case Z.VERSION:
                        return this.advance(), {
                            command: {
                                type: "version",
                                address: n,
                                minVersion: r.label
                            }
                        };
                    case Z.LBRACE:
                        return this.parseGroup(n);
                    case Z.RBRACE:
                        return {
                            command: null
                        };
                    case Z.ERROR:
                        return {
                            command: null,
                            error: `invalid command: ${r.value}`
                        };
                    default:
                        return n && (n.start !== void 0 || n.end !== void 0) ? {
                            command: null,
                            error: "command expected"
                        } : {
                            command: null
                        };
                }
            }
            parseSimpleCommand(t, n) {
                this.advance();
                let r = t.value;
                switch(r){
                    case "p":
                        return {
                            command: {
                                type: "print",
                                address: n
                            }
                        };
                    case "P":
                        return {
                            command: {
                                type: "printFirstLine",
                                address: n
                            }
                        };
                    case "d":
                        return {
                            command: {
                                type: "delete",
                                address: n
                            }
                        };
                    case "D":
                        return {
                            command: {
                                type: "deleteFirstLine",
                                address: n
                            }
                        };
                    case "h":
                        return {
                            command: {
                                type: "hold",
                                address: n
                            }
                        };
                    case "H":
                        return {
                            command: {
                                type: "holdAppend",
                                address: n
                            }
                        };
                    case "g":
                        return {
                            command: {
                                type: "get",
                                address: n
                            }
                        };
                    case "G":
                        return {
                            command: {
                                type: "getAppend",
                                address: n
                            }
                        };
                    case "x":
                        return {
                            command: {
                                type: "exchange",
                                address: n
                            }
                        };
                    case "n":
                        return {
                            command: {
                                type: "next",
                                address: n
                            }
                        };
                    case "N":
                        return {
                            command: {
                                type: "nextAppend",
                                address: n
                            }
                        };
                    case "q":
                        return {
                            command: {
                                type: "quit",
                                address: n
                            }
                        };
                    case "Q":
                        return {
                            command: {
                                type: "quitSilent",
                                address: n
                            }
                        };
                    case "z":
                        return {
                            command: {
                                type: "zap",
                                address: n
                            }
                        };
                    case "=":
                        return {
                            command: {
                                type: "lineNumber",
                                address: n
                            }
                        };
                    case "l":
                        return {
                            command: {
                                type: "list",
                                address: n
                            }
                        };
                    case "F":
                        return {
                            command: {
                                type: "printFilename",
                                address: n
                            }
                        };
                    default:
                        return {
                            command: null,
                            error: `unknown command: ${r}`
                        };
                }
            }
            parseSubstituteFromToken(t, n) {
                this.advance();
                let r = t.flags || "", s, i = r.match(/(\d+)/);
                return i && (s = parseInt(i[1], 10)), {
                    command: {
                        type: "substitute",
                        address: n,
                        pattern: t.pattern || "",
                        replacement: t.replacement || "",
                        global: r.includes("g"),
                        ignoreCase: r.includes("i") || r.includes("I"),
                        printOnMatch: r.includes("p"),
                        nthOccurrence: s,
                        extendedRegex: this.extendedRegex
                    }
                };
            }
            parseTransliterateFromToken(t, n) {
                this.advance();
                let r = t.source || "", s = t.dest || "";
                return r.length !== s.length ? {
                    command: null,
                    error: "transliteration sets must have same length"
                } : {
                    command: {
                        type: "transliterate",
                        address: n,
                        source: r,
                        dest: s
                    }
                };
            }
            parseTextCommand(t, n) {
                let r = t.value, s = t.text || "";
                switch(r){
                    case "a":
                        return {
                            command: {
                                type: "append",
                                address: n,
                                text: s
                            }
                        };
                    case "i":
                        return {
                            command: {
                                type: "insert",
                                address: n,
                                text: s
                            }
                        };
                    case "c":
                        return {
                            command: {
                                type: "change",
                                address: n,
                                text: s
                            }
                        };
                    default:
                        return {
                            command: null,
                            error: `unknown text command: ${r}`
                        };
                }
            }
            parseGroup(t) {
                this.advance();
                let n = [];
                for(; !this.isAtEnd() && !this.check(Z.RBRACE);){
                    if (this.check(Z.NEWLINE) || this.check(Z.SEMICOLON)) {
                        this.advance();
                        continue;
                    }
                    let r = this.parseCommand();
                    if (r.error) return {
                        command: null,
                        error: r.error
                    };
                    r.command && n.push(r.command);
                }
                return this.check(Z.RBRACE) ? (this.advance(), {
                    command: {
                        type: "group",
                        address: t,
                        commands: n
                    }
                }) : {
                    command: null,
                    error: "unmatched brace in grouped commands"
                };
            }
            parseAddressRange() {
                let t = this.parseAddress();
                if (t === void 0) return;
                let n;
                if (this.check(Z.RELATIVE_OFFSET)) n = {
                    offset: this.advance().offset || 0
                };
                else if (this.check(Z.COMMA) && (this.advance(), n = this.parseAddress(), n === void 0)) return {
                    error: "expected context address"
                };
                return {
                    address: {
                        start: t,
                        end: n
                    }
                };
            }
            parseAddress() {
                let t = this.peek();
                switch(t.type){
                    case Z.NUMBER:
                        return this.advance(), t.value;
                    case Z.DOLLAR:
                        return this.advance(), "$";
                    case Z.PATTERN:
                        return this.advance(), {
                            pattern: t.pattern || t.value
                        };
                    case Z.STEP:
                        return this.advance(), {
                            first: t.first || 0,
                            step: t.step || 0
                        };
                    case Z.RELATIVE_OFFSET:
                        return this.advance(), {
                            offset: t.offset || 0
                        };
                    default:
                        return;
                }
            }
            peek() {
                return this.tokens[this.pos] || {
                    type: Z.EOF,
                    value: "",
                    line: 0,
                    column: 0
                };
            }
            advance() {
                return this.isAtEnd() || this.pos++, this.tokens[this.pos - 1];
            }
            check(t) {
                return this.peek().type === t;
            }
            isAtEnd() {
                return this.peek().type === Z.EOF;
            }
        };
    });
    var ku = {};
    V(ku, {
        sedCommand: ()=>Xw
    });
    async function ro(e, t, n, r = {}) {
        let { limits: s, filename: i, fs: o, cwd: a } = r, l = e.endsWith(`
`), c = e.split(`
`);
        c.length > 0 && c[c.length - 1] === "" && c.pop();
        let u = c.length, f = "", p, d = false, m = "", h, g = new Map(), b = new Map(), y = new Map(), w = new Map(), E = s ? {
            maxIterations: s.maxSedIterations
        } : void 0;
        for(let C = 0; C < c.length; C++){
            let A = {
                ...wu(u, i, g),
                patternSpace: c[C],
                holdSpace: m,
                lastPattern: h,
                lineNumber: C + 1,
                totalLines: u,
                substitutionMade: false
            }, I = {
                lines: c,
                currentLineIndex: C
            }, O = 0, L = 1e4;
            A.linesConsumedInCycle = 0;
            do {
                if (O++, O > L) break;
                if (A.restartCycle = false, A.pendingFileReads = [], A.pendingFileWrites = [], to(t, A, I, E), o && a) {
                    for (let R of A.pendingFileReads){
                        let T = o.resolvePath(a, R.filename);
                        try {
                            if (R.wholeFile) {
                                let Y = await o.readFile(T);
                                A.appendBuffer.push(Y.replace(/\n$/, ""));
                            } else {
                                if (!b.has(T)) {
                                    let K = await o.readFile(T);
                                    b.set(T, K.split(`
`)), y.set(T, 0);
                                }
                                let Y = b.get(T), ie = y.get(T);
                                Y && ie !== void 0 && ie < Y.length && (A.appendBuffer.push(Y[ie]), y.set(T, ie + 1));
                            }
                        } catch  {}
                    }
                    for (let R of A.pendingFileWrites){
                        let T = o.resolvePath(a, R.filename), Y = w.get(T) || "";
                        w.set(T, Y + R.content);
                    }
                }
            }while (A.restartCycle && !A.deleted && !A.quit && !A.quitSilent);
            if (C += A.linesConsumedInCycle, m = A.holdSpace, h = A.lastPattern, !n) for (let R of A.nCommandOutput)f += `${R}
`;
            let D = A.lineNumberOutput.length > 0;
            for (let R of A.lineNumberOutput)f += `${R}
`;
            let $ = [], N = [];
            for (let R of A.appendBuffer)R.startsWith("__INSERT__") ? $.push(R.slice(10)) : N.push(R);
            for (let R of $)f += `${R}
`;
            let P = false;
            !A.deleted && !A.quitSilent ? n ? A.printed && (f += `${A.patternSpace}
`, P = true) : (f += `${A.patternSpace}
`, P = true) : A.changedText !== void 0 && (f += `${A.changedText}
`, P = true);
            for (let R of N)f += `${R}
`;
            if (d = (D || P) && N.length === 0, A.quit || A.quitSilent) {
                if (A.exitCode !== void 0 && (p = A.exitCode), A.errorMessage) return {
                    output: "",
                    exitCode: p || 1,
                    errorMessage: A.errorMessage
                };
                break;
            }
        }
        if (o && a) for (let [C, A] of w)try {
            await o.writeFile(C, A);
        } catch  {}
        return !l && d && f.endsWith(`
`) && (f = f.slice(0, -1)), {
            output: f,
            exitCode: p
        };
    }
    var Kw, Xw, vu = v(()=>{
        de();
        X();
        xu();
        Nu();
        Kw = {
            name: "sed",
            summary: "stream editor for filtering and transforming text",
            usage: "sed [OPTION]... {script} [input-file]...",
            options: [
                "-n, --quiet, --silent  suppress automatic printing of pattern space",
                "-e script              add the script to commands to be executed",
                "-f script-file         read script from file",
                "-i, --in-place         edit files in place",
                "-E, -r, --regexp-extended  use extended regular expressions",
                "    --help             display this help and exit"
            ],
            description: `Commands:
  s/regexp/replacement/[flags]  substitute
  d                             delete pattern space
  p                             print pattern space
  a\\ text                       append text after line
  i\\ text                       insert text before line
  c\\ text                       change (replace) line with text
  h                             copy pattern space to hold space
  H                             append pattern space to hold space
  g                             copy hold space to pattern space
  G                             append hold space to pattern space
  x                             exchange pattern and hold spaces
  n                             read next line into pattern space
  N                             append next line to pattern space
  y/source/dest/                transliterate characters
  =                             print line number
  l                             list pattern space (escape special chars)
  b [label]                     branch to label
  t [label]                     branch on substitution
  T [label]                     branch if no substitution
  :label                        define label
  q                             quit
  Q                             quit without printing

Addresses:
  N                             line number
  $                             last line
  /regexp/                      lines matching regexp
  N,M                           range from line N to M
  first~step                    every step-th line starting at first`
        };
        Xw = {
            name: "sed",
            async execute (e, t) {
                if (_(e)) return F(Kw);
                let n = [], r = [], s = false, i = false, o = false, a = [];
                for(let m = 0; m < e.length; m++){
                    let h = e[m];
                    if (h === "-n" || h === "--quiet" || h === "--silent") s = true;
                    else if (h === "-i" || h === "--in-place") i = true;
                    else if (h.startsWith("-i")) i = true;
                    else if (h === "-E" || h === "-r" || h === "--regexp-extended") o = true;
                    else if (h === "-e") m + 1 < e.length && n.push(e[++m]);
                    else if (h === "-f") m + 1 < e.length && r.push(e[++m]);
                    else {
                        if (h.startsWith("--")) return G("sed", h);
                        if (h === "-") a.push(h);
                        else if (h.startsWith("-") && h.length > 1) {
                            for (let g of h.slice(1))if (g !== "n" && g !== "e" && g !== "f" && g !== "i" && g !== "E" && g !== "r") return G("sed", `-${g}`);
                            h.includes("n") && (s = true), h.includes("i") && (i = true), (h.includes("E") || h.includes("r")) && (o = true), h.includes("e") && !h.includes("n") && !h.includes("i") && m + 1 < e.length && n.push(e[++m]), h.includes("f") && !h.includes("e") && m + 1 < e.length && r.push(e[++m]);
                        } else !h.startsWith("-") && n.length === 0 && r.length === 0 ? n.push(h) : h.startsWith("-") || a.push(h);
                    }
                }
                for (let m of r){
                    let h = t.fs.resolvePath(t.cwd, m);
                    try {
                        let g = await t.fs.readFile(h);
                        for (let b of g.split(`
`)){
                            let y = b.trim();
                            y && !y.startsWith("#") && n.push(y);
                        }
                    } catch  {
                        return {
                            stdout: "",
                            stderr: `sed: couldn't open file ${m}: No such file or directory
`,
                            exitCode: 1
                        };
                    }
                }
                if (n.length === 0) return {
                    stdout: "",
                    stderr: `sed: no script specified
`,
                    exitCode: 1
                };
                let { commands: l, error: c, silentMode: u } = Su(n, o);
                if (c) return {
                    stdout: "",
                    stderr: `sed: ${c}
`,
                    exitCode: 1
                };
                let f = !!(s || u);
                if (i) {
                    if (a.length === 0) return {
                        stdout: "",
                        stderr: `sed: -i requires at least one file argument
`,
                        exitCode: 1
                    };
                    for (let m of a){
                        if (m === "-") continue;
                        let h = t.fs.resolvePath(t.cwd, m);
                        try {
                            let g = await t.fs.readFile(h), b = await ro(g, l, f, {
                                limits: t.limits,
                                filename: m,
                                fs: t.fs,
                                cwd: t.cwd
                            });
                            if (b.errorMessage) return {
                                stdout: "",
                                stderr: `${b.errorMessage}
`,
                                exitCode: b.exitCode ?? 1
                            };
                            await t.fs.writeFile(h, b.output);
                        } catch (g) {
                            return g instanceof ne ? {
                                stdout: "",
                                stderr: `sed: ${g.message}
`,
                                exitCode: ne.EXIT_CODE
                            } : {
                                stdout: "",
                                stderr: `sed: ${m}: No such file or directory
`,
                                exitCode: 1
                            };
                        }
                    }
                    return {
                        stdout: "",
                        stderr: "",
                        exitCode: 0
                    };
                }
                let p = "";
                if (a.length === 0) {
                    p = t.stdin;
                    try {
                        let m = await ro(p, l, f, {
                            limits: t.limits,
                            fs: t.fs,
                            cwd: t.cwd
                        });
                        return {
                            stdout: m.output,
                            stderr: m.errorMessage ? `${m.errorMessage}
` : "",
                            exitCode: m.exitCode ?? 0
                        };
                    } catch (m) {
                        if (m instanceof ne) return {
                            stdout: "",
                            stderr: `sed: ${m.message}
`,
                            exitCode: ne.EXIT_CODE
                        };
                        throw m;
                    }
                }
                let d = false;
                for (let m of a){
                    let h;
                    if (m === "-") d ? h = "" : (h = t.stdin, d = true);
                    else {
                        let g = t.fs.resolvePath(t.cwd, m);
                        try {
                            h = await t.fs.readFile(g);
                        } catch (b) {
                            return b instanceof ne ? {
                                stdout: "",
                                stderr: `sed: ${b.message}
`,
                                exitCode: ne.EXIT_CODE
                            } : {
                                stdout: "",
                                stderr: `sed: ${m}: No such file or directory
`,
                                exitCode: 1
                            };
                        }
                    }
                    p.length > 0 && h.length > 0 && !p.endsWith(`
`) && (p += `
`), p += h;
                }
                try {
                    let m = await ro(p, l, f, {
                        limits: t.limits,
                        filename: a.length === 1 ? a[0] : void 0,
                        fs: t.fs,
                        cwd: t.cwd
                    });
                    return {
                        stdout: m.output,
                        stderr: m.errorMessage ? `${m.errorMessage}
` : "",
                        exitCode: m.exitCode ?? 0
                    };
                } catch (m) {
                    if (m instanceof ne) return {
                        stdout: "",
                        stderr: `sed: ${m.message}
`,
                        exitCode: ne.EXIT_CODE
                    };
                    throw m;
                }
            }
        };
    });
    function so(e = {}) {
        let { fieldSep: t = /\s+/, maxIterations: n = 1e4, maxRecursionDepth: r = 100, fs: s, cwd: i, exec: o } = e;
        return {
            FS: " ",
            OFS: " ",
            ORS: `
`,
            OFMT: "%.6g",
            NR: 0,
            NF: 0,
            FNR: 0,
            FILENAME: "",
            RSTART: 0,
            RLENGTH: -1,
            SUBSEP: "",
            fields: [],
            line: "",
            vars: {},
            arrays: {},
            arrayAliases: new Map(),
            ARGC: 0,
            ARGV: {},
            ENVIRON: {},
            functions: new Map(),
            fieldSep: t,
            maxIterations: n,
            maxRecursionDepth: r,
            currentRecursionDepth: 0,
            exitCode: 0,
            shouldExit: false,
            shouldNext: false,
            shouldNextFile: false,
            loopBreak: false,
            loopContinue: false,
            hasReturn: false,
            inEndBlock: false,
            output: "",
            openedFiles: new Set(),
            fs: s,
            cwd: i,
            exec: o
        };
    }
    var $u = v(()=>{});
    function Iu(e, t, n) {
        switch(n){
            case "+":
                return e + t;
            case "-":
                return e - t;
            case "*":
                return e * t;
            case "/":
                return t !== 0 ? e / t : 0;
            case "%":
                return t !== 0 ? e % t : 0;
            case "^":
            case "**":
                return e ** t;
            default:
                return 0;
        }
    }
    var Ru = v(()=>{});
    function Nt(e) {
        if (typeof e == "number") return e;
        let t = parseFloat(e);
        return Number.isNaN(t) ? 0 : t;
    }
    function qe(e) {
        return typeof e == "string" ? e : (String(e));
    }
    async function us(e, t) {
        if (e.type === "regex") return e.pattern;
        let n = qe(await t.evalExpr(e));
        return n.startsWith("/") && n.endsWith("/") && (n = n.slice(1, -1)), n;
    }
    async function Tu(e, t) {
        return e ? e.type === "variable" ? e.name : e.type === "field" ? `$${Math.floor(Nt(await t.evalExpr(e.index)))}` : "$0" : "$0";
    }
    function Ou(e, t) {
        if (e === "$0") return t.line;
        if (e.startsWith("$")) {
            let n = parseInt(e.slice(1), 10) - 1;
            return t.fields[n] || "";
        }
        return qe(t.vars[e] ?? "");
    }
    function Du(e, t, n) {
        if (e === "$0") n.line = t, n.fields = n.FS === " " ? t.trim().split(/\s+/).filter(Boolean) : t.split(n.fieldSep), n.NF = n.fields.length;
        else if (e.startsWith("$")) {
            let r = parseInt(e.slice(1), 10) - 1;
            for(; n.fields.length <= r;)n.fields.push("");
            n.fields[r] = t, n.NF = n.fields.length, n.line = n.fields.join(n.OFS);
        } else n.vars[e] = t;
    }
    async function Jw(e, t, n) {
        return e.length === 0 ? t.line.length : qe(await n.evalExpr(e[0])).length;
    }
    async function Yw(e, t, n) {
        if (e.length < 2) return "";
        let r = qe(await n.evalExpr(e[0])), s = Math.floor(Nt(await n.evalExpr(e[1]))) - 1;
        if (e.length >= 3) {
            let i = Math.floor(Nt(await n.evalExpr(e[2])));
            return r.substr(Math.max(0, s), i);
        }
        return r.substr(Math.max(0, s));
    }
    async function ex(e, t, n) {
        if (e.length < 2) return 0;
        let r = qe(await n.evalExpr(e[0])), s = qe(await n.evalExpr(e[1])), i = r.indexOf(s);
        return i === -1 ? 0 : i + 1;
    }
    async function tx(e, t, n) {
        if (e.length < 2) return 0;
        let r = qe(await n.evalExpr(e[0])), s = e[1];
        if (s.type !== "variable") return 0;
        let i = s.name, o = t.FS;
        if (e.length >= 3) {
            let l = e[2];
            if (l.type === "regex") o = new RegExp(l.pattern);
            else {
                let c = qe(await n.evalExpr(l));
                o = c === " " ? /\s+/ : c;
            }
        } else t.FS === " " && (o = /\s+/);
        let a = r.split(o);
        t.arrays[i] = {};
        for(let l = 0; l < a.length; l++)t.arrays[i][String(l + 1)] = a[l];
        return a.length;
    }
    async function nx(e, t, n) {
        if (e.length < 2) return 0;
        let r = await us(e[0], n), s = qe(await n.evalExpr(e[1])), i = await Tu(e[2], n), o = Ou(i, t);
        try {
            let a = new RegExp(r), l = o.replace(a, Fu(s)), c = l !== o ? 1 : 0;
            return Du(i, l, t), c;
        } catch  {
            return 0;
        }
    }
    async function rx(e, t, n) {
        if (e.length < 2) return 0;
        let r = await us(e[0], n), s = qe(await n.evalExpr(e[1])), i = await Tu(e[2], n), o = Ou(i, t);
        try {
            let a = new RegExp(r, "g"), l = o.match(a), c = l ? l.length : 0, u = o.replace(a, Fu(s));
            return Du(i, u, t), c;
        } catch  {
            return 0;
        }
    }
    function Fu(e) {
        return (t)=>{
            let n = "", r = 0;
            for(; r < e.length;)if (e[r] === "\\" && r + 1 < e.length) {
                let s = e[r + 1];
                s === "&" ? (n += "&", r += 2) : s === "\\" ? (n += "\\", r += 2) : (n += e[r + 1], r += 2);
            } else e[r] === "&" ? (n += t, r++) : (n += e[r], r++);
            return n;
        };
    }
    async function sx(e, t, n) {
        if (e.length < 2) return t.RSTART = 0, t.RLENGTH = -1, 0;
        let r = qe(await n.evalExpr(e[0])), s = await us(e[1], n);
        try {
            let o = new RegExp(s).exec(r);
            if (o) return t.RSTART = o.index + 1, t.RLENGTH = o[0].length, t.RSTART;
        } catch  {}
        return t.RSTART = 0, t.RLENGTH = -1, 0;
    }
    async function ix(e, t, n) {
        if (e.length < 3) return "";
        let r = await us(e[0], n), s = qe(await n.evalExpr(e[1])), i = qe(await n.evalExpr(e[2])), o = e.length >= 4 ? qe(await n.evalExpr(e[3])) : t.line;
        try {
            let a = i.toLowerCase() === "g", l = a ? 0 : parseInt(i, 10) || 1;
            if (a) {
                let c = new RegExp(r, "g");
                return o.replace(c, (u, ...f)=>Pu(s, u, f.slice(0, -2)));
            } else {
                let c = 0, u = new RegExp(r, "g");
                return o.replace(u, (f, ...p)=>(c++, c === l ? Pu(s, f, p.slice(0, -2)) : f));
            }
        } catch  {
            return o;
        }
    }
    function Pu(e, t, n) {
        let r = "", s = 0;
        for(; s < e.length;)if (e[s] === "\\" && s + 1 < e.length) {
            let i = e[s + 1];
            if (i === "&") r += "&", s += 2;
            else if (i === "0") r += t, s += 2;
            else if (i >= "1" && i <= "9") {
                let o = parseInt(i, 10) - 1;
                r += n[o] || "", s += 2;
            } else i === "n" ? (r += `
`, s += 2) : i === "t" ? (r += "	", s += 2) : (r += i, s += 2);
        } else e[s] === "&" ? (r += t, s++) : (r += e[s], s++);
        return r;
    }
    async function ox(e, t, n) {
        return e.length === 0 ? "" : qe(await n.evalExpr(e[0])).toLowerCase();
    }
    async function ax(e, t, n) {
        return e.length === 0 ? "" : qe(await n.evalExpr(e[0])).toUpperCase();
    }
    async function lx(e, t, n) {
        if (e.length === 0) return "";
        let r = qe(await n.evalExpr(e[0])), s = [];
        for(let i = 1; i < e.length; i++)s.push(await n.evalExpr(e[i]));
        return fs(r, s);
    }
    async function cx(e, t, n) {
        return e.length === 0 ? 0 : Math.floor(Nt(await n.evalExpr(e[0])));
    }
    async function ux(e, t, n) {
        return e.length === 0 ? 0 : Math.sqrt(Nt(await n.evalExpr(e[0])));
    }
    async function fx(e, t, n) {
        return e.length === 0 ? 0 : Math.sin(Nt(await n.evalExpr(e[0])));
    }
    async function px(e, t, n) {
        return e.length === 0 ? 0 : Math.cos(Nt(await n.evalExpr(e[0])));
    }
    async function dx(e, t, n) {
        let r = e.length > 0 ? Nt(await n.evalExpr(e[0])) : 0, s = e.length > 1 ? Nt(await n.evalExpr(e[1])) : 0;
        return Math.atan2(r, s);
    }
    async function hx(e, t, n) {
        return e.length === 0 ? 0 : Math.log(Nt(await n.evalExpr(e[0])));
    }
    async function mx(e, t, n) {
        return e.length === 0 ? 1 : Math.exp(Nt(await n.evalExpr(e[0])));
    }
    function gx(e, t, n) {
        return t.random ? t.random() : Math.random();
    }
    async function yx(e, t, n) {
        let r = e.length > 0 ? Nt(await n.evalExpr(e[0])) : Date.now();
        return t.vars._srand_seed = r, r;
    }
    function bx(e, t) {
        return ()=>{
            throw new Error(`${e}() is not supported - ${t}`);
        };
    }
    function io(e) {
        return ()=>{
            throw new Error(`function '${e}()' is not implemented`);
        };
    }
    function fs(e, t) {
        let n = 0, r = "", s = 0;
        for(; s < e.length;)if (e[s] === "%" && s + 1 < e.length) {
            let i = s + 1, o = "", a = "", l = "", c, u = i;
            for(; i < e.length && /\d/.test(e[i]);)i++;
            i > u && e[i] === "$" ? (c = parseInt(e.substring(u, i), 10) - 1, i++) : i = u;
            let f = ()=>{
                if (i < e.length) {
                    if (i + 1 < e.length && (e[i] === "h" && e[i + 1] === "h" || e[i] === "l" && e[i + 1] === "l")) {
                        i += 2;
                        return;
                    }
                    /[lzjh]/.test(e[i]) && i++;
                }
            };
            for(; i < e.length && /[-+ #0]/.test(e[i]);)o += e[i++];
            if (e[i] === "*") {
                let h = t[n++], g = h !== void 0 ? Math.floor(Number(h)) : 0;
                g < 0 ? (o += "-", a = String(-g)) : a = String(g), i++;
            } else for(; i < e.length && /\d/.test(e[i]);)a += e[i++];
            if (e[i] === ".") if (i++, e[i] === "*") {
                let h = t[n++];
                l = String(h !== void 0 ? Math.floor(Number(h)) : 0), i++;
            } else for(; i < e.length && /\d/.test(e[i]);)l += e[i++];
            f();
            let p = e[i], m = t[c !== void 0 ? c : n];
            switch(p){
                case "s":
                    {
                        let h = m !== void 0 ? String(m) : "";
                        if (l && (h = h.substring(0, parseInt(l, 10))), a) {
                            let g = parseInt(a, 10);
                            o.includes("-") ? h = h.padEnd(g) : h = h.padStart(g);
                        }
                        r += h, c === void 0 && n++;
                        break;
                    }
                case "d":
                case "i":
                    {
                        let h = m !== void 0 ? Math.floor(Number(m)) : 0;
                        Number.isNaN(h) && (h = 0);
                        let g = h < 0, b = Math.abs(h).toString();
                        if (l) {
                            let E = parseInt(l, 10);
                            b = b.padStart(E, "0");
                        }
                        let y = "";
                        g ? y = "-" : o.includes("+") ? y = "+" : o.includes(" ") && (y = " ");
                        let w = y + b;
                        if (a) {
                            let E = parseInt(a, 10);
                            o.includes("-") ? w = w.padEnd(E) : o.includes("0") && !l ? w = y + b.padStart(E - y.length, "0") : w = w.padStart(E);
                        }
                        r += w, c === void 0 && n++;
                        break;
                    }
                case "f":
                    {
                        let h = m !== void 0 ? Number(m) : 0;
                        Number.isNaN(h) && (h = 0);
                        let g = l ? parseInt(l, 10) : 6, b = h.toFixed(g);
                        if (a) {
                            let y = parseInt(a, 10);
                            o.includes("-") ? b = b.padEnd(y) : b = b.padStart(y);
                        }
                        r += b, c === void 0 && n++;
                        break;
                    }
                case "e":
                case "E":
                    {
                        let h = m !== void 0 ? Number(m) : 0;
                        Number.isNaN(h) && (h = 0);
                        let g = l ? parseInt(l, 10) : 6, b = h.toExponential(g);
                        if (p === "E" && (b = b.toUpperCase()), a) {
                            let y = parseInt(a, 10);
                            o.includes("-") ? b = b.padEnd(y) : b = b.padStart(y);
                        }
                        r += b, c === void 0 && n++;
                        break;
                    }
                case "g":
                case "G":
                    {
                        let h = m !== void 0 ? Number(m) : 0;
                        Number.isNaN(h) && (h = 0);
                        let g = l ? parseInt(l, 10) : 6, b = h !== 0 ? Math.floor(Math.log10(Math.abs(h))) : 0, y;
                        if (h === 0 ? y = "0" : b < -4 || b >= g ? (y = h.toExponential(g - 1), p === "G" && (y = y.toUpperCase())) : y = h.toPrecision(g), y.includes(".") && (y = y.replace(/\.?0+$/, "").replace(/\.?0+e/, "e")), y.includes("e") && (y = y.replace(/\.?0+e/, "e")), a) {
                            let w = parseInt(a, 10);
                            o.includes("-") ? y = y.padEnd(w) : y = y.padStart(w);
                        }
                        r += y, c === void 0 && n++;
                        break;
                    }
                case "x":
                case "X":
                    {
                        let h = m !== void 0 ? Math.floor(Number(m)) : 0;
                        Number.isNaN(h) && (h = 0);
                        let g = Math.abs(h).toString(16);
                        if (p === "X" && (g = g.toUpperCase()), l) {
                            let w = parseInt(l, 10);
                            g = g.padStart(w, "0");
                        }
                        let b = h < 0 ? "-" : "", y = b + g;
                        if (a) {
                            let w = parseInt(a, 10);
                            o.includes("-") ? y = y.padEnd(w) : o.includes("0") && !l ? y = b + g.padStart(w - b.length, "0") : y = y.padStart(w);
                        }
                        r += y, c === void 0 && n++;
                        break;
                    }
                case "o":
                    {
                        let h = m !== void 0 ? Math.floor(Number(m)) : 0;
                        Number.isNaN(h) && (h = 0);
                        let g = Math.abs(h).toString(8);
                        if (l) {
                            let w = parseInt(l, 10);
                            g = g.padStart(w, "0");
                        }
                        let b = h < 0 ? "-" : "", y = b + g;
                        if (a) {
                            let w = parseInt(a, 10);
                            o.includes("-") ? y = y.padEnd(w) : o.includes("0") && !l ? y = b + g.padStart(w - b.length, "0") : y = y.padStart(w);
                        }
                        r += y, c === void 0 && n++;
                        break;
                    }
                case "c":
                    {
                        typeof m == "number" ? r += String.fromCharCode(m) : r += String(m ?? "").charAt(0) || "", c === void 0 && n++;
                        break;
                    }
                case "%":
                    r += "%";
                    break;
                default:
                    r += e.substring(s, i + 1);
            }
            s = i + 1;
        } else if (e[s] === "\\" && s + 1 < e.length) {
            let i = e[s + 1];
            switch(i){
                case "n":
                    r += `
`;
                    break;
                case "t":
                    r += "	";
                    break;
                case "r":
                    r += "\r";
                    break;
                case "\\":
                    r += "\\";
                    break;
                default:
                    r += i;
            }
            s += 2;
        } else r += e[s++];
        return r;
    }
    var _u, oo = v(()=>{
        _u = {
            length: Jw,
            substr: Yw,
            index: ex,
            split: tx,
            sub: nx,
            gsub: rx,
            match: sx,
            gensub: ix,
            tolower: ox,
            toupper: ax,
            sprintf: lx,
            int: cx,
            sqrt: ux,
            sin: fx,
            cos: px,
            atan2: dx,
            log: hx,
            exp: mx,
            rand: gx,
            srand: yx,
            system: bx("system", "shell execution not allowed in sandboxed environment"),
            close: ()=>0,
            fflush: ()=>0,
            systime: io("systime"),
            mktime: io("mktime"),
            strftime: io("strftime")
        };
    });
    function rt(e) {
        return typeof e == "number" ? e !== 0 : !(e === "" || e === "0");
    }
    function Ie(e) {
        if (typeof e == "number") return e;
        let t = parseFloat(e);
        return Number.isNaN(t) ? 0 : t;
    }
    function we(e) {
        return typeof e == "string" ? e : (String(e));
    }
    function ao(e) {
        if (typeof e == "number") return true;
        let t = String(e).trim();
        return t === "" ? false : !Number.isNaN(Number(t));
    }
    function br(e, t) {
        try {
            return new RegExp(e).test(t);
        } catch  {
            return false;
        }
    }
    var Ln = v(()=>{});
    function Lu(e, t) {
        return t === "" ? [] : e.FS === " " ? t.trim().split(/\s+/).filter(Boolean) : t.split(e.fieldSep);
    }
    function ps(e, t) {
        return t === 0 ? e.line : t < 0 || t > e.fields.length ? "" : e.fields[t - 1] ?? "";
    }
    function lo(e, t, n) {
        if (t === 0) e.line = we(n), e.fields = Lu(e, e.line), e.NF = e.fields.length;
        else if (t > 0) {
            for(; e.fields.length < t;)e.fields.push("");
            e.fields[t - 1] = we(n), e.NF = e.fields.length, e.line = e.fields.join(e.OFS);
        }
    }
    function Mn(e, t) {
        e.line = t, e.fields = Lu(e, t), e.NF = e.fields.length;
    }
    function Mu(e, t) {
        if (e.FS = t, t === " ") e.fieldSep = /\s+/;
        else try {
            e.fieldSep = new RegExp(t);
        } catch  {
            e.fieldSep = new RegExp(t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
        }
    }
    var ds = v(()=>{
        Ln();
    });
    function hs(e, t) {
        switch(t){
            case "FS":
                return e.FS;
            case "OFS":
                return e.OFS;
            case "ORS":
                return e.ORS;
            case "OFMT":
                return e.OFMT;
            case "NR":
                return e.NR;
            case "NF":
                return e.NF;
            case "FNR":
                return e.FNR;
            case "FILENAME":
                return e.FILENAME;
            case "RSTART":
                return e.RSTART;
            case "RLENGTH":
                return e.RLENGTH;
            case "SUBSEP":
                return e.SUBSEP;
            case "ARGC":
                return e.ARGC;
        }
        return e.vars[t] ?? "";
    }
    function Wn(e, t, n) {
        switch(t){
            case "FS":
                Mu(e, we(n));
                return;
            case "OFS":
                e.OFS = we(n);
                return;
            case "ORS":
                e.ORS = we(n);
                return;
            case "OFMT":
                e.OFMT = we(n);
                return;
            case "NR":
                e.NR = Math.floor(Ie(n));
                return;
            case "NF":
                {
                    let r = Math.floor(Ie(n));
                    if (r < e.NF) e.fields = e.fields.slice(0, r), e.line = e.fields.join(e.OFS);
                    else if (r > e.NF) {
                        for(; e.fields.length < r;)e.fields.push("");
                        e.line = e.fields.join(e.OFS);
                    }
                    e.NF = r;
                    return;
                }
            case "FNR":
                e.FNR = Math.floor(Ie(n));
                return;
            case "FILENAME":
                e.FILENAME = we(n);
                return;
            case "RSTART":
                e.RSTART = Math.floor(Ie(n));
                return;
            case "RLENGTH":
                e.RLENGTH = Math.floor(Ie(n));
                return;
            case "SUBSEP":
                e.SUBSEP = we(n);
                return;
        }
        e.vars[t] = n;
    }
    function wr(e, t) {
        let n = t, r = new Set(), s = e.arrayAliases.get(n);
        for(; s !== void 0 && !r.has(n);)r.add(n), n = s, s = e.arrayAliases.get(n);
        return n;
    }
    function ms(e, t, n) {
        if (t === "ARGV") return e.ARGV[n] ?? "";
        if (t === "ENVIRON") return e.ENVIRON[n] ?? "";
        let r = wr(e, t);
        return e.arrays[r]?.[n] ?? "";
    }
    function co(e, t, n, r) {
        let s = wr(e, t);
        e.arrays[s] || (e.arrays[s] = {}), e.arrays[s][n] = r;
    }
    function Wu(e, t, n) {
        if (t === "ARGV") return e.ARGV[n] !== void 0;
        if (t === "ENVIRON") return e.ENVIRON[n] !== void 0;
        let r = wr(e, t);
        return e.arrays[r]?.[n] !== void 0;
    }
    function Bu(e, t, n) {
        let r = wr(e, t);
        e.arrays[r] && delete e.arrays[r][n];
    }
    function Uu(e, t) {
        let n = wr(e, t);
        delete e.arrays[n];
    }
    var uo = v(()=>{
        ds();
        Ln();
    });
    function zu(e) {
        fo = e;
    }
    async function re(e, t) {
        switch(t.type){
            case "number":
                return t.value;
            case "string":
                return t.value;
            case "regex":
                return br(t.pattern, e.line) ? 1 : 0;
            case "field":
                return wx(e, t);
            case "variable":
                return hs(e, t.name);
            case "array_access":
                return xx(e, t);
            case "binary":
                return Ex(e, t);
            case "unary":
                return Cx(e, t);
            case "ternary":
                return rt(await re(e, t.condition)) ? await re(e, t.consequent) : await re(e, t.alternate);
            case "call":
                return Nx(e, t.name, t.args);
            case "assignment":
                return vx(e, t);
            case "pre_increment":
                return $x(e, t.operand);
            case "pre_decrement":
                return Ix(e, t.operand);
            case "post_increment":
                return Rx(e, t.operand);
            case "post_decrement":
                return Px(e, t.operand);
            case "in":
                return Tx(e, t.key, t.array);
            case "getline":
                return Ox(e, t.variable, t.file, t.command);
            case "tuple":
                return _x(e, t.elements);
            default:
                return "";
        }
    }
    async function wx(e, t) {
        let n = Math.floor(Ie(await re(e, t.index)));
        return ps(e, n);
    }
    async function xx(e, t) {
        let n = we(await re(e, t.key));
        return ms(e, t.array, n);
    }
    async function Ex(e, t) {
        let n = t.operator;
        if (n === "||") return rt(await re(e, t.left)) || rt(await re(e, t.right)) ? 1 : 0;
        if (n === "&&") return rt(await re(e, t.left)) && rt(await re(e, t.right)) ? 1 : 0;
        if (n === "~") {
            let a = await re(e, t.left), l = t.right.type === "regex" ? t.right.pattern : we(await re(e, t.right));
            try {
                return new RegExp(l).test(we(a)) ? 1 : 0;
            } catch  {
                return 0;
            }
        }
        if (n === "!~") {
            let a = await re(e, t.left), l = t.right.type === "regex" ? t.right.pattern : we(await re(e, t.right));
            try {
                return new RegExp(l).test(we(a)) ? 0 : 1;
            } catch  {
                return 1;
            }
        }
        let r = await re(e, t.left), s = await re(e, t.right);
        if (n === " ") return we(r) + we(s);
        if (Sx(n)) return Ax(r, s, n);
        let i = Ie(r), o = Ie(s);
        return Iu(i, o, n);
    }
    function Sx(e) {
        return [
            "<",
            "<=",
            ">",
            ">=",
            "==",
            "!="
        ].includes(e);
    }
    function Ax(e, t, n) {
        let r = ao(e), s = ao(t);
        if (r && s) {
            let a = Ie(e), l = Ie(t);
            switch(n){
                case "<":
                    return a < l ? 1 : 0;
                case "<=":
                    return a <= l ? 1 : 0;
                case ">":
                    return a > l ? 1 : 0;
                case ">=":
                    return a >= l ? 1 : 0;
                case "==":
                    return a === l ? 1 : 0;
                case "!=":
                    return a !== l ? 1 : 0;
            }
        }
        let i = we(e), o = we(t);
        switch(n){
            case "<":
                return i < o ? 1 : 0;
            case "<=":
                return i <= o ? 1 : 0;
            case ">":
                return i > o ? 1 : 0;
            case ">=":
                return i >= o ? 1 : 0;
            case "==":
                return i === o ? 1 : 0;
            case "!=":
                return i !== o ? 1 : 0;
        }
        return 0;
    }
    async function Cx(e, t) {
        let n = await re(e, t.operand);
        switch(t.operator){
            case "!":
                return rt(n) ? 0 : 1;
            case "-":
                return -Ie(n);
            case "+":
                return +Ie(n);
            default:
                return n;
        }
    }
    async function Nx(e, t, n) {
        let r = _u[t];
        if (r) return r(n, e, {
            evalExpr: (i)=>re(e, i)
        });
        let s = e.functions.get(t);
        return s ? kx(e, s, n) : "";
    }
    async function kx(e, t, n) {
        if (e.currentRecursionDepth++, e.currentRecursionDepth > e.maxRecursionDepth) throw e.currentRecursionDepth--, new ne(`awk: recursion depth exceeded maximum (${e.maxRecursionDepth})`, "recursion", e.output);
        let r = {};
        for (let o of t.params)r[o] = e.vars[o];
        let s = [];
        for(let o = 0; o < t.params.length; o++){
            let a = t.params[o];
            if (o < n.length) {
                let l = n[o];
                l.type === "variable" && (e.arrayAliases.set(a, l.name), s.push(a));
                let c = await re(e, l);
                e.vars[a] = c;
            } else e.vars[a] = "";
        }
        e.hasReturn = false, e.returnValue = void 0, fo && await fo(e, t.body.statements);
        let i = e.returnValue ?? "";
        for (let o of t.params)r[o] !== void 0 ? e.vars[o] = r[o] : delete e.vars[o];
        for (let o of s)e.arrayAliases.delete(o);
        return e.hasReturn = false, e.returnValue = void 0, e.currentRecursionDepth--, i;
    }
    async function vx(e, t) {
        let n = await re(e, t.value), r = t.target, s = t.operator, i;
        if (s === "=") i = n;
        else {
            let o;
            if (r.type === "field") {
                let c = Math.floor(Ie(await re(e, r.index)));
                o = ps(e, c);
            } else if (r.type === "variable") o = hs(e, r.name);
            else {
                let c = we(await re(e, r.key));
                o = ms(e, r.array, c);
            }
            let a = Ie(o), l = Ie(n);
            switch(s){
                case "+=":
                    i = a + l;
                    break;
                case "-=":
                    i = a - l;
                    break;
                case "*=":
                    i = a * l;
                    break;
                case "/=":
                    i = l !== 0 ? a / l : 0;
                    break;
                case "%=":
                    i = l !== 0 ? a % l : 0;
                    break;
                case "^=":
                    i = a ** l;
                    break;
                default:
                    i = n;
            }
        }
        if (r.type === "field") {
            let o = Math.floor(Ie(await re(e, r.index)));
            lo(e, o, i);
        } else if (r.type === "variable") Wn(e, r.name, i);
        else {
            let o = we(await re(e, r.key));
            co(e, r.array, o, i);
        }
        return i;
    }
    async function gs(e, t, n, r) {
        let s;
        if (t.type === "field") {
            let i = Math.floor(Ie(await re(e, t.index)));
            s = Ie(ps(e, i)), lo(e, i, s + n);
        } else if (t.type === "variable") s = Ie(hs(e, t.name)), Wn(e, t.name, s + n);
        else {
            let i = we(await re(e, t.key));
            s = Ie(ms(e, t.array, i)), co(e, t.array, i, s + n);
        }
        return r ? s + n : s;
    }
    async function $x(e, t) {
        return gs(e, t, 1, true);
    }
    async function Ix(e, t) {
        return gs(e, t, -1, true);
    }
    async function Rx(e, t) {
        return gs(e, t, 1, false);
    }
    async function Px(e, t) {
        return gs(e, t, -1, false);
    }
    async function Tx(e, t, n) {
        let r;
        if (t.type === "tuple") {
            let s = [];
            for (let i of t.elements)s.push(we(await re(e, i)));
            r = s.join(e.SUBSEP);
        } else r = we(await re(e, t));
        return Wu(e, n, r) ? 1 : 0;
    }
    async function Ox(e, t, n, r) {
        if (r) return Dx(e, t, r);
        if (n) return Fx(e, t, n);
        if (!e.lines || e.lineIndex === void 0) return -1;
        let s = e.lineIndex + 1;
        if (s >= e.lines.length) return 0;
        let i = e.lines[s];
        return t ? Wn(e, t, i) : Mn(e, i), e.NR++, e.lineIndex = s, 1;
    }
    async function Dx(e, t, n) {
        if (!e.exec) return -1;
        let r = we(await re(e, n)), s = `__cmd_${r}`, i = `__cmdi_${r}`, o, a;
        if (e.vars[s] === void 0) try {
            o = (await e.exec(r)).stdout.split(`
`), o.length > 0 && o[o.length - 1] === "" && o.pop(), e.vars[s] = JSON.stringify(o), e.vars[i] = -1, a = -1;
        } catch  {
            return -1;
        }
        else o = JSON.parse(e.vars[s]), a = e.vars[i];
        let l = a + 1;
        if (l >= o.length) return 0;
        let c = o[l];
        return e.vars[i] = l, t ? Wn(e, t, c) : Mn(e, c), 1;
    }
    async function Fx(e, t, n) {
        if (!e.fs || !e.cwd) return -1;
        let r = we(await re(e, n));
        if (r === "/dev/null") return 0;
        let s = e.fs.resolvePath(e.cwd, r), i = `__fc_${s}`, o = `__fi_${s}`, a, l;
        if (e.vars[i] === void 0) try {
            a = (await e.fs.readFile(s)).split(`
`), a.length > 0 && a[a.length - 1] === "" && a.pop(), e.vars[i] = JSON.stringify(a), e.vars[o] = -1, l = -1;
        } catch  {
            return -1;
        }
        else a = JSON.parse(e.vars[i]), l = e.vars[o];
        let c = l + 1;
        if (c >= a.length) return 0;
        let u = a[c];
        return e.vars[o] = c, t ? Wn(e, t, u) : Mn(e, u), 1;
    }
    async function _x(e, t) {
        if (t.length === 0) return "";
        for(let n = 0; n < t.length - 1; n++)await re(e, t[n]);
        return re(e, t[t.length - 1]);
    }
    var fo, po = v(()=>{
        de();
        Ru();
        oo();
        ds();
        Ln();
        uo();
        fo = null;
    });
    async function Bn(e, t) {
        for (let n of t)if (await hn(e, n), Lx(e)) break;
    }
    function Lx(e) {
        return e.shouldExit || e.shouldNext || e.shouldNextFile || e.loopBreak || e.loopContinue || e.hasReturn;
    }
    async function hn(e, t) {
        switch(t.type){
            case "block":
                await Bn(e, t.statements);
                break;
            case "expr_stmt":
                await re(e, t.expression);
                break;
            case "print":
                await Mx(e, t.args, t.output);
                break;
            case "printf":
                await Wx(e, t.format, t.args, t.output);
                break;
            case "if":
                await Bx(e, t);
                break;
            case "while":
                await Ux(e, t);
                break;
            case "do_while":
                await zx(e, t);
                break;
            case "for":
                await jx(e, t);
                break;
            case "for_in":
                await Hx(e, t);
                break;
            case "break":
                e.loopBreak = true;
                break;
            case "continue":
                e.loopContinue = true;
                break;
            case "next":
                e.shouldNext = true;
                break;
            case "nextfile":
                e.shouldNextFile = true;
                break;
            case "exit":
                e.shouldExit = true, e.exitCode = t.code ? Math.floor(Ie(await re(e, t.code))) : 0;
                break;
            case "return":
                e.hasReturn = true, e.returnValue = t.value ? await re(e, t.value) : "";
                break;
            case "delete":
                await Vx(e, t.target);
                break;
        }
    }
    async function Mx(e, t, n) {
        let r = [];
        for (let i of t){
            let o = await re(e, i);
            typeof o == "number" ? Number.isInteger(o) && Math.abs(o) < Number.MAX_SAFE_INTEGER ? r.push(String(o)) : r.push(fs(e.OFMT, [
                o
            ])) : r.push(we(o));
        }
        let s = r.join(e.OFS) + e.ORS;
        n ? await ju(e, n.redirect, n.file, s) : e.output += s;
    }
    async function Wx(e, t, n, r) {
        let s = we(await re(e, t)), i = [];
        for (let a of n)i.push(await re(e, a));
        let o = fs(s, i);
        r ? await ju(e, r.redirect, r.file, o) : e.output += o;
    }
    async function ju(e, t, n, r) {
        if (!e.fs || !e.cwd) {
            e.output += r;
            return;
        }
        let s = we(await re(e, n)), i = e.fs.resolvePath(e.cwd, s);
        t === ">" ? e.openedFiles.has(i) ? await e.fs.appendFile(i, r) : (await e.fs.writeFile(i, r), e.openedFiles.add(i)) : (e.openedFiles.has(i) || e.openedFiles.add(i), await e.fs.appendFile(i, r));
    }
    async function Bx(e, t) {
        rt(await re(e, t.condition)) ? await hn(e, t.consequent) : t.alternate && await hn(e, t.alternate);
    }
    async function Ux(e, t) {
        let n = 0;
        for(; rt(await re(e, t.condition));){
            if (n++, n > e.maxIterations) throw new ne(`awk: while loop exceeded maximum iterations (${e.maxIterations})`, "iterations", e.output);
            if (e.loopContinue = false, await hn(e, t.body), e.loopBreak) {
                e.loopBreak = false;
                break;
            }
            if (e.shouldExit || e.shouldNext || e.hasReturn) break;
        }
    }
    async function zx(e, t) {
        let n = 0;
        do {
            if (n++, n > e.maxIterations) throw new ne(`awk: do-while loop exceeded maximum iterations (${e.maxIterations})`, "iterations", e.output);
            if (e.loopContinue = false, await hn(e, t.body), e.loopBreak) {
                e.loopBreak = false;
                break;
            }
            if (e.shouldExit || e.shouldNext || e.hasReturn) break;
        }while (rt(await re(e, t.condition)));
    }
    async function jx(e, t) {
        t.init && await re(e, t.init);
        let n = 0;
        for(; !t.condition || rt(await re(e, t.condition));){
            if (n++, n > e.maxIterations) throw new ne(`awk: for loop exceeded maximum iterations (${e.maxIterations})`, "iterations", e.output);
            if (e.loopContinue = false, await hn(e, t.body), e.loopBreak) {
                e.loopBreak = false;
                break;
            }
            if (e.shouldExit || e.shouldNext || e.hasReturn) break;
            t.update && await re(e, t.update);
        }
    }
    async function Hx(e, t) {
        let n = e.arrays[t.array];
        if (n) for (let r of Object.keys(n)){
            if (e.vars[t.variable] = r, e.loopContinue = false, await hn(e, t.body), e.loopBreak) {
                e.loopBreak = false;
                break;
            }
            if (e.shouldExit || e.shouldNext || e.hasReturn) break;
        }
    }
    async function Vx(e, t) {
        if (t.type === "array_access") {
            let n = we(await re(e, t.key));
            Bu(e, t.array, n);
        } else t.type === "variable" && Uu(e, t.name);
    }
    var Hu = v(()=>{
        de();
        oo();
        po();
        Ln();
        uo();
        zu(Bn);
    });
    var xr, Vu = v(()=>{
        po();
        ds();
        Hu();
        Ln();
        xr = class {
            ctx;
            program = null;
            rangeStates = [];
            constructor(t){
                this.ctx = t;
            }
            execute(t) {
                this.program = t, this.ctx.output = "";
                for (let n of t.functions)this.ctx.functions.set(n.name, n);
                this.rangeStates = t.rules.map(()=>false);
            }
            async executeBegin() {
                if (this.program) {
                    for (let t of this.program.rules)if (t.pattern?.type === "begin" && (await Bn(this.ctx, t.action.statements), this.ctx.shouldExit)) break;
                }
            }
            async executeLine(t) {
                if (!(!this.program || this.ctx.shouldExit)) {
                    Mn(this.ctx, t), this.ctx.NR++, this.ctx.FNR++, this.ctx.shouldNext = false;
                    for(let n = 0; n < this.program.rules.length && !(this.ctx.shouldExit || this.ctx.shouldNext || this.ctx.shouldNextFile); n++){
                        let r = this.program.rules[n];
                        r.pattern?.type === "begin" || r.pattern?.type === "end" || await this.matchesRule(r, n) && await Bn(this.ctx, r.action.statements);
                    }
                }
            }
            async executeEnd() {
                if (this.program && !this.ctx.inEndBlock) {
                    this.ctx.inEndBlock = true, this.ctx.shouldExit = false;
                    for (let t of this.program.rules)if (t.pattern?.type === "end" && (await Bn(this.ctx, t.action.statements), this.ctx.shouldExit)) break;
                    this.ctx.inEndBlock = false;
                }
            }
            getOutput() {
                return this.ctx.output;
            }
            getExitCode() {
                return this.ctx.exitCode;
            }
            getContext() {
                return this.ctx;
            }
            async matchesRule(t, n) {
                let r = t.pattern;
                if (!r) return true;
                switch(r.type){
                    case "begin":
                    case "end":
                        return false;
                    case "regex_pattern":
                        return br(r.pattern, this.ctx.line);
                    case "expr_pattern":
                        return rt(await re(this.ctx, r.expression));
                    case "range":
                        {
                            let s = await this.matchPattern(r.start), i = await this.matchPattern(r.end);
                            return this.rangeStates[n] ? (i && (this.rangeStates[n] = false), true) : s ? (this.rangeStates[n] = true, i && (this.rangeStates[n] = false), true) : false;
                        }
                    default:
                        return false;
                }
            }
            async matchPattern(t) {
                switch(t.type){
                    case "regex_pattern":
                        return br(t.pattern, this.ctx.line);
                    case "expr_pattern":
                        return rt(await re(this.ctx, t.expression));
                    default:
                        return false;
                }
            }
        };
    });
    var qu = v(()=>{
        $u();
        Vu();
    });
    function Gx(e) {
        return e.replace(/\[\[:space:\]\]/g, "[ \\t\\n\\r\\f\\v]").replace(/\[\[:blank:\]\]/g, "[ \\t]").replace(/\[\[:alpha:\]\]/g, "[a-zA-Z]").replace(/\[\[:digit:\]\]/g, "[0-9]").replace(/\[\[:alnum:\]\]/g, "[a-zA-Z0-9]").replace(/\[\[:upper:\]\]/g, "[A-Z]").replace(/\[\[:lower:\]\]/g, "[a-z]").replace(/\[\[:punct:\]\]/g, "[!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~]").replace(/\[\[:xdigit:\]\]/g, "[0-9A-Fa-f]").replace(/\[\[:graph:\]\]/g, "[!-~]").replace(/\[\[:print:\]\]/g, "[ -~]").replace(/\[\[:cntrl:\]\]/g, "[\\x00-\\x1f\\x7f]");
    }
    var S, qx, ys, Gu = v(()=>{
        (function(e) {
            e.NUMBER = "NUMBER", e.STRING = "STRING", e.REGEX = "REGEX", e.IDENT = "IDENT", e.BEGIN = "BEGIN", e.END = "END", e.IF = "IF", e.ELSE = "ELSE", e.WHILE = "WHILE", e.DO = "DO", e.FOR = "FOR", e.IN = "IN", e.BREAK = "BREAK", e.CONTINUE = "CONTINUE", e.NEXT = "NEXT", e.NEXTFILE = "NEXTFILE", e.EXIT = "EXIT", e.RETURN = "RETURN", e.DELETE = "DELETE", e.FUNCTION = "FUNCTION", e.PRINT = "PRINT", e.PRINTF = "PRINTF", e.GETLINE = "GETLINE", e.PLUS = "PLUS", e.MINUS = "MINUS", e.STAR = "STAR", e.SLASH = "SLASH", e.PERCENT = "PERCENT", e.CARET = "CARET", e.EQ = "EQ", e.NE = "NE", e.LT = "LT", e.GT = "GT", e.LE = "LE", e.GE = "GE", e.MATCH = "MATCH", e.NOT_MATCH = "NOT_MATCH", e.AND = "AND", e.OR = "OR", e.NOT = "NOT", e.ASSIGN = "ASSIGN", e.PLUS_ASSIGN = "PLUS_ASSIGN", e.MINUS_ASSIGN = "MINUS_ASSIGN", e.STAR_ASSIGN = "STAR_ASSIGN", e.SLASH_ASSIGN = "SLASH_ASSIGN", e.PERCENT_ASSIGN = "PERCENT_ASSIGN", e.CARET_ASSIGN = "CARET_ASSIGN", e.INCREMENT = "INCREMENT", e.DECREMENT = "DECREMENT", e.QUESTION = "QUESTION", e.COLON = "COLON", e.COMMA = "COMMA", e.SEMICOLON = "SEMICOLON", e.NEWLINE = "NEWLINE", e.LPAREN = "LPAREN", e.RPAREN = "RPAREN", e.LBRACE = "LBRACE", e.RBRACE = "RBRACE", e.LBRACKET = "LBRACKET", e.RBRACKET = "RBRACKET", e.DOLLAR = "DOLLAR", e.APPEND = "APPEND", e.PIPE = "PIPE", e.EOF = "EOF";
        })(S || (S = {}));
        qx = {
            BEGIN: S.BEGIN,
            END: S.END,
            if: S.IF,
            else: S.ELSE,
            while: S.WHILE,
            do: S.DO,
            for: S.FOR,
            in: S.IN,
            break: S.BREAK,
            continue: S.CONTINUE,
            next: S.NEXT,
            nextfile: S.NEXTFILE,
            exit: S.EXIT,
            return: S.RETURN,
            delete: S.DELETE,
            function: S.FUNCTION,
            print: S.PRINT,
            printf: S.PRINTF,
            getline: S.GETLINE
        };
        ys = class {
            input;
            pos = 0;
            line = 1;
            column = 1;
            lastTokenType = null;
            constructor(t){
                this.input = t;
            }
            tokenize() {
                let t = [];
                for(; this.pos < this.input.length;){
                    let n = this.nextToken();
                    n && (t.push(n), this.lastTokenType = n.type);
                }
                return t.push(this.makeToken(S.EOF, "")), t;
            }
            makeToken(t, n) {
                return {
                    type: t,
                    value: n,
                    line: this.line,
                    column: this.column
                };
            }
            peek(t = 0) {
                return this.input[this.pos + t] || "";
            }
            advance() {
                let t = this.input[this.pos++] || "";
                return t === `
` ? (this.line++, this.column = 1) : this.column++, t;
            }
            skipWhitespace() {
                for(; this.pos < this.input.length;){
                    let t = this.peek();
                    if (t === " " || t === "	" || t === "\r") this.advance();
                    else if (t === "\\") if (this.peek(1) === `
`) this.advance(), this.advance();
                    else break;
                    else if (t === "#") for(; this.pos < this.input.length && this.peek() !== `
`;)this.advance();
                    else break;
                }
            }
            nextToken() {
                if (this.skipWhitespace(), this.pos >= this.input.length) return null;
                let t = this.line, n = this.column, r = this.peek();
                return r === `
` ? (this.advance(), {
                    type: S.NEWLINE,
                    value: `
`,
                    line: t,
                    column: n
                }) : r === '"' ? this.readString() : r === "/" && this.canBeRegex() ? this.readRegex() : this.isDigit(r) || r === "." && this.isDigit(this.peek(1)) ? this.readNumber() : this.isAlpha(r) || r === "_" ? this.readIdentifier() : this.readOperator();
            }
            canBeRegex() {
                return (new Set([
                    null,
                    S.NEWLINE,
                    S.SEMICOLON,
                    S.LBRACE,
                    S.RBRACE,
                    S.LPAREN,
                    S.LBRACKET,
                    S.COMMA,
                    S.ASSIGN,
                    S.PLUS_ASSIGN,
                    S.MINUS_ASSIGN,
                    S.STAR_ASSIGN,
                    S.SLASH_ASSIGN,
                    S.PERCENT_ASSIGN,
                    S.CARET_ASSIGN,
                    S.AND,
                    S.OR,
                    S.NOT,
                    S.MATCH,
                    S.NOT_MATCH,
                    S.QUESTION,
                    S.COLON,
                    S.LT,
                    S.GT,
                    S.LE,
                    S.GE,
                    S.EQ,
                    S.NE,
                    S.PLUS,
                    S.MINUS,
                    S.STAR,
                    S.PERCENT,
                    S.CARET,
                    S.PRINT,
                    S.PRINTF,
                    S.IF,
                    S.WHILE,
                    S.DO,
                    S.FOR,
                    S.RETURN
                ])).has(this.lastTokenType);
            }
            readString() {
                let t = this.line, n = this.column;
                this.advance();
                let r = "";
                for(; this.pos < this.input.length && this.peek() !== '"';)if (this.peek() === "\\") {
                    this.advance();
                    let s = this.advance();
                    switch(s){
                        case "n":
                            r += `
`;
                            break;
                        case "t":
                            r += "	";
                            break;
                        case "r":
                            r += "\r";
                            break;
                        case "f":
                            r += "\f";
                            break;
                        case "b":
                            r += "\b";
                            break;
                        case "v":
                            r += "\v";
                            break;
                        case "a":
                            r += "\x07";
                            break;
                        case "\\":
                            r += "\\";
                            break;
                        case '"':
                            r += '"';
                            break;
                        case "/":
                            r += "/";
                            break;
                        case "x":
                            {
                                let i = "";
                                for(; i.length < 2 && /[0-9a-fA-F]/.test(this.peek());)i += this.advance();
                                i.length > 0 ? r += String.fromCharCode(parseInt(i, 16)) : r += "x";
                                break;
                            }
                        default:
                            if (/[0-7]/.test(s)) {
                                let i = s;
                                for(; i.length < 3 && /[0-7]/.test(this.peek());)i += this.advance();
                                r += String.fromCharCode(parseInt(i, 8));
                            } else r += s;
                    }
                } else r += this.advance();
                return this.peek() === '"' && this.advance(), {
                    type: S.STRING,
                    value: r,
                    line: t,
                    column: n
                };
            }
            readRegex() {
                let t = this.line, n = this.column;
                this.advance();
                let r = "";
                for(; this.pos < this.input.length && this.peek() !== "/";)if (this.peek() === "\\") r += this.advance(), this.pos < this.input.length && (r += this.advance());
                else {
                    if (this.peek() === `
`) break;
                    r += this.advance();
                }
                return this.peek() === "/" && this.advance(), r = Gx(r), {
                    type: S.REGEX,
                    value: r,
                    line: t,
                    column: n
                };
            }
            readNumber() {
                let t = this.line, n = this.column, r = "";
                for(; this.isDigit(this.peek());)r += this.advance();
                if (this.peek() === "." && this.isDigit(this.peek(1))) for(r += this.advance(); this.isDigit(this.peek());)r += this.advance();
                if (this.peek() === "e" || this.peek() === "E") for(r += this.advance(), (this.peek() === "+" || this.peek() === "-") && (r += this.advance()); this.isDigit(this.peek());)r += this.advance();
                return {
                    type: S.NUMBER,
                    value: parseFloat(r),
                    line: t,
                    column: n
                };
            }
            readIdentifier() {
                let t = this.line, n = this.column, r = "";
                for(; this.isAlphaNumeric(this.peek()) || this.peek() === "_";)r += this.advance();
                let s = qx[r];
                return s ? {
                    type: s,
                    value: r,
                    line: t,
                    column: n
                } : {
                    type: S.IDENT,
                    value: r,
                    line: t,
                    column: n
                };
            }
            readOperator() {
                let t = this.line, n = this.column, r = this.advance(), s = this.peek();
                switch(r){
                    case "+":
                        return s === "+" ? (this.advance(), {
                            type: S.INCREMENT,
                            value: "++",
                            line: t,
                            column: n
                        }) : s === "=" ? (this.advance(), {
                            type: S.PLUS_ASSIGN,
                            value: "+=",
                            line: t,
                            column: n
                        }) : {
                            type: S.PLUS,
                            value: "+",
                            line: t,
                            column: n
                        };
                    case "-":
                        return s === "-" ? (this.advance(), {
                            type: S.DECREMENT,
                            value: "--",
                            line: t,
                            column: n
                        }) : s === "=" ? (this.advance(), {
                            type: S.MINUS_ASSIGN,
                            value: "-=",
                            line: t,
                            column: n
                        }) : {
                            type: S.MINUS,
                            value: "-",
                            line: t,
                            column: n
                        };
                    case "*":
                        return s === "*" ? (this.advance(), {
                            type: S.CARET,
                            value: "**",
                            line: t,
                            column: n
                        }) : s === "=" ? (this.advance(), {
                            type: S.STAR_ASSIGN,
                            value: "*=",
                            line: t,
                            column: n
                        }) : {
                            type: S.STAR,
                            value: "*",
                            line: t,
                            column: n
                        };
                    case "/":
                        return s === "=" ? (this.advance(), {
                            type: S.SLASH_ASSIGN,
                            value: "/=",
                            line: t,
                            column: n
                        }) : {
                            type: S.SLASH,
                            value: "/",
                            line: t,
                            column: n
                        };
                    case "%":
                        return s === "=" ? (this.advance(), {
                            type: S.PERCENT_ASSIGN,
                            value: "%=",
                            line: t,
                            column: n
                        }) : {
                            type: S.PERCENT,
                            value: "%",
                            line: t,
                            column: n
                        };
                    case "^":
                        return s === "=" ? (this.advance(), {
                            type: S.CARET_ASSIGN,
                            value: "^=",
                            line: t,
                            column: n
                        }) : {
                            type: S.CARET,
                            value: "^",
                            line: t,
                            column: n
                        };
                    case "=":
                        return s === "=" ? (this.advance(), {
                            type: S.EQ,
                            value: "==",
                            line: t,
                            column: n
                        }) : {
                            type: S.ASSIGN,
                            value: "=",
                            line: t,
                            column: n
                        };
                    case "!":
                        return s === "=" ? (this.advance(), {
                            type: S.NE,
                            value: "!=",
                            line: t,
                            column: n
                        }) : s === "~" ? (this.advance(), {
                            type: S.NOT_MATCH,
                            value: "!~",
                            line: t,
                            column: n
                        }) : {
                            type: S.NOT,
                            value: "!",
                            line: t,
                            column: n
                        };
                    case "<":
                        return s === "=" ? (this.advance(), {
                            type: S.LE,
                            value: "<=",
                            line: t,
                            column: n
                        }) : {
                            type: S.LT,
                            value: "<",
                            line: t,
                            column: n
                        };
                    case ">":
                        return s === "=" ? (this.advance(), {
                            type: S.GE,
                            value: ">=",
                            line: t,
                            column: n
                        }) : s === ">" ? (this.advance(), {
                            type: S.APPEND,
                            value: ">>",
                            line: t,
                            column: n
                        }) : {
                            type: S.GT,
                            value: ">",
                            line: t,
                            column: n
                        };
                    case "&":
                        return s === "&" ? (this.advance(), {
                            type: S.AND,
                            value: "&&",
                            line: t,
                            column: n
                        }) : {
                            type: S.IDENT,
                            value: "&",
                            line: t,
                            column: n
                        };
                    case "|":
                        return s === "|" ? (this.advance(), {
                            type: S.OR,
                            value: "||",
                            line: t,
                            column: n
                        }) : {
                            type: S.PIPE,
                            value: "|",
                            line: t,
                            column: n
                        };
                    case "~":
                        return {
                            type: S.MATCH,
                            value: "~",
                            line: t,
                            column: n
                        };
                    case "?":
                        return {
                            type: S.QUESTION,
                            value: "?",
                            line: t,
                            column: n
                        };
                    case ":":
                        return {
                            type: S.COLON,
                            value: ":",
                            line: t,
                            column: n
                        };
                    case ",":
                        return {
                            type: S.COMMA,
                            value: ",",
                            line: t,
                            column: n
                        };
                    case ";":
                        return {
                            type: S.SEMICOLON,
                            value: ";",
                            line: t,
                            column: n
                        };
                    case "(":
                        return {
                            type: S.LPAREN,
                            value: "(",
                            line: t,
                            column: n
                        };
                    case ")":
                        return {
                            type: S.RPAREN,
                            value: ")",
                            line: t,
                            column: n
                        };
                    case "{":
                        return {
                            type: S.LBRACE,
                            value: "{",
                            line: t,
                            column: n
                        };
                    case "}":
                        return {
                            type: S.RBRACE,
                            value: "}",
                            line: t,
                            column: n
                        };
                    case "[":
                        return {
                            type: S.LBRACKET,
                            value: "[",
                            line: t,
                            column: n
                        };
                    case "]":
                        return {
                            type: S.RBRACKET,
                            value: "]",
                            line: t,
                            column: n
                        };
                    case "$":
                        return {
                            type: S.DOLLAR,
                            value: "$",
                            line: t,
                            column: n
                        };
                    default:
                        return {
                            type: S.IDENT,
                            value: r,
                            line: t,
                            column: n
                        };
                }
            }
            isDigit(t) {
                return t >= "0" && t <= "9";
            }
            isAlpha(t) {
                return t >= "a" && t <= "z" || t >= "A" && t <= "Z";
            }
            isAlphaNumeric(t) {
                return this.isDigit(t) || this.isAlpha(t);
            }
        };
    });
    function Ju(e) {
        e.expect(H.PRINT);
        let t = [];
        if (e.check(H.NEWLINE) || e.check(H.SEMICOLON) || e.check(H.RBRACE) || e.check(H.PIPE) || e.check(H.GT) || e.check(H.APPEND)) t.push({
            type: "field",
            index: {
                type: "number",
                value: 0
            }
        });
        else for(t.push(bs(e)); e.check(H.COMMA);)e.advance(), t.push(bs(e));
        let n;
        return e.check(H.GT) ? (e.advance(), n = {
            redirect: ">",
            file: e.parsePrimary()
        }) : e.check(H.APPEND) && (e.advance(), n = {
            redirect: ">>",
            file: e.parsePrimary()
        }), {
            type: "print",
            args: t,
            output: n
        };
    }
    function bs(e) {
        return Zx(e) ? ho(e, true) : ho(e, false);
    }
    function ho(e, t) {
        let n = t ? e.parseTernary() : Qx(e);
        if (e.match(H.ASSIGN, H.PLUS_ASSIGN, H.MINUS_ASSIGN, H.STAR_ASSIGN, H.SLASH_ASSIGN, H.PERCENT_ASSIGN, H.CARET_ASSIGN)) {
            let r = e.advance(), s = ho(e, t);
            if (n.type !== "variable" && n.type !== "field" && n.type !== "array_access") throw new Error("Invalid assignment target");
            return {
                type: "assignment",
                operator: {
                    "=": "=",
                    "+=": "+=",
                    "-=": "-=",
                    "*=": "*=",
                    "/=": "/=",
                    "%=": "%=",
                    "^=": "^="
                }[r.value],
                target: n,
                value: s
            };
        }
        return n;
    }
    function Zx(e) {
        let t = 0, n = e.pos;
        for(; n < e.tokens.length;){
            let r = e.tokens[n];
            if (r.type === H.LPAREN && t++, r.type === H.RPAREN && t--, r.type === H.QUESTION && t === 0) return true;
            if (r.type === H.NEWLINE || r.type === H.SEMICOLON || r.type === H.RBRACE || r.type === H.COMMA || r.type === H.PIPE) return false;
            n++;
        }
        return false;
    }
    function Qx(e) {
        let t = Zu(e);
        for(; e.check(H.OR);){
            e.advance();
            let n = Zu(e);
            t = {
                type: "binary",
                operator: "||",
                left: t,
                right: n
            };
        }
        return t;
    }
    function Zu(e) {
        let t = Qu(e);
        for(; e.check(H.AND);){
            e.advance();
            let n = Qu(e);
            t = {
                type: "binary",
                operator: "&&",
                left: t,
                right: n
            };
        }
        return t;
    }
    function Qu(e) {
        let t = Kx(e);
        if (e.check(H.IN)) {
            e.advance();
            let n = String(e.expect(H.IDENT).value);
            return {
                type: "in",
                key: t,
                array: n
            };
        }
        return t;
    }
    function Kx(e) {
        let t = Ku(e);
        for(; Xx(e) && !Jx(e);){
            let n = Ku(e);
            t = {
                type: "binary",
                operator: " ",
                left: t,
                right: n
            };
        }
        return t;
    }
    function Ku(e) {
        let t = Xu(e);
        for(; e.match(H.MATCH, H.NOT_MATCH);){
            let n = e.advance().type === H.MATCH ? "~" : "!~", r = Xu(e);
            t = {
                type: "binary",
                operator: n,
                left: t,
                right: r
            };
        }
        return t;
    }
    function Xu(e) {
        let t = e.parseAddSub();
        for(; e.match(H.LT, H.LE, H.GE, H.EQ, H.NE);){
            let n = e.advance(), r = e.parseAddSub();
            t = {
                type: "binary",
                operator: {
                    "<": "<",
                    "<=": "<=",
                    ">=": ">=",
                    "==": "==",
                    "!=": "!="
                }[n.value],
                left: t,
                right: r
            };
        }
        return t;
    }
    function Xx(e) {
        return e.match(H.NUMBER, H.STRING, H.IDENT, H.DOLLAR, H.LPAREN, H.NOT, H.MINUS, H.PLUS, H.INCREMENT, H.DECREMENT);
    }
    function Jx(e) {
        return e.match(H.AND, H.OR, H.QUESTION, H.ASSIGN, H.PLUS_ASSIGN, H.MINUS_ASSIGN, H.STAR_ASSIGN, H.SLASH_ASSIGN, H.PERCENT_ASSIGN, H.CARET_ASSIGN, H.COMMA, H.SEMICOLON, H.NEWLINE, H.RBRACE, H.RPAREN, H.RBRACKET, H.COLON, H.PIPE, H.APPEND, H.GT, H.IN);
    }
    function Yu(e) {
        e.expect(H.PRINTF);
        let t = e.check(H.LPAREN);
        t && (e.advance(), e.skipNewlines());
        let n = t ? e.parseExpression() : bs(e), r = [];
        for(; e.check(H.COMMA);)e.advance(), t && e.skipNewlines(), r.push(t ? e.parseExpression() : bs(e));
        t && (e.skipNewlines(), e.expect(H.RPAREN));
        let s;
        return e.check(H.GT) ? (e.advance(), s = {
            redirect: ">",
            file: e.parsePrimary()
        }) : e.check(H.APPEND) && (e.advance(), s = {
            redirect: ">>",
            file: e.parsePrimary()
        }), {
            type: "printf",
            format: n,
            args: r,
            output: s
        };
    }
    var H, ef = v(()=>{
        H = {
            LPAREN: "LPAREN",
            RPAREN: "RPAREN",
            QUESTION: "QUESTION",
            NEWLINE: "NEWLINE",
            SEMICOLON: "SEMICOLON",
            RBRACE: "RBRACE",
            COMMA: "COMMA",
            PIPE: "PIPE",
            GT: "GT",
            APPEND: "APPEND",
            AND: "AND",
            OR: "OR",
            ASSIGN: "ASSIGN",
            PLUS_ASSIGN: "PLUS_ASSIGN",
            MINUS_ASSIGN: "MINUS_ASSIGN",
            STAR_ASSIGN: "STAR_ASSIGN",
            SLASH_ASSIGN: "SLASH_ASSIGN",
            PERCENT_ASSIGN: "PERCENT_ASSIGN",
            CARET_ASSIGN: "CARET_ASSIGN",
            RBRACKET: "RBRACKET",
            COLON: "COLON",
            IN: "IN",
            PRINT: "PRINT",
            PRINTF: "PRINTF",
            IDENT: "IDENT",
            LT: "LT",
            LE: "LE",
            GE: "GE",
            EQ: "EQ",
            NE: "NE",
            MATCH: "MATCH",
            NOT_MATCH: "NOT_MATCH",
            NUMBER: "NUMBER",
            STRING: "STRING",
            DOLLAR: "DOLLAR",
            NOT: "NOT",
            MINUS: "MINUS",
            PLUS: "PLUS",
            INCREMENT: "INCREMENT",
            DECREMENT: "DECREMENT"
        };
    });
    var ws, tf = v(()=>{
        Gu();
        ef();
        ws = class {
            tokens = [];
            pos = 0;
            parse(t) {
                let n = new ys(t);
                return this.tokens = n.tokenize(), this.pos = 0, this.parseProgram();
            }
            setPos(t) {
                this.pos = t;
            }
            current() {
                return this.tokens[this.pos] || {
                    type: S.EOF,
                    value: "",
                    line: 0,
                    column: 0
                };
            }
            advance() {
                let t = this.current();
                return this.pos < this.tokens.length && this.pos++, t;
            }
            match(...t) {
                return t.includes(this.current().type);
            }
            check(t) {
                return this.current().type === t;
            }
            expect(t, n) {
                if (!this.check(t)) {
                    let r = this.current();
                    throw new Error(n || `Expected ${t}, got ${r.type} at line ${r.line}:${r.column}`);
                }
                return this.advance();
            }
            skipNewlines() {
                for(; this.check(S.NEWLINE);)this.advance();
            }
            skipTerminators() {
                for(; this.check(S.NEWLINE) || this.check(S.SEMICOLON);)this.advance();
            }
            parseProgram() {
                let t = [], n = [];
                for(this.skipNewlines(); !this.check(S.EOF) && (this.skipNewlines(), !this.check(S.EOF));)this.check(S.FUNCTION) ? t.push(this.parseFunction()) : n.push(this.parseRule()), this.skipTerminators();
                return {
                    functions: t,
                    rules: n
                };
            }
            parseFunction() {
                this.expect(S.FUNCTION);
                let t = this.expect(S.IDENT).value;
                this.expect(S.LPAREN);
                let n = [];
                if (!this.check(S.RPAREN)) for(n.push(this.expect(S.IDENT).value); this.check(S.COMMA);)this.advance(), n.push(this.expect(S.IDENT).value);
                this.expect(S.RPAREN), this.skipNewlines();
                let r = this.parseBlock();
                return {
                    name: t,
                    params: n,
                    body: r
                };
            }
            parseRule() {
                let t;
                if (this.check(S.BEGIN)) this.advance(), t = {
                    type: "begin"
                };
                else if (this.check(S.END)) this.advance(), t = {
                    type: "end"
                };
                else if (this.check(S.LBRACE)) t = void 0;
                else if (this.check(S.REGEX)) {
                    let r = this.advance();
                    if (this.check(S.AND) || this.check(S.OR)) {
                        let s = {
                            type: "binary",
                            operator: "~",
                            left: {
                                type: "field",
                                index: {
                                    type: "number",
                                    value: 0
                                }
                            },
                            right: {
                                type: "regex",
                                pattern: r.value
                            }
                        };
                        t = {
                            type: "expr_pattern",
                            expression: this.parseLogicalOrRest(s)
                        };
                    } else {
                        let s = {
                            type: "regex_pattern",
                            pattern: r.value
                        };
                        if (this.check(S.COMMA)) {
                            this.advance();
                            let i;
                            this.check(S.REGEX) ? i = {
                                type: "regex_pattern",
                                pattern: this.advance().value
                            } : i = {
                                type: "expr_pattern",
                                expression: this.parseExpression()
                            }, t = {
                                type: "range",
                                start: s,
                                end: i
                            };
                        } else t = s;
                    }
                } else {
                    let s = {
                        type: "expr_pattern",
                        expression: this.parseExpression()
                    };
                    if (this.check(S.COMMA)) {
                        this.advance();
                        let i;
                        this.check(S.REGEX) ? i = {
                            type: "regex_pattern",
                            pattern: this.advance().value
                        } : i = {
                            type: "expr_pattern",
                            expression: this.parseExpression()
                        }, t = {
                            type: "range",
                            start: s,
                            end: i
                        };
                    } else t = s;
                }
                this.skipNewlines();
                let n;
                return this.check(S.LBRACE) ? n = this.parseBlock() : n = {
                    type: "block",
                    statements: [
                        {
                            type: "print",
                            args: [
                                {
                                    type: "field",
                                    index: {
                                        type: "number",
                                        value: 0
                                    }
                                }
                            ]
                        }
                    ]
                }, {
                    pattern: t,
                    action: n
                };
            }
            parseBlock() {
                this.expect(S.LBRACE), this.skipNewlines();
                let t = [];
                for(; !this.check(S.RBRACE) && !this.check(S.EOF);)t.push(this.parseStatement()), this.skipTerminators();
                return this.expect(S.RBRACE), {
                    type: "block",
                    statements: t
                };
            }
            parseStatement() {
                if (this.check(S.SEMICOLON) || this.check(S.NEWLINE)) return this.advance(), {
                    type: "block",
                    statements: []
                };
                if (this.check(S.LBRACE)) return this.parseBlock();
                if (this.check(S.IF)) return this.parseIf();
                if (this.check(S.WHILE)) return this.parseWhile();
                if (this.check(S.DO)) return this.parseDoWhile();
                if (this.check(S.FOR)) return this.parseFor();
                if (this.check(S.BREAK)) return this.advance(), {
                    type: "break"
                };
                if (this.check(S.CONTINUE)) return this.advance(), {
                    type: "continue"
                };
                if (this.check(S.NEXT)) return this.advance(), {
                    type: "next"
                };
                if (this.check(S.NEXTFILE)) return this.advance(), {
                    type: "nextfile"
                };
                if (this.check(S.EXIT)) {
                    this.advance();
                    let n;
                    return !this.check(S.NEWLINE) && !this.check(S.SEMICOLON) && !this.check(S.RBRACE) && !this.check(S.EOF) && (n = this.parseExpression()), {
                        type: "exit",
                        code: n
                    };
                }
                if (this.check(S.RETURN)) {
                    this.advance();
                    let n;
                    return !this.check(S.NEWLINE) && !this.check(S.SEMICOLON) && !this.check(S.RBRACE) && !this.check(S.EOF) && (n = this.parseExpression()), {
                        type: "return",
                        value: n
                    };
                }
                if (this.check(S.DELETE)) {
                    this.advance();
                    let n = this.parsePrimary();
                    if (n.type !== "array_access" && n.type !== "variable") throw new Error("delete requires array element or array");
                    return {
                        type: "delete",
                        target: n
                    };
                }
                return this.check(S.PRINT) ? Ju(this) : this.check(S.PRINTF) ? Yu(this) : {
                    type: "expr_stmt",
                    expression: this.parseExpression()
                };
            }
            parseIf() {
                this.expect(S.IF), this.expect(S.LPAREN);
                let t = this.parseExpression();
                this.expect(S.RPAREN), this.skipNewlines();
                let n = this.parseStatement();
                this.skipTerminators();
                let r;
                return this.check(S.ELSE) && (this.advance(), this.skipNewlines(), r = this.parseStatement()), {
                    type: "if",
                    condition: t,
                    consequent: n,
                    alternate: r
                };
            }
            parseWhile() {
                this.expect(S.WHILE), this.expect(S.LPAREN);
                let t = this.parseExpression();
                this.expect(S.RPAREN), this.skipNewlines();
                let n = this.parseStatement();
                return {
                    type: "while",
                    condition: t,
                    body: n
                };
            }
            parseDoWhile() {
                this.expect(S.DO), this.skipNewlines();
                let t = this.parseStatement();
                this.skipNewlines(), this.expect(S.WHILE), this.expect(S.LPAREN);
                let n = this.parseExpression();
                return this.expect(S.RPAREN), {
                    type: "do_while",
                    body: t,
                    condition: n
                };
            }
            parseFor() {
                if (this.expect(S.FOR), this.expect(S.LPAREN), this.check(S.IDENT)) {
                    let i = this.advance();
                    if (this.check(S.IN)) {
                        this.advance();
                        let o = this.expect(S.IDENT).value;
                        this.expect(S.RPAREN), this.skipNewlines();
                        let a = this.parseStatement();
                        return {
                            type: "for_in",
                            variable: i.value,
                            array: o,
                            body: a
                        };
                    }
                    this.pos--;
                }
                let t;
                this.check(S.SEMICOLON) || (t = this.parseExpression()), this.expect(S.SEMICOLON);
                let n;
                this.check(S.SEMICOLON) || (n = this.parseExpression()), this.expect(S.SEMICOLON);
                let r;
                this.check(S.RPAREN) || (r = this.parseExpression()), this.expect(S.RPAREN), this.skipNewlines();
                let s = this.parseStatement();
                return {
                    type: "for",
                    init: t,
                    condition: n,
                    update: r,
                    body: s
                };
            }
            parseExpression() {
                return this.parseAssignment();
            }
            parseAssignment() {
                let t = this.parseTernary();
                if (this.match(S.ASSIGN, S.PLUS_ASSIGN, S.MINUS_ASSIGN, S.STAR_ASSIGN, S.SLASH_ASSIGN, S.PERCENT_ASSIGN, S.CARET_ASSIGN)) {
                    let n = this.advance(), r = this.parseAssignment();
                    if (t.type !== "variable" && t.type !== "field" && t.type !== "array_access") throw new Error("Invalid assignment target");
                    return {
                        type: "assignment",
                        operator: {
                            "=": "=",
                            "+=": "+=",
                            "-=": "-=",
                            "*=": "*=",
                            "/=": "/=",
                            "%=": "%=",
                            "^=": "^="
                        }[n.value],
                        target: t,
                        value: r
                    };
                }
                return t;
            }
            parseTernary() {
                let t = this.parsePipeGetline();
                if (this.check(S.QUESTION)) {
                    this.advance();
                    let n = this.parseExpression();
                    this.expect(S.COLON);
                    let r = this.parseExpression();
                    t = {
                        type: "ternary",
                        condition: t,
                        consequent: n,
                        alternate: r
                    };
                }
                return t;
            }
            parsePipeGetline() {
                let t = this.parseOr();
                if (this.check(S.PIPE)) {
                    if (this.advance(), !this.check(S.GETLINE)) throw new Error("Expected 'getline' after '|' in expression context");
                    this.advance();
                    let n;
                    return this.check(S.IDENT) && (n = this.advance().value), {
                        type: "getline",
                        command: t,
                        variable: n
                    };
                }
                return t;
            }
            parseOr() {
                let t = this.parseAnd();
                for(; this.check(S.OR);){
                    this.advance();
                    let n = this.parseAnd();
                    t = {
                        type: "binary",
                        operator: "||",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseLogicalOrRest(t) {
                for(t = this.parseLogicalAndRest(t); this.check(S.OR);){
                    this.advance();
                    let n = this.parseAnd();
                    t = {
                        type: "binary",
                        operator: "||",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseLogicalAndRest(t) {
                for(; this.check(S.AND);){
                    this.advance();
                    let n = this.parseIn();
                    t = {
                        type: "binary",
                        operator: "&&",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseAnd() {
                let t = this.parseIn();
                for(; this.check(S.AND);){
                    this.advance();
                    let n = this.parseIn();
                    t = {
                        type: "binary",
                        operator: "&&",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseIn() {
                let t = this.parseConcatenation();
                if (this.check(S.IN)) {
                    this.advance();
                    let n = this.expect(S.IDENT).value;
                    return {
                        type: "in",
                        key: t,
                        array: n
                    };
                }
                return t;
            }
            parseConcatenation() {
                let t = this.parseMatch();
                for(; this.canStartExpression() && !this.isConcatTerminator();){
                    let n = this.parseMatch();
                    t = {
                        type: "binary",
                        operator: " ",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseMatch() {
                let t = this.parseComparison();
                for(; this.match(S.MATCH, S.NOT_MATCH);){
                    let n = this.advance().type === S.MATCH ? "~" : "!~", r = this.parseComparison();
                    t = {
                        type: "binary",
                        operator: n,
                        left: t,
                        right: r
                    };
                }
                return t;
            }
            parseComparison() {
                let t = this.parseAddSub();
                for(; this.match(S.LT, S.LE, S.GT, S.GE, S.EQ, S.NE);){
                    let n = this.advance(), r = this.parseAddSub();
                    t = {
                        type: "binary",
                        operator: {
                            "<": "<",
                            "<=": "<=",
                            ">": ">",
                            ">=": ">=",
                            "==": "==",
                            "!=": "!="
                        }[n.value],
                        left: t,
                        right: r
                    };
                }
                return t;
            }
            canStartExpression() {
                return this.match(S.NUMBER, S.STRING, S.IDENT, S.DOLLAR, S.LPAREN, S.NOT, S.MINUS, S.PLUS, S.INCREMENT, S.DECREMENT);
            }
            isConcatTerminator() {
                return this.match(S.AND, S.OR, S.QUESTION, S.ASSIGN, S.PLUS_ASSIGN, S.MINUS_ASSIGN, S.STAR_ASSIGN, S.SLASH_ASSIGN, S.PERCENT_ASSIGN, S.CARET_ASSIGN, S.COMMA, S.SEMICOLON, S.NEWLINE, S.RBRACE, S.RPAREN, S.RBRACKET, S.COLON, S.PIPE, S.APPEND, S.IN);
            }
            parseAddSub() {
                let t = this.parseMulDiv();
                for(; this.match(S.PLUS, S.MINUS);){
                    let n = this.advance().value, r = this.parseMulDiv();
                    t = {
                        type: "binary",
                        operator: n,
                        left: t,
                        right: r
                    };
                }
                return t;
            }
            parseMulDiv() {
                let t = this.parseUnary();
                for(; this.match(S.STAR, S.SLASH, S.PERCENT);){
                    let n = this.advance(), r = this.parseUnary();
                    t = {
                        type: "binary",
                        operator: {
                            "*": "*",
                            "/": "/",
                            "%": "%"
                        }[n.value],
                        left: t,
                        right: r
                    };
                }
                return t;
            }
            parseUnary() {
                if (this.check(S.INCREMENT)) {
                    this.advance();
                    let t = this.parseUnary();
                    return t.type !== "variable" && t.type !== "field" && t.type !== "array_access" ? {
                        type: "unary",
                        operator: "+",
                        operand: {
                            type: "unary",
                            operator: "+",
                            operand: t
                        }
                    } : {
                        type: "pre_increment",
                        operand: t
                    };
                }
                if (this.check(S.DECREMENT)) {
                    this.advance();
                    let t = this.parseUnary();
                    return t.type !== "variable" && t.type !== "field" && t.type !== "array_access" ? {
                        type: "unary",
                        operator: "-",
                        operand: {
                            type: "unary",
                            operator: "-",
                            operand: t
                        }
                    } : {
                        type: "pre_decrement",
                        operand: t
                    };
                }
                if (this.match(S.NOT, S.MINUS, S.PLUS)) {
                    let t = this.advance().value, n = this.parseUnary();
                    return {
                        type: "unary",
                        operator: t,
                        operand: n
                    };
                }
                return this.parsePower();
            }
            parsePower() {
                let t = this.parsePostfix();
                if (this.check(S.CARET)) {
                    this.advance();
                    let n = this.parsePower();
                    t = {
                        type: "binary",
                        operator: "^",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parsePostfix() {
                let t = this.parsePrimary();
                if (this.check(S.INCREMENT)) {
                    if (this.advance(), t.type !== "variable" && t.type !== "field" && t.type !== "array_access") throw new Error("Invalid increment operand");
                    return {
                        type: "post_increment",
                        operand: t
                    };
                }
                if (this.check(S.DECREMENT)) {
                    if (this.advance(), t.type !== "variable" && t.type !== "field" && t.type !== "array_access") throw new Error("Invalid decrement operand");
                    return {
                        type: "post_decrement",
                        operand: t
                    };
                }
                return t;
            }
            parseFieldIndex() {
                if (this.check(S.INCREMENT)) {
                    this.advance();
                    let t = this.parseFieldIndex();
                    return t.type !== "variable" && t.type !== "field" && t.type !== "array_access" ? {
                        type: "unary",
                        operator: "+",
                        operand: {
                            type: "unary",
                            operator: "+",
                            operand: t
                        }
                    } : {
                        type: "pre_increment",
                        operand: t
                    };
                }
                if (this.check(S.DECREMENT)) {
                    this.advance();
                    let t = this.parseFieldIndex();
                    return t.type !== "variable" && t.type !== "field" && t.type !== "array_access" ? {
                        type: "unary",
                        operator: "-",
                        operand: {
                            type: "unary",
                            operator: "-",
                            operand: t
                        }
                    } : {
                        type: "pre_decrement",
                        operand: t
                    };
                }
                if (this.match(S.NOT, S.MINUS, S.PLUS)) {
                    let t = this.advance().value, n = this.parseFieldIndex();
                    return {
                        type: "unary",
                        operator: t,
                        operand: n
                    };
                }
                return this.parseFieldIndexPower();
            }
            parseFieldIndexPower() {
                let t = this.parseFieldIndexPrimary();
                if (this.check(S.CARET)) {
                    this.advance();
                    let n = this.parseFieldIndexPower();
                    t = {
                        type: "binary",
                        operator: "^",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseFieldIndexPrimary() {
                if (this.check(S.NUMBER)) return {
                    type: "number",
                    value: this.advance().value
                };
                if (this.check(S.STRING)) return {
                    type: "string",
                    value: this.advance().value
                };
                if (this.check(S.DOLLAR)) return this.advance(), {
                    type: "field",
                    index: this.parseFieldIndex()
                };
                if (this.check(S.LPAREN)) {
                    this.advance();
                    let t = this.parseExpression();
                    return this.expect(S.RPAREN), t;
                }
                if (this.check(S.IDENT)) {
                    let t = this.advance().value;
                    if (this.check(S.LPAREN)) {
                        this.advance();
                        let n = [];
                        if (!this.check(S.RPAREN)) for(n.push(this.parseExpression()); this.check(S.COMMA);)this.advance(), n.push(this.parseExpression());
                        return this.expect(S.RPAREN), {
                            type: "call",
                            name: t,
                            args: n
                        };
                    }
                    if (this.check(S.LBRACKET)) {
                        this.advance();
                        let n = this.parseExpression();
                        if (this.check(S.COMMA)) {
                            let r = [
                                n
                            ];
                            for(; this.check(S.COMMA);)this.advance(), r.push(this.parseExpression());
                            this.expect(S.RBRACKET);
                            let s = r.reduce((i, o)=>({
                                    type: "binary",
                                    operator: " ",
                                    left: {
                                        type: "binary",
                                        operator: " ",
                                        left: i,
                                        right: {
                                            type: "variable",
                                            name: "SUBSEP"
                                        }
                                    },
                                    right: o
                                }));
                            return {
                                type: "array_access",
                                array: t,
                                key: s
                            };
                        }
                        return this.expect(S.RBRACKET), {
                            type: "array_access",
                            array: t,
                            key: n
                        };
                    }
                    return {
                        type: "variable",
                        name: t
                    };
                }
                throw new Error(`Unexpected token in field index: ${this.current().type} at line ${this.current().line}:${this.current().column}`);
            }
            parsePrimary() {
                if (this.check(S.NUMBER)) return {
                    type: "number",
                    value: this.advance().value
                };
                if (this.check(S.STRING)) return {
                    type: "string",
                    value: this.advance().value
                };
                if (this.check(S.REGEX)) return {
                    type: "regex",
                    pattern: this.advance().value
                };
                if (this.check(S.DOLLAR)) return this.advance(), {
                    type: "field",
                    index: this.parseFieldIndex()
                };
                if (this.check(S.LPAREN)) {
                    this.advance();
                    let t = this.parseExpression();
                    if (this.check(S.COMMA)) {
                        let n = [
                            t
                        ];
                        for(; this.check(S.COMMA);)this.advance(), n.push(this.parseExpression());
                        return this.expect(S.RPAREN), {
                            type: "tuple",
                            elements: n
                        };
                    }
                    return this.expect(S.RPAREN), t;
                }
                if (this.check(S.GETLINE)) {
                    this.advance();
                    let t, n;
                    return this.check(S.IDENT) && (t = this.advance().value), this.check(S.LT) && (this.advance(), n = this.parsePrimary()), {
                        type: "getline",
                        variable: t,
                        file: n
                    };
                }
                if (this.check(S.IDENT)) {
                    let t = this.advance().value;
                    if (this.check(S.LPAREN)) {
                        this.advance();
                        let n = [];
                        if (this.skipNewlines(), !this.check(S.RPAREN)) for(n.push(this.parseExpression()); this.check(S.COMMA);)this.advance(), this.skipNewlines(), n.push(this.parseExpression());
                        return this.skipNewlines(), this.expect(S.RPAREN), {
                            type: "call",
                            name: t,
                            args: n
                        };
                    }
                    if (this.check(S.LBRACKET)) {
                        this.advance();
                        let n = [
                            this.parseExpression()
                        ];
                        for(; this.check(S.COMMA);)this.advance(), n.push(this.parseExpression());
                        this.expect(S.RBRACKET);
                        let r;
                        if (n.length === 1) r = n[0];
                        else {
                            r = n[0];
                            for(let s = 1; s < n.length; s++)r = {
                                type: "binary",
                                operator: " ",
                                left: {
                                    type: "binary",
                                    operator: " ",
                                    left: r,
                                    right: {
                                        type: "variable",
                                        name: "SUBSEP"
                                    }
                                },
                                right: n[s]
                            };
                        }
                        return {
                            type: "array_access",
                            array: t,
                            key: r
                        };
                    }
                    return {
                        type: "variable",
                        name: t
                    };
                }
                throw new Error(`Unexpected token: ${this.current().type} at line ${this.current().line}:${this.current().column}`);
            }
        };
    });
    var sf = {};
    V(sf, {
        awkCommand2: ()=>e1
    });
    function mo(e) {
        return e.replace(/\\t/g, "	").replace(/\\n/g, `
`).replace(/\\r/g, "\r").replace(/\\b/g, "\b").replace(/\\f/g, "\f").replace(/\\a/g, "\x07").replace(/\\v/g, "\v").replace(/\\\\/g, "\\");
    }
    function nf(e) {
        if (e === " ") return /\s+/;
        if (/[[\](){}.*+?^$|\\]/.test(e)) try {
            return new RegExp(e);
        } catch  {
            return new RegExp(rf(e));
        }
        return new RegExp(rf(e));
    }
    function rf(e) {
        return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    var Yx, e1, of = v(()=>{
        de();
        X();
        qu();
        tf();
        Yx = {
            name: "awk",
            summary: "pattern scanning and text processing language",
            usage: "awk [OPTIONS] 'PROGRAM' [FILE...]",
            options: [
                "-F FS      use FS as field separator",
                "-v VAR=VAL assign VAL to variable VAR",
                "    --help display this help and exit"
            ]
        }, e1 = {
            name: "awk",
            async execute (e, t) {
                if (_(e)) return F(Yx);
                let n = /\s+/, r = " ", s = {}, i = 0;
                for(let h = 0; h < e.length; h++){
                    let g = e[h];
                    if (g === "-F" && h + 1 < e.length) r = mo(e[++h]), n = nf(r), i = h + 1;
                    else if (g.startsWith("-F")) r = mo(g.slice(2)), n = nf(r), i = h + 1;
                    else if (g === "-v" && h + 1 < e.length) {
                        let b = e[++h], y = b.indexOf("=");
                        if (y > 0) {
                            let w = b.slice(0, y), E = mo(b.slice(y + 1));
                            s[w] = E;
                        }
                        i = h + 1;
                    } else {
                        if (g.startsWith("--")) return G("awk", g);
                        if (g.startsWith("-") && g.length > 1) {
                            let b = g[1];
                            if (b !== "F" && b !== "v") return G("awk", `-${b}`);
                            i = h + 1;
                        } else if (!g.startsWith("-")) {
                            i = h;
                            break;
                        }
                    }
                }
                if (i >= e.length) return {
                    stdout: "",
                    stderr: `awk: missing program
`,
                    exitCode: 1
                };
                let o = e[i], a = e.slice(i + 1), l = new ws(), c;
                try {
                    c = l.parse(o);
                } catch (h) {
                    return {
                        stdout: "",
                        stderr: `awk: ${h instanceof Error ? h.message : String(h)}
`,
                        exitCode: 1
                    };
                }
                let u = {
                    readFile: t.fs.readFile.bind(t.fs),
                    writeFile: t.fs.writeFile.bind(t.fs),
                    appendFile: async (h, g)=>{
                        try {
                            let b = await t.fs.readFile(h);
                            await t.fs.writeFile(h, b + g);
                        } catch  {
                            await t.fs.writeFile(h, g);
                        }
                    },
                    resolvePath: t.fs.resolvePath.bind(t.fs)
                }, f = so({
                    fieldSep: n,
                    maxIterations: t.limits?.maxAwkIterations,
                    fs: u,
                    cwd: t.cwd,
                    exec: t.exec ? (h)=>t.exec(h, {
                            cwd: t.cwd
                        }) : void 0
                });
                f.FS = r, f.vars = {
                    ...s
                }, f.ARGC = a.length + 1, f.ARGV = {
                    0: "awk"
                };
                for(let h = 0; h < a.length; h++)f.ARGV[String(h + 1)] = a[h];
                f.ENVIRON = {
                    ...t.env
                };
                let p = new xr(f);
                p.execute(c);
                let d = c.rules.some((h)=>h.pattern?.type !== "begin" && h.pattern?.type !== "end"), m = c.rules.some((h)=>h.pattern?.type === "end");
                try {
                    if (await p.executeBegin(), f.shouldExit) return await p.executeEnd(), {
                        stdout: p.getOutput(),
                        stderr: "",
                        exitCode: p.getExitCode()
                    };
                    if (!d && !m) return {
                        stdout: p.getOutput(),
                        stderr: "",
                        exitCode: p.getExitCode()
                    };
                    let h = [];
                    if (a.length > 0) for (let g of a)try {
                        let b = t.fs.resolvePath(t.cwd, g), w = (await t.fs.readFile(b)).split(`
`);
                        w.length > 0 && w[w.length - 1] === "" && w.pop(), h.push({
                            filename: g,
                            lines: w
                        });
                    } catch  {
                        return {
                            stdout: "",
                            stderr: `awk: ${g}: No such file or directory
`,
                            exitCode: 1
                        };
                    }
                    else {
                        let g = t.stdin.split(`
`);
                        g.length > 0 && g[g.length - 1] === "" && g.pop(), h.push({
                            filename: "",
                            lines: g
                        });
                    }
                    for (let g of h){
                        for(f.FILENAME = g.filename, f.FNR = 0, f.lines = g.lines, f.lineIndex = -1, f.shouldNextFile = false; f.lineIndex < g.lines.length - 1 && (f.lineIndex++, await p.executeLine(g.lines[f.lineIndex]), !(f.shouldExit || f.shouldNextFile)););
                        if (f.shouldExit) break;
                    }
                    return await p.executeEnd(), {
                        stdout: p.getOutput(),
                        stderr: "",
                        exitCode: p.getExitCode()
                    };
                } catch (h) {
                    let g = h instanceof Error ? h.message : String(h), b = h instanceof ne ? ne.EXIT_CODE : 2;
                    return {
                        stdout: p.getOutput(),
                        stderr: `awk: ${g}
`,
                        exitCode: b
                    };
                }
            }
        };
    });
    function af(e) {
        let t = e.trim(), n = t.match(/^([+-]?\d*\.?\d+)\s*([kmgtpeKMGTPE])?[iI]?[bB]?$/);
        if (!n) {
            let o = parseFloat(t);
            return Number.isNaN(o) ? 0 : o;
        }
        let r = parseFloat(n[1]), s = (n[2] || "").toLowerCase(), i = t1[s] || 1;
        return r * i;
    }
    function lf(e) {
        let t = e.trim().toLowerCase().slice(0, 3);
        return n1[t] || 0;
    }
    function r1(e, t) {
        let n = e.split(/(\d+)/), r = t.split(/(\d+)/), s = Math.max(n.length, r.length);
        for(let i = 0; i < s; i++){
            let o = n[i] || "", a = r[i] || "", l = /^\d+$/.test(o) ? parseInt(o, 10) : null, c = /^\d+$/.test(a) ? parseInt(a, 10) : null;
            if (l !== null && c !== null) {
                if (l !== c) return l - c;
            } else if (o !== a) return o.localeCompare(a);
        }
        return 0;
    }
    function cf(e) {
        return e.replace(/[^a-zA-Z0-9\s]/g, "");
    }
    function go(e, t, n) {
        let r = n !== null ? n : /\s+/, s = e.split(r), i = t.startField - 1;
        if (i >= s.length) return "";
        if (t.endField === void 0) {
            let l = s[i] || "";
            return t.startChar !== void 0 && (l = l.slice(t.startChar - 1)), t.ignoreLeading && (l = l.trimStart()), l;
        }
        let o = Math.min(t.endField - 1, s.length - 1), a = "";
        for(let l = i; l <= o && l < s.length; l++){
            let c = s[l] || "";
            if (l === i && t.startChar !== void 0 && (c = c.slice(t.startChar - 1)), l === o && t.endChar !== void 0) {
                let u = l === i && t.startChar !== void 0 ? t.endChar - t.startChar + 1 : t.endChar;
                c = c.slice(0, u);
            }
            l > i && (a += n || " "), a += c;
        }
        return t.ignoreLeading && (a = a.trimStart()), a;
    }
    function uf(e, t, n) {
        let r = e, s = t;
        if (n.dictionaryOrder && (r = cf(r), s = cf(s)), n.ignoreCase && (r = r.toLowerCase(), s = s.toLowerCase()), n.monthSort) {
            let i = lf(r), o = lf(s);
            return i - o;
        }
        if (n.humanNumeric) {
            let i = af(r), o = af(s);
            return i - o;
        }
        if (n.versionSort) return r1(r, s);
        if (n.numeric) {
            let i = parseFloat(r) || 0, o = parseFloat(s) || 0;
            return i - o;
        }
        return r.localeCompare(s);
    }
    function ff(e) {
        let { keys: t, fieldDelimiter: n, numeric: r, ignoreCase: s, reverse: i, humanNumeric: o, versionSort: a, dictionaryOrder: l, monthSort: c, ignoreLeadingBlanks: u, stable: f } = e;
        return (p, d)=>{
            let m = p, h = d;
            if (u && (m = m.trimStart(), h = h.trimStart()), t.length === 0) {
                let b = uf(m, h, {
                    numeric: r,
                    ignoreCase: s,
                    humanNumeric: o,
                    versionSort: a,
                    dictionaryOrder: l,
                    monthSort: c
                });
                if (b !== 0) return i ? -b : b;
                if (!f) {
                    let y = p.localeCompare(d);
                    return i ? -y : y;
                }
                return 0;
            }
            for (let g of t){
                let b = go(m, g, n), y = go(h, g, n);
                g.ignoreLeading && (b = b.trimStart(), y = y.trimStart());
                let w = {
                    numeric: g.numeric ?? r,
                    ignoreCase: g.ignoreCase ?? s,
                    humanNumeric: g.humanNumeric ?? o,
                    versionSort: g.versionSort ?? a,
                    dictionaryOrder: g.dictionaryOrder ?? l,
                    monthSort: g.monthSort ?? c
                }, E = g.reverse ?? i, C = uf(b, y, w);
                if (C !== 0) return E ? -C : C;
            }
            if (!f) {
                let g = p.localeCompare(d);
                return i ? -g : g;
            }
            return 0;
        };
    }
    function pf(e, t) {
        if (t.keys.length === 0) {
            if (t.ignoreCase) {
                let s = new Set();
                return e.filter((i)=>{
                    let o = i.toLowerCase();
                    return s.has(o) ? false : (s.add(o), true);
                });
            }
            return [
                ...new Set(e)
            ];
        }
        let n = t.keys[0], r = new Set();
        return e.filter((s)=>{
            let i = go(s, n, t.fieldDelimiter);
            return (n.ignoreCase ?? t.ignoreCase) && (i = i.toLowerCase()), r.has(i) ? false : (r.add(i), true);
        });
    }
    var t1, n1, df = v(()=>{
        t1 = {
            "": 1,
            k: 1024,
            m: 1048576,
            g: 1073741824,
            t: 1099511627776,
            p: 1125899906842624,
            e: 1152921504606847e3
        }, n1 = {
            jan: 1,
            feb: 2,
            mar: 3,
            apr: 4,
            may: 5,
            jun: 6,
            jul: 7,
            aug: 8,
            sep: 9,
            oct: 10,
            nov: 11,
            dec: 12
        };
    });
    function xs(e) {
        let t = {
            startField: 1
        }, n = "", r = e, s = r.match(/([bdfhMnrV]+)$/);
        s && (n = s[1], r = r.slice(0, -n.length)), n.includes("n") && (t.numeric = true), n.includes("r") && (t.reverse = true), n.includes("f") && (t.ignoreCase = true), n.includes("b") && (t.ignoreLeading = true), n.includes("h") && (t.humanNumeric = true), n.includes("V") && (t.versionSort = true), n.includes("d") && (t.dictionaryOrder = true), n.includes("M") && (t.monthSort = true);
        let i = r.split(",");
        if (i.length === 0 || i[0] === "") return null;
        let o = i[0].split("."), a = parseInt(o[0], 10);
        if (Number.isNaN(a) || a < 1) return null;
        if (t.startField = a, o.length > 1 && o[1]) {
            let l = parseInt(o[1], 10);
            !Number.isNaN(l) && l >= 1 && (t.startChar = l);
        }
        if (i.length > 1 && i[1]) {
            let l = i[1], c = l.match(/([bdfhMnrV]+)$/);
            if (c) {
                let f = c[1];
                f.includes("n") && (t.numeric = true), f.includes("r") && (t.reverse = true), f.includes("f") && (t.ignoreCase = true), f.includes("b") && (t.ignoreLeading = true), f.includes("h") && (t.humanNumeric = true), f.includes("V") && (t.versionSort = true), f.includes("d") && (t.dictionaryOrder = true), f.includes("M") && (t.monthSort = true), l = l.slice(0, -f.length);
            }
            let u = l.split(".");
            if (u[0]) {
                let f = parseInt(u[0], 10);
                if (!Number.isNaN(f) && f >= 1 && (t.endField = f), u.length > 1 && u[1]) {
                    let p = parseInt(u[1], 10);
                    !Number.isNaN(p) && p >= 1 && (t.endChar = p);
                }
            }
        }
        return t;
    }
    var hf = v(()=>{});
    var mf = {};
    V(mf, {
        sortCommand: ()=>i1
    });
    var s1, i1, gf = v(()=>{
        pn();
        X();
        df();
        hf();
        s1 = {
            name: "sort",
            summary: "sort lines of text files",
            usage: "sort [OPTION]... [FILE]...",
            options: [
                "-b, --ignore-leading-blanks  ignore leading blanks",
                "-d, --dictionary-order  consider only blanks and alphanumeric characters",
                "-f, --ignore-case    fold lower case to upper case characters",
                "-h, --human-numeric-sort  compare human readable numbers (e.g., 2K 1G)",
                "-M, --month-sort     compare (unknown) < 'JAN' < ... < 'DEC'",
                "-n, --numeric-sort   compare according to string numerical value",
                "-r, --reverse        reverse the result of comparisons",
                "-V, --version-sort   natural sort of (version) numbers within text",
                "-c, --check          check for sorted input; do not sort",
                "-o, --output=FILE    write result to FILE instead of stdout",
                "-s, --stable         stabilize sort by disabling last-resort comparison",
                "-u, --unique         output only unique lines",
                "-k, --key=KEYDEF     sort via a key; KEYDEF gives location and type",
                "-t, --field-separator=SEP  use SEP as field separator",
                "    --help           display this help and exit"
            ],
            description: `KEYDEF is F[.C][OPTS][,F[.C][OPTS]]
  F is a field number (1-indexed)
  C is a character position within the field (1-indexed)
  OPTS can be: b d f h M n r V (per-key modifiers)

Examples:
  -k1        sort by first field
  -k2,2      sort by second field only
  -k1.3      sort by first field starting at 3rd character
  -k1,2n     sort by fields 1-2 numerically
  -k2 -k1    sort by field 2, then by field 1`
        }, i1 = {
            name: "sort",
            async execute (e, t) {
                if (_(e)) return F(s1);
                let n = {
                    reverse: false,
                    numeric: false,
                    unique: false,
                    ignoreCase: false,
                    humanNumeric: false,
                    versionSort: false,
                    dictionaryOrder: false,
                    monthSort: false,
                    ignoreLeadingBlanks: false,
                    stable: false,
                    checkOnly: false,
                    outputFile: null,
                    keys: [],
                    fieldDelimiter: null
                }, r = [];
                for(let c = 0; c < e.length; c++){
                    let u = e[c];
                    if (u === "-r" || u === "--reverse") n.reverse = true;
                    else if (u === "-n" || u === "--numeric-sort") n.numeric = true;
                    else if (u === "-u" || u === "--unique") n.unique = true;
                    else if (u === "-f" || u === "--ignore-case") n.ignoreCase = true;
                    else if (u === "-h" || u === "--human-numeric-sort") n.humanNumeric = true;
                    else if (u === "-V" || u === "--version-sort") n.versionSort = true;
                    else if (u === "-d" || u === "--dictionary-order") n.dictionaryOrder = true;
                    else if (u === "-M" || u === "--month-sort") n.monthSort = true;
                    else if (u === "-b" || u === "--ignore-leading-blanks") n.ignoreLeadingBlanks = true;
                    else if (u === "-s" || u === "--stable") n.stable = true;
                    else if (u === "-c" || u === "--check") n.checkOnly = true;
                    else if (u === "-o" || u === "--output") n.outputFile = e[++c] || null;
                    else if (u.startsWith("-o")) n.outputFile = u.slice(2) || null;
                    else if (u.startsWith("--output=")) n.outputFile = u.slice(9) || null;
                    else if (u === "-t" || u === "--field-separator") n.fieldDelimiter = e[++c] || null;
                    else if (u.startsWith("-t")) n.fieldDelimiter = u.slice(2) || null;
                    else if (u.startsWith("--field-separator=")) n.fieldDelimiter = u.slice(18) || null;
                    else if (u === "-k" || u === "--key") {
                        let f = e[++c];
                        if (f) {
                            let p = xs(f);
                            p && n.keys.push(p);
                        }
                    } else if (u.startsWith("-k")) {
                        let f = xs(u.slice(2));
                        f && n.keys.push(f);
                    } else if (u.startsWith("--key=")) {
                        let f = xs(u.slice(6));
                        f && n.keys.push(f);
                    } else {
                        if (u.startsWith("--")) return G("sort", u);
                        if (u.startsWith("-") && !u.startsWith("--")) {
                            let f = false;
                            for (let p of u.slice(1))if (p === "r") n.reverse = true;
                            else if (p === "n") n.numeric = true;
                            else if (p === "u") n.unique = true;
                            else if (p === "f") n.ignoreCase = true;
                            else if (p === "h") n.humanNumeric = true;
                            else if (p === "V") n.versionSort = true;
                            else if (p === "d") n.dictionaryOrder = true;
                            else if (p === "M") n.monthSort = true;
                            else if (p === "b") n.ignoreLeadingBlanks = true;
                            else if (p === "s") n.stable = true;
                            else if (p === "c") n.checkOnly = true;
                            else {
                                f = true;
                                break;
                            }
                            if (f) return G("sort", u);
                        } else r.push(u);
                    }
                }
                let s = await Tn(t, r, {
                    cmdName: "sort"
                });
                if (!s.ok) return s.error;
                let o = s.content.split(`
`);
                o.length > 0 && o[o.length - 1] === "" && o.pop();
                let a = ff(n);
                if (n.checkOnly) {
                    let c = r.length > 0 ? r[0] : "-";
                    for(let u = 1; u < o.length; u++)if (a(o[u - 1], o[u]) > 0) return {
                        stdout: "",
                        stderr: `sort: ${c}:${u + 1}: disorder: ${o[u]}
`,
                        exitCode: 1
                    };
                    return {
                        stdout: "",
                        stderr: "",
                        exitCode: 0
                    };
                }
                o.sort(a), n.unique && (o = pf(o, n));
                let l = o.length > 0 ? `${o.join(`
`)}
` : "";
                if (n.outputFile) {
                    let c = t.fs.resolvePath(t.cwd, n.outputFile);
                    return await t.fs.writeFile(c, l), {
                        stdout: "",
                        stderr: "",
                        exitCode: 0
                    };
                }
                return {
                    stdout: l,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var yf = {};
    V(yf, {
        uniqCommand: ()=>l1
    });
    var o1, a1, l1, bf = v(()=>{
        Oe();
        pn();
        X();
        o1 = {
            name: "uniq",
            summary: "report or omit repeated lines",
            usage: "uniq [OPTION]... [INPUT [OUTPUT]]",
            options: [
                "-c, --count        prefix lines by the number of occurrences",
                "-d, --repeated     only print duplicate lines",
                "-i, --ignore-case  ignore case when comparing",
                "-u, --unique       only print unique lines",
                "    --help         display this help and exit"
            ]
        }, a1 = {
            count: {
                short: "c",
                long: "count",
                type: "boolean"
            },
            duplicatesOnly: {
                short: "d",
                long: "repeated",
                type: "boolean"
            },
            uniqueOnly: {
                short: "u",
                long: "unique",
                type: "boolean"
            },
            ignoreCase: {
                short: "i",
                long: "ignore-case",
                type: "boolean"
            }
        }, l1 = {
            name: "uniq",
            async execute (e, t) {
                if (_(e)) return F(o1);
                let n = fe("uniq", e, a1);
                if (!n.ok) return n.error;
                let { count: r, duplicatesOnly: s, uniqueOnly: i, ignoreCase: o } = n.result.flags, a = n.result.positional, l = await Tn(t, a, {
                    cmdName: "uniq"
                });
                if (!l.ok) return l.error;
                let u = l.content.split(`
`);
                if (u.length > 0 && u[u.length - 1] === "" && u.pop(), u.length === 0) return {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                };
                let f = [], p = u[0], d = 1, m = (b, y)=>o ? b.toLowerCase() === y.toLowerCase() : b === y;
                for(let b = 1; b < u.length; b++)m(u[b], p) ? d++ : (f.push({
                    line: p,
                    count: d
                }), p = u[b], d = 1);
                f.push({
                    line: p,
                    count: d
                });
                let h = f;
                s ? h = f.filter((b)=>b.count > 1) : i && (h = f.filter((b)=>b.count === 1));
                let g = "";
                for (let { line: b, count: y } of h)r ? g += `${String(y).padStart(4)} ${b}
` : g += `${b}
`;
                return {
                    stdout: g,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var wf = {};
    V(wf, {
        commCommand: ()=>u1
    });
    var c1, u1, xf = v(()=>{
        X();
        c1 = {
            name: "comm",
            summary: "compare two sorted files line by line",
            usage: "comm [OPTION]... FILE1 FILE2",
            options: [
                "-1             suppress column 1 (lines unique to FILE1)",
                "-2             suppress column 2 (lines unique to FILE2)",
                "-3             suppress column 3 (lines that appear in both files)",
                "    --help     display this help and exit"
            ]
        }, u1 = {
            name: "comm",
            async execute (e, t) {
                if (_(e)) return F(c1);
                let n = false, r = false, s = false, i = [];
                for (let g of e)if (g === "-1") n = true;
                else if (g === "-2") r = true;
                else if (g === "-3") s = true;
                else if (g === "-12" || g === "-21") n = true, r = true;
                else if (g === "-13" || g === "-31") n = true, s = true;
                else if (g === "-23" || g === "-32") r = true, s = true;
                else if (g === "-123" || g === "-132" || g === "-213" || g === "-231" || g === "-312" || g === "-321") n = true, r = true, s = true;
                else {
                    if (g.startsWith("-") && g !== "-") return G("comm", g);
                    i.push(g);
                }
                if (i.length !== 2) return {
                    stdout: "",
                    stderr: `comm: missing operand
Try 'comm --help' for more information.
`,
                    exitCode: 1
                };
                let o = async (g)=>{
                    if (g === "-") return t.stdin;
                    try {
                        let b = t.fs.resolvePath(t.cwd, g);
                        return await t.fs.readFile(b);
                    } catch  {
                        return null;
                    }
                }, a = await o(i[0]);
                if (a === null) return {
                    stdout: "",
                    stderr: `comm: ${i[0]}: No such file or directory
`,
                    exitCode: 1
                };
                let l = await o(i[1]);
                if (l === null) return {
                    stdout: "",
                    stderr: `comm: ${i[1]}: No such file or directory
`,
                    exitCode: 1
                };
                let c = a.split(`
`), u = l.split(`
`);
                c.length > 0 && c[c.length - 1] === "" && c.pop(), u.length > 0 && u[u.length - 1] === "" && u.pop();
                let f = 0, p = 0, d = "", m = n ? "" : "	", h = (n ? "" : "	") + (r ? "" : "	");
                for(; f < c.length || p < u.length;)f >= c.length ? (r || (d += `${m}${u[p]}
`), p++) : p >= u.length ? (n || (d += `${c[f]}
`), f++) : c[f] < u[p] ? (n || (d += `${c[f]}
`), f++) : c[f] > u[p] ? (r || (d += `${m}${u[p]}
`), p++) : (s || (d += `${h}${c[f]}
`), f++, p++);
                return {
                    stdout: d,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var Ef = {};
    V(Ef, {
        cutCommand: ()=>h1
    });
    function p1(e) {
        let t = [], n = e.split(",");
        for (let r of n)if (r.includes("-")) {
            let [s, i] = r.split("-");
            t.push({
                start: s ? parseInt(s, 10) : 1,
                end: i ? parseInt(i, 10) : null
            });
        } else {
            let s = parseInt(r, 10);
            t.push({
                start: s,
                end: s
            });
        }
        return t;
    }
    function d1(e, t) {
        let n = [];
        for (let r of t){
            let s = r.start - 1, i = r.end === null ? e.length : r.end;
            for(let o = s; o < i && o < e.length; o++)o >= 0 && !n.includes(e[o]) && n.push(e[o]);
        }
        return n;
    }
    var f1, h1, Sf = v(()=>{
        pn();
        X();
        f1 = {
            name: "cut",
            summary: "remove sections from each line of files",
            usage: "cut [OPTION]... [FILE]...",
            options: [
                "-c LIST              select only these characters",
                "-d DELIM             use DELIM instead of TAB for field delimiter",
                "-f LIST              select only these fields",
                "-s, --only-delimited  do not print lines without delimiters",
                "    --help           display this help and exit"
            ]
        };
        h1 = {
            name: "cut",
            async execute (e, t) {
                if (_(e)) return F(f1);
                let n = "	", r = null, s = null, i = false, o = [];
                for(let p = 0; p < e.length; p++){
                    let d = e[p];
                    if (d === "-d") n = e[++p] || "	";
                    else if (d.startsWith("-d")) n = d.slice(2);
                    else if (d === "-f") r = e[++p];
                    else if (d.startsWith("-f")) r = d.slice(2);
                    else if (d === "-c") s = e[++p];
                    else if (d.startsWith("-c")) s = d.slice(2);
                    else if (d === "-s" || d === "--only-delimited") i = true;
                    else {
                        if (d.startsWith("--")) return G("cut", d);
                        if (d.startsWith("-")) {
                            let m = false;
                            for (let h of d.slice(1))if (h === "s") i = true;
                            else if (!"dfc".includes(h)) {
                                m = true;
                                break;
                            }
                            if (m) return G("cut", d);
                        } else o.push(d);
                    }
                }
                if (!r && !s) return {
                    stdout: "",
                    stderr: `cut: you must specify a list of bytes, characters, or fields
`,
                    exitCode: 1
                };
                let a = await Tn(t, o, {
                    cmdName: "cut"
                });
                if (!a.ok) return a.error;
                let c = a.content.split(`
`);
                c.length > 0 && c[c.length - 1] === "" && c.pop();
                let u = p1(r || s || "1"), f = "";
                for (let p of c)if (s) {
                    let d = p.split(""), m = [];
                    for (let h of u){
                        let g = h.start - 1, b = h.end === null ? d.length : h.end;
                        for(let y = g; y < b && y < d.length; y++)y >= 0 && m.push(d[y]);
                    }
                    f += `${m.join("")}
`;
                } else {
                    if (i && !p.includes(n)) continue;
                    let d = p.split(n), m = d1(d, u);
                    f += `${m.join(n)}
`;
                }
                return {
                    stdout: f,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var Cf = {};
    V(Cf, {
        pasteCommand: ()=>y1
    });
    function Af(e, t) {
        if (e.length === 0) return "";
        if (e.length === 1) return e[0];
        let n = e[0];
        for(let r = 1; r < e.length; r++){
            let s = (r - 1) % t.length;
            n += t[s] + e[r];
        }
        return n;
    }
    var m1, g1, y1, Nf = v(()=>{
        Oe();
        X();
        m1 = {
            name: "paste",
            summary: "merge lines of files",
            usage: "paste [OPTION]... [FILE]...",
            description: [
                "Write lines consisting of the sequentially corresponding lines from",
                "each FILE, separated by TABs, to standard output.",
                "",
                "With no FILE, or when FILE is -, read standard input."
            ],
            options: [
                "-d, --delimiters=LIST   reuse characters from LIST instead of TABs",
                "-s, --serial            paste one file at a time instead of in parallel",
                "    --help              display this help and exit"
            ],
            examples: [
                "paste file1 file2       Merge file1 and file2 side by side",
                "paste -d, file1 file2   Use comma as delimiter",
                "paste -s file1          Paste all lines of file1 on one line",
                "paste - - < file        Paste pairs of lines from file"
            ]
        }, g1 = {
            delimiter: {
                short: "d",
                long: "delimiters",
                type: "string",
                default: "	"
            },
            serial: {
                short: "s",
                long: "serial",
                type: "boolean"
            }
        }, y1 = {
            name: "paste",
            async execute (e, t) {
                if (_(e)) return F(m1);
                let n = fe("paste", e, g1);
                if (!n.ok) return n.error;
                let r = n.result.flags.delimiter, s = n.result.flags.serial, i = n.result.positional;
                if (i.length === 0) return {
                    stdout: "",
                    stderr: `usage: paste [-s] [-d delimiters] file ...
`,
                    exitCode: 1
                };
                let o = t.stdin ? t.stdin.split(`
`) : [
                    ""
                ];
                o.length > 0 && o[o.length - 1] === "" && o.pop();
                let a = i.filter((f)=>f === "-").length, l = [], c = 0;
                for (let f of i)if (f === "-") {
                    let p = [];
                    for(let d = c; d < o.length; d += a)p.push(o[d]);
                    l.push(p), c++;
                } else {
                    let p = t.fs.resolvePath(t.cwd, f);
                    try {
                        let m = (await t.fs.readFile(p)).split(`
`);
                        m.length > 0 && m[m.length - 1] === "" && m.pop(), l.push(m);
                    } catch  {
                        return {
                            stdout: "",
                            stderr: `paste: ${f}: No such file or directory
`,
                            exitCode: 1
                        };
                    }
                }
                let u = "";
                if (s) for (let f of l)f && (u += `${Af(f, r)}
`);
                else {
                    let f = Math.max(...l.map((p)=>p?.length ?? 0));
                    for(let p = 0; p < f; p++){
                        let d = [];
                        for (let m of l)d.push(m?.[p] ?? "");
                        u += `${Af(d, r)}
`;
                    }
                }
                return {
                    stdout: u,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var vf = {};
    V(vf, {
        trCommand: ()=>E1
    });
    function kf(e) {
        let t = "", n = 0;
        for(; n < e.length;){
            if (e[n] === "[" && e[n + 1] === ":") {
                let r = false;
                for (let [s, i] of Object.entries(w1))if (e.slice(n).startsWith(s)) {
                    t += i, n += s.length, r = true;
                    break;
                }
                if (r) continue;
            }
            if (e[n] === "\\" && n + 1 < e.length) {
                let r = e[n + 1];
                r === "n" ? t += `
` : r === "t" ? t += "	" : r === "r" ? t += "\r" : t += r, n += 2;
                continue;
            }
            if (n + 2 < e.length && e[n + 1] === "-") {
                let r = e.charCodeAt(n), s = e.charCodeAt(n + 2);
                for(let i = r; i <= s; i++)t += String.fromCharCode(i);
                n += 3;
                continue;
            }
            t += e[n], n++;
        }
        return t;
    }
    var b1, w1, x1, E1, $f = v(()=>{
        Oe();
        X();
        b1 = {
            name: "tr",
            summary: "translate or delete characters",
            usage: "tr [OPTION]... SET1 [SET2]",
            options: [
                "-c, -C, --complement   use the complement of SET1",
                "-d, --delete           delete characters in SET1",
                "-s, --squeeze-repeats  squeeze repeated characters",
                "    --help             display this help and exit"
            ],
            description: `SET syntax:
  a-z         character range
  [:alnum:]   all letters and digits
  [:alpha:]   all letters
  [:digit:]   all digits
  [:lower:]   all lowercase letters
  [:upper:]   all uppercase letters
  [:space:]   all whitespace
  [:blank:]   horizontal whitespace
  [:punct:]   all punctuation
  [:print:]   all printable characters
  [:graph:]   all printable characters except space
  [:cntrl:]   all control characters
  [:xdigit:]  all hexadecimal digits
  \\n, \\t, \\r  escape sequences`
        }, w1 = {
            "[:alnum:]": "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
            "[:alpha:]": "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
            "[:blank:]": " 	",
            "[:cntrl:]": Array.from({
                length: 32
            }, (e, t)=>String.fromCharCode(t)).join("").concat(""),
            "[:digit:]": "0123456789",
            "[:graph:]": Array.from({
                length: 94
            }, (e, t)=>String.fromCharCode(33 + t)).join(""),
            "[:lower:]": "abcdefghijklmnopqrstuvwxyz",
            "[:print:]": Array.from({
                length: 95
            }, (e, t)=>String.fromCharCode(32 + t)).join(""),
            "[:punct:]": "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~",
            "[:space:]": ` 	
\r\f\v`,
            "[:upper:]": "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
            "[:xdigit:]": "0123456789ABCDEFabcdef"
        };
        x1 = {
            complement: {
                short: "c",
                long: "complement",
                type: "boolean"
            },
            complementUpper: {
                short: "C",
                type: "boolean"
            },
            delete: {
                short: "d",
                long: "delete",
                type: "boolean"
            },
            squeeze: {
                short: "s",
                long: "squeeze-repeats",
                type: "boolean"
            }
        }, E1 = {
            name: "tr",
            async execute (e, t) {
                if (_(e)) return F(b1);
                let n = fe("tr", e, x1);
                if (!n.ok) return n.error;
                let r = n.result.flags.complement || n.result.flags.complementUpper, s = n.result.flags.delete, i = n.result.flags.squeeze, o = n.result.positional;
                if (o.length < 1) return {
                    stdout: "",
                    stderr: `tr: missing operand
`,
                    exitCode: 1
                };
                if (!s && !i && o.length < 2) return {
                    stdout: "",
                    stderr: `tr: missing operand after SET1
`,
                    exitCode: 1
                };
                let a = kf(o[0]), l = o.length > 1 ? kf(o[1]) : "", c = t.stdin, u = (p)=>{
                    let d = a.includes(p);
                    return r ? !d : d;
                }, f = "";
                if (s) for (let p of c)u(p) || (f += p);
                else if (i && o.length === 1) {
                    let p = "";
                    for (let d of c)u(d) && d === p || (f += d, p = d);
                } else {
                    if (r) {
                        let p = l.length > 0 ? l[l.length - 1] : "";
                        for (let d of c)a.includes(d) ? f += d : f += p;
                    } else {
                        let p = new Map();
                        for(let d = 0; d < a.length; d++){
                            let m = d < l.length ? l[d] : l[l.length - 1];
                            p.set(a[d], m);
                        }
                        for (let d of c)f += p.get(d) ?? d;
                    }
                    if (i) {
                        let p = "", d = "";
                        for (let m of f)l.includes(m) && m === d || (p += m, d = m);
                        f = p;
                    }
                }
                return {
                    stdout: f,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var If = {};
    V(If, {
        rev: ()=>C1
    });
    function A1(e) {
        return Array.from(e).reverse().join("");
    }
    var S1, C1, Rf = v(()=>{
        X();
        S1 = {
            name: "rev",
            summary: "reverse lines characterwise",
            usage: "rev [file ...]",
            description: "Copies the specified files to standard output, reversing the order of characters in every line. If no files are specified, standard input is read.",
            examples: [
                "echo 'hello' | rev     # Output: olleh",
                "rev file.txt           # Reverse each line in file"
            ]
        };
        C1 = {
            name: "rev",
            execute: async (e, t)=>{
                if (_(e)) return F(S1);
                let n = [];
                for (let i of e)if (i === "--") {
                    let o = e.indexOf(i);
                    n.push(...e.slice(o + 1));
                    break;
                } else {
                    if (i.startsWith("-") && i !== "-") return G("rev", i);
                    n.push(i);
                }
                let r = "", s = (i)=>{
                    let o = i.split(`
`), a = i.endsWith(`
`) && o[o.length - 1] === "";
                    return a && o.pop(), o.map(A1).join(`
`) + (a ? `
` : "");
                };
                if (n.length === 0) {
                    let i = t.stdin ?? "";
                    r = s(i);
                } else for (let i of n)if (i === "-") {
                    let o = t.stdin ?? "";
                    r += s(o);
                } else {
                    let o = t.fs.resolvePath(t.cwd, i), a = await t.fs.readFile(o);
                    if (a === null) return {
                        exitCode: 1,
                        stdout: r,
                        stderr: `rev: ${i}: No such file or directory
`
                    };
                    r += s(a);
                }
                return {
                    exitCode: 0,
                    stdout: r,
                    stderr: ""
                };
            }
        };
    });
    var Tf = {};
    V(Tf, {
        nl: ()=>$1
    });
    function k1(e, t, n) {
        let r = String(e);
        switch(t){
            case "ln":
                return r.padEnd(n);
            case "rn":
                return r.padStart(n);
            case "rz":
                return r.padStart(n, "0");
            default:
                return t;
        }
    }
    function v1(e, t) {
        switch(t){
            case "a":
                return true;
            case "t":
                return e.trim().length > 0;
            case "n":
                return false;
            default:
                return t;
        }
    }
    function Pf(e, t, n) {
        if (e === "") return {
            output: "",
            nextNumber: n
        };
        let r = e.split(`
`), s = [], i = n, o = e.endsWith(`
`) && r[r.length - 1] === "";
        o && r.pop();
        for (let a of r)if (v1(a, t.bodyStyle)) {
            let l = k1(i, t.numberFormat, t.width);
            s.push(`${l}${t.separator}${a}`), i += t.increment;
        } else {
            let l = " ".repeat(t.width);
            s.push(`${l}${t.separator}${a}`);
        }
        return {
            output: s.join(`
`) + (o ? `
` : ""),
            nextNumber: i
        };
    }
    var N1, $1, Of = v(()=>{
        X();
        N1 = {
            name: "nl",
            summary: "number lines of files",
            usage: "nl [OPTION]... [FILE]...",
            description: "Write each FILE to standard output, with line numbers added. If no FILE is specified, standard input is read.",
            options: [
                "-b STYLE     Body numbering style: a (all), t (non-empty), n (none)",
                "-n FORMAT    Number format: ln (left), rn (right), rz (right zeros)",
                "-w WIDTH     Number width (default: 6)",
                "-s SEP       Separator after number (default: TAB)",
                "-v START     Starting line number (default: 1)",
                "-i INCR      Line number increment (default: 1)"
            ],
            examples: [
                "nl file.txt              # Number non-empty lines",
                "nl -ba file.txt          # Number all lines",
                "nl -n rz -w 3 file.txt   # Right-justified with zeros",
                "nl -s ': ' file.txt      # Use ': ' as separator"
            ]
        };
        $1 = {
            name: "nl",
            execute: async (e, t)=>{
                if (_(e)) return F(N1);
                let n = {
                    bodyStyle: "t",
                    numberFormat: "rn",
                    width: 6,
                    separator: "	",
                    startNumber: 1,
                    increment: 1
                }, r = [], s = 0;
                for(; s < e.length;){
                    let a = e[s];
                    if (a === "-b" && s + 1 < e.length) {
                        let l = e[s + 1];
                        if (l !== "a" && l !== "t" && l !== "n") return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `nl: invalid body numbering style: '${l}'
`
                        };
                        n.bodyStyle = l, s += 2;
                    } else if (a.startsWith("-b")) {
                        let l = a.slice(2);
                        if (l !== "a" && l !== "t" && l !== "n") return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `nl: invalid body numbering style: '${l}'
`
                        };
                        n.bodyStyle = l, s++;
                    } else if (a === "-n" && s + 1 < e.length) {
                        let l = e[s + 1];
                        if (l !== "ln" && l !== "rn" && l !== "rz") return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `nl: invalid line numbering format: '${l}'
`
                        };
                        n.numberFormat = l, s += 2;
                    } else if (a.startsWith("-n")) {
                        let l = a.slice(2);
                        if (l !== "ln" && l !== "rn" && l !== "rz") return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `nl: invalid line numbering format: '${l}'
`
                        };
                        n.numberFormat = l, s++;
                    } else if (a === "-w" && s + 1 < e.length) {
                        let l = parseInt(e[s + 1], 10);
                        if (Number.isNaN(l) || l < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `nl: invalid line number field width: '${e[s + 1]}'
`
                        };
                        n.width = l, s += 2;
                    } else if (a.startsWith("-w")) {
                        let l = parseInt(a.slice(2), 10);
                        if (Number.isNaN(l) || l < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `nl: invalid line number field width: '${a.slice(2)}'
`
                        };
                        n.width = l, s++;
                    } else if (a === "-s" && s + 1 < e.length) n.separator = e[s + 1], s += 2;
                    else if (a.startsWith("-s")) n.separator = a.slice(2), s++;
                    else if (a === "-v" && s + 1 < e.length) {
                        let l = parseInt(e[s + 1], 10);
                        if (Number.isNaN(l)) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `nl: invalid starting line number: '${e[s + 1]}'
`
                        };
                        n.startNumber = l, s += 2;
                    } else if (a.startsWith("-v")) {
                        let l = parseInt(a.slice(2), 10);
                        if (Number.isNaN(l)) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `nl: invalid starting line number: '${a.slice(2)}'
`
                        };
                        n.startNumber = l, s++;
                    } else if (a === "-i" && s + 1 < e.length) {
                        let l = parseInt(e[s + 1], 10);
                        if (Number.isNaN(l)) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `nl: invalid line number increment: '${e[s + 1]}'
`
                        };
                        n.increment = l, s += 2;
                    } else if (a.startsWith("-i")) {
                        let l = parseInt(a.slice(2), 10);
                        if (Number.isNaN(l)) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `nl: invalid line number increment: '${a.slice(2)}'
`
                        };
                        n.increment = l, s++;
                    } else if (a === "--") {
                        r.push(...e.slice(s + 1));
                        break;
                    } else {
                        if (a.startsWith("-") && a !== "-") return G("nl", a);
                        r.push(a), s++;
                    }
                }
                let i = "", o = n.startNumber;
                if (r.length === 0) {
                    let a = t.stdin ?? "";
                    i = Pf(a, n, o).output;
                } else for (let a of r){
                    let l = t.fs.resolvePath(t.cwd, a), c = await t.fs.readFile(l);
                    if (c === null) return {
                        exitCode: 1,
                        stdout: i,
                        stderr: `nl: ${a}: No such file or directory
`
                    };
                    let u = Pf(c, n, o);
                    i += u.output, o = u.nextNumber;
                }
                return {
                    exitCode: 0,
                    stdout: i,
                    stderr: ""
                };
            }
        };
    });
    var Ff = {};
    V(Ff, {
        fold: ()=>T1
    });
    function R1(e, t, n) {
        return n ? new TextEncoder().encode(e).length : e === "	" ? 8 - t % 8 : e === "\b" ? -1 : 1;
    }
    function P1(e, t) {
        if (e.length === 0) return e;
        let { width: n, breakAtSpaces: r, countBytes: s } = t, i = [], o = "", a = 0, l = -1, c = 0;
        for(let u = 0; u < e.length; u++){
            let f = e[u], p = R1(f, a, s);
            a + p > n && o.length > 0 ? r && l >= 0 ? (i.push(o.slice(0, l + 1)), o = o.slice(l + 1) + f, a = a - c - 1 + p, l = -1, c = 0) : (i.push(o), o = f, a = p, l = -1, c = 0) : (o += f, a += p, (f === " " || f === "	") && (l = o.length - 1, c = a - p));
        }
        return o.length > 0 && i.push(o), i.join(`
`);
    }
    function Df(e, t) {
        if (e === "") return "";
        let n = e.split(`
`), r = e.endsWith(`
`) && n[n.length - 1] === "";
        return r && n.pop(), n.map((i)=>P1(i, t)).join(`
`) + (r ? `
` : "");
    }
    var I1, T1, _f = v(()=>{
        X();
        I1 = {
            name: "fold",
            summary: "wrap each input line to fit in specified width",
            usage: "fold [OPTION]... [FILE]...",
            description: "Wrap input lines in each FILE, writing to standard output. If no FILE is specified, standard input is read.",
            options: [
                "-w WIDTH    Use WIDTH columns instead of 80",
                "-s          Break at spaces",
                "-b          Count bytes rather than columns"
            ],
            examples: [
                "fold -w 40 file.txt           # Wrap at 40 columns",
                "fold -sw 40 file.txt          # Word wrap at 40 columns",
                "echo 'long line' | fold -w 5  # Force wrap at 5"
            ]
        };
        T1 = {
            name: "fold",
            execute: async (e, t)=>{
                if (_(e)) return F(I1);
                let n = {
                    width: 80,
                    breakAtSpaces: false,
                    countBytes: false
                }, r = [], s = 0;
                for(; s < e.length;){
                    let o = e[s];
                    if (o === "-w" && s + 1 < e.length) {
                        let a = parseInt(e[s + 1], 10);
                        if (Number.isNaN(a) || a < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `fold: invalid number of columns: '${e[s + 1]}'
`
                        };
                        n.width = a, s += 2;
                    } else if (o.startsWith("-w") && o.length > 2) {
                        let a = parseInt(o.slice(2), 10);
                        if (Number.isNaN(a) || a < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `fold: invalid number of columns: '${o.slice(2)}'
`
                        };
                        n.width = a, s++;
                    } else if (o === "-s") n.breakAtSpaces = true, s++;
                    else if (o === "-b") n.countBytes = true, s++;
                    else if (o === "-bs" || o === "-sb") n.breakAtSpaces = true, n.countBytes = true, s++;
                    else if (o.match(/^-[sb]+w\d+$/)) {
                        o.includes("s") && (n.breakAtSpaces = true), o.includes("b") && (n.countBytes = true);
                        let a = o.replace(/^-[sb]+w/, ""), l = parseInt(a, 10);
                        if (Number.isNaN(l) || l < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `fold: invalid number of columns: '${a}'
`
                        };
                        n.width = l, s++;
                    } else if (o.match(/^-[sb]+w$/) && s + 1 < e.length) {
                        o.includes("s") && (n.breakAtSpaces = true), o.includes("b") && (n.countBytes = true);
                        let a = parseInt(e[s + 1], 10);
                        if (Number.isNaN(a) || a < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `fold: invalid number of columns: '${e[s + 1]}'
`
                        };
                        n.width = a, s += 2;
                    } else if (o === "--") {
                        r.push(...e.slice(s + 1));
                        break;
                    } else if (o.startsWith("-") && o !== "-") {
                        let a = o.slice(1), l = false;
                        for (let c of a)if (c === "s") n.breakAtSpaces = true;
                        else if (c === "b") n.countBytes = true;
                        else {
                            l = true;
                            break;
                        }
                        if (l) return G("fold", o);
                        s++;
                    } else r.push(o), s++;
                }
                let i = "";
                if (r.length === 0) {
                    let o = t.stdin ?? "";
                    i = Df(o, n);
                } else for (let o of r){
                    let a = t.fs.resolvePath(t.cwd, o), l = await t.fs.readFile(a);
                    if (l === null) return {
                        exitCode: 1,
                        stdout: i,
                        stderr: `fold: ${o}: No such file or directory
`
                    };
                    i += Df(l, n);
                }
                return {
                    exitCode: 0,
                    stdout: i,
                    stderr: ""
                };
            }
        };
    });
    var Mf = {};
    V(Mf, {
        expand: ()=>_1
    });
    function Es(e) {
        let t = e.split(",").map((r)=>r.trim()), n = [];
        for (let r of t){
            let s = parseInt(r, 10);
            if (Number.isNaN(s) || s < 1) return null;
            n.push(s);
        }
        for(let r = 1; r < n.length; r++)if (n[r] <= n[r - 1]) return null;
        return n;
    }
    function D1(e, t) {
        if (t.length === 1) {
            let n = t[0];
            return n - e % n;
        }
        for (let n of t)if (n > e) return n - e;
        if (t.length >= 2) {
            let n = t[t.length - 1] - t[t.length - 2], r = t[t.length - 1], s = Math.floor((e - r) / n) + 1;
            return r + s * n - e;
        }
        return 1;
    }
    function F1(e, t) {
        let { tabStops: n, leadingOnly: r } = t, s = "", i = 0, o = true;
        for (let a of e)if (a === "	") if (r && !o) s += a, i++;
        else {
            let l = D1(i, n);
            s += " ".repeat(l), i += l;
        }
        else a !== " " && a !== "	" && (o = false), s += a, i++;
        return s;
    }
    function Lf(e, t) {
        if (e === "") return "";
        let n = e.split(`
`), r = e.endsWith(`
`) && n[n.length - 1] === "";
        return r && n.pop(), n.map((i)=>F1(i, t)).join(`
`) + (r ? `
` : "");
    }
    var O1, _1, Wf = v(()=>{
        X();
        O1 = {
            name: "expand",
            summary: "convert tabs to spaces",
            usage: "expand [OPTION]... [FILE]...",
            description: "Convert TABs in each FILE to spaces, writing to standard output. If no FILE is specified, standard input is read.",
            options: [
                "-t N        Use N spaces per tab (default: 8)",
                "-t LIST     Use comma-separated list of tab stops",
                "-i          Only convert leading tabs on each line"
            ],
            examples: [
                "expand file.txt             # Convert all tabs to 8 spaces",
                "expand -t 4 file.txt        # Use 4-space tabs",
                "expand -t 4,8,12 file.txt   # Custom tab stops"
            ]
        };
        _1 = {
            name: "expand",
            execute: async (e, t)=>{
                if (_(e)) return F(O1);
                let n = {
                    tabStops: [
                        8
                    ],
                    leadingOnly: false
                }, r = [], s = 0;
                for(; s < e.length;){
                    let o = e[s];
                    if (o === "-t" && s + 1 < e.length) {
                        let a = Es(e[s + 1]);
                        if (!a) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `expand: invalid tab size: '${e[s + 1]}'
`
                        };
                        n.tabStops = a, s += 2;
                    } else if (o.startsWith("-t") && o.length > 2) {
                        let a = Es(o.slice(2));
                        if (!a) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `expand: invalid tab size: '${o.slice(2)}'
`
                        };
                        n.tabStops = a, s++;
                    } else if (o === "--tabs" && s + 1 < e.length) {
                        let a = Es(e[s + 1]);
                        if (!a) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `expand: invalid tab size: '${e[s + 1]}'
`
                        };
                        n.tabStops = a, s += 2;
                    } else if (o.startsWith("--tabs=")) {
                        let a = Es(o.slice(7));
                        if (!a) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `expand: invalid tab size: '${o.slice(7)}'
`
                        };
                        n.tabStops = a, s++;
                    } else if (o === "-i" || o === "--initial") n.leadingOnly = true, s++;
                    else if (o === "--") {
                        r.push(...e.slice(s + 1));
                        break;
                    } else {
                        if (o.startsWith("-") && o !== "-") return G("expand", o);
                        r.push(o), s++;
                    }
                }
                let i = "";
                if (r.length === 0) {
                    let o = t.stdin ?? "";
                    i = Lf(o, n);
                } else for (let o of r){
                    let a = t.fs.resolvePath(t.cwd, o), l = await t.fs.readFile(a);
                    if (l === null) return {
                        exitCode: 1,
                        stdout: i,
                        stderr: `expand: ${o}: No such file or directory
`
                    };
                    i += Lf(l, n);
                }
                return {
                    exitCode: 0,
                    stdout: i,
                    stderr: ""
                };
            }
        };
    });
    var zf = {};
    V(zf, {
        unexpand: ()=>W1
    });
    function Ss(e) {
        let t = e.split(",").map((r)=>r.trim()), n = [];
        for (let r of t){
            let s = parseInt(r, 10);
            if (Number.isNaN(s) || s < 1) return null;
            n.push(s);
        }
        for(let r = 1; r < n.length; r++)if (n[r] <= n[r - 1]) return null;
        return n;
    }
    function Bf(e, t) {
        if (t.length === 1) {
            let n = t[0];
            return e + (n - e % n);
        }
        for (let n of t)if (n > e) return n;
        if (t.length >= 2) {
            let n = t[t.length - 1] - t[t.length - 2], r = t[t.length - 1], s = Math.floor((e - r) / n) + 1;
            return r + s * n;
        }
        return -1;
    }
    function M1(e, t) {
        let { tabStops: n, allBlanks: r } = t, s = "", i = 0, o = "", a = 0, l = true, c = ()=>{
            if (o.length === 0) return;
            let u = a + o.length;
            if (!r && !l) {
                s += o, o = "";
                return;
            }
            let f = a, p = "";
            for(; f < u;){
                let m = Bf(f, n);
                if (m <= u && m > f) p += "	", f = m;
                else break;
            }
            let d = u - f;
            d > 0 && (p += " ".repeat(d)), s += p, o = "";
        };
        for (let u of e)u === " " ? (o.length === 0 && (a = i), o += u, i++) : u === "	" ? (c(), s += u, i = Bf(i, n)) : (c(), s += u, i++, l = false);
        return c(), s;
    }
    function Uf(e, t) {
        if (e === "") return "";
        let n = e.split(`
`), r = e.endsWith(`
`) && n[n.length - 1] === "";
        return r && n.pop(), n.map((i)=>M1(i, t)).join(`
`) + (r ? `
` : "");
    }
    var L1, W1, jf = v(()=>{
        X();
        L1 = {
            name: "unexpand",
            summary: "convert spaces to tabs",
            usage: "unexpand [OPTION]... [FILE]...",
            description: "Convert blanks in each FILE to TABs, writing to standard output. If no FILE is specified, standard input is read.",
            options: [
                "-t N        Use N spaces per tab (default: 8)",
                "-t LIST     Use comma-separated list of tab stops",
                "-a          Convert all sequences of blanks (not just leading)"
            ],
            examples: [
                "unexpand file.txt           # Convert leading spaces to tabs",
                "unexpand -a file.txt        # Convert all space sequences",
                "unexpand -t 4 file.txt      # Use 4-space tabs"
            ]
        };
        W1 = {
            name: "unexpand",
            execute: async (e, t)=>{
                if (_(e)) return F(L1);
                let n = {
                    tabStops: [
                        8
                    ],
                    allBlanks: false
                }, r = [], s = 0;
                for(; s < e.length;){
                    let o = e[s];
                    if (o === "-t" && s + 1 < e.length) {
                        let a = Ss(e[s + 1]);
                        if (!a) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `unexpand: invalid tab size: '${e[s + 1]}'
`
                        };
                        n.tabStops = a, s += 2;
                    } else if (o.startsWith("-t") && o.length > 2) {
                        let a = Ss(o.slice(2));
                        if (!a) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `unexpand: invalid tab size: '${o.slice(2)}'
`
                        };
                        n.tabStops = a, s++;
                    } else if (o === "--tabs" && s + 1 < e.length) {
                        let a = Ss(e[s + 1]);
                        if (!a) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `unexpand: invalid tab size: '${e[s + 1]}'
`
                        };
                        n.tabStops = a, s += 2;
                    } else if (o.startsWith("--tabs=")) {
                        let a = Ss(o.slice(7));
                        if (!a) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `unexpand: invalid tab size: '${o.slice(7)}'
`
                        };
                        n.tabStops = a, s++;
                    } else if (o === "-a" || o === "--all") n.allBlanks = true, s++;
                    else if (o === "--") {
                        r.push(...e.slice(s + 1));
                        break;
                    } else {
                        if (o.startsWith("-") && o !== "-") return G("unexpand", o);
                        r.push(o), s++;
                    }
                }
                let i = "";
                if (r.length === 0) {
                    let o = t.stdin ?? "";
                    i = Uf(o, n);
                } else for (let o of r){
                    let a = t.fs.resolvePath(t.cwd, o), l = await t.fs.readFile(a);
                    if (l === null) return {
                        exitCode: 1,
                        stdout: i,
                        stderr: `unexpand: ${o}: No such file or directory
`
                    };
                    i += Uf(l, n);
                }
                return {
                    exitCode: 0,
                    stdout: i,
                    stderr: ""
                };
            }
        };
    });
    var qf = {};
    V(qf, {
        strings: ()=>z1
    });
    function U1(e) {
        return e >= 32 && e <= 126 || e === 9;
    }
    function Hf(e, t) {
        if (t === null) return "";
        switch(t){
            case "o":
                return `${e.toString(8).padStart(7, " ")} `;
            case "x":
                return `${e.toString(16).padStart(7, " ")} `;
            case "d":
                return `${e.toString(10).padStart(7, " ")} `;
            default:
                return t;
        }
    }
    function Vf(e, t) {
        let n = [], r = "", s = 0, i = typeof e == "string" ? new TextEncoder().encode(e) : e;
        for(let o = 0; o < i.length; o++){
            let a = i[o];
            if (U1(a)) r.length === 0 && (s = o), r += String.fromCharCode(a);
            else {
                if (r.length >= t.minLength) {
                    let l = Hf(s, t.offsetFormat);
                    n.push(`${l}${r}`);
                }
                r = "";
            }
        }
        if (r.length >= t.minLength) {
            let o = Hf(s, t.offsetFormat);
            n.push(`${o}${r}`);
        }
        return n;
    }
    var B1, z1, Gf = v(()=>{
        X();
        B1 = {
            name: "strings",
            summary: "print the sequences of printable characters in files",
            usage: "strings [OPTION]... [FILE]...",
            description: "For each FILE, print the printable character sequences that are at least MIN characters long. If no FILE is specified, standard input is read.",
            options: [
                "-n MIN       Print sequences of at least MIN characters (default: 4)",
                "-t FORMAT    Print offset before each string (o=octal, x=hex, d=decimal)",
                "-a           Scan the entire file (default behavior)",
                "-e ENCODING  Select character encoding (s=7-bit, S=8-bit)"
            ],
            examples: [
                "strings file.bin          # Extract strings (min 4 chars)",
                "strings -n 8 file.bin     # Extract strings (min 8 chars)",
                "strings -t x file.bin     # Show hex offset",
                "echo 'hello' | strings    # Read from stdin"
            ]
        };
        z1 = {
            name: "strings",
            execute: async (e, t)=>{
                if (_(e)) return F(B1);
                let n = {
                    minLength: 4,
                    offsetFormat: null
                }, r = [], s = 0;
                for(; s < e.length;){
                    let o = e[s];
                    if (o === "-n" && s + 1 < e.length) {
                        let a = Number.parseInt(e[s + 1], 10);
                        if (Number.isNaN(a) || a < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `strings: invalid minimum string length: '${e[s + 1]}'
`
                        };
                        n.minLength = a, s += 2;
                    } else if (o.match(/^-n\d+$/)) {
                        let a = Number.parseInt(o.slice(2), 10);
                        if (Number.isNaN(a) || a < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `strings: invalid minimum string length: '${o.slice(2)}'
`
                        };
                        n.minLength = a, s++;
                    } else if (o.match(/^-\d+$/)) {
                        let a = Number.parseInt(o.slice(1), 10);
                        if (Number.isNaN(a) || a < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `strings: invalid minimum string length: '${o.slice(1)}'
`
                        };
                        n.minLength = a, s++;
                    } else if (o === "-t" && s + 1 < e.length) {
                        let a = e[s + 1];
                        if (a !== "o" && a !== "x" && a !== "d") return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `strings: invalid radix: '${a}'
`
                        };
                        n.offsetFormat = a, s += 2;
                    } else if (o.startsWith("-t") && o.length === 3) {
                        let a = o[2];
                        if (a !== "o" && a !== "x" && a !== "d") return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `strings: invalid radix: '${a}'
`
                        };
                        n.offsetFormat = a, s++;
                    } else if (o === "-a" || o === "--all" || o === "-") o === "-" && r.push(o), s++;
                    else if (o === "-e" && s + 1 < e.length) {
                        let a = e[s + 1];
                        if (a !== "s" && a !== "S") return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `strings: invalid encoding: '${a}'
`
                        };
                        s += 2;
                    } else if (o.startsWith("-e") && o.length === 3) {
                        let a = o[2];
                        if (a !== "s" && a !== "S") return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `strings: invalid encoding: '${a}'
`
                        };
                        s++;
                    } else if (o === "--") {
                        r.push(...e.slice(s + 1));
                        break;
                    } else {
                        if (o.startsWith("-") && o !== "-") return G("strings", o);
                        r.push(o), s++;
                    }
                }
                let i = "";
                if (r.length === 0) {
                    let o = t.stdin ?? "", a = Vf(o, n);
                    i = a.length > 0 ? `${a.join(`
`)}
` : "";
                } else for (let o of r){
                    let a;
                    if (o === "-") a = t.stdin ?? "";
                    else {
                        let c = t.fs.resolvePath(t.cwd, o);
                        if (a = await t.fs.readFile(c), a === null) return {
                            exitCode: 1,
                            stdout: i,
                            stderr: `strings: ${o}: No such file or directory
`
                        };
                    }
                    let l = Vf(a, n);
                    l.length > 0 && (i += `${l.join(`
`)}
`);
                }
                return {
                    exitCode: 0,
                    stdout: i,
                    stderr: ""
                };
            }
        };
    });
    var Qf = {};
    V(Qf, {
        split: ()=>Z1
    });
    function Zf(e) {
        let t = e.match(/^(\d+)([KMGTPEZY]?)([B]?)$/i);
        if (!t) return null;
        let n = Number.parseInt(t[1], 10);
        if (Number.isNaN(n) || n < 1) return null;
        let r = (t[2] || "").toUpperCase(), i = {
            "": 1,
            K: 1024,
            M: 1024 * 1024,
            G: 1024 * 1024 * 1024,
            T: 1024 * 1024 * 1024 * 1024,
            P: 1024 * 1024 * 1024 * 1024 * 1024
        }[r];
        return i === void 0 ? null : n * i;
    }
    function H1(e, t, n) {
        if (t) return e.toString().padStart(n, "0");
        let r = "abcdefghijklmnopqrstuvwxyz", s = "", i = e;
        for(let o = 0; o < n; o++)s = r[i % 26] + s, i = Math.floor(i / 26);
        return s;
    }
    function V1(e, t) {
        let n = e.split(`
`), r = e.endsWith(`
`) && n[n.length - 1] === "";
        r && n.pop();
        let s = [];
        for(let i = 0; i < n.length; i += t){
            let o = n.slice(i, i + t), l = i + t >= n.length && !r ? o.join(`
`) : `${o.join(`
`)}
`;
            s.push({
                content: l,
                hasContent: true
            });
        }
        return s;
    }
    function q1(e, t) {
        let r = new TextEncoder().encode(e), s = new TextDecoder(), i = [];
        for(let o = 0; o < r.length; o += t){
            let a = r.slice(o, o + t);
            i.push({
                content: s.decode(a),
                hasContent: a.length > 0
            });
        }
        return i;
    }
    function G1(e, t) {
        let r = new TextEncoder().encode(e), s = new TextDecoder(), i = [], o = Math.ceil(r.length / t);
        for(let a = 0; a < t; a++){
            let l = a * o, c = Math.min(l + o, r.length), u = r.slice(l, c);
            i.push({
                content: s.decode(u),
                hasContent: u.length > 0
            });
        }
        return i;
    }
    var j1, Z1, Kf = v(()=>{
        X();
        j1 = {
            name: "split",
            summary: "split a file into pieces",
            usage: "split [OPTION]... [FILE [PREFIX]]",
            description: "Output pieces of FILE to PREFIXaa, PREFIXab, ...; default size is 1000 lines, and default PREFIX is 'x'.",
            options: [
                "-l N         Put N lines per output file",
                "-b SIZE      Put SIZE bytes per output file (K, M, G suffixes)",
                "-n CHUNKS    Split into CHUNKS equal-sized files",
                "-d           Use numeric suffixes (00, 01, ...) instead of alphabetic",
                "-a LENGTH    Use suffixes of length LENGTH (default: 2)",
                "--additional-suffix=SUFFIX  Append SUFFIX to file names"
            ],
            examples: [
                "split -l 100 file.txt        # Split into 100-line chunks",
                "split -b 1M file.bin         # Split into 1MB chunks",
                "split -n 5 file.txt          # Split into 5 equal parts",
                "split -d file.txt part_      # part_00, part_01, ...",
                "split -a 3 -d file.txt x     # x000, x001, ..."
            ]
        };
        Z1 = {
            name: "split",
            execute: async (e, t)=>{
                if (_(e)) return F(j1);
                let n = {
                    mode: "lines",
                    lines: 1e3,
                    bytes: 0,
                    chunks: 0,
                    useNumericSuffix: false,
                    suffixLength: 2,
                    additionalSuffix: ""
                }, r = [], s = 0;
                for(; s < e.length;){
                    let c = e[s];
                    if (c === "-l" && s + 1 < e.length) {
                        let u = Number.parseInt(e[s + 1], 10);
                        if (Number.isNaN(u) || u < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `split: invalid number of lines: '${e[s + 1]}'
`
                        };
                        n.mode = "lines", n.lines = u, s += 2;
                    } else if (c.match(/^-l\d+$/)) {
                        let u = Number.parseInt(c.slice(2), 10);
                        if (Number.isNaN(u) || u < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `split: invalid number of lines: '${c.slice(2)}'
`
                        };
                        n.mode = "lines", n.lines = u, s++;
                    } else if (c === "-b" && s + 1 < e.length) {
                        let u = Zf(e[s + 1]);
                        if (u === null) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `split: invalid number of bytes: '${e[s + 1]}'
`
                        };
                        n.mode = "bytes", n.bytes = u, s += 2;
                    } else if (c.match(/^-b.+$/)) {
                        let u = Zf(c.slice(2));
                        if (u === null) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `split: invalid number of bytes: '${c.slice(2)}'
`
                        };
                        n.mode = "bytes", n.bytes = u, s++;
                    } else if (c === "-n" && s + 1 < e.length) {
                        let u = Number.parseInt(e[s + 1], 10);
                        if (Number.isNaN(u) || u < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `split: invalid number of chunks: '${e[s + 1]}'
`
                        };
                        n.mode = "chunks", n.chunks = u, s += 2;
                    } else if (c.match(/^-n\d+$/)) {
                        let u = Number.parseInt(c.slice(2), 10);
                        if (Number.isNaN(u) || u < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `split: invalid number of chunks: '${c.slice(2)}'
`
                        };
                        n.mode = "chunks", n.chunks = u, s++;
                    } else if (c === "-a" && s + 1 < e.length) {
                        let u = Number.parseInt(e[s + 1], 10);
                        if (Number.isNaN(u) || u < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `split: invalid suffix length: '${e[s + 1]}'
`
                        };
                        n.suffixLength = u, s += 2;
                    } else if (c.match(/^-a\d+$/)) {
                        let u = Number.parseInt(c.slice(2), 10);
                        if (Number.isNaN(u) || u < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `split: invalid suffix length: '${c.slice(2)}'
`
                        };
                        n.suffixLength = u, s++;
                    } else if (c === "-d" || c === "--numeric-suffixes") n.useNumericSuffix = true, s++;
                    else if (c.startsWith("--additional-suffix=")) n.additionalSuffix = c.slice(20), s++;
                    else if (c === "--additional-suffix" && s + 1 < e.length) n.additionalSuffix = e[s + 1], s += 2;
                    else if (c === "--") {
                        r.push(...e.slice(s + 1));
                        break;
                    } else {
                        if (c.startsWith("-") && c !== "-") return G("split", c);
                        r.push(c), s++;
                    }
                }
                let i = "-", o = "x";
                r.length >= 1 && (i = r[0]), r.length >= 2 && (o = r[1]);
                let a;
                if (i === "-") a = t.stdin ?? "";
                else {
                    let c = t.fs.resolvePath(t.cwd, i), u = await t.fs.readFile(c);
                    if (u === null) return {
                        exitCode: 1,
                        stdout: "",
                        stderr: `split: ${i}: No such file or directory
`
                    };
                    a = u;
                }
                if (a === "") return {
                    exitCode: 0,
                    stdout: "",
                    stderr: ""
                };
                let l;
                switch(n.mode){
                    case "lines":
                        l = V1(a, n.lines);
                        break;
                    case "bytes":
                        l = q1(a, n.bytes);
                        break;
                    case "chunks":
                        l = G1(a, n.chunks);
                        break;
                    default:
                        return n.mode;
                }
                for(let c = 0; c < l.length; c++){
                    let u = l[c];
                    if (!u.hasContent) continue;
                    let f = H1(c, n.useNumericSuffix, n.suffixLength), p = `${o}${f}${n.additionalSuffix}`, d = t.fs.resolvePath(t.cwd, p);
                    await t.fs.writeFile(d, u.content);
                }
                return {
                    exitCode: 0,
                    stdout: "",
                    stderr: ""
                };
            }
        };
    });
    var Jf = {};
    V(Jf, {
        column: ()=>eE
    });
    function Xf(e, t, n) {
        return t ? n ? e.split(t) : e.split(t).filter((r)=>r.length > 0) : n ? e.split(/[ \t]/) : e.split(/[ \t]+/).filter((r)=>r.length > 0);
    }
    function X1(e) {
        let t = [];
        for (let n of e)for(let r = 0; r < n.length; r++){
            let s = n[r].length;
            (t[r] === void 0 || s > t[r]) && (t[r] = s);
        }
        return t;
    }
    function J1(e, t) {
        if (e.length === 0) return "";
        let n = X1(e), r = [];
        for (let s of e){
            let i = [];
            for(let o = 0; o < s.length; o++)o === s.length - 1 ? i.push(s[o]) : i.push(s[o].padEnd(n[o]));
            r.push(i.join(t));
        }
        return r.join(`
`);
    }
    function Y1(e, t, n) {
        if (e.length === 0) return "";
        let r = Math.max(...e.map((c)=>c.length)), s = n.length, i = r + s, o = Math.max(1, Math.floor((t + s) / i)), a = Math.ceil(e.length / o), l = [];
        for(let c = 0; c < a; c++){
            let u = [];
            for(let f = 0; f < o; f++){
                let p = f * a + c;
                p < e.length && (f === o - 1 || (f + 1) * a + c >= e.length ? u.push(e[p]) : u.push(e[p].padEnd(r)));
            }
            l.push(u.join(n));
        }
        return l.join(`
`);
    }
    var Q1, K1, eE, Yf = v(()=>{
        Oe();
        X();
        Q1 = {
            name: "column",
            summary: "columnate lists",
            usage: "column [OPTION]... [FILE]...",
            description: "Format input into multiple columns. By default, fills rows first. Use -t to create a table based on whitespace-delimited input.",
            options: [
                "-t           Create a table (determine columns from input)",
                "-s SEP       Input field delimiter (default: whitespace)",
                "-o SEP       Output field delimiter (default: two spaces)",
                "-c WIDTH     Output width for fill mode (default: 80)",
                "-n           Don't merge multiple adjacent delimiters"
            ],
            examples: [
                "ls | column              # Fill columns with ls output",
                "cat data | column -t     # Format as table",
                "column -t -s ',' file    # Format CSV as table",
                "column -c 40 file        # Fill 40-char wide columns"
            ]
        }, K1 = {
            table: {
                short: "t",
                long: "table",
                type: "boolean"
            },
            separator: {
                short: "s",
                type: "string"
            },
            outputSep: {
                short: "o",
                type: "string"
            },
            width: {
                short: "c",
                type: "number",
                default: 80
            },
            noMerge: {
                short: "n",
                type: "boolean"
            }
        };
        eE = {
            name: "column",
            execute: async (e, t)=>{
                if (_(e)) return F(Q1);
                let n = fe("column", e, K1);
                if (!n.ok) return n.error;
                let { table: r, separator: s, outputSep: i, width: o, noMerge: a } = n.result.flags, l = n.result.positional, c = i ?? "  ", u;
                if (l.length === 0) u = t.stdin ?? "";
                else {
                    let h = [];
                    for (let g of l)if (g === "-") h.push(t.stdin ?? "");
                    else {
                        let b = t.fs.resolvePath(t.cwd, g), y = await t.fs.readFile(b);
                        if (y === null) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `column: ${g}: No such file or directory
`
                        };
                        h.push(y);
                    }
                    u = h.join("");
                }
                if (u === "" || u.trim() === "") return {
                    exitCode: 0,
                    stdout: "",
                    stderr: ""
                };
                let f = u.split(`
`);
                u.endsWith(`
`) && f[f.length - 1] === "" && f.pop();
                let d = f.filter((h)=>h.trim().length > 0), m;
                if (r) {
                    let h = d.map((g)=>Xf(g, s, a));
                    m = J1(h, c);
                } else {
                    let h = [];
                    for (let g of d){
                        let b = Xf(g, s, a);
                        h.push(...b);
                    }
                    m = Y1(h, o, c);
                }
                return m.length > 0 && (m += `
`), {
                    exitCode: 0,
                    stdout: m,
                    stderr: ""
                };
            }
        };
    });
    var ep = {};
    V(ep, {
        join: ()=>iE
    });
    function nE(e, t) {
        return t ? e.split(t) : e.split(/[ \t]+/).filter((n)=>n.length > 0);
    }
    function rE(e, t, n, r) {
        let s = nE(e, t), i = s[n - 1] ?? "";
        return r && (i = i.toLowerCase()), {
            fields: s,
            joinKey: i,
            original: e
        };
    }
    function yo(e, t, n) {
        let r = n.separator ?? " ";
        if (n.outputFormat) {
            let o = [];
            for (let { file: a, field: l } of n.outputFormat){
                let c = a === 1 ? e : t;
                c && l === 0 ? o.push(c.joinKey) : c && c.fields[l - 1] !== void 0 ? o.push(c.fields[l - 1]) : o.push(n.emptyString);
            }
            return o.join(r);
        }
        let s = [], i = e?.joinKey ?? t?.joinKey ?? "";
        if (s.push(i), e) for(let o = 0; o < e.fields.length; o++)o !== n.field1 - 1 && s.push(e.fields[o]);
        if (t) for(let o = 0; o < t.fields.length; o++)o !== n.field2 - 1 && s.push(t.fields[o]);
        return s.join(r);
    }
    function sE(e) {
        let t = e.split(","), n = [];
        for (let r of t){
            let s = r.trim().match(/^(\d+)\.(\d+)$/);
            if (!s) return null;
            let i = Number.parseInt(s[1], 10), o = Number.parseInt(s[2], 10);
            if (i !== 1 && i !== 2) return null;
            n.push({
                file: i,
                field: o
            });
        }
        return n;
    }
    var tE, iE, tp = v(()=>{
        X();
        tE = {
            name: "join",
            summary: "join lines of two files on a common field",
            usage: "join [OPTION]... FILE1 FILE2",
            description: "For each pair of input lines with identical join fields, write a line to standard output. The default join field is the first, delimited by blanks.",
            options: [
                "-1 FIELD     Join on this FIELD of file 1 (default: 1)",
                "-2 FIELD     Join on this FIELD of file 2 (default: 1)",
                "-t CHAR      Use CHAR as input and output field separator",
                "-a FILENUM   Also print unpairable lines from file FILENUM (1 or 2)",
                "-v FILENUM   Like -a but only output unpairable lines",
                "-e STRING    Replace missing fields with STRING",
                "-o FORMAT    Output format (comma-separated list of FILENUM.FIELD)",
                "-i           Ignore case when comparing fields"
            ],
            examples: [
                "join file1 file2               # Join on first field",
                "join -1 2 -2 1 file1 file2     # Join file1 col 2 with file2 col 1",
                "join -t ',' file1.csv file2.csv  # Join CSV files",
                "join -a 1 file1 file2          # Left outer join"
            ]
        };
        iE = {
            name: "join",
            execute: async (e, t)=>{
                if (_(e)) return F(tE);
                let n = {
                    field1: 1,
                    field2: 1,
                    separator: null,
                    printUnpairable: new Set(),
                    onlyUnpairable: new Set(),
                    emptyString: "",
                    outputFormat: null,
                    ignoreCase: false
                }, r = [], s = 0;
                for(; s < e.length;){
                    let p = e[s];
                    if (p === "-1" && s + 1 < e.length) {
                        let d = Number.parseInt(e[s + 1], 10);
                        if (Number.isNaN(d) || d < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `join: invalid field number: '${e[s + 1]}'
`
                        };
                        n.field1 = d, s += 2;
                    } else if (p === "-2" && s + 1 < e.length) {
                        let d = Number.parseInt(e[s + 1], 10);
                        if (Number.isNaN(d) || d < 1) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `join: invalid field number: '${e[s + 1]}'
`
                        };
                        n.field2 = d, s += 2;
                    } else if ((p === "-t" || p === "--field-separator") && s + 1 < e.length) n.separator = e[s + 1], s += 2;
                    else if (p.startsWith("-t") && p.length > 2) n.separator = p.slice(2), s++;
                    else if (p === "-a" && s + 1 < e.length) {
                        let d = Number.parseInt(e[s + 1], 10);
                        if (d !== 1 && d !== 2) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `join: invalid file number: '${e[s + 1]}'
`
                        };
                        n.printUnpairable.add(d), s += 2;
                    } else if (p.match(/^-a[12]$/)) n.printUnpairable.add(Number.parseInt(p[2], 10)), s++;
                    else if (p === "-v" && s + 1 < e.length) {
                        let d = Number.parseInt(e[s + 1], 10);
                        if (d !== 1 && d !== 2) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `join: invalid file number: '${e[s + 1]}'
`
                        };
                        n.onlyUnpairable.add(d), s += 2;
                    } else if (p.match(/^-v[12]$/)) n.onlyUnpairable.add(Number.parseInt(p[2], 10)), s++;
                    else if (p === "-e" && s + 1 < e.length) n.emptyString = e[s + 1], s += 2;
                    else if (p === "-o" && s + 1 < e.length) {
                        let d = sE(e[s + 1]);
                        if (!d) return {
                            exitCode: 1,
                            stdout: "",
                            stderr: `join: invalid field spec: '${e[s + 1]}'
`
                        };
                        n.outputFormat = d, s += 2;
                    } else if (p === "-i" || p === "--ignore-case") n.ignoreCase = true, s++;
                    else if (p === "--") {
                        r.push(...e.slice(s + 1));
                        break;
                    } else {
                        if (p.startsWith("-") && p !== "-") return G("join", p);
                        r.push(p), s++;
                    }
                }
                if (r.length !== 2) return {
                    exitCode: 1,
                    stdout: "",
                    stderr: r.length < 2 ? `join: missing file operand
` : `join: extra operand
`
                };
                let i = [];
                for (let p of r)if (p === "-") i.push(t.stdin ?? "");
                else {
                    let d = t.fs.resolvePath(t.cwd, p), m = await t.fs.readFile(d);
                    if (m === null) return {
                        exitCode: 1,
                        stdout: "",
                        stderr: `join: ${p}: No such file or directory
`
                    };
                    i.push(m);
                }
                let o = (p, d)=>{
                    let m = p.split(`
`);
                    return p.endsWith(`
`) && m[m.length - 1] === "" && m.pop(), m.filter((h)=>h.length > 0).map((h)=>rE(h, n.separator, d, n.ignoreCase));
                }, a = o(i[0], n.field1), l = o(i[1], n.field2), c = new Map();
                for (let p of l){
                    let d = c.get(p.joinKey);
                    d ? d.push(p) : c.set(p.joinKey, [
                        p
                    ]);
                }
                let u = [], f = new Set();
                for (let p of a){
                    let d = c.get(p.joinKey);
                    if (d && d.length > 0) {
                        if (f.add(p.joinKey), n.onlyUnpairable.size === 0) for (let m of d)u.push(yo(p, m, n));
                    } else (n.printUnpairable.has(1) || n.onlyUnpairable.has(1)) && u.push(yo(p, null, n));
                }
                if (n.printUnpairable.has(2) || n.onlyUnpairable.has(2)) for (let p of l)f.has(p.joinKey) || u.push(yo(null, p, n));
                return {
                    exitCode: 0,
                    stdout: u.length > 0 ? `${u.join(`
`)}
` : "",
                    stderr: ""
                };
            }
        };
    });
    var np = {};
    V(np, {
        teeCommand: ()=>lE
    });
    var oE, aE, lE, rp = v(()=>{
        Oe();
        X();
        oE = {
            name: "tee",
            summary: "read from stdin and write to stdout and files",
            usage: "tee [OPTION]... [FILE]...",
            options: [
                "-a, --append     append to the given FILEs, do not overwrite",
                "    --help       display this help and exit"
            ]
        }, aE = {
            append: {
                short: "a",
                long: "append",
                type: "boolean"
            }
        }, lE = {
            name: "tee",
            async execute (e, t) {
                if (_(e)) return F(oE);
                let n = fe("tee", e, aE);
                if (!n.ok) return n.error;
                let { append: r } = n.result.flags, s = n.result.positional, i = t.stdin, o = "", a = 0;
                for (let l of s)try {
                    let c = t.fs.resolvePath(t.cwd, l);
                    r ? await t.fs.appendFile(c, i) : await t.fs.writeFile(c, i);
                } catch  {
                    o += `tee: ${l}: No such file or directory
`, a = 1;
                }
                return {
                    stdout: i,
                    stderr: o,
                    exitCode: a
                };
            }
        };
    });
    function kt(e, t) {
        switch(e.type){
            case "name":
                {
                    let n = e.pattern, r = n.match(/^\*(\.[a-zA-Z0-9]+)$/);
                    if (r) {
                        let s = r[1], i = t.name;
                        if (e.ignoreCase) {
                            if (!i.toLowerCase().endsWith(s.toLowerCase())) return {
                                matches: false,
                                pruned: false,
                                printed: false
                            };
                        } else if (!i.endsWith(s)) return {
                            matches: false,
                            pruned: false,
                            printed: false
                        };
                        return {
                            matches: true,
                            pruned: false,
                            printed: false
                        };
                    }
                    return {
                        matches: Ye(t.name, n, e.ignoreCase),
                        pruned: false,
                        printed: false
                    };
                }
            case "path":
                {
                    let n = e.pattern, r = t.relativePath, s = n.split("/");
                    for(let o = 0; o < s.length - 1; o++){
                        let a = s[o];
                        if (a && a !== "." && a !== ".." && !a.includes("*") && !a.includes("?") && !a.includes("[")) {
                            let l = `/${a}/`;
                            if (e.ignoreCase) {
                                if (!r.toLowerCase().includes(l.toLowerCase())) return {
                                    matches: false,
                                    pruned: false,
                                    printed: false
                                };
                            } else if (!r.includes(l)) return {
                                matches: false,
                                pruned: false,
                                printed: false
                            };
                        }
                    }
                    let i = n.match(/\*(\.[a-zA-Z0-9]+)$/);
                    if (i) {
                        let o = i[1];
                        if (e.ignoreCase) {
                            if (!r.toLowerCase().endsWith(o.toLowerCase())) return {
                                matches: false,
                                pruned: false,
                                printed: false
                            };
                        } else if (!r.endsWith(o)) return {
                            matches: false,
                            pruned: false,
                            printed: false
                        };
                    }
                    return {
                        matches: Ye(r, n, e.ignoreCase),
                        pruned: false,
                        printed: false
                    };
                }
            case "regex":
                try {
                    let n = e.ignoreCase ? "i" : "";
                    return {
                        matches: new RegExp(e.pattern, n).test(t.relativePath),
                        pruned: false,
                        printed: false
                    };
                } catch  {
                    return {
                        matches: false,
                        pruned: false,
                        printed: false
                    };
                }
            case "type":
                return e.fileType === "f" ? {
                    matches: t.isFile,
                    pruned: false,
                    printed: false
                } : e.fileType === "d" ? {
                    matches: t.isDirectory,
                    pruned: false,
                    printed: false
                } : {
                    matches: false,
                    pruned: false,
                    printed: false
                };
            case "empty":
                return {
                    matches: t.isEmpty,
                    pruned: false,
                    printed: false
                };
            case "mtime":
                {
                    let r = (Date.now() - t.mtime) / (1e3 * 60 * 60 * 24), s;
                    return e.comparison === "more" ? s = r > e.days : e.comparison === "less" ? s = r < e.days : s = Math.floor(r) === e.days, {
                        matches: s,
                        pruned: false,
                        printed: false
                    };
                }
            case "newer":
                {
                    let n = t.newerRefTimes.get(e.refPath);
                    return n === void 0 ? {
                        matches: false,
                        pruned: false,
                        printed: false
                    } : {
                        matches: t.mtime > n,
                        pruned: false,
                        printed: false
                    };
                }
            case "size":
                {
                    let n = e.value;
                    switch(e.unit){
                        case "c":
                            n = e.value;
                            break;
                        case "k":
                            n = e.value * 1024;
                            break;
                        case "M":
                            n = e.value * 1024 * 1024;
                            break;
                        case "G":
                            n = e.value * 1024 * 1024 * 1024;
                            break;
                        case "b":
                            n = e.value * 512;
                            break;
                    }
                    let r;
                    return e.comparison === "more" ? r = t.size > n : e.comparison === "less" ? r = t.size < n : e.unit === "b" ? r = Math.ceil(t.size / 512) === e.value : r = t.size === n, {
                        matches: r,
                        pruned: false,
                        printed: false
                    };
                }
            case "perm":
                {
                    let n = t.mode & 511, r = e.mode & 511, s;
                    return e.matchType === "exact" ? s = n === r : e.matchType === "all" ? s = (n & r) === r : s = (n & r) !== 0, {
                        matches: s,
                        pruned: false,
                        printed: false
                    };
                }
            case "prune":
                return {
                    matches: true,
                    pruned: true,
                    printed: false
                };
            case "print":
                return {
                    matches: true,
                    pruned: false,
                    printed: true
                };
            case "not":
                {
                    let n = kt(e.expr, t);
                    return {
                        matches: !n.matches,
                        pruned: n.pruned,
                        printed: false
                    };
                }
            case "and":
                {
                    let n = kt(e.left, t);
                    if (!n.matches) return {
                        matches: false,
                        pruned: n.pruned,
                        printed: false
                    };
                    let r = kt(e.right, t);
                    return {
                        matches: r.matches,
                        pruned: n.pruned || r.pruned,
                        printed: n.printed || r.printed
                    };
                }
            case "or":
                {
                    let n = kt(e.left, t);
                    if (n.matches) return n;
                    let r = kt(e.right, t);
                    return {
                        matches: r.matches,
                        pruned: n.pruned || r.pruned,
                        printed: r.printed
                    };
                }
        }
    }
    function Er(e) {
        if (!e) return false;
        switch(e.type){
            case "name":
            case "path":
            case "regex":
            case "type":
            case "prune":
            case "print":
                return false;
            case "empty":
            case "mtime":
            case "newer":
            case "size":
            case "perm":
                return true;
            case "not":
                return Er(e.expr);
            case "and":
            case "or":
                return Er(e.left) || Er(e.right);
        }
    }
    function Sr(e) {
        if (!e) return false;
        switch(e.type){
            case "empty":
                return true;
            case "not":
                return Sr(e.expr);
            case "and":
            case "or":
                return Sr(e.left) || Sr(e.right);
            default:
                return false;
        }
    }
    function sp(e) {
        let t = {
            terminalDirName: null,
            requiredExtension: null
        };
        if (!e) return t;
        let n = cE(e);
        if (uE(e) && n.length === 1) {
            let i = n[0].split("/").filter((o)=>o.length > 0);
            if (i.length >= 2) for(let o = i.length - 2; o >= 0; o--){
                let a = i[o];
                if (!a.includes("*") && !a.includes("?") && !a.includes("[") && a !== "." && a !== "..") {
                    let l = i[o + 1];
                    if (l && (l.includes("*") || l.includes("?"))) {
                        t.terminalDirName = a;
                        let c = l.match(/^\*(\.[a-zA-Z0-9]+)$/);
                        c && (t.requiredExtension = c[1]);
                    }
                    break;
                }
            }
        }
        return t;
    }
    function cE(e) {
        let t = [], n = (r)=>{
            r.type === "path" ? t.push(r.pattern) : r.type === "not" ? n(r.expr) : (r.type === "and" || r.type === "or") && (n(r.left), n(r.right));
        };
        return n(e), t;
    }
    function uE(e) {
        let t = (n)=>n.type === "type" && n.fileType === "f" ? true : n.type === "not" ? t(n.expr) : n.type === "and" || n.type === "or" ? t(n.left) || t(n.right) : false;
        return t(e);
    }
    function ip(e) {
        let t = [], n = (r)=>{
            r && (r.type === "newer" ? t.push(r.refPath) : r.type === "not" ? n(r.expr) : (r.type === "and" || r.type === "or") && (n(r.left), n(r.right)));
        };
        return n(e), t;
    }
    function Ar(e) {
        if (!e) return true;
        switch(e.type){
            case "name":
            case "path":
            case "regex":
            case "type":
            case "prune":
            case "print":
                return true;
            case "empty":
            case "mtime":
            case "newer":
            case "size":
            case "perm":
                return false;
            case "not":
                return Ar(e.expr);
            case "and":
            case "or":
                return Ar(e.left) && Ar(e.right);
        }
    }
    function mn(e, t, n, r, s) {
        switch(e.type){
            case "name":
                {
                    let i = e.pattern, o = i.match(/^\*(\.[a-zA-Z0-9]+)$/);
                    if (o) {
                        let a = o[1];
                        if (e.ignoreCase) {
                            if (!t.toLowerCase().endsWith(a.toLowerCase())) return {
                                matches: false,
                                pruned: false,
                                printed: false
                            };
                        } else if (!t.endsWith(a)) return {
                            matches: false,
                            pruned: false,
                            printed: false
                        };
                        return {
                            matches: true,
                            pruned: false,
                            printed: false
                        };
                    }
                    return {
                        matches: Ye(t, i, e.ignoreCase),
                        pruned: false,
                        printed: false
                    };
                }
            case "path":
                {
                    let i = e.pattern, o = i.split("/");
                    for(let l = 0; l < o.length - 1; l++){
                        let c = o[l];
                        if (c && c !== "." && c !== ".." && !c.includes("*") && !c.includes("?") && !c.includes("[")) {
                            let u = `/${c}/`;
                            if (e.ignoreCase) {
                                if (!n.toLowerCase().includes(u.toLowerCase())) return {
                                    matches: false,
                                    pruned: false,
                                    printed: false
                                };
                            } else if (!n.includes(u)) return {
                                matches: false,
                                pruned: false,
                                printed: false
                            };
                        }
                    }
                    let a = i.match(/\*(\.[a-zA-Z0-9]+)$/);
                    if (a) {
                        let l = a[1];
                        if (e.ignoreCase) {
                            if (!n.toLowerCase().endsWith(l.toLowerCase())) return {
                                matches: false,
                                pruned: false,
                                printed: false
                            };
                        } else if (!n.endsWith(l)) return {
                            matches: false,
                            pruned: false,
                            printed: false
                        };
                    }
                    return {
                        matches: Ye(n, i, e.ignoreCase),
                        pruned: false,
                        printed: false
                    };
                }
            case "regex":
                try {
                    let i = e.ignoreCase ? "i" : "";
                    return {
                        matches: new RegExp(e.pattern, i).test(n),
                        pruned: false,
                        printed: false
                    };
                } catch  {
                    return {
                        matches: false,
                        pruned: false,
                        printed: false
                    };
                }
            case "type":
                return e.fileType === "f" ? {
                    matches: r,
                    pruned: false,
                    printed: false
                } : e.fileType === "d" ? {
                    matches: s,
                    pruned: false,
                    printed: false
                } : {
                    matches: false,
                    pruned: false,
                    printed: false
                };
            case "prune":
                return {
                    matches: true,
                    pruned: true,
                    printed: false
                };
            case "print":
                return {
                    matches: true,
                    pruned: false,
                    printed: true
                };
            case "not":
                {
                    let i = mn(e.expr, t, n, r, s);
                    return {
                        matches: !i.matches,
                        pruned: i.pruned,
                        printed: false
                    };
                }
            case "and":
                {
                    let i = mn(e.left, t, n, r, s);
                    if (!i.matches) return {
                        matches: false,
                        pruned: i.pruned,
                        printed: false
                    };
                    let o = mn(e.right, t, n, r, s);
                    return {
                        matches: o.matches,
                        pruned: i.pruned || o.pruned,
                        printed: i.printed || o.printed
                    };
                }
            case "or":
                {
                    let i = mn(e.left, t, n, r, s);
                    if (i.matches) return i;
                    let o = mn(e.right, t, n, r, s);
                    return {
                        matches: o.matches,
                        pruned: i.pruned || o.pruned,
                        printed: o.printed
                    };
                }
            default:
                return {
                    matches: false,
                    pruned: false,
                    printed: false
                };
        }
    }
    function Cr(e) {
        if (!e) return false;
        switch(e.type){
            case "prune":
                return true;
            case "not":
                return Cr(e.expr);
            case "and":
            case "or":
                return Cr(e.left) || Cr(e.right);
            default:
                return false;
        }
    }
    function Yt(e) {
        switch(e.type){
            case "name":
            case "path":
            case "regex":
            case "type":
            case "prune":
            case "print":
                return true;
            case "empty":
            case "mtime":
            case "newer":
            case "size":
            case "perm":
                return false;
            case "not":
                return Yt(e.expr);
            case "and":
            case "or":
                return Yt(e.left) && Yt(e.right);
        }
    }
    function op(e, t) {
        if (!e || !t.isDirectory) return {
            shouldPrune: false
        };
        if (!Yt(e)) return bo(e, t);
        let n = {
            name: t.name,
            relativePath: t.relativePath,
            isFile: t.isFile,
            isDirectory: t.isDirectory,
            isEmpty: false,
            mtime: 0,
            size: 0,
            mode: 0,
            newerRefTimes: new Map()
        };
        return {
            shouldPrune: kt(e, n).pruned
        };
    }
    function bo(e, t) {
        switch(e.type){
            case "or":
                {
                    if (Yt(e.left)) {
                        let n = {
                            name: t.name,
                            relativePath: t.relativePath,
                            isFile: t.isFile,
                            isDirectory: t.isDirectory,
                            isEmpty: false,
                            mtime: 0,
                            size: 0,
                            mode: 0,
                            newerRefTimes: new Map()
                        };
                        if (kt(e.left, n).pruned) return {
                            shouldPrune: true
                        };
                    }
                    return bo(e.right, t);
                }
            case "and":
                {
                    if (Yt(e.left) && Yt(e.right)) {
                        let n = {
                            name: t.name,
                            relativePath: t.relativePath,
                            isFile: t.isFile,
                            isDirectory: t.isDirectory,
                            isEmpty: false,
                            mtime: 0,
                            size: 0,
                            mode: 0,
                            newerRefTimes: new Map()
                        };
                        return {
                            shouldPrune: kt(e, n).pruned
                        };
                    }
                    if (Yt(e.left)) {
                        let n = {
                            name: t.name,
                            relativePath: t.relativePath,
                            isFile: t.isFile,
                            isDirectory: t.isDirectory,
                            isEmpty: false,
                            mtime: 0,
                            size: 0,
                            mode: 0,
                            newerRefTimes: new Map()
                        };
                        return kt(e.left, n).matches ? bo(e.right, t) : {
                            shouldPrune: false
                        };
                    }
                    return {
                        shouldPrune: false
                    };
                }
            case "not":
                return {
                    shouldPrune: false
                };
            default:
                return {
                    shouldPrune: false
                };
        }
    }
    var ap = v(()=>{
        Hi();
    });
    function lp(e, t) {
        let n = [], r = [], s = t;
        for(; s < e.length;){
            let o = e[s];
            if (o === "(" || o === "\\(") {
                n.push({
                    type: "lparen"
                }), s++;
                continue;
            }
            if (o === ")" || o === "\\)") {
                n.push({
                    type: "rparen"
                }), s++;
                continue;
            }
            if (o === "-name" && s + 1 < e.length) n.push({
                type: "expr",
                expr: {
                    type: "name",
                    pattern: e[++s]
                }
            });
            else if (o === "-iname" && s + 1 < e.length) n.push({
                type: "expr",
                expr: {
                    type: "name",
                    pattern: e[++s],
                    ignoreCase: true
                }
            });
            else if (o === "-path" && s + 1 < e.length) n.push({
                type: "expr",
                expr: {
                    type: "path",
                    pattern: e[++s]
                }
            });
            else if (o === "-ipath" && s + 1 < e.length) n.push({
                type: "expr",
                expr: {
                    type: "path",
                    pattern: e[++s],
                    ignoreCase: true
                }
            });
            else if (o === "-regex" && s + 1 < e.length) n.push({
                type: "expr",
                expr: {
                    type: "regex",
                    pattern: e[++s]
                }
            });
            else if (o === "-iregex" && s + 1 < e.length) n.push({
                type: "expr",
                expr: {
                    type: "regex",
                    pattern: e[++s],
                    ignoreCase: true
                }
            });
            else if (o === "-type" && s + 1 < e.length) {
                let a = e[++s];
                if (a === "f" || a === "d") n.push({
                    type: "expr",
                    expr: {
                        type: "type",
                        fileType: a
                    }
                });
                else return {
                    expr: null,
                    pathIndex: s,
                    error: `find: Unknown argument to -type: ${a}
`,
                    actions: []
                };
            } else if (o === "-empty") n.push({
                type: "expr",
                expr: {
                    type: "empty"
                }
            });
            else if (o === "-mtime" && s + 1 < e.length) {
                let a = e[++s], l = "exact", c = a;
                a.startsWith("+") ? (l = "more", c = a.slice(1)) : a.startsWith("-") && (l = "less", c = a.slice(1));
                let u = parseInt(c, 10);
                Number.isNaN(u) || n.push({
                    type: "expr",
                    expr: {
                        type: "mtime",
                        days: u,
                        comparison: l
                    }
                });
            } else if (o === "-newer" && s + 1 < e.length) {
                let a = e[++s];
                n.push({
                    type: "expr",
                    expr: {
                        type: "newer",
                        refPath: a
                    }
                });
            } else if (o === "-size" && s + 1 < e.length) {
                let a = e[++s], l = "exact", c = a;
                a.startsWith("+") ? (l = "more", c = a.slice(1)) : a.startsWith("-") && (l = "less", c = a.slice(1));
                let u = c.match(/^(\d+)([ckMGb])?$/);
                if (u) {
                    let f = parseInt(u[1], 10), p = u[2] || "b";
                    n.push({
                        type: "expr",
                        expr: {
                            type: "size",
                            value: f,
                            unit: p,
                            comparison: l
                        }
                    });
                }
            } else if (o === "-perm" && s + 1 < e.length) {
                let a = e[++s], l = "exact", c = a;
                a.startsWith("-") ? (l = "all", c = a.slice(1)) : a.startsWith("/") && (l = "any", c = a.slice(1));
                let u = parseInt(c, 8);
                Number.isNaN(u) || n.push({
                    type: "expr",
                    expr: {
                        type: "perm",
                        mode: u,
                        matchType: l
                    }
                });
            } else if (o === "-prune") n.push({
                type: "expr",
                expr: {
                    type: "prune"
                }
            });
            else if (o === "-not" || o === "!") n.push({
                type: "not"
            });
            else if (o === "-o" || o === "-or") n.push({
                type: "op",
                op: "or"
            });
            else if (o === "-a" || o === "-and") n.push({
                type: "op",
                op: "and"
            });
            else if (o === "-maxdepth" || o === "-mindepth") s++;
            else if (o !== "-depth") if (o === "-exec") {
                let a = [];
                for(s++; s < e.length && e[s] !== ";" && e[s] !== "+";)a.push(e[s]), s++;
                if (s >= e.length) return {
                    expr: null,
                    pathIndex: s,
                    error: "find: missing argument to `-exec'\n",
                    actions: []
                };
                let l = e[s] === "+";
                r.push({
                    type: "exec",
                    command: a,
                    batchMode: l
                });
            } else if (o === "-print") n.push({
                type: "expr",
                expr: {
                    type: "print"
                }
            }), r.push({
                type: "print"
            });
            else if (o === "-print0") r.push({
                type: "print0"
            });
            else if (o === "-printf" && s + 1 < e.length) {
                let a = e[++s];
                r.push({
                    type: "printf",
                    format: a
                });
            } else if (o === "-delete") r.push({
                type: "delete"
            });
            else {
                if (o.startsWith("-")) return {
                    expr: null,
                    pathIndex: s,
                    error: `find: unknown predicate '${o}'
`,
                    actions: []
                };
                if (n.length === 0) {
                    s++;
                    continue;
                }
                break;
            }
            s++;
        }
        if (n.length === 0) return {
            expr: null,
            pathIndex: s,
            actions: r
        };
        let i = fE(n);
        return i.error ? {
            expr: null,
            pathIndex: s,
            error: i.error,
            actions: r
        } : {
            expr: i.expr,
            pathIndex: s,
            actions: r
        };
    }
    function fE(e) {
        let t = 0;
        function n() {
            let a = r();
            if (!a) return null;
            for(; t < e.length;){
                let l = e[t];
                if (l.type === "op" && l.op === "or") {
                    t++;
                    let c = r();
                    if (!c) return a;
                    a = {
                        type: "or",
                        left: a,
                        right: c
                    };
                } else break;
            }
            return a;
        }
        function r() {
            let a = s();
            if (!a) return null;
            for(; t < e.length;){
                let l = e[t];
                if (l.type === "op" && l.op === "and") {
                    t++;
                    let c = s();
                    if (!c) return a;
                    a = {
                        type: "and",
                        left: a,
                        right: c
                    };
                } else if (l.type === "expr" || l.type === "not" || l.type === "lparen") {
                    let c = s();
                    if (!c) return a;
                    a = {
                        type: "and",
                        left: a,
                        right: c
                    };
                } else break;
            }
            return a;
        }
        function s() {
            if (t < e.length && e[t].type === "not") {
                t++;
                let a = s();
                return a ? {
                    type: "not",
                    expr: a
                } : null;
            }
            return i();
        }
        function i() {
            if (t >= e.length) return null;
            let a = e[t];
            if (a.type === "lparen") {
                t++;
                let l = n();
                return t < e.length && e[t].type === "rparen" && t++, l;
            }
            return a.type === "expr" ? (t++, a.expr) : (a.type === "rparen", null);
        }
        return {
            expr: n()
        };
    }
    var cp = v(()=>{});
    var fp = {};
    V(fp, {
        findCommand: ()=>gE
    });
    function pE() {
        return {
            readdirCalls: 0,
            readdirTime: 0,
            statCalls: 0,
            statTime: 0,
            evalCalls: 0,
            evalTime: 0,
            nodeCount: 0,
            batchCount: 0,
            batchTime: 0,
            earlyPrunes: 0
        };
    }
    function dE(e, t, n) {
        e({
            category: "find",
            name: "summary",
            durationMs: n,
            details: {
                readdirCalls: t.readdirCalls,
                readdirTimeMs: t.readdirTime,
                statCalls: t.statCalls,
                statTimeMs: t.statTime,
                evalCalls: t.evalCalls,
                evalTimeMs: t.evalTime,
                nodeCount: t.nodeCount,
                batchCount: t.batchCount,
                batchTimeMs: t.batchTime,
                earlyPrunes: t.earlyPrunes,
                otherTimeMs: n - t.readdirTime - t.statTime - t.evalTime - t.batchTime
            }
        });
    }
    function yE(e, t) {
        let n = Jr(e), r = "", s = 0;
        for(; s < n.length;)if (n[s] === "%" && s + 1 < n.length) {
            if (s++, n[s] === "%") {
                r += "%", s++;
                continue;
            }
            let [i, o, a] = tc(n, s);
            if (s += a, s >= n.length) {
                r += "%";
                break;
            }
            let l = n[s], c;
            switch(l){
                case "f":
                    c = t.name, s++;
                    break;
                case "h":
                    {
                        let u = t.path.lastIndexOf("/");
                        c = u > 0 ? t.path.slice(0, u) : ".", s++;
                        break;
                    }
                case "p":
                    c = t.path, s++;
                    break;
                case "P":
                    {
                        let u = t.startingPoint;
                        t.path === u ? c = "" : t.path.startsWith(`${u}/`) ? c = t.path.slice(u.length + 1) : u === "." && t.path.startsWith("./") ? c = t.path.slice(2) : c = t.path, s++;
                        break;
                    }
                case "s":
                    c = String(t.size), s++;
                    break;
                case "d":
                    c = String(t.depth), s++;
                    break;
                case "m":
                    c = (t.mode & 511).toString(8), s++;
                    break;
                case "M":
                    c = bE(t.mode, t.isDirectory), s++;
                    break;
                case "t":
                    {
                        let u = new Date(t.mtime);
                        c = wE(u), s++;
                        break;
                    }
                case "T":
                    {
                        if (s + 1 < n.length) {
                            let u = n[s + 1], f = new Date(t.mtime);
                            c = xE(f, u), s += 2;
                        } else c = "%T", s++;
                        break;
                    }
                default:
                    r += `%${i !== 0 || o !== -1 ? `${i}.${o}` : ""}${l}`, s++;
                    continue;
            }
            r += Xr(c, i, o);
        } else r += n[s], s++;
        return r;
    }
    function bE(e, t) {
        let n = e & 511, r = t ? "d" : "-";
        return r += n & 256 ? "r" : "-", r += n & 128 ? "w" : "-", r += n & 64 ? "x" : "-", r += n & 32 ? "r" : "-", r += n & 16 ? "w" : "-", r += n & 8 ? "x" : "-", r += n & 4 ? "r" : "-", r += n & 2 ? "w" : "-", r += n & 1 ? "x" : "-", r;
    }
    function wE(e) {
        let t = [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ], n = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ], r = t[e.getDay()], s = n[e.getMonth()], i = String(e.getDate()).padStart(2, " "), o = String(e.getHours()).padStart(2, "0"), a = String(e.getMinutes()).padStart(2, "0"), l = String(e.getSeconds()).padStart(2, "0"), c = e.getFullYear();
        return `${r} ${s} ${i} ${o}:${a}:${l} ${c}`;
    }
    function xE(e, t) {
        switch(t){
            case "@":
                return String(e.getTime() / 1e3);
            case "Y":
                return String(e.getFullYear());
            case "m":
                return String(e.getMonth() + 1).padStart(2, "0");
            case "d":
                return String(e.getDate()).padStart(2, "0");
            case "H":
                return String(e.getHours()).padStart(2, "0");
            case "M":
                return String(e.getMinutes()).padStart(2, "0");
            case "S":
                return String(e.getSeconds()).padStart(2, "0");
            case "T":
                return `${String(e.getHours()).padStart(2, "0")}:${String(e.getMinutes()).padStart(2, "0")}:${String(e.getSeconds()).padStart(2, "0")}`;
            case "F":
                return `${e.getFullYear()}-${String(e.getMonth() + 1).padStart(2, "0")}-${String(e.getDate()).padStart(2, "0")}`;
            default:
                return `%T${t}`;
        }
    }
    var up, hE, mE, gE, pp = v(()=>{
        X();
        Bi();
        ap();
        cp();
        up = 500;
        hE = {
            name: "find",
            summary: "search for files in a directory hierarchy",
            usage: "find [path...] [expression]",
            options: [
                "-name PATTERN    file name matches shell pattern PATTERN",
                "-iname PATTERN   like -name but case insensitive",
                "-path PATTERN    file path matches shell pattern PATTERN",
                "-ipath PATTERN   like -path but case insensitive",
                "-regex PATTERN   file path matches regular expression PATTERN",
                "-iregex PATTERN  like -regex but case insensitive",
                "-type TYPE       file is of type: f (regular file), d (directory)",
                "-empty           file is empty or directory is empty",
                "-mtime N         file's data was modified N*24 hours ago",
                "-newer FILE      file was modified more recently than FILE",
                "-size N[ckMGb]   file uses N units of space (c=bytes, k=KB, M=MB, G=GB, b=512B blocks)",
                "-perm MODE       file's permission bits are exactly MODE (octal)",
                "-perm -MODE      all permission bits MODE are set",
                "-perm /MODE      any permission bits MODE are set",
                "-maxdepth LEVELS descend at most LEVELS directories",
                "-mindepth LEVELS do not apply tests at levels less than LEVELS",
                "-depth           process directory contents before directory itself",
                "-prune           do not descend into this directory",
                "-not, !          negate the following expression",
                "-a, -and         logical AND (default)",
                "-o, -or          logical OR",
                "-exec CMD {} ;   execute CMD on each file ({} is replaced by filename)",
                "-exec CMD {} +   execute CMD with multiple files at once",
                "-print           print the full file name (default action)",
                "-print0          print the full file name followed by a null character",
                "-printf FORMAT   print FORMAT with directives: %f %h %p %P %s %d %m %M %t",
                "-delete          delete found files/directories",
                "    --help       display this help and exit"
            ]
        }, mE = new Set([
            "-name",
            "-iname",
            "-path",
            "-ipath",
            "-regex",
            "-iregex",
            "-type",
            "-maxdepth",
            "-mindepth",
            "-mtime",
            "-newer",
            "-size",
            "-perm"
        ]), gE = {
            name: "find",
            async execute (e, t) {
                if (_(e)) return F(hE);
                let n = [], r = null, s = null, i = false, o = false;
                for(let N = 0; N < e.length; N++){
                    let P = e[N];
                    if (P === "-maxdepth" && N + 1 < e.length) o = true, r = parseInt(e[++N], 10);
                    else if (P === "-mindepth" && N + 1 < e.length) o = true, s = parseInt(e[++N], 10);
                    else if (P === "-depth") o = true, i = true;
                    else if (P === "-exec") for(o = true, N++; N < e.length && e[N] !== ";" && e[N] !== "+";)N++;
                    else !P.startsWith("-") && P !== ";" && P !== "+" && P !== "(" && P !== ")" && P !== "\\(" && P !== "\\)" && P !== "!" ? o || n.push(P) : mE.has(P) ? (o = true, N++) : (P.startsWith("-") || P === "(" || P === "\\(" || P === "!") && (o = true);
                }
                n.length === 0 && n.push(".");
                let { expr: a, error: l, actions: c } = lp(e, 0);
                if (l) return {
                    stdout: "",
                    stderr: l,
                    exitCode: 1
                };
                let u = c.some((N)=>N.type === "print"), f = c.length === 0, p = [], d = c.some((N)=>N.type === "printf"), m = [], h = "", g = 0, b = ip(a), y = new Map();
                for (let N of b){
                    let P = t.fs.resolvePath(t.cwd, N);
                    try {
                        let k = await t.fs.stat(P);
                        y.set(N, k.mtime?.getTime() ?? Date.now());
                    } catch  {}
                }
                let w = c.some((N)=>{
                    if (N.type !== "printf") return false;
                    let P = N.format.replace(/%%/g, "");
                    return /%[-+]?[0-9]*\.?[0-9]*(s|m|M|t|T)/.test(P);
                }), E = Er(a) || w, C = Sr(a), A = sp(a), I = Cr(a), O = Ar(a), L = typeof t.fs.readdirWithFileTypes == "function";
                for (let N of n){
                    let Y = function(B) {
                        let be = s === null || B.depth >= s, ee = false;
                        if (be && a !== null) {
                            let U = Date.now(), ye;
                            if (O) ye = mn(a, B.name, B.relativePath, B.isFile, B.isDirectory);
                            else {
                                let Ce = {
                                    name: B.name,
                                    relativePath: B.relativePath,
                                    isFile: B.isFile,
                                    isDirectory: B.isDirectory,
                                    isEmpty: B.isEmpty,
                                    mtime: B.stat?.mtime?.getTime() ?? Date.now(),
                                    size: B.stat?.size ?? 0,
                                    mode: B.stat?.mode ?? 420,
                                    newerRefTimes: y
                                };
                                ye = kt(a, Ce);
                            }
                            be = ye.matches, ee = u ? ye.printed : be, k.evalCalls++, k.evalTime += Date.now() - U;
                        } else be && (ee = true);
                        return ee ? {
                            print: true,
                            printfData: d ? {
                                path: B.relativePath,
                                name: B.name,
                                size: B.stat?.size ?? 0,
                                mtime: B.stat?.mtime?.getTime() ?? Date.now(),
                                mode: B.stat?.mode ?? 420,
                                isDirectory: B.isDirectory,
                                depth: B.depth,
                                startingPoint: N
                            } : null
                        } : {
                            print: false,
                            printfData: null
                        };
                    };
                    N.length > 1 && N.endsWith("/") && (N = N.slice(0, -1));
                    let P = t.fs.resolvePath(t.cwd, N);
                    try {
                        await t.fs.stat(P);
                    } catch  {
                        h += `find: ${N}: No such file or directory
`, g = 1;
                        continue;
                    }
                    let k = pE(), R = Date.now();
                    async function T(B) {
                        let { path: q, depth: be, typeInfo: ee } = B;
                        if (k.nodeCount++, r !== null && be > r) return null;
                        let ge, U, ye;
                        if (ee && !E) ge = ee.isFile, U = ee.isDirectory;
                        else {
                            try {
                                let un = Date.now();
                                ye = await t.fs.stat(q), k.statCalls++, k.statTime += Date.now() - un;
                            } catch  {
                                return null;
                            }
                            if (!ye) return null;
                            ge = ye.isFile, U = ye.isDirectory;
                        }
                        let Ce;
                        q === P ? Ce = N.split("/").pop() || N : Ce = q.split("/").pop() || "";
                        let Re = q === P ? N : N === "." ? `./${q.slice(P === "/" ? P.length : P.length + 1)}` : N + q.slice(P.length), Me = [], ze = null, We = null, Be = false;
                        U && I && !i && (Be = op(a, {
                            name: Ce,
                            relativePath: Re,
                            isFile: ge,
                            isDirectory: U
                        }).shouldPrune, Be && k.earlyPrunes++);
                        let yt = r !== null && be >= r, bt = A.terminalDirName !== null && Ce === A.terminalDirName, dr = !yt && !bt && !Be;
                        if (U && ((dr || C || bt) && !Be)) {
                            let un = Date.now();
                            if (L && t.fs.readdirWithFileTypes) {
                                if (ze = await t.fs.readdirWithFileTypes(q), We = ze.map((at)=>at.name), k.readdirCalls++, k.readdirTime += Date.now() - un, dr) Me = ze.map((at, Ct)=>({
                                        path: q === "/" ? `/${at.name}` : `${q}/${at.name}`,
                                        depth: be + 1,
                                        typeInfo: {
                                            isFile: at.isFile,
                                            isDirectory: at.isDirectory
                                        },
                                        resultIndex: Ct
                                    }));
                                else if (bt) {
                                    let at = A.requiredExtension;
                                    Me = ze.filter((Ct)=>Ct.isFile && (!at || Ct.name.endsWith(at))).map((Ct, Vy)=>({
                                            path: q === "/" ? `/${Ct.name}` : `${q}/${Ct.name}`,
                                            depth: be + 1,
                                            typeInfo: {
                                                isFile: Ct.isFile,
                                                isDirectory: Ct.isDirectory
                                            },
                                            resultIndex: Vy
                                        }));
                                }
                            } else We = await t.fs.readdir(q), k.readdirCalls++, k.readdirTime += Date.now() - un, dr && (Me = We.map((at, Ct)=>({
                                    path: q === "/" ? `/${at}` : `${q}/${at}`,
                                    depth: be + 1,
                                    resultIndex: Ct
                                })));
                        }
                        let Qr = ge ? (ye?.size ?? 0) === 0 : We !== null && We.length === 0, Rn = Be;
                        if (!i && a !== null && !Be && I) {
                            let un = Date.now(), at = {
                                name: Ce,
                                relativePath: Re,
                                isFile: ge,
                                isDirectory: U,
                                isEmpty: Qr,
                                mtime: ye?.mtime?.getTime() ?? Date.now(),
                                size: ye?.size ?? 0,
                                mode: ye?.mode ?? 420,
                                newerRefTimes: y
                            };
                            Rn = kt(a, at).pruned, k.evalCalls++, k.evalTime += Date.now() - un;
                        }
                        return {
                            relativePath: Re,
                            name: Ce,
                            isFile: ge,
                            isDirectory: U,
                            isEmpty: Qr,
                            stat: ye,
                            depth: be,
                            children: Rn ? [] : Me,
                            pruned: Rn
                        };
                    }
                    async function ie() {
                        let B = {
                            paths: [],
                            printfData: []
                        };
                        if (i) {
                            let ye = function(Ce) {
                                let Re = {
                                    paths: [],
                                    printfData: []
                                }, Me = ee[Ce];
                                if (!Me) return Re;
                                for (let Be of Me.childIndices){
                                    let yt = ye(Be);
                                    Re.paths.push(...yt.paths), Re.printfData.push(...yt.printfData);
                                }
                                let { print: ze, printfData: We } = Y(Me.node);
                                return ze && (Re.paths.push(Me.node.relativePath), We && Re.printfData.push(We)), Re;
                            };
                            let ee = [], ge = [
                                {
                                    item: {
                                        path: P,
                                        depth: 0,
                                        resultIndex: 0
                                    },
                                    parentIndex: -1,
                                    childOrderInParent: 0
                                }
                            ], U = new Map();
                            for(; ge.length > 0;){
                                let Ce = Date.now(), Re = ge.splice(0, up), Me = await Promise.all(Re.map((ze)=>T(ze.item)));
                                k.batchCount++, k.batchTime += Date.now() - Ce;
                                for(let ze = 0; ze < Re.length; ze++){
                                    let We = Me[ze], Be = Re[ze];
                                    if (!We) continue;
                                    let yt = ee.length;
                                    if (Be.parentIndex >= 0) {
                                        let bt = U.get(Be.parentIndex) || [];
                                        bt.push(yt), U.set(Be.parentIndex, bt);
                                    }
                                    ee.push({
                                        node: We,
                                        parentIndex: Be.parentIndex,
                                        childIndices: []
                                    });
                                    for(let bt = 0; bt < We.children.length; bt++)ge.push({
                                        item: We.children[bt],
                                        parentIndex: yt,
                                        childOrderInParent: bt
                                    });
                                }
                            }
                            for (let [Ce, Re] of U)Ce >= 0 && Ce < ee.length && (ee[Ce].childIndices = Re);
                            if (ee.length > 0) {
                                let Ce = ye(0);
                                B.paths.push(...Ce.paths), B.printfData.push(...Ce.printfData);
                            }
                        } else {
                            let Ce = function(Re) {
                                let Me = ee.get(Re);
                                Me && (B.paths.push(Me.path), Me.printfData && B.printfData.push(Me.printfData));
                                let ze = ye.get(Re);
                                if (ze) for (let We of ze)Ce(We);
                            };
                            let ee = new Map(), ge = 0, U = [
                                {
                                    item: {
                                        path: P,
                                        depth: 0,
                                        resultIndex: 0
                                    },
                                    orderIndex: ge++
                                }
                            ], ye = new Map();
                            for(; U.length > 0;){
                                let Re = Date.now(), Me = U.splice(0, up), ze = await Promise.all(Me.map(async ({ item: We, orderIndex: Be })=>{
                                    let yt = await T(We);
                                    return yt ? {
                                        node: yt,
                                        orderIndex: Be
                                    } : null;
                                }));
                                k.batchCount++, k.batchTime += Date.now() - Re;
                                for (let We of ze){
                                    if (!We) continue;
                                    let { node: Be, orderIndex: yt } = We, { print: bt, printfData: dr } = Y(Be);
                                    if (bt && ee.set(yt, {
                                        path: Be.relativePath,
                                        printfData: dr
                                    }), Be.children.length > 0) {
                                        let Mi = [];
                                        for (let Qr of Be.children){
                                            let Rn = ge++;
                                            Mi.push(Rn), U.push({
                                                item: Qr,
                                                orderIndex: Rn
                                            });
                                        }
                                        ye.set(yt, Mi);
                                    }
                                }
                            }
                            Ce(0);
                        }
                        return B;
                    }
                    let K = await ie();
                    if (p.push(...K.paths), m.push(...K.printfData), t.trace) {
                        let B = Date.now() - R;
                        dE(t.trace, k, B), t.trace({
                            category: "find",
                            name: "searchPath",
                            durationMs: B,
                            details: {
                                path: N,
                                resultsFound: K.paths.length
                            }
                        });
                    }
                }
                let D = "";
                if (c.length > 0) for (let N of c)switch(N.type){
                    case "print":
                        D += p.length > 0 ? `${p.join(`
`)}
` : "";
                        break;
                    case "print0":
                        D += p.length > 0 ? `${p.join("\0")}\0` : "";
                        break;
                    case "delete":
                        {
                            let P = [
                                ...p
                            ].sort((k, R)=>R.length - k.length);
                            for (let k of P){
                                let R = t.fs.resolvePath(t.cwd, k);
                                try {
                                    await t.fs.rm(R, {
                                        recursive: false
                                    });
                                } catch (T) {
                                    let Y = T instanceof Error ? T.message : String(T);
                                    h += `find: cannot delete '${k}': ${Y}
`, g = 1;
                                }
                            }
                            break;
                        }
                    case "printf":
                        for (let P of m)D += yE(N.format, P);
                        break;
                    case "exec":
                        if (!t.exec) return {
                            stdout: "",
                            stderr: `find: -exec not supported in this context
`,
                            exitCode: 1
                        };
                        if (N.batchMode) {
                            let P = [];
                            for (let T of N.command)T === "{}" ? P.push(...p) : P.push(T);
                            let k = P.map((T)=>`"${T}"`).join(" "), R = await t.exec(k, {
                                cwd: t.cwd
                            });
                            D += R.stdout, h += R.stderr, R.exitCode !== 0 && (g = R.exitCode);
                        } else for (let P of p){
                            let R = N.command.map((Y)=>Y === "{}" ? P : Y).map((Y)=>`"${Y}"`).join(" "), T = await t.exec(R, {
                                cwd: t.cwd
                            });
                            D += T.stdout, h += T.stderr, T.exitCode !== 0 && (g = T.exitCode);
                        }
                        break;
                }
                else f && (D = p.length > 0 ? `${p.join(`
`)}
` : "");
                return {
                    stdout: D,
                    stderr: h,
                    exitCode: g
                };
            }
        };
    });
    var dp = {};
    V(dp, {
        basenameCommand: ()=>SE
    });
    var EE, SE, hp = v(()=>{
        X();
        EE = {
            name: "basename",
            summary: "strip directory and suffix from filenames",
            usage: `basename NAME [SUFFIX]
basename OPTION... NAME...`,
            options: [
                "-a, --multiple   support multiple arguments",
                "-s, --suffix=SUFFIX  remove a trailing SUFFIX",
                "    --help       display this help and exit"
            ]
        }, SE = {
            name: "basename",
            async execute (e, t) {
                if (_(e)) return F(EE);
                let n = false, r = "", s = [];
                for(let o = 0; o < e.length; o++){
                    let a = e[o];
                    a === "-a" || a === "--multiple" ? n = true : a === "-s" && o + 1 < e.length ? (r = e[++o], n = true) : a.startsWith("--suffix=") ? (r = a.slice(9), n = true) : a.startsWith("-") || s.push(a);
                }
                if (s.length === 0) return {
                    stdout: "",
                    stderr: `basename: missing operand
`,
                    exitCode: 1
                };
                !n && s.length >= 2 && (r = s.pop() ?? "");
                let i = [];
                for (let o of s){
                    let a = o.replace(/\/+$/, ""), l = a.split("/").pop() || a;
                    r && l.endsWith(r) && (l = l.slice(0, -r.length)), i.push(l);
                }
                return {
                    stdout: `${i.join(`
`)}
`,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var mp = {};
    V(mp, {
        dirnameCommand: ()=>CE
    });
    var AE, CE, gp = v(()=>{
        X();
        AE = {
            name: "dirname",
            summary: "strip last component from file name",
            usage: "dirname [OPTION] NAME...",
            options: [
                "    --help       display this help and exit"
            ]
        }, CE = {
            name: "dirname",
            async execute (e, t) {
                if (_(e)) return F(AE);
                let n = e.filter((s)=>!s.startsWith("-"));
                if (n.length === 0) return {
                    stdout: "",
                    stderr: `dirname: missing operand
`,
                    exitCode: 1
                };
                let r = [];
                for (let s of n){
                    let i = s.replace(/\/+$/, ""), o = i.lastIndexOf("/");
                    o === -1 ? r.push(".") : o === 0 ? r.push("/") : r.push(i.slice(0, o));
                }
                return {
                    stdout: `${r.join(`
`)}
`,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var bp = {};
    V(bp, {
        treeCommand: ()=>vE
    });
    async function $E(e, t, n, r, s) {
        let i = {
            output: "",
            stderr: "",
            dirCount: 0,
            fileCount: 0
        }, o = e.fs.resolvePath(e.cwd, t);
        try {
            if (!(await e.fs.stat(o)).isDirectory) return i.output = `${t}
`, i.fileCount = 1, i;
        } catch  {
            return i.stderr = `tree: ${t}: No such file or directory
`, i;
        }
        if (i.output = `${t}
`, n.maxDepth !== null && s >= n.maxDepth) return i;
        try {
            let a = [];
            if (e.fs.readdirWithFileTypes) a = (await e.fs.readdirWithFileTypes(o)).map((u)=>({
                    name: u.name,
                    isDirectory: u.isDirectory
                }));
            else {
                let c = await e.fs.readdir(o);
                for(let u = 0; u < c.length; u += 100){
                    let f = c.slice(u, u + 100), p = await Promise.all(f.map(async (d)=>{
                        let m = o === "/" ? `/${d}` : `${o}/${d}`;
                        try {
                            let h = await e.fs.stat(m);
                            return {
                                name: d,
                                isDirectory: h.isDirectory
                            };
                        } catch  {
                            return null;
                        }
                    }));
                    a.push(...p.filter((d)=>d !== null));
                }
            }
            let l = a.filter((c)=>!(!n.showHidden && c.name.startsWith(".") || n.directoriesOnly && !c.isDirectory));
            l.sort((c, u)=>c.name.localeCompare(u.name));
            for(let c = 0; c < l.length; c++){
                let u = l[c], f = o === "/" ? `/${u.name}` : `${o}/${u.name}`, p = c === l.length - 1, d = p ? "`-- " : "|-- ", m = r + (p ? "    " : "|   ");
                if (u.isDirectory) {
                    i.dirCount++;
                    let h = n.fullPath ? f : u.name;
                    if (i.output += `${r + d + h}
`, n.maxDepth === null || s + 1 < n.maxDepth) {
                        let g = await yp(e, f, n, m, s + 1);
                        i.output += g.output, i.dirCount += g.dirCount, i.fileCount += g.fileCount;
                    }
                } else {
                    i.fileCount++;
                    let h = n.fullPath ? f : u.name;
                    i.output += `${r + d + h}
`;
                }
            }
        } catch  {
            i.stderr = `tree: ${t}: Permission denied
`;
        }
        return i;
    }
    async function yp(e, t, n, r, s) {
        let i = {
            output: "",
            stderr: "",
            dirCount: 0,
            fileCount: 0
        };
        if (n.maxDepth !== null && s >= n.maxDepth) return i;
        try {
            let o = [];
            if (e.fs.readdirWithFileTypes) o = (await e.fs.readdirWithFileTypes(t)).map((c)=>({
                    name: c.name,
                    isDirectory: c.isDirectory
                }));
            else {
                let l = await e.fs.readdir(t);
                for(let c = 0; c < l.length; c += 100){
                    let u = l.slice(c, c + 100), f = await Promise.all(u.map(async (p)=>{
                        let d = t === "/" ? `/${p}` : `${t}/${p}`;
                        try {
                            let m = await e.fs.stat(d);
                            return {
                                name: p,
                                isDirectory: m.isDirectory
                            };
                        } catch  {
                            return null;
                        }
                    }));
                    o.push(...f.filter((p)=>p !== null));
                }
            }
            let a = o.filter((l)=>!(!n.showHidden && l.name.startsWith(".") || n.directoriesOnly && !l.isDirectory));
            a.sort((l, c)=>l.name.localeCompare(c.name));
            for(let l = 0; l < a.length; l++){
                let c = a[l], u = t === "/" ? `/${c.name}` : `${t}/${c.name}`, f = l === a.length - 1, p = f ? "`-- " : "|-- ", d = r + (f ? "    " : "|   ");
                if (c.isDirectory) {
                    i.dirCount++;
                    let m = n.fullPath ? u : c.name;
                    i.output += `${r + p + m}
`;
                    let h = await yp(e, u, n, d, s + 1);
                    i.output += h.output, i.dirCount += h.dirCount, i.fileCount += h.fileCount;
                } else {
                    i.fileCount++;
                    let m = n.fullPath ? u : c.name;
                    i.output += `${r + p + m}
`;
                }
            }
        } catch  {}
        return i;
    }
    var NE, kE, vE, wp = v(()=>{
        Oe();
        Pn();
        X();
        NE = {
            name: "tree",
            summary: "list contents of directories in a tree-like format",
            usage: "tree [OPTION]... [DIRECTORY]...",
            options: [
                "-a          include hidden files",
                "-d          list directories only",
                "-L LEVEL    limit depth of directory tree",
                "-f          print full path prefix for each file",
                "    --help  display this help and exit"
            ]
        }, kE = {
            showHidden: {
                short: "a",
                type: "boolean"
            },
            directoriesOnly: {
                short: "d",
                type: "boolean"
            },
            fullPath: {
                short: "f",
                type: "boolean"
            },
            maxDepth: {
                short: "L",
                type: "number"
            }
        }, vE = {
            name: "tree",
            async execute (e, t) {
                if (_(e)) return F(NE);
                let n = fe("tree", e, kE);
                if (!n.ok) return n.error;
                let r = {
                    showHidden: n.result.flags.showHidden,
                    directoriesOnly: n.result.flags.directoriesOnly,
                    maxDepth: n.result.flags.maxDepth ?? null,
                    fullPath: n.result.flags.fullPath
                }, s = n.result.positional;
                s.length === 0 && s.push(".");
                let i = "", o = "", a = 0, l = 0;
                for (let c of s){
                    let u = await $E(t, c, r, "", 0);
                    i += u.output, o += u.stderr, a += u.dirCount, l += u.fileCount;
                }
                return i += `
${a} director${a === 1 ? "y" : "ies"}`, r.directoriesOnly || (i += `, ${l} file${l === 1 ? "" : "s"}`), i += `
`, {
                    stdout: i,
                    stderr: o,
                    exitCode: o ? 1 : 0
                };
            }
        };
    });
    var Ep = {};
    V(Ep, {
        duCommand: ()=>PE
    });
    async function xp(e, t, n, r, s) {
        let i = {
            output: "",
            totalSize: 0,
            stderr: ""
        };
        try {
            let o = await e.fs.stat(t);
            if (!o.isDirectory) return i.totalSize = o.size, (r.allFiles || s === 0) && (i.output = As(o.size, r.humanReadable) + "	" + n + `
`), i;
            let a = 0, l = [];
            if (e.fs.readdirWithFileTypes) {
                let f = await e.fs.readdirWithFileTypes(t), p = f.filter((m)=>m.isFile), d = f.filter((m)=>m.isDirectory);
                for(let m = 0; m < p.length; m += 100){
                    let h = p.slice(m, m + 100), g = await Promise.all(h.map(async (b)=>{
                        let y = t === "/" ? `/${b.name}` : `${t}/${b.name}`;
                        try {
                            let w = await e.fs.stat(y);
                            return {
                                name: b.name,
                                isDirectory: false,
                                size: w.size
                            };
                        } catch  {
                            return {
                                name: b.name,
                                isDirectory: false,
                                size: 0
                            };
                        }
                    }));
                    l.push(...g);
                }
                l.push(...d.map((m)=>({
                        name: m.name,
                        isDirectory: true
                    })));
            } else {
                let f = await e.fs.readdir(t);
                for(let p = 0; p < f.length; p += 100){
                    let d = f.slice(p, p + 100), m = await Promise.all(d.map(async (h)=>{
                        let g = t === "/" ? `/${h}` : `${t}/${h}`;
                        try {
                            let b = await e.fs.stat(g);
                            return {
                                name: h,
                                isDirectory: b.isDirectory,
                                size: b.isDirectory ? void 0 : b.size
                            };
                        } catch  {
                            return {
                                name: h,
                                isDirectory: false,
                                size: 0
                            };
                        }
                    }));
                    l.push(...m);
                }
            }
            l.sort((f, p)=>f.name.localeCompare(p.name));
            let c = l.filter((f)=>!f.isDirectory);
            for (let f of c){
                let p = f.size ?? 0;
                if (a += p, r.allFiles && !r.summarize) {
                    let d = n === "." ? f.name : `${n}/${f.name}`;
                    i.output += As(p, r.humanReadable) + "	" + d + `
`;
                }
            }
            let u = l.filter((f)=>f.isDirectory);
            for(let f = 0; f < u.length; f += 100){
                let p = u.slice(f, f + 100), d = await Promise.all(p.map(async (m)=>{
                    let h = t === "/" ? `/${m.name}` : `${t}/${m.name}`, g = n === "." ? m.name : `${n}/${m.name}`;
                    return {
                        name: m.name,
                        result: await xp(e, h, g, r, s + 1)
                    };
                }));
                d.sort((m, h)=>m.name.localeCompare(h.name));
                for (let { result: m } of d)a += m.totalSize, r.summarize || (r.maxDepth === null || s + 1 <= r.maxDepth) && (i.output += m.output);
            }
            i.totalSize = a, (r.summarize || r.maxDepth === null || s <= r.maxDepth) && (i.output += `${As(a, r.humanReadable)}	${n}
`);
        } catch  {
            i.stderr = `du: cannot read directory '${n}': Permission denied
`;
        }
        return i;
    }
    function As(e, t) {
        return t ? e < 1024 ? `${e}` : e < 1024 * 1024 ? `${(e / 1024).toFixed(1)}K` : e < 1024 * 1024 * 1024 ? `${(e / (1024 * 1024)).toFixed(1)}M` : `${(e / (1024 * 1024 * 1024)).toFixed(1)}G` : String(Math.ceil(e / 1024) || 1);
    }
    var IE, RE, PE, Sp = v(()=>{
        Oe();
        Pn();
        X();
        IE = {
            name: "du",
            summary: "estimate file space usage",
            usage: "du [OPTION]... [FILE]...",
            options: [
                "-a          write counts for all files, not just directories",
                "-h          print sizes in human readable format",
                "-s          display only a total for each argument",
                "-c          produce a grand total",
                "--max-depth=N  print total for directory only if N or fewer levels deep",
                "    --help  display this help and exit"
            ]
        }, RE = {
            allFiles: {
                short: "a",
                type: "boolean"
            },
            humanReadable: {
                short: "h",
                type: "boolean"
            },
            summarize: {
                short: "s",
                type: "boolean"
            },
            grandTotal: {
                short: "c",
                type: "boolean"
            },
            maxDepth: {
                long: "max-depth",
                type: "number"
            }
        }, PE = {
            name: "du",
            async execute (e, t) {
                if (_(e)) return F(IE);
                let n = fe("du", e, RE);
                if (!n.ok) return n.error;
                let r = {
                    allFiles: n.result.flags.allFiles,
                    humanReadable: n.result.flags.humanReadable,
                    summarize: n.result.flags.summarize,
                    grandTotal: n.result.flags.grandTotal,
                    maxDepth: n.result.flags.maxDepth ?? null
                }, s = n.result.positional;
                s.length === 0 && s.push(".");
                let i = "", o = "", a = 0;
                for (let l of s){
                    let c = t.fs.resolvePath(t.cwd, l);
                    try {
                        await t.fs.stat(c);
                        let u = await xp(t, c, l, r, 0);
                        i += u.output, a += u.totalSize, o += u.stderr;
                    } catch  {
                        o += `du: cannot access '${l}': No such file or directory
`;
                    }
                }
                return r.grandTotal && s.length > 0 && (i += `${As(a, r.humanReadable)}	total
`), {
                    stdout: i,
                    stderr: o,
                    exitCode: o ? 1 : 0
                };
            }
        };
    });
    var wo = {};
    V(wo, {
        envCommand: ()=>OE,
        printenvCommand: ()=>FE
    });
    var TE, OE, DE, FE, xo = v(()=>{
        X();
        TE = {
            name: "env",
            summary: "run a program in a modified environment",
            usage: "env [OPTION]... [NAME=VALUE]... [COMMAND [ARG]...]",
            options: [
                "-i, --ignore-environment  start with an empty environment",
                "-u NAME, --unset=NAME     remove NAME from the environment",
                "    --help                display this help and exit"
            ]
        }, OE = {
            name: "env",
            async execute (e, t) {
                if (_(e)) return F(TE);
                let n = false, r = [], s = {}, i = -1;
                for(let m = 0; m < e.length; m++){
                    let h = e[m];
                    if (h === "-i" || h === "--ignore-environment") n = true;
                    else if (h === "-u" && m + 1 < e.length) r.push(e[++m]);
                    else if (h.startsWith("-u")) r.push(h.slice(2));
                    else if (h.startsWith("--unset=")) r.push(h.slice(8));
                    else {
                        if (h.startsWith("--") && h !== "--") return G("env", h);
                        if (h.startsWith("-") && h !== "-") {
                            for (let g of h.slice(1))if (g !== "i" && g !== "u") return G("env", `-${g}`);
                            h.includes("i") && (n = true);
                        } else if (h.includes("=") && i === -1) {
                            let g = h.indexOf("="), b = h.slice(0, g), y = h.slice(g + 1);
                            s[b] = y;
                        } else {
                            i = m;
                            break;
                        }
                    }
                }
                let o;
                if (n) o = {
                    ...s
                };
                else {
                    o = {
                        ...t.env
                    };
                    for (let m of r)delete o[m];
                    Object.assign(o, s);
                }
                if (i === -1) {
                    let m = [];
                    for (let [h, g] of Object.entries(o))m.push(`${h}=${g}`);
                    return {
                        stdout: m.join(`
`) + (m.length > 0 ? `
` : ""),
                        stderr: "",
                        exitCode: 0
                    };
                }
                if (!t.exec) return {
                    stdout: "",
                    stderr: `env: command execution not supported in this context
`,
                    exitCode: 1
                };
                let a = e.slice(i), l = a[0], u = a.slice(1).map((m)=>/[\s"'\\$`!*?[\]{}|&;<>()]/.test(m) ? `'${m.replace(/'/g, "'\\''")}'` : m), f = [
                    "command",
                    l,
                    ...u
                ].join(" "), p = Object.entries(s).map(([m, h])=>`${m}="${h}"`).join(" "), d = p ? `${p} ${f}` : f;
                return t.exec(d, {
                    cwd: t.cwd
                });
            }
        }, DE = {
            name: "printenv",
            summary: "print all or part of environment",
            usage: "printenv [OPTION]... [VARIABLE]...",
            options: [
                "    --help       display this help and exit"
            ]
        }, FE = {
            name: "printenv",
            async execute (e, t) {
                if (_(e)) return F(DE);
                let n = e.filter((i)=>!i.startsWith("-"));
                if (n.length === 0) {
                    let i = [];
                    for (let [o, a] of Object.entries(t.env))i.push(`${o}=${a}`);
                    return {
                        stdout: i.join(`
`) + (i.length > 0 ? `
` : ""),
                        stderr: "",
                        exitCode: 0
                    };
                }
                let r = [], s = 0;
                for (let i of n)i in t.env ? r.push(t.env[i]) : s = 1;
                return {
                    stdout: r.join(`
`) + (r.length > 0 ? `
` : ""),
                    stderr: "",
                    exitCode: s
                };
            }
        };
    });
    var Eo = {};
    V(Eo, {
        aliasCommand: ()=>LE,
        unaliasCommand: ()=>ME
    });
    var _E, Un, LE, ME, So = v(()=>{
        X();
        _E = {
            name: "alias",
            summary: "define or display aliases",
            usage: "alias [name[=value] ...]",
            options: [
                "    --help display this help and exit"
            ]
        }, Un = "BASH_ALIAS_", LE = {
            name: "alias",
            async execute (e, t) {
                if (_(e)) return F(_E);
                if (e.length === 0) {
                    let r = "";
                    for (let [s, i] of Object.entries(t.env))if (s.startsWith(Un)) {
                        let o = s.slice(Un.length);
                        r += `alias ${o}='${i}'
`;
                    }
                    return {
                        stdout: r,
                        stderr: "",
                        exitCode: 0
                    };
                }
                let n = e[0] === "--" ? e.slice(1) : e;
                for (let r of n){
                    let s = r.indexOf("=");
                    if (s === -1) {
                        let i = Un + r;
                        return t.env[i] ? {
                            stdout: `alias ${r}='${t.env[i]}'
`,
                            stderr: "",
                            exitCode: 0
                        } : {
                            stdout: "",
                            stderr: `alias: ${r}: not found
`,
                            exitCode: 1
                        };
                    } else {
                        let i = r.slice(0, s), o = r.slice(s + 1);
                        (o.startsWith("'") && o.endsWith("'") || o.startsWith('"') && o.endsWith('"')) && (o = o.slice(1, -1)), t.env[Un + i] = o;
                    }
                }
                return {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                };
            }
        }, ME = {
            name: "unalias",
            async execute (e, t) {
                if (_(e)) return F({
                    name: "unalias",
                    summary: "remove alias definitions",
                    usage: "unalias name [name ...]",
                    options: [
                        "-a      remove all aliases",
                        "    --help display this help and exit"
                    ]
                });
                if (e.length === 0) return {
                    stdout: "",
                    stderr: `unalias: usage: unalias [-a] name [name ...]
`,
                    exitCode: 1
                };
                if (e[0] === "-a") {
                    for (let i of Object.keys(t.env))i.startsWith(Un) && delete t.env[i];
                    return {
                        stdout: "",
                        stderr: "",
                        exitCode: 0
                    };
                }
                let n = e[0] === "--" ? e.slice(1) : e, r = false, s = "";
                for (let i of n){
                    let o = Un + i;
                    t.env[o] ? delete t.env[o] : (s += `unalias: ${i}: not found
`, r = true);
                }
                return {
                    stdout: "",
                    stderr: s,
                    exitCode: r ? 1 : 0
                };
            }
        };
    });
    var Cp = {};
    V(Cp, {
        historyCommand: ()=>BE
    });
    var WE, Ap, BE, Np = v(()=>{
        X();
        WE = {
            name: "history",
            summary: "display command history",
            usage: "history [n]",
            options: [
                "-c      clear the history list",
                "    --help display this help and exit"
            ]
        }, Ap = "BASH_HISTORY", BE = {
            name: "history",
            async execute (e, t) {
                if (_(e)) return F(WE);
                let n = t.env[Ap] || "[]", r;
                try {
                    r = JSON.parse(n);
                } catch  {
                    r = [];
                }
                if (e[0] === "-c") return t.env[Ap] = "[]", {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                };
                let s = r.length;
                e[0] && /^\d+$/.test(e[0]) && (s = Math.min(parseInt(e[0], 10), r.length));
                let i = r.length - s, o = "";
                for(let a = i; a < r.length; a++){
                    let l = (a + 1).toString().padStart(5, " ");
                    o += `${l}  ${r[a]}
`;
                }
                return {
                    stdout: o,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var kp = {};
    V(kp, {
        xargsCommand: ()=>zE
    });
    var UE, zE, vp = v(()=>{
        X();
        UE = {
            name: "xargs",
            summary: "build and execute command lines from standard input",
            usage: "xargs [OPTION]... [COMMAND [INITIAL-ARGS]]",
            options: [
                "-I REPLACE   replace occurrences of REPLACE with input",
                "-d DELIM     use DELIM as input delimiter (e.g., -d '\\n' for newline)",
                "-n NUM       use at most NUM arguments per command line",
                "-P NUM       run at most NUM processes at a time",
                "-0, --null   items are separated by null, not whitespace",
                "-t, --verbose  print commands before executing",
                "-r, --no-run-if-empty  do not run command if input is empty",
                "    --help   display this help and exit"
            ]
        }, zE = {
            name: "xargs",
            async execute (e, t) {
                if (_(e)) return F(UE);
                let n = null, r = null, s = null, i = null, o = false, a = false, l = false, c = 0;
                for(let y = 0; y < e.length; y++){
                    let w = e[y];
                    if (w === "-I" && y + 1 < e.length) n = e[++y], c = y + 1;
                    else if (w === "-d" && y + 1 < e.length) r = e[++y].replace(/\\n/g, `
`).replace(/\\t/g, "	").replace(/\\r/g, "\r").replace(/\\0/g, "\0").replace(/\\\\/g, "\\"), c = y + 1;
                    else if (w === "-n" && y + 1 < e.length) s = parseInt(e[++y], 10), c = y + 1;
                    else if (w === "-P" && y + 1 < e.length) i = parseInt(e[++y], 10), c = y + 1;
                    else if (w === "-0" || w === "--null") o = true, c = y + 1;
                    else if (w === "-t" || w === "--verbose") a = true, c = y + 1;
                    else if (w === "-r" || w === "--no-run-if-empty") l = true, c = y + 1;
                    else {
                        if (w.startsWith("--")) return G("xargs", w);
                        if (w.startsWith("-") && w.length > 1) {
                            for (let E of w.slice(1))if (!"0tr".includes(E)) return G("xargs", `-${E}`);
                            w.includes("0") && (o = true), w.includes("t") && (a = true), w.includes("r") && (l = true), c = y + 1;
                        } else if (!w.startsWith("-")) {
                            c = y;
                            break;
                        }
                    }
                }
                let u = e.slice(c);
                u.length === 0 && u.push("echo");
                let f;
                if (o ? f = t.stdin.split("\0").filter((y)=>y.length > 0) : r !== null ? f = t.stdin.replace(/\n$/, "").split(r).filter((w)=>w.length > 0) : f = t.stdin.split(/\s+/).map((y)=>y.trim()).filter((y)=>y.length > 0), f.length === 0) return l ? {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                } : {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                };
                let p = "", d = "", m = 0, h = (y)=>/[\s"'\\$`!*?[\]{}();&|<>#]/.test(y) ? `"${y.replace(/([\\"`$])/g, "\\$1")}"` : y, g = async (y)=>{
                    let w = y.map(h).join(" ");
                    return a && (d += `${w}
`), t.exec ? t.exec(w, {
                        cwd: t.cwd
                    }) : {
                        stdout: `${w}
`,
                        stderr: "",
                        exitCode: 0
                    };
                }, b = async (y)=>{
                    if (i !== null && i > 1) for(let w = 0; w < y.length; w += i){
                        let E = y.slice(w, w + i), C = await Promise.all(E.map(g));
                        for (let A of C)p += A.stdout, d += A.stderr, A.exitCode !== 0 && (m = A.exitCode);
                    }
                    else for (let w of y){
                        let E = await g(w);
                        p += E.stdout, d += E.stderr, E.exitCode !== 0 && (m = E.exitCode);
                    }
                };
                if (n !== null) {
                    let y = f.map((w)=>u.map((E)=>E.replaceAll(n, w)));
                    await b(y);
                } else if (s !== null) {
                    let y = [];
                    for(let w = 0; w < f.length; w += s){
                        let E = f.slice(w, w + s);
                        y.push([
                            ...u,
                            ...E
                        ]);
                    }
                    await b(y);
                } else {
                    let y = [
                        ...u,
                        ...f
                    ], w = await g(y);
                    p += w.stdout, d += w.stderr, m = w.exitCode;
                }
                return {
                    stdout: p,
                    stderr: d,
                    exitCode: m
                };
            }
        };
    });
    var Ao = {};
    V(Ao, {
        falseCommand: ()=>HE,
        trueCommand: ()=>jE
    });
    var jE, HE, Co = v(()=>{
        jE = {
            name: "true",
            async execute () {
                return {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                };
            }
        }, HE = {
            name: "false",
            async execute () {
                return {
                    stdout: "",
                    stderr: "",
                    exitCode: 1
                };
            }
        };
    });
    var $p = {};
    V($p, {
        clearCommand: ()=>qE
    });
    var VE, qE, Ip = v(()=>{
        X();
        VE = {
            name: "clear",
            summary: "clear the terminal screen",
            usage: "clear [OPTIONS]",
            options: [
                "    --help display this help and exit"
            ]
        }, qE = {
            name: "clear",
            async execute (e, t) {
                return _(e) ? F(VE) : {
                    stdout: "\x1B[2J\x1B[H",
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var No = {};
    V(No, {
        bashCommand: ()=>GE,
        shCommand: ()=>ZE
    });
    async function zn(e, t, n, r) {
        if (!r.exec) return {
            stdout: "",
            stderr: `bash: internal error: exec function not available
`,
            exitCode: 1
        };
        let s = {
            ...r.exportedEnv || {},
            0: t,
            "#": String(n.length),
            "@": n.join(" "),
            "*": n.join(" ")
        };
        n.forEach((a, l)=>{
            s[String(l + 1)] = a;
        });
        let i = e;
        if (i.startsWith("#!")) {
            let a = i.indexOf(`
`);
            a !== -1 && (i = i.slice(a + 1));
        }
        return await r.exec(i, {
            env: s,
            cwd: r.cwd
        });
    }
    var Rp, GE, ZE, ko = v(()=>{
        X();
        Rp = {
            name: "bash",
            summary: "execute shell commands or scripts",
            usage: "bash [OPTIONS] [SCRIPT_FILE] [ARGUMENTS...]",
            options: [
                "-c COMMAND  execute COMMAND string",
                "    --help  display this help and exit"
            ],
            notes: [
                "Without -c, reads and executes commands from SCRIPT_FILE.",
                "Arguments are passed as $1, $2, etc. to the script.",
                '$0 is set to the script name (or "bash" with -c).'
            ]
        }, GE = {
            name: "bash",
            async execute (e, t) {
                if (_(e)) return F(Rp);
                if (e[0] === "-c" && e.length >= 2) {
                    let s = e[1], i = e[2] || "bash", o = e.slice(3);
                    return zn(s, i, o, t);
                }
                if (e.length === 0) return t.stdin?.trim() ? zn(t.stdin, "bash", [], t) : {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                };
                let n = e[0], r = e.slice(1);
                try {
                    let s = t.fs.resolvePath(t.cwd, n), i = await t.fs.readFile(s);
                    return zn(i, n, r, t);
                } catch  {
                    return {
                        stdout: "",
                        stderr: `bash: ${n}: No such file or directory
`,
                        exitCode: 127
                    };
                }
            }
        }, ZE = {
            name: "sh",
            async execute (e, t) {
                if (_(e)) return F({
                    ...Rp,
                    name: "sh",
                    summary: "execute shell commands or scripts (POSIX shell)"
                });
                if (e[0] === "-c" && e.length >= 2) {
                    let s = e[1], i = e[2] || "sh", o = e.slice(3);
                    return zn(s, i, o, t);
                }
                if (e.length === 0) return t.stdin?.trim() ? zn(t.stdin, "sh", [], t) : {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                };
                let n = e[0], r = e.slice(1);
                try {
                    let s = t.fs.resolvePath(t.cwd, n), i = await t.fs.readFile(s);
                    return zn(i, n, r, t);
                } catch  {
                    return {
                        stdout: "",
                        stderr: `sh: ${n}: No such file or directory
`,
                        exitCode: 127
                    };
                }
            }
        };
    });
    function vo(e, t, n, r, s, i, o, a, l, c) {
        switch(t){
            case "sort":
                return Array.isArray(e) ? [
                    [
                        ...e
                    ].sort(o)
                ] : [
                    null
                ];
            case "sort_by":
                return !Array.isArray(e) || n.length === 0 ? [
                    null
                ] : [
                    [
                        ...e
                    ].sort((f, p)=>{
                        let d = s(f, n[0], r)[0], m = s(p, n[0], r)[0];
                        return o(d, m);
                    })
                ];
            case "bsearch":
                {
                    if (!Array.isArray(e)) {
                        let f = e === null ? "null" : typeof e == "object" ? "object" : typeof e;
                        throw new Error(`${f} (${JSON.stringify(e)}) cannot be searched from`);
                    }
                    return n.length === 0 ? [
                        null
                    ] : s(e, n[0], r).map((f)=>{
                        let p = 0, d = e.length;
                        for(; p < d;){
                            let m = p + d >>> 1;
                            o(e[m], f) < 0 ? p = m + 1 : d = m;
                        }
                        return p < e.length && o(e[p], f) === 0 ? p : -p - 1;
                    });
                }
            case "unique_by":
                {
                    if (!Array.isArray(e) || n.length === 0) return [
                        null
                    ];
                    let u = new Map();
                    for (let p of e){
                        let d = s(p, n[0], r)[0], m = JSON.stringify(d);
                        u.has(m) || u.set(m, {
                            item: p,
                            key: d
                        });
                    }
                    let f = [
                        ...u.values()
                    ];
                    return f.sort((p, d)=>o(p.key, d.key)), [
                        f.map((p)=>p.item)
                    ];
                }
            case "group_by":
                {
                    if (!Array.isArray(e) || n.length === 0) return [
                        null
                    ];
                    let u = new Map();
                    for (let f of e){
                        let p = JSON.stringify(s(f, n[0], r)[0]);
                        u.has(p) || u.set(p, []), u.get(p)?.push(f);
                    }
                    return [
                        [
                            ...u.values()
                        ]
                    ];
                }
            case "max":
                return Array.isArray(e) && e.length > 0 ? [
                    e.reduce((u, f)=>o(u, f) > 0 ? u : f)
                ] : [
                    null
                ];
            case "max_by":
                return !Array.isArray(e) || e.length === 0 || n.length === 0 ? [
                    null
                ] : [
                    e.reduce((u, f)=>{
                        let p = s(u, n[0], r)[0], d = s(f, n[0], r)[0];
                        return o(p, d) > 0 ? u : f;
                    })
                ];
            case "min":
                return Array.isArray(e) && e.length > 0 ? [
                    e.reduce((u, f)=>o(u, f) < 0 ? u : f)
                ] : [
                    null
                ];
            case "min_by":
                return !Array.isArray(e) || e.length === 0 || n.length === 0 ? [
                    null
                ] : [
                    e.reduce((u, f)=>{
                        let p = s(u, n[0], r)[0], d = s(f, n[0], r)[0];
                        return o(p, d) < 0 ? u : f;
                    })
                ];
            case "add":
                {
                    let u = (f)=>{
                        let p = f.filter((d)=>d !== null);
                        return p.length === 0 ? null : p.every((d)=>typeof d == "number") ? p.reduce((d, m)=>d + m, 0) : p.every((d)=>typeof d == "string") ? p.join("") : p.every((d)=>Array.isArray(d)) ? p.flat() : p.every((d)=>d && typeof d == "object" && !Array.isArray(d)) ? Object.assign({}, ...p) : null;
                    };
                    if (n.length >= 1) {
                        let f = s(e, n[0], r);
                        return [
                            u(f)
                        ];
                    }
                    return Array.isArray(e) ? [
                        u(e)
                    ] : [
                        null
                    ];
                }
            case "any":
                {
                    if (n.length >= 2) {
                        try {
                            let u = i(e, n[0], r);
                            for (let f of u)if (s(f, n[1], r).some(a)) return [
                                true
                            ];
                        } catch (u) {
                            if (u instanceof c) throw u;
                        }
                        return [
                            false
                        ];
                    }
                    return n.length === 1 ? Array.isArray(e) ? [
                        e.some((u)=>a(s(u, n[0], r)[0]))
                    ] : [
                        false
                    ] : Array.isArray(e) ? [
                        e.some(a)
                    ] : [
                        false
                    ];
                }
            case "all":
                {
                    if (n.length >= 2) {
                        try {
                            let u = i(e, n[0], r);
                            for (let f of u)if (!s(f, n[1], r).some(a)) return [
                                false
                            ];
                        } catch (u) {
                            if (u instanceof c) throw u;
                        }
                        return [
                            true
                        ];
                    }
                    return n.length === 1 ? Array.isArray(e) ? [
                        e.every((u)=>a(s(u, n[0], r)[0]))
                    ] : [
                        true
                    ] : Array.isArray(e) ? [
                        e.every(a)
                    ] : [
                        true
                    ];
                }
            case "select":
                return n.length === 0 ? [
                    e
                ] : s(e, n[0], r).some(a) ? [
                    e
                ] : [];
            case "map":
                return n.length === 0 || !Array.isArray(e) ? [
                    null
                ] : [
                    e.flatMap((f)=>s(f, n[0], r))
                ];
            case "map_values":
                {
                    if (n.length === 0) return [
                        null
                    ];
                    if (Array.isArray(e)) return [
                        e.flatMap((u)=>s(u, n[0], r))
                    ];
                    if (e && typeof e == "object") {
                        let u = {};
                        for (let [f, p] of Object.entries(e)){
                            let d = s(p, n[0], r);
                            d.length > 0 && (u[f] = d[0]);
                        }
                        return [
                            u
                        ];
                    }
                    return [
                        null
                    ];
                }
            case "has":
                {
                    if (n.length === 0) return [
                        false
                    ];
                    let f = s(e, n[0], r)[0];
                    return Array.isArray(e) && typeof f == "number" ? [
                        f >= 0 && f < e.length
                    ] : e && typeof e == "object" && typeof f == "string" ? [
                        f in e
                    ] : [
                        false
                    ];
                }
            case "in":
                {
                    if (n.length === 0) return [
                        false
                    ];
                    let f = s(e, n[0], r)[0];
                    return Array.isArray(f) && typeof e == "number" ? [
                        e >= 0 && e < f.length
                    ] : f && typeof f == "object" && typeof e == "string" ? [
                        e in f
                    ] : [
                        false
                    ];
                }
            case "contains":
                {
                    if (n.length === 0) return [
                        false
                    ];
                    let u = s(e, n[0], r);
                    return [
                        l(e, u[0])
                    ];
                }
            case "inside":
                {
                    if (n.length === 0) return [
                        false
                    ];
                    let u = s(e, n[0], r);
                    return [
                        l(u[0], e)
                    ];
                }
            default:
                return null;
        }
    }
    var Pp = v(()=>{});
    function $o(e, t, n, r, s, i, o, a) {
        switch(t){
            case "first":
                if (n.length > 0) try {
                    let l = i(e, n[0], r);
                    return l.length > 0 ? [
                        l[0]
                    ] : [];
                } catch (l) {
                    if (l instanceof a) throw l;
                    return [];
                }
                return Array.isArray(e) && e.length > 0 ? [
                    e[0]
                ] : [
                    null
                ];
            case "last":
                if (n.length > 0) {
                    let l = s(e, n[0], r);
                    return l.length > 0 ? [
                        l[l.length - 1]
                    ] : [];
                }
                return Array.isArray(e) && e.length > 0 ? [
                    e[e.length - 1]
                ] : [
                    null
                ];
            case "nth":
                {
                    if (n.length < 1) return [
                        null
                    ];
                    let l = s(e, n[0], r);
                    if (n.length > 1) {
                        for (let u of l)if (u < 0) throw new Error("nth doesn't support negative indices");
                        let c;
                        try {
                            c = i(e, n[1], r);
                        } catch (u) {
                            if (u instanceof a) throw u;
                            c = [];
                        }
                        return l.flatMap((u)=>{
                            let f = u;
                            return f < c.length ? [
                                c[f]
                            ] : [];
                        });
                    }
                    return Array.isArray(e) ? l.flatMap((c)=>{
                        let u = c;
                        if (u < 0) throw new Error("nth doesn't support negative indices");
                        return u < e.length ? [
                            e[u]
                        ] : [
                            null
                        ];
                    }) : [
                        null
                    ];
                }
            case "range":
                {
                    if (n.length === 0) return [];
                    let l = s(e, n[0], r);
                    if (n.length === 1) {
                        let p = [];
                        for (let d of l){
                            let m = d;
                            for(let h = 0; h < m; h++)p.push(h);
                        }
                        return p;
                    }
                    let c = s(e, n[1], r);
                    if (n.length === 2) {
                        let p = [];
                        for (let d of l)for (let m of c){
                            let h = d, g = m;
                            for(let b = h; b < g; b++)p.push(b);
                        }
                        return p;
                    }
                    let u = s(e, n[2], r), f = [];
                    for (let p of l)for (let d of c)for (let m of u){
                        let h = p, g = d, b = m;
                        if (b !== 0) if (b > 0) for(let y = h; y < g; y += b)f.push(y);
                        else for(let y = h; y > g; y += b)f.push(y);
                    }
                    return f;
                }
            case "limit":
                return n.length < 2 ? [] : s(e, n[0], r).flatMap((c)=>{
                    let u = c;
                    if (u < 0) throw new Error("limit doesn't support negative count");
                    if (u === 0) return [];
                    let f;
                    try {
                        f = i(e, n[1], r);
                    } catch (p) {
                        if (p instanceof a) throw p;
                        f = [];
                    }
                    return f.slice(0, u);
                });
            case "isempty":
                {
                    if (n.length < 1) return [
                        true
                    ];
                    try {
                        return [
                            i(e, n[0], r).length === 0
                        ];
                    } catch (l) {
                        if (l instanceof a) throw l;
                        return [
                            true
                        ];
                    }
                }
            case "isvalid":
                {
                    if (n.length < 1) return [
                        true
                    ];
                    try {
                        return [
                            s(e, n[0], r).length > 0
                        ];
                    } catch (l) {
                        if (l instanceof a) throw l;
                        return [
                            false
                        ];
                    }
                }
            case "skip":
                return n.length < 2 ? [] : s(e, n[0], r).flatMap((c)=>{
                    let u = c;
                    if (u < 0) throw new Error("skip doesn't support negative count");
                    return s(e, n[1], r).slice(u);
                });
            case "until":
                {
                    if (n.length < 2) return [
                        e
                    ];
                    let l = e, c = r.limits.maxIterations;
                    for(let u = 0; u < c; u++){
                        if (s(l, n[0], r).some(o)) return [
                            l
                        ];
                        let p = s(l, n[1], r);
                        if (p.length === 0) return [
                            l
                        ];
                        l = p[0];
                    }
                    throw new a(`jq until: too many iterations (${c}), increase executionLimits.maxJqIterations`, "iterations");
                }
            case "while":
                {
                    if (n.length < 2) return [
                        e
                    ];
                    let l = [], c = e, u = r.limits.maxIterations;
                    for(let f = 0; f < u && s(c, n[0], r).some(o); f++){
                        l.push(c);
                        let d = s(c, n[1], r);
                        if (d.length === 0) break;
                        c = d[0];
                    }
                    if (l.length >= u) throw new a(`jq while: too many iterations (${u}), increase executionLimits.maxJqIterations`, "iterations");
                    return l;
                }
            case "repeat":
                {
                    if (n.length === 0) return [
                        e
                    ];
                    let l = [], c = e, u = r.limits.maxIterations;
                    for(let f = 0; f < u; f++){
                        l.push(c);
                        let p = s(c, n[0], r);
                        if (p.length === 0) break;
                        c = p[0];
                    }
                    if (l.length >= u) throw new a(`jq repeat: too many iterations (${u}), increase executionLimits.maxJqIterations`, "iterations");
                    return l;
                }
            default:
                return null;
        }
    }
    var Tp = v(()=>{});
    function Io(e, t, n, r, s) {
        switch(t){
            case "now":
                return [
                    Date.now() / 1e3
                ];
            case "gmtime":
                {
                    if (typeof e != "number") return [
                        null
                    ];
                    let i = new Date(e * 1e3), o = i.getUTCFullYear(), a = i.getUTCMonth(), l = i.getUTCDate(), c = i.getUTCHours(), u = i.getUTCMinutes(), f = i.getUTCSeconds(), p = i.getUTCDay(), d = Date.UTC(o, 0, 1), m = Math.floor((i.getTime() - d) / (1440 * 60 * 1e3));
                    return [
                        [
                            o,
                            a,
                            l,
                            c,
                            u,
                            f,
                            p,
                            m
                        ]
                    ];
                }
            case "mktime":
                {
                    if (!Array.isArray(e)) throw new Error("mktime requires parsed datetime inputs");
                    let [i, o, a, l = 0, c = 0, u = 0] = e;
                    if (typeof i != "number" || typeof o != "number") throw new Error("mktime requires parsed datetime inputs");
                    let f = Date.UTC(i, o, a ?? 1, l ?? 0, c ?? 0, u ?? 0);
                    return [
                        Math.floor(f / 1e3)
                    ];
                }
            case "strftime":
                {
                    if (n.length === 0) return [
                        null
                    ];
                    let o = s(e, n[0], r)[0];
                    if (typeof o != "string") throw new Error("strftime/1 requires a string format");
                    let a;
                    if (typeof e == "number") a = new Date(e * 1e3);
                    else if (Array.isArray(e)) {
                        let [p, d, m, h = 0, g = 0, b = 0] = e;
                        if (typeof p != "number" || typeof d != "number") throw new Error("strftime/1 requires parsed datetime inputs");
                        a = new Date(Date.UTC(p, d, m ?? 1, h ?? 0, g ?? 0, b ?? 0));
                    } else throw new Error("strftime/1 requires parsed datetime inputs");
                    let l = [
                        "Sunday",
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday"
                    ], c = [
                        "January",
                        "February",
                        "March",
                        "April",
                        "May",
                        "June",
                        "July",
                        "August",
                        "September",
                        "October",
                        "November",
                        "December"
                    ], u = (p, d = 2)=>String(p).padStart(d, "0");
                    return [
                        o.replace(/%Y/g, String(a.getUTCFullYear())).replace(/%m/g, u(a.getUTCMonth() + 1)).replace(/%d/g, u(a.getUTCDate())).replace(/%H/g, u(a.getUTCHours())).replace(/%M/g, u(a.getUTCMinutes())).replace(/%S/g, u(a.getUTCSeconds())).replace(/%A/g, l[a.getUTCDay()]).replace(/%B/g, c[a.getUTCMonth()]).replace(/%Z/g, "UTC").replace(/%%/g, "%")
                    ];
                }
            case "strptime":
                {
                    if (n.length === 0) return [
                        null
                    ];
                    if (typeof e != "string") throw new Error("strptime/1 requires a string input");
                    let o = s(e, n[0], r)[0];
                    if (typeof o != "string") throw new Error("strptime/1 requires a string format");
                    if (o === "%Y-%m-%dT%H:%M:%SZ") {
                        let l = e.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})Z$/);
                        if (l) {
                            let [, c, u, f, p, d, m] = l.map(Number), h = new Date(Date.UTC(c, u - 1, f, p, d, m)), g = h.getUTCDay(), b = Date.UTC(c, 0, 1), y = Math.floor((h.getTime() - b) / (1440 * 60 * 1e3));
                            return [
                                [
                                    c,
                                    u - 1,
                                    f,
                                    p,
                                    d,
                                    m,
                                    g,
                                    y
                                ]
                            ];
                        }
                    }
                    let a = new Date(e);
                    if (!Number.isNaN(a.getTime())) {
                        let l = a.getUTCFullYear(), c = a.getUTCMonth(), u = a.getUTCDate(), f = a.getUTCHours(), p = a.getUTCMinutes(), d = a.getUTCSeconds(), m = a.getUTCDay(), h = Date.UTC(l, 0, 1), g = Math.floor((a.getTime() - h) / (1440 * 60 * 1e3));
                        return [
                            [
                                l,
                                c,
                                u,
                                f,
                                p,
                                d,
                                m,
                                g
                            ]
                        ];
                    }
                    throw new Error(`Cannot parse date: ${e}`);
                }
            case "fromdate":
                {
                    if (typeof e != "string") throw new Error("fromdate requires a string input");
                    let i = new Date(e);
                    if (Number.isNaN(i.getTime())) throw new Error(`date "${e}" does not match format "%Y-%m-%dT%H:%M:%SZ"`);
                    return [
                        Math.floor(i.getTime() / 1e3)
                    ];
                }
            case "todate":
                {
                    if (typeof e != "number") throw new Error("todate requires a number input");
                    return [
                        new Date(e * 1e3).toISOString().replace(/\.\d{3}Z$/, "Z")
                    ];
                }
            default:
                return null;
        }
    }
    var Op = v(()=>{});
    function vt(e) {
        return e !== false && e !== null;
    }
    function jn(e, t) {
        return JSON.stringify(e) === JSON.stringify(t);
    }
    function Nr(e, t) {
        return typeof e == "number" && typeof t == "number" ? e - t : typeof e == "string" && typeof t == "string" ? e.localeCompare(t) : 0;
    }
    function Ro(e, t) {
        let n = {
            ...e
        };
        for (let r of Object.keys(t))r in n && n[r] && typeof n[r] == "object" && !Array.isArray(n[r]) && t[r] && typeof t[r] == "object" && !Array.isArray(t[r]) ? n[r] = Ro(n[r], t[r]) : n[r] = t[r];
        return n;
    }
    function Hn(e, t = 3e3) {
        let n = 0, r = e;
        for(; n < t;)if (Array.isArray(r)) {
            if (r.length === 0) return n + 1;
            r = r[0], n++;
        } else if (r !== null && typeof r == "object") {
            let s = Object.keys(r);
            if (s.length === 0) return n + 1;
            r = r[s[0]], n++;
        } else return n;
        return n;
    }
    function Cs(e, t) {
        let n = (i)=>i === null ? 0 : typeof i == "boolean" ? 1 : typeof i == "number" ? 2 : typeof i == "string" ? 3 : Array.isArray(i) ? 4 : typeof i == "object" ? 5 : 6, r = n(e), s = n(t);
        if (r !== s) return r - s;
        if (typeof e == "number" && typeof t == "number") return e - t;
        if (typeof e == "string" && typeof t == "string") return e.localeCompare(t);
        if (typeof e == "boolean" && typeof t == "boolean") return (e ? 1 : 0) - (t ? 1 : 0);
        if (Array.isArray(e) && Array.isArray(t)) {
            for(let i = 0; i < Math.min(e.length, t.length); i++){
                let o = Cs(e[i], t[i]);
                if (o !== 0) return o;
            }
            return e.length - t.length;
        }
        if (e && t && typeof e == "object" && typeof t == "object") {
            let i = e, o = t, a = Object.keys(i).sort(), l = Object.keys(o).sort();
            for(let c = 0; c < Math.min(a.length, l.length); c++){
                let u = a[c].localeCompare(l[c]);
                if (u !== 0) return u;
            }
            if (a.length !== l.length) return a.length - l.length;
            for (let c of a){
                let u = Cs(i[c], o[c]);
                if (u !== 0) return u;
            }
        }
        return 0;
    }
    function Ns(e, t) {
        if (jn(e, t)) return true;
        if (typeof e == "string" && typeof t == "string") return e.includes(t);
        if (Array.isArray(e) && Array.isArray(t)) return t.every((n)=>e.some((r)=>Ns(r, n)));
        if (e && t && typeof e == "object" && typeof t == "object" && !Array.isArray(e) && !Array.isArray(t)) {
            let n = e, r = t;
            return Object.keys(r).every((s)=>s in n && Ns(n[s], r[s]));
        }
        return false;
    }
    var ks = v(()=>{});
    function Po(e, t, n) {
        switch(t){
            case "@base64":
                return typeof e == "string" ? typeof Buffer < "u" ? [
                    Buffer.from(e, "utf-8").toString("base64")
                ] : [
                    btoa(e)
                ] : [
                    null
                ];
            case "@base64d":
                return typeof e == "string" ? typeof Buffer < "u" ? [
                    Buffer.from(e, "base64").toString("utf-8")
                ] : [
                    atob(e)
                ] : [
                    null
                ];
            case "@uri":
                return typeof e == "string" ? [
                    encodeURIComponent(e).replace(/!/g, "%21").replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A")
                ] : [
                    null
                ];
            case "@urid":
                return typeof e == "string" ? [
                    decodeURIComponent(e)
                ] : [
                    null
                ];
            case "@csv":
                return Array.isArray(e) ? [
                    e.map((s)=>{
                        if (s === null) return "";
                        if (typeof s == "boolean") return s ? "true" : "false";
                        if (typeof s == "number") return String(s);
                        let i = String(s);
                        return i.includes(",") || i.includes('"') || i.includes(`
`) || i.includes("\r") ? `"${i.replace(/"/g, '""')}"` : i;
                    }).join(",")
                ] : [
                    null
                ];
            case "@tsv":
                return Array.isArray(e) ? [
                    e.map((r)=>String(r ?? "").replace(/\t/g, "\\t").replace(/\n/g, "\\n")).join("	")
                ] : [
                    null
                ];
            case "@json":
                {
                    let r = n ?? QE;
                    return Hn(e, r + 1) > r ? [
                        null
                    ] : [
                        JSON.stringify(e)
                    ];
                }
            case "@html":
                return typeof e == "string" ? [
                    e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;")
                ] : [
                    null
                ];
            case "@sh":
                return typeof e == "string" ? [
                    `'${e.replace(/'/g, "'\\''")}'`
                ] : [
                    null
                ];
            case "@text":
                return typeof e == "string" ? [
                    e
                ] : e == null ? [
                    ""
                ] : [
                    String(e)
                ];
            default:
                return null;
        }
    }
    var QE, Dp = v(()=>{
        ks();
        QE = 2e3;
    });
    function To(e, t, n, r, s, i) {
        switch(t){
            case "index":
                return n.length === 0 ? [
                    null
                ] : s(e, n[0], r).map((a)=>{
                    if (typeof e == "string" && typeof a == "string") {
                        if (a === "" && e === "") return null;
                        let l = e.indexOf(a);
                        return l >= 0 ? l : null;
                    }
                    if (Array.isArray(e)) {
                        if (Array.isArray(a)) {
                            for(let c = 0; c <= e.length - a.length; c++){
                                let u = true;
                                for(let f = 0; f < a.length; f++)if (!i(e[c + f], a[f])) {
                                    u = false;
                                    break;
                                }
                                if (u) return c;
                            }
                            return null;
                        }
                        let l = e.findIndex((c)=>i(c, a));
                        return l >= 0 ? l : null;
                    }
                    return null;
                });
            case "rindex":
                return n.length === 0 ? [
                    null
                ] : s(e, n[0], r).map((a)=>{
                    if (typeof e == "string" && typeof a == "string") {
                        let l = e.lastIndexOf(a);
                        return l >= 0 ? l : null;
                    }
                    if (Array.isArray(e)) {
                        if (Array.isArray(a)) {
                            for(let l = e.length - a.length; l >= 0; l--){
                                let c = true;
                                for(let u = 0; u < a.length; u++)if (!i(e[l + u], a[u])) {
                                    c = false;
                                    break;
                                }
                                if (c) return l;
                            }
                            return null;
                        }
                        for(let l = e.length - 1; l >= 0; l--)if (i(e[l], a)) return l;
                        return null;
                    }
                    return null;
                });
            case "indices":
                return n.length === 0 ? [
                    []
                ] : s(e, n[0], r).map((a)=>{
                    let l = [];
                    if (typeof e == "string" && typeof a == "string") {
                        let c = e.indexOf(a);
                        for(; c !== -1;)l.push(c), c = e.indexOf(a, c + 1);
                    } else if (Array.isArray(e)) if (Array.isArray(a)) {
                        let c = a.length;
                        if (c === 0) for(let u = 0; u <= e.length; u++)l.push(u);
                        else for(let u = 0; u <= e.length - c; u++){
                            let f = true;
                            for(let p = 0; p < c; p++)if (!i(e[u + p], a[p])) {
                                f = false;
                                break;
                            }
                            f && l.push(u);
                        }
                    } else for(let c = 0; c < e.length; c++)i(e[c], a) && l.push(c);
                    return l;
                });
            default:
                return null;
        }
    }
    var Fp = v(()=>{});
    function Oo(e, t, n, r, s) {
        switch(t){
            case "fabs":
            case "abs":
                return typeof e == "number" ? [
                    Math.abs(e)
                ] : typeof e == "string" ? [
                    e
                ] : [
                    null
                ];
            case "exp10":
                return typeof e == "number" ? [
                    10 ** e
                ] : [
                    null
                ];
            case "exp2":
                return typeof e == "number" ? [
                    2 ** e
                ] : [
                    null
                ];
            case "pow":
                {
                    if (n.length < 2) return [
                        null
                    ];
                    let i = s(e, n[0], r), o = s(e, n[1], r), a = i[0], l = o[0];
                    return typeof a != "number" || typeof l != "number" ? [
                        null
                    ] : [
                        a ** l
                    ];
                }
            case "atan2":
                {
                    if (n.length < 2) return [
                        null
                    ];
                    let i = s(e, n[0], r), o = s(e, n[1], r), a = i[0], l = o[0];
                    return typeof a != "number" || typeof l != "number" ? [
                        null
                    ] : [
                        Math.atan2(a, l)
                    ];
                }
            case "hypot":
                {
                    if (typeof e != "number" || n.length === 0) return [
                        null
                    ];
                    let i = s(e, n[0], r)[0];
                    return [
                        Math.hypot(e, i)
                    ];
                }
            case "fma":
                {
                    if (typeof e != "number" || n.length < 2) return [
                        null
                    ];
                    let i = s(e, n[0], r)[0], o = s(e, n[1], r)[0];
                    return [
                        e * i + o
                    ];
                }
            case "copysign":
                {
                    if (typeof e != "number" || n.length === 0) return [
                        null
                    ];
                    let i = s(e, n[0], r)[0];
                    return [
                        Math.sign(i) * Math.abs(e)
                    ];
                }
            case "drem":
            case "remainder":
                {
                    if (typeof e != "number" || n.length === 0) return [
                        null
                    ];
                    let i = s(e, n[0], r)[0];
                    return [
                        e - Math.round(e / i) * i
                    ];
                }
            case "fdim":
                {
                    if (typeof e != "number" || n.length === 0) return [
                        null
                    ];
                    let i = s(e, n[0], r)[0];
                    return [
                        Math.max(0, e - i)
                    ];
                }
            case "fmax":
                {
                    if (typeof e != "number" || n.length === 0) return [
                        null
                    ];
                    let i = s(e, n[0], r)[0];
                    return [
                        Math.max(e, i)
                    ];
                }
            case "fmin":
                {
                    if (typeof e != "number" || n.length === 0) return [
                        null
                    ];
                    let i = s(e, n[0], r)[0];
                    return [
                        Math.min(e, i)
                    ];
                }
            case "ldexp":
                {
                    if (typeof e != "number" || n.length === 0) return [
                        null
                    ];
                    let i = s(e, n[0], r)[0];
                    return [
                        e * 2 ** i
                    ];
                }
            case "scalbn":
            case "scalbln":
                {
                    if (typeof e != "number" || n.length === 0) return [
                        null
                    ];
                    let i = s(e, n[0], r)[0];
                    return [
                        e * 2 ** i
                    ];
                }
            case "nearbyint":
                return typeof e == "number" ? [
                    Math.round(e)
                ] : [
                    null
                ];
            case "logb":
                return typeof e == "number" ? [
                    Math.floor(Math.log2(Math.abs(e)))
                ] : [
                    null
                ];
            case "significand":
                if (typeof e == "number") {
                    let i = Math.floor(Math.log2(Math.abs(e)));
                    return [
                        e / 2 ** i
                    ];
                }
                return [
                    null
                ];
            case "frexp":
                if (typeof e == "number") {
                    if (e === 0) return [
                        [
                            0,
                            0
                        ]
                    ];
                    let i = Math.floor(Math.log2(Math.abs(e))) + 1;
                    return [
                        [
                            e / 2 ** i,
                            i
                        ]
                    ];
                }
                return [
                    null
                ];
            case "modf":
                if (typeof e == "number") {
                    let i = Math.trunc(e);
                    return [
                        [
                            e - i,
                            i
                        ]
                    ];
                }
                return [
                    null
                ];
            default:
                return null;
        }
    }
    var _p = v(()=>{});
    function Do(e, t, n, r, s, i, o, a) {
        switch(t){
            case "recurse":
                {
                    if (n.length === 0) {
                        let d = [], m = (h)=>{
                            if (d.push(h), Array.isArray(h)) for (let g of h)m(g);
                            else if (h && typeof h == "object") for (let g of Object.keys(h))m(h[g]);
                        };
                        return m(e), d;
                    }
                    let l = [], c = n.length >= 2 ? n[1] : null, u = 1e4, f = 0, p = (d)=>{
                        if (f++ > u || c && !s(d, c, r).some(i)) return;
                        l.push(d);
                        let m = s(d, n[0], r);
                        for (let h of m)h != null && p(h);
                    };
                    return p(e), l;
                }
            case "recurse_down":
                return a(e, "recurse", n, r);
            case "walk":
                {
                    if (n.length === 0) return [
                        e
                    ];
                    let l = new WeakSet(), c = (u)=>{
                        if (u && typeof u == "object") {
                            if (l.has(u)) return u;
                            l.add(u);
                        }
                        let f;
                        if (Array.isArray(u)) f = u.map(c);
                        else if (u && typeof u == "object") {
                            let d = {};
                            for (let [m, h] of Object.entries(u))d[m] = c(h);
                            f = d;
                        } else f = u;
                        return s(f, n[0], r)[0];
                    };
                    return [
                        c(e)
                    ];
                }
            case "transpose":
                {
                    if (!Array.isArray(e)) return [
                        null
                    ];
                    if (e.length === 0) return [
                        []
                    ];
                    let l = Math.max(...e.map((u)=>Array.isArray(u) ? u.length : 0)), c = [];
                    for(let u = 0; u < l; u++)c.push(e.map((f)=>Array.isArray(f) ? f[u] : null));
                    return [
                        c
                    ];
                }
            case "combinations":
                {
                    if (n.length > 0) {
                        let f = s(e, n[0], r)[0];
                        if (!Array.isArray(e) || f < 0) return [];
                        if (f === 0) return [
                            []
                        ];
                        let p = [], d = (m, h)=>{
                            if (h === f) {
                                p.push([
                                    ...m
                                ]);
                                return;
                            }
                            for (let g of e)m.push(g), d(m, h + 1), m.pop();
                        };
                        return d([], 0), p;
                    }
                    if (!Array.isArray(e)) return [];
                    if (e.length === 0) return [
                        []
                    ];
                    for (let u of e)if (!Array.isArray(u)) return [];
                    let l = [], c = (u, f)=>{
                        if (u === e.length) {
                            l.push([
                                ...f
                            ]);
                            return;
                        }
                        let p = e[u];
                        for (let d of p)f.push(d), c(u + 1, f), f.pop();
                    };
                    return c(0, []), l;
                }
            case "parent":
                {
                    if (r.root === void 0 || r.currentPath === void 0) return [];
                    let l = r.currentPath;
                    if (l.length === 0) return [];
                    let c = n.length > 0 ? s(e, n[0], r)[0] : 1;
                    if (c >= 0) {
                        if (c > l.length) return [];
                        let u = l.slice(0, l.length - c);
                        return [
                            o(r.root, u)
                        ];
                    } else {
                        let u = -c - 1;
                        if (u >= l.length) return [
                            e
                        ];
                        let f = l.slice(0, u);
                        return [
                            o(r.root, f)
                        ];
                    }
                }
            case "parents":
                {
                    if (r.root === void 0 || r.currentPath === void 0) return [
                        []
                    ];
                    let l = r.currentPath, c = [];
                    for(let u = l.length - 1; u >= 0; u--)c.push(o(r.root, l.slice(0, u)));
                    return [
                        c
                    ];
                }
            case "root":
                return r.root !== void 0 ? [
                    r.root
                ] : [];
            default:
                return null;
        }
    }
    var Lp = v(()=>{});
    function Fo(e, t, n, r, s) {
        switch(t){
            case "keys":
                return Array.isArray(e) ? [
                    e.map((i, o)=>o)
                ] : e && typeof e == "object" ? [
                    Object.keys(e).sort()
                ] : [
                    null
                ];
            case "keys_unsorted":
                return Array.isArray(e) ? [
                    e.map((i, o)=>o)
                ] : e && typeof e == "object" ? [
                    Object.keys(e)
                ] : [
                    null
                ];
            case "length":
                return typeof e == "string" ? [
                    e.length
                ] : Array.isArray(e) ? [
                    e.length
                ] : e && typeof e == "object" ? [
                    Object.keys(e).length
                ] : e === null ? [
                    0
                ] : typeof e == "number" ? [
                    Math.abs(e)
                ] : [
                    null
                ];
            case "utf8bytelength":
                {
                    if (typeof e == "string") return [
                        new TextEncoder().encode(e).length
                    ];
                    let i = e === null ? "null" : Array.isArray(e) ? "array" : typeof e, o = i === "array" || i === "object" ? JSON.stringify(e) : String(e);
                    throw new Error(`${i} (${o}) only strings have UTF-8 byte length`);
                }
            case "to_entries":
                return e && typeof e == "object" && !Array.isArray(e) ? [
                    Object.entries(e).map(([i, o])=>({
                            key: i,
                            value: o
                        }))
                ] : [
                    null
                ];
            case "from_entries":
                if (Array.isArray(e)) {
                    let i = {};
                    for (let o of e)if (o && typeof o == "object") {
                        let a = o, l = a.key ?? a.Key ?? a.name ?? a.Name ?? a.k, c = a.value ?? a.Value ?? a.v;
                        l !== void 0 && (i[String(l)] = c);
                    }
                    return [
                        i
                    ];
                }
                return [
                    null
                ];
            case "with_entries":
                {
                    if (n.length === 0) return [
                        e
                    ];
                    if (e && typeof e == "object" && !Array.isArray(e)) {
                        let o = Object.entries(e).map(([l, c])=>({
                                key: l,
                                value: c
                            })).flatMap((l)=>s(l, n[0], r)), a = {};
                        for (let l of o)if (l && typeof l == "object") {
                            let c = l, u = c.key ?? c.name ?? c.k, f = c.value ?? c.v;
                            u !== void 0 && (a[String(u)] = f);
                        }
                        return [
                            a
                        ];
                    }
                    return [
                        null
                    ];
                }
            case "reverse":
                return Array.isArray(e) ? [
                    [
                        ...e
                    ].reverse()
                ] : typeof e == "string" ? [
                    e.split("").reverse().join("")
                ] : [
                    null
                ];
            case "flatten":
                return Array.isArray(e) ? (n.length > 0 ? s(e, n[0], r) : [
                    Number.POSITIVE_INFINITY
                ]).map((o)=>{
                    let a = o;
                    if (a < 0) throw new Error("flatten depth must not be negative");
                    return e.flat(a);
                }) : [
                    null
                ];
            case "unique":
                if (Array.isArray(e)) {
                    let i = new Set(), o = [];
                    for (let a of e){
                        let l = JSON.stringify(a);
                        i.has(l) || (i.add(l), o.push(a));
                    }
                    return [
                        o
                    ];
                }
                return [
                    null
                ];
            case "tojson":
            case "tojsonstream":
                {
                    let i = r.limits.maxDepth ?? KE;
                    return Hn(e, i + 1) > i ? [
                        null
                    ] : [
                        JSON.stringify(e)
                    ];
                }
            case "fromjson":
                {
                    if (typeof e == "string") {
                        let i = e.trim().toLowerCase();
                        if (i === "nan") return [
                            Number.NaN
                        ];
                        if (i === "inf" || i === "infinity") return [
                            Number.POSITIVE_INFINITY
                        ];
                        if (i === "-inf" || i === "-infinity") return [
                            Number.NEGATIVE_INFINITY
                        ];
                        try {
                            return [
                                JSON.parse(e)
                            ];
                        } catch  {
                            throw new Error(`Invalid JSON: ${e}`);
                        }
                    }
                    return [
                        e
                    ];
                }
            case "tostring":
                return typeof e == "string" ? [
                    e
                ] : [
                    JSON.stringify(e)
                ];
            case "tonumber":
                if (typeof e == "number") return [
                    e
                ];
                if (typeof e == "string") {
                    let i = Number(e);
                    if (Number.isNaN(i)) throw new Error(`${JSON.stringify(e)} cannot be parsed as a number`);
                    return [
                        i
                    ];
                }
                throw new Error(`${typeof e} cannot be parsed as a number`);
            case "toboolean":
                {
                    if (typeof e == "boolean") return [
                        e
                    ];
                    if (typeof e == "string") {
                        if (e === "true") return [
                            true
                        ];
                        if (e === "false") return [
                            false
                        ];
                        throw new Error(`string (${JSON.stringify(e)}) cannot be parsed as a boolean`);
                    }
                    let i = e === null ? "null" : Array.isArray(e) ? "array" : typeof e, o = i === "array" || i === "object" ? JSON.stringify(e) : String(e);
                    throw new Error(`${i} (${o}) cannot be parsed as a boolean`);
                }
            case "tostream":
                {
                    let i = [], o = (a, l)=>{
                        if (a === null || typeof a != "object") i.push([
                            l,
                            a
                        ]);
                        else if (Array.isArray(a)) if (a.length === 0) i.push([
                            l,
                            []
                        ]);
                        else for(let c = 0; c < a.length; c++)o(a[c], [
                            ...l,
                            c
                        ]);
                        else {
                            let c = Object.keys(a);
                            if (c.length === 0) i.push([
                                l,
                                {}
                            ]);
                            else for (let u of c)o(a[u], [
                                ...l,
                                u
                            ]);
                        }
                    };
                    return o(e, []), i.push([
                        []
                    ]), i;
                }
            case "fromstream":
                {
                    if (n.length === 0) return [
                        e
                    ];
                    let i = s(e, n[0], r), o = null;
                    for (let a of i){
                        if (!Array.isArray(a) || a.length === 1 && Array.isArray(a[0]) && a[0].length === 0 || a.length !== 2) continue;
                        let [l, c] = a;
                        if (!Array.isArray(l)) continue;
                        if (l.length === 0) {
                            o = c;
                            continue;
                        }
                        o === null && (o = typeof l[0] == "number" ? [] : {});
                        let u = o;
                        for(let p = 0; p < l.length - 1; p++){
                            let d = l[p], m = l[p + 1];
                            if (Array.isArray(u) && typeof d == "number") {
                                for(; u.length <= d;)u.push(null);
                                u[d] === null && (u[d] = typeof m == "number" ? [] : {}), u = u[d];
                            } else if (u && typeof u == "object" && !Array.isArray(u)) {
                                let h = u;
                                (h[String(d)] === null || h[String(d)] === void 0) && (h[String(d)] = typeof m == "number" ? [] : {}), u = h[String(d)];
                            }
                        }
                        let f = l[l.length - 1];
                        if (Array.isArray(u) && typeof f == "number") {
                            for(; u.length <= f;)u.push(null);
                            u[f] = c;
                        } else u && typeof u == "object" && !Array.isArray(u) && (u[String(f)] = c);
                    }
                    return [
                        o
                    ];
                }
            case "truncate_stream":
                {
                    let i = typeof e == "number" ? Math.floor(e) : 0;
                    if (n.length === 0) return [];
                    let o = [], a = s(e, n[0], r);
                    for (let l of a)if (Array.isArray(l)) {
                        if (l.length === 1 && Array.isArray(l[0])) {
                            let c = l[0];
                            c.length > i && o.push([
                                c.slice(i)
                            ]);
                            continue;
                        }
                        if (l.length === 2 && Array.isArray(l[0])) {
                            let c = l[0], u = l[1];
                            c.length > i && o.push([
                                c.slice(i),
                                u
                            ]);
                        }
                    }
                    return o;
                }
            default:
                return null;
        }
    }
    var KE, Mp = v(()=>{
        ks();
        KE = 2e3;
    });
    function _o(e, t, n, r, s, i, o, a, l, c) {
        switch(t){
            case "getpath":
                {
                    if (n.length === 0) return [
                        null
                    ];
                    let u = s(e, n[0], r), f = [];
                    for (let p of u){
                        let d = p, m = e;
                        for (let h of d){
                            if (m == null) {
                                m = null;
                                break;
                            }
                            if (Array.isArray(m) && typeof h == "number") m = m[h];
                            else if (typeof m == "object" && typeof h == "string") m = m[h];
                            else {
                                m = null;
                                break;
                            }
                        }
                        f.push(m);
                    }
                    return f;
                }
            case "setpath":
                {
                    if (n.length < 2) return [
                        null
                    ];
                    let f = s(e, n[0], r)[0], d = s(e, n[1], r)[0];
                    return [
                        o(e, f, d)
                    ];
                }
            case "delpaths":
                {
                    if (n.length === 0) return [
                        e
                    ];
                    let f = s(e, n[0], r)[0], p = e;
                    for (let d of f.sort((m, h)=>h.length - m.length))p = a(p, d);
                    return [
                        p
                    ];
                }
            case "path":
                {
                    if (n.length === 0) return [
                        []
                    ];
                    let u = [];
                    return c(e, n[0], r, [], u), u;
                }
            case "del":
                return n.length === 0 ? [
                    e
                ] : [
                    l(e, n[0], r)
                ];
            case "pick":
                {
                    if (n.length === 0) return [
                        null
                    ];
                    let u = [];
                    for (let p of n)c(e, p, r, [], u);
                    let f = null;
                    for (let p of u){
                        for (let m of p)if (typeof m == "number" && m < 0) throw new Error("Out of bounds negative array index");
                        let d = e;
                        for (let m of p){
                            if (d == null) break;
                            if (Array.isArray(d) && typeof m == "number") d = d[m];
                            else if (typeof d == "object" && typeof m == "string") d = d[m];
                            else {
                                d = null;
                                break;
                            }
                        }
                        f = o(f, p, d);
                    }
                    return [
                        f
                    ];
                }
            case "paths":
                {
                    let u = [], f = (p, d)=>{
                        if (p && typeof p == "object") if (Array.isArray(p)) for(let m = 0; m < p.length; m++)u.push([
                            ...d,
                            m
                        ]), f(p[m], [
                            ...d,
                            m
                        ]);
                        else for (let m of Object.keys(p))u.push([
                            ...d,
                            m
                        ]), f(p[m], [
                            ...d,
                            m
                        ]);
                    };
                    return f(e, []), n.length > 0 ? u.filter((p)=>{
                        let d = e;
                        for (let h of p)if (Array.isArray(d) && typeof h == "number") d = d[h];
                        else if (d && typeof d == "object" && typeof h == "string") d = d[h];
                        else return false;
                        return s(d, n[0], r).some(i);
                    }) : u;
                }
            case "leaf_paths":
                {
                    let u = [], f = (p, d)=>{
                        if (p === null || typeof p != "object") u.push(d);
                        else if (Array.isArray(p)) for(let m = 0; m < p.length; m++)f(p[m], [
                            ...d,
                            m
                        ]);
                        else for (let m of Object.keys(p))f(p[m], [
                            ...d,
                            m
                        ]);
                    };
                    return f(e, []), u;
                }
            default:
                return null;
        }
    }
    var Wp = v(()=>{});
    function Lo(e, t, n, r, s, i) {
        switch(t){
            case "IN":
                {
                    if (n.length === 0) return [
                        false
                    ];
                    if (n.length === 1) {
                        let c = s(e, n[0], r);
                        for (let u of c)if (i(e, u)) return [
                            true
                        ];
                        return [
                            false
                        ];
                    }
                    let o = s(e, n[0], r), a = s(e, n[1], r), l = new Set(a.map((c)=>JSON.stringify(c)));
                    for (let c of o)if (l.has(JSON.stringify(c))) return [
                        true
                    ];
                    return [
                        false
                    ];
                }
            case "INDEX":
                {
                    if (n.length === 0) return [
                        {}
                    ];
                    if (n.length === 1) {
                        let l = s(e, n[0], r), c = {};
                        for (let u of l){
                            let f = String(u);
                            c[f] = u;
                        }
                        return [
                            c
                        ];
                    }
                    if (n.length === 2) {
                        let l = s(e, n[0], r), c = {};
                        for (let u of l){
                            let f = s(u, n[1], r);
                            if (f.length > 0) {
                                let p = String(f[0]);
                                c[p] = u;
                            }
                        }
                        return [
                            c
                        ];
                    }
                    let o = s(e, n[0], r), a = {};
                    for (let l of o){
                        let c = s(l, n[1], r), u = s(l, n[2], r);
                        if (c.length > 0 && u.length > 0) {
                            let f = String(c[0]);
                            a[f] = u[0];
                        }
                    }
                    return [
                        a
                    ];
                }
            case "JOIN":
                {
                    if (n.length < 2) return [
                        null
                    ];
                    let o = s(e, n[0], r)[0];
                    if (!o || typeof o != "object" || Array.isArray(o)) return [
                        null
                    ];
                    let a = o;
                    if (!Array.isArray(e)) return [
                        null
                    ];
                    let l = [];
                    for (let c of e){
                        let u = s(c, n[1], r), f = u.length > 0 ? String(u[0]) : "", p = f in a ? a[f] : null;
                        l.push([
                            c,
                            p
                        ]);
                    }
                    return [
                        l
                    ];
                }
            default:
                return null;
        }
    }
    var Bp = v(()=>{});
    function Mo(e, t, n, r, s) {
        switch(t){
            case "join":
                {
                    if (!Array.isArray(e)) return [
                        null
                    ];
                    let i = n.length > 0 ? s(e, n[0], r) : [
                        ""
                    ];
                    for (let o of e)if (Array.isArray(o) || o !== null && typeof o == "object") throw new Error("cannot join: contains arrays or objects");
                    return i.map((o)=>e.map((a)=>a === null ? "" : typeof a == "string" ? a : String(a)).join(String(o)));
                }
            case "split":
                {
                    if (typeof e != "string" || n.length === 0) return [
                        null
                    ];
                    let i = s(e, n[0], r), o = String(i[0]);
                    return [
                        e.split(o)
                    ];
                }
            case "splits":
                {
                    if (typeof e != "string" || n.length === 0) return [];
                    let i = s(e, n[0], r), o = String(i[0]);
                    try {
                        let a = n.length > 1 ? String(s(e, n[1], r)[0]) : "g", l = new RegExp(o, a.includes("g") ? a : `${a}g`);
                        return e.split(l);
                    } catch  {
                        return [];
                    }
                }
            case "scan":
                {
                    if (typeof e != "string" || n.length === 0) return [];
                    let i = s(e, n[0], r), o = String(i[0]);
                    try {
                        let a = n.length > 1 ? String(s(e, n[1], r)[0]) : "", l = new RegExp(o, a.includes("g") ? a : `${a}g`);
                        return [
                            ...e.matchAll(l)
                        ].map((u)=>u.length > 1 ? u.slice(1) : u[0]);
                    } catch  {
                        return [];
                    }
                }
            case "test":
                {
                    if (typeof e != "string" || n.length === 0) return [
                        false
                    ];
                    let i = s(e, n[0], r), o = String(i[0]);
                    try {
                        let a = n.length > 1 ? String(s(e, n[1], r)[0]) : "";
                        return [
                            new RegExp(o, a).test(e)
                        ];
                    } catch  {
                        return [
                            false
                        ];
                    }
                }
            case "match":
                {
                    if (typeof e != "string" || n.length === 0) return [
                        null
                    ];
                    let i = s(e, n[0], r), o = String(i[0]);
                    try {
                        let a = n.length > 1 ? String(s(e, n[1], r)[0]) : "", c = new RegExp(o, `${a}d`).exec(e);
                        if (!c) return [];
                        let u = c.indices;
                        return [
                            {
                                offset: c.index,
                                length: c[0].length,
                                string: c[0],
                                captures: c.slice(1).map((f, p)=>({
                                        offset: u?.[p + 1]?.[0] ?? null,
                                        length: f?.length ?? 0,
                                        string: f ?? "",
                                        name: null
                                    }))
                            }
                        ];
                    } catch  {
                        return [
                            null
                        ];
                    }
                }
            case "capture":
                {
                    if (typeof e != "string" || n.length === 0) return [
                        null
                    ];
                    let i = s(e, n[0], r), o = String(i[0]);
                    try {
                        let a = n.length > 1 ? String(s(e, n[1], r)[0]) : "", l = new RegExp(o, a), c = e.match(l);
                        return !c || !c.groups ? [
                            {}
                        ] : [
                            c.groups
                        ];
                    } catch  {
                        return [
                            null
                        ];
                    }
                }
            case "sub":
                {
                    if (typeof e != "string" || n.length < 2) return [
                        null
                    ];
                    let i = s(e, n[0], r), o = s(e, n[1], r), a = String(i[0]), l = String(o[0]);
                    try {
                        let c = n.length > 2 ? String(s(e, n[2], r)[0]) : "";
                        return [
                            e.replace(new RegExp(a, c), l)
                        ];
                    } catch  {
                        return [
                            e
                        ];
                    }
                }
            case "gsub":
                {
                    if (typeof e != "string" || n.length < 2) return [
                        null
                    ];
                    let i = s(e, n[0], r), o = s(e, n[1], r), a = String(i[0]), l = String(o[0]);
                    try {
                        let c = n.length > 2 ? String(s(e, n[2], r)[0]) : "g", u = c.includes("g") ? c : `${c}g`;
                        return [
                            e.replace(new RegExp(a, u), l)
                        ];
                    } catch  {
                        return [
                            e
                        ];
                    }
                }
            case "ascii_downcase":
                return typeof e == "string" ? [
                    e.replace(/[A-Z]/g, (i)=>String.fromCharCode(i.charCodeAt(0) + 32))
                ] : [
                    null
                ];
            case "ascii_upcase":
                return typeof e == "string" ? [
                    e.replace(/[a-z]/g, (i)=>String.fromCharCode(i.charCodeAt(0) - 32))
                ] : [
                    null
                ];
            case "ltrimstr":
                {
                    if (typeof e != "string" || n.length === 0) return [
                        e
                    ];
                    let i = s(e, n[0], r), o = String(i[0]);
                    return [
                        e.startsWith(o) ? e.slice(o.length) : e
                    ];
                }
            case "rtrimstr":
                {
                    if (typeof e != "string" || n.length === 0) return [
                        e
                    ];
                    let i = s(e, n[0], r), o = String(i[0]);
                    return o === "" ? [
                        e
                    ] : [
                        e.endsWith(o) ? e.slice(0, -o.length) : e
                    ];
                }
            case "trimstr":
                {
                    if (typeof e != "string" || n.length === 0) return [
                        e
                    ];
                    let i = s(e, n[0], r), o = String(i[0]);
                    if (o === "") return [
                        e
                    ];
                    let a = e;
                    return a.startsWith(o) && (a = a.slice(o.length)), a.endsWith(o) && (a = a.slice(0, -o.length)), [
                        a
                    ];
                }
            case "trim":
                if (typeof e == "string") return [
                    e.trim()
                ];
                throw new Error("trim input must be a string");
            case "ltrim":
                if (typeof e == "string") return [
                    e.trimStart()
                ];
                throw new Error("trim input must be a string");
            case "rtrim":
                if (typeof e == "string") return [
                    e.trimEnd()
                ];
                throw new Error("trim input must be a string");
            case "startswith":
                {
                    if (typeof e != "string" || n.length === 0) return [
                        false
                    ];
                    let i = s(e, n[0], r);
                    return [
                        e.startsWith(String(i[0]))
                    ];
                }
            case "endswith":
                {
                    if (typeof e != "string" || n.length === 0) return [
                        false
                    ];
                    let i = s(e, n[0], r);
                    return [
                        e.endsWith(String(i[0]))
                    ];
                }
            case "ascii":
                return typeof e == "string" && e.length > 0 ? [
                    e.charCodeAt(0)
                ] : [
                    null
                ];
            case "explode":
                return typeof e == "string" ? [
                    Array.from(e).map((i)=>i.codePointAt(0))
                ] : [
                    null
                ];
            case "implode":
                if (!Array.isArray(e)) throw new Error("implode input must be an array");
                return [
                    e.map((a)=>{
                        if (typeof a == "string") throw new Error(`string (${JSON.stringify(a)}) can't be imploded, unicode codepoint needs to be numeric`);
                        if (typeof a != "number" || Number.isNaN(a)) throw new Error("number (null) can't be imploded, unicode codepoint needs to be numeric");
                        let l = Math.trunc(a);
                        return l < 0 || l > 1114111 || l >= 55296 && l <= 57343 ? String.fromCodePoint(65533) : String.fromCodePoint(l);
                    }).join("")
                ];
            default:
                return null;
        }
    }
    var Up = v(()=>{});
    function Wo(e, t) {
        switch(t){
            case "type":
                return e === null ? [
                    "null"
                ] : Array.isArray(e) ? [
                    "array"
                ] : typeof e == "boolean" ? [
                    "boolean"
                ] : typeof e == "number" ? [
                    "number"
                ] : typeof e == "string" ? [
                    "string"
                ] : typeof e == "object" ? [
                    "object"
                ] : [
                    "null"
                ];
            case "infinite":
                return [
                    Number.POSITIVE_INFINITY
                ];
            case "nan":
                return [
                    Number.NaN
                ];
            case "isinfinite":
                return [
                    typeof e == "number" && !Number.isFinite(e)
                ];
            case "isnan":
                return [
                    typeof e == "number" && Number.isNaN(e)
                ];
            case "isnormal":
                return [
                    typeof e == "number" && Number.isFinite(e) && e !== 0
                ];
            case "isfinite":
                return [
                    typeof e == "number" && Number.isFinite(e)
                ];
            case "numbers":
                return typeof e == "number" ? [
                    e
                ] : [];
            case "strings":
                return typeof e == "string" ? [
                    e
                ] : [];
            case "booleans":
                return typeof e == "boolean" ? [
                    e
                ] : [];
            case "nulls":
                return e === null ? [
                    e
                ] : [];
            case "arrays":
                return Array.isArray(e) ? [
                    e
                ] : [];
            case "objects":
                return e && typeof e == "object" && !Array.isArray(e) ? [
                    e
                ] : [];
            case "iterables":
                return Array.isArray(e) || e && typeof e == "object" && !Array.isArray(e) ? [
                    e
                ] : [];
            case "scalars":
                return !Array.isArray(e) && !(e && typeof e == "object") ? [
                    e
                ] : [];
            case "values":
                return e === null ? [] : [
                    e
                ];
            case "not":
                return e === false || e === null ? [
                    true
                ] : [
                    false
                ];
            case "null":
                return [
                    null
                ];
            case "true":
                return [
                    true
                ];
            case "false":
                return [
                    false
                ];
            case "empty":
                return [];
            default:
                return null;
        }
    }
    var zp = v(()=>{});
    var jp = v(()=>{
        Pp();
        Tp();
        Op();
        Dp();
        Fp();
        _p();
        Lp();
        Mp();
        Wp();
        Bp();
        Up();
        zp();
    });
    function vs(e, t, n) {
        if (t.length === 0) return n;
        let [r, ...s] = t;
        if (typeof r == "number") {
            if (e && typeof e == "object" && !Array.isArray(e)) throw new Error("Cannot index object with number");
            if (r > 536870911) throw new Error("Array index too large");
            if (r < 0) throw new Error("Out of bounds negative array index");
            let a = Array.isArray(e) ? [
                ...e
            ] : [];
            for(; a.length <= r;)a.push(null);
            return a[r] = vs(a[r], s, n), a;
        }
        if (Array.isArray(e)) throw new Error("Cannot index array with string");
        let i = e && typeof e == "object" && !Array.isArray(e) ? {
            ...e
        } : {};
        return i[r] = vs(i[r], s, n), i;
    }
    function $s(e, t) {
        if (t.length === 0) return null;
        if (t.length === 1) {
            let s = t[0];
            if (Array.isArray(e) && typeof s == "number") {
                let i = [
                    ...e
                ];
                return i.splice(s, 1), i;
            }
            if (e && typeof e == "object" && !Array.isArray(e)) {
                let i = {
                    ...e
                };
                return delete i[String(s)], i;
            }
            return e;
        }
        let [n, ...r] = t;
        if (Array.isArray(e) && typeof n == "number") {
            let s = [
                ...e
            ];
            return s[n] = $s(s[n], r), s;
        }
        if (e && typeof e == "object" && !Array.isArray(e)) {
            let s = {
                ...e
            };
            return s[String(n)] = $s(s[String(n)], r), s;
        }
        return e;
    }
    var Hp = v(()=>{});
    function YE(e) {
        return {
            vars: new Map(),
            limits: {
                maxIterations: e?.limits?.maxIterations ?? XE,
                maxDepth: e?.limits?.maxDepth ?? Gp
            },
            env: e?.env
        };
    }
    function Ps(e, t, n) {
        let r = new Map(e.vars);
        return r.set(t, n), {
            vars: r,
            limits: e.limits,
            env: e.env,
            root: e.root,
            currentPath: e.currentPath,
            funcs: e.funcs,
            labels: e.labels
        };
    }
    function kr(e, t, n) {
        switch(t.type){
            case "var":
                return Ps(e, t.name, n);
            case "array":
                {
                    if (!Array.isArray(n)) return null;
                    let r = e;
                    for(let s = 0; s < t.elements.length; s++){
                        let i = t.elements[s], o = s < n.length ? n[s] : null, a = kr(r, i, o);
                        if (a === null) return null;
                        r = a;
                    }
                    return r;
                }
            case "object":
                {
                    if (n === null || typeof n != "object" || Array.isArray(n)) return null;
                    let r = n, s = e;
                    for (let i of t.fields){
                        let o;
                        if (typeof i.key == "string") o = i.key;
                        else {
                            let c = z(n, i.key, e);
                            if (c.length === 0) return null;
                            o = String(c[0]);
                        }
                        let a = o in r ? r[o] : null;
                        i.keyVar && (s = Ps(s, i.keyVar, a));
                        let l = kr(s, i.pattern, a);
                        if (l === null) return null;
                        s = l;
                    }
                    return s;
                }
        }
    }
    function eS(e, t) {
        let n = e;
        for (let r of t)if (n && typeof n == "object") n = n[r];
        else return;
        return n;
    }
    function en(e) {
        if (e.type === "Identity") return [];
        if (e.type === "Field") {
            let t = e.base ? en(e.base) : [];
            return t === null ? null : [
                ...t,
                e.name
            ];
        }
        if (e.type === "Index" && e.index.type === "Literal") {
            let t = e.base ? en(e.base) : [];
            if (t === null) return null;
            let n = e.index.value;
            return typeof n == "number" || typeof n == "string" ? [
                ...t,
                n
            ] : null;
        }
        if (e.type === "Pipe") {
            let t = en(e.left);
            return t === null ? null : Bo(t, e.right);
        }
        if (e.type === "Call") {
            if (e.name === "parent" || e.name === "root") return null;
            if (e.name === "first" && e.args.length === 0) return [
                0
            ];
            if (e.name === "last" && e.args.length === 0) return [
                -1
            ];
        }
        return null;
    }
    function Bo(e, t) {
        if (t.type === "Call") {
            if (t.name === "parent") {
                let n = 1;
                if (t.args.length > 0 && t.args[0].type === "Literal") {
                    let r = t.args[0].value;
                    typeof r == "number" && (n = r);
                }
                if (n >= 0) return e.slice(0, Math.max(0, e.length - n));
                {
                    let r = -n - 1;
                    return e.slice(0, Math.min(r, e.length));
                }
            }
            if (t.name === "root") return [];
        }
        if (t.type === "Field") {
            let n = en(t);
            if (n !== null) return [
                ...e,
                ...n
            ];
        }
        if (t.type === "Index" && t.index.type === "Literal") {
            let n = en(t);
            if (n !== null) return [
                ...e,
                ...n
            ];
        }
        if (t.type === "Pipe") {
            let n = Bo(e, t.left);
            return n === null ? null : Bo(n, t.right);
        }
        return t.type === "Identity" ? e : null;
    }
    function Vp(e, t, n) {
        if (t.type === "Comma") {
            let r = [];
            try {
                r.push(...z(e, t.left, n));
            } catch (s) {
                if (s instanceof ne) throw s;
                if (r.length > 0) return r;
                throw new Error("evaluation failed");
            }
            try {
                r.push(...z(e, t.right, n));
            } catch (s) {
                if (s instanceof ne) throw s;
                return r;
            }
            return r;
        }
        return z(e, t, n);
    }
    function z(e, t, n) {
        let r = n && "vars" in n ? n : YE(n);
        switch(r.root === void 0 && (r = {
            ...r,
            root: e,
            currentPath: []
        }), t.type){
            case "Identity":
                return [
                    e
                ];
            case "Field":
                return (t.base ? z(e, t.base, r) : [
                    e
                ]).flatMap((i)=>{
                    if (i && typeof i == "object" && !Array.isArray(i)) {
                        let a = i[t.name];
                        return [
                            a === void 0 ? null : a
                        ];
                    }
                    if (i === null) return [
                        null
                    ];
                    let o = Array.isArray(i) ? "array" : typeof i;
                    throw new Error(`Cannot index ${o} with string "${t.name}"`);
                });
            case "Index":
                return (t.base ? z(e, t.base, r) : [
                    e
                ]).flatMap((i)=>z(i, t.index, r).flatMap((a)=>{
                        if (typeof a == "number" && Array.isArray(i)) {
                            if (Number.isNaN(a)) return [
                                null
                            ];
                            let l = Math.trunc(a), c = l < 0 ? i.length + l : l;
                            return c >= 0 && c < i.length ? [
                                i[c]
                            ] : [
                                null
                            ];
                        }
                        return typeof a == "string" && i && typeof i == "object" && !Array.isArray(i) ? [
                            i[a]
                        ] : [
                            null
                        ];
                    }));
            case "Slice":
                return (t.base ? z(e, t.base, r) : [
                    e
                ]).flatMap((i)=>{
                    if (i === null) return [
                        null
                    ];
                    if (!Array.isArray(i) && typeof i != "string") throw new Error(`Cannot slice ${typeof i} (${JSON.stringify(i)})`);
                    let o = i.length, a = t.start ? z(e, t.start, r) : [
                        0
                    ], l = t.end ? z(e, t.end, r) : [
                        o
                    ];
                    return a.flatMap((c)=>l.map((u)=>{
                            let f = c, p = u, d = Number.isNaN(f) ? 0 : Number.isInteger(f) ? f : Math.floor(f), m = Number.isNaN(p) ? o : Number.isInteger(p) ? p : Math.ceil(p), h = qp(d, o), g = qp(m, o);
                            return i.slice(h, g);
                        }));
                });
            case "Iterate":
                return (t.base ? z(e, t.base, r) : [
                    e
                ]).flatMap((i)=>Array.isArray(i) ? i : i && typeof i == "object" ? Object.values(i) : []);
            case "Pipe":
                {
                    let s = z(e, t.left, r), i = en(t.left), o = [];
                    for (let a of s)try {
                        if (i !== null) {
                            let l = {
                                ...r,
                                currentPath: [
                                    ...r.currentPath ?? [],
                                    ...i
                                ]
                            };
                            o.push(...z(a, t.right, l));
                        } else o.push(...z(a, t.right, r));
                    } catch (l) {
                        throw l instanceof Vn ? l.withPrependedResults(o) : l;
                    }
                    return o;
                }
            case "Comma":
                {
                    let s = z(e, t.left, r), i = z(e, t.right, r);
                    return [
                        ...s,
                        ...i
                    ];
                }
            case "Literal":
                return [
                    t.value
                ];
            case "Array":
                return t.elements ? [
                    z(e, t.elements, r)
                ] : [
                    []
                ];
            case "Object":
                {
                    let s = [
                        {}
                    ];
                    for (let i of t.entries){
                        let o = typeof i.key == "string" ? [
                            i.key
                        ] : z(e, i.key, r), a = z(e, i.value, r), l = [];
                        for (let c of s)for (let u of o){
                            if (typeof u != "string") {
                                let f = u === null ? "null" : Array.isArray(u) ? "array" : typeof u;
                                throw new Error(`Cannot use ${f} (${JSON.stringify(u)}) as object key`);
                            }
                            for (let f of a)l.push({
                                ...c,
                                [u]: f
                            });
                        }
                        s.length = 0, s.push(...l);
                    }
                    return s;
                }
            case "Paren":
                return z(e, t.expr, r);
            case "BinaryOp":
                return rS(e, t.op, t.left, t.right, r);
            case "UnaryOp":
                return z(e, t.operand, r).map((i)=>{
                    if (t.op === "-") {
                        if (typeof i == "number") return -i;
                        if (typeof i == "string") {
                            let o = (a)=>a.length > 5 ? `"${a.slice(0, 3)}...` : JSON.stringify(a);
                            throw new Error(`string (${o(i)}) cannot be negated`);
                        }
                        return null;
                    }
                    return t.op === "not" ? !vt(i) : null;
                });
            case "Cond":
                return z(e, t.cond, r).flatMap((i)=>{
                    if (vt(i)) return z(e, t.then, r);
                    for (let o of t.elifs)if (z(e, o.cond, r).some(vt)) return z(e, o.then, r);
                    return t.else ? z(e, t.else, r) : [
                        e
                    ];
                });
            case "Try":
                try {
                    return z(e, t.body, r);
                } catch (s) {
                    if (t.catch) {
                        let i = s instanceof Rs ? s.value : s instanceof Error ? s.message : String(s);
                        return z(i, t.catch, r);
                    }
                    return [];
                }
            case "Call":
                return Zp(e, t.name, t.args, r);
            case "VarBind":
                return z(e, t.value, r).flatMap((i)=>{
                    let o = null, a = [];
                    t.pattern ? a.push(t.pattern) : t.name && a.push({
                        type: "var",
                        name: t.name
                    }), t.alternatives && a.push(...t.alternatives);
                    for (let l of a)if (o = kr(r, l, i), o !== null) break;
                    return o === null ? [] : z(e, t.body, o);
                });
            case "VarRef":
                {
                    if (t.name === "$ENV") return [
                        r.env ?? {}
                    ];
                    let s = r.vars.get(t.name);
                    return s !== void 0 ? [
                        s
                    ] : [
                        null
                    ];
                }
            case "Recurse":
                {
                    let s = [], i = new WeakSet(), o = (a)=>{
                        if (a && typeof a == "object") {
                            if (i.has(a)) return;
                            i.add(a);
                        }
                        if (s.push(a), Array.isArray(a)) for (let l of a)o(l);
                        else if (a && typeof a == "object") for (let l of Object.keys(a))o(a[l]);
                    };
                    return o(e), s;
                }
            case "Optional":
                try {
                    return z(e, t.expr, r);
                } catch  {
                    return [];
                }
            case "StringInterp":
                return [
                    t.parts.map((i)=>typeof i == "string" ? i : z(e, i, r).map((a)=>typeof a == "string" ? a : JSON.stringify(a)).join("")).join("")
                ];
            case "UpdateOp":
                return [
                    tS(e, t.path, t.op, t.value, r)
                ];
            case "Reduce":
                {
                    let s = z(e, t.expr, r), i = z(e, t.init, r)[0], o = r.limits.maxDepth ?? Gp;
                    for (let a of s){
                        let l;
                        if (t.pattern) {
                            if (l = kr(r, t.pattern, a), l === null) continue;
                        } else l = Ps(r, t.varName, a);
                        if (i = z(i, t.update, l)[0], Hn(i, o + 1) > o) return [
                            null
                        ];
                    }
                    return [
                        i
                    ];
                }
            case "Foreach":
                {
                    let s = z(e, t.expr, r), i = z(e, t.init, r)[0], o = [];
                    for (let a of s)try {
                        let l;
                        if (t.pattern) {
                            if (l = kr(r, t.pattern, a), l === null) continue;
                        } else l = Ps(r, t.varName, a);
                        if (i = z(i, t.update, l)[0], t.extract) {
                            let c = z(i, t.extract, l);
                            o.push(...c);
                        } else o.push(i);
                    } catch (l) {
                        throw l instanceof Vn ? l.withPrependedResults(o) : l;
                    }
                    return o;
                }
            case "Label":
                try {
                    return z(e, t.body, {
                        ...r,
                        labels: new Set([
                            ...r.labels ?? [],
                            t.name
                        ])
                    });
                } catch (s) {
                    if (s instanceof Vn && s.label === t.name) return s.partialResults;
                    throw s;
                }
            case "Break":
                throw new Vn(t.name);
            case "Def":
                {
                    let s = new Map(r.funcs ?? []), i = `${t.name}/${t.params.length}`;
                    s.set(i, {
                        params: t.params,
                        body: t.funcBody,
                        closure: new Map(r.funcs ?? [])
                    });
                    let o = {
                        ...r,
                        funcs: s
                    };
                    return z(e, t.body, o);
                }
            default:
                {
                    let s = t;
                    throw new Error(`Unknown AST node type: ${s.type}`);
                }
        }
    }
    function qp(e, t) {
        return e < 0 ? Math.max(0, t + e) : Math.min(e, t);
    }
    function tS(e, t, n, r, s) {
        function i(l, c) {
            switch(n){
                case "=":
                    return c;
                case "|=":
                    return z(l, r, s)[0] ?? null;
                case "+=":
                    return typeof l == "number" && typeof c == "number" || typeof l == "string" && typeof c == "string" ? l + c : Array.isArray(l) && Array.isArray(c) ? [
                        ...l,
                        ...c
                    ] : l && c && typeof l == "object" && typeof c == "object" ? {
                        ...l,
                        ...c
                    } : c;
                case "-=":
                    return typeof l == "number" && typeof c == "number" ? l - c : l;
                case "*=":
                    return typeof l == "number" && typeof c == "number" ? l * c : l;
                case "/=":
                    return typeof l == "number" && typeof c == "number" ? l / c : l;
                case "%=":
                    return typeof l == "number" && typeof c == "number" ? l % c : l;
                case "//=":
                    return l === null || l === false ? c : l;
                default:
                    return c;
            }
        }
        function o(l, c, u) {
            switch(c.type){
                case "Identity":
                    return u(l);
                case "Field":
                    {
                        if (c.base) return o(l, c.base, (f)=>{
                            if (f && typeof f == "object" && !Array.isArray(f)) {
                                let p = {
                                    ...f
                                };
                                return p[c.name] = u(p[c.name]), p;
                            }
                            return f;
                        });
                        if (l && typeof l == "object" && !Array.isArray(l)) {
                            let f = {
                                ...l
                            };
                            return f[c.name] = u(f[c.name]), f;
                        }
                        return l;
                    }
                case "Index":
                    {
                        let p = z(e, c.index, s)[0];
                        if (typeof p == "number" && Number.isNaN(p)) throw new Error("Cannot set array element at NaN index");
                        if (typeof p == "number" && !Number.isInteger(p) && (p = Math.trunc(p)), c.base) return o(l, c.base, (d)=>{
                            if (typeof p == "number" && Array.isArray(d)) {
                                let m = [
                                    ...d
                                ], h = p < 0 ? m.length + p : p;
                                if (h >= 0) {
                                    for(; m.length <= h;)m.push(null);
                                    m[h] = u(m[h]);
                                }
                                return m;
                            }
                            if (typeof p == "string" && d && typeof d == "object" && !Array.isArray(d)) {
                                let m = {
                                    ...d
                                };
                                return m[p] = u(m[p]), m;
                            }
                            return d;
                        });
                        if (typeof p == "number") {
                            if (p > 536870911) throw new Error("Array index too large");
                            if (p < 0 && (!l || !Array.isArray(l))) throw new Error("Out of bounds negative array index");
                            if (Array.isArray(l)) {
                                let m = [
                                    ...l
                                ], h = p < 0 ? m.length + p : p;
                                if (h >= 0) {
                                    for(; m.length <= h;)m.push(null);
                                    m[h] = u(m[h]);
                                }
                                return m;
                            }
                            if (l == null) {
                                let m = [];
                                for(; m.length <= p;)m.push(null);
                                return m[p] = u(null), m;
                            }
                            return l;
                        }
                        if (typeof p == "string" && l && typeof l == "object" && !Array.isArray(l)) {
                            let d = {
                                ...l
                            };
                            return d[p] = u(d[p]), d;
                        }
                        return l;
                    }
                case "Iterate":
                    {
                        let f = (p)=>{
                            if (Array.isArray(p)) return p.map((d)=>u(d));
                            if (p && typeof p == "object") {
                                let d = {};
                                for (let [m, h] of Object.entries(p))d[m] = u(h);
                                return d;
                            }
                            return p;
                        };
                        return c.base ? o(l, c.base, f) : f(l);
                    }
                case "Pipe":
                    {
                        let f = o(l, c.left, (p)=>p);
                        return o(f, c.right, u);
                    }
                default:
                    return u(l);
            }
        }
        return o(e, t, (l)=>{
            if (n === "|=") return i(l, l);
            let c = z(e, r, s);
            return i(l, c[0] ?? null);
        });
    }
    function nS(e, t, n) {
        function r(i, o, a) {
            switch(o.type){
                case "Identity":
                    return a;
                case "Field":
                    {
                        if (o.base) {
                            let l = z(i, o.base, n)[0], c = r(l, {
                                type: "Field",
                                name: o.name
                            }, a);
                            return r(i, o.base, c);
                        }
                        return i && typeof i == "object" && !Array.isArray(i) ? {
                            ...i,
                            [o.name]: a
                        } : i;
                    }
                case "Index":
                    {
                        if (o.base) {
                            let u = z(i, o.base, n)[0], f = r(u, {
                                type: "Index",
                                index: o.index
                            }, a);
                            return r(i, o.base, f);
                        }
                        let c = z(e, o.index, n)[0];
                        if (typeof c == "number" && Array.isArray(i)) {
                            let u = [
                                ...i
                            ], f = c < 0 ? u.length + c : c;
                            return f >= 0 && f < u.length && (u[f] = a), u;
                        }
                        return typeof c == "string" && i && typeof i == "object" && !Array.isArray(i) ? {
                            ...i,
                            [c]: a
                        } : i;
                    }
                default:
                    return i;
            }
        }
        function s(i, o) {
            switch(o.type){
                case "Identity":
                    return null;
                case "Field":
                    {
                        if (o.base) {
                            let l = z(i, o.base, n)[0];
                            if (l == null) return i;
                            let c = s(l, {
                                type: "Field",
                                name: o.name
                            });
                            return r(i, o.base, c);
                        }
                        if (i && typeof i == "object" && !Array.isArray(i)) {
                            let l = {
                                ...i
                            };
                            return delete l[o.name], l;
                        }
                        return i;
                    }
                case "Index":
                    {
                        if (o.base) {
                            let u = z(i, o.base, n)[0];
                            if (u == null) return i;
                            let f = s(u, {
                                type: "Index",
                                index: o.index
                            });
                            return r(i, o.base, f);
                        }
                        let c = z(e, o.index, n)[0];
                        if (typeof c == "number" && Array.isArray(i)) {
                            let u = [
                                ...i
                            ], f = c < 0 ? u.length + c : c;
                            return f >= 0 && f < u.length && u.splice(f, 1), u;
                        }
                        if (typeof c == "string" && i && typeof i == "object" && !Array.isArray(i)) {
                            let u = {
                                ...i
                            };
                            return delete u[c], u;
                        }
                        return i;
                    }
                case "Iterate":
                    return Array.isArray(i) ? [] : i && typeof i == "object" ? {} : i;
                case "Pipe":
                    {
                        let u = function(d, m, h) {
                            switch(m.type){
                                case "Identity":
                                    return h;
                                case "Field":
                                    return d && typeof d == "object" && !Array.isArray(d) ? {
                                        ...d,
                                        [m.name]: h
                                    } : d;
                                case "Index":
                                    {
                                        let b = z(e, m.index, n)[0];
                                        if (typeof b == "number" && Array.isArray(d)) {
                                            let y = [
                                                ...d
                                            ], w = b < 0 ? y.length + b : b;
                                            return w >= 0 && w < y.length && (y[w] = h), y;
                                        }
                                        return typeof b == "string" && d && typeof d == "object" && !Array.isArray(d) ? {
                                            ...d,
                                            [b]: h
                                        } : d;
                                    }
                                case "Pipe":
                                    {
                                        let g = z(d, m.left, n)[0], b = u(g, m.right, h);
                                        return u(d, m.left, b);
                                    }
                                default:
                                    return d;
                            }
                        };
                        let l = o.left, c = o.right, f = z(i, l, n)[0];
                        if (f == null) return i;
                        let p = s(f, c);
                        return u(i, l, p);
                    }
                default:
                    return i;
            }
        }
        return s(e, t);
    }
    function rS(e, t, n, r, s) {
        if (t === "and") return z(e, n, s).flatMap((l)=>vt(l) ? z(e, r, s).map((u)=>vt(u)) : [
                false
            ]);
        if (t === "or") return z(e, n, s).flatMap((l)=>vt(l) ? [
                true
            ] : z(e, r, s).map((u)=>vt(u)));
        if (t === "//") {
            let l = z(e, n, s).filter((c)=>c != null && c !== false);
            return l.length > 0 ? l : z(e, r, s);
        }
        let i = z(e, n, s), o = z(e, r, s);
        return i.flatMap((a)=>o.map((l)=>{
                switch(t){
                    case "+":
                        return a === null ? l : l === null ? a : typeof a == "number" && typeof l == "number" || typeof a == "string" && typeof l == "string" ? a + l : Array.isArray(a) && Array.isArray(l) ? [
                            ...a,
                            ...l
                        ] : a && l && typeof a == "object" && typeof l == "object" && !Array.isArray(a) && !Array.isArray(l) ? {
                            ...a,
                            ...l
                        } : null;
                    case "-":
                        if (typeof a == "number" && typeof l == "number") return a - l;
                        if (Array.isArray(a) && Array.isArray(l)) {
                            let c = new Set(l.map((u)=>JSON.stringify(u)));
                            return a.filter((u)=>!c.has(JSON.stringify(u)));
                        }
                        if (typeof a == "string" && typeof l == "string") {
                            let c = (u)=>u.length > 10 ? `"${u.slice(0, 10)}...` : JSON.stringify(u);
                            throw new Error(`string (${c(a)}) and string (${c(l)}) cannot be subtracted`);
                        }
                        return null;
                    case "*":
                        return typeof a == "number" && typeof l == "number" ? a * l : typeof a == "string" && typeof l == "number" ? a.repeat(l) : a && l && typeof a == "object" && typeof l == "object" && !Array.isArray(a) && !Array.isArray(l) ? Ro(a, l) : null;
                    case "/":
                        if (typeof a == "number" && typeof l == "number") {
                            if (l === 0) throw new Error(`number (${a}) and number (${l}) cannot be divided because the divisor is zero`);
                            return a / l;
                        }
                        return typeof a == "string" && typeof l == "string" ? a.split(l) : null;
                    case "%":
                        if (typeof a == "number" && typeof l == "number") {
                            if (l === 0) throw new Error(`number (${a}) and number (${l}) cannot be divided (remainder) because the divisor is zero`);
                            return !Number.isFinite(a) && !Number.isNaN(a) ? !Number.isFinite(l) && !Number.isNaN(l) && a < 0 && l > 0 ? -1 : 0 : a % l;
                        }
                        return null;
                    case "==":
                        return jn(a, l);
                    case "!=":
                        return !jn(a, l);
                    case "<":
                        return Nr(a, l) < 0;
                    case "<=":
                        return Nr(a, l) <= 0;
                    case ">":
                        return Nr(a, l) > 0;
                    case ">=":
                        return Nr(a, l) >= 0;
                    default:
                        return null;
                }
            }));
    }
    function Zp(e, t, n, r) {
        let s = JE[t];
        if (s) return typeof e == "number" ? [
            s(e)
        ] : [
            null
        ];
        let i = Oo(e, t, n, r, z);
        if (i !== null) return i;
        let o = Mo(e, t, n, r, z);
        if (o !== null) return o;
        let a = Io(e, t, n, r, z);
        if (a !== null) return a;
        let l = Po(e, t, r.limits.maxDepth);
        if (l !== null) return l;
        let c = Wo(e, t);
        if (c !== null) return c;
        let u = Fo(e, t, n, r, z);
        if (u !== null) return u;
        let f = vo(e, t, n, r, z, Vp, Cs, vt, Ns, ne);
        if (f !== null) return f;
        let p = _o(e, t, n, r, z, vt, vs, $s, nS, Is);
        if (p !== null) return p;
        let d = To(e, t, n, r, z, jn);
        if (d !== null) return d;
        let m = $o(e, t, n, r, z, Vp, vt, ne);
        if (m !== null) return m;
        let h = Do(e, t, n, r, z, vt, eS, Zp);
        if (h !== null) return h;
        let g = Lo(e, t, n, r, z, jn);
        if (g !== null) return g;
        switch(t){
            case "builtins":
                return [
                    [
                        "add/0",
                        "all/0",
                        "all/1",
                        "all/2",
                        "any/0",
                        "any/1",
                        "any/2",
                        "arrays/0",
                        "ascii/0",
                        "ascii_downcase/0",
                        "ascii_upcase/0",
                        "booleans/0",
                        "bsearch/1",
                        "builtins/0",
                        "combinations/0",
                        "combinations/1",
                        "contains/1",
                        "debug/0",
                        "del/1",
                        "delpaths/1",
                        "empty/0",
                        "env/0",
                        "error/0",
                        "error/1",
                        "explode/0",
                        "first/0",
                        "first/1",
                        "flatten/0",
                        "flatten/1",
                        "floor/0",
                        "from_entries/0",
                        "fromdate/0",
                        "fromjson/0",
                        "getpath/1",
                        "gmtime/0",
                        "group_by/1",
                        "gsub/2",
                        "gsub/3",
                        "has/1",
                        "implode/0",
                        "IN/1",
                        "IN/2",
                        "INDEX/1",
                        "INDEX/2",
                        "index/1",
                        "indices/1",
                        "infinite/0",
                        "inside/1",
                        "isempty/1",
                        "isnan/0",
                        "isnormal/0",
                        "isvalid/1",
                        "iterables/0",
                        "join/1",
                        "keys/0",
                        "keys_unsorted/0",
                        "last/0",
                        "last/1",
                        "length/0",
                        "limit/2",
                        "ltrimstr/1",
                        "map/1",
                        "map_values/1",
                        "match/1",
                        "match/2",
                        "max/0",
                        "max_by/1",
                        "min/0",
                        "min_by/1",
                        "mktime/0",
                        "modulemeta/1",
                        "nan/0",
                        "not/0",
                        "nth/1",
                        "nth/2",
                        "null/0",
                        "nulls/0",
                        "numbers/0",
                        "objects/0",
                        "path/1",
                        "paths/0",
                        "paths/1",
                        "pick/1",
                        "range/1",
                        "range/2",
                        "range/3",
                        "recurse/0",
                        "recurse/1",
                        "recurse_down/0",
                        "repeat/1",
                        "reverse/0",
                        "rindex/1",
                        "rtrimstr/1",
                        "scalars/0",
                        "scan/1",
                        "scan/2",
                        "select/1",
                        "setpath/2",
                        "skip/2",
                        "sort/0",
                        "sort_by/1",
                        "split/1",
                        "splits/1",
                        "splits/2",
                        "sqrt/0",
                        "startswith/1",
                        "strftime/1",
                        "strings/0",
                        "strptime/1",
                        "sub/2",
                        "sub/3",
                        "test/1",
                        "test/2",
                        "to_entries/0",
                        "toboolean/0",
                        "todate/0",
                        "tojson/0",
                        "tostream/0",
                        "fromstream/1",
                        "truncate_stream/1",
                        "tonumber/0",
                        "tostring/0",
                        "transpose/0",
                        "trim/0",
                        "ltrim/0",
                        "rtrim/0",
                        "type/0",
                        "unique/0",
                        "unique_by/1",
                        "until/2",
                        "utf8bytelength/0",
                        "values/0",
                        "walk/1",
                        "while/2",
                        "with_entries/1"
                    ]
                ];
            case "error":
                {
                    let b = n.length > 0 ? z(e, n[0], r)[0] : e;
                    throw new Rs(b);
                }
            case "env":
                return [
                    r.env ?? {}
                ];
            case "debug":
                return [
                    e
                ];
            case "input_line_number":
                return [
                    1
                ];
            default:
                {
                    let b = `${t}/${n.length}`, y = r.funcs?.get(b);
                    if (y) {
                        let w = y.closure ?? r.funcs ?? new Map(), E = new Map(w);
                        E.set(b, y);
                        for(let A = 0; A < y.params.length; A++){
                            let I = y.params[A], O = n[A];
                            if (O) {
                                let L = z(e, O, r), D;
                                if (L.length === 0) D = {
                                    type: "Call",
                                    name: "empty",
                                    args: []
                                };
                                else if (L.length === 1) D = {
                                    type: "Literal",
                                    value: L[0]
                                };
                                else {
                                    D = {
                                        type: "Literal",
                                        value: L[L.length - 1]
                                    };
                                    for(let $ = L.length - 2; $ >= 0; $--)D = {
                                        type: "Comma",
                                        left: {
                                            type: "Literal",
                                            value: L[$]
                                        },
                                        right: D
                                    };
                                }
                                E.set(`${I}/0`, {
                                    params: [],
                                    body: D
                                });
                            }
                        }
                        let C = {
                            ...r,
                            funcs: E
                        };
                        return z(e, y.body, C);
                    }
                    throw new Error(`Unknown function: ${t}`);
                }
        }
    }
    function Is(e, t, n, r, s) {
        if (t.type === "Comma") {
            let a = t;
            Is(e, a.left, n, r, s), Is(e, a.right, n, r, s);
            return;
        }
        let i = en(t);
        if (i !== null) {
            s.push([
                ...r,
                ...i
            ]);
            return;
        }
        if (t.type === "Iterate") {
            if (Array.isArray(e)) for(let a = 0; a < e.length; a++)s.push([
                ...r,
                a
            ]);
            else if (e && typeof e == "object") for (let a of Object.keys(e))s.push([
                ...r,
                a
            ]);
            return;
        }
        if (t.type === "Recurse") {
            let a = (l, c)=>{
                if (s.push([
                    ...r,
                    ...c
                ]), l && typeof l == "object") if (Array.isArray(l)) for(let u = 0; u < l.length; u++)a(l[u], [
                    ...c,
                    u
                ]);
                else for (let u of Object.keys(l))a(l[u], [
                    ...c,
                    u
                ]);
            };
            a(e, []);
            return;
        }
        if (t.type === "Pipe") {
            let a = en(t.left);
            if (a !== null) {
                let l = z(e, t.left, n);
                for (let c of l)Is(c, t.right, n, [
                    ...r,
                    ...a
                ], s);
                return;
            }
        }
        z(e, t, n).length > 0 && s.push(r);
    }
    var Vn, Rs, XE, Gp, JE, Qp = v(()=>{
        de();
        jp();
        Hp();
        ks();
        Vn = class e extends Error {
            label;
            partialResults;
            constructor(t, n = []){
                super(`break ${t}`), this.label = t, this.partialResults = n, this.name = "BreakError";
            }
            withPrependedResults(t) {
                return new e(this.label, [
                    ...t,
                    ...this.partialResults
                ]);
            }
        }, Rs = class extends Error {
            value;
            constructor(t){
                super(typeof t == "string" ? t : JSON.stringify(t)), this.value = t, this.name = "JqError";
            }
        }, XE = 1e4, Gp = 2e3, JE = {
            floor: Math.floor,
            ceil: Math.ceil,
            round: Math.round,
            sqrt: Math.sqrt,
            log: Math.log,
            log10: Math.log10,
            log2: Math.log2,
            exp: Math.exp,
            sin: Math.sin,
            cos: Math.cos,
            tan: Math.tan,
            asin: Math.asin,
            acos: Math.acos,
            atan: Math.atan,
            sinh: Math.sinh,
            cosh: Math.cosh,
            tanh: Math.tanh,
            asinh: Math.asinh,
            acosh: Math.acosh,
            atanh: Math.atanh,
            cbrt: Math.cbrt,
            expm1: Math.expm1,
            log1p: Math.log1p,
            trunc: Math.trunc
        };
    });
    function Kp(e) {
        let t = [], n = 0, r = (c = 0)=>e[n + c], s = ()=>e[n++], i = ()=>n >= e.length, o = (c)=>c >= "0" && c <= "9", a = (c)=>c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "_", l = (c)=>a(c) || o(c);
        for(; !i();){
            let c = n, u = s();
            if (!(u === " " || u === "	" || u === `
` || u === "\r")) {
                if (u === "#") {
                    for(; !i() && r() !== `
`;)s();
                    continue;
                }
                if (u === "." && r() === ".") {
                    s(), t.push({
                        type: "DOTDOT",
                        pos: c
                    });
                    continue;
                }
                if (u === "=" && r() === "=") {
                    s(), t.push({
                        type: "EQ",
                        pos: c
                    });
                    continue;
                }
                if (u === "!" && r() === "=") {
                    s(), t.push({
                        type: "NE",
                        pos: c
                    });
                    continue;
                }
                if (u === "<" && r() === "=") {
                    s(), t.push({
                        type: "LE",
                        pos: c
                    });
                    continue;
                }
                if (u === ">" && r() === "=") {
                    s(), t.push({
                        type: "GE",
                        pos: c
                    });
                    continue;
                }
                if (u === "/" && r() === "/") {
                    s(), r() === "=" ? (s(), t.push({
                        type: "UPDATE_ALT",
                        pos: c
                    })) : t.push({
                        type: "ALT",
                        pos: c
                    });
                    continue;
                }
                if (u === "+" && r() === "=") {
                    s(), t.push({
                        type: "UPDATE_ADD",
                        pos: c
                    });
                    continue;
                }
                if (u === "-" && r() === "=") {
                    s(), t.push({
                        type: "UPDATE_SUB",
                        pos: c
                    });
                    continue;
                }
                if (u === "*" && r() === "=") {
                    s(), t.push({
                        type: "UPDATE_MUL",
                        pos: c
                    });
                    continue;
                }
                if (u === "/" && r() === "=") {
                    s(), t.push({
                        type: "UPDATE_DIV",
                        pos: c
                    });
                    continue;
                }
                if (u === "%" && r() === "=") {
                    s(), t.push({
                        type: "UPDATE_MOD",
                        pos: c
                    });
                    continue;
                }
                if (u === "=" && r() !== "=") {
                    t.push({
                        type: "ASSIGN",
                        pos: c
                    });
                    continue;
                }
                if (u === ".") {
                    t.push({
                        type: "DOT",
                        pos: c
                    });
                    continue;
                }
                if (u === "|") {
                    r() === "=" ? (s(), t.push({
                        type: "UPDATE_PIPE",
                        pos: c
                    })) : t.push({
                        type: "PIPE",
                        pos: c
                    });
                    continue;
                }
                if (u === ",") {
                    t.push({
                        type: "COMMA",
                        pos: c
                    });
                    continue;
                }
                if (u === ":") {
                    t.push({
                        type: "COLON",
                        pos: c
                    });
                    continue;
                }
                if (u === ";") {
                    t.push({
                        type: "SEMICOLON",
                        pos: c
                    });
                    continue;
                }
                if (u === "(") {
                    t.push({
                        type: "LPAREN",
                        pos: c
                    });
                    continue;
                }
                if (u === ")") {
                    t.push({
                        type: "RPAREN",
                        pos: c
                    });
                    continue;
                }
                if (u === "[") {
                    t.push({
                        type: "LBRACKET",
                        pos: c
                    });
                    continue;
                }
                if (u === "]") {
                    t.push({
                        type: "RBRACKET",
                        pos: c
                    });
                    continue;
                }
                if (u === "{") {
                    t.push({
                        type: "LBRACE",
                        pos: c
                    });
                    continue;
                }
                if (u === "}") {
                    t.push({
                        type: "RBRACE",
                        pos: c
                    });
                    continue;
                }
                if (u === "?") {
                    t.push({
                        type: "QUESTION",
                        pos: c
                    });
                    continue;
                }
                if (u === "+") {
                    t.push({
                        type: "PLUS",
                        pos: c
                    });
                    continue;
                }
                if (u === "-") {
                    t.push({
                        type: "MINUS",
                        pos: c
                    });
                    continue;
                }
                if (u === "*") {
                    t.push({
                        type: "STAR",
                        pos: c
                    });
                    continue;
                }
                if (u === "/") {
                    t.push({
                        type: "SLASH",
                        pos: c
                    });
                    continue;
                }
                if (u === "%") {
                    t.push({
                        type: "PERCENT",
                        pos: c
                    });
                    continue;
                }
                if (u === "<") {
                    t.push({
                        type: "LT",
                        pos: c
                    });
                    continue;
                }
                if (u === ">") {
                    t.push({
                        type: "GT",
                        pos: c
                    });
                    continue;
                }
                if (o(u)) {
                    let f = u;
                    for(; !i() && (o(r()) || r() === "." || r() === "e" || r() === "E");)(r() === "e" || r() === "E") && (e[n + 1] === "+" || e[n + 1] === "-") && (f += s()), f += s();
                    t.push({
                        type: "NUMBER",
                        value: Number(f),
                        pos: c
                    });
                    continue;
                }
                if (u === '"') {
                    let f = "";
                    for(; !i() && r() !== '"';)if (r() === "\\") {
                        if (s(), i()) break;
                        let p = s();
                        switch(p){
                            case "n":
                                f += `
`;
                                break;
                            case "r":
                                f += "\r";
                                break;
                            case "t":
                                f += "	";
                                break;
                            case "\\":
                                f += "\\";
                                break;
                            case '"':
                                f += '"';
                                break;
                            case "(":
                                f += "\\(";
                                break;
                            default:
                                f += p;
                        }
                    } else f += s();
                    i() || s(), t.push({
                        type: "STRING",
                        value: f,
                        pos: c
                    });
                    continue;
                }
                if (a(u) || u === "$" || u === "@") {
                    let f = u;
                    for(; !i() && l(r());)f += s();
                    let p = sS[f];
                    p ? t.push({
                        type: p,
                        pos: c
                    }) : t.push({
                        type: "IDENT",
                        value: f,
                        pos: c
                    });
                    continue;
                }
                throw new Error(`Unexpected character '${u}' at position ${c}`);
            }
        }
        return t.push({
            type: "EOF",
            pos: n
        }), t;
    }
    function Xp(e) {
        let t = Kp(e);
        return new Uo(t).parse();
    }
    var sS, Uo, Jp = v(()=>{
        sS = {
            and: "AND",
            or: "OR",
            not: "NOT",
            if: "IF",
            then: "THEN",
            elif: "ELIF",
            else: "ELSE",
            end: "END",
            as: "AS",
            try: "TRY",
            catch: "CATCH",
            true: "TRUE",
            false: "FALSE",
            null: "NULL",
            reduce: "REDUCE",
            foreach: "FOREACH",
            label: "LABEL",
            break: "BREAK",
            def: "DEF"
        };
        Uo = class e {
            tokens;
            pos = 0;
            constructor(t){
                this.tokens = t;
            }
            peek(t = 0) {
                return this.tokens[this.pos + t] ?? {
                    type: "EOF",
                    pos: -1
                };
            }
            advance() {
                return this.tokens[this.pos++];
            }
            check(t) {
                return this.peek().type === t;
            }
            match(...t) {
                for (let n of t)if (this.check(n)) return this.advance();
                return null;
            }
            expect(t, n) {
                if (!this.check(t)) throw new Error(`${n} at position ${this.peek().pos}, got ${this.peek().type}`);
                return this.advance();
            }
            parse() {
                let t = this.parseExpr();
                if (!this.check("EOF")) throw new Error(`Unexpected token ${this.peek().type} at position ${this.peek().pos}`);
                return t;
            }
            parseExpr() {
                return this.parsePipe();
            }
            parsePattern() {
                if (this.match("LBRACKET")) {
                    let r = [];
                    if (!this.check("RBRACKET")) for(r.push(this.parsePattern()); this.match("COMMA") && !this.check("RBRACKET");)r.push(this.parsePattern());
                    return this.expect("RBRACKET", "Expected ']' after array pattern"), {
                        type: "array",
                        elements: r
                    };
                }
                if (this.match("LBRACE")) {
                    let r = [];
                    if (!this.check("RBRACE")) for(r.push(this.parsePatternField()); this.match("COMMA") && !this.check("RBRACE");)r.push(this.parsePatternField());
                    return this.expect("RBRACE", "Expected '}' after object pattern"), {
                        type: "object",
                        fields: r
                    };
                }
                let t = this.expect("IDENT", "Expected variable name in pattern"), n = t.value;
                if (!n.startsWith("$")) throw new Error(`Variable name must start with $ at position ${t.pos}`);
                return {
                    type: "var",
                    name: n
                };
            }
            parsePatternField() {
                if (this.match("LPAREN")) {
                    let n = this.parseExpr();
                    this.expect("RPAREN", "Expected ')' after computed key"), this.expect("COLON", "Expected ':' after computed key");
                    let r = this.parsePattern();
                    return {
                        key: n,
                        pattern: r
                    };
                }
                let t = this.peek();
                if (t.type === "IDENT") {
                    let n = t.value;
                    if (n.startsWith("$")) {
                        if (this.advance(), this.match("COLON")) {
                            let r = this.parsePattern();
                            return {
                                key: n.slice(1),
                                pattern: r,
                                keyVar: n
                            };
                        }
                        return {
                            key: n.slice(1),
                            pattern: {
                                type: "var",
                                name: n
                            }
                        };
                    }
                    if (this.advance(), this.match("COLON")) {
                        let r = this.parsePattern();
                        return {
                            key: n,
                            pattern: r
                        };
                    }
                    return {
                        key: n,
                        pattern: {
                            type: "var",
                            name: `$${n}`
                        }
                    };
                }
                throw new Error(`Expected field name in object pattern at position ${t.pos}`);
            }
            parsePipe() {
                let t = this.parseComma();
                for(; this.match("PIPE");){
                    let n = this.parseComma();
                    t = {
                        type: "Pipe",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseComma() {
                let t = this.parseVarBind();
                for(; this.match("COMMA");){
                    let n = this.parseVarBind();
                    t = {
                        type: "Comma",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseVarBind() {
                let t = this.parseUpdate();
                if (this.match("AS")) {
                    let n = this.parsePattern(), r = [];
                    for(; this.check("QUESTION") && this.peekAhead(1)?.type === "ALT";)this.advance(), this.advance(), r.push(this.parsePattern());
                    this.expect("PIPE", "Expected '|' after variable binding");
                    let s = this.parseExpr();
                    return n.type === "var" && r.length === 0 ? {
                        type: "VarBind",
                        name: n.name,
                        value: t,
                        body: s
                    } : {
                        type: "VarBind",
                        name: n.type === "var" ? n.name : "",
                        value: t,
                        body: s,
                        pattern: n.type !== "var" ? n : void 0,
                        alternatives: r.length > 0 ? r : void 0
                    };
                }
                return t;
            }
            peekAhead(t) {
                let n = this.pos + t;
                return n < this.tokens.length ? this.tokens[n] : void 0;
            }
            parseUpdate() {
                let t = this.parseAlt(), n = {
                    ASSIGN: "=",
                    UPDATE_ADD: "+=",
                    UPDATE_SUB: "-=",
                    UPDATE_MUL: "*=",
                    UPDATE_DIV: "/=",
                    UPDATE_MOD: "%=",
                    UPDATE_ALT: "//=",
                    UPDATE_PIPE: "|="
                }, r = this.match("ASSIGN", "UPDATE_ADD", "UPDATE_SUB", "UPDATE_MUL", "UPDATE_DIV", "UPDATE_MOD", "UPDATE_ALT", "UPDATE_PIPE");
                if (r) {
                    let s = this.parseVarBind();
                    return {
                        type: "UpdateOp",
                        op: n[r.type],
                        path: t,
                        value: s
                    };
                }
                return t;
            }
            parseAlt() {
                let t = this.parseOr();
                for(; this.match("ALT");){
                    let n = this.parseOr();
                    t = {
                        type: "BinaryOp",
                        op: "//",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseOr() {
                let t = this.parseAnd();
                for(; this.match("OR");){
                    let n = this.parseAnd();
                    t = {
                        type: "BinaryOp",
                        op: "or",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseAnd() {
                let t = this.parseNot();
                for(; this.match("AND");){
                    let n = this.parseNot();
                    t = {
                        type: "BinaryOp",
                        op: "and",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseNot() {
                return this.parseComparison();
            }
            parseComparison() {
                let t = this.parseAddSub(), n = {
                    EQ: "==",
                    NE: "!=",
                    LT: "<",
                    LE: "<=",
                    GT: ">",
                    GE: ">="
                }, r = this.match("EQ", "NE", "LT", "LE", "GT", "GE");
                if (r) {
                    let s = this.parseAddSub();
                    t = {
                        type: "BinaryOp",
                        op: n[r.type],
                        left: t,
                        right: s
                    };
                }
                return t;
            }
            parseAddSub() {
                let t = this.parseMulDiv();
                for(;;)if (this.match("PLUS")) {
                    let n = this.parseMulDiv();
                    t = {
                        type: "BinaryOp",
                        op: "+",
                        left: t,
                        right: n
                    };
                } else if (this.match("MINUS")) {
                    let n = this.parseMulDiv();
                    t = {
                        type: "BinaryOp",
                        op: "-",
                        left: t,
                        right: n
                    };
                } else break;
                return t;
            }
            parseMulDiv() {
                let t = this.parseUnary();
                for(;;)if (this.match("STAR")) {
                    let n = this.parseUnary();
                    t = {
                        type: "BinaryOp",
                        op: "*",
                        left: t,
                        right: n
                    };
                } else if (this.match("SLASH")) {
                    let n = this.parseUnary();
                    t = {
                        type: "BinaryOp",
                        op: "/",
                        left: t,
                        right: n
                    };
                } else if (this.match("PERCENT")) {
                    let n = this.parseUnary();
                    t = {
                        type: "BinaryOp",
                        op: "%",
                        left: t,
                        right: n
                    };
                } else break;
                return t;
            }
            parseUnary() {
                return this.match("MINUS") ? {
                    type: "UnaryOp",
                    op: "-",
                    operand: this.parseUnary()
                } : this.parsePostfix();
            }
            parsePostfix() {
                let t = this.parsePrimary();
                for(;;)if (this.match("QUESTION")) t = {
                    type: "Optional",
                    expr: t
                };
                else if (this.check("DOT") && (this.peek(1).type === "IDENT" || this.peek(1).type === "STRING")) this.advance(), t = {
                    type: "Field",
                    name: this.advance().value,
                    base: t
                };
                else if (this.check("LBRACKET")) if (this.advance(), this.match("RBRACKET")) t = {
                    type: "Iterate",
                    base: t
                };
                else if (this.check("COLON")) {
                    this.advance();
                    let n = this.check("RBRACKET") ? void 0 : this.parseExpr();
                    this.expect("RBRACKET", "Expected ']'"), t = {
                        type: "Slice",
                        end: n,
                        base: t
                    };
                } else {
                    let n = this.parseExpr();
                    if (this.match("COLON")) {
                        let r = this.check("RBRACKET") ? void 0 : this.parseExpr();
                        this.expect("RBRACKET", "Expected ']'"), t = {
                            type: "Slice",
                            start: n,
                            end: r,
                            base: t
                        };
                    } else this.expect("RBRACKET", "Expected ']'"), t = {
                        type: "Index",
                        index: n,
                        base: t
                    };
                }
                else break;
                return t;
            }
            parsePrimary() {
                if (this.match("DOTDOT")) return {
                    type: "Recurse"
                };
                if (this.match("DOT")) {
                    if (this.check("LBRACKET")) {
                        if (this.advance(), this.match("RBRACKET")) return {
                            type: "Iterate"
                        };
                        if (this.check("COLON")) {
                            this.advance();
                            let n = this.check("RBRACKET") ? void 0 : this.parseExpr();
                            return this.expect("RBRACKET", "Expected ']'"), {
                                type: "Slice",
                                end: n
                            };
                        }
                        let t = this.parseExpr();
                        if (this.match("COLON")) {
                            let n = this.check("RBRACKET") ? void 0 : this.parseExpr();
                            return this.expect("RBRACKET", "Expected ']'"), {
                                type: "Slice",
                                start: t,
                                end: n
                            };
                        }
                        return this.expect("RBRACKET", "Expected ']'"), {
                            type: "Index",
                            index: t
                        };
                    }
                    return this.check("IDENT") || this.check("STRING") ? {
                        type: "Field",
                        name: this.advance().value
                    } : {
                        type: "Identity"
                    };
                }
                if (this.match("TRUE")) return {
                    type: "Literal",
                    value: true
                };
                if (this.match("FALSE")) return {
                    type: "Literal",
                    value: false
                };
                if (this.match("NULL")) return {
                    type: "Literal",
                    value: null
                };
                if (this.check("NUMBER")) return {
                    type: "Literal",
                    value: this.advance().value
                };
                if (this.check("STRING")) {
                    let n = this.advance().value;
                    return n.includes("\\(") ? this.parseStringInterpolation(n) : {
                        type: "Literal",
                        value: n
                    };
                }
                if (this.match("LBRACKET")) {
                    if (this.match("RBRACKET")) return {
                        type: "Array"
                    };
                    let t = this.parseExpr();
                    return this.expect("RBRACKET", "Expected ']'"), {
                        type: "Array",
                        elements: t
                    };
                }
                if (this.match("LBRACE")) return this.parseObjectConstruction();
                if (this.match("LPAREN")) {
                    let t = this.parseExpr();
                    return this.expect("RPAREN", "Expected ')'"), {
                        type: "Paren",
                        expr: t
                    };
                }
                if (this.match("IF")) return this.parseIf();
                if (this.match("TRY")) {
                    let t = this.parsePostfix(), n;
                    return this.match("CATCH") && (n = this.parsePostfix()), {
                        type: "Try",
                        body: t,
                        catch: n
                    };
                }
                if (this.match("REDUCE")) {
                    let t = this.parseAddSub();
                    this.expect("AS", "Expected 'as' after reduce expression");
                    let n = this.parsePattern();
                    this.expect("LPAREN", "Expected '(' after variable");
                    let r = this.parseExpr();
                    this.expect("SEMICOLON", "Expected ';' after init expression");
                    let s = this.parseExpr();
                    this.expect("RPAREN", "Expected ')' after update expression");
                    let i = n.type === "var" ? n.name : "";
                    return {
                        type: "Reduce",
                        expr: t,
                        varName: i,
                        init: r,
                        update: s,
                        pattern: n.type !== "var" ? n : void 0
                    };
                }
                if (this.match("FOREACH")) {
                    let t = this.parseAddSub();
                    this.expect("AS", "Expected 'as' after foreach expression");
                    let n = this.parsePattern();
                    this.expect("LPAREN", "Expected '(' after variable");
                    let r = this.parseExpr();
                    this.expect("SEMICOLON", "Expected ';' after init expression");
                    let s = this.parseExpr(), i;
                    this.match("SEMICOLON") && (i = this.parseExpr()), this.expect("RPAREN", "Expected ')' after expressions");
                    let o = n.type === "var" ? n.name : "";
                    return {
                        type: "Foreach",
                        expr: t,
                        varName: o,
                        init: r,
                        update: s,
                        extract: i,
                        pattern: n.type !== "var" ? n : void 0
                    };
                }
                if (this.match("LABEL")) {
                    let t = this.expect("IDENT", "Expected label name (e.g., $out)"), n = t.value;
                    if (!n.startsWith("$")) throw new Error(`Label name must start with $ at position ${t.pos}`);
                    this.expect("PIPE", "Expected '|' after label name");
                    let r = this.parseExpr();
                    return {
                        type: "Label",
                        name: n,
                        body: r
                    };
                }
                if (this.match("BREAK")) {
                    let t = this.expect("IDENT", "Expected label name to break to"), n = t.value;
                    if (!n.startsWith("$")) throw new Error(`Break label must start with $ at position ${t.pos}`);
                    return {
                        type: "Break",
                        name: n
                    };
                }
                if (this.match("DEF")) {
                    let n = this.expect("IDENT", "Expected function name after def").value, r = [];
                    if (this.match("LPAREN")) {
                        if (!this.check("RPAREN")) {
                            let o = this.expect("IDENT", "Expected parameter name");
                            for(r.push(o.value); this.match("SEMICOLON");){
                                let a = this.expect("IDENT", "Expected parameter name");
                                r.push(a.value);
                            }
                        }
                        this.expect("RPAREN", "Expected ')' after parameters");
                    }
                    this.expect("COLON", "Expected ':' after function name");
                    let s = this.parseExpr();
                    this.expect("SEMICOLON", "Expected ';' after function body");
                    let i = this.parseExpr();
                    return {
                        type: "Def",
                        name: n,
                        params: r,
                        funcBody: s,
                        body: i
                    };
                }
                if (this.match("NOT")) return {
                    type: "Call",
                    name: "not",
                    args: []
                };
                if (this.check("IDENT")) {
                    let n = this.advance().value;
                    if (n.startsWith("$")) return {
                        type: "VarRef",
                        name: n
                    };
                    if (this.match("LPAREN")) {
                        let r = [];
                        if (!this.check("RPAREN")) for(r.push(this.parseExpr()); this.match("SEMICOLON");)r.push(this.parseExpr());
                        return this.expect("RPAREN", "Expected ')'"), {
                            type: "Call",
                            name: n,
                            args: r
                        };
                    }
                    return {
                        type: "Call",
                        name: n,
                        args: []
                    };
                }
                throw new Error(`Unexpected token ${this.peek().type} at position ${this.peek().pos}`);
            }
            parseObjectConstruction() {
                let t = [];
                if (!this.check("RBRACE")) do {
                    let n, r;
                    if (this.match("LPAREN")) n = this.parseExpr(), this.expect("RPAREN", "Expected ')'"), this.expect("COLON", "Expected ':'"), r = this.parseObjectValue();
                    else if (this.check("IDENT")) {
                        let s = this.advance().value;
                        this.match("COLON") ? (n = s, r = this.parseObjectValue()) : (n = s, r = {
                            type: "Field",
                            name: s
                        });
                    } else if (this.check("STRING")) n = this.advance().value, this.expect("COLON", "Expected ':'"), r = this.parseObjectValue();
                    else throw new Error(`Expected object key at position ${this.peek().pos}`);
                    t.push({
                        key: n,
                        value: r
                    });
                }while (this.match("COMMA"));
                return this.expect("RBRACE", "Expected '}'"), {
                    type: "Object",
                    entries: t
                };
            }
            parseObjectValue() {
                let t = this.parseVarBind();
                for(; this.match("PIPE");){
                    let n = this.parseVarBind();
                    t = {
                        type: "Pipe",
                        left: t,
                        right: n
                    };
                }
                return t;
            }
            parseIf() {
                let t = this.parseExpr();
                this.expect("THEN", "Expected 'then'");
                let n = this.parseExpr(), r = [];
                for(; this.match("ELIF");){
                    let i = this.parseExpr();
                    this.expect("THEN", "Expected 'then' after elif");
                    let o = this.parseExpr();
                    r.push({
                        cond: i,
                        then: o
                    });
                }
                let s;
                return this.match("ELSE") && (s = this.parseExpr()), this.expect("END", "Expected 'end'"), {
                    type: "Cond",
                    cond: t,
                    then: n,
                    elifs: r,
                    else: s
                };
            }
            parseStringInterpolation(t) {
                let n = [], r = "", s = 0;
                for(; s < t.length;)if (t[s] === "\\" && t[s + 1] === "(") {
                    r && (n.push(r), r = ""), s += 2;
                    let i = 1, o = "";
                    for(; s < t.length && i > 0;)t[s] === "(" ? i++ : t[s] === ")" && i--, i > 0 && (o += t[s]), s++;
                    let a = Kp(o), l = new e(a);
                    n.push(l.parse());
                } else r += t[s], s++;
                return r && n.push(r), {
                    type: "StringInterp",
                    parts: n
                };
            }
        };
    });
    var Yp = v(()=>{
        Qp();
        Jp();
    });
    var td = {};
    V(td, {
        jqCommand: ()=>oS
    });
    function ed(e) {
        let t = [], n = 0, r = e.length;
        for(; n < r;){
            for(; n < r && /\s/.test(e[n]);)n++;
            if (n >= r) break;
            let s = n, i = e[n];
            if (i === "{" || i === "[") {
                let o = i, a = i === "{" ? "}" : "]", l = 1, c = false, u = false;
                for(n++; n < r && l > 0;){
                    let f = e[n];
                    u ? u = false : f === "\\" ? u = true : f === '"' ? c = !c : c || (f === o ? l++ : f === a && l--), n++;
                }
                if (l !== 0) throw new Error(`Unexpected end of JSON input at position ${n} (unclosed ${o})`);
                t.push(JSON.parse(e.slice(s, n)));
            } else if (i === '"') {
                let o = false;
                for(n++; n < r;){
                    let a = e[n];
                    if (o) o = false;
                    else if (a === "\\") o = true;
                    else if (a === '"') {
                        n++;
                        break;
                    }
                    n++;
                }
                t.push(JSON.parse(e.slice(s, n)));
            } else if (i === "-" || i >= "0" && i <= "9") {
                for(; n < r && /[\d.eE+-]/.test(e[n]);)n++;
                t.push(JSON.parse(e.slice(s, n)));
            } else if (e.slice(n, n + 4) === "true") t.push(true), n += 4;
            else if (e.slice(n, n + 5) === "false") t.push(false), n += 5;
            else if (e.slice(n, n + 4) === "null") t.push(null), n += 4;
            else {
                let o = e.slice(n, n + 10);
                throw new Error(`Invalid JSON at position ${s}: unexpected '${o.split(/\s/)[0]}'`);
            }
        }
        return t;
    }
    function vr(e, t, n, r, s, i = 0) {
        if (e === null || e === void 0) return "null";
        if (typeof e == "boolean") return String(e);
        if (typeof e == "number") return Number.isFinite(e) ? String(e) : "null";
        if (typeof e == "string") return n ? e : JSON.stringify(e);
        let o = s ? "	" : "  ";
        if (Array.isArray(e)) return e.length === 0 ? "[]" : t ? `[${e.map((l)=>vr(l, true, false, r, s)).join(",")}]` : `[
${e.map((l)=>o.repeat(i + 1) + vr(l, false, false, r, s, i + 1)).join(`,
`)}
${o.repeat(i)}]`;
        if (typeof e == "object") {
            let a = Object.keys(e);
            return r && (a = a.sort()), a.length === 0 ? "{}" : t ? `{${a.map((c)=>`${JSON.stringify(c)}:${vr(e[c], true, false, r, s)}`).join(",")}}` : `{
${a.map((c)=>{
                let u = vr(e[c], false, false, r, s, i + 1);
                return `${o.repeat(i + 1)}${JSON.stringify(c)}: ${u}`;
            }).join(`,
`)}
${o.repeat(i)}}`;
        }
        return String(e);
    }
    var iS, oS, nd = v(()=>{
        de();
        pn();
        X();
        Yp();
        iS = {
            name: "jq",
            summary: "command-line JSON processor",
            usage: "jq [OPTIONS] FILTER [FILE]",
            options: [
                "-r, --raw-output  output strings without quotes",
                "-c, --compact     compact output (no pretty printing)",
                "-e, --exit-status set exit status based on output",
                "-s, --slurp       read entire input into array",
                "-n, --null-input  don't read any input",
                "-j, --join-output don't print newlines after each output",
                "-a, --ascii       force ASCII output",
                "-S, --sort-keys   sort object keys",
                "-C, --color       colorize output (ignored)",
                "-M, --monochrome  monochrome output (ignored)",
                "    --tab         use tabs for indentation",
                "    --help        display this help and exit"
            ]
        };
        oS = {
            name: "jq",
            async execute (e, t) {
                if (_(e)) return F(iS);
                let n = false, r = false, s = false, i = false, o = false, a = false, l = false, c = false, u = ".", f = false, p = [];
                for(let m = 0; m < e.length; m++){
                    let h = e[m];
                    if (h === "-r" || h === "--raw-output") n = true;
                    else if (h === "-c" || h === "--compact-output") r = true;
                    else if (h === "-e" || h === "--exit-status") s = true;
                    else if (h === "-s" || h === "--slurp") i = true;
                    else if (h === "-n" || h === "--null-input") o = true;
                    else if (h === "-j" || h === "--join-output") a = true;
                    else if (!(h === "-a" || h === "--ascii")) {
                        if (h === "-S" || h === "--sort-keys") l = true;
                        else if (!(h === "-C" || h === "--color")) {
                            if (!(h === "-M" || h === "--monochrome")) if (h === "--tab") c = true;
                            else if (h === "-") p.push("-");
                            else {
                                if (h.startsWith("--")) return G("jq", h);
                                if (h.startsWith("-")) {
                                    for (let g of h.slice(1))if (g === "r") n = true;
                                    else if (g === "c") r = true;
                                    else if (g === "e") s = true;
                                    else if (g === "s") i = true;
                                    else if (g === "n") o = true;
                                    else if (g === "j") a = true;
                                    else if (g !== "a") {
                                        if (g === "S") l = true;
                                        else if (g !== "C") {
                                            if (g !== "M") return G("jq", `-${g}`);
                                        }
                                    }
                                } else f ? p.push(h) : (u = h, f = true);
                            }
                        }
                    }
                }
                let d = [];
                if (!o) if (p.length === 0 || p.length === 1 && p[0] === "-") d.push({
                    source: "stdin",
                    content: t.stdin
                });
                else {
                    let m = await fn(t, p, {
                        cmdName: "jq",
                        stopOnError: true
                    });
                    if (m.exitCode !== 0) return {
                        stdout: "",
                        stderr: m.stderr,
                        exitCode: 2
                    };
                    d = m.files.map((h)=>({
                            source: h.filename || "stdin",
                            content: h.content
                        }));
                }
                try {
                    let m = Xp(u), h = [], g = {
                        limits: t.limits ? {
                            maxIterations: t.limits.maxJqIterations
                        } : void 0,
                        env: t.env
                    };
                    if (o) h = z(null, m, g);
                    else if (i) {
                        let C = [];
                        for (let { content: A } of d){
                            let I = A.trim();
                            I && C.push(...ed(I));
                        }
                        h = z(C, m, g);
                    } else for (let { content: C } of d){
                        let A = C.trim();
                        if (!A) continue;
                        let I = ed(A);
                        for (let O of I)h.push(...z(O, m, g));
                    }
                    let b = h.map((C)=>vr(C, r, n, l, c)), y = a ? "" : `
`, w = b.join(y), E = s && (h.length === 0 || h.every((C)=>C == null || C === false)) ? 1 : 0;
                    return {
                        stdout: w ? a ? w : `${w}
` : "",
                        stderr: "",
                        exitCode: E
                    };
                } catch (m) {
                    if (m instanceof ne) return {
                        stdout: "",
                        stderr: `jq: ${m.message}
`,
                        exitCode: ne.EXIT_CODE
                    };
                    let h = m.message;
                    return h.includes("Unknown function") ? {
                        stdout: "",
                        stderr: `jq: error: ${h}
`,
                        exitCode: 3
                    } : {
                        stdout: "",
                        stderr: `jq: parse error: ${h}
`,
                        exitCode: 5
                    };
                }
            }
        };
    });
    var sd = {};
    V(sd, {
        base64Command: ()=>cS
    });
    async function rd(e, t, n) {
        if (t.length === 0 || t.length === 1 && t[0] === "-") return {
            ok: true,
            data: Uint8Array.from(e.stdin, (a)=>a.charCodeAt(0))
        };
        let r = [];
        for (let a of t){
            if (a === "-") {
                r.push(Uint8Array.from(e.stdin, (l)=>l.charCodeAt(0)));
                continue;
            }
            try {
                let l = e.fs.resolvePath(e.cwd, a), c = await e.fs.readFileBuffer(l);
                r.push(c);
            } catch  {
                return {
                    ok: false,
                    error: {
                        stdout: "",
                        stderr: `${n}: ${a}: No such file or directory
`,
                        exitCode: 1
                    }
                };
            }
        }
        let s = r.reduce((a, l)=>a + l.length, 0), i = new Uint8Array(s), o = 0;
        for (let a of r)i.set(a, o), o += a.length;
        return {
            ok: true,
            data: i
        };
    }
    var aS, lS, cS, id = v(()=>{
        Oe();
        X();
        aS = {
            name: "base64",
            summary: "base64 encode/decode data and print to standard output",
            usage: "base64 [OPTION]... [FILE]",
            options: [
                "-d, --decode    decode data",
                "-w, --wrap=COLS wrap encoded lines after COLS character (default 76, 0 to disable)",
                "    --help      display this help and exit"
            ]
        }, lS = {
            decode: {
                short: "d",
                long: "decode",
                type: "boolean"
            },
            wrap: {
                short: "w",
                long: "wrap",
                type: "number",
                default: 76
            }
        };
        cS = {
            name: "base64",
            async execute (e, t) {
                if (_(e)) return F(aS);
                let n = fe("base64", e, lS);
                if (!n.ok) return n.error;
                let r = n.result.flags.decode, s = n.result.flags.wrap, i = n.result.positional;
                try {
                    if (r) {
                        let l = await rd(t, i, "base64");
                        if (!l.ok) return l.error;
                        let u = String.fromCharCode(...l.data).replace(/\s/g, "");
                        return {
                            stdout: atob(u),
                            stderr: "",
                            exitCode: 0
                        };
                    }
                    let o = await rd(t, i, "base64");
                    if (!o.ok) return o.error;
                    let a = btoa(String.fromCharCode(...o.data));
                    if (s > 0) {
                        let l = [];
                        for(let c = 0; c < a.length; c += s)l.push(a.slice(c, c + s));
                        a = l.join(`
`) + (a.length > 0 ? `
` : "");
                    }
                    return {
                        stdout: a,
                        stderr: "",
                        exitCode: 0
                    };
                } catch  {
                    return {
                        stdout: "",
                        stderr: `base64: invalid input
`,
                        exitCode: 1
                    };
                }
            }
        };
    });
    var ad = {};
    V(ad, {
        diffCommand: ()=>pS
    });
    var uS, fS, pS, ld = v(()=>{
        Oe();
        X();
        uS = {
            name: "diff",
            summary: "compare files line by line",
            usage: "diff [OPTION]... FILE1 FILE2",
            options: [
                "-u, --unified     output unified diff format (default)",
                "-q, --brief       report only whether files differ",
                "-s, --report-identical-files  report when files are the same",
                "-i, --ignore-case  ignore case differences",
                "    --help        display this help and exit"
            ]
        }, fS = {
            unified: {
                short: "u",
                long: "unified",
                type: "boolean"
            },
            brief: {
                short: "q",
                long: "brief",
                type: "boolean"
            },
            reportSame: {
                short: "s",
                long: "report-identical-files",
                type: "boolean"
            },
            ignoreCase: {
                short: "i",
                long: "ignore-case",
                type: "boolean"
            }
        }, pS = {
            name: "diff",
            async execute (e, t) {
                if (_(e)) return F(uS);
                let n = fe("diff", e, fS);
                if (!n.ok) return n.error;
                let r = n.result.flags.brief, s = n.result.flags.reportSame, i = n.result.flags.ignoreCase, o = n.result.positional;
                if (n.result.flags.unified, o.length < 2) return {
                    stdout: "",
                    stderr: `diff: missing operand
`,
                    exitCode: 2
                };
                let a, l, [c, u] = o;
                try {
                    a = c === "-" ? t.stdin : await t.fs.readFile(t.fs.resolvePath(t.cwd, c));
                } catch  {
                    return {
                        stdout: "",
                        stderr: `diff: ${c}: No such file or directory
`,
                        exitCode: 2
                    };
                }
                try {
                    l = u === "-" ? t.stdin : await t.fs.readFile(t.fs.resolvePath(t.cwd, u));
                } catch  {
                    return {
                        stdout: "",
                        stderr: `diff: ${u}: No such file or directory
`,
                        exitCode: 2
                    };
                }
                let f = a, p = l;
                return i && (f = f.toLowerCase(), p = p.toLowerCase()), f === p ? s ? {
                    stdout: `Files ${c} and ${u} are identical
`,
                    stderr: "",
                    exitCode: 0
                } : {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                } : r ? {
                    stdout: `Files ${c} and ${u} differ
`,
                    stderr: "",
                    exitCode: 1
                } : {
                    stdout: createTwoFilesPatch(c, u, a, l, "", "", {
                        context: 3
                    }),
                    stderr: "",
                    exitCode: 1
                };
            }
        };
    });
    var cd = {};
    V(cd, {
        dateCommand: ()=>bS
    });
    function Xe(e, t = 2) {
        return String(e).padStart(t, "0");
    }
    function gS(e) {
        let t = -e.getTimezoneOffset();
        return `${t >= 0 ? "+" : "-"}${Xe(Math.floor(Math.abs(t) / 60))}${Xe(Math.abs(t) % 60)}`;
    }
    function Ts(e, t, n) {
        let r = n ? {
            Y: e.getUTCFullYear(),
            m: e.getUTCMonth(),
            D: e.getUTCDate(),
            H: e.getUTCHours(),
            M: e.getUTCMinutes(),
            S: e.getUTCSeconds(),
            w: e.getUTCDay()
        } : {
            Y: e.getFullYear(),
            m: e.getMonth(),
            D: e.getDate(),
            H: e.getHours(),
            M: e.getMinutes(),
            S: e.getSeconds(),
            w: e.getDay()
        }, s = "", i = 0;
        for(; i < t.length;){
            if (t[i] === "%" && i + 1 < t.length) {
                let o = t[++i];
                switch(o){
                    case "%":
                        s += "%";
                        break;
                    case "a":
                        s += hS[r.w];
                        break;
                    case "b":
                    case "h":
                        s += mS[r.m];
                        break;
                    case "d":
                        s += Xe(r.D);
                        break;
                    case "e":
                        s += String(r.D).padStart(2, " ");
                        break;
                    case "F":
                        s += `${r.Y}-${Xe(r.m + 1)}-${Xe(r.D)}`;
                        break;
                    case "H":
                        s += Xe(r.H);
                        break;
                    case "I":
                        s += Xe(r.H % 12 || 12);
                        break;
                    case "m":
                        s += Xe(r.m + 1);
                        break;
                    case "M":
                        s += Xe(r.M);
                        break;
                    case "n":
                        s += `
`;
                        break;
                    case "p":
                        s += r.H < 12 ? "AM" : "PM";
                        break;
                    case "P":
                        s += r.H < 12 ? "am" : "pm";
                        break;
                    case "R":
                        s += `${Xe(r.H)}:${Xe(r.M)}`;
                        break;
                    case "s":
                        s += Math.floor(e.getTime() / 1e3);
                        break;
                    case "S":
                        s += Xe(r.S);
                        break;
                    case "t":
                        s += "	";
                        break;
                    case "T":
                        s += `${Xe(r.H)}:${Xe(r.M)}:${Xe(r.S)}`;
                        break;
                    case "u":
                        s += r.w || 7;
                        break;
                    case "w":
                        s += r.w;
                        break;
                    case "y":
                        s += Xe(r.Y % 100);
                        break;
                    case "Y":
                        s += r.Y;
                        break;
                    case "z":
                        s += n ? "+0000" : gS(e);
                        break;
                    case "Z":
                        s += n ? "UTC" : Intl.DateTimeFormat().resolvedOptions().timeZone;
                        break;
                    default:
                        s += `%${o}`;
                }
            } else s += t[i];
            i++;
        }
        return s;
    }
    function yS(e) {
        let t = new Date(e);
        if (!Number.isNaN(t.getTime())) return t;
        if (/^\d+$/.test(e)) return new Date(Number.parseInt(e, 10) * 1e3);
        let n = e.toLowerCase();
        return n === "now" || n === "today" ? new Date() : n === "yesterday" ? new Date(Date.now() - 864e5) : n === "tomorrow" ? new Date(Date.now() + 864e5) : null;
    }
    var dS, hS, mS, bS, ud = v(()=>{
        X();
        dS = {
            name: "date",
            summary: "display the current time in the given FORMAT",
            usage: "date [OPTION]... [+FORMAT]",
            options: [
                "-d, --date=STRING   display time described by STRING",
                "-u, --utc           print Coordinated Universal Time (UTC)",
                "-I, --iso-8601      output date/time in ISO 8601 format",
                "-R, --rfc-email     output RFC 5322 date format",
                "    --help          display this help and exit"
            ]
        }, hS = [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ], mS = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ];
        bS = {
            name: "date",
            async execute (e, t) {
                if (_(e)) return F(dS);
                let n = false, r = null, s = null, i = false, o = false;
                for(let c = 0; c < e.length; c++){
                    let u = e[c];
                    if (u === "-u" || u === "--utc") n = true;
                    else if (u === "-d" || u === "--date") r = e[++c] ?? "";
                    else if (u.startsWith("--date=")) r = u.slice(7);
                    else if (u === "-I" || u === "--iso-8601") i = true;
                    else if (u === "-R" || u === "--rfc-email") o = true;
                    else if (u.startsWith("+")) s = u.slice(1);
                    else {
                        if (u.startsWith("--")) return G("date", u);
                        if (u.startsWith("-")) for (let f of u.slice(1))if (f === "u") n = true;
                        else if (f === "I") i = true;
                        else if (f === "R") o = true;
                        else return G("date", `-${f}`);
                    }
                }
                let a = r !== null ? yS(r) : new Date();
                if (!a) return {
                    stdout: "",
                    stderr: `date: invalid date '${r}'
`,
                    exitCode: 1
                };
                let l;
                return s ? l = Ts(a, s, n) : i ? l = Ts(a, "%Y-%m-%dT%H:%M:%S%z", n) : o ? l = Ts(a, "%a, %d %b %Y %H:%M:%S %z", n) : l = Ts(a, "%a %b %e %H:%M:%S %Z %Y", n), {
                    stdout: `${l}
`,
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var fd = {};
    V(fd, {
        sleepCommand: ()=>ES
    });
    function xS(e) {
        let t = e.match(/^(\d+\.?\d*)(s|m|h|d)?$/);
        if (!t) return null;
        let n = parseFloat(t[1]);
        switch(t[2] || "s"){
            case "s":
                return n * 1e3;
            case "m":
                return n * 60 * 1e3;
            case "h":
                return n * 60 * 60 * 1e3;
            case "d":
                return n * 24 * 60 * 60 * 1e3;
            default:
                return null;
        }
    }
    var wS, ES, pd = v(()=>{
        X();
        wS = {
            name: "sleep",
            summary: "delay for a specified amount of time",
            usage: "sleep NUMBER[SUFFIX]",
            description: `Pause for NUMBER seconds. SUFFIX may be:
  s - seconds (default)
  m - minutes
  h - hours
  d - days

NUMBER may be a decimal number.`,
            options: [
                "    --help display this help and exit"
            ]
        };
        ES = {
            name: "sleep",
            async execute (e, t) {
                if (_(e)) return F(wS);
                if (e.length === 0) return {
                    stdout: "",
                    stderr: `sleep: missing operand
`,
                    exitCode: 1
                };
                let n = 0;
                for (let r of e){
                    let s = xS(r);
                    if (s === null) return {
                        stdout: "",
                        stderr: `sleep: invalid time interval '${r}'
`,
                        exitCode: 1
                    };
                    n += s;
                }
                return t.sleep ? await t.sleep(n) : await new Promise((r)=>setTimeout(r, n)), {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var dd = {};
    V(dd, {
        timeoutCommand: ()=>CS
    });
    function AS(e) {
        let t = e.match(/^(\d+\.?\d*)(s|m|h|d)?$/);
        if (!t) return null;
        let n = parseFloat(t[1]);
        switch(t[2] || "s"){
            case "s":
                return n * 1e3;
            case "m":
                return n * 60 * 1e3;
            case "h":
                return n * 60 * 60 * 1e3;
            case "d":
                return n * 24 * 60 * 60 * 1e3;
            default:
                return null;
        }
    }
    var SS, CS, hd = v(()=>{
        X();
        SS = {
            name: "timeout",
            summary: "run a command with a time limit",
            usage: "timeout [OPTION] DURATION COMMAND [ARG]...",
            description: `Start COMMAND, and kill it if still running after DURATION.

DURATION is a number with optional suffix:
  s - seconds (default)
  m - minutes
  h - hours
  d - days`,
            options: [
                "-k, --kill-after=DURATION  send KILL signal after DURATION if still running",
                "-s, --signal=SIGNAL        specify signal to send (default: TERM)",
                "    --preserve-status      exit with same status as COMMAND, even on timeout",
                "    --foreground           run command in foreground",
                "    --help                 display this help and exit"
            ]
        };
        CS = {
            name: "timeout",
            async execute (e, t) {
                if (_(e)) return F(SS);
                let r = 0;
                for(let p = 0; p < e.length; p++){
                    let d = e[p];
                    if (d === "--preserve-status") r = p + 1;
                    else if (d === "--foreground") r = p + 1;
                    else if (d === "-k" || d === "--kill-after") p++, r = p + 1;
                    else if (d.startsWith("--kill-after=")) r = p + 1;
                    else if (d === "-s" || d === "--signal") p++, r = p + 1;
                    else if (d.startsWith("--signal=")) r = p + 1;
                    else {
                        if (d.startsWith("--") && d !== "--") return G("timeout", d);
                        if (d.startsWith("-") && d.length > 1 && d !== "--") if (d.startsWith("-k")) r = p + 1;
                        else if (d.startsWith("-s")) r = p + 1;
                        else return G("timeout", d);
                        else {
                            r = p;
                            break;
                        }
                    }
                }
                let s = e.slice(r);
                if (s.length === 0) return {
                    stdout: "",
                    stderr: `timeout: missing operand
`,
                    exitCode: 1
                };
                let i = s[0], o = AS(i);
                if (o === null) return {
                    stdout: "",
                    stderr: `timeout: invalid time interval '${i}'
`,
                    exitCode: 1
                };
                let a = s.slice(1);
                if (a.length === 0) return {
                    stdout: "",
                    stderr: `timeout: missing operand
`,
                    exitCode: 1
                };
                if (!t.exec) return {
                    stdout: "",
                    stderr: `timeout: exec not available
`,
                    exitCode: 1
                };
                let l = a.map((p)=>p.includes(" ") || p.includes("	") ? `'${p.replace(/'/g, "'\\''")}'` : p).join(" "), c = new Promise((p)=>{
                    setTimeout(()=>p({
                            timedOut: true
                        }), o);
                }), u = t.exec(l, {
                    cwd: t.cwd
                }).then((p)=>({
                        timedOut: false,
                        result: p
                    })), f = await Promise.race([
                    c,
                    u
                ]);
                return f.timedOut ? {
                    stdout: "",
                    stderr: "",
                    exitCode: 124
                } : f.result;
            }
        };
    });
    var md = {};
    V(md, {
        timeCommand: ()=>NS
    });
    function kS(e) {
        let t = Math.floor(e / 3600), n = Math.floor(e % 3600 / 60), r = e % 60;
        return t > 0 ? `${t}:${n.toString().padStart(2, "0")}:${r.toFixed(2).padStart(5, "0")}` : `${n}:${r.toFixed(2).padStart(5, "0")}`;
    }
    var NS, gd = v(()=>{
        NS = {
            name: "time",
            async execute (e, t) {
                let n = "%e %M", r = null, s = false, i = false, o = 0;
                for(; o < e.length;){
                    let m = e[o];
                    if (m === "-f" || m === "--format") {
                        if (o++, o >= e.length) return {
                            stdout: "",
                            stderr: `time: missing argument to '-f'
`,
                            exitCode: 1
                        };
                        n = e[o], o++;
                    } else if (m === "-o" || m === "--output") {
                        if (o++, o >= e.length) return {
                            stdout: "",
                            stderr: `time: missing argument to '-o'
`,
                            exitCode: 1
                        };
                        r = e[o], o++;
                    } else if (m === "-a" || m === "--append") s = true, o++;
                    else if (m === "-v" || m === "--verbose") n = `Command being timed: %C
Elapsed (wall clock) time: %e seconds
Maximum resident set size (kbytes): %M`, o++;
                    else if (m === "-p" || m === "--portability") i = true, o++;
                    else if (m === "--") {
                        o++;
                        break;
                    } else if (m.startsWith("-")) o++;
                    else break;
                }
                let a = e.slice(o);
                if (a.length === 0) return {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                };
                let l = performance.now(), c = a.join(" "), u;
                try {
                    if (!t.exec) return {
                        stdout: "",
                        stderr: `time: exec not available
`,
                        exitCode: 1
                    };
                    u = await t.exec(c, {
                        env: t.env,
                        cwd: t.cwd
                    });
                } catch (m) {
                    u = {
                        stdout: "",
                        stderr: `time: ${m.message}
`,
                        exitCode: 127
                    };
                }
                let p = (performance.now() - l) / 1e3, d;
                if (i ? d = `real ${p.toFixed(2)}
user 0.00
sys 0.00
` : (d = n.replace(/%e/g, p.toFixed(2)).replace(/%E/g, kS(p)).replace(/%M/g, "0").replace(/%S/g, "0.00").replace(/%U/g, "0.00").replace(/%P/g, "0%").replace(/%C/g, c), d.endsWith(`
`) || (d += `
`)), r) try {
                    let m = t.fs.resolvePath(t.cwd, r);
                    if (s && await t.fs.exists(m)) {
                        let h = await t.fs.readFile(m);
                        await t.fs.writeFile(m, h + d);
                    } else await t.fs.writeFile(m, d);
                } catch (m) {
                    return {
                        stdout: u.stdout,
                        stderr: u.stderr + `time: cannot write to '${r}': ${m.message}
`,
                        exitCode: u.exitCode
                    };
                }
                else u = {
                    ...u,
                    stderr: u.stderr + d
                };
                return u;
            }
        };
    });
    var yd = {};
    V(yd, {
        seqCommand: ()=>vS
    });
    var vS, bd = v(()=>{
        vS = {
            name: "seq",
            async execute (e) {
                let t = `
`, n = false, r = [], s = 0;
                for(; s < e.length;){
                    let m = e[s];
                    if (m === "-s" && s + 1 < e.length) {
                        t = e[s + 1], s += 2;
                        continue;
                    }
                    if (m === "-w") {
                        n = true, s++;
                        continue;
                    }
                    if (m === "--") {
                        s++;
                        break;
                    }
                    if (m.startsWith("-") && m !== "-") {
                        if (m.startsWith("-s") && m.length > 2) {
                            t = m.slice(2), s++;
                            continue;
                        }
                        if ((m === "-ws" || m === "-sw") && (n = true, s + 1 < e.length)) {
                            t = e[s + 1], s += 2;
                            continue;
                        }
                    }
                    r.push(m), s++;
                }
                for(; s < e.length;)r.push(e[s]), s++;
                if (r.length === 0) return {
                    stdout: "",
                    stderr: `seq: missing operand
`,
                    exitCode: 1
                };
                let i = 1, o = 1, a;
                if (r.length === 1 ? a = parseFloat(r[0]) : r.length === 2 ? (i = parseFloat(r[0]), a = parseFloat(r[1])) : (i = parseFloat(r[0]), o = parseFloat(r[1]), a = parseFloat(r[2])), Number.isNaN(i) || Number.isNaN(o) || Number.isNaN(a)) return {
                    stdout: "",
                    stderr: `seq: invalid floating point argument: '${r.find((h)=>Number.isNaN(parseFloat(h)))}'
`,
                    exitCode: 1
                };
                if (o === 0) return {
                    stdout: "",
                    stderr: `seq: invalid Zero increment value: '0'
`,
                    exitCode: 1
                };
                let l = [], c = (m)=>{
                    let h = String(m), g = h.indexOf(".");
                    return g === -1 ? 0 : h.length - g - 1;
                }, u = Math.max(c(i), c(o), c(a)), f = 1e5, p = 0;
                if (o > 0) for(let m = i; m <= a + 1e-10 && !(p++ > f); m += o)l.push(u > 0 ? m.toFixed(u) : String(Math.round(m)));
                else for(let m = i; m >= a - 1e-10 && !(p++ > f); m += o)l.push(u > 0 ? m.toFixed(u) : String(Math.round(m)));
                if (n && l.length > 0) {
                    let m = Math.max(...l.map((h)=>h.replace("-", "").length));
                    for(let h = 0; h < l.length; h++){
                        let g = l[h].startsWith("-"), y = (g ? l[h].slice(1) : l[h]).padStart(m, "0");
                        l[h] = g ? `-${y}` : y;
                    }
                }
                let d = l.join(t);
                return {
                    stdout: d ? `${d}
` : "",
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var wd = {};
    V(wd, {
        exprCommand: ()=>$S
    });
    function IS(e) {
        if (e.length === 1) return e[0];
        let t = 0;
        function n() {
            let c = r();
            for(; t < e.length && e[t] === "|";){
                t++;
                let u = r();
                if (c !== "0" && c !== "") return c;
                c = u;
            }
            return c;
        }
        function r() {
            let c = s();
            for(; t < e.length && e[t] === "&";){
                t++;
                let u = s();
                (c === "0" || c === "" || u === "0" || u === "") && (c = "0");
            }
            return c;
        }
        function s() {
            let c = i();
            for(; t < e.length;){
                let u = e[t];
                if ([
                    "=",
                    "!=",
                    "<",
                    ">",
                    "<=",
                    ">="
                ].includes(u)) {
                    t++;
                    let f = i(), p = parseInt(c, 10), d = parseInt(f, 10), m = !Number.isNaN(p) && !Number.isNaN(d), h;
                    u === "=" ? h = m ? p === d : c === f : u === "!=" ? h = m ? p !== d : c !== f : u === "<" ? h = m ? p < d : c < f : u === ">" ? h = m ? p > d : c > f : u === "<=" ? h = m ? p <= d : c <= f : h = m ? p >= d : c >= f, c = h ? "1" : "0";
                } else break;
            }
            return c;
        }
        function i() {
            let c = o();
            for(; t < e.length;){
                let u = e[t];
                if (u === "+" || u === "-") {
                    t++;
                    let f = o(), p = parseInt(c, 10), d = parseInt(f, 10);
                    if (Number.isNaN(p) || Number.isNaN(d)) throw new Error("non-integer argument");
                    c = String(u === "+" ? p + d : p - d);
                } else break;
            }
            return c;
        }
        function o() {
            let c = a();
            for(; t < e.length;){
                let u = e[t];
                if (u === "*" || u === "/" || u === "%") {
                    t++;
                    let f = a(), p = parseInt(c, 10), d = parseInt(f, 10);
                    if (Number.isNaN(p) || Number.isNaN(d)) throw new Error("non-integer argument");
                    if ((u === "/" || u === "%") && d === 0) throw new Error("division by zero");
                    u === "*" ? c = String(p * d) : u === "/" ? c = String(Math.trunc(p / d)) : c = String(p % d);
                } else break;
            }
            return c;
        }
        function a() {
            let c = l();
            for(; t < e.length && e[t] === ":";){
                t++;
                let u = l(), f = new RegExp(`^${u}`), p = c.match(f);
                p ? c = p[1] !== void 0 ? p[1] : String(p[0].length) : c = "0";
            }
            return c;
        }
        function l() {
            if (t >= e.length) throw new Error("syntax error");
            let c = e[t];
            if (c === "match") {
                t++;
                let u = l(), f = l(), p = new RegExp(f), d = u.match(p);
                return d ? d[1] !== void 0 ? d[1] : String(d[0].length) : "0";
            }
            if (c === "substr") {
                t++;
                let u = l(), f = parseInt(l(), 10), p = parseInt(l(), 10);
                if (Number.isNaN(f) || Number.isNaN(p)) throw new Error("non-integer argument");
                return u.substring(f - 1, f - 1 + p);
            }
            if (c === "index") {
                t++;
                let u = l(), f = l();
                for(let p = 0; p < u.length; p++)if (f.includes(u[p])) return String(p + 1);
                return "0";
            }
            if (c === "length") {
                t++;
                let u = l();
                return String(u.length);
            }
            if (c === "(") {
                t++;
                let u = n();
                if (t >= e.length || e[t] !== ")") throw new Error("syntax error");
                return t++, u;
            }
            return t++, c;
        }
        return n();
    }
    var $S, xd = v(()=>{
        $S = {
            name: "expr",
            async execute (e, t) {
                if (e.length === 0) return {
                    stdout: "",
                    stderr: `expr: missing operand
`,
                    exitCode: 2
                };
                try {
                    let n = IS(e), r = n === "0" || n === "" ? 1 : 0;
                    return {
                        stdout: `${n}
`,
                        stderr: "",
                        exitCode: r
                    };
                } catch (n) {
                    return {
                        stdout: "",
                        stderr: `expr: ${n.message}
`,
                        exitCode: 2
                    };
                }
            }
        };
    });
    function PS(e) {
        function t(d, m) {
            return d << m | d >>> 32 - m;
        }
        let n = new Uint32Array([
            3614090360,
            3905402710,
            606105819,
            3250441966,
            4118548399,
            1200080426,
            2821735955,
            4249261313,
            1770035416,
            2336552879,
            4294925233,
            2304563134,
            1804603682,
            4254626195,
            2792965006,
            1236535329,
            4129170786,
            3225465664,
            643717713,
            3921069994,
            3593408605,
            38016083,
            3634488961,
            3889429448,
            568446438,
            3275163606,
            4107603335,
            1163531501,
            2850285829,
            4243563512,
            1735328473,
            2368359562,
            4294588738,
            2272392833,
            1839030562,
            4259657740,
            2763975236,
            1272893353,
            4139469664,
            3200236656,
            681279174,
            3936430074,
            3572445317,
            76029189,
            3654602809,
            3873151461,
            530742520,
            3299628645,
            4096336452,
            1126891415,
            2878612391,
            4237533241,
            1700485571,
            2399980690,
            4293915773,
            2240044497,
            1873313359,
            4264355552,
            2734768916,
            1309151649,
            4149444226,
            3174756917,
            718787259,
            3951481745
        ]), r = [
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21
        ], s = e.length * 8, i = (e.length % 64 < 56 ? 56 : 120) - e.length % 64, o = new Uint8Array(e.length + i + 8);
        o.set(e), o[e.length] = 128;
        let a = new DataView(o.buffer);
        a.setUint32(o.length - 8, s >>> 0, true), a.setUint32(o.length - 4, Math.floor(s / 4294967296), true);
        let l = 1732584193, c = 4023233417, u = 2562383102, f = 271733878;
        for(let d = 0; d < o.length; d += 64){
            let m = new Uint32Array(16);
            for(let w = 0; w < 16; w++)m[w] = a.getUint32(d + w * 4, true);
            let h = l, g = c, b = u, y = f;
            for(let w = 0; w < 64; w++){
                let E, C;
                w < 16 ? (E = g & b | ~g & y, C = w) : w < 32 ? (E = y & g | ~y & b, C = (5 * w + 1) % 16) : w < 48 ? (E = g ^ b ^ y, C = (3 * w + 5) % 16) : (E = b ^ (g | ~y), C = 7 * w % 16), E = E + h + n[w] + m[C] >>> 0, h = y, y = b, b = g, g = g + t(E, r[w]) >>> 0;
            }
            l = l + h >>> 0, c = c + g >>> 0, u = u + b >>> 0, f = f + y >>> 0;
        }
        let p = new Uint8Array(16);
        return new DataView(p.buffer).setUint32(0, l, true), new DataView(p.buffer).setUint32(4, c, true), new DataView(p.buffer).setUint32(8, u, true), new DataView(p.buffer).setUint32(12, f, true), Array.from(p).map((d)=>d.toString(16).padStart(2, "0")).join("");
    }
    async function Ed(e, t) {
        if (e === "md5") return PS(t);
        let n = await globalThis.crypto.subtle.digest(RS[e], new Uint8Array(t).buffer);
        return Array.from(new Uint8Array(n)).map((r)=>r.toString(16).padStart(2, "0")).join("");
    }
    function qn(e, t, n) {
        let r = {
            name: e,
            summary: n,
            usage: `${e} [OPTION]... [FILE]...`,
            options: [
                "-c, --check    read checksums from FILEs and check them",
                "    --help     display this help and exit"
            ]
        };
        return {
            name: e,
            async execute (s, i) {
                if (_(s)) return F(r);
                let o = false, a = [];
                for (let f of s)if (f === "-c" || f === "--check") o = true;
                else if (!(f === "-b" || f === "-t" || f === "--binary" || f === "--text")) {
                    if (f.startsWith("-") && f !== "-") return G(e, f);
                    a.push(f);
                }
                a.length === 0 && a.push("-");
                let l = async (f)=>{
                    if (f === "-") return Uint8Array.from(i.stdin, (p)=>p.charCodeAt(0));
                    try {
                        return await i.fs.readFileBuffer(i.fs.resolvePath(i.cwd, f));
                    } catch  {
                        return null;
                    }
                };
                if (o) {
                    let f = 0, p = "";
                    for (let d of a){
                        let m = d === "-" ? i.stdin : await i.fs.readFile(i.fs.resolvePath(i.cwd, d)).catch(()=>null);
                        if (m === null) return {
                            stdout: "",
                            stderr: `${e}: ${d}: No such file or directory
`,
                            exitCode: 1
                        };
                        for (let h of m.split(`
`)){
                            let g = h.match(/^([a-fA-F0-9]+)\s+[* ]?(.+)$/);
                            if (!g) continue;
                            let [, b, y] = g, w = await l(y);
                            if (w === null) {
                                p += `${y}: FAILED open or read
`, f++;
                                continue;
                            }
                            let E = await Ed(t, w) === b.toLowerCase();
                            p += `${y}: ${E ? "OK" : "FAILED"}
`, E || f++;
                        }
                    }
                    return f > 0 && (p += `${e}: WARNING: ${f} computed checksum${f > 1 ? "s" : ""} did NOT match
`), {
                        stdout: p,
                        stderr: "",
                        exitCode: f > 0 ? 1 : 0
                    };
                }
                let c = "", u = 0;
                for (let f of a){
                    let p = await l(f);
                    if (p === null) {
                        c += `${e}: ${f}: No such file or directory
`, u = 1;
                        continue;
                    }
                    c += `${await Ed(t, p)}  ${f}
`;
                }
                return {
                    stdout: c,
                    stderr: "",
                    exitCode: u
                };
            }
        };
    }
    var RS, Os = v(()=>{
        X();
        RS = {
            sha1: "SHA-1",
            sha256: "SHA-256"
        };
    });
    var Sd = {};
    V(Sd, {
        md5sumCommand: ()=>TS
    });
    var TS, Ad = v(()=>{
        Os();
        TS = qn("md5sum", "md5", "compute MD5 message digest");
    });
    var Cd = {};
    V(Cd, {
        sha1sumCommand: ()=>OS
    });
    var OS, Nd = v(()=>{
        Os();
        OS = qn("sha1sum", "sha1", "compute SHA1 message digest");
    });
    var kd = {};
    V(kd, {
        sha256sumCommand: ()=>DS
    });
    var DS, vd = v(()=>{
        Os();
        DS = qn("sha256sum", "sha256", "compute SHA256 message digest");
    });
    var $d = Kr((zo)=>{
        zo.read = function(e, t, n, r, s) {
            var i, o, a = s * 8 - r - 1, l = (1 << a) - 1, c = l >> 1, u = -7, f = n ? s - 1 : 0, p = n ? -1 : 1, d = e[t + f];
            for(f += p, i = d & (1 << -u) - 1, d >>= -u, u += a; u > 0; i = i * 256 + e[t + f], f += p, u -= 8);
            for(o = i & (1 << -u) - 1, i >>= -u, u += r; u > 0; o = o * 256 + e[t + f], f += p, u -= 8);
            if (i === 0) i = 1 - c;
            else {
                if (i === l) return o ? NaN : (d ? -1 : 1) * (1 / 0);
                o = o + Math.pow(2, r), i = i - c;
            }
            return (d ? -1 : 1) * o * Math.pow(2, i - r);
        };
        zo.write = function(e, t, n, r, s, i) {
            var o, a, l, c = i * 8 - s - 1, u = (1 << c) - 1, f = u >> 1, p = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : i - 1, m = r ? 1 : -1, h = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
            for(t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, o = u) : (o = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), o + f >= 1 ? t += p / l : t += p * Math.pow(2, 1 - f), t * l >= 2 && (o++, l /= 2), o + f >= u ? (a = 0, o = u) : o + f >= 1 ? (a = (t * l - 1) * Math.pow(2, s), o = o + f) : (a = t * Math.pow(2, f - 1) * Math.pow(2, s), o = 0)); s >= 8; e[n + d] = a & 255, d += m, a /= 256, s -= 8);
            for(o = o << s | a, c += s; c > 0; e[n + d] = o & 255, d += m, o /= 256, c -= 8);
            e[n + d - m] |= h * 128;
        };
    });
    function Id(e, t = "utf-8") {
        switch(t.toLowerCase()){
            case "utf-8":
            case "utf8":
                return typeof globalThis.TextDecoder < "u" ? new globalThis.TextDecoder("utf-8").decode(e) : _S(e);
            case "utf-16le":
                return LS(e);
            case "ascii":
                return MS(e);
            case "latin1":
            case "iso-8859-1":
                return WS(e);
            case "windows-1252":
                return BS(e);
            default:
                throw new RangeError(`Encoding '${t}' not supported`);
        }
    }
    function _S(e) {
        let t = "", n = 0;
        for(; n < e.length;){
            let r = e[n++];
            if (r < 128) t += String.fromCharCode(r);
            else if (r < 224) {
                let s = e[n++] & 63;
                t += String.fromCharCode((r & 31) << 6 | s);
            } else if (r < 240) {
                let s = e[n++] & 63, i = e[n++] & 63;
                t += String.fromCharCode((r & 15) << 12 | s << 6 | i);
            } else {
                let s = e[n++] & 63, i = e[n++] & 63, o = e[n++] & 63, a = (r & 7) << 18 | s << 12 | i << 6 | o;
                a -= 65536, t += String.fromCharCode(55296 + (a >> 10 & 1023), 56320 + (a & 1023));
            }
        }
        return t;
    }
    function LS(e) {
        let t = "";
        for(let n = 0; n < e.length; n += 2)t += String.fromCharCode(e[n] | e[n + 1] << 8);
        return t;
    }
    function MS(e) {
        return String.fromCharCode(...e.map((t)=>t & 127));
    }
    function WS(e) {
        return String.fromCharCode(...e);
    }
    function BS(e) {
        let t = "";
        for (let n of e)n >= 128 && n <= 159 && jo[n] ? t += jo[n] : t += String.fromCharCode(n);
        return t;
    }
    var jo, FS, Rd = v(()=>{
        jo = {
            128: "",
            130: "",
            131: "",
            132: "",
            133: "",
            134: "",
            135: "",
            136: "",
            137: "",
            138: "",
            139: "",
            140: "",
            142: "",
            145: "",
            146: "",
            147: "",
            148: "",
            149: "",
            150: "",
            151: "",
            152: "",
            153: "",
            154: "",
            155: "",
            156: "",
            158: "",
            159: ""
        }, FS = {};
        for (let [e, t] of Object.entries(jo))FS[t] = Number.parseInt(e);
    });
    function ct(e) {
        return new DataView(e.buffer, e.byteOffset);
    }
    var Td, Pe, Gn, De, Od, Dd, Fd, ut, $r = v(()=>{
        Kl($d());
        Rd();
        Td = {
            len: 1,
            get (e, t) {
                return ct(e).getUint8(t);
            },
            put (e, t, n) {
                return ct(e).setUint8(t, n), t + 1;
            }
        }, Pe = {
            len: 2,
            get (e, t) {
                return ct(e).getUint16(t, true);
            },
            put (e, t, n) {
                return ct(e).setUint16(t, n, true), t + 2;
            }
        }, Gn = {
            len: 2,
            get (e, t) {
                return ct(e).getUint16(t);
            },
            put (e, t, n) {
                return ct(e).setUint16(t, n), t + 2;
            }
        }, De = {
            len: 4,
            get (e, t) {
                return ct(e).getUint32(t, true);
            },
            put (e, t, n) {
                return ct(e).setUint32(t, n, true), t + 4;
            }
        }, Od = {
            len: 4,
            get (e, t) {
                return ct(e).getUint32(t);
            },
            put (e, t, n) {
                return ct(e).setUint32(t, n), t + 4;
            }
        }, Dd = {
            len: 4,
            get (e, t) {
                return ct(e).getInt32(t);
            },
            put (e, t, n) {
                return ct(e).setInt32(t, n), t + 4;
            }
        }, Fd = {
            len: 8,
            get (e, t) {
                return ct(e).getBigUint64(t, true);
            },
            put (e, t, n) {
                return ct(e).setBigUint64(t, n, true), t + 8;
            }
        }, ut = class {
            constructor(t, n){
                this.len = t, this.encoding = n;
            }
            get(t, n = 0) {
                let r = t.subarray(n, n + this.len);
                return Id(r, this.encoding);
            }
        };
    });
    var zS, ke, gn, Ir = v(()=>{
        zS = "End-Of-Stream", ke = class extends Error {
            constructor(){
                super(zS), this.name = "EndOfStreamError";
            }
        }, gn = class extends Error {
            constructor(t = "The operation was aborted"){
                super(t), this.name = "AbortError";
            }
        };
    });
    var _d = v(()=>{});
    var yn, Ds = v(()=>{
        Ir();
        yn = class {
            constructor(){
                this.endOfStream = false, this.interrupted = false, this.peekQueue = [];
            }
            async peek(t, n = false) {
                let r = await this.read(t, n);
                return this.peekQueue.push(t.subarray(0, r)), r;
            }
            async read(t, n = false) {
                if (t.length === 0) return 0;
                let r = this.readFromPeekBuffer(t);
                if (this.endOfStream || (r += await this.readRemainderFromStream(t.subarray(r), n)), r === 0 && !n) throw new ke();
                return r;
            }
            readFromPeekBuffer(t) {
                let n = t.length, r = 0;
                for(; this.peekQueue.length > 0 && n > 0;){
                    let s = this.peekQueue.pop();
                    if (!s) throw new Error("peekData should be defined");
                    let i = Math.min(s.length, n);
                    t.set(s.subarray(0, i), r), r += i, n -= i, i < s.length && this.peekQueue.push(s.subarray(i));
                }
                return r;
            }
            async readRemainderFromStream(t, n) {
                let r = 0;
                for(; r < t.length && !this.endOfStream;){
                    if (this.interrupted) throw new gn();
                    let s = await this.readFromStream(t.subarray(r), n);
                    if (s === 0) break;
                    r += s;
                }
                if (!n && r < t.length) throw new ke();
                return r;
            }
        };
    });
    var Ld = v(()=>{
        Ir();
        _d();
        Ds();
    });
    var Fs, Md = v(()=>{
        Ds();
        Fs = class extends yn {
            constructor(t){
                super(), this.reader = t;
            }
            async abort() {
                return this.close();
            }
            async close() {
                this.reader.releaseLock();
            }
        };
    });
    var Rr, Ho = v(()=>{
        Md();
        Rr = class extends Fs {
            async readFromStream(t, n) {
                if (t.length === 0) return 0;
                let r = await this.reader.read(new Uint8Array(t.length), {
                    min: n ? void 0 : t.length
                });
                return r.done && (this.endOfStream = r.done), r.value ? (t.set(r.value), r.value.length) : 0;
            }
        };
    });
    var Zn, Vo = v(()=>{
        Ir();
        Ds();
        Zn = class extends yn {
            constructor(t){
                super(), this.reader = t, this.buffer = null;
            }
            writeChunk(t, n) {
                let r = Math.min(n.length, t.length);
                return t.set(n.subarray(0, r)), r < n.length ? this.buffer = n.subarray(r) : this.buffer = null, r;
            }
            async readFromStream(t, n) {
                if (t.length === 0) return 0;
                let r = 0;
                for(this.buffer && (r += this.writeChunk(t, this.buffer)); r < t.length && !this.endOfStream;){
                    let s = await this.reader.read();
                    if (s.done) {
                        this.endOfStream = true;
                        break;
                    }
                    s.value && (r += this.writeChunk(t.subarray(r), s.value));
                }
                if (!n && r === 0 && this.endOfStream) throw new ke();
                return r;
            }
            abort() {
                return this.interrupted = true, this.reader.cancel();
            }
            async close() {
                await this.abort(), this.reader.releaseLock();
            }
        };
    });
    function qo(e) {
        try {
            let t = e.getReader({
                mode: "byob"
            });
            return t instanceof ReadableStreamDefaultReader ? new Zn(t) : new Rr(t);
        } catch (t) {
            if (t instanceof TypeError) return new Zn(e.getReader());
            throw t;
        }
    }
    var Wd = v(()=>{
        Ho();
        Vo();
    });
    var bn = v(()=>{
        Ir();
        Ld();
        Ho();
        Vo();
        Wd();
    });
    var Gt, Pr = v(()=>{
        bn();
        Gt = class {
            constructor(t){
                this.numBuffer = new Uint8Array(8), this.position = 0, this.onClose = t?.onClose, t?.abortSignal && t.abortSignal.addEventListener("abort", ()=>{
                    this.abort();
                });
            }
            async readToken(t, n = this.position) {
                let r = new Uint8Array(t.len);
                if (await this.readBuffer(r, {
                    position: n
                }) < t.len) throw new ke();
                return t.get(r, 0);
            }
            async peekToken(t, n = this.position) {
                let r = new Uint8Array(t.len);
                if (await this.peekBuffer(r, {
                    position: n
                }) < t.len) throw new ke();
                return t.get(r, 0);
            }
            async readNumber(t) {
                if (await this.readBuffer(this.numBuffer, {
                    length: t.len
                }) < t.len) throw new ke();
                return t.get(this.numBuffer, 0);
            }
            async peekNumber(t) {
                if (await this.peekBuffer(this.numBuffer, {
                    length: t.len
                }) < t.len) throw new ke();
                return t.get(this.numBuffer, 0);
            }
            async ignore(t) {
                if (this.fileInfo.size !== void 0) {
                    let n = this.fileInfo.size - this.position;
                    if (t > n) return this.position += n, n;
                }
                return this.position += t, t;
            }
            async close() {
                await this.abort(), await this.onClose?.();
            }
            normalizeOptions(t, n) {
                if (!this.supportsRandomAccess() && n && n.position !== void 0 && n.position < this.position) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
                return {
                    mayBeLess: false,
                    offset: 0,
                    length: t.length,
                    position: this.position,
                    ...n
                };
            }
            abort() {
                return Promise.resolve();
            }
        };
    });
    var HS, _s, Bd = v(()=>{
        Pr();
        bn();
        HS = 256e3, _s = class extends Gt {
            constructor(t, n){
                super(n), this.streamReader = t, this.fileInfo = n?.fileInfo ?? {};
            }
            async readBuffer(t, n) {
                let r = this.normalizeOptions(t, n), s = r.position - this.position;
                if (s > 0) return await this.ignore(s), this.readBuffer(t, n);
                if (s < 0) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
                if (r.length === 0) return 0;
                let i = await this.streamReader.read(t.subarray(0, r.length), r.mayBeLess);
                if (this.position += i, (!n || !n.mayBeLess) && i < r.length) throw new ke();
                return i;
            }
            async peekBuffer(t, n) {
                let r = this.normalizeOptions(t, n), s = 0;
                if (r.position) {
                    let i = r.position - this.position;
                    if (i > 0) {
                        let o = new Uint8Array(r.length + i);
                        return s = await this.peekBuffer(o, {
                            mayBeLess: r.mayBeLess
                        }), t.set(o.subarray(i)), s - i;
                    }
                    if (i < 0) throw new Error("Cannot peek from a negative offset in a stream");
                }
                if (r.length > 0) {
                    try {
                        s = await this.streamReader.peek(t.subarray(0, r.length), r.mayBeLess);
                    } catch (i) {
                        if (n?.mayBeLess && i instanceof ke) return 0;
                        throw i;
                    }
                    if (!r.mayBeLess && s < r.length) throw new ke();
                }
                return s;
            }
            async ignore(t) {
                let n = Math.min(HS, t), r = new Uint8Array(n), s = 0;
                for(; s < t;){
                    let i = t - s, o = await this.readBuffer(r, {
                        length: Math.min(n, i)
                    });
                    if (o < 0) return o;
                    s += o;
                }
                return s;
            }
            abort() {
                return this.streamReader.abort();
            }
            async close() {
                return this.streamReader.close();
            }
            supportsRandomAccess() {
                return false;
            }
        };
    });
    var Ls, Ud = v(()=>{
        bn();
        Pr();
        Ls = class extends Gt {
            constructor(t, n){
                super(n), this.uint8Array = t, this.fileInfo = {
                    ...n?.fileInfo ?? {},
                    size: t.length
                };
            }
            async readBuffer(t, n) {
                n?.position && (this.position = n.position);
                let r = await this.peekBuffer(t, n);
                return this.position += r, r;
            }
            async peekBuffer(t, n) {
                let r = this.normalizeOptions(t, n), s = Math.min(this.uint8Array.length - r.position, r.length);
                if (!r.mayBeLess && s < r.length) throw new ke();
                return t.set(this.uint8Array.subarray(r.position, r.position + s)), s;
            }
            close() {
                return super.close();
            }
            supportsRandomAccess() {
                return true;
            }
            setPosition(t) {
                this.position = t;
            }
        };
    });
    var Ms, zd = v(()=>{
        bn();
        Pr();
        Ms = class extends Gt {
            constructor(t, n){
                super(n), this.blob = t, this.fileInfo = {
                    ...n?.fileInfo ?? {},
                    size: t.size,
                    mimeType: t.type
                };
            }
            async readBuffer(t, n) {
                n?.position && (this.position = n.position);
                let r = await this.peekBuffer(t, n);
                return this.position += r, r;
            }
            async peekBuffer(t, n) {
                let r = this.normalizeOptions(t, n), s = Math.min(this.blob.size - r.position, r.length);
                if (!r.mayBeLess && s < r.length) throw new ke();
                let i = await this.blob.slice(r.position, r.position + s).arrayBuffer();
                return t.set(new Uint8Array(i)), s;
            }
            close() {
                return super.close();
            }
            supportsRandomAccess() {
                return true;
            }
            setPosition(t) {
                this.position = t;
            }
        };
    });
    function jd(e, t) {
        let n = qo(e), r = t ?? {}, s = r.onClose;
        return r.onClose = async ()=>{
            if (await n.close(), s) return s();
        }, new _s(n, r);
    }
    function Hd(e, t) {
        return new Ls(e, t);
    }
    function Vd(e, t) {
        return new Ms(e, t);
    }
    var qd = v(()=>{
        bn();
        Bd();
        Ud();
        zd();
        bn();
        Pr();
    });
    var Zd = Kr((HP, Gd)=>{
        var Qn = 1e3, Kn = Qn * 60, Xn = Kn * 60, wn = Xn * 24, qS = wn * 7, GS = wn * 365.25;
        Gd.exports = function(e, t) {
            t = t || {};
            var n = typeof e;
            if (n === "string" && e.length > 0) return ZS(e);
            if (n === "number" && isFinite(e)) return t.long ? KS(e) : QS(e);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
        };
        function ZS(e) {
            if (e = String(e), !(e.length > 100)) {
                var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
                if (t) {
                    var n = parseFloat(t[1]), r = (t[2] || "ms").toLowerCase();
                    switch(r){
                        case "years":
                        case "year":
                        case "yrs":
                        case "yr":
                        case "y":
                            return n * GS;
                        case "weeks":
                        case "week":
                        case "w":
                            return n * qS;
                        case "days":
                        case "day":
                        case "d":
                            return n * wn;
                        case "hours":
                        case "hour":
                        case "hrs":
                        case "hr":
                        case "h":
                            return n * Xn;
                        case "minutes":
                        case "minute":
                        case "mins":
                        case "min":
                        case "m":
                            return n * Kn;
                        case "seconds":
                        case "second":
                        case "secs":
                        case "sec":
                        case "s":
                            return n * Qn;
                        case "milliseconds":
                        case "millisecond":
                        case "msecs":
                        case "msec":
                        case "ms":
                            return n;
                        default:
                            return;
                    }
                }
            }
        }
        function QS(e) {
            var t = Math.abs(e);
            return t >= wn ? Math.round(e / wn) + "d" : t >= Xn ? Math.round(e / Xn) + "h" : t >= Kn ? Math.round(e / Kn) + "m" : t >= Qn ? Math.round(e / Qn) + "s" : e + "ms";
        }
        function KS(e) {
            var t = Math.abs(e);
            return t >= wn ? Ws(e, t, wn, "day") : t >= Xn ? Ws(e, t, Xn, "hour") : t >= Kn ? Ws(e, t, Kn, "minute") : t >= Qn ? Ws(e, t, Qn, "second") : e + " ms";
        }
        function Ws(e, t, n, r) {
            var s = t >= n * 1.5;
            return Math.round(e / n) + " " + r + (s ? "s" : "");
        }
    });
    var Kd = Kr((VP, Qd)=>{
        function XS(e) {
            n.debug = n, n.default = n, n.coerce = l, n.disable = o, n.enable = s, n.enabled = a, n.humanize = Zd(), n.destroy = c, Object.keys(e).forEach((u)=>{
                n[u] = e[u];
            }), n.names = [], n.skips = [], n.formatters = {};
            function t(u) {
                let f = 0;
                for(let p = 0; p < u.length; p++)f = (f << 5) - f + u.charCodeAt(p), f |= 0;
                return n.colors[Math.abs(f) % n.colors.length];
            }
            n.selectColor = t;
            function n(u) {
                let f, p = null, d, m;
                function h(...g) {
                    if (!h.enabled) return;
                    let b = h, y = Number(new Date()), w = y - (f || y);
                    b.diff = w, b.prev = f, b.curr = y, f = y, g[0] = n.coerce(g[0]), typeof g[0] != "string" && g.unshift("%O");
                    let E = 0;
                    g[0] = g[0].replace(/%([a-zA-Z%])/g, (A, I)=>{
                        if (A === "%%") return "%";
                        E++;
                        let O = n.formatters[I];
                        if (typeof O == "function") {
                            let L = g[E];
                            A = O.call(b, L), g.splice(E, 1), E--;
                        }
                        return A;
                    }), n.formatArgs.call(b, g), (b.log || n.log).apply(b, g);
                }
                return h.namespace = u, h.useColors = n.useColors(), h.color = n.selectColor(u), h.extend = r, h.destroy = n.destroy, Object.defineProperty(h, "enabled", {
                    enumerable: true,
                    configurable: false,
                    get: ()=>p !== null ? p : (d !== n.namespaces && (d = n.namespaces, m = n.enabled(u)), m),
                    set: (g)=>{
                        p = g;
                    }
                }), typeof n.init == "function" && n.init(h), h;
            }
            function r(u, f) {
                let p = n(this.namespace + (typeof f > "u" ? ":" : f) + u);
                return p.log = this.log, p;
            }
            function s(u) {
                n.save(u), n.namespaces = u, n.names = [], n.skips = [];
                let f = (typeof u == "string" ? u : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
                for (let p of f)p[0] === "-" ? n.skips.push(p.slice(1)) : n.names.push(p);
            }
            function i(u, f) {
                let p = 0, d = 0, m = -1, h = 0;
                for(; p < u.length;)if (d < f.length && (f[d] === u[p] || f[d] === "*")) f[d] === "*" ? (m = d, h = p, d++) : (p++, d++);
                else if (m !== -1) d = m + 1, h++, p = h;
                else return false;
                for(; d < f.length && f[d] === "*";)d++;
                return d === f.length;
            }
            function o() {
                let u = [
                    ...n.names,
                    ...n.skips.map((f)=>"-" + f)
                ].join(",");
                return n.enable(""), u;
            }
            function a(u) {
                for (let f of n.skips)if (i(u, f)) return false;
                for (let f of n.names)if (i(u, f)) return true;
                return false;
            }
            function l(u) {
                return u instanceof Error ? u.stack || u.message : u;
            }
            function c() {
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
            return n.enable(n.load()), n;
        }
        Qd.exports = XS;
    });
    var Xd = Kr((ft, Bs)=>{
        ft.formatArgs = YS;
        ft.save = eA;
        ft.load = tA;
        ft.useColors = JS;
        ft.storage = nA();
        ft.destroy = (()=>{
            let e = false;
            return ()=>{
                e || (e = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
            };
        })();
        ft.colors = [
            "#0000CC",
            "#0000FF",
            "#0033CC",
            "#0033FF",
            "#0066CC",
            "#0066FF",
            "#0099CC",
            "#0099FF",
            "#00CC00",
            "#00CC33",
            "#00CC66",
            "#00CC99",
            "#00CCCC",
            "#00CCFF",
            "#3300CC",
            "#3300FF",
            "#3333CC",
            "#3333FF",
            "#3366CC",
            "#3366FF",
            "#3399CC",
            "#3399FF",
            "#33CC00",
            "#33CC33",
            "#33CC66",
            "#33CC99",
            "#33CCCC",
            "#33CCFF",
            "#6600CC",
            "#6600FF",
            "#6633CC",
            "#6633FF",
            "#66CC00",
            "#66CC33",
            "#9900CC",
            "#9900FF",
            "#9933CC",
            "#9933FF",
            "#99CC00",
            "#99CC33",
            "#CC0000",
            "#CC0033",
            "#CC0066",
            "#CC0099",
            "#CC00CC",
            "#CC00FF",
            "#CC3300",
            "#CC3333",
            "#CC3366",
            "#CC3399",
            "#CC33CC",
            "#CC33FF",
            "#CC6600",
            "#CC6633",
            "#CC9900",
            "#CC9933",
            "#CCCC00",
            "#CCCC33",
            "#FF0000",
            "#FF0033",
            "#FF0066",
            "#FF0099",
            "#FF00CC",
            "#FF00FF",
            "#FF3300",
            "#FF3333",
            "#FF3366",
            "#FF3399",
            "#FF33CC",
            "#FF33FF",
            "#FF6600",
            "#FF6633",
            "#FF9900",
            "#FF9933",
            "#FFCC00",
            "#FFCC33"
        ];
        function JS() {
            if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
            if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
            let e;
            return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(e[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function YS(e) {
            if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + Bs.exports.humanize(this.diff), !this.useColors) return;
            let t = "color: " + this.color;
            e.splice(1, 0, t, "color: inherit");
            let n = 0, r = 0;
            e[0].replace(/%[a-zA-Z%]/g, (s)=>{
                s !== "%%" && (n++, s === "%c" && (r = n));
            }), e.splice(r, 0, t);
        }
        ft.log = console.debug || console.log || (()=>{});
        function eA(e) {
            try {
                e ? ft.storage.setItem("debug", e) : ft.storage.removeItem("debug");
            } catch  {}
        }
        function tA() {
            let e;
            try {
                e = ft.storage.getItem("debug") || ft.storage.getItem("DEBUG");
            } catch  {}
            return !e && typeof process < "u" && "env" in process && (e = define_process_env_default.DEBUG), e;
        }
        function nA() {
            try {
                return localStorage;
            } catch  {}
        }
        Bs.exports = Kd()(ft);
        var { formatters: rA } = Bs.exports;
        rA.j = function(e) {
            try {
                return JSON.stringify(e);
            } catch (t) {
                return "[UnexpectedJSONParseError]: " + t.message;
            }
        };
    });
    var xn, Go, Jd, Yd, eh, th = v(()=>{
        $r();
        xn = {
            LocalFileHeader: 67324752,
            DataDescriptor: 134695760,
            CentralFileHeader: 33639248,
            EndOfCentralDirectory: 101010256
        }, Go = {
            get (e) {
                return {
                    signature: De.get(e, 0),
                    compressedSize: De.get(e, 8),
                    uncompressedSize: De.get(e, 12)
                };
            },
            len: 16
        }, Jd = {
            get (e) {
                let t = Pe.get(e, 6);
                return {
                    signature: De.get(e, 0),
                    minVersion: Pe.get(e, 4),
                    dataDescriptor: !!(t & 8),
                    compressedMethod: Pe.get(e, 8),
                    compressedSize: De.get(e, 18),
                    uncompressedSize: De.get(e, 22),
                    filenameLength: Pe.get(e, 26),
                    extraFieldLength: Pe.get(e, 28),
                    filename: null
                };
            },
            len: 30
        }, Yd = {
            get (e) {
                return {
                    signature: De.get(e, 0),
                    nrOfThisDisk: Pe.get(e, 4),
                    nrOfThisDiskWithTheStart: Pe.get(e, 6),
                    nrOfEntriesOnThisDisk: Pe.get(e, 8),
                    nrOfEntriesOfSize: Pe.get(e, 10),
                    sizeOfCd: De.get(e, 12),
                    offsetOfStartOfCd: De.get(e, 16),
                    zipFileCommentLength: Pe.get(e, 20)
                };
            },
            len: 22
        }, eh = {
            get (e) {
                let t = Pe.get(e, 8);
                return {
                    signature: De.get(e, 0),
                    minVersion: Pe.get(e, 6),
                    dataDescriptor: !!(t & 8),
                    compressedMethod: Pe.get(e, 10),
                    compressedSize: De.get(e, 20),
                    uncompressedSize: De.get(e, 24),
                    filenameLength: Pe.get(e, 28),
                    extraFieldLength: Pe.get(e, 30),
                    fileCommentLength: Pe.get(e, 32),
                    relativeOffsetOfLocalHeader: De.get(e, 42),
                    filename: null
                };
            },
            len: 46
        };
    });
    function rh(e) {
        let t = new Uint8Array(De.len);
        return De.put(t, 0, e), t;
    }
    function iA(e, t) {
        let n = e.length, r = t.length;
        if (r > n) return -1;
        for(let s = 0; s <= n - r; s++){
            let i = true;
            for(let o = 0; o < r; o++)if (e[s + o] !== t[o]) {
                i = false;
                break;
            }
            if (i) return s;
        }
        return -1;
    }
    function oA(e) {
        let t = e.reduce((s, i)=>s + i.length, 0), n = new Uint8Array(t), r = 0;
        for (let s of e)n.set(s, r), r += s.length;
        return n;
    }
    var nh, Mt, Zo, sA, Us, Tr, sh = v(()=>{
        $r();
        nh = Kl(Xd());
        th();
        Mt = (0, nh.default)("tokenizer:inflate"), Zo = 256 * 1024, sA = rh(xn.DataDescriptor), Us = rh(xn.EndOfCentralDirectory), Tr = class e {
            constructor(t){
                this.tokenizer = t, this.syncBuffer = new Uint8Array(Zo);
            }
            async isZip() {
                return await this.peekSignature() === xn.LocalFileHeader;
            }
            peekSignature() {
                return this.tokenizer.peekToken(De);
            }
            async findEndOfCentralDirectoryLocator() {
                let t = this.tokenizer, n = Math.min(16 * 1024, t.fileInfo.size), r = this.syncBuffer.subarray(0, n);
                await this.tokenizer.readBuffer(r, {
                    position: t.fileInfo.size - n
                });
                for(let s = r.length - 4; s >= 0; s--)if (r[s] === Us[0] && r[s + 1] === Us[1] && r[s + 2] === Us[2] && r[s + 3] === Us[3]) return t.fileInfo.size - n + s;
                return -1;
            }
            async readCentralDirectory() {
                if (!this.tokenizer.supportsRandomAccess()) {
                    Mt("Cannot reading central-directory without random-read support");
                    return;
                }
                Mt("Reading central-directory...");
                let t = this.tokenizer.position, n = await this.findEndOfCentralDirectoryLocator();
                if (n > 0) {
                    Mt("Central-directory 32-bit signature found");
                    let r = await this.tokenizer.readToken(Yd, n), s = [];
                    this.tokenizer.setPosition(r.offsetOfStartOfCd);
                    for(let i = 0; i < r.nrOfEntriesOfSize; ++i){
                        let o = await this.tokenizer.readToken(eh);
                        if (o.signature !== xn.CentralFileHeader) throw new Error("Expected Central-File-Header signature");
                        o.filename = await this.tokenizer.readToken(new ut(o.filenameLength, "utf-8")), await this.tokenizer.ignore(o.extraFieldLength), await this.tokenizer.ignore(o.fileCommentLength), s.push(o), Mt(`Add central-directory file-entry: n=${i + 1}/${s.length}: filename=${s[i].filename}`);
                    }
                    return this.tokenizer.setPosition(t), s;
                }
                this.tokenizer.setPosition(t);
            }
            async unzip(t) {
                let n = await this.readCentralDirectory();
                if (n) return this.iterateOverCentralDirectory(n, t);
                let r = false;
                do {
                    let s = await this.readLocalFileHeader();
                    if (!s) break;
                    let i = t(s);
                    r = !!i.stop;
                    let o;
                    if (await this.tokenizer.ignore(s.extraFieldLength), s.dataDescriptor && s.compressedSize === 0) {
                        let a = [], l = Zo;
                        Mt("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
                        let c = -1;
                        for(; c < 0 && l === Zo;){
                            l = await this.tokenizer.peekBuffer(this.syncBuffer, {
                                mayBeLess: true
                            }), c = iA(this.syncBuffer.subarray(0, l), sA);
                            let u = c >= 0 ? c : l;
                            if (i.handler) {
                                let f = new Uint8Array(u);
                                await this.tokenizer.readBuffer(f), a.push(f);
                            } else await this.tokenizer.ignore(u);
                        }
                        Mt(`Found data-descriptor-signature at pos=${this.tokenizer.position}`), i.handler && await this.inflate(s, oA(a), i.handler);
                    } else i.handler ? (Mt(`Reading compressed-file-data: ${s.compressedSize} bytes`), o = new Uint8Array(s.compressedSize), await this.tokenizer.readBuffer(o), await this.inflate(s, o, i.handler)) : (Mt(`Ignoring compressed-file-data: ${s.compressedSize} bytes`), await this.tokenizer.ignore(s.compressedSize));
                    if (Mt(`Reading data-descriptor at pos=${this.tokenizer.position}`), s.dataDescriptor && (await this.tokenizer.readToken(Go)).signature !== 134695760) throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - Go.len}`);
                }while (!r);
            }
            async iterateOverCentralDirectory(t, n) {
                for (let r of t){
                    let s = n(r);
                    if (s.handler) {
                        this.tokenizer.setPosition(r.relativeOffsetOfLocalHeader);
                        let i = await this.readLocalFileHeader();
                        if (i) {
                            await this.tokenizer.ignore(i.extraFieldLength);
                            let o = new Uint8Array(r.compressedSize);
                            await this.tokenizer.readBuffer(o), await this.inflate(i, o, s.handler);
                        }
                    }
                    if (s.stop) break;
                }
            }
            async inflate(t, n, r) {
                if (t.compressedMethod === 0) return r(n);
                if (t.compressedMethod !== 8) throw new Error(`Unsupported ZIP compression method: ${t.compressedMethod}`);
                Mt(`Decompress filename=${t.filename}, compressed-size=${n.length}`);
                let s = await e.decompressDeflateRaw(n);
                return r(s);
            }
            static async decompressDeflateRaw(t) {
                let n = new ReadableStream({
                    start (i) {
                        i.enqueue(t), i.close();
                    }
                }), r = new DecompressionStream("deflate-raw"), s = n.pipeThrough(r);
                try {
                    let o = await new Response(s).arrayBuffer();
                    return new Uint8Array(o);
                } catch (i) {
                    let o = i instanceof Error ? `Failed to deflate ZIP entry: ${i.message}` : "Unknown decompression error in ZIP entry";
                    throw new TypeError(o);
                }
            }
            async readLocalFileHeader() {
                let t = await this.tokenizer.peekToken(De);
                if (t === xn.LocalFileHeader) {
                    let n = await this.tokenizer.readToken(Jd);
                    return n.filename = await this.tokenizer.readToken(new ut(n.filenameLength, "utf-8")), n;
                }
                if (t === xn.CentralFileHeader) return false;
                throw t === 3759263696 ? new Error("Encrypted ZIP") : new Error("Unexpected signature");
            }
        };
    });
    var Or, ih = v(()=>{
        Or = class {
            constructor(t){
                this.tokenizer = t;
            }
            inflate() {
                let t = this.tokenizer;
                return new ReadableStream({
                    async pull (n) {
                        let r = new Uint8Array(1024), s = await t.readBuffer(r, {
                            mayBeLess: true
                        });
                        if (s === 0) {
                            n.close();
                            return;
                        }
                        n.enqueue(r.subarray(0, s));
                    }
                }).pipeThrough(new DecompressionStream("gzip"));
            }
        };
    });
    var oh = v(()=>{
        sh();
        ih();
    });
    function Qo(e) {
        let { byteLength: t } = e;
        if (t === 6) return e.getUint16(0) * 2 ** 32 + e.getUint32(2);
        if (t === 5) return e.getUint8(0) * 2 ** 32 + e.getUint32(1);
        if (t === 4) return e.getUint32(0);
        if (t === 3) return e.getUint8(0) * 2 ** 16 + e.getUint16(1);
        if (t === 2) return e.getUint16(0);
        if (t === 1) return e.getUint8(0);
    }
    var ah = v(()=>{
        ({
            utf8: new globalThis.TextDecoder("utf8")
        }), new globalThis.TextEncoder(), Array.from({
            length: 256
        }, (e, t)=>t.toString(16).padStart(2, "0"));
    });
    function lh(e, t) {
        if (t === "utf-16le") {
            let n = [];
            for(let r = 0; r < e.length; r++){
                let s = e.charCodeAt(r);
                n.push(s & 255, s >> 8 & 255);
            }
            return n;
        }
        if (t === "utf-16be") {
            let n = [];
            for(let r = 0; r < e.length; r++){
                let s = e.charCodeAt(r);
                n.push(s >> 8 & 255, s & 255);
            }
            return n;
        }
        return [
            ...e
        ].map((n)=>n.charCodeAt(0));
    }
    function ch(e, t = 0) {
        let n = Number.parseInt(new ut(6).get(e, 148).replace(/\0.*$/, "").trim(), 8);
        if (Number.isNaN(n)) return false;
        let r = 256;
        for(let s = t; s < t + 148; s++)r += e[s];
        for(let s = t + 156; s < t + 512; s++)r += e[s];
        return n === r;
    }
    var uh, fh = v(()=>{
        $r();
        uh = {
            get: (e, t)=>e[t + 3] & 127 | e[t + 2] << 7 | e[t + 1] << 14 | e[t] << 21,
            len: 4
        };
    });
    var ph, dh, hh = v(()=>{
        ph = [
            "jpg",
            "png",
            "apng",
            "gif",
            "webp",
            "flif",
            "xcf",
            "cr2",
            "cr3",
            "orf",
            "arw",
            "dng",
            "nef",
            "rw2",
            "raf",
            "tif",
            "bmp",
            "icns",
            "jxr",
            "psd",
            "indd",
            "zip",
            "tar",
            "rar",
            "gz",
            "bz2",
            "7z",
            "dmg",
            "mp4",
            "mid",
            "mkv",
            "webm",
            "mov",
            "avi",
            "mpg",
            "mp2",
            "mp3",
            "m4a",
            "oga",
            "ogg",
            "ogv",
            "opus",
            "flac",
            "wav",
            "spx",
            "amr",
            "pdf",
            "epub",
            "elf",
            "macho",
            "exe",
            "swf",
            "rtf",
            "wasm",
            "woff",
            "woff2",
            "eot",
            "ttf",
            "otf",
            "ttc",
            "ico",
            "flv",
            "ps",
            "xz",
            "sqlite",
            "nes",
            "crx",
            "xpi",
            "cab",
            "deb",
            "ar",
            "rpm",
            "Z",
            "lz",
            "cfb",
            "mxf",
            "mts",
            "blend",
            "bpg",
            "docx",
            "pptx",
            "xlsx",
            "3gp",
            "3g2",
            "j2c",
            "jp2",
            "jpm",
            "jpx",
            "mj2",
            "aif",
            "qcp",
            "odt",
            "ods",
            "odp",
            "xml",
            "mobi",
            "heic",
            "cur",
            "ktx",
            "ape",
            "wv",
            "dcm",
            "ics",
            "glb",
            "pcap",
            "dsf",
            "lnk",
            "alias",
            "voc",
            "ac3",
            "m4v",
            "m4p",
            "m4b",
            "f4v",
            "f4p",
            "f4b",
            "f4a",
            "mie",
            "asf",
            "ogm",
            "ogx",
            "mpc",
            "arrow",
            "shp",
            "aac",
            "mp1",
            "it",
            "s3m",
            "xm",
            "skp",
            "avif",
            "eps",
            "lzh",
            "pgp",
            "asar",
            "stl",
            "chm",
            "3mf",
            "zst",
            "jxl",
            "vcf",
            "jls",
            "pst",
            "dwg",
            "parquet",
            "class",
            "arj",
            "cpio",
            "ace",
            "avro",
            "icc",
            "fbx",
            "vsdx",
            "vtt",
            "apk",
            "drc",
            "lz4",
            "potx",
            "xltx",
            "dotx",
            "xltm",
            "ott",
            "ots",
            "otp",
            "odg",
            "otg",
            "xlsm",
            "docm",
            "dotm",
            "potm",
            "pptm",
            "jar",
            "jmp",
            "rm",
            "sav",
            "ppsm",
            "ppsx",
            "tar.gz",
            "reg",
            "dat"
        ], dh = [
            "image/jpeg",
            "image/png",
            "image/gif",
            "image/webp",
            "image/flif",
            "image/x-xcf",
            "image/x-canon-cr2",
            "image/x-canon-cr3",
            "image/tiff",
            "image/bmp",
            "image/vnd.ms-photo",
            "image/vnd.adobe.photoshop",
            "application/x-indesign",
            "application/epub+zip",
            "application/x-xpinstall",
            "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
            "application/vnd.oasis.opendocument.text",
            "application/vnd.oasis.opendocument.spreadsheet",
            "application/vnd.oasis.opendocument.presentation",
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "application/vnd.openxmlformats-officedocument.presentationml.presentation",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
            "application/zip",
            "application/x-tar",
            "application/x-rar-compressed",
            "application/gzip",
            "application/x-bzip2",
            "application/x-7z-compressed",
            "application/x-apple-diskimage",
            "application/vnd.apache.arrow.file",
            "video/mp4",
            "audio/midi",
            "video/matroska",
            "video/webm",
            "video/quicktime",
            "video/vnd.avi",
            "audio/wav",
            "audio/qcelp",
            "audio/x-ms-asf",
            "video/x-ms-asf",
            "application/vnd.ms-asf",
            "video/mpeg",
            "video/3gpp",
            "audio/mpeg",
            "audio/mp4",
            "video/ogg",
            "audio/ogg",
            "audio/ogg; codecs=opus",
            "application/ogg",
            "audio/flac",
            "audio/ape",
            "audio/wavpack",
            "audio/amr",
            "application/pdf",
            "application/x-elf",
            "application/x-mach-binary",
            "application/x-msdownload",
            "application/x-shockwave-flash",
            "application/rtf",
            "application/wasm",
            "font/woff",
            "font/woff2",
            "application/vnd.ms-fontobject",
            "font/ttf",
            "font/otf",
            "font/collection",
            "image/x-icon",
            "video/x-flv",
            "application/postscript",
            "application/eps",
            "application/x-xz",
            "application/x-sqlite3",
            "application/x-nintendo-nes-rom",
            "application/x-google-chrome-extension",
            "application/vnd.ms-cab-compressed",
            "application/x-deb",
            "application/x-unix-archive",
            "application/x-rpm",
            "application/x-compress",
            "application/x-lzip",
            "application/x-cfb",
            "application/x-mie",
            "application/mxf",
            "video/mp2t",
            "application/x-blender",
            "image/bpg",
            "image/j2c",
            "image/jp2",
            "image/jpx",
            "image/jpm",
            "image/mj2",
            "audio/aiff",
            "application/xml",
            "application/x-mobipocket-ebook",
            "image/heif",
            "image/heif-sequence",
            "image/heic",
            "image/heic-sequence",
            "image/icns",
            "image/ktx",
            "application/dicom",
            "audio/x-musepack",
            "text/calendar",
            "text/vcard",
            "text/vtt",
            "model/gltf-binary",
            "application/vnd.tcpdump.pcap",
            "audio/x-dsf",
            "application/x.ms.shortcut",
            "application/x.apple.alias",
            "audio/x-voc",
            "audio/vnd.dolby.dd-raw",
            "audio/x-m4a",
            "image/apng",
            "image/x-olympus-orf",
            "image/x-sony-arw",
            "image/x-adobe-dng",
            "image/x-nikon-nef",
            "image/x-panasonic-rw2",
            "image/x-fujifilm-raf",
            "video/x-m4v",
            "video/3gpp2",
            "application/x-esri-shape",
            "audio/aac",
            "audio/x-it",
            "audio/x-s3m",
            "audio/x-xm",
            "video/MP1S",
            "video/MP2P",
            "application/vnd.sketchup.skp",
            "image/avif",
            "application/x-lzh-compressed",
            "application/pgp-encrypted",
            "application/x-asar",
            "model/stl",
            "application/vnd.ms-htmlhelp",
            "model/3mf",
            "image/jxl",
            "application/zstd",
            "image/jls",
            "application/vnd.ms-outlook",
            "image/vnd.dwg",
            "application/vnd.apache.parquet",
            "application/java-vm",
            "application/x-arj",
            "application/x-cpio",
            "application/x-ace-compressed",
            "application/avro",
            "application/vnd.iccprofile",
            "application/x.autodesk.fbx",
            "application/vnd.visio",
            "application/vnd.android.package-archive",
            "application/vnd.google.draco",
            "application/x-lz4",
            "application/vnd.openxmlformats-officedocument.presentationml.template",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
            "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
            "application/vnd.ms-excel.template.macroenabled.12",
            "application/vnd.oasis.opendocument.text-template",
            "application/vnd.oasis.opendocument.spreadsheet-template",
            "application/vnd.oasis.opendocument.presentation-template",
            "application/vnd.oasis.opendocument.graphics",
            "application/vnd.oasis.opendocument.graphics-template",
            "application/vnd.ms-excel.sheet.macroenabled.12",
            "application/vnd.ms-word.document.macroenabled.12",
            "application/vnd.ms-word.template.macroenabled.12",
            "application/vnd.ms-powerpoint.template.macroenabled.12",
            "application/vnd.ms-powerpoint.presentation.macroenabled.12",
            "application/java-archive",
            "application/vnd.rn-realmedia",
            "application/x-spss-sav",
            "application/x-ms-regedit",
            "application/x-ft-windows-registry-hive",
            "application/x-jmp-data"
        ];
    });
    async function mh(e, t) {
        return new Jo(t).fromBuffer(e);
    }
    function Xo(e) {
        switch(e = e.toLowerCase(), e){
            case "application/epub+zip":
                return {
                    ext: "epub",
                    mime: e
                };
            case "application/vnd.oasis.opendocument.text":
                return {
                    ext: "odt",
                    mime: e
                };
            case "application/vnd.oasis.opendocument.text-template":
                return {
                    ext: "ott",
                    mime: e
                };
            case "application/vnd.oasis.opendocument.spreadsheet":
                return {
                    ext: "ods",
                    mime: e
                };
            case "application/vnd.oasis.opendocument.spreadsheet-template":
                return {
                    ext: "ots",
                    mime: e
                };
            case "application/vnd.oasis.opendocument.presentation":
                return {
                    ext: "odp",
                    mime: e
                };
            case "application/vnd.oasis.opendocument.presentation-template":
                return {
                    ext: "otp",
                    mime: e
                };
            case "application/vnd.oasis.opendocument.graphics":
                return {
                    ext: "odg",
                    mime: e
                };
            case "application/vnd.oasis.opendocument.graphics-template":
                return {
                    ext: "otg",
                    mime: e
                };
            case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
                return {
                    ext: "ppsx",
                    mime: e
                };
            case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
                return {
                    ext: "xlsx",
                    mime: e
                };
            case "application/vnd.ms-excel.sheet.macroenabled":
                return {
                    ext: "xlsm",
                    mime: "application/vnd.ms-excel.sheet.macroenabled.12"
                };
            case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
                return {
                    ext: "xltx",
                    mime: e
                };
            case "application/vnd.ms-excel.template.macroenabled":
                return {
                    ext: "xltm",
                    mime: "application/vnd.ms-excel.template.macroenabled.12"
                };
            case "application/vnd.ms-powerpoint.slideshow.macroenabled":
                return {
                    ext: "ppsm",
                    mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
                };
            case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
                return {
                    ext: "docx",
                    mime: e
                };
            case "application/vnd.ms-word.document.macroenabled":
                return {
                    ext: "docm",
                    mime: "application/vnd.ms-word.document.macroenabled.12"
                };
            case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
                return {
                    ext: "dotx",
                    mime: e
                };
            case "application/vnd.ms-word.template.macroenabledtemplate":
                return {
                    ext: "dotm",
                    mime: "application/vnd.ms-word.template.macroenabled.12"
                };
            case "application/vnd.openxmlformats-officedocument.presentationml.template":
                return {
                    ext: "potx",
                    mime: e
                };
            case "application/vnd.ms-powerpoint.template.macroenabled":
                return {
                    ext: "potm",
                    mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
                };
            case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
                return {
                    ext: "pptx",
                    mime: e
                };
            case "application/vnd.ms-powerpoint.presentation.macroenabled":
                return {
                    ext: "pptm",
                    mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
                };
            case "application/vnd.ms-visio.drawing":
                return {
                    ext: "vsdx",
                    mime: "application/vnd.visio"
                };
            case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
                return {
                    ext: "3mf",
                    mime: "model/3mf"
                };
        }
    }
    function Wt(e, t, n) {
        n = {
            offset: 0,
            ...n
        };
        for (let [r, s] of t.entries())if (n.mask) {
            if (s !== (n.mask[r] & e[r + n.offset])) return false;
        } else if (s !== e[r + n.offset]) return false;
        return true;
    }
    var Ko, Jo, gh = v(()=>{
        $r();
        qd();
        oh();
        ah();
        fh();
        hh();
        Ko = 4100;
        Jo = class {
            constructor(t){
                this.options = {
                    mpegOffsetTolerance: 0,
                    ...t
                }, this.detectors = [
                    ...t?.customDetectors ?? [],
                    {
                        id: "core",
                        detect: this.detectConfident
                    },
                    {
                        id: "core.imprecise",
                        detect: this.detectImprecise
                    }
                ], this.tokenizerOptions = {
                    abortSignal: t?.signal
                };
            }
            async fromTokenizer(t) {
                let n = t.position;
                for (let r of this.detectors){
                    let s = await r.detect(t);
                    if (s) return s;
                    if (n !== t.position) return;
                }
            }
            async fromBuffer(t) {
                if (!(t instanceof Uint8Array || t instanceof ArrayBuffer)) throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof t}\``);
                let n = t instanceof Uint8Array ? t : new Uint8Array(t);
                if (n?.length > 1) return this.fromTokenizer(Hd(n, this.tokenizerOptions));
            }
            async fromBlob(t) {
                let n = Vd(t, this.tokenizerOptions);
                try {
                    return await this.fromTokenizer(n);
                } finally{
                    await n.close();
                }
            }
            async fromStream(t) {
                let n = jd(t, this.tokenizerOptions);
                try {
                    return await this.fromTokenizer(n);
                } finally{
                    await n.close();
                }
            }
            async toDetectionStream(t, n) {
                let { sampleSize: r = Ko } = n, s, i, o = t.getReader({
                    mode: "byob"
                });
                try {
                    let { value: c, done: u } = await o.read(new Uint8Array(r));
                    if (i = c, !u && c) try {
                        s = await this.fromBuffer(c.subarray(0, r));
                    } catch (f) {
                        if (!(f instanceof ke)) throw f;
                        s = void 0;
                    }
                    i = c;
                } finally{
                    o.releaseLock();
                }
                let a = new TransformStream({
                    async start (c) {
                        c.enqueue(i);
                    },
                    transform (c, u) {
                        u.enqueue(c);
                    }
                }), l = t.pipeThrough(a);
                return l.fileType = s, l;
            }
            check(t, n) {
                return Wt(this.buffer, t, n);
            }
            checkString(t, n) {
                return this.check(lh(t, n?.encoding), n);
            }
            detectConfident = async (t)=>{
                if (this.buffer = new Uint8Array(Ko), t.fileInfo.size === void 0 && (t.fileInfo.size = Number.MAX_SAFE_INTEGER), this.tokenizer = t, await t.peekBuffer(this.buffer, {
                    length: 32,
                    mayBeLess: true
                }), this.check([
                    66,
                    77
                ])) return {
                    ext: "bmp",
                    mime: "image/bmp"
                };
                if (this.check([
                    11,
                    119
                ])) return {
                    ext: "ac3",
                    mime: "audio/vnd.dolby.dd-raw"
                };
                if (this.check([
                    120,
                    1
                ])) return {
                    ext: "dmg",
                    mime: "application/x-apple-diskimage"
                };
                if (this.check([
                    77,
                    90
                ])) return {
                    ext: "exe",
                    mime: "application/x-msdownload"
                };
                if (this.check([
                    37,
                    33
                ])) return await t.peekBuffer(this.buffer, {
                    length: 24,
                    mayBeLess: true
                }), this.checkString("PS-Adobe-", {
                    offset: 2
                }) && this.checkString(" EPSF-", {
                    offset: 14
                }) ? {
                    ext: "eps",
                    mime: "application/eps"
                } : {
                    ext: "ps",
                    mime: "application/postscript"
                };
                if (this.check([
                    31,
                    160
                ]) || this.check([
                    31,
                    157
                ])) return {
                    ext: "Z",
                    mime: "application/x-compress"
                };
                if (this.check([
                    199,
                    113
                ])) return {
                    ext: "cpio",
                    mime: "application/x-cpio"
                };
                if (this.check([
                    96,
                    234
                ])) return {
                    ext: "arj",
                    mime: "application/x-arj"
                };
                if (this.check([
                    239,
                    187,
                    191
                ])) return this.tokenizer.ignore(3), this.detectConfident(t);
                if (this.check([
                    71,
                    73,
                    70
                ])) return {
                    ext: "gif",
                    mime: "image/gif"
                };
                if (this.check([
                    73,
                    73,
                    188
                ])) return {
                    ext: "jxr",
                    mime: "image/vnd.ms-photo"
                };
                if (this.check([
                    31,
                    139,
                    8
                ])) {
                    let r = new Or(t).inflate(), s = true;
                    try {
                        let i;
                        try {
                            i = await this.fromStream(r);
                        } catch  {
                            s = false;
                        }
                        if (i && i.ext === "tar") return {
                            ext: "tar.gz",
                            mime: "application/gzip"
                        };
                    } finally{
                        s && await r.cancel();
                    }
                    return {
                        ext: "gz",
                        mime: "application/gzip"
                    };
                }
                if (this.check([
                    66,
                    90,
                    104
                ])) return {
                    ext: "bz2",
                    mime: "application/x-bzip2"
                };
                if (this.checkString("ID3")) {
                    await t.ignore(6);
                    let n = await t.readToken(uh);
                    return t.position + n > t.fileInfo.size ? {
                        ext: "mp3",
                        mime: "audio/mpeg"
                    } : (await t.ignore(n), this.fromTokenizer(t));
                }
                if (this.checkString("MP+")) return {
                    ext: "mpc",
                    mime: "audio/x-musepack"
                };
                if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([
                    87,
                    83
                ], {
                    offset: 1
                })) return {
                    ext: "swf",
                    mime: "application/x-shockwave-flash"
                };
                if (this.check([
                    255,
                    216,
                    255
                ])) return this.check([
                    247
                ], {
                    offset: 3
                }) ? {
                    ext: "jls",
                    mime: "image/jls"
                } : {
                    ext: "jpg",
                    mime: "image/jpeg"
                };
                if (this.check([
                    79,
                    98,
                    106,
                    1
                ])) return {
                    ext: "avro",
                    mime: "application/avro"
                };
                if (this.checkString("FLIF")) return {
                    ext: "flif",
                    mime: "image/flif"
                };
                if (this.checkString("8BPS")) return {
                    ext: "psd",
                    mime: "image/vnd.adobe.photoshop"
                };
                if (this.checkString("MPCK")) return {
                    ext: "mpc",
                    mime: "audio/x-musepack"
                };
                if (this.checkString("FORM")) return {
                    ext: "aif",
                    mime: "audio/aiff"
                };
                if (this.checkString("icns", {
                    offset: 0
                })) return {
                    ext: "icns",
                    mime: "image/icns"
                };
                if (this.check([
                    80,
                    75,
                    3,
                    4
                ])) {
                    let n;
                    return await new Tr(t).unzip((r)=>{
                        switch(r.filename){
                            case "META-INF/mozilla.rsa":
                                return n = {
                                    ext: "xpi",
                                    mime: "application/x-xpinstall"
                                }, {
                                    stop: true
                                };
                            case "META-INF/MANIFEST.MF":
                                return n = {
                                    ext: "jar",
                                    mime: "application/java-archive"
                                }, {
                                    stop: true
                                };
                            case "mimetype":
                                return {
                                    async handler (s) {
                                        let i = new TextDecoder("utf-8").decode(s).trim();
                                        n = Xo(i);
                                    },
                                    stop: true
                                };
                            case "[Content_Types].xml":
                                return {
                                    async handler (s) {
                                        let i = new TextDecoder("utf-8").decode(s), o = i.indexOf('.main+xml"');
                                        if (o === -1) {
                                            let a = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                                            i.includes(`ContentType="${a}"`) && (n = Xo(a));
                                        } else {
                                            i = i.slice(0, Math.max(0, o));
                                            let a = i.lastIndexOf('"'), l = i.slice(Math.max(0, a + 1));
                                            n = Xo(l);
                                        }
                                    },
                                    stop: true
                                };
                            default:
                                return /classes\d*\.dex/.test(r.filename) ? (n = {
                                    ext: "apk",
                                    mime: "application/vnd.android.package-archive"
                                }, {
                                    stop: true
                                }) : {};
                        }
                    }).catch((r)=>{
                        if (!(r instanceof ke)) throw r;
                    }), n ?? {
                        ext: "zip",
                        mime: "application/zip"
                    };
                }
                if (this.checkString("OggS")) {
                    await t.ignore(28);
                    let n = new Uint8Array(8);
                    return await t.readBuffer(n), Wt(n, [
                        79,
                        112,
                        117,
                        115,
                        72,
                        101,
                        97,
                        100
                    ]) ? {
                        ext: "opus",
                        mime: "audio/ogg; codecs=opus"
                    } : Wt(n, [
                        128,
                        116,
                        104,
                        101,
                        111,
                        114,
                        97
                    ]) ? {
                        ext: "ogv",
                        mime: "video/ogg"
                    } : Wt(n, [
                        1,
                        118,
                        105,
                        100,
                        101,
                        111,
                        0
                    ]) ? {
                        ext: "ogm",
                        mime: "video/ogg"
                    } : Wt(n, [
                        127,
                        70,
                        76,
                        65,
                        67
                    ]) ? {
                        ext: "oga",
                        mime: "audio/ogg"
                    } : Wt(n, [
                        83,
                        112,
                        101,
                        101,
                        120,
                        32,
                        32
                    ]) ? {
                        ext: "spx",
                        mime: "audio/ogg"
                    } : Wt(n, [
                        1,
                        118,
                        111,
                        114,
                        98,
                        105,
                        115
                    ]) ? {
                        ext: "ogg",
                        mime: "audio/ogg"
                    } : {
                        ext: "ogx",
                        mime: "application/ogg"
                    };
                }
                if (this.check([
                    80,
                    75
                ]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) return {
                    ext: "zip",
                    mime: "application/zip"
                };
                if (this.checkString("MThd")) return {
                    ext: "mid",
                    mime: "audio/midi"
                };
                if (this.checkString("wOFF") && (this.check([
                    0,
                    1,
                    0,
                    0
                ], {
                    offset: 4
                }) || this.checkString("OTTO", {
                    offset: 4
                }))) return {
                    ext: "woff",
                    mime: "font/woff"
                };
                if (this.checkString("wOF2") && (this.check([
                    0,
                    1,
                    0,
                    0
                ], {
                    offset: 4
                }) || this.checkString("OTTO", {
                    offset: 4
                }))) return {
                    ext: "woff2",
                    mime: "font/woff2"
                };
                if (this.check([
                    212,
                    195,
                    178,
                    161
                ]) || this.check([
                    161,
                    178,
                    195,
                    212
                ])) return {
                    ext: "pcap",
                    mime: "application/vnd.tcpdump.pcap"
                };
                if (this.checkString("DSD ")) return {
                    ext: "dsf",
                    mime: "audio/x-dsf"
                };
                if (this.checkString("LZIP")) return {
                    ext: "lz",
                    mime: "application/x-lzip"
                };
                if (this.checkString("fLaC")) return {
                    ext: "flac",
                    mime: "audio/flac"
                };
                if (this.check([
                    66,
                    80,
                    71,
                    251
                ])) return {
                    ext: "bpg",
                    mime: "image/bpg"
                };
                if (this.checkString("wvpk")) return {
                    ext: "wv",
                    mime: "audio/wavpack"
                };
                if (this.checkString("%PDF")) return {
                    ext: "pdf",
                    mime: "application/pdf"
                };
                if (this.check([
                    0,
                    97,
                    115,
                    109
                ])) return {
                    ext: "wasm",
                    mime: "application/wasm"
                };
                if (this.check([
                    73,
                    73
                ])) {
                    let n = await this.readTiffHeader(false);
                    if (n) return n;
                }
                if (this.check([
                    77,
                    77
                ])) {
                    let n = await this.readTiffHeader(true);
                    if (n) return n;
                }
                if (this.checkString("MAC ")) return {
                    ext: "ape",
                    mime: "audio/ape"
                };
                if (this.check([
                    26,
                    69,
                    223,
                    163
                ])) {
                    async function n() {
                        let a = await t.peekNumber(Td), l = 128, c = 0;
                        for(; (a & l) === 0 && l !== 0;)++c, l >>= 1;
                        let u = new Uint8Array(c + 1);
                        return await t.readBuffer(u), u;
                    }
                    async function r() {
                        let a = await n(), l = await n();
                        l[0] ^= 128 >> l.length - 1;
                        let c = Math.min(6, l.length), u = new DataView(a.buffer), f = new DataView(l.buffer, l.length - c, c);
                        return {
                            id: Qo(u),
                            len: Qo(f)
                        };
                    }
                    async function s(a) {
                        for(; a > 0;){
                            let l = await r();
                            if (l.id === 17026) return (await t.readToken(new ut(l.len))).replaceAll(/\00.*$/g, "");
                            await t.ignore(l.len), --a;
                        }
                    }
                    let i = await r();
                    switch(await s(i.len)){
                        case "webm":
                            return {
                                ext: "webm",
                                mime: "video/webm"
                            };
                        case "matroska":
                            return {
                                ext: "mkv",
                                mime: "video/matroska"
                            };
                        default:
                            return;
                    }
                }
                if (this.checkString("SQLi")) return {
                    ext: "sqlite",
                    mime: "application/x-sqlite3"
                };
                if (this.check([
                    78,
                    69,
                    83,
                    26
                ])) return {
                    ext: "nes",
                    mime: "application/x-nintendo-nes-rom"
                };
                if (this.checkString("Cr24")) return {
                    ext: "crx",
                    mime: "application/x-google-chrome-extension"
                };
                if (this.checkString("MSCF") || this.checkString("ISc(")) return {
                    ext: "cab",
                    mime: "application/vnd.ms-cab-compressed"
                };
                if (this.check([
                    237,
                    171,
                    238,
                    219
                ])) return {
                    ext: "rpm",
                    mime: "application/x-rpm"
                };
                if (this.check([
                    197,
                    208,
                    211,
                    198
                ])) return {
                    ext: "eps",
                    mime: "application/eps"
                };
                if (this.check([
                    40,
                    181,
                    47,
                    253
                ])) return {
                    ext: "zst",
                    mime: "application/zstd"
                };
                if (this.check([
                    127,
                    69,
                    76,
                    70
                ])) return {
                    ext: "elf",
                    mime: "application/x-elf"
                };
                if (this.check([
                    33,
                    66,
                    68,
                    78
                ])) return {
                    ext: "pst",
                    mime: "application/vnd.ms-outlook"
                };
                if (this.checkString("PAR1") || this.checkString("PARE")) return {
                    ext: "parquet",
                    mime: "application/vnd.apache.parquet"
                };
                if (this.checkString("ttcf")) return {
                    ext: "ttc",
                    mime: "font/collection"
                };
                if (this.check([
                    207,
                    250,
                    237,
                    254
                ])) return {
                    ext: "macho",
                    mime: "application/x-mach-binary"
                };
                if (this.check([
                    4,
                    34,
                    77,
                    24
                ])) return {
                    ext: "lz4",
                    mime: "application/x-lz4"
                };
                if (this.checkString("regf")) return {
                    ext: "dat",
                    mime: "application/x-ft-windows-registry-hive"
                };
                if (this.checkString("$FL2") || this.checkString("$FL3")) return {
                    ext: "sav",
                    mime: "application/x-spss-sav"
                };
                if (this.check([
                    79,
                    84,
                    84,
                    79,
                    0
                ])) return {
                    ext: "otf",
                    mime: "font/otf"
                };
                if (this.checkString("#!AMR")) return {
                    ext: "amr",
                    mime: "audio/amr"
                };
                if (this.checkString("{\\rtf")) return {
                    ext: "rtf",
                    mime: "application/rtf"
                };
                if (this.check([
                    70,
                    76,
                    86,
                    1
                ])) return {
                    ext: "flv",
                    mime: "video/x-flv"
                };
                if (this.checkString("IMPM")) return {
                    ext: "it",
                    mime: "audio/x-it"
                };
                if (this.checkString("-lh0-", {
                    offset: 2
                }) || this.checkString("-lh1-", {
                    offset: 2
                }) || this.checkString("-lh2-", {
                    offset: 2
                }) || this.checkString("-lh3-", {
                    offset: 2
                }) || this.checkString("-lh4-", {
                    offset: 2
                }) || this.checkString("-lh5-", {
                    offset: 2
                }) || this.checkString("-lh6-", {
                    offset: 2
                }) || this.checkString("-lh7-", {
                    offset: 2
                }) || this.checkString("-lzs-", {
                    offset: 2
                }) || this.checkString("-lz4-", {
                    offset: 2
                }) || this.checkString("-lz5-", {
                    offset: 2
                }) || this.checkString("-lhd-", {
                    offset: 2
                })) return {
                    ext: "lzh",
                    mime: "application/x-lzh-compressed"
                };
                if (this.check([
                    0,
                    0,
                    1,
                    186
                ])) {
                    if (this.check([
                        33
                    ], {
                        offset: 4,
                        mask: [
                            241
                        ]
                    })) return {
                        ext: "mpg",
                        mime: "video/MP1S"
                    };
                    if (this.check([
                        68
                    ], {
                        offset: 4,
                        mask: [
                            196
                        ]
                    })) return {
                        ext: "mpg",
                        mime: "video/MP2P"
                    };
                }
                if (this.checkString("ITSF")) return {
                    ext: "chm",
                    mime: "application/vnd.ms-htmlhelp"
                };
                if (this.check([
                    202,
                    254,
                    186,
                    190
                ])) return {
                    ext: "class",
                    mime: "application/java-vm"
                };
                if (this.checkString(".RMF")) return {
                    ext: "rm",
                    mime: "application/vnd.rn-realmedia"
                };
                if (this.checkString("DRACO")) return {
                    ext: "drc",
                    mime: "application/vnd.google.draco"
                };
                if (this.check([
                    253,
                    55,
                    122,
                    88,
                    90,
                    0
                ])) return {
                    ext: "xz",
                    mime: "application/x-xz"
                };
                if (this.checkString("<?xml ")) return {
                    ext: "xml",
                    mime: "application/xml"
                };
                if (this.check([
                    55,
                    122,
                    188,
                    175,
                    39,
                    28
                ])) return {
                    ext: "7z",
                    mime: "application/x-7z-compressed"
                };
                if (this.check([
                    82,
                    97,
                    114,
                    33,
                    26,
                    7
                ]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) return {
                    ext: "rar",
                    mime: "application/x-rar-compressed"
                };
                if (this.checkString("solid ")) return {
                    ext: "stl",
                    mime: "model/stl"
                };
                if (this.checkString("AC")) {
                    let n = new ut(4, "latin1").get(this.buffer, 2);
                    if (n.match("^d*") && n >= 1e3 && n <= 1050) return {
                        ext: "dwg",
                        mime: "image/vnd.dwg"
                    };
                }
                if (this.checkString("070707")) return {
                    ext: "cpio",
                    mime: "application/x-cpio"
                };
                if (this.checkString("BLENDER")) return {
                    ext: "blend",
                    mime: "application/x-blender"
                };
                if (this.checkString("!<arch>")) return await t.ignore(8), await t.readToken(new ut(13, "ascii")) === "debian-binary" ? {
                    ext: "deb",
                    mime: "application/x-deb"
                } : {
                    ext: "ar",
                    mime: "application/x-unix-archive"
                };
                if (this.checkString("WEBVTT") && [
                    `
`,
                    "\r",
                    "	",
                    " ",
                    "\0"
                ].some((n)=>this.checkString(n, {
                        offset: 6
                    }))) return {
                    ext: "vtt",
                    mime: "text/vtt"
                };
                if (this.check([
                    137,
                    80,
                    78,
                    71,
                    13,
                    10,
                    26,
                    10
                ])) {
                    await t.ignore(8);
                    async function n() {
                        return {
                            length: await t.readToken(Dd),
                            type: await t.readToken(new ut(4, "latin1"))
                        };
                    }
                    do {
                        let r = await n();
                        if (r.length < 0) return;
                        switch(r.type){
                            case "IDAT":
                                return {
                                    ext: "png",
                                    mime: "image/png"
                                };
                            case "acTL":
                                return {
                                    ext: "apng",
                                    mime: "image/apng"
                                };
                            default:
                                await t.ignore(r.length + 4);
                        }
                    }while (t.position + 8 < t.fileInfo.size);
                    return {
                        ext: "png",
                        mime: "image/png"
                    };
                }
                if (this.check([
                    65,
                    82,
                    82,
                    79,
                    87,
                    49,
                    0,
                    0
                ])) return {
                    ext: "arrow",
                    mime: "application/vnd.apache.arrow.file"
                };
                if (this.check([
                    103,
                    108,
                    84,
                    70,
                    2,
                    0,
                    0,
                    0
                ])) return {
                    ext: "glb",
                    mime: "model/gltf-binary"
                };
                if (this.check([
                    102,
                    114,
                    101,
                    101
                ], {
                    offset: 4
                }) || this.check([
                    109,
                    100,
                    97,
                    116
                ], {
                    offset: 4
                }) || this.check([
                    109,
                    111,
                    111,
                    118
                ], {
                    offset: 4
                }) || this.check([
                    119,
                    105,
                    100,
                    101
                ], {
                    offset: 4
                })) return {
                    ext: "mov",
                    mime: "video/quicktime"
                };
                if (this.check([
                    73,
                    73,
                    82,
                    79,
                    8,
                    0,
                    0,
                    0,
                    24
                ])) return {
                    ext: "orf",
                    mime: "image/x-olympus-orf"
                };
                if (this.checkString("gimp xcf ")) return {
                    ext: "xcf",
                    mime: "image/x-xcf"
                };
                if (this.checkString("ftyp", {
                    offset: 4
                }) && (this.buffer[8] & 96) !== 0) {
                    let n = new ut(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
                    switch(n){
                        case "avif":
                        case "avis":
                            return {
                                ext: "avif",
                                mime: "image/avif"
                            };
                        case "mif1":
                            return {
                                ext: "heic",
                                mime: "image/heif"
                            };
                        case "msf1":
                            return {
                                ext: "heic",
                                mime: "image/heif-sequence"
                            };
                        case "heic":
                        case "heix":
                            return {
                                ext: "heic",
                                mime: "image/heic"
                            };
                        case "hevc":
                        case "hevx":
                            return {
                                ext: "heic",
                                mime: "image/heic-sequence"
                            };
                        case "qt":
                            return {
                                ext: "mov",
                                mime: "video/quicktime"
                            };
                        case "M4V":
                        case "M4VH":
                        case "M4VP":
                            return {
                                ext: "m4v",
                                mime: "video/x-m4v"
                            };
                        case "M4P":
                            return {
                                ext: "m4p",
                                mime: "video/mp4"
                            };
                        case "M4B":
                            return {
                                ext: "m4b",
                                mime: "audio/mp4"
                            };
                        case "M4A":
                            return {
                                ext: "m4a",
                                mime: "audio/x-m4a"
                            };
                        case "F4V":
                            return {
                                ext: "f4v",
                                mime: "video/mp4"
                            };
                        case "F4P":
                            return {
                                ext: "f4p",
                                mime: "video/mp4"
                            };
                        case "F4A":
                            return {
                                ext: "f4a",
                                mime: "audio/mp4"
                            };
                        case "F4B":
                            return {
                                ext: "f4b",
                                mime: "audio/mp4"
                            };
                        case "crx":
                            return {
                                ext: "cr3",
                                mime: "image/x-canon-cr3"
                            };
                        default:
                            return n.startsWith("3g") ? n.startsWith("3g2") ? {
                                ext: "3g2",
                                mime: "video/3gpp2"
                            } : {
                                ext: "3gp",
                                mime: "video/3gpp"
                            } : {
                                ext: "mp4",
                                mime: "video/mp4"
                            };
                    }
                }
                if (this.checkString(`REGEDIT4\r
`)) return {
                    ext: "reg",
                    mime: "application/x-ms-regedit"
                };
                if (this.check([
                    82,
                    73,
                    70,
                    70
                ])) {
                    if (this.checkString("WEBP", {
                        offset: 8
                    })) return {
                        ext: "webp",
                        mime: "image/webp"
                    };
                    if (this.check([
                        65,
                        86,
                        73
                    ], {
                        offset: 8
                    })) return {
                        ext: "avi",
                        mime: "video/vnd.avi"
                    };
                    if (this.check([
                        87,
                        65,
                        86,
                        69
                    ], {
                        offset: 8
                    })) return {
                        ext: "wav",
                        mime: "audio/wav"
                    };
                    if (this.check([
                        81,
                        76,
                        67,
                        77
                    ], {
                        offset: 8
                    })) return {
                        ext: "qcp",
                        mime: "audio/qcelp"
                    };
                }
                if (this.check([
                    73,
                    73,
                    85,
                    0,
                    24,
                    0,
                    0,
                    0,
                    136,
                    231,
                    116,
                    216
                ])) return {
                    ext: "rw2",
                    mime: "image/x-panasonic-rw2"
                };
                if (this.check([
                    48,
                    38,
                    178,
                    117,
                    142,
                    102,
                    207,
                    17,
                    166,
                    217
                ])) {
                    async function n() {
                        let r = new Uint8Array(16);
                        return await t.readBuffer(r), {
                            id: r,
                            size: Number(await t.readToken(Fd))
                        };
                    }
                    for(await t.ignore(30); t.position + 24 < t.fileInfo.size;){
                        let r = await n(), s = r.size - 24;
                        if (Wt(r.id, [
                            145,
                            7,
                            220,
                            183,
                            183,
                            169,
                            207,
                            17,
                            142,
                            230,
                            0,
                            192,
                            12,
                            32,
                            83,
                            101
                        ])) {
                            let i = new Uint8Array(16);
                            if (s -= await t.readBuffer(i), Wt(i, [
                                64,
                                158,
                                105,
                                248,
                                77,
                                91,
                                207,
                                17,
                                168,
                                253,
                                0,
                                128,
                                95,
                                92,
                                68,
                                43
                            ])) return {
                                ext: "asf",
                                mime: "audio/x-ms-asf"
                            };
                            if (Wt(i, [
                                192,
                                239,
                                25,
                                188,
                                77,
                                91,
                                207,
                                17,
                                168,
                                253,
                                0,
                                128,
                                95,
                                92,
                                68,
                                43
                            ])) return {
                                ext: "asf",
                                mime: "video/x-ms-asf"
                            };
                            break;
                        }
                        await t.ignore(s);
                    }
                    return {
                        ext: "asf",
                        mime: "application/vnd.ms-asf"
                    };
                }
                if (this.check([
                    171,
                    75,
                    84,
                    88,
                    32,
                    49,
                    49,
                    187,
                    13,
                    10,
                    26,
                    10
                ])) return {
                    ext: "ktx",
                    mime: "image/ktx"
                };
                if ((this.check([
                    126,
                    16,
                    4
                ]) || this.check([
                    126,
                    24,
                    4
                ])) && this.check([
                    48,
                    77,
                    73,
                    69
                ], {
                    offset: 4
                })) return {
                    ext: "mie",
                    mime: "application/x-mie"
                };
                if (this.check([
                    39,
                    10,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ], {
                    offset: 2
                })) return {
                    ext: "shp",
                    mime: "application/x-esri-shape"
                };
                if (this.check([
                    255,
                    79,
                    255,
                    81
                ])) return {
                    ext: "j2c",
                    mime: "image/j2c"
                };
                if (this.check([
                    0,
                    0,
                    0,
                    12,
                    106,
                    80,
                    32,
                    32,
                    13,
                    10,
                    135,
                    10
                ])) switch(await t.ignore(20), await t.readToken(new ut(4, "ascii"))){
                    case "jp2 ":
                        return {
                            ext: "jp2",
                            mime: "image/jp2"
                        };
                    case "jpx ":
                        return {
                            ext: "jpx",
                            mime: "image/jpx"
                        };
                    case "jpm ":
                        return {
                            ext: "jpm",
                            mime: "image/jpm"
                        };
                    case "mjp2":
                        return {
                            ext: "mj2",
                            mime: "image/mj2"
                        };
                    default:
                        return;
                }
                if (this.check([
                    255,
                    10
                ]) || this.check([
                    0,
                    0,
                    0,
                    12,
                    74,
                    88,
                    76,
                    32,
                    13,
                    10,
                    135,
                    10
                ])) return {
                    ext: "jxl",
                    mime: "image/jxl"
                };
                if (this.check([
                    254,
                    255
                ])) return this.checkString("<?xml ", {
                    offset: 2,
                    encoding: "utf-16be"
                }) ? {
                    ext: "xml",
                    mime: "application/xml"
                } : void 0;
                if (this.check([
                    208,
                    207,
                    17,
                    224,
                    161,
                    177,
                    26,
                    225
                ])) return {
                    ext: "cfb",
                    mime: "application/x-cfb"
                };
                if (await t.peekBuffer(this.buffer, {
                    length: Math.min(256, t.fileInfo.size),
                    mayBeLess: true
                }), this.check([
                    97,
                    99,
                    115,
                    112
                ], {
                    offset: 36
                })) return {
                    ext: "icc",
                    mime: "application/vnd.iccprofile"
                };
                if (this.checkString("**ACE", {
                    offset: 7
                }) && this.checkString("**", {
                    offset: 12
                })) return {
                    ext: "ace",
                    mime: "application/x-ace-compressed"
                };
                if (this.checkString("BEGIN:")) {
                    if (this.checkString("VCARD", {
                        offset: 6
                    })) return {
                        ext: "vcf",
                        mime: "text/vcard"
                    };
                    if (this.checkString("VCALENDAR", {
                        offset: 6
                    })) return {
                        ext: "ics",
                        mime: "text/calendar"
                    };
                }
                if (this.checkString("FUJIFILMCCD-RAW")) return {
                    ext: "raf",
                    mime: "image/x-fujifilm-raf"
                };
                if (this.checkString("Extended Module:")) return {
                    ext: "xm",
                    mime: "audio/x-xm"
                };
                if (this.checkString("Creative Voice File")) return {
                    ext: "voc",
                    mime: "audio/x-voc"
                };
                if (this.check([
                    4,
                    0,
                    0,
                    0
                ]) && this.buffer.length >= 16) {
                    let n = new DataView(this.buffer.buffer).getUint32(12, true);
                    if (n > 12 && this.buffer.length >= n + 16) try {
                        let r = new TextDecoder().decode(this.buffer.subarray(16, n + 16));
                        if (JSON.parse(r).files) return {
                            ext: "asar",
                            mime: "application/x-asar"
                        };
                    } catch  {}
                }
                if (this.check([
                    6,
                    14,
                    43,
                    52,
                    2,
                    5,
                    1,
                    1,
                    13,
                    1,
                    2,
                    1,
                    1,
                    2
                ])) return {
                    ext: "mxf",
                    mime: "application/mxf"
                };
                if (this.checkString("SCRM", {
                    offset: 44
                })) return {
                    ext: "s3m",
                    mime: "audio/x-s3m"
                };
                if (this.check([
                    71
                ]) && this.check([
                    71
                ], {
                    offset: 188
                })) return {
                    ext: "mts",
                    mime: "video/mp2t"
                };
                if (this.check([
                    71
                ], {
                    offset: 4
                }) && this.check([
                    71
                ], {
                    offset: 196
                })) return {
                    ext: "mts",
                    mime: "video/mp2t"
                };
                if (this.check([
                    66,
                    79,
                    79,
                    75,
                    77,
                    79,
                    66,
                    73
                ], {
                    offset: 60
                })) return {
                    ext: "mobi",
                    mime: "application/x-mobipocket-ebook"
                };
                if (this.check([
                    68,
                    73,
                    67,
                    77
                ], {
                    offset: 128
                })) return {
                    ext: "dcm",
                    mime: "application/dicom"
                };
                if (this.check([
                    76,
                    0,
                    0,
                    0,
                    1,
                    20,
                    2,
                    0,
                    0,
                    0,
                    0,
                    0,
                    192,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    70
                ])) return {
                    ext: "lnk",
                    mime: "application/x.ms.shortcut"
                };
                if (this.check([
                    98,
                    111,
                    111,
                    107,
                    0,
                    0,
                    0,
                    0,
                    109,
                    97,
                    114,
                    107,
                    0,
                    0,
                    0,
                    0
                ])) return {
                    ext: "alias",
                    mime: "application/x.apple.alias"
                };
                if (this.checkString("Kaydara FBX Binary  \0")) return {
                    ext: "fbx",
                    mime: "application/x.autodesk.fbx"
                };
                if (this.check([
                    76,
                    80
                ], {
                    offset: 34
                }) && (this.check([
                    0,
                    0,
                    1
                ], {
                    offset: 8
                }) || this.check([
                    1,
                    0,
                    2
                ], {
                    offset: 8
                }) || this.check([
                    2,
                    0,
                    2
                ], {
                    offset: 8
                }))) return {
                    ext: "eot",
                    mime: "application/vnd.ms-fontobject"
                };
                if (this.check([
                    6,
                    6,
                    237,
                    245,
                    216,
                    29,
                    70,
                    229,
                    189,
                    49,
                    239,
                    231,
                    254,
                    116,
                    183,
                    29
                ])) return {
                    ext: "indd",
                    mime: "application/x-indesign"
                };
                if (this.check([
                    255,
                    255,
                    0,
                    0,
                    7,
                    0,
                    0,
                    0,
                    4,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0
                ]) || this.check([
                    0,
                    0,
                    255,
                    255,
                    0,
                    0,
                    0,
                    7,
                    0,
                    0,
                    0,
                    4,
                    0,
                    1,
                    0,
                    1
                ])) return {
                    ext: "jmp",
                    mime: "application/x-jmp-data"
                };
                if (await t.peekBuffer(this.buffer, {
                    length: Math.min(512, t.fileInfo.size),
                    mayBeLess: true
                }), this.checkString("ustar", {
                    offset: 257
                }) && (this.checkString("\0", {
                    offset: 262
                }) || this.checkString(" ", {
                    offset: 262
                })) || this.check([
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ], {
                    offset: 257
                }) && ch(this.buffer)) return {
                    ext: "tar",
                    mime: "application/x-tar"
                };
                if (this.check([
                    255,
                    254
                ])) {
                    let n = "utf-16le";
                    return this.checkString("<?xml ", {
                        offset: 2,
                        encoding: n
                    }) ? {
                        ext: "xml",
                        mime: "application/xml"
                    } : this.check([
                        255,
                        14
                    ], {
                        offset: 2
                    }) && this.checkString("SketchUp Model", {
                        offset: 4,
                        encoding: n
                    }) ? {
                        ext: "skp",
                        mime: "application/vnd.sketchup.skp"
                    } : this.checkString(`Windows Registry Editor Version 5.00\r
`, {
                        offset: 2,
                        encoding: n
                    }) ? {
                        ext: "reg",
                        mime: "application/x-ms-regedit"
                    } : void 0;
                }
                if (this.checkString("-----BEGIN PGP MESSAGE-----")) return {
                    ext: "pgp",
                    mime: "application/pgp-encrypted"
                };
            };
            detectImprecise = async (t)=>{
                if (this.buffer = new Uint8Array(Ko), await t.peekBuffer(this.buffer, {
                    length: Math.min(8, t.fileInfo.size),
                    mayBeLess: true
                }), this.check([
                    0,
                    0,
                    1,
                    186
                ]) || this.check([
                    0,
                    0,
                    1,
                    179
                ])) return {
                    ext: "mpg",
                    mime: "video/mpeg"
                };
                if (this.check([
                    0,
                    1,
                    0,
                    0,
                    0
                ])) return {
                    ext: "ttf",
                    mime: "font/ttf"
                };
                if (this.check([
                    0,
                    0,
                    1,
                    0
                ])) return {
                    ext: "ico",
                    mime: "image/x-icon"
                };
                if (this.check([
                    0,
                    0,
                    2,
                    0
                ])) return {
                    ext: "cur",
                    mime: "image/x-icon"
                };
                if (await t.peekBuffer(this.buffer, {
                    length: Math.min(2 + this.options.mpegOffsetTolerance, t.fileInfo.size),
                    mayBeLess: true
                }), this.buffer.length >= 2 + this.options.mpegOffsetTolerance) for(let n = 0; n <= this.options.mpegOffsetTolerance; ++n){
                    let r = this.scanMpeg(n);
                    if (r) return r;
                }
            };
            async readTiffTag(t) {
                let n = await this.tokenizer.readToken(t ? Gn : Pe);
                switch(this.tokenizer.ignore(10), n){
                    case 50341:
                        return {
                            ext: "arw",
                            mime: "image/x-sony-arw"
                        };
                    case 50706:
                        return {
                            ext: "dng",
                            mime: "image/x-adobe-dng"
                        };
                }
            }
            async readTiffIFD(t) {
                let n = await this.tokenizer.readToken(t ? Gn : Pe);
                for(let r = 0; r < n; ++r){
                    let s = await this.readTiffTag(t);
                    if (s) return s;
                }
            }
            async readTiffHeader(t) {
                let n = (t ? Gn : Pe).get(this.buffer, 2), r = (t ? Od : De).get(this.buffer, 4);
                if (n === 42) {
                    if (r >= 6) {
                        if (this.checkString("CR", {
                            offset: 8
                        })) return {
                            ext: "cr2",
                            mime: "image/x-canon-cr2"
                        };
                        if (r >= 8) {
                            let i = (t ? Gn : Pe).get(this.buffer, 8), o = (t ? Gn : Pe).get(this.buffer, 10);
                            if (i === 28 && o === 254 || i === 31 && o === 11) return {
                                ext: "nef",
                                mime: "image/x-nikon-nef"
                            };
                        }
                    }
                    return await this.tokenizer.ignore(r), await this.readTiffIFD(t) ?? {
                        ext: "tif",
                        mime: "image/tiff"
                    };
                }
                if (n === 43) return {
                    ext: "tif",
                    mime: "image/tiff"
                };
            }
            scanMpeg(t) {
                if (this.check([
                    255,
                    224
                ], {
                    offset: t,
                    mask: [
                        255,
                        224
                    ]
                })) {
                    if (this.check([
                        16
                    ], {
                        offset: t + 1,
                        mask: [
                            22
                        ]
                    })) return this.check([
                        8
                    ], {
                        offset: t + 1,
                        mask: [
                            8
                        ]
                    }) ? {
                        ext: "aac",
                        mime: "audio/aac"
                    } : {
                        ext: "aac",
                        mime: "audio/aac"
                    };
                    if (this.check([
                        2
                    ], {
                        offset: t + 1,
                        mask: [
                            6
                        ]
                    })) return {
                        ext: "mp3",
                        mime: "audio/mpeg"
                    };
                    if (this.check([
                        4
                    ], {
                        offset: t + 1,
                        mask: [
                            6
                        ]
                    })) return {
                        ext: "mp2",
                        mime: "audio/mpeg"
                    };
                    if (this.check([
                        6
                    ], {
                        offset: t + 1,
                        mask: [
                            6
                        ]
                    })) return {
                        ext: "mp1",
                        mime: "audio/mpeg"
                    };
                }
            }
        }, new Set(ph), new Set(dh);
    });
    var wh = {};
    V(wh, {
        fileCommand: ()=>pA
    });
    function lA(e, t) {
        if (bh[e]) return bh[e];
        let [n, r] = t.split("/"), s = r?.split("+")[0]?.replace(/-/g, " ") || e;
        switch(n){
            case "image":
                return `${s.toUpperCase()} image data`;
            case "audio":
                return `${s.toUpperCase()} audio`;
            case "video":
                return `${s.toUpperCase()} video`;
            case "font":
                return `${s} font`;
            case "model":
                return `${s} 3D model`;
            case "application":
                return r?.includes("zip") || r?.includes("compressed") ? `${s} archive data` : r?.includes("executable") ? `${s} executable` : `${e.toUpperCase()} data`;
            default:
                return `${e.toUpperCase()} data`;
        }
    }
    function cA(e) {
        let t = e.split("/").pop() || e;
        if (t.startsWith(".") && !t.includes(".", 1)) return t;
        let n = t.lastIndexOf(".");
        return n === -1 || n === 0 ? "" : t.slice(n).toLowerCase();
    }
    function uA(e, t) {
        if (e.startsWith("#!")) {
            let l = e.split(`
`)[0];
            return l.includes("python") ? {
                description: "Python script, ASCII text executable",
                mime: "text/x-python"
            } : l.includes("node") || l.includes("bun") || l.includes("deno") ? {
                description: "JavaScript script, ASCII text executable",
                mime: "text/javascript"
            } : l.includes("bash") ? {
                description: "Bourne-Again shell script, ASCII text executable",
                mime: "text/x-shellscript"
            } : l.includes("sh") ? {
                description: "POSIX shell script, ASCII text executable",
                mime: "text/x-shellscript"
            } : l.includes("ruby") ? {
                description: "Ruby script, ASCII text executable",
                mime: "text/x-ruby"
            } : l.includes("perl") ? {
                description: "Perl script, ASCII text executable",
                mime: "text/x-perl"
            } : {
                description: "script, ASCII text executable",
                mime: "text/plain"
            };
        }
        let n = e.trimStart();
        if (n.startsWith("<?xml")) return {
            description: "XML document",
            mime: "application/xml"
        };
        if (n.startsWith("<!DOCTYPE html") || n.toLowerCase().startsWith("<html")) return {
            description: "HTML document",
            mime: "text/html"
        };
        let r = e.includes(`\r
`), s = e.includes("\r") && !r, i = "";
        r ? i = ", with CRLF line terminators" : s && (i = ", with CR line terminators");
        let o = cA(t);
        if (o && yh[o]) {
            let l = yh[o];
            return l.mime.startsWith("text/") && i ? {
                description: `${l.description}${i}`,
                mime: l.mime
            } : l;
        }
        let a = false;
        for(let l = 0; l < Math.min(e.length, 8192); l++)if (e.charCodeAt(l) > 127) {
            a = true;
            break;
        }
        return a ? {
            description: `UTF-8 Unicode text${i}`,
            mime: "text/plain; charset=utf-8"
        } : {
            description: `ASCII text${i}`,
            mime: "text/plain"
        };
    }
    async function fA(e, t) {
        if (t.length === 0) return {
            description: "empty",
            mime: "inode/x-empty"
        };
        let n = await mh(t);
        if (n) return {
            description: lA(n.ext, n.mime),
            mime: n.mime
        };
        let r = new TextDecoder("utf-8", {
            fatal: false
        }).decode(t);
        return uA(r, e);
    }
    var aA, yh, bh, pA, xh = v(()=>{
        gh();
        X();
        aA = {
            name: "file",
            summary: "determine file type",
            usage: "file [OPTION]... FILE...",
            options: [
                "-b, --brief          do not prepend filenames to output",
                "-i, --mime           output MIME type strings",
                "-L, --dereference    follow symlinks",
                "    --help           display this help and exit"
            ]
        }, yh = {
            ".js": {
                description: "JavaScript source",
                mime: "text/javascript"
            },
            ".mjs": {
                description: "JavaScript module",
                mime: "text/javascript"
            },
            ".cjs": {
                description: "CommonJS module",
                mime: "text/javascript"
            },
            ".ts": {
                description: "TypeScript source",
                mime: "text/typescript"
            },
            ".tsx": {
                description: "TypeScript JSX source",
                mime: "text/typescript"
            },
            ".jsx": {
                description: "JavaScript JSX source",
                mime: "text/javascript"
            },
            ".py": {
                description: "Python script",
                mime: "text/x-python"
            },
            ".rb": {
                description: "Ruby script",
                mime: "text/x-ruby"
            },
            ".go": {
                description: "Go source",
                mime: "text/x-go"
            },
            ".rs": {
                description: "Rust source",
                mime: "text/x-rust"
            },
            ".c": {
                description: "C source",
                mime: "text/x-c"
            },
            ".h": {
                description: "C header",
                mime: "text/x-c"
            },
            ".cpp": {
                description: "C++ source",
                mime: "text/x-c++"
            },
            ".hpp": {
                description: "C++ header",
                mime: "text/x-c++"
            },
            ".java": {
                description: "Java source",
                mime: "text/x-java"
            },
            ".sh": {
                description: "Bourne-Again shell script",
                mime: "text/x-shellscript"
            },
            ".bash": {
                description: "Bourne-Again shell script",
                mime: "text/x-shellscript"
            },
            ".zsh": {
                description: "Zsh shell script",
                mime: "text/x-shellscript"
            },
            ".json": {
                description: "JSON data",
                mime: "application/json"
            },
            ".yaml": {
                description: "YAML data",
                mime: "text/yaml"
            },
            ".yml": {
                description: "YAML data",
                mime: "text/yaml"
            },
            ".xml": {
                description: "XML document",
                mime: "application/xml"
            },
            ".csv": {
                description: "CSV text",
                mime: "text/csv"
            },
            ".toml": {
                description: "TOML data",
                mime: "text/toml"
            },
            ".html": {
                description: "HTML document",
                mime: "text/html"
            },
            ".htm": {
                description: "HTML document",
                mime: "text/html"
            },
            ".css": {
                description: "CSS stylesheet",
                mime: "text/css"
            },
            ".svg": {
                description: "SVG image",
                mime: "image/svg+xml"
            },
            ".md": {
                description: "Markdown document",
                mime: "text/markdown"
            },
            ".markdown": {
                description: "Markdown document",
                mime: "text/markdown"
            },
            ".txt": {
                description: "ASCII text",
                mime: "text/plain"
            },
            ".rst": {
                description: "reStructuredText",
                mime: "text/x-rst"
            },
            ".env": {
                description: "ASCII text",
                mime: "text/plain"
            },
            ".gitignore": {
                description: "ASCII text",
                mime: "text/plain"
            },
            ".dockerignore": {
                description: "ASCII text",
                mime: "text/plain"
            }
        }, bh = {
            jpg: "JPEG image data",
            jpeg: "JPEG image data",
            png: "PNG image data",
            gif: "GIF image data",
            webp: "WebP image data",
            bmp: "PC bitmap",
            ico: "MS Windows icon resource",
            tif: "TIFF image data",
            tiff: "TIFF image data",
            psd: "Adobe Photoshop Document",
            avif: "AVIF image",
            heic: "HEIC image",
            heif: "HEIF image",
            jxl: "JPEG XL image",
            icns: "Mac OS X icon",
            svg: "SVG Scalable Vector Graphics image",
            pdf: "PDF document",
            epub: "EPUB document",
            mobi: "Mobipocket E-book",
            djvu: "DjVu document",
            zip: "Zip archive data",
            gz: "gzip compressed data",
            gzip: "gzip compressed data",
            bz2: "bzip2 compressed data",
            xz: "XZ compressed data",
            tar: "POSIX tar archive",
            rar: "RAR archive data",
            "7z": "7-zip archive data",
            lz: "lzip compressed data",
            lzma: "LZMA compressed data",
            zst: "Zstandard compressed data",
            cab: "Microsoft Cabinet archive",
            ar: "Unix ar archive",
            rpm: "RPM package",
            deb: "Debian binary package",
            apk: "Android Package",
            dmg: "Apple disk image",
            iso: "ISO 9660 CD-ROM filesystem data",
            vhd: "Microsoft Virtual Hard Disk",
            vhdx: "Microsoft Virtual Hard Disk (new format)",
            qcow2: "QEMU QCOW Image",
            mp3: "Audio file with ID3",
            m4a: "MPEG-4 audio",
            aac: "AAC audio",
            wav: "RIFF (little-endian) data, WAVE audio",
            flac: "FLAC audio bitstream data",
            ogg: "Ogg data",
            oga: "Ogg audio",
            opus: "Ogg Opus audio",
            aiff: "AIFF audio",
            wma: "Windows Media Audio",
            amr: "AMR audio",
            mid: "MIDI audio",
            midi: "MIDI audio",
            ape: "Monkey's Audio",
            mp4: "ISO Media, MPEG-4",
            m4v: "MPEG-4 video",
            webm: "WebM",
            avi: "RIFF (little-endian) data, AVI",
            mov: "ISO Media, Apple QuickTime movie",
            mkv: "Matroska data",
            wmv: "Windows Media Video",
            flv: "Flash Video",
            "3gp": "3GPP multimedia",
            "3g2": "3GPP2 multimedia",
            ogv: "Ogg video",
            mts: "MPEG transport stream",
            m2ts: "MPEG transport stream",
            ts: "MPEG transport stream",
            mpg: "MPEG video",
            mpeg: "MPEG video",
            exe: "PE32 executable",
            dll: "PE32 DLL",
            elf: "ELF executable",
            mach: "Mach-O executable",
            wasm: "WebAssembly (wasm) binary module",
            dex: "Android Dalvik executable",
            class: "Java class file",
            swf: "Adobe Flash",
            doc: "Microsoft Word Document",
            docx: "Microsoft Word 2007+ Document",
            xls: "Microsoft Excel Spreadsheet",
            xlsx: "Microsoft Excel 2007+ Spreadsheet",
            ppt: "Microsoft PowerPoint Presentation",
            pptx: "Microsoft PowerPoint 2007+ Presentation",
            odt: "OpenDocument Text",
            ods: "OpenDocument Spreadsheet",
            odp: "OpenDocument Presentation",
            ttf: "TrueType Font",
            otf: "OpenType Font",
            woff: "Web Open Font Format",
            woff2: "Web Open Font Format 2",
            eot: "Embedded OpenType font",
            stl: "Stereolithography CAD",
            obj: "Wavefront 3D Object",
            gltf: "GL Transmission Format",
            glb: "GL Transmission Format (binary)",
            sqlite: "SQLite 3.x database",
            mdb: "Microsoft Access Database",
            xml: "XML document",
            json: "JSON data",
            macho: "Mach-O binary",
            ics: "iCalendar data",
            vcf: "vCard data",
            msi: "Microsoft Installer",
            ps: "PostScript",
            ai: "Adobe Illustrator",
            indd: "Adobe InDesign",
            sketch: "Sketch design file",
            fig: "Figma design file",
            xd: "Adobe XD",
            blend: "Blender",
            fbx: "Autodesk FBX",
            lnk: "MS Windows shortcut",
            alias: "Mac OS alias",
            torrent: "BitTorrent file",
            pcap: "pcap capture file",
            arrow: "Apache Arrow",
            parquet: "Apache Parquet"
        };
        pA = {
            name: "file",
            async execute (e, t) {
                if (_(e)) return F(aA);
                let n = false, r = false, s = [];
                for (let a of e)if (a.startsWith("--")) {
                    if (a === "--brief") n = true;
                    else if (a === "--mime" || a === "--mime-type") r = true;
                    else if (a !== "--dereference") return G("file", a);
                } else if (a.startsWith("-") && a !== "-") {
                    for (let l of a.slice(1))if (l === "b") n = true;
                    else if (l === "i") r = true;
                    else if (l !== "L") return G("file", `-${l}`);
                } else s.push(a);
                if (s.length === 0) return {
                    stdout: "",
                    stderr: `Usage: file [-bLi] FILE...
`,
                    exitCode: 1
                };
                let i = "", o = 0;
                for (let a of s)try {
                    let l = t.fs.resolvePath(t.cwd, a);
                    if ((await t.fs.stat(l)).isDirectory) {
                        let d = r ? "inode/directory" : "directory";
                        i += n ? `${d}
` : `${a}: ${d}
`;
                        continue;
                    }
                    let u = await t.fs.readFileBuffer(l), f = await fA(a, u), p = r ? f.mime : f.description;
                    i += n ? `${p}
` : `${a}: ${p}
`;
                } catch  {
                    i += n ? `cannot open
` : `${a}: cannot open (No such file or directory)
`, o = 1;
                }
                return {
                    stdout: i,
                    stderr: "",
                    exitCode: o
                };
            }
        };
    });
    var Eh = {};
    V(Eh, {
        htmlToMarkdownCommand: ()=>mA
    });
    var hA, mA, Sh = v(()=>{
        X();
        hA = {
            name: "html-to-markdown",
            summary: "convert HTML to Markdown (BashEnv extension)",
            usage: "html-to-markdown [OPTION]... [FILE]",
            description: [
                "Convert HTML content to Markdown format using the turndown library.",
                "This is a non-standard BashEnv extension command, not available in regular bash.",
                "",
                "Read HTML from FILE or standard input and output Markdown to standard output.",
                "Commonly used with curl to convert web pages:",
                "  curl -s https://example.com | html-to-markdown",
                "",
                "Supported HTML elements:",
                "  - Headings (h1-h6)  # Markdown headings",
                "  - Paragraphs (p)  Plain text with blank lines",
                "  - Links (a)  [text](url)",
                "  - Images (img)  ![alt](src)",
                "  - Bold/Strong  **text**",
                "  - Italic/Em  _text_",
                "  - Code (code, pre)  `inline` or fenced blocks",
                "  - Lists (ul, ol, li)  - or 1. items",
                "  - Blockquotes  > quoted text",
                "  - Horizontal rules (hr)  ---"
            ],
            options: [
                "-b, --bullet=CHAR     bullet character for unordered lists (-, +, or *)",
                "-c, --code=FENCE      fence style for code blocks (``` or ~~~)",
                "-r, --hr=STRING       string for horizontal rules (default: ---)",
                "    --heading-style=STYLE",
                "                      heading style: 'atx' for # headings (default),",
                "                      'setext' for underlined headings (h1/h2 only)",
                "    --help            display this help and exit"
            ],
            examples: [
                "echo '<h1>Hello</h1><p>World</p>' | html-to-markdown",
                "html-to-markdown page.html",
                "curl -s https://example.com | html-to-markdown > page.md"
            ]
        }, mA = {
            name: "html-to-markdown",
            async execute (e, t) {
                if (_(e)) return F(hA);
                let n = "-", r = "```", s = "---", i = "atx", o = [];
                for(let l = 0; l < e.length; l++){
                    let c = e[l];
                    if (c === "-b" || c === "--bullet") n = e[++l] ?? "-";
                    else if (c.startsWith("--bullet=")) n = c.slice(9);
                    else if (c === "-c" || c === "--code") r = e[++l] ?? "```";
                    else if (c.startsWith("--code=")) r = c.slice(7);
                    else if (c === "-r" || c === "--hr") s = e[++l] ?? "---";
                    else if (c.startsWith("--hr=")) s = c.slice(5);
                    else if (c.startsWith("--heading-style=")) {
                        let u = c.slice(16);
                        (u === "setext" || u === "atx") && (i = u);
                    } else if (c === "-") o.push("-");
                    else {
                        if (c.startsWith("--")) return G("html-to-markdown", c);
                        if (c.startsWith("-")) return G("html-to-markdown", c);
                        o.push(c);
                    }
                }
                let a;
                if (o.length === 0 || o.length === 1 && o[0] === "-") a = t.stdin;
                else try {
                    let l = t.fs.resolvePath(t.cwd, o[0]);
                    a = await t.fs.readFile(l);
                } catch  {
                    return {
                        stdout: "",
                        stderr: `html-to-markdown: ${o[0]}: No such file or directory
`,
                        exitCode: 1
                    };
                }
                if (!a.trim()) return {
                    stdout: "",
                    stderr: "",
                    exitCode: 0
                };
                try {
                    let l = new TurndownService({
                        bulletListMarker: n,
                        codeBlockStyle: "fenced",
                        fence: r,
                        hr: s,
                        headingStyle: i
                    });
                    return l.remove([
                        "script",
                        "style",
                        "footer"
                    ]), {
                        stdout: `${l.turndown(a).trim()}
`,
                        stderr: "",
                        exitCode: 0
                    };
                } catch (l) {
                    return {
                        stdout: "",
                        stderr: `html-to-markdown: conversion error: ${l.message}
`,
                        exitCode: 1
                    };
                }
            }
        };
    });
    var Ah = {};
    V(Ah, {
        helpCommand: ()=>bA
    });
    function yA(e) {
        let t = [], n = new Set(e);
        t.push(`Available commands:
`);
        let r = [];
        for (let [s, i] of Object.entries(gA)){
            let o = i.filter((a)=>n.has(a));
            if (o.length > 0) {
                t.push(`  ${s}:`), t.push(`    ${o.join(", ")}
`);
                for (let a of o)n.delete(a);
            }
        }
        for (let s of n)r.push(s);
        return r.length > 0 && (t.push("  Other:"), t.push(`    ${r.sort().join(", ")}
`)), t.push("Use '<command> --help' for details on a specific command."), `${t.join(`
`)}
`;
    }
    var gA, bA, Ch = v(()=>{
        gA = {
            "File operations": [
                "ls",
                "cat",
                "head",
                "tail",
                "wc",
                "touch",
                "mkdir",
                "rm",
                "cp",
                "mv",
                "ln",
                "chmod",
                "stat",
                "readlink"
            ],
            "Text processing": [
                "grep",
                "sed",
                "awk",
                "sort",
                "uniq",
                "cut",
                "tr",
                "tee",
                "diff"
            ],
            Search: [
                "find"
            ],
            "Navigation & paths": [
                "pwd",
                "basename",
                "dirname",
                "tree",
                "du"
            ],
            "Environment & shell": [
                "echo",
                "printf",
                "env",
                "printenv",
                "export",
                "alias",
                "unalias",
                "history",
                "clear",
                "true",
                "false",
                "bash",
                "sh"
            ],
            "Data processing": [
                "xargs",
                "jq",
                "base64",
                "date"
            ],
            Network: [
                "curl",
                "html-to-markdown"
            ]
        };
        bA = {
            name: "help",
            async execute (e, t) {
                if (e.includes("--help") || e.includes("-h")) return {
                    stdout: `help - display available commands

Usage: help [command]

Options:
  -h, --help    Show this help message

If a command name is provided, shows help for that command.
Otherwise, lists all available commands.
`,
                    stderr: "",
                    exitCode: 0
                };
                if (e.length > 0 && t.exec) {
                    let r = e[0];
                    return t.exec(`${r} --help`, {
                        cwd: t.cwd
                    });
                }
                let n = t.getRegisteredCommands?.() ?? [];
                return {
                    stdout: yA(n),
                    stderr: "",
                    exitCode: 0
                };
            }
        };
    });
    var Nh = {};
    V(Nh, {
        whichCommand: ()=>EA
    });
    var wA, xA, EA, kh = v(()=>{
        Oe();
        X();
        wA = {
            name: "which",
            summary: "locate a command",
            usage: "which [-as] program ...",
            options: [
                "-a         List all instances of executables found",
                "-s         No output, just return 0 if found, 1 if not",
                "--help     display this help and exit"
            ]
        }, xA = {
            showAll: {
                short: "a",
                type: "boolean"
            },
            silent: {
                short: "s",
                type: "boolean"
            }
        }, EA = {
            name: "which",
            async execute (e, t) {
                if (_(e)) return F(wA);
                let n = fe("which", e, xA);
                if (!n.ok) return n.error;
                let r = n.result.flags.showAll, s = n.result.flags.silent, i = n.result.positional;
                if (i.length === 0) return {
                    stdout: "",
                    stderr: "",
                    exitCode: 1
                };
                let a = (t.env.PATH || "/usr/bin:/bin").split(":"), l = "", c = true;
                for (let u of i){
                    let f = false;
                    for (let p of a){
                        if (!p) continue;
                        let d = `${p}/${u}`;
                        if (await t.fs.exists(d) && (f = true, s || (l += `${d}
`), !r)) break;
                    }
                    f || (c = false);
                }
                return {
                    stdout: l,
                    stderr: "",
                    exitCode: c ? 0 : 1
                };
            }
        };
    });
    var vh = {};
    V(vh, {
        tac: ()=>AA
    });
    async function SA(e, t) {
        if (e.length > 0 && e[0] !== "-") {
            let s = e[0].startsWith("/") ? e[0] : `${t.cwd}/${e[0]}`;
            try {
                let o = (await t.fs.readFile(s)).split(`
`);
                o[o.length - 1] === "" && o.pop();
                let a = o.reverse();
                return {
                    stdout: a.length > 0 ? `${a.join(`
`)}
` : "",
                    stderr: "",
                    exitCode: 0
                };
            } catch  {
                return {
                    stdout: "",
                    stderr: `tac: ${e[0]}: No such file or directory
`,
                    exitCode: 1
                };
            }
        }
        let n = t.stdin.split(`
`);
        n[n.length - 1] === "" && n.pop();
        let r = n.reverse();
        return {
            stdout: r.length > 0 ? `${r.join(`
`)}
` : "",
            stderr: "",
            exitCode: 0
        };
    }
    var AA, $h = v(()=>{
        AA = {
            name: "tac",
            execute: SA
        };
    });
    var Ih = {};
    V(Ih, {
        hostname: ()=>NA
    });
    async function CA(e, t) {
        return {
            stdout: `localhost
`,
            stderr: "",
            exitCode: 0
        };
    }
    var NA, Rh = v(()=>{
        NA = {
            name: "hostname",
            execute: CA
        };
    });
    var Ph = {};
    V(Ph, {
        whoami: ()=>vA
    });
    async function kA(e, t) {
        return {
            stdout: `user
`,
            stderr: "",
            exitCode: 0
        };
    }
    var vA, Th = v(()=>{
        vA = {
            name: "whoami",
            execute: kA
        };
    });
    var Oh = {};
    V(Oh, {
        od: ()=>IA
    });
    async function $A(e, t) {
        let n = "octal", r = [], s = [];
        for(let d = 0; d < e.length; d++){
            let m = e[d];
            if (m === "-c") r.push("char");
            else if (m === "-An" || m === "-A" && e[d + 1] === "n") n = "none", m === "-A" && d++;
            else if (m === "-t" && e[d + 1]) {
                let h = e[++d];
                h === "x1" ? r.push("hex") : h === "c" ? r.push("char") : h.startsWith("o") && r.push("octal");
            } else (!m.startsWith("-") || m === "-") && s.push(m);
        }
        r.length === 0 && r.push("octal");
        let i = t.stdin;
        if (s.length > 0 && s[0] !== "-") {
            let d = s[0].startsWith("/") ? s[0] : `${t.cwd}/${s[0]}`;
            try {
                i = await t.fs.readFile(d);
            } catch  {
                return {
                    stdout: "",
                    stderr: `od: ${s[0]}: No such file or directory
`,
                    exitCode: 1
                };
            }
        }
        let o = r.includes("char");
        function a(d) {
            return d === 0 ? "  \\0" : d === 7 ? "  \\a" : d === 8 ? "  \\b" : d === 9 ? "  \\t" : d === 10 ? "  \\n" : d === 11 ? "  \\v" : d === 12 ? "  \\f" : d === 13 ? "  \\r" : d >= 32 && d < 127 ? `   ${String.fromCharCode(d)}` : ` ${d.toString(8).padStart(3, "0")}`;
        }
        function l(d) {
            return o ? `  ${d.toString(16).padStart(2, "0")}` : ` ${d.toString(16).padStart(2, "0")}`;
        }
        function c(d) {
            return ` ${d.toString(8).padStart(3, "0")}`;
        }
        let u = [];
        for (let d of i)u.push(d.charCodeAt(0));
        let f = 16, p = [];
        for(let d = 0; d < u.length; d += f){
            let m = u.slice(d, d + f);
            for(let h = 0; h < r.length; h++){
                let g = r[h], b;
                g === "char" ? b = m.map(a) : g === "hex" ? b = m.map(l) : b = m.map(c);
                let y = "";
                h === 0 && n !== "none" ? y = `${d.toString(8).padStart(7, "0")} ` : (h > 0 || n === "none") && (y = n === "none" ? "" : "        "), p.push(y + b.join(""));
            }
        }
        return n !== "none" && u.length > 0 && p.push(u.length.toString(8).padStart(7, "0")), {
            stdout: p.length > 0 ? `${p.join(`
`)}
` : "",
            stderr: "",
            exitCode: 0
        };
    }
    var IA, Dh = v(()=>{
        IA = {
            name: "od",
            execute: $A
        };
    });
    var js = {};
    V(js, {
        gunzipCommand: ()=>MA,
        gzipCommand: ()=>LA,
        zcatCommand: ()=>WA
    });
    function _h(e) {
        return e.best ? constants$3.Z_BEST_COMPRESSION : e.level8 ? 8 : e.level7 ? 7 : e.level6 ? 6 : e.level5 ? 5 : e.level4 ? 4 : e.level3 ? 3 : e.level2 ? 2 : e.fast ? constants$3.Z_BEST_SPEED : constants$3.Z_DEFAULT_COMPRESSION;
    }
    function Lh(e) {
        if (e.length < 10) return {
            originalName: null,
            mtime: null,
            headerSize: 0
        };
        if (e[0] !== 31 || e[1] !== 139) return {
            originalName: null,
            mtime: null,
            headerSize: 0
        };
        let t = e[3], n = e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, r = 10;
        if (t & 4) {
            if (r + 2 > e.length) return {
                originalName: null,
                mtime: null,
                headerSize: 0
            };
            let i = e[r] | e[r + 1] << 8;
            r += 2 + i;
        }
        let s = null;
        if (t & 8) {
            let i = r;
            for(; r < e.length && e[r] !== 0;)r++;
            r < e.length && (s = new TextDecoder().decode(e.slice(i, r)), r++);
        }
        if (t & 16) {
            for(; r < e.length && e[r] !== 0;)r++;
            r++;
        }
        return t & 2 && (r += 2), {
            originalName: s,
            mtime: n > 0 ? new Date(n * 1e3) : null,
            headerSize: r
        };
    }
    function DA(e) {
        if (e.length < 4) return 0;
        let t = e.length;
        return e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24;
    }
    function zs(e) {
        return e.length >= 2 && e[0] === 31 && e[1] === 139;
    }
    async function Mh(e, t, n, r, s, i) {
        let o = n.suffix, a, l, c;
        if (t === "-" || t === "") if (c = Uint8Array.from(e.stdin, (u)=>u.charCodeAt(0)), s) {
            if (!zs(c)) return n.quiet ? {
                stdout: "",
                stderr: "",
                exitCode: 1
            } : {
                stdout: "",
                stderr: `${r}: stdin: not in gzip format
`,
                exitCode: 1
            };
            try {
                let u = gunzipSync(c);
                return {
                    stdout: String.fromCharCode(...u),
                    stderr: "",
                    exitCode: 0
                };
            } catch (u) {
                let f = u instanceof Error ? u.message : "unknown error";
                return {
                    stdout: "",
                    stderr: `${r}: stdin: ${f}
`,
                    exitCode: 1
                };
            }
        } else {
            _h(n);
            let f = gzipSync(c);
            return {
                stdout: String.fromCharCode(...f),
                stderr: "",
                exitCode: 0
            };
        }
        a = e.fs.resolvePath(e.cwd, t);
        try {
            if ((await e.fs.stat(a)).isDirectory) return n.recursive ? await Wh(e, a, n, r, s, i) : n.quiet ? {
                stdout: "",
                stderr: "",
                exitCode: 1
            } : {
                stdout: "",
                stderr: `${r}: ${t}: is a directory -- ignored
`,
                exitCode: 1
            };
        } catch  {
            return {
                stdout: "",
                stderr: `${r}: ${t}: No such file or directory
`,
                exitCode: 1
            };
        }
        try {
            c = await e.fs.readFileBuffer(a);
        } catch  {
            return {
                stdout: "",
                stderr: `${r}: ${t}: No such file or directory
`,
                exitCode: 1
            };
        }
        if (s) {
            if (!t.endsWith(o)) return n.quiet ? {
                stdout: "",
                stderr: "",
                exitCode: 1
            } : {
                stdout: "",
                stderr: `${r}: ${t}: unknown suffix -- ignored
`,
                exitCode: 1
            };
            if (!zs(c)) return n.quiet ? {
                stdout: "",
                stderr: "",
                exitCode: 1
            } : {
                stdout: "",
                stderr: `${r}: ${t}: not in gzip format
`,
                exitCode: 1
            };
            let u;
            try {
                u = gunzipSync(c);
            } catch (f) {
                let p = f instanceof Error ? f.message : "unknown error";
                return {
                    stdout: "",
                    stderr: `${r}: ${t}: ${p}
`,
                    exitCode: 1
                };
            }
            if (i) return {
                stdout: String.fromCharCode(...u),
                stderr: "",
                exitCode: 0
            };
            if (n.name) {
                let f = Lh(c);
                f.originalName ? l = e.fs.resolvePath(e.cwd, f.originalName) : l = a.slice(0, -o.length);
            } else l = a.slice(0, -o.length);
            if (!n.force) try {
                return await e.fs.stat(l), {
                    stdout: "",
                    stderr: `${r}: ${l} already exists; not overwritten
`,
                    exitCode: 1
                };
            } catch  {}
            if (await e.fs.writeFile(l, u), !n.keep && !i && await e.fs.rm(a), n.verbose) {
                let f = c.length > 0 ? ((1 - c.length / u.length) * 100).toFixed(1) : "0.0";
                return {
                    stdout: "",
                    stderr: `${t}:	${f}% -- replaced with ${l.split("/").pop()}
`,
                    exitCode: 0
                };
            }
            return {
                stdout: "",
                stderr: "",
                exitCode: 0
            };
        } else {
            if (t.endsWith(o)) return n.quiet ? {
                stdout: "",
                stderr: "",
                exitCode: 1
            } : {
                stdout: "",
                stderr: `${r}: ${t} already has ${o} suffix -- unchanged
`,
                exitCode: 1
            };
            let u = _h(n), f;
            try {
                f = gzipSync(c, {
                    level: u
                });
            } catch (p) {
                let d = p instanceof Error ? p.message : "unknown error";
                return {
                    stdout: "",
                    stderr: `${r}: ${t}: ${d}
`,
                    exitCode: 1
                };
            }
            if (i) return {
                stdout: String.fromCharCode(...f),
                stderr: "",
                exitCode: 0
            };
            if (l = a + o, !n.force) try {
                return await e.fs.stat(l), {
                    stdout: "",
                    stderr: `${r}: ${l} already exists; not overwritten
`,
                    exitCode: 1
                };
            } catch  {}
            if (await e.fs.writeFile(l, f), !n.keep && !i && await e.fs.rm(a), n.verbose) {
                let p = c.length > 0 ? ((1 - f.length / c.length) * 100).toFixed(1) : "0.0";
                return {
                    stdout: "",
                    stderr: `${t}:	${p}% -- replaced with ${l.split("/").pop()}
`,
                    exitCode: 0
                };
            }
            return {
                stdout: "",
                stderr: "",
                exitCode: 0
            };
        }
    }
    async function Wh(e, t, n, r, s, i) {
        let o = await e.fs.readdir(t), a = "", l = "", c = 0;
        for (let u of o){
            let f = e.fs.resolvePath(t, u), p = await e.fs.stat(f);
            if (p.isDirectory) {
                let d = await Wh(e, f, n, r, s, i);
                a += d.stdout, l += d.stderr, d.exitCode !== 0 && (c = d.exitCode);
            } else if (p.isFile) {
                let d = n.suffix;
                if (s && !u.endsWith(d) || !s && u.endsWith(d)) continue;
                let m = f.startsWith(`${e.cwd}/`) ? f.slice(e.cwd.length + 1) : f, h = await Mh(e, m, n, r, s, i);
                a += h.stdout, l += h.stderr, h.exitCode !== 0 && (c = h.exitCode);
            }
        }
        return {
            stdout: a,
            stderr: l,
            exitCode: c
        };
    }
    async function FA(e, t, n, r) {
        let s;
        if (t === "-" || t === "") s = Uint8Array.from(e.stdin, (f)=>f.charCodeAt(0));
        else {
            let f = e.fs.resolvePath(e.cwd, t);
            try {
                s = await e.fs.readFileBuffer(f);
            } catch  {
                return {
                    stdout: "",
                    stderr: `${r}: ${t}: No such file or directory
`,
                    exitCode: 1
                };
            }
        }
        if (!zs(s)) return n.quiet ? {
            stdout: "",
            stderr: "",
            exitCode: 1
        } : {
            stdout: "",
            stderr: `${r}: ${t}: not in gzip format
`,
            exitCode: 1
        };
        let i = s.length, o = DA(s), a = o > 0 ? ((1 - i / o) * 100).toFixed(1) : "0.0", c = Lh(s).originalName || (t === "-" ? "" : t.replace(/\.gz$/, ""));
        return {
            stdout: `${i.toString().padStart(10)} ${o.toString().padStart(10)} ${a.padStart(5)}% ${c}
`,
            stderr: "",
            exitCode: 0
        };
    }
    async function _A(e, t, n, r) {
        let s;
        if (t === "-" || t === "") s = Uint8Array.from(e.stdin, (i)=>i.charCodeAt(0));
        else {
            let i = e.fs.resolvePath(e.cwd, t);
            try {
                s = await e.fs.readFileBuffer(i);
            } catch  {
                return {
                    stdout: "",
                    stderr: `${r}: ${t}: No such file or directory
`,
                    exitCode: 1
                };
            }
        }
        if (!zs(s)) return n.quiet ? {
            stdout: "",
            stderr: "",
            exitCode: 1
        } : {
            stdout: "",
            stderr: `${r}: ${t}: not in gzip format
`,
            exitCode: 1
        };
        try {
            return gunzipSync(s), n.verbose ? {
                stdout: "",
                stderr: `${t}:	OK
`,
                exitCode: 0
            } : {
                stdout: "",
                stderr: "",
                exitCode: 0
            };
        } catch (i) {
            let o = i instanceof Error ? i.message : "invalid";
            return {
                stdout: "",
                stderr: `${r}: ${t}: ${o}
`,
                exitCode: 1
            };
        }
    }
    async function ta(e, t, n) {
        let r = n === "zcat" ? TA : n === "gunzip" ? PA : RA;
        if (_(e)) return F(r);
        let s = fe(n, e, OA);
        if (!s.ok) return s.error.stderr.includes("unrecognized option"), s.error;
        let i = s.result.flags, o = s.result.positional, a = n === "gunzip" || n === "zcat" || i.decompress || i.uncompress, l = n === "zcat" || i.stdout || i.toStdout;
        if (i.list) {
            o.length === 0 && (o = [
                "-"
            ]);
            let p = `  compressed uncompressed  ratio uncompressed_name
`, d = "", m = 0;
            for (let h of o){
                let g = await FA(t, h, i, n);
                p += g.stdout, d += g.stderr, g.exitCode !== 0 && (m = g.exitCode);
            }
            return {
                stdout: p,
                stderr: d,
                exitCode: m
            };
        }
        if (i.test) {
            o.length === 0 && (o = [
                "-"
            ]);
            let p = "", d = "", m = 0;
            for (let h of o){
                let g = await _A(t, h, i, n);
                p += g.stdout, d += g.stderr, g.exitCode !== 0 && (m = g.exitCode);
            }
            return {
                stdout: p,
                stderr: d,
                exitCode: m
            };
        }
        o.length === 0 && (o = [
            "-"
        ]);
        let c = "", u = "", f = 0;
        for (let p of o){
            let d = await Mh(t, p, i, n, a, l);
            c += d.stdout, u += d.stderr, d.exitCode !== 0 && (f = d.exitCode);
        }
        return {
            stdout: c,
            stderr: u,
            exitCode: f
        };
    }
    var RA, PA, TA, OA, LA, MA, WA, Hs = v(()=>{
        Oe();
        X();
        RA = {
            name: "gzip",
            summary: "compress or expand files",
            usage: "gzip [OPTION]... [FILE]...",
            description: `Compress FILEs (by default, in-place).

When no FILE is given, or when FILE is -, read from standard input.

With -d, decompress instead.`,
            options: [
                "-c, --stdout      write to standard output, keep original files",
                "-d, --decompress  decompress",
                "-f, --force       force overwrite of output file",
                "-k, --keep        keep (don't delete) input files",
                "-l, --list        list compressed file contents",
                "-n, --no-name     do not save or restore the original name and timestamp",
                "-N, --name        save or restore the original file name and timestamp",
                "-q, --quiet       suppress all warnings",
                "-r, --recursive   operate recursively on directories",
                "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)",
                "-t, --test        test compressed file integrity",
                "-v, --verbose     verbose mode",
                "-1, --fast        compress faster",
                "-9, --best        compress better",
                "    --help        display this help and exit"
            ]
        }, PA = {
            name: "gunzip",
            summary: "decompress files",
            usage: "gunzip [OPTION]... [FILE]...",
            description: `Decompress FILEs (by default, in-place).

When no FILE is given, or when FILE is -, read from standard input.`,
            options: [
                "-c, --stdout      write to standard output, keep original files",
                "-f, --force       force overwrite of output file",
                "-k, --keep        keep (don't delete) input files",
                "-l, --list        list compressed file contents",
                "-n, --no-name     do not restore the original name and timestamp",
                "-N, --name        restore the original file name and timestamp",
                "-q, --quiet       suppress all warnings",
                "-r, --recursive   operate recursively on directories",
                "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)",
                "-t, --test        test compressed file integrity",
                "-v, --verbose     verbose mode",
                "    --help        display this help and exit"
            ]
        }, TA = {
            name: "zcat",
            summary: "decompress files to stdout",
            usage: "zcat [OPTION]... [FILE]...",
            description: `Decompress FILEs to standard output.

When no FILE is given, or when FILE is -, read from standard input.`,
            options: [
                "-f, --force       force; read compressed data even from a terminal",
                "-l, --list        list compressed file contents",
                "-q, --quiet       suppress all warnings",
                "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)",
                "-t, --test        test compressed file integrity",
                "-v, --verbose     verbose mode",
                "    --help        display this help and exit"
            ]
        }, OA = {
            stdout: {
                short: "c",
                long: "stdout",
                type: "boolean"
            },
            toStdout: {
                long: "to-stdout",
                type: "boolean"
            },
            decompress: {
                short: "d",
                long: "decompress",
                type: "boolean"
            },
            uncompress: {
                long: "uncompress",
                type: "boolean"
            },
            force: {
                short: "f",
                long: "force",
                type: "boolean"
            },
            keep: {
                short: "k",
                long: "keep",
                type: "boolean"
            },
            list: {
                short: "l",
                long: "list",
                type: "boolean"
            },
            noName: {
                short: "n",
                long: "no-name",
                type: "boolean"
            },
            name: {
                short: "N",
                long: "name",
                type: "boolean"
            },
            quiet: {
                short: "q",
                long: "quiet",
                type: "boolean"
            },
            recursive: {
                short: "r",
                long: "recursive",
                type: "boolean"
            },
            suffix: {
                short: "S",
                long: "suffix",
                type: "string",
                default: ".gz"
            },
            test: {
                short: "t",
                long: "test",
                type: "boolean"
            },
            verbose: {
                short: "v",
                long: "verbose",
                type: "boolean"
            },
            fast: {
                short: "1",
                long: "fast",
                type: "boolean"
            },
            level2: {
                short: "2",
                type: "boolean"
            },
            level3: {
                short: "3",
                type: "boolean"
            },
            level4: {
                short: "4",
                type: "boolean"
            },
            level5: {
                short: "5",
                type: "boolean"
            },
            level6: {
                short: "6",
                type: "boolean"
            },
            level7: {
                short: "7",
                type: "boolean"
            },
            level8: {
                short: "8",
                type: "boolean"
            },
            best: {
                short: "9",
                long: "best",
                type: "boolean"
            }
        };
        LA = {
            name: "gzip",
            async execute (e, t) {
                return ta(e, t, "gzip");
            }
        }, MA = {
            name: "gunzip",
            async execute (e, t) {
                return ta(e, t, "gunzip");
            }
        }, WA = {
            name: "zcat",
            async execute (e, t) {
                return ta(e, t, "zcat");
            }
        };
    });
    function na(e) {
        let t = e.indexOf("=");
        if (t >= 0) {
            let n = e.slice(0, t), r = e.slice(t + 1);
            return n ? `${encodeURIComponent(n)}=${encodeURIComponent(r)}` : encodeURIComponent(r);
        }
        return encodeURIComponent(e);
    }
    function ra(e) {
        let t = e.indexOf("=");
        if (t < 0) return null;
        let n = e.slice(0, t), r = e.slice(t + 1), s, i, o = r.match(/;type=([^;]+)$/);
        o && (i = o[1], r = r.slice(0, -o[0].length));
        let a = r.match(/;filename=([^;]+)/);
        return a && (s = a[1], r = r.replace(a[0], "")), (r.startsWith("@") || r.startsWith("<")) && (s = s ?? r.slice(1).split("/").pop()), {
            name: n,
            value: r,
            filename: s,
            contentType: i
        };
    }
    function Bh(e, t) {
        let n = `----CurlFormBoundary${Date.now().toString(36)}`, r = [];
        for (let s of e){
            let i = s.value;
            if (i.startsWith("@") || i.startsWith("<")) {
                let a = i.slice(1);
                i = t.get(a) ?? "";
            }
            let o = `--${n}\r
`;
            s.filename ? (o += `Content-Disposition: form-data; name="${s.name}"; filename="${s.filename}"\r
`, s.contentType && (o += `Content-Type: ${s.contentType}\r
`)) : o += `Content-Disposition: form-data; name="${s.name}"\r
`, o += `\r
${i}\r
`, r.push(o);
        }
        return r.push(`--${n}--\r
`), {
            body: r.join(""),
            boundary: n
        };
    }
    var sa = v(()=>{});
    var Uh, zh = v(()=>{
        Uh = {
            name: "curl",
            summary: "transfer a URL",
            usage: "curl [OPTIONS] URL",
            options: [
                "-X, --request METHOD  HTTP method (GET, POST, PUT, DELETE, etc.)",
                "-H, --header HEADER   Add header (can be used multiple times)",
                "-d, --data DATA       HTTP POST data",
                "    --data-raw DATA   HTTP POST data (no @ interpretation)",
                "    --data-binary DATA  HTTP POST binary data",
                "    --data-urlencode DATA  URL-encode and POST data",
                "-F, --form NAME=VALUE  Multipart form data",
                "-u, --user USER:PASS  HTTP authentication",
                "-A, --user-agent STR  Set User-Agent header",
                "-e, --referer URL     Set Referer header",
                "-b, --cookie DATA     Send cookies (name=value or @file)",
                "-c, --cookie-jar FILE Save cookies to file",
                "-T, --upload-file FILE  Upload file (PUT)",
                "-o, --output FILE     Write output to file",
                "-O, --remote-name     Write to file named from URL",
                "-I, --head            Show headers only (HEAD request)",
                "-i, --include         Include response headers in output",
                "-s, --silent          Silent mode (no progress)",
                "-S, --show-error      Show errors even when silent",
                "-f, --fail            Fail silently on HTTP errors (no output)",
                "-L, --location        Follow redirects (default)",
                "    --max-redirs NUM  Maximum redirects (default: 20)",
                "-m, --max-time SECS   Maximum time for request",
                "    --connect-timeout SECS  Connection timeout",
                "-w, --write-out FMT   Output format after completion",
                "-v, --verbose         Verbose output",
                "    --help            Display this help and exit",
                "",
                "Note: Network access must be configured via BashEnv network option.",
                "      curl is not available by default for security reasons."
            ]
        };
    });
    function jh(e) {
        let t = {
            method: "GET",
            headers: {},
            dataBinary: false,
            formFields: [],
            useRemoteName: false,
            headOnly: false,
            includeHeaders: false,
            silent: false,
            showError: false,
            failSilently: false,
            followRedirects: true,
            verbose: false
        };
        for(let n = 0; n < e.length; n++){
            let r = e[n];
            if (r === "-X" || r === "--request") t.method = e[++n] ?? "GET";
            else if (r.startsWith("-X")) t.method = r.slice(2);
            else if (r.startsWith("--request=")) t.method = r.slice(10);
            else if (r === "-H" || r === "--header") {
                let s = e[++n];
                if (s) {
                    let i = s.indexOf(":");
                    if (i > 0) {
                        let o = s.slice(0, i).trim(), a = s.slice(i + 1).trim();
                        t.headers[o] = a;
                    }
                }
            } else if (r.startsWith("--header=")) {
                let s = r.slice(9), i = s.indexOf(":");
                if (i > 0) {
                    let o = s.slice(0, i).trim(), a = s.slice(i + 1).trim();
                    t.headers[o] = a;
                }
            } else if (r === "-d" || r === "--data" || r === "--data-raw") t.data = e[++n] ?? "", t.method === "GET" && (t.method = "POST");
            else if (r.startsWith("-d")) t.data = r.slice(2), t.method === "GET" && (t.method = "POST");
            else if (r.startsWith("--data=")) t.data = r.slice(7), t.method === "GET" && (t.method = "POST");
            else if (r.startsWith("--data-raw=")) t.data = r.slice(11), t.method === "GET" && (t.method = "POST");
            else if (r === "--data-binary") t.data = e[++n] ?? "", t.dataBinary = true, t.method === "GET" && (t.method = "POST");
            else if (r.startsWith("--data-binary=")) t.data = r.slice(14), t.dataBinary = true, t.method === "GET" && (t.method = "POST");
            else if (r === "--data-urlencode") {
                let s = e[++n] ?? "";
                t.data = (t.data ? `${t.data}&` : "") + na(s), t.method === "GET" && (t.method = "POST");
            } else if (r.startsWith("--data-urlencode=")) {
                let s = r.slice(17);
                t.data = (t.data ? `${t.data}&` : "") + na(s), t.method === "GET" && (t.method = "POST");
            } else if (r === "-F" || r === "--form") {
                let s = e[++n] ?? "", i = ra(s);
                i && t.formFields.push(i), t.method === "GET" && (t.method = "POST");
            } else if (r.startsWith("--form=")) {
                let s = r.slice(7), i = ra(s);
                i && t.formFields.push(i), t.method === "GET" && (t.method = "POST");
            } else if (r === "-u" || r === "--user") t.user = e[++n];
            else if (r.startsWith("-u")) t.user = r.slice(2);
            else if (r.startsWith("--user=")) t.user = r.slice(7);
            else if (r === "-A" || r === "--user-agent") t.headers["User-Agent"] = e[++n] ?? "";
            else if (r.startsWith("-A")) t.headers["User-Agent"] = r.slice(2);
            else if (r.startsWith("--user-agent=")) t.headers["User-Agent"] = r.slice(13);
            else if (r === "-e" || r === "--referer") t.headers.Referer = e[++n] ?? "";
            else if (r.startsWith("-e")) t.headers.Referer = r.slice(2);
            else if (r.startsWith("--referer=")) t.headers.Referer = r.slice(10);
            else if (r === "-b" || r === "--cookie") t.headers.Cookie = e[++n] ?? "";
            else if (r.startsWith("-b")) t.headers.Cookie = r.slice(2);
            else if (r.startsWith("--cookie=")) t.headers.Cookie = r.slice(9);
            else if (r === "-c" || r === "--cookie-jar") t.cookieJar = e[++n];
            else if (r.startsWith("--cookie-jar=")) t.cookieJar = r.slice(13);
            else if (r === "-T" || r === "--upload-file") t.uploadFile = e[++n], t.method === "GET" && (t.method = "PUT");
            else if (r.startsWith("--upload-file=")) t.uploadFile = r.slice(14), t.method === "GET" && (t.method = "PUT");
            else if (r === "-m" || r === "--max-time") {
                let s = parseFloat(e[++n] ?? "0");
                !Number.isNaN(s) && s > 0 && (t.timeoutMs = s * 1e3);
            } else if (r.startsWith("--max-time=")) {
                let s = parseFloat(r.slice(11));
                !Number.isNaN(s) && s > 0 && (t.timeoutMs = s * 1e3);
            } else if (r === "--connect-timeout") {
                let s = parseFloat(e[++n] ?? "0");
                !Number.isNaN(s) && s > 0 && t.timeoutMs === void 0 && (t.timeoutMs = s * 1e3);
            } else if (r.startsWith("--connect-timeout=")) {
                let s = parseFloat(r.slice(18));
                !Number.isNaN(s) && s > 0 && t.timeoutMs === void 0 && (t.timeoutMs = s * 1e3);
            } else if (r === "-o" || r === "--output") t.outputFile = e[++n];
            else if (r.startsWith("--output=")) t.outputFile = r.slice(9);
            else if (r === "-O" || r === "--remote-name") t.useRemoteName = true;
            else if (r === "-I" || r === "--head") t.headOnly = true, t.method = "HEAD";
            else if (r === "-i" || r === "--include") t.includeHeaders = true;
            else if (r === "-s" || r === "--silent") t.silent = true;
            else if (r === "-S" || r === "--show-error") t.showError = true;
            else if (r === "-f" || r === "--fail") t.failSilently = true;
            else if (r === "-L" || r === "--location") t.followRedirects = true;
            else if (r === "--max-redirs") n++;
            else if (!r.startsWith("--max-redirs=")) if (r === "-w" || r === "--write-out") t.writeOut = e[++n];
            else if (r.startsWith("--write-out=")) t.writeOut = r.slice(12);
            else if (r === "-v" || r === "--verbose") t.verbose = true;
            else {
                if (r.startsWith("--") && r !== "--") return G("curl", r);
                if (r.startsWith("-") && r !== "-") for (let s of r.slice(1))switch(s){
                    case "s":
                        t.silent = true;
                        break;
                    case "S":
                        t.showError = true;
                        break;
                    case "f":
                        t.failSilently = true;
                        break;
                    case "L":
                        t.followRedirects = true;
                        break;
                    case "I":
                        t.headOnly = true, t.method = "HEAD";
                        break;
                    case "i":
                        t.includeHeaders = true;
                        break;
                    case "O":
                        t.useRemoteName = true;
                        break;
                    case "v":
                        t.verbose = true;
                        break;
                    default:
                        return G("curl", `-${s}`);
                }
                else r.startsWith("-") || (t.url = r);
            }
        }
        return t;
    }
    var Hh = v(()=>{
        X();
        sa();
    });
    function ia(e) {
        return Object.entries(e).map(([t, n])=>`${t}: ${n}`).join(`\r
`);
    }
    function Vh(e) {
        try {
            return new URL(e).pathname.split("/").pop() || "index.html";
        } catch  {
            return "index.html";
        }
    }
    function oa(e, t) {
        let n = e;
        return n = n.replace(/%\{http_code\}/g, String(t.status)), n = n.replace(/%\{content_type\}/g, t.headers["content-type"] || ""), n = n.replace(/%\{url_effective\}/g, t.url), n = n.replace(/%\{size_download\}/g, String(t.bodyLength)), n = n.replace(/\\n/g, `
`), n;
    }
    var qh = v(()=>{});
    var Gh = {};
    V(Gh, {
        curlCommand: ()=>HA
    });
    async function BA(e, t) {
        if (e.uploadFile) {
            let n = t.fs.resolvePath(t.cwd, e.uploadFile);
            return {
                body: await t.fs.readFile(n)
            };
        }
        if (e.formFields.length > 0) {
            let n = new Map();
            for (let i of e.formFields)if (i.value.startsWith("@") || i.value.startsWith("<")) {
                let o = t.fs.resolvePath(t.cwd, i.value.slice(1));
                try {
                    let a = await t.fs.readFile(o);
                    n.set(i.value.slice(1), a);
                } catch  {
                    n.set(i.value.slice(1), "");
                }
            }
            let { body: r, boundary: s } = Bh(e.formFields, n);
            return {
                body: r,
                contentType: `multipart/form-data; boundary=${s}`
            };
        }
        return e.data !== void 0 ? {
            body: e.data
        } : {};
    }
    function UA(e, t) {
        let n = {
            ...e.headers
        };
        if (e.user) {
            let r = Buffer.from(e.user).toString("base64");
            n.Authorization = `Basic ${r}`;
        }
        return t && !n["Content-Type"] && (n["Content-Type"] = t), n;
    }
    async function zA(e, t, n) {
        if (!e.cookieJar) return;
        let r = t["set-cookie"];
        if (!r) return;
        let s = n.fs.resolvePath(n.cwd, e.cookieJar);
        await n.fs.writeFile(s, r);
    }
    function jA(e, t, n) {
        let r = "";
        if (e.verbose) {
            r += `> ${e.method} ${n}
`;
            for (let [s, i] of Object.entries(e.headers))r += `> ${s}: ${i}
`;
            r += `>
`, r += `< HTTP/1.1 ${t.status} ${t.statusText}
`;
            for (let [s, i] of Object.entries(t.headers))r += `< ${s}: ${i}
`;
            r += `<
`;
        }
        return e.includeHeaders && !e.verbose && (r += `HTTP/1.1 ${t.status} ${t.statusText}\r
`, r += ia(t.headers), r += `\r
\r
`), e.headOnly ? e.includeHeaders || e.verbose || (r += `HTTP/1.1 ${t.status} ${t.statusText}\r
`, r += ia(t.headers), r += `\r
`) : r += t.body, e.writeOut && (r += oa(e.writeOut, {
            status: t.status,
            headers: t.headers,
            url: t.url,
            bodyLength: t.body.length
        })), r;
    }
    var HA, Zh = v(()=>{
        wt();
        X();
        sa();
        zh();
        Hh();
        qh();
        HA = {
            name: "curl",
            async execute (e, t) {
                if (_(e)) return F(Uh);
                let n = jh(e);
                if ("exitCode" in n) return n;
                let r = n;
                if (!r.url) return {
                    stdout: "",
                    stderr: `curl: no URL specified
`,
                    exitCode: 2
                };
                if (!t.fetch) return {
                    stdout: "",
                    stderr: `curl: internal error: fetch not available
`,
                    exitCode: 1
                };
                let s = r.url;
                s.match(/^https?:\/\//) || (s = `https://${s}`);
                try {
                    let { body: i, contentType: o } = await BA(r, t), a = UA(r, o), l = await t.fetch(s, {
                        method: r.method,
                        headers: Object.keys(a).length > 0 ? a : void 0,
                        body: i,
                        followRedirects: r.followRedirects,
                        timeoutMs: r.timeoutMs
                    });
                    if (await zA(r, l.headers, t), r.failSilently && l.status >= 400) return {
                        stdout: "",
                        stderr: r.showError || !r.silent ? `curl: (22) The requested URL returned error: ${l.status}
` : "",
                        exitCode: 22
                    };
                    let c = jA(r, l, s);
                    if (r.outputFile || r.useRemoteName) {
                        let u = r.outputFile || Vh(s), f = t.fs.resolvePath(t.cwd, u);
                        await t.fs.writeFile(f, r.headOnly ? "" : l.body), r.verbose || (c = ""), r.writeOut && (c = oa(r.writeOut, {
                            status: l.status,
                            headers: l.headers,
                            url: l.url,
                            bodyLength: l.body.length
                        }));
                    }
                    return {
                        stdout: c,
                        stderr: "",
                        exitCode: 0
                    };
                } catch (i) {
                    let o = Ne(i), a = 1;
                    return o.includes("Network access denied") ? a = 7 : o.includes("HTTP method") && o.includes("not allowed") ? a = 3 : o.includes("Redirect target not in allow-list") || o.includes("Too many redirects") ? a = 47 : o.includes("aborted") && (a = 28), {
                        stdout: "",
                        stderr: !r.silent || r.showError ? `curl: (${a}) ${o}
` : "",
                        exitCode: a
                    };
                }
            }
        };
    });
    function Dr() {
        return {
            pid: process.pid,
            ppid: process.ppid,
            uid: process.getuid?.() ?? 1e3,
            gid: process.getgid?.() ?? 1e3
        };
    }
    function im() {
        let { pid: e, ppid: t, uid: n, gid: r } = Dr();
        return `Name:	bash
State:	R (running)
Pid:	${e}
PPid:	${t}
Uid:	${n}	${n}	${n}	${n}
Gid:	${r}	${r}	${r}	${r}
`;
    }
    var rm, sm, ca = v(()=>{
        rm = "5.1.0(1)-release", sm = "Linux version 5.15.0-generic (just-bash) #1 SMP PREEMPT";
    });
    function am(e) {
        let t = e.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
        if (!t) return false;
        let n = e.slice(t[0].length);
        if (n === "" || n === "+") return true;
        if (n[0] === "[") {
            let r = 0, s = 0;
            for(; s < n.length; s++)if (n[s] === "[") r++;
            else if (n[s] === "]" && (r--, r === 0)) break;
            if (r !== 0 || s >= n.length) return false;
            let i = n.slice(s + 1);
            return i === "" || i === "+";
        }
        return false;
    }
    function lm(e) {
        let t = 0;
        for(let n = 0; n < e.length; n++){
            let r = e[n];
            if (r === "[") t++;
            else if (r === "]") t--;
            else {
                if (t === 0 && r === "=") return n;
                if (t === 0 && r === "+" && e[n + 1] === "=") return n + 1;
            }
        }
        return -1;
    }
    function aC(e) {
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e);
    }
    function cm(e) {
        return e === " " || e === "	" || e === `
` || e === ";" || e === "&" || e === "|" || e === "(" || e === ")" || e === "<" || e === ">";
    }
    var x, Sn, Gs, sC, iC, oC, Zs, tn = v(()=>{
        (function(e) {
            e.EOF = "EOF", e.NEWLINE = "NEWLINE", e.SEMICOLON = "SEMICOLON", e.AMP = "AMP", e.PIPE = "PIPE", e.PIPE_AMP = "PIPE_AMP", e.AND_AND = "AND_AND", e.OR_OR = "OR_OR", e.BANG = "BANG", e.LESS = "LESS", e.GREAT = "GREAT", e.DLESS = "DLESS", e.DGREAT = "DGREAT", e.LESSAND = "LESSAND", e.GREATAND = "GREATAND", e.LESSGREAT = "LESSGREAT", e.DLESSDASH = "DLESSDASH", e.CLOBBER = "CLOBBER", e.TLESS = "TLESS", e.AND_GREAT = "AND_GREAT", e.AND_DGREAT = "AND_DGREAT", e.LPAREN = "LPAREN", e.RPAREN = "RPAREN", e.LBRACE = "LBRACE", e.RBRACE = "RBRACE", e.DSEMI = "DSEMI", e.SEMI_AND = "SEMI_AND", e.SEMI_SEMI_AND = "SEMI_SEMI_AND", e.DBRACK_START = "DBRACK_START", e.DBRACK_END = "DBRACK_END", e.DPAREN_START = "DPAREN_START", e.DPAREN_END = "DPAREN_END", e.IF = "IF", e.THEN = "THEN", e.ELSE = "ELSE", e.ELIF = "ELIF", e.FI = "FI", e.FOR = "FOR", e.WHILE = "WHILE", e.UNTIL = "UNTIL", e.DO = "DO", e.DONE = "DONE", e.CASE = "CASE", e.ESAC = "ESAC", e.IN = "IN", e.FUNCTION = "FUNCTION", e.SELECT = "SELECT", e.TIME = "TIME", e.COPROC = "COPROC", e.WORD = "WORD", e.NAME = "NAME", e.NUMBER = "NUMBER", e.ASSIGNMENT_WORD = "ASSIGNMENT_WORD", e.FD_VARIABLE = "FD_VARIABLE", e.COMMENT = "COMMENT", e.HEREDOC_CONTENT = "HEREDOC_CONTENT";
        })(x || (x = {}));
        Sn = class extends Error {
            line;
            column;
            constructor(t, n, r){
                super(`line ${n}: ${t}`), this.line = n, this.column = r, this.name = "LexerError";
            }
        }, Gs = {
            if: x.IF,
            then: x.THEN,
            else: x.ELSE,
            elif: x.ELIF,
            fi: x.FI,
            for: x.FOR,
            while: x.WHILE,
            until: x.UNTIL,
            do: x.DO,
            done: x.DONE,
            case: x.CASE,
            esac: x.ESAC,
            in: x.IN,
            function: x.FUNCTION,
            select: x.SELECT,
            time: x.TIME,
            coproc: x.COPROC
        };
        sC = [
            [
                ";",
                ";",
                "&",
                x.SEMI_SEMI_AND
            ],
            [
                "<",
                "<",
                "<",
                x.TLESS
            ],
            [
                "&",
                ">",
                ">",
                x.AND_DGREAT
            ]
        ], iC = [
            [
                "[",
                "[",
                x.DBRACK_START
            ],
            [
                "]",
                "]",
                x.DBRACK_END
            ],
            [
                "(",
                "(",
                x.DPAREN_START
            ],
            [
                ")",
                ")",
                x.DPAREN_END
            ],
            [
                "&",
                "&",
                x.AND_AND
            ],
            [
                "|",
                "|",
                x.OR_OR
            ],
            [
                ";",
                ";",
                x.DSEMI
            ],
            [
                ";",
                "&",
                x.SEMI_AND
            ],
            [
                "|",
                "&",
                x.PIPE_AMP
            ],
            [
                ">",
                ">",
                x.DGREAT
            ],
            [
                "<",
                "&",
                x.LESSAND
            ],
            [
                ">",
                "&",
                x.GREATAND
            ],
            [
                "<",
                ">",
                x.LESSGREAT
            ],
            [
                ">",
                "|",
                x.CLOBBER
            ],
            [
                "&",
                ">",
                x.AND_GREAT
            ]
        ], oC = {
            "|": x.PIPE,
            "&": x.AMP,
            ";": x.SEMICOLON,
            "(": x.LPAREN,
            ")": x.RPAREN,
            "<": x.LESS,
            ">": x.GREAT
        };
        Zs = class {
            input;
            pos = 0;
            line = 1;
            column = 1;
            tokens = [];
            pendingHeredocs = [];
            dparenDepth = 0;
            constructor(t){
                this.input = t;
            }
            tokenize() {
                let n = this.input.length, r = this.tokens, s = this.pendingHeredocs;
                for(; this.pos < n;){
                    if (s.length > 0 && r.length > 0 && r[r.length - 1].type === x.NEWLINE) {
                        this.readHeredocContent();
                        continue;
                    }
                    if (this.skipWhitespace(), this.pos >= n) break;
                    let i = this.nextToken();
                    i && r.push(i);
                }
                return r.push({
                    type: x.EOF,
                    value: "",
                    start: this.pos,
                    end: this.pos,
                    line: this.line,
                    column: this.column
                }), r;
            }
            skipWhitespace() {
                let t = this.input, n = t.length, r = this.pos, s = this.column, i = this.line;
                for(; r < n;){
                    let o = t[r];
                    if (o === " " || o === "	") r++, s++;
                    else if (o === "\\" && t[r + 1] === `
`) r += 2, i++, s = 1;
                    else break;
                }
                this.pos = r, this.column = s, this.line = i;
            }
            nextToken() {
                let t = this.input, n = this.pos, r = this.line, s = this.column, i = t[n], o = t[n + 1], a = t[n + 2];
                if (i === "#" && this.dparenDepth === 0) return this.readComment(n, r, s);
                if (i === `
`) return this.pos = n + 1, this.line++, this.column = 1, {
                    type: x.NEWLINE,
                    value: `
`,
                    start: n,
                    end: n + 1,
                    line: r,
                    column: s
                };
                if (i === "<" && o === "<" && a === "-") return this.pos = n + 3, this.column = s + 3, this.registerHeredocFromLookahead(true), this.makeToken(x.DLESSDASH, "<<-", n, r, s);
                for (let [c, u, f, p] of sC)if (i === c && o === u && a === f) return this.pos = n + 3, this.column = s + 3, this.makeToken(p, c + u + f, n, r, s);
                if (i === "<" && o === "<") return this.pos = n + 2, this.column = s + 2, this.registerHeredocFromLookahead(false), this.makeToken(x.DLESS, "<<", n, r, s);
                if (i === "(" && o === "(") return this.dparenDepth > 0 ? (this.pos = n + 1, this.column = s + 1, this.dparenDepth++, this.makeToken(x.LPAREN, "(", n, r, s)) : this.looksLikeNestedSubshells(n + 2) || this.dparenClosesWithSpacedParens(n + 2) ? (this.pos = n + 1, this.column = s + 1, this.makeToken(x.LPAREN, "(", n, r, s)) : (this.pos = n + 2, this.column = s + 2, this.dparenDepth = 1, this.makeToken(x.DPAREN_START, "((", n, r, s));
                if (i === ")" && o === ")") return this.dparenDepth === 1 ? (this.pos = n + 2, this.column = s + 2, this.dparenDepth = 0, this.makeToken(x.DPAREN_END, "))", n, r, s)) : this.dparenDepth > 1 ? (this.pos = n + 1, this.column = s + 1, this.dparenDepth--, this.makeToken(x.RPAREN, ")", n, r, s)) : (this.pos = n + 1, this.column = s + 1, this.makeToken(x.RPAREN, ")", n, r, s));
                for (let [c, u, f] of iC)if (!(c === "(" && u === "(" || c === ")" && u === ")") && !(this.dparenDepth > 0 && c === ";" && (f === x.DSEMI || f === x.SEMI_AND || f === x.SEMI_SEMI_AND)) && i === c && o === u) {
                    if (f === x.DBRACK_START || f === x.DBRACK_END) {
                        let p = t[n + 2];
                        if (p !== void 0 && p !== " " && p !== "	" && p !== `
` && p !== ";" && p !== "&" && p !== "|" && p !== "(" && p !== ")" && p !== "<" && p !== ">") break;
                    }
                    return this.pos = n + 2, this.column = s + 2, this.makeToken(f, c + u, n, r, s);
                }
                if (i === "(" && this.dparenDepth > 0) return this.pos = n + 1, this.column = s + 1, this.dparenDepth++, this.makeToken(x.LPAREN, "(", n, r, s);
                if (i === ")" && this.dparenDepth > 1) return this.pos = n + 1, this.column = s + 1, this.dparenDepth--, this.makeToken(x.RPAREN, ")", n, r, s);
                let l = oC[i];
                if (l) return this.pos = n + 1, this.column = s + 1, this.makeToken(l, i, n, r, s);
                if (i === "{") {
                    let c = this.scanFdVariable(n);
                    return c !== null ? (this.pos = c.end, this.column = s + (c.end - n), {
                        type: x.FD_VARIABLE,
                        value: c.varname,
                        start: n,
                        end: c.end,
                        line: r,
                        column: s
                    }) : o === "}" ? (this.pos = n + 2, this.column = s + 2, {
                        type: x.WORD,
                        value: "{}",
                        start: n,
                        end: n + 2,
                        line: r,
                        column: s,
                        quoted: false,
                        singleQuoted: false
                    }) : this.scanBraceExpansion(n) !== null ? this.readWordWithBraceExpansion(n, r, s) : this.scanLiteralBraceWord(n) !== null ? this.readWordWithBraceExpansion(n, r, s) : o !== void 0 && o !== " " && o !== "	" && o !== `
` ? this.readWord(n, r, s) : (this.pos = n + 1, this.column = s + 1, this.makeToken(x.LBRACE, "{", n, r, s));
                }
                return i === "}" ? this.isWordCharFollowing(n + 1) ? this.readWord(n, r, s) : (this.pos = n + 1, this.column = s + 1, this.makeToken(x.RBRACE, "}", n, r, s)) : i === "!" ? o === "=" ? (this.pos = n + 2, this.column = s + 2, this.makeToken(x.WORD, "!=", n, r, s)) : (this.pos = n + 1, this.column = s + 1, this.makeToken(x.BANG, "!", n, r, s)) : this.readWord(n, r, s);
            }
            looksLikeNestedSubshells(t) {
                let n = this.input, r = n.length, s = t;
                for(; s < r && (n[s] === " " || n[s] === "	");)s++;
                if (s >= r) return false;
                let i = n[s];
                if (i === "(") return this.looksLikeNestedSubshells(s + 1);
                let o = /[a-zA-Z_]/.test(i), a = i === "!" || i === "[";
                if (!o && !a) return false;
                let l = s;
                for(; l < r && /[a-zA-Z0-9_\-.]/.test(n[l]);)l++;
                if (l === s) return a;
                let c = l;
                for(; c < r && (n[c] === " " || n[c] === "	");)c++;
                if (c >= r) return false;
                let u = n[c];
                if (u === "=" && n[c + 1] !== "=" || u === `
` || l === c && /[+\-*/%<>&|^!~?:]/.test(u) && u !== "-" || u === ")" && n[c + 1] === ")") return false;
                if (c > l && (u === "-" || u === '"' || u === "'" || u === "$" || /[a-zA-Z_/.]/.test(u))) {
                    let f = c;
                    for(; f < r && n[f] !== `
`;){
                        if (n[f] === ")") return true;
                        f++;
                    }
                    return false;
                }
                if (u === ")") {
                    let f = c + 1;
                    for(; f < r && (n[f] === " " || n[f] === "	");)f++;
                    if (n[f] === "|" && n[f + 1] === "|" || n[f] === "&" && n[f + 1] === "&" || n[f] === ";" || n[f] === "|" && n[f + 1] !== "|") return true;
                }
                return false;
            }
            makeToken(t, n, r, s, i) {
                return {
                    type: t,
                    value: n,
                    start: r,
                    end: this.pos,
                    line: s,
                    column: i
                };
            }
            readComment(t, n, r) {
                let s = this.input, i = s.length, o = this.pos;
                for(; o < i && s[o] !== `
`;)o++;
                let a = s.slice(t, o);
                return this.pos = o, this.column = r + (o - t), {
                    type: x.COMMENT,
                    value: a,
                    start: t,
                    end: o,
                    line: n,
                    column: r
                };
            }
            readWord(t, n, r) {
                let s = this.input, i = s.length, o = this.pos, a = o;
                for(; o < i;){
                    let y = s[o];
                    if (y === " " || y === "	" || y === `
` || y === ";" || y === "&" || y === "|" || y === "(" || y === ")" || y === "<" || y === ">" || y === "'" || y === '"' || y === "\\" || y === "$" || y === "`" || y === "{" || y === "}" || y === "~" || y === "*" || y === "?" || y === "[") break;
                    o++;
                }
                if (o > a) {
                    let y = s[o];
                    if (!(y === "(" && o > a && "@*+?!".includes(s[o - 1]))) {
                        if (o >= i || y === " " || y === "	" || y === `
` || y === ";" || y === "&" || y === "|" || y === "(" || y === ")" || y === "<" || y === ">") {
                            let w = s.slice(a, o);
                            if (this.pos = o, this.column = r + (o - a), Gs[w]) return {
                                type: Gs[w],
                                value: w,
                                start: t,
                                end: o,
                                line: n,
                                column: r
                            };
                            let E = lm(w);
                            return E > 0 && am(w.slice(0, E)) ? {
                                type: x.ASSIGNMENT_WORD,
                                value: w,
                                start: t,
                                end: o,
                                line: n,
                                column: r
                            } : /^[0-9]+$/.test(w) ? {
                                type: x.NUMBER,
                                value: w,
                                start: t,
                                end: o,
                                line: n,
                                column: r
                            } : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(w) ? {
                                type: x.NAME,
                                value: w,
                                start: t,
                                end: o,
                                line: n,
                                column: r,
                                quoted: false,
                                singleQuoted: false
                            } : {
                                type: x.WORD,
                                value: w,
                                start: t,
                                end: o,
                                line: n,
                                column: r,
                                quoted: false,
                                singleQuoted: false
                            };
                        }
                    }
                }
                o = this.pos;
                let l = this.column, c = this.line, u = "", f = false, p = false, d = false, m = false, h = s[o] === '"' || s[o] === "'", g = false, b = 0;
                for(; o < i;){
                    let y = s[o];
                    if (!d && !m) {
                        if (y === "(" && u.length > 0 && "@*+?!".includes(u[u.length - 1])) {
                            let w = this.scanExtglobPattern(o);
                            if (w !== null) {
                                u += w.content, o = w.end, l += w.content.length;
                                continue;
                            }
                        }
                        if (y === "[" && b === 0) {
                            if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(u)) {
                                let w = o + 1 < i ? s[o + 1] : "";
                                if (w === "^" || w === "!") {
                                    u += y, o++, l++;
                                    continue;
                                }
                                b = 1, u += y, o++, l++;
                                continue;
                            }
                        } else if (y === "[" && b > 0) {
                            u.length > 0 && u[u.length - 1] !== "\\" && b++, u += y, o++, l++;
                            continue;
                        } else if (y === "]" && b > 0) {
                            u.length > 0 && u[u.length - 1] !== "\\" && b--, u += y, o++, l++;
                            continue;
                        }
                        if (b > 0) {
                            if (y === `
`) break;
                            u += y, o++, l++;
                            continue;
                        }
                        if (y === " " || y === "	" || y === `
` || y === ";" || y === "&" || y === "|" || y === "(" || y === ")" || y === "<" || y === ">") break;
                    }
                    if (y === "$" && o + 1 < i && s[o + 1] === "'" && !d && !m) {
                        for(u += "$'", o += 2, l += 2; o < i && s[o] !== "'";)s[o] === "\\" && o + 1 < i ? (u += s[o] + s[o + 1], o += 2, l += 2) : (u += s[o], o++, l++);
                        o < i && (u += "'", o++, l++);
                        continue;
                    }
                    if (y === "$" && o + 1 < i && s[o + 1] === '"' && !d && !m) {
                        o++, l++, m = true, f = true, u === "" && (h = true), o++, l++;
                        continue;
                    }
                    if (y === "'" && !m) {
                        if (d) if (d = false, !h || g) u += y;
                        else {
                            let w = o + 1 < i ? s[o + 1] : "";
                            w && !cm(w) && w !== "'" && (w === '"' ? (g = true, u += y, p = false, f = false) : (g = true, u += y));
                        }
                        else d = true, h && !g ? (p = true, f = true) : u += y;
                        o++, l++;
                        continue;
                    }
                    if (y === '"' && !d) {
                        if (m) if (m = false, !h || g) u += y;
                        else {
                            let w = o + 1 < i ? s[o + 1] : "";
                            w && !cm(w) && w !== '"' && (w === "'" ? (g = true, u += y, p = false, f = false) : (g = true, u += y));
                        }
                        else m = true, h && !g ? f = true : u += y;
                        o++, l++;
                        continue;
                    }
                    if (y === "\\" && !d && o + 1 < i) {
                        let w = s[o + 1];
                        if (w === `
`) {
                            o += 2, c++, l = 1;
                            continue;
                        }
                        if (m) {
                            if (w === '"' || w === "\\" || w === "$" || w === "`" || w === `
`) {
                                if (w === `
`) {
                                    o += 2, l = 1, c++;
                                    continue;
                                }
                                u += y + w, o += 2, l += 2;
                                continue;
                            }
                        } else {
                            w === "\\" || w === '"' || w === "'" || w === "`" || w === "*" || w === "?" || w === "[" || w === "]" || w === "(" || w === ")" || w === "$" || w === "-" || w === "." || w === "^" || w === "+" || w === "{" || w === "}" ? u += y + w : u += w, o += 2, l += 2;
                            continue;
                        }
                    }
                    if (y === "$" && o + 1 < i && s[o + 1] === "(" && !d) {
                        u += y, o++, l++, u += s[o], o++, l++;
                        let w = 1, E = false, C = false, A = 0, I = false, O = "", L = s[o] === "(" && !this.dollarDparenIsSubshell(o);
                        for(; w > 0 && o < i;){
                            let D = s[o];
                            if (u += D, E) D === "'" && (E = false);
                            else if (C) D === "\\" && o + 1 < i ? (u += s[o + 1], o++, l++) : D === '"' && (C = false);
                            else if (D === "'") E = true, O = "";
                            else if (D === '"') C = true, O = "";
                            else if (D === "\\" && o + 1 < i) u += s[o + 1], o++, l++, O = "";
                            else if (D === "$" && o + 1 < i && s[o + 1] === "{") {
                                o++, l++, u += s[o], o++, l++;
                                let $ = 1, N = false, P = false;
                                for(; $ > 0 && o < i;){
                                    let k = s[o];
                                    if (k === "\\" && o + 1 < i && !N) {
                                        u += k, o++, l++, u += s[o], o++, l++;
                                        continue;
                                    }
                                    u += k, N ? k === "'" && (N = false) : P ? k === '"' && (P = false) : k === "'" ? N = true : k === '"' ? P = true : k === "{" ? $++ : k === "}" && $--, k === `
` ? (c++, l = 0) : l++, o++;
                                }
                                O = "";
                                continue;
                            } else if (D === "#" && !L && (O === "" || /\s/.test(s[o - 1] || ""))) {
                                for(; o + 1 < i && s[o + 1] !== `
`;)o++, l++, u += s[o];
                                O = "";
                            } else /[a-zA-Z_]/.test(D) ? O += D : (O === "case" ? (A++, I = false) : O === "in" && A > 0 ? I = true : O === "esac" && A > 0 && (A--, I = false), O = "", D === "(" ? o > 0 && s[o - 1] === "$" ? w++ : I || w++ : D === ")" ? I ? I = false : w-- : D === ";" && A > 0 && o + 1 < i && s[o + 1] === ";" && (I = true));
                            D === `
` && (c++, l = 0, O = ""), o++, l++;
                        }
                        continue;
                    }
                    if (y === "$" && o + 1 < i && s[o + 1] === "[" && !d) {
                        u += y, o++, l++, u += s[o], o++, l++;
                        let w = 1;
                        for(; w > 0 && o < i;){
                            let E = s[o];
                            u += E, E === "[" ? w++ : E === "]" ? w-- : E === `
` && (c++, l = 0), o++, l++;
                        }
                        continue;
                    }
                    if (y === "$" && o + 1 < i && s[o + 1] === "{" && !d) {
                        u += y, o++, l++, u += s[o], o++, l++;
                        let w = 1, E = false, C = false, A = c, I = l, O = c, L = l;
                        for(; w > 0 && o < i;){
                            let D = s[o];
                            if (D === "\\" && o + 1 < i && s[o + 1] === `
`) {
                                o += 2, c++, l = 1;
                                continue;
                            }
                            if (D === "\\" && o + 1 < i && !E) {
                                u += D, o++, l++, u += s[o], o++, l++;
                                continue;
                            }
                            u += D, E ? D === "'" && (E = false) : C ? D === '"' && (C = false) : D === "'" ? (E = true, A = c, I = l) : D === '"' ? (C = true, O = c, L = l) : D === "{" ? w++ : D === "}" && w--, D === `
` && (c++, l = 0), o++, l++;
                        }
                        if (E) throw new Sn("unexpected EOF while looking for matching `''", A, I);
                        if (C) throw new Sn("unexpected EOF while looking for matching `\"'", O, L);
                        continue;
                    }
                    if (y === "$" && o + 1 < i && !d) {
                        let w = s[o + 1];
                        if (w === "#" || w === "?" || w === "$" || w === "!" || w === "@" || w === "*" || w === "-" || w >= "0" && w <= "9") {
                            u += y + w, o += 2, l += 2;
                            continue;
                        }
                    }
                    if (y === "`" && !d) {
                        for(u += y, o++, l++; o < i && s[o] !== "`";){
                            let w = s[o];
                            u += w, w === "\\" && o + 1 < i && (u += s[o + 1], o++, l++), w === `
` && (c++, l = 0), o++, l++;
                        }
                        o < i && (u += s[o], o++, l++);
                        continue;
                    }
                    u += y, o++, y === `
` ? (c++, l = 1) : l++;
                }
                if (this.pos = o, this.column = l, this.line = c, g && h && (u = s[t] + u, f = false, p = false), d || m) {
                    let y = d ? "'" : '"';
                    throw new Sn(`unexpected EOF while looking for matching \`${y}'`, n, r);
                }
                if (!h && u.length >= 2) {
                    if (u[0] === "'" && u[u.length - 1] === "'") {
                        let y = u.slice(1, -1);
                        !y.includes("'") && !y.includes('"') && (u = y, f = true, p = true);
                    } else if (u[0] === '"' && u[u.length - 1] === '"') {
                        let y = u.slice(1, -1), w = false;
                        for(let E = 0; E < y.length; E++){
                            if (y[E] === '"') {
                                w = true;
                                break;
                            }
                            y[E] === "\\" && E + 1 < y.length && E++;
                        }
                        w || (u = y, f = true, p = false);
                    }
                }
                if (u === "") return {
                    type: x.WORD,
                    value: "",
                    start: t,
                    end: o,
                    line: n,
                    column: r,
                    quoted: f,
                    singleQuoted: p
                };
                if (!f && Gs[u]) return {
                    type: Gs[u],
                    value: u,
                    start: t,
                    end: o,
                    line: n,
                    column: r
                };
                if (!h) {
                    let y = lm(u);
                    if (y > 0 && am(u.slice(0, y))) return {
                        type: x.ASSIGNMENT_WORD,
                        value: u,
                        start: t,
                        end: o,
                        line: n,
                        column: r,
                        quoted: f,
                        singleQuoted: p
                    };
                }
                return /^[0-9]+$/.test(u) ? {
                    type: x.NUMBER,
                    value: u,
                    start: t,
                    end: o,
                    line: n,
                    column: r
                } : aC(u) ? {
                    type: x.NAME,
                    value: u,
                    start: t,
                    end: o,
                    line: n,
                    column: r,
                    quoted: f,
                    singleQuoted: p
                } : {
                    type: x.WORD,
                    value: u,
                    start: t,
                    end: o,
                    line: n,
                    column: r,
                    quoted: f,
                    singleQuoted: p
                };
            }
            readHeredocContent() {
                for(; this.pendingHeredocs.length > 0;){
                    let t = this.pendingHeredocs.shift();
                    if (!t) break;
                    let n = this.pos, r = this.line, s = this.column, i = "";
                    for(; this.pos < this.input.length;){
                        this.pos;
                        let a = "";
                        for(; this.pos < this.input.length && this.input[this.pos] !== `
`;)a += this.input[this.pos], this.pos++, this.column++;
                        if ((t.stripTabs ? a.replace(/^\t+/, "") : a) === t.delimiter) {
                            this.pos < this.input.length && this.input[this.pos] === `
` && (this.pos++, this.line++, this.column = 1);
                            break;
                        }
                        i += a, this.pos < this.input.length && this.input[this.pos] === `
` && (i += `
`, this.pos++, this.line++, this.column = 1);
                    }
                    this.tokens.push({
                        type: x.HEREDOC_CONTENT,
                        value: i,
                        start: n,
                        end: this.pos,
                        line: r,
                        column: s
                    });
                }
            }
            addPendingHeredoc(t, n, r) {
                this.pendingHeredocs.push({
                    delimiter: t,
                    stripTabs: n,
                    quoted: r
                });
            }
            registerHeredocFromLookahead(t) {
                let n = this.pos, r = this.column;
                for(; this.pos < this.input.length && (this.input[this.pos] === " " || this.input[this.pos] === "	");)this.pos++, this.column++;
                let s = "", i = false;
                for(; this.pos < this.input.length;){
                    let o = this.input[this.pos];
                    if (/[\s;<>&|()]/.test(o)) break;
                    if (o === "'" || o === '"') {
                        i = true;
                        let a = o;
                        for(this.pos++, this.column++; this.pos < this.input.length && this.input[this.pos] !== a;)s += this.input[this.pos], this.pos++, this.column++;
                        this.pos < this.input.length && this.input[this.pos] === a && (this.pos++, this.column++);
                    } else o === "\\" ? (i = true, this.pos++, this.column++, this.pos < this.input.length && (s += this.input[this.pos], this.pos++, this.column++)) : (s += o, this.pos++, this.column++);
                }
                this.pos = n, this.column = r, s && this.pendingHeredocs.push({
                    delimiter: s,
                    stripTabs: t,
                    quoted: i
                });
            }
            isWordCharFollowing(t) {
                if (t >= this.input.length) return false;
                let n = this.input[t];
                return !(n === " " || n === "	" || n === `
` || n === ";" || n === "&" || n === "|" || n === "(" || n === ")" || n === "<" || n === ">");
            }
            readWordWithBraceExpansion(t, n, r) {
                let s = this.input, i = s.length, o = t, a = r;
                for(; o < i;){
                    let c = s[o];
                    if (c === " " || c === "	" || c === `
` || c === ";" || c === "&" || c === "|" || c === "(" || c === ")" || c === "<" || c === ">") break;
                    if (c === "{") {
                        if (this.scanBraceExpansion(o) !== null) {
                            let f = 1;
                            for(o++, a++; o < i && f > 0;)s[o] === "{" ? f++ : s[o] === "}" && f--, o++, a++;
                            continue;
                        }
                        o++, a++;
                        continue;
                    }
                    if (c === "}") {
                        o++, a++;
                        continue;
                    }
                    if (c === "$" && o + 1 < i && s[o + 1] === "(") {
                        o++, a++, o++, a++;
                        let u = 1;
                        for(; u > 0 && o < i;)s[o] === "(" ? u++ : s[o] === ")" && u--, o++, a++;
                        continue;
                    }
                    if (c === "$" && o + 1 < i && s[o + 1] === "{") {
                        o++, a++, o++, a++;
                        let u = 1;
                        for(; u > 0 && o < i;)s[o] === "{" ? u++ : s[o] === "}" && u--, o++, a++;
                        continue;
                    }
                    if (c === "`") {
                        for(o++, a++; o < i && s[o] !== "`";)s[o] === "\\" && o + 1 < i ? (o += 2, a += 2) : (o++, a++);
                        o < i && (o++, a++);
                        continue;
                    }
                    o++, a++;
                }
                let l = s.slice(t, o);
                return this.pos = o, this.column = a, {
                    type: x.WORD,
                    value: l,
                    start: t,
                    end: o,
                    line: n,
                    column: r,
                    quoted: false,
                    singleQuoted: false
                };
            }
            scanBraceExpansion(t) {
                let n = this.input, r = n.length, s = t + 1, i = 1, o = false, a = false;
                for(; s < r && i > 0;){
                    let l = n[s];
                    if (l === "{") i++, s++;
                    else if (l === "}") i--, s++;
                    else if (l === "," && i === 1) o = true, s++;
                    else if (l === "." && s + 1 < r && n[s + 1] === ".") a = true, s += 2;
                    else {
                        if (l === " " || l === "	" || l === `
` || l === ";" || l === "&" || l === "|") return null;
                        s++;
                    }
                }
                return i === 0 && (o || a) ? n.slice(t, s) : null;
            }
            scanLiteralBraceWord(t) {
                let n = this.input, r = n.length, s = t + 1, i = 1;
                for(; s < r && i > 0;){
                    let o = n[s];
                    if (o === "{") i++, s++;
                    else if (o === "}") {
                        if (i--, i === 0) return n.slice(t, s + 1);
                        s++;
                    } else {
                        if (o === " " || o === "	" || o === `
` || o === ";" || o === "&" || o === "|") return null;
                        s++;
                    }
                }
                return null;
            }
            scanExtglobPattern(t) {
                let n = this.input, r = n.length, s = t + 1, i = 1;
                for(; s < r && i > 0;){
                    let o = n[s];
                    if (o === "\\" && s + 1 < r) {
                        s += 2;
                        continue;
                    }
                    if ("@*+?!".includes(o) && s + 1 < r && n[s + 1] === "(") {
                        s++, i++, s++;
                        continue;
                    }
                    if (o === "(") i++, s++;
                    else if (o === ")") i--, s++;
                    else {
                        if (o === `
`) return null;
                        s++;
                    }
                }
                return i === 0 ? {
                    content: n.slice(t, s),
                    end: s
                } : null;
            }
            scanFdVariable(t) {
                let n = this.input, r = n.length, s = t + 1, i = s;
                for(; s < r;){
                    let u = n[s];
                    if (s === i) {
                        if (!(u >= "a" && u <= "z" || u >= "A" && u <= "Z" || u === "_")) return null;
                    } else if (!(u >= "a" && u <= "z" || u >= "A" && u <= "Z" || u >= "0" && u <= "9" || u === "_")) break;
                    s++;
                }
                if (s === i) return null;
                let o = n.slice(i, s);
                if (s >= r || n[s] !== "}" || (s++, s >= r)) return null;
                let a = n[s], l = s + 1 < r ? n[s + 1] : "";
                return a === ">" || a === "<" || a === "&" && (l === ">" || l === "<") ? {
                    varname: o,
                    end: s
                } : null;
            }
            dollarDparenIsSubshell(t) {
                let n = this.input, r = n.length, s = t + 1, i = 2, o = false, a = false, l = false;
                for(; s < r && i > 0;){
                    let c = n[s];
                    if (o) {
                        c === "'" && (o = false), c === `
` && (l = true), s++;
                        continue;
                    }
                    if (a) {
                        if (c === "\\") {
                            s += 2;
                            continue;
                        }
                        c === '"' && (a = false), c === `
` && (l = true), s++;
                        continue;
                    }
                    if (c === "'") {
                        o = true, s++;
                        continue;
                    }
                    if (c === '"') {
                        a = true, s++;
                        continue;
                    }
                    if (c === "\\") {
                        s += 2;
                        continue;
                    }
                    if (c === `
` && (l = true), c === "(") {
                        i++, s++;
                        continue;
                    }
                    if (c === ")") {
                        if (i--, i === 1) {
                            let u = s + 1;
                            if (u < r && n[u] === ")") return false;
                            let f = u, p = false;
                            for(; f < r && (n[f] === " " || n[f] === "	" || n[f] === `
`);)p = true, f++;
                            if (p && f < r && n[f] === ")" || l) return true;
                        }
                        if (i === 0) return false;
                        s++;
                        continue;
                    }
                    s++;
                }
                return false;
            }
            dparenClosesWithSpacedParens(t) {
                let n = this.input, r = n.length, s = t, i = 2, o = false, a = false;
                for(; s < r && i > 0;){
                    let l = n[s];
                    if (o) {
                        l === "'" && (o = false), s++;
                        continue;
                    }
                    if (a) {
                        if (l === "\\") {
                            s += 2;
                            continue;
                        }
                        l === '"' && (a = false), s++;
                        continue;
                    }
                    if (l === "'") {
                        o = true, s++;
                        continue;
                    }
                    if (l === '"') {
                        a = true, s++;
                        continue;
                    }
                    if (l === "\\") {
                        s += 2;
                        continue;
                    }
                    if (l === "(") {
                        i++, s++;
                        continue;
                    }
                    if (l === ")") {
                        if (i--, i === 1) {
                            let c = s + 1;
                            if (c < r && n[c] === ")") return false;
                            let u = c, f = false;
                            for(; u < r && (n[u] === " " || n[u] === "	" || n[u] === `
`);)f = true, u++;
                            if (f && u < r && n[u] === ")") return true;
                        }
                        if (i === 0) return false;
                        s++;
                        continue;
                    }
                    if (i === 1 && (l === "|" && s + 1 < r && n[s + 1] === "|" || l === "&" && s + 1 < r && n[s + 1] === "&" || l === "|" && s + 1 < r && n[s + 1] !== "|")) return true;
                    s++;
                }
                return false;
            }
        };
    });
    var da, ha, um, fm, pm, dm, Ge, An = v(()=>{
        tn();
        da = 1e6, ha = 1e5, um = 1e6, fm = new Set([
            x.LESS,
            x.GREAT,
            x.DLESS,
            x.DGREAT,
            x.LESSAND,
            x.GREATAND,
            x.LESSGREAT,
            x.DLESSDASH,
            x.CLOBBER,
            x.TLESS,
            x.AND_GREAT,
            x.AND_DGREAT
        ]), pm = new Set([
            x.LESS,
            x.GREAT,
            x.DLESS,
            x.DGREAT,
            x.LESSAND,
            x.GREATAND,
            x.LESSGREAT,
            x.DLESSDASH,
            x.CLOBBER,
            x.TLESS
        ]), dm = new Set([
            x.LESS,
            x.GREAT,
            x.DLESS,
            x.DGREAT,
            x.LESSAND,
            x.GREATAND,
            x.LESSGREAT,
            x.DLESSDASH,
            x.CLOBBER,
            x.TLESS,
            x.AND_GREAT,
            x.AND_DGREAT
        ]), Ge = class extends Error {
            line;
            column;
            token;
            constructor(t, n, r, s = void 0){
                super(`Parse error at ${n}:${r}: ${t}`), this.line = n, this.column = r, this.token = s, this.name = "ParseException";
            }
        };
    });
    var j, Cn = v(()=>{
        j = {
            script (e) {
                return {
                    type: "Script",
                    statements: e
                };
            },
            statement (e, t = [], n = false, r, s) {
                let i = {
                    type: "Statement",
                    pipelines: e,
                    operators: t,
                    background: n
                };
                return r && (i.deferredError = r), s !== void 0 && (i.sourceText = s), i;
            },
            pipeline (e, t = false, n = false, r = false, s) {
                return {
                    type: "Pipeline",
                    commands: e,
                    negated: t,
                    timed: n,
                    timePosix: r,
                    pipeStderr: s
                };
            },
            simpleCommand (e, t = [], n = [], r = []) {
                return {
                    type: "SimpleCommand",
                    name: e,
                    args: t,
                    assignments: n,
                    redirections: r
                };
            },
            word (e) {
                return {
                    type: "Word",
                    parts: e
                };
            },
            literal (e) {
                return {
                    type: "Literal",
                    value: e
                };
            },
            singleQuoted (e) {
                return {
                    type: "SingleQuoted",
                    value: e
                };
            },
            doubleQuoted (e) {
                return {
                    type: "DoubleQuoted",
                    parts: e
                };
            },
            escaped (e) {
                return {
                    type: "Escaped",
                    value: e
                };
            },
            parameterExpansion (e, t = null) {
                return {
                    type: "ParameterExpansion",
                    parameter: e,
                    operation: t
                };
            },
            commandSubstitution (e, t = false) {
                return {
                    type: "CommandSubstitution",
                    body: e,
                    legacy: t
                };
            },
            arithmeticExpansion (e) {
                return {
                    type: "ArithmeticExpansion",
                    expression: e
                };
            },
            assignment (e, t, n = false, r = null) {
                return {
                    type: "Assignment",
                    name: e,
                    value: t,
                    append: n,
                    array: r
                };
            },
            redirection (e, t, n = null, r) {
                let s = {
                    type: "Redirection",
                    fd: n,
                    operator: e,
                    target: t
                };
                return r && (s.fdVariable = r), s;
            },
            hereDoc (e, t, n = false, r = false) {
                return {
                    type: "HereDoc",
                    delimiter: e,
                    content: t,
                    stripTabs: n,
                    quoted: r
                };
            },
            ifNode (e, t = null, n = []) {
                return {
                    type: "If",
                    clauses: e,
                    elseBody: t,
                    redirections: n
                };
            },
            forNode (e, t, n, r = []) {
                return {
                    type: "For",
                    variable: e,
                    words: t,
                    body: n,
                    redirections: r
                };
            },
            whileNode (e, t, n = []) {
                return {
                    type: "While",
                    condition: e,
                    body: t,
                    redirections: n
                };
            },
            untilNode (e, t, n = []) {
                return {
                    type: "Until",
                    condition: e,
                    body: t,
                    redirections: n
                };
            },
            caseNode (e, t, n = []) {
                return {
                    type: "Case",
                    word: e,
                    items: t,
                    redirections: n
                };
            },
            caseItem (e, t, n = ";;") {
                return {
                    type: "CaseItem",
                    patterns: e,
                    body: t,
                    terminator: n
                };
            },
            subshell (e, t = []) {
                return {
                    type: "Subshell",
                    body: e,
                    redirections: t
                };
            },
            group (e, t = []) {
                return {
                    type: "Group",
                    body: e,
                    redirections: t
                };
            },
            functionDef (e, t, n = [], r) {
                return {
                    type: "FunctionDef",
                    name: e,
                    body: t,
                    redirections: n,
                    sourceFile: r
                };
            },
            conditionalCommand (e, t = [], n) {
                return {
                    type: "ConditionalCommand",
                    expression: e,
                    redirections: t,
                    line: n
                };
            },
            arithmeticCommand (e, t = [], n) {
                return {
                    type: "ArithmeticCommand",
                    expression: e,
                    redirections: t,
                    line: n
                };
            }
        };
    });
    function ve(e, t) {
        for(; t < e.length;){
            if (e[t] === "\\" && e[t + 1] === `
`) {
                t += 2;
                continue;
            }
            if (/\s/.test(e[t])) {
                t++;
                continue;
            }
            break;
        }
        return t;
    }
    function Fr(e) {
        if (e.includes("#")) {
            let [t, n] = e.split("#"), r = Number.parseInt(t, 10);
            if (r < 2 || r > 64) return Number.NaN;
            if (r <= 36) return Number.parseInt(n, r);
            let s = 0;
            for (let i of n){
                let o;
                if (/[0-9]/.test(i)) o = i.charCodeAt(0) - 48;
                else if (/[a-z]/.test(i)) o = i.charCodeAt(0) - 97 + 10;
                else if (/[A-Z]/.test(i)) o = i.charCodeAt(0) - 65 + 36;
                else if (i === "@") o = 62;
                else if (i === "_") o = 63;
                else return Number.NaN;
                if (o >= r) return Number.NaN;
                s = s * r + o;
            }
            return s;
        }
        return e.startsWith("0x") || e.startsWith("0X") ? Number.parseInt(e.slice(2), 16) : e.startsWith("0") && e.length > 1 && /^[0-9]+$/.test(e) ? /[89]/.test(e) ? Number.NaN : Number.parseInt(e, 8) : Number.parseInt(e, 10);
    }
    function hm(e, t, n, r) {
        if (n.slice(r, r + 3) !== "$((") return null;
        let s = r + 3, i = 1, o = s;
        for(; s < n.length - 1 && i > 0;)n[s] === "(" && n[s + 1] === "(" ? (i++, s += 2) : n[s] === ")" && n[s + 1] === ")" ? (i--, i > 0 && (s += 2)) : s++;
        let a = n.slice(o, s), { expr: l } = e(t, a, 0);
        return s += 2, {
            expr: {
                type: "ArithNested",
                expression: l
            },
            pos: s
        };
    }
    function mm(e, t) {
        if (e.slice(t, t + 2) !== "$'") return null;
        let n = t + 2, r = "";
        for(; n < e.length && e[n] !== "'";)if (e[n] === "\\" && n + 1 < e.length) {
            let i = e[n + 1];
            switch(i){
                case "n":
                    r += `
`;
                    break;
                case "t":
                    r += "	";
                    break;
                case "r":
                    r += "\r";
                    break;
                case "\\":
                    r += "\\";
                    break;
                case "'":
                    r += "'";
                    break;
                default:
                    r += i;
            }
            n += 2;
        } else r += e[n], n++;
        e[n] === "'" && n++;
        let s = Number.parseInt(r, 10);
        return {
            expr: {
                type: "ArithNumber",
                value: Number.isNaN(s) ? 0 : s
            },
            pos: n
        };
    }
    function gm(e, t) {
        if (e.slice(t, t + 2) !== '$"') return null;
        let n = t + 2, r = "";
        for(; n < e.length && e[n] !== '"';)e[n] === "\\" && n + 1 < e.length ? (r += e[n + 1], n += 2) : (r += e[n], n++);
        e[n] === '"' && n++;
        let s = Number.parseInt(r, 10);
        return {
            expr: {
                type: "ArithNumber",
                value: Number.isNaN(s) ? 0 : s
            },
            pos: n
        };
    }
    var Qs, ym = v(()=>{
        Qs = [
            "=",
            "+=",
            "-=",
            "*=",
            "/=",
            "%=",
            "<<=",
            ">>=",
            "&=",
            "|=",
            "^="
        ];
    });
    function lC(e) {
        let t = "", n = 0;
        for(; n < e.length;)if (e[n] === '"') {
            for(n++; n < e.length && e[n] !== '"';)e[n] === "\\" && n + 1 < e.length ? (t += e[n + 1], n += 2) : (t += e[n], n++);
            n < e.length && n++;
        } else t += e[n], n++;
        return t;
    }
    function he(e, t) {
        let n = lC(t), { expr: r, pos: s } = Et(e, n, 0), i = ve(n, s);
        if (i < n.length) {
            let o = t.slice(i).trim();
            if (o) return {
                type: "ArithmeticExpression",
                originalText: t,
                expression: {
                    type: "ArithSyntaxError",
                    errorToken: o,
                    message: `${o}: syntax error: invalid arithmetic operator (error token is "${o}")`
                }
            };
        }
        return {
            type: "ArithmeticExpression",
            expression: r,
            originalText: t
        };
    }
    function pt(e, t) {
        return {
            expr: {
                type: "ArithSyntaxError",
                errorToken: e,
                message: `syntax error: operand expected (error token is "${e}")`
            },
            pos: t
        };
    }
    function dt(e, t) {
        return ve(e, t) >= e.length;
    }
    function Et(e, t, n) {
        return cC(e, t, n);
    }
    function cC(e, t, n) {
        let { expr: r, pos: s } = _r(e, t, n);
        for(s = ve(t, s); t[s] === ",";){
            if (s++, dt(t, s)) return pt(",", s);
            let { expr: o, pos: a } = _r(e, t, s);
            r = {
                type: "ArithBinary",
                operator: ",",
                left: r,
                right: o
            }, s = ve(t, a);
        }
        return {
            expr: r,
            pos: s
        };
    }
    function _r(e, t, n) {
        let { expr: r, pos: s } = uC(e, t, n);
        if (s = ve(t, s), t[s] === "?") {
            s++;
            let { expr: i, pos: o } = Et(e, t, s);
            if (s = ve(t, o), t[s] === ":") {
                s++;
                let { expr: a, pos: l } = Et(e, t, s);
                return {
                    expr: {
                        type: "ArithTernary",
                        condition: r,
                        consequent: i,
                        alternate: a
                    },
                    pos: l
                };
            }
        }
        return {
            expr: r,
            pos: s
        };
    }
    function uC(e, t, n) {
        let { expr: r, pos: s } = bm(e, t, n);
        for(; s = ve(t, s), t.slice(s, s + 2) === "||";){
            if (s += 2, dt(t, s)) return pt("||", s);
            let { expr: o, pos: a } = bm(e, t, s);
            r = {
                type: "ArithBinary",
                operator: "||",
                left: r,
                right: o
            }, s = a;
        }
        return {
            expr: r,
            pos: s
        };
    }
    function bm(e, t, n) {
        let { expr: r, pos: s } = wm(e, t, n);
        for(; s = ve(t, s), t.slice(s, s + 2) === "&&";){
            if (s += 2, dt(t, s)) return pt("&&", s);
            let { expr: o, pos: a } = wm(e, t, s);
            r = {
                type: "ArithBinary",
                operator: "&&",
                left: r,
                right: o
            }, s = a;
        }
        return {
            expr: r,
            pos: s
        };
    }
    function wm(e, t, n) {
        let { expr: r, pos: s } = xm(e, t, n);
        for(; s = ve(t, s), t[s] === "|" && t[s + 1] !== "|";){
            if (s++, dt(t, s)) return pt("|", s);
            let { expr: o, pos: a } = xm(e, t, s);
            r = {
                type: "ArithBinary",
                operator: "|",
                left: r,
                right: o
            }, s = a;
        }
        return {
            expr: r,
            pos: s
        };
    }
    function xm(e, t, n) {
        let { expr: r, pos: s } = Em(e, t, n);
        for(; s = ve(t, s), t[s] === "^";){
            if (s++, dt(t, s)) return pt("^", s);
            let { expr: o, pos: a } = Em(e, t, s);
            r = {
                type: "ArithBinary",
                operator: "^",
                left: r,
                right: o
            }, s = a;
        }
        return {
            expr: r,
            pos: s
        };
    }
    function Em(e, t, n) {
        let { expr: r, pos: s } = Sm(e, t, n);
        for(; s = ve(t, s), t[s] === "&" && t[s + 1] !== "&";){
            if (s++, dt(t, s)) return pt("&", s);
            let { expr: o, pos: a } = Sm(e, t, s);
            r = {
                type: "ArithBinary",
                operator: "&",
                left: r,
                right: o
            }, s = a;
        }
        return {
            expr: r,
            pos: s
        };
    }
    function Sm(e, t, n) {
        let { expr: r, pos: s } = Am(e, t, n);
        for(; s = ve(t, s), t.slice(s, s + 2) === "==" || t.slice(s, s + 2) === "!=";){
            let i = t.slice(s, s + 2);
            if (s += 2, dt(t, s)) return pt(i, s);
            let { expr: o, pos: a } = Am(e, t, s);
            r = {
                type: "ArithBinary",
                operator: i,
                left: r,
                right: o
            }, s = a;
        }
        return {
            expr: r,
            pos: s
        };
    }
    function Am(e, t, n) {
        let { expr: r, pos: s } = ma(e, t, n);
        for(;;)if (s = ve(t, s), t.slice(s, s + 2) === "<=" || t.slice(s, s + 2) === ">=") {
            let i = t.slice(s, s + 2);
            if (s += 2, dt(t, s)) return pt(i, s);
            let { expr: o, pos: a } = ma(e, t, s);
            r = {
                type: "ArithBinary",
                operator: i,
                left: r,
                right: o
            }, s = a;
        } else if (t[s] === "<" || t[s] === ">") {
            let i = t[s];
            if (s++, dt(t, s)) return pt(i, s);
            let { expr: o, pos: a } = ma(e, t, s);
            r = {
                type: "ArithBinary",
                operator: i,
                left: r,
                right: o
            }, s = a;
        } else break;
        return {
            expr: r,
            pos: s
        };
    }
    function ma(e, t, n) {
        let { expr: r, pos: s } = Cm(e, t, n);
        for(; s = ve(t, s), t.slice(s, s + 2) === "<<" || t.slice(s, s + 2) === ">>";){
            let i = t.slice(s, s + 2);
            if (s += 2, dt(t, s)) return pt(i, s);
            let { expr: o, pos: a } = Cm(e, t, s);
            r = {
                type: "ArithBinary",
                operator: i,
                left: r,
                right: o
            }, s = a;
        }
        return {
            expr: r,
            pos: s
        };
    }
    function Cm(e, t, n) {
        let { expr: r, pos: s } = Nm(e, t, n);
        for(; s = ve(t, s), (t[s] === "+" || t[s] === "-") && t[s + 1] !== t[s];){
            let i = t[s];
            if (s++, dt(t, s)) return pt(i, s);
            let { expr: o, pos: a } = Nm(e, t, s);
            r = {
                type: "ArithBinary",
                operator: i,
                left: r,
                right: o
            }, s = a;
        }
        return {
            expr: r,
            pos: s
        };
    }
    function Nm(e, t, n) {
        let { expr: r, pos: s } = Ks(e, t, n);
        for(;;)if (s = ve(t, s), t[s] === "*" && t[s + 1] !== "*") {
            if (s++, dt(t, s)) return pt("*", s);
            let { expr: o, pos: a } = Ks(e, t, s);
            r = {
                type: "ArithBinary",
                operator: "*",
                left: r,
                right: o
            }, s = a;
        } else if (t[s] === "/" || t[s] === "%") {
            let i = t[s];
            if (s++, dt(t, s)) return pt(i, s);
            let { expr: o, pos: a } = Ks(e, t, s);
            r = {
                type: "ArithBinary",
                operator: i,
                left: r,
                right: o
            }, s = a;
        } else break;
        return {
            expr: r,
            pos: s
        };
    }
    function Ks(e, t, n) {
        let { expr: r, pos: s } = ga(e, t, n), i = ve(t, s);
        if (t.slice(i, i + 2) === "**") {
            if (i += 2, dt(t, i)) return pt("**", i);
            let { expr: a, pos: l } = Ks(e, t, i);
            return {
                expr: {
                    type: "ArithBinary",
                    operator: "**",
                    left: r,
                    right: a
                },
                pos: l
            };
        }
        return {
            expr: r,
            pos: s
        };
    }
    function ga(e, t, n) {
        let r = ve(t, n);
        if (t.slice(r, r + 2) === "++" || t.slice(r, r + 2) === "--") {
            let s = t.slice(r, r + 2);
            r += 2;
            let { expr: i, pos: o } = ga(e, t, r);
            return {
                expr: {
                    type: "ArithUnary",
                    operator: s,
                    operand: i,
                    prefix: true
                },
                pos: o
            };
        }
        if (t[r] === "+" || t[r] === "-" || t[r] === "!" || t[r] === "~") {
            let s = t[r];
            r++;
            let { expr: i, pos: o } = ga(e, t, r);
            return {
                expr: {
                    type: "ArithUnary",
                    operator: s,
                    operand: i,
                    prefix: true
                },
                pos: o
            };
        }
        return pC(e, t, r);
    }
    function fC(e, t) {
        let n = e[t];
        return n === "$" || n === "`";
    }
    function pC(e, t, n) {
        let { expr: r, pos: s } = km(e, t, n, false), i = [
            r
        ];
        for(; fC(t, s);){
            let { expr: a, pos: l } = km(e, t, s, true);
            i.push(a), s = l;
        }
        i.length > 1 && (r = {
            type: "ArithConcat",
            parts: i
        });
        let o;
        if (t[s] === "[" && r.type === "ArithConcat") {
            s++;
            let { expr: a, pos: l } = Et(e, t, s);
            o = a, s = l, t[s] === "]" && s++;
        }
        if (o && r.type === "ArithConcat" && (r = {
            type: "ArithDynamicElement",
            nameExpr: r,
            subscript: o
        }, o = void 0), s = ve(t, s), r.type === "ArithConcat" || r.type === "ArithVariable" || r.type === "ArithDynamicElement") {
            for (let a of Qs)if (t.slice(s, s + a.length) === a && t.slice(s, s + a.length + 1) !== "==") {
                s += a.length;
                let { expr: l, pos: c } = _r(e, t, s);
                return r.type === "ArithDynamicElement" ? {
                    expr: {
                        type: "ArithDynamicAssignment",
                        operator: a,
                        target: r.nameExpr,
                        subscript: r.subscript,
                        value: l
                    },
                    pos: c
                } : r.type === "ArithConcat" ? {
                    expr: {
                        type: "ArithDynamicAssignment",
                        operator: a,
                        target: r,
                        value: l
                    },
                    pos: c
                } : {
                    expr: {
                        type: "ArithAssignment",
                        operator: a,
                        variable: r.name,
                        value: l
                    },
                    pos: c
                };
            }
        }
        if (t.slice(s, s + 2) === "++" || t.slice(s, s + 2) === "--") {
            let a = t.slice(s, s + 2);
            return s += 2, {
                expr: {
                    type: "ArithUnary",
                    operator: a,
                    operand: r,
                    prefix: false
                },
                pos: s
            };
        }
        return {
            expr: r,
            pos: s
        };
    }
    function km(e, t, n, r = false) {
        let s = ve(t, n), i = hm(Et, e, t, s);
        if (i) return i;
        let o = mm(t, s);
        if (o) return o;
        let a = gm(t, s);
        if (a) return a;
        if (t.slice(s, s + 2) === "$(" && t[s + 2] !== "(") {
            s += 2;
            let c = 1, u = s;
            for(; s < t.length && c > 0;)t[s] === "(" ? c++ : t[s] === ")" && c--, c > 0 && s++;
            let f = t.slice(u, s);
            return s++, {
                expr: {
                    type: "ArithCommandSubst",
                    command: f
                },
                pos: s
            };
        }
        if (t[s] === "`") {
            s++;
            let c = s;
            for(; s < t.length && t[s] !== "`";)s++;
            let u = t.slice(c, s);
            return t[s] === "`" && s++, {
                expr: {
                    type: "ArithCommandSubst",
                    command: u
                },
                pos: s
            };
        }
        if (t[s] === "(") {
            s++;
            let { expr: c, pos: u } = Et(e, t, s);
            return s = ve(t, u), t[s] === ")" && s++, {
                expr: {
                    type: "ArithGroup",
                    expression: c
                },
                pos: s
            };
        }
        if (t[s] === "'") {
            s++;
            let c = "";
            for(; s < t.length && t[s] !== "'";)c += t[s], s++;
            t[s] === "'" && s++;
            let u = Number.parseInt(c, 10);
            return {
                expr: {
                    type: "ArithSingleQuote",
                    content: c,
                    value: Number.isNaN(u) ? 0 : u
                },
                pos: s
            };
        }
        if (t[s] === '"') {
            s++;
            let c = "";
            for(; s < t.length && t[s] !== '"';)t[s] === "\\" && s + 1 < t.length ? (c += t[s + 1], s += 2) : (c += t[s], s++);
            t[s] === '"' && s++;
            let u = c.trim();
            if (!u) return {
                expr: {
                    type: "ArithNumber",
                    value: 0
                },
                pos: s
            };
            let { expr: f } = Et(e, u, 0);
            return {
                expr: f,
                pos: s
            };
        }
        if (/[0-9]/.test(t[s])) {
            let c = "", u = false, f = false;
            for(; s < t.length;){
                let d = t[s];
                if (u) if (/[0-9a-zA-Z@_]/.test(d)) c += d, s++;
                else break;
                else if (d === "#") u = true, c += d, s++;
                else if (c === "0" && (d === "x" || d === "X") && s + 1 < t.length && /[0-9a-fA-F]/.test(t[s + 1])) f = true, c += d, s++;
                else if (f && /[0-9a-fA-F]/.test(d)) c += d, s++;
                else if (!f && /[0-9]/.test(d)) c += d, s++;
                else break;
            }
            if (s < t.length && /[a-zA-Z_]/.test(t[s])) {
                let d = c;
                for(; s < t.length && /[a-zA-Z0-9_]/.test(t[s]);)d += t[s], s++;
                return {
                    expr: {
                        type: "ArithSyntaxError",
                        errorToken: d,
                        message: `${d}: value too great for base (error token is "${d}")`
                    },
                    pos: s
                };
            }
            if (t[s] === "." && /[0-9]/.test(t[s + 1])) throw new Ee(`${c}.${t[s + 1]}...: syntax error: invalid arithmetic operator`);
            if (t[s] === "[") {
                let d = t.slice(s).trim();
                return {
                    expr: {
                        type: "ArithNumberSubscript",
                        number: c,
                        errorToken: d
                    },
                    pos: t.length
                };
            }
            return {
                expr: {
                    type: "ArithNumber",
                    value: Fr(c)
                },
                pos: s
            };
        }
        if (t[s] === "$" && t[s + 1] === "{") {
            let c = s + 2, u = 1, f = c;
            for(; f < t.length && u > 0;)t[f] === "{" ? u++ : t[f] === "}" && u--, u > 0 && f++;
            let p = t.slice(c, f), d = f + 1;
            if (t[d] === "#") {
                let m = d + 1;
                for(; m < t.length && /[0-9a-zA-Z@_]/.test(t[m]);)m++;
                let h = t.slice(d + 1, m);
                return {
                    expr: {
                        type: "ArithDynamicBase",
                        baseExpr: p,
                        value: h
                    },
                    pos: m
                };
            }
            if (/[0-9]/.test(t[d]) || t[d] === "x" || t[d] === "X") {
                let m = d;
                if (t[d] === "x" || t[d] === "X") for(m++; m < t.length && /[0-9a-fA-F]/.test(t[m]);)m++;
                else for(; m < t.length && /[0-9]/.test(t[m]);)m++;
                let h = t.slice(d, m);
                return {
                    expr: {
                        type: "ArithDynamicNumber",
                        prefix: p,
                        suffix: h
                    },
                    pos: m
                };
            }
            return s = d, {
                expr: {
                    type: "ArithBracedExpansion",
                    content: p
                },
                pos: s
            };
        }
        if (t[s] === "$" && s + 1 < t.length && /[0-9]/.test(t[s + 1])) {
            s++;
            let c = "";
            for(; s < t.length && /[0-9]/.test(t[s]);)c += t[s], s++;
            return {
                expr: {
                    type: "ArithVariable",
                    name: c,
                    hasDollarPrefix: true
                },
                pos: s
            };
        }
        if (t[s] === "$" && s + 1 < t.length && /[*@#?\-!$]/.test(t[s + 1])) {
            let c = t[s + 1];
            return s += 2, {
                expr: {
                    type: "ArithSpecialVar",
                    name: c
                },
                pos: s
            };
        }
        let l = false;
        if (t[s] === "$" && s + 1 < t.length && /[a-zA-Z_]/.test(t[s + 1]) && (l = true, s++), s < t.length && /[a-zA-Z_]/.test(t[s])) {
            let c = "";
            for(; s < t.length && /[a-zA-Z0-9_]/.test(t[s]);)c += t[s], s++;
            if (t[s] === "[" && !r) {
                s++;
                let u;
                if (t[s] === "'" || t[s] === '"') {
                    let p = t[s];
                    for(s++, u = ""; s < t.length && t[s] !== p;)u += t[s], s++;
                    t[s] === p && s++, s = ve(t, s), t[s] === "]" && s++;
                }
                let f;
                if (u === void 0) {
                    let { expr: p, pos: d } = Et(e, t, s);
                    f = p, s = d, t[s] === "]" && s++;
                }
                if (s = ve(t, s), t[s] === "[" && f) return {
                    expr: {
                        type: "ArithDoubleSubscript",
                        array: c,
                        index: f
                    },
                    pos: s
                };
                if (!r) {
                    for (let p of Qs)if (t.slice(s, s + p.length) === p && t.slice(s, s + p.length + 1) !== "==") {
                        s += p.length;
                        let { expr: d, pos: m } = _r(e, t, s);
                        return {
                            expr: {
                                type: "ArithAssignment",
                                operator: p,
                                variable: c,
                                subscript: f,
                                stringKey: u,
                                value: d
                            },
                            pos: m
                        };
                    }
                }
                return {
                    expr: {
                        type: "ArithArrayElement",
                        array: c,
                        index: f,
                        stringKey: u
                    },
                    pos: s
                };
            }
            if (s = ve(t, s), !r) {
                for (let u of Qs)if (t.slice(s, s + u.length) === u && t.slice(s, s + u.length + 1) !== "==") {
                    s += u.length;
                    let { expr: f, pos: p } = _r(e, t, s);
                    return {
                        expr: {
                            type: "ArithAssignment",
                            operator: u,
                            variable: c,
                            value: f
                        },
                        pos: p
                    };
                }
            }
            return {
                expr: {
                    type: "ArithVariable",
                    name: c,
                    hasDollarPrefix: l
                },
                pos: s
            };
        }
        if (t[s] === "#") {
            let c = s + 1;
            for(; c < t.length && t[c] !== `
`;)c++;
            let u = t.slice(s, c).trim() || "#";
            return {
                expr: {
                    type: "ArithSyntaxError",
                    errorToken: u,
                    message: `${u}: syntax error: invalid arithmetic operator (error token is "${u}")`
                },
                pos: t.length
            };
        }
        return {
            expr: {
                type: "ArithNumber",
                value: 0
            },
            pos: s
        };
    }
    var Je = v(()=>{
        de();
        ym();
    });
    function dC(e) {
        let t = "", n = 0;
        for(; n < e.length;){
            let r = e[n];
            if (r < 128) {
                t += String.fromCharCode(r), n++;
                continue;
            }
            if ((r & 224) === 192) {
                if (n + 1 < e.length && (e[n + 1] & 192) === 128 && r >= 194) {
                    let s = (r & 31) << 6 | e[n + 1] & 63;
                    t += String.fromCharCode(s), n += 2;
                    continue;
                }
                t += String.fromCharCode(r), n++;
                continue;
            }
            if ((r & 240) === 224) {
                if (n + 2 < e.length && (e[n + 1] & 192) === 128 && (e[n + 2] & 192) === 128) {
                    if (r === 224 && e[n + 1] < 160) {
                        t += String.fromCharCode(r), n++;
                        continue;
                    }
                    let s = (r & 15) << 12 | (e[n + 1] & 63) << 6 | e[n + 2] & 63;
                    if (s >= 55296 && s <= 57343) {
                        t += String.fromCharCode(r), n++;
                        continue;
                    }
                    t += String.fromCharCode(s), n += 3;
                    continue;
                }
                t += String.fromCharCode(r), n++;
                continue;
            }
            if ((r & 248) === 240 && r <= 244) {
                if (n + 3 < e.length && (e[n + 1] & 192) === 128 && (e[n + 2] & 192) === 128 && (e[n + 3] & 192) === 128) {
                    if (r === 240 && e[n + 1] < 144) {
                        t += String.fromCharCode(r), n++;
                        continue;
                    }
                    let s = (r & 7) << 18 | (e[n + 1] & 63) << 12 | (e[n + 2] & 63) << 6 | e[n + 3] & 63;
                    if (s > 1114111) {
                        t += String.fromCharCode(r), n++;
                        continue;
                    }
                    t += String.fromCodePoint(s), n += 4;
                    continue;
                }
                t += String.fromCharCode(r), n++;
                continue;
            }
            t += String.fromCharCode(r), n++;
        }
        return t;
    }
    function Im(e, t, n) {
        let r = n + 1;
        for(; r < t.length && /[a-zA-Z0-9_-]/.test(t[r]);)r++;
        return r;
    }
    function ya(e, t, n, r, s) {
        let i = 1, o = n + 1;
        for(; o < t.length && i > 0;)t[o] === r ? i++ : t[o] === s && i--, i > 0 && o++;
        return i === 0 ? o : -1;
    }
    function Nn(e, t, n) {
        let r = n, s = 1;
        for(; r < t.length && s > 0;){
            let i = t[r];
            if (i === "\\" && r + 1 < t.length) {
                r += 2;
                continue;
            }
            if (i === "'") {
                let o = t.indexOf("'", r + 1);
                if (o !== -1) {
                    r = o + 1;
                    continue;
                }
            }
            if (i === '"') {
                for(r++; r < t.length && t[r] !== '"';)t[r] === "\\" && r + 1 < t.length ? r += 2 : r++;
                r < t.length && r++;
                continue;
            }
            i === "{" ? s++ : i === "}" && s--, s > 0 && r++;
        }
        return r;
    }
    function Rm(e, t, n) {
        let r = n, s = false;
        for(; r < t.length;){
            let i = t[r];
            if (i === "/" && s || i === "}") break;
            if (i === "'") {
                let o = t.indexOf("'", r + 1);
                if (o !== -1) {
                    r = o + 1, s = true;
                    continue;
                }
            }
            if (i === '"') {
                for(r++; r < t.length && t[r] !== '"';)t[r] === "\\" && r + 1 < t.length ? r += 2 : r++;
                r < t.length && r++, s = true;
                continue;
            }
            i === "\\" ? (r += 2, s = true) : (r++, s = true);
        }
        return r;
    }
    function Pm(e, t, n) {
        let r = n, s = "";
        for(; r < t.length;){
            let i = t[r];
            if (i === "*" || i === "?") s += i, r++;
            else if (i === "[") {
                let o = hC(t, r);
                o === -1 ? (s += i, r++) : (s += t.slice(r, o + 1), r = o + 1);
            } else break;
        }
        return {
            pattern: s,
            endIndex: r
        };
    }
    function hC(e, t) {
        let n = t + 1;
        for(n < e.length && e[n] === "^" && n++, n < e.length && e[n] === "]" && n++; n < e.length;){
            let r = e[n];
            if (r === "\\" && n + 1 < e.length) {
                let s = e[n + 1];
                if (s === '"' || s === "'") return -1;
                n += 2;
                continue;
            }
            if (r === "]") return n;
            if (r === '"' || r === "$" || r === "`") return -1;
            if (r === "'") {
                let s = e.indexOf("'", n + 1);
                if (s !== -1) {
                    n = s + 1;
                    continue;
                }
            }
            if (r === "[" && n + 1 < e.length && e[n + 1] === ":") {
                let s = e.indexOf(":]", n + 2);
                if (s !== -1) {
                    n = s + 2;
                    continue;
                }
            }
            if (r === "[" && n + 1 < e.length && (e[n + 1] === "." || e[n + 1] === "=")) {
                let i = `${e[n + 1]}]`, o = e.indexOf(i, n + 2);
                if (o !== -1) {
                    n = o + 2;
                    continue;
                }
            }
            n++;
        }
        return -1;
    }
    function Tm(e, t, n) {
        let r = "", s = n;
        for(; s < t.length && t[s] !== "'";){
            let i = t[s];
            if (i === "\\" && s + 1 < t.length) switch(t[s + 1]){
                case "n":
                    r += `
`, s += 2;
                    break;
                case "t":
                    r += "	", s += 2;
                    break;
                case "r":
                    r += "\r", s += 2;
                    break;
                case "\\":
                    r += "\\", s += 2;
                    break;
                case "'":
                    r += "'", s += 2;
                    break;
                case '"':
                    r += '"', s += 2;
                    break;
                case "a":
                    r += "\x07", s += 2;
                    break;
                case "b":
                    r += "\b", s += 2;
                    break;
                case "e":
                case "E":
                    r += "\x1B", s += 2;
                    break;
                case "f":
                    r += "\f", s += 2;
                    break;
                case "v":
                    r += "\v", s += 2;
                    break;
                case "x":
                    {
                        let a = [], l = s;
                        for(; l + 1 < t.length && t[l] === "\\" && t[l + 1] === "x";){
                            let c = t.slice(l + 2, l + 4), u = parseInt(c, 16);
                            if (!Number.isNaN(u) && c.length > 0) a.push(u), l += 2 + c.length;
                            else break;
                        }
                        a.length > 0 ? (r += dC(a), s = l) : (r += "\\x", s += 2);
                        break;
                    }
                case "u":
                    {
                        let a = t.slice(s + 2, s + 6), l = parseInt(a, 16);
                        Number.isNaN(l) ? (r += "\\u", s += 2) : (r += String.fromCharCode(l), s += 6);
                        break;
                    }
                case "c":
                    {
                        if (s + 2 < t.length) {
                            let l = t[s + 2].charCodeAt(0) & 31;
                            r += String.fromCharCode(l), s += 3;
                        } else r += "\\c", s += 2;
                        break;
                    }
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                    {
                        let a = "", l = s + 1;
                        for(; l < t.length && l < s + 4 && /[0-7]/.test(t[l]);)a += t[l], l++;
                        let c = parseInt(a, 8);
                        r += String.fromCharCode(c), s = l;
                        break;
                    }
                default:
                    r += i, s++;
            }
            else r += i, s++;
        }
        return s < t.length && t[s] === "'" && s++, {
            part: j.literal(r),
            endIndex: s
        };
    }
    function ba(e, t) {
        let n = t.trim();
        return n === "" ? {
            type: "ArithmeticExpression",
            expression: {
                type: "ArithNumber",
                value: 0
            }
        } : he(e, n);
    }
    function $m(e) {
        let t = [], n = "", r = 0;
        for(let s = 0; s < e.length; s++){
            let i = e[s];
            i === "{" ? (r++, n += i) : i === "}" ? (r--, n += i) : i === "," && r === 0 ? (t.push(n), n = "") : n += i;
        }
        return t.push(n), t;
    }
    function Om(e, t, n, r) {
        let s = ya(e, t, n, "{", "}");
        if (s === -1) return null;
        let i = t.slice(n + 1, s), o = i.match(/^(-?\d+)\.\.(-?\d+)(?:\.\.(-?\d+))?$/);
        if (o) return {
            part: {
                type: "BraceExpansion",
                items: [
                    {
                        type: "Range",
                        start: Number.parseInt(o[1], 10),
                        end: Number.parseInt(o[2], 10),
                        step: o[3] ? Number.parseInt(o[3], 10) : void 0,
                        startStr: o[1],
                        endStr: o[2]
                    }
                ]
            },
            endIndex: s + 1
        };
        let a = i.match(/^([a-zA-Z])\.\.([a-zA-Z])(?:\.\.(-?\d+))?$/);
        return a ? {
            part: {
                type: "BraceExpansion",
                items: [
                    {
                        type: "Range",
                        start: a[1],
                        end: a[2],
                        step: a[3] ? Number.parseInt(a[3], 10) : void 0
                    }
                ]
            },
            endIndex: s + 1
        } : i.includes(",") && r ? {
            part: {
                type: "BraceExpansion",
                items: $m(i).map((u)=>({
                        type: "Word",
                        word: j.word(r(e, u, false, false, false))
                    }))
            },
            endIndex: s + 1
        } : i.includes(",") ? {
            part: {
                type: "BraceExpansion",
                items: $m(i).map((u)=>({
                        type: "Word",
                        word: j.word([
                            j.literal(u)
                        ])
                    }))
            },
            endIndex: s + 1
        } : null;
    }
    function wa(e, t) {
        let n = "";
        for (let r of t.parts)switch(r.type){
            case "Literal":
                n += r.value;
                break;
            case "SingleQuoted":
                n += `'${r.value}'`;
                break;
            case "Escaped":
                n += r.value;
                break;
            case "DoubleQuoted":
                n += '"';
                for (let s of r.parts)s.type === "Literal" || s.type === "Escaped" ? n += s.value : s.type === "ParameterExpansion" && (n += `\${${s.parameter}}`);
                n += '"';
                break;
            case "ParameterExpansion":
                n += `\${${r.parameter}}`;
                break;
            case "Glob":
                n += r.pattern;
                break;
            case "TildeExpansion":
                n += "~", r.user && (n += r.user);
                break;
            case "BraceExpansion":
                {
                    n += "{";
                    let s = [];
                    for (let i of r.items)if (i.type === "Range") {
                        let o = i.startStr ?? String(i.start), a = i.endStr ?? String(i.end);
                        i.step !== void 0 ? s.push(`${o}..${a}..${i.step}`) : s.push(`${o}..${a}`);
                    } else s.push(wa(e, i.word));
                    s.length === 1 && r.items[0].type === "Range" ? n += s[0] : n += s.join(","), n += "}";
                    break;
                }
            default:
                n += r.type;
        }
        return n;
    }
    function Dm(e, t) {
        return {
            [x.LESS]: "<",
            [x.GREAT]: ">",
            [x.DGREAT]: ">>",
            [x.LESSAND]: "<&",
            [x.GREATAND]: ">&",
            [x.LESSGREAT]: "<>",
            [x.CLOBBER]: ">|",
            [x.TLESS]: "<<<",
            [x.AND_GREAT]: "&>",
            [x.AND_DGREAT]: "&>>",
            [x.DLESS]: "<",
            [x.DLESSDASH]: "<"
        }[t] || ">";
    }
    var xa = v(()=>{
        Cn();
        Je();
        tn();
    });
    function Xs(e) {
        let t = e.current(), n = t.type;
        if (n === x.NUMBER) {
            let r = e.peek(1);
            return t.end !== r.start ? false : pm.has(r.type);
        }
        if (n === x.FD_VARIABLE) {
            let r = e.peek(1);
            return dm.has(r.type);
        }
        return fm.has(n);
    }
    function Js(e) {
        let t = null, n;
        e.check(x.NUMBER) ? t = Number.parseInt(e.advance().value, 10) : e.check(x.FD_VARIABLE) && (n = e.advance().value);
        let r = e.advance(), s = Dm(e, r.type);
        if (r.type === x.DLESS || r.type === x.DLESSDASH) return mC(e, s, t, r.type === x.DLESSDASH);
        e.isWord() || e.error("Expected redirection target");
        let i = e.parseWord();
        return j.redirection(s, i, t, n);
    }
    function mC(e, t, n, r) {
        e.isWord() || e.error("Expected here-document delimiter");
        let s = e.advance(), i = s.value, o = s.quoted || false;
        (i.startsWith("'") && i.endsWith("'") || i.startsWith('"') && i.endsWith('"')) && (i = i.slice(1, -1));
        let a = j.redirection(r ? "<<-" : "<<", j.hereDoc(i, j.word([]), r, o), n);
        return e.addPendingHeredoc(a, i, r, o), a;
    }
    function _m(e) {
        let t = e.current().line, n = [], r = null, s = [], i = [];
        for(; e.check(x.ASSIGNMENT_WORD) || Xs(e);)e.checkIterationLimit(), e.check(x.ASSIGNMENT_WORD) ? n.push(gC(e)) : i.push(Js(e));
        if (e.isWord()) r = e.parseWord();
        else if (n.length > 0 && (e.check(x.DBRACK_START) || e.check(x.DPAREN_START))) {
            let a = e.advance();
            r = j.word([
                j.literal(a.value)
            ]);
        }
        for(; (!e.isStatementEnd() || e.check(x.RBRACE)) && !e.check(x.PIPE, x.PIPE_AMP);)if (e.checkIterationLimit(), Xs(e)) i.push(Js(e));
        else if (e.check(x.RBRACE)) {
            let a = e.advance();
            s.push(e.parseWordFromString(a.value, false, false));
        } else if (e.check(x.LBRACE)) {
            let a = e.advance();
            s.push(e.parseWordFromString(a.value, false, false));
        } else if (e.check(x.DBRACK_END)) {
            let a = e.advance();
            s.push(e.parseWordFromString(a.value, false, false));
        } else if (e.isWord()) s.push(e.parseWord());
        else if (e.check(x.ASSIGNMENT_WORD)) {
            let a = e.advance(), l = a.value, c = l.endsWith("="), u = l.endsWith("=(");
            if ((c || u) && (u || e.check(x.LPAREN))) {
                let f = u ? l.slice(0, -2) : l.slice(0, -1);
                u || e.expect(x.LPAREN);
                let p = Ea(e);
                e.expect(x.RPAREN);
                let d = p.map((h)=>wa(e, h)), m = `${f}=(${d.join(" ")})`;
                s.push(e.parseWordFromString(m, false, false));
            } else s.push(e.parseWordFromString(l, a.quoted, a.singleQuoted));
        } else if (e.check(x.LPAREN)) e.error("syntax error near unexpected token `('");
        else break;
        let o = j.simpleCommand(r, s, n, i);
        return o.line = t, o;
    }
    function gC(e) {
        let t = e.expect(x.ASSIGNMENT_WORD), n = t.value, r = n.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
        r || e.error(`Invalid assignment: ${n}`);
        let s = r[0], i, o = s.length;
        if (n[o] === "[") {
            let f = 0, p = o + 1;
            for(; o < n.length; o++)if (n[o] === "[") f++;
            else if (n[o] === "]" && (f--, f === 0)) break;
            f !== 0 && e.error(`Invalid assignment: ${n}`), i = n.slice(p, o), o++;
        }
        let a = n[o] === "+";
        a && o++, n[o] !== "=" && e.error(`Invalid assignment: ${n}`), o++;
        let l = n.slice(o);
        if (l === "(") {
            let f = Ea(e);
            e.expect(x.RPAREN);
            let p = i !== void 0 ? `${s}[${i}]` : s;
            return j.assignment(p, null, a, f);
        }
        if (l === "" && e.check(x.LPAREN)) {
            let f = e.current();
            if (t.end === f.start) {
                e.advance();
                let p = Ea(e);
                e.expect(x.RPAREN);
                let d = i !== void 0 ? `${s}[${i}]` : s;
                return j.assignment(d, null, a, p);
            }
        }
        let c = l ? e.parseWordFromString(l, t.quoted, t.singleQuoted, true) : null, u = i !== void 0 ? `${s}[${i}]` : s;
        return j.assignment(u, c, a, null);
    }
    function Ea(e) {
        let t = [];
        for(e.skipNewlines(); !e.check(x.RPAREN, x.EOF);)e.checkIterationLimit(), e.isWord() ? t.push(e.parseWord()) : yC.has(e.current().type) ? e.error(`syntax error near unexpected token \`${e.current().value}'`) : e.advance(), e.skipNewlines();
        return t;
    }
    var yC, Lm = v(()=>{
        Cn();
        tn();
        An();
        xa();
        yC = new Set([
            x.AMP,
            x.PIPE,
            x.PIPE_AMP,
            x.SEMICOLON,
            x.AND_AND,
            x.OR_OR,
            x.DSEMI,
            x.SEMI_AND,
            x.SEMI_SEMI_AND
        ]);
    });
    function Sa(e, t) {
        e.expect(x.IF);
        let n = [], r = e.parseCompoundList();
        e.expect(x.THEN);
        let s = e.parseCompoundList();
        if (s.length === 0) {
            let a = e.check(x.FI) ? "fi" : e.check(x.ELSE) ? "else" : e.check(x.ELIF) ? "elif" : "fi";
            e.error(`syntax error near unexpected token \`${a}'`);
        }
        for(n.push({
            condition: r,
            body: s
        }); e.check(x.ELIF);){
            e.advance();
            let a = e.parseCompoundList();
            e.expect(x.THEN);
            let l = e.parseCompoundList();
            if (l.length === 0) {
                let c = e.check(x.FI) ? "fi" : e.check(x.ELSE) ? "else" : e.check(x.ELIF) ? "elif" : "fi";
                e.error(`syntax error near unexpected token \`${c}'`);
            }
            n.push({
                condition: a,
                body: l
            });
        }
        let i = null;
        e.check(x.ELSE) && (e.advance(), i = e.parseCompoundList(), i.length === 0 && e.error("syntax error near unexpected token `fi'")), e.expect(x.FI);
        let o = t?.skipRedirections ? [] : e.parseOptionalRedirections();
        return j.ifNode(n, i, o);
    }
    function Aa(e, t) {
        let n = e.expect(x.FOR);
        if (e.check(x.DPAREN_START)) return wC(e, t, n.line);
        e.isWord() || e.error("Expected variable name in for loop");
        let s = e.advance().value, i = null;
        if (e.skipNewlines(), e.check(x.IN)) for(e.advance(), i = []; !e.check(x.SEMICOLON, x.NEWLINE, x.DO, x.EOF) && e.isWord();)i.push(e.parseWord());
        e.check(x.SEMICOLON) && e.advance(), e.skipNewlines(), e.expect(x.DO);
        let o = e.parseCompoundList();
        e.expect(x.DONE);
        let a = t?.skipRedirections ? [] : e.parseOptionalRedirections();
        return j.forNode(s, i, o, a);
    }
    function wC(e, t, n) {
        e.expect(x.DPAREN_START);
        let r = null, s = null, i = null, o = [
            "",
            "",
            ""
        ], a = 0, l = 0;
        for(; !e.check(x.DPAREN_END, x.EOF);){
            let f = e.advance();
            if (f.type === x.SEMICOLON && l === 0) {
                if (a++, a > 2) break;
            } else f.value === "(" && l++, f.value === ")" && l--, o[a] += f.value;
        }
        e.expect(x.DPAREN_END), o[0].trim() && (r = he(e, o[0].trim())), o[1].trim() && (s = he(e, o[1].trim())), o[2].trim() && (i = he(e, o[2].trim())), e.skipNewlines(), e.check(x.SEMICOLON) && e.advance(), e.skipNewlines();
        let c;
        e.check(x.LBRACE) ? (e.advance(), c = e.parseCompoundList(), e.expect(x.RBRACE)) : (e.expect(x.DO), c = e.parseCompoundList(), e.expect(x.DONE));
        let u = t?.skipRedirections ? [] : e.parseOptionalRedirections();
        return {
            type: "CStyleFor",
            init: r,
            condition: s,
            update: i,
            body: c,
            redirections: u,
            line: n
        };
    }
    function Ca(e, t) {
        e.expect(x.WHILE);
        let n = e.parseCompoundList();
        e.expect(x.DO);
        let r = e.parseCompoundList();
        r.length === 0 && e.error("syntax error near unexpected token `done'"), e.expect(x.DONE);
        let s = t?.skipRedirections ? [] : e.parseOptionalRedirections();
        return j.whileNode(n, r, s);
    }
    function Na(e, t) {
        e.expect(x.UNTIL);
        let n = e.parseCompoundList();
        e.expect(x.DO);
        let r = e.parseCompoundList();
        r.length === 0 && e.error("syntax error near unexpected token `done'"), e.expect(x.DONE);
        let s = t?.skipRedirections ? [] : e.parseOptionalRedirections();
        return j.untilNode(n, r, s);
    }
    function ka(e, t) {
        e.expect(x.CASE), e.isWord() || e.error("Expected word after 'case'");
        let n = e.parseWord();
        e.skipNewlines(), e.expect(x.IN), e.skipNewlines();
        let r = [];
        for(; !e.check(x.ESAC, x.EOF);){
            e.checkIterationLimit();
            let i = e.getPos(), o = xC(e);
            if (o && r.push(o), e.skipNewlines(), e.getPos() === i && !o) break;
        }
        e.expect(x.ESAC);
        let s = t?.skipRedirections ? [] : e.parseOptionalRedirections();
        return j.caseNode(n, r, s);
    }
    function xC(e) {
        e.check(x.LPAREN) && e.advance();
        let t = [];
        for(; e.isWord() && (t.push(e.parseWord()), e.check(x.PIPE));)e.advance();
        if (t.length === 0) return null;
        e.expect(x.RPAREN), e.skipNewlines();
        let n = [];
        for(; !e.check(x.DSEMI, x.SEMI_AND, x.SEMI_SEMI_AND, x.ESAC, x.EOF);){
            e.checkIterationLimit(), e.isWord() && e.peek(1).type === x.RPAREN && e.error("syntax error near unexpected token `)'"), e.check(x.LPAREN) && e.peek(1).type === x.WORD && e.error(`syntax error near unexpected token \`${e.peek(1).value}'`);
            let s = e.getPos(), i = e.parseStatement();
            if (i && n.push(i), e.skipSeparators(false), e.getPos() === s && !i) break;
        }
        let r = ";;";
        return e.check(x.DSEMI) ? (e.advance(), r = ";;") : e.check(x.SEMI_AND) ? (e.advance(), r = ";&") : e.check(x.SEMI_SEMI_AND) && (e.advance(), r = ";;&"), j.caseItem(t, n, r);
    }
    function va(e, t) {
        e.expect(x.LPAREN);
        let n = e.parseCompoundList();
        e.expect(x.RPAREN);
        let r = t?.skipRedirections ? [] : e.parseOptionalRedirections();
        return j.subshell(n, r);
    }
    function $a(e, t) {
        e.expect(x.LBRACE);
        let n = e.parseCompoundList();
        e.expect(x.RBRACE);
        let r = t?.skipRedirections ? [] : e.parseOptionalRedirections();
        return j.group(n, r);
    }
    var Mm = v(()=>{
        Cn();
        Je();
        tn();
    });
    function Wm(e) {
        return e.isWord() || e.check(x.LBRACE) || e.check(x.RBRACE) || e.check(x.ASSIGNMENT_WORD);
    }
    function Bm(e) {
        if (e.check(x.BANG) && e.peek(1).type === x.LPAREN) {
            e.advance(), e.advance();
            let t = 1, n = "!(";
            for(; t > 0 && !e.check(x.EOF);)if (e.check(x.LPAREN)) t++, n += "(", e.advance();
            else if (e.check(x.RPAREN)) t--, t > 0 && (n += ")"), e.advance();
            else if (e.isWord()) n += e.advance().value;
            else if (e.check(x.PIPE)) n += "|", e.advance();
            else break;
            return n += ")", e.parseWordFromString(n, false, false, false, false, true);
        }
        return e.parseWordNoBraceExpansion();
    }
    function Ra(e) {
        return e.skipNewlines(), CC(e);
    }
    function CC(e) {
        let t = Um(e);
        for(e.skipNewlines(); e.check(x.OR_OR);){
            e.advance(), e.skipNewlines();
            let n = Um(e);
            t = {
                type: "CondOr",
                left: t,
                right: n
            }, e.skipNewlines();
        }
        return t;
    }
    function Um(e) {
        let t = Ia(e);
        for(e.skipNewlines(); e.check(x.AND_AND);){
            e.advance(), e.skipNewlines();
            let n = Ia(e);
            t = {
                type: "CondAnd",
                left: t,
                right: n
            }, e.skipNewlines();
        }
        return t;
    }
    function Ia(e) {
        return e.skipNewlines(), e.check(x.BANG) ? (e.advance(), e.skipNewlines(), {
            type: "CondNot",
            operand: Ia(e)
        }) : NC(e);
    }
    function NC(e) {
        if (e.check(x.LPAREN)) {
            e.advance();
            let t = Ra(e);
            return e.expect(x.RPAREN), {
                type: "CondGroup",
                expression: t
            };
        }
        if (Wm(e)) {
            let t = e.current(), n = t.value;
            if (SC.includes(n) && !t.quoted) {
                if (e.advance(), e.check(x.DBRACK_END) && e.error(`Expected operand after ${n}`), Wm(e)) {
                    let i = e.parseWordNoBraceExpansion();
                    return {
                        type: "CondUnary",
                        operator: n,
                        operand: i
                    };
                }
                let s = e.current();
                e.error(`unexpected argument \`${s.value}' to conditional unary operator`);
            }
            let r = e.parseWordNoBraceExpansion();
            if (e.isWord() && AC.includes(e.current().value)) {
                let s = e.advance().value, i;
                return s === "=~" ? i = kC(e) : s === "==" || s === "!=" ? i = Bm(e) : i = e.parseWordNoBraceExpansion(), {
                    type: "CondBinary",
                    operator: s,
                    left: r,
                    right: i
                };
            }
            if (e.check(x.LESS)) {
                e.advance();
                let s = e.parseWordNoBraceExpansion();
                return {
                    type: "CondBinary",
                    operator: "<",
                    left: r,
                    right: s
                };
            }
            if (e.check(x.GREAT)) {
                e.advance();
                let s = e.parseWordNoBraceExpansion();
                return {
                    type: "CondBinary",
                    operator: ">",
                    left: r,
                    right: s
                };
            }
            if (e.isWord() && e.current().value === "=") {
                e.advance();
                let s = Bm(e);
                return {
                    type: "CondBinary",
                    operator: "==",
                    left: r,
                    right: s
                };
            }
            return {
                type: "CondWord",
                word: r
            };
        }
        e.error("Expected conditional expression");
    }
    function kC(e) {
        let t = [], n = 0, r = -1, s = e.getInput(), i = ()=>e.check(x.DBRACK_END) || e.check(x.AND_AND) || e.check(x.OR_OR) || e.check(x.NEWLINE) || e.check(x.EOF);
        for(; !i();){
            let o = e.current(), a = r >= 0 && o.start > r;
            if (n === 0 && a) break;
            if (n > 0 && a) {
                let l = s.slice(r, o.start);
                t.push({
                    type: "Literal",
                    value: l
                });
            }
            if (e.isWord() || e.check(x.ASSIGNMENT_WORD)) {
                let l = e.parseWordForRegex();
                t.push(...l.parts), r = e.peek(-1).end;
            } else if (e.check(x.LPAREN)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "("
                }), n++, r = l.end;
            } else if (e.check(x.DPAREN_START)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "(("
                }), n += 2, r = l.end;
            } else if (e.check(x.DPAREN_END)) if (n >= 2) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "))"
                }), n -= 2, r = l.end;
            } else {
                if (n === 1) break;
                break;
            }
            else if (e.check(x.RPAREN)) if (n > 0) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: ")"
                }), n--, r = l.end;
            } else break;
            else if (e.check(x.PIPE)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "|"
                }), r = l.end;
            } else if (e.check(x.SEMICOLON)) if (n > 0) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: ";"
                }), r = l.end;
            } else break;
            else if (n > 0 && e.check(x.LESS)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "<"
                }), r = l.end;
            } else if (n > 0 && e.check(x.GREAT)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: ">"
                }), r = l.end;
            } else if (n > 0 && e.check(x.DGREAT)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: ">>"
                }), r = l.end;
            } else if (n > 0 && e.check(x.DLESS)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "<<"
                }), r = l.end;
            } else if (n > 0 && e.check(x.LESSAND)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "<&"
                }), r = l.end;
            } else if (n > 0 && e.check(x.GREATAND)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: ">&"
                }), r = l.end;
            } else if (n > 0 && e.check(x.LESSGREAT)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "<>"
                }), r = l.end;
            } else if (n > 0 && e.check(x.CLOBBER)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: ">|"
                }), r = l.end;
            } else if (n > 0 && e.check(x.TLESS)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "<<<"
                }), r = l.end;
            } else if (n > 0 && e.check(x.AMP)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "&"
                }), r = l.end;
            } else if (n > 0 && e.check(x.LBRACE)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "{"
                }), r = l.end;
            } else if (n > 0 && e.check(x.RBRACE)) {
                let l = e.advance();
                t.push({
                    type: "Literal",
                    value: "}"
                }), r = l.end;
            } else break;
        }
        return t.length === 0 && e.error("Expected regex pattern after =~"), {
            type: "Word",
            parts: t
        };
    }
    var SC, AC, zm = v(()=>{
        tn();
        SC = [
            "-a",
            "-b",
            "-c",
            "-d",
            "-e",
            "-f",
            "-g",
            "-h",
            "-k",
            "-p",
            "-r",
            "-s",
            "-t",
            "-u",
            "-w",
            "-x",
            "-G",
            "-L",
            "-N",
            "-O",
            "-S",
            "-z",
            "-n",
            "-o",
            "-v",
            "-R"
        ], AC = [
            "==",
            "!=",
            "=~",
            "<",
            ">",
            "-eq",
            "-ne",
            "-lt",
            "-le",
            "-gt",
            "-ge",
            "-nt",
            "-ot",
            "-ef"
        ];
    });
    function $C(e, t) {
        let n = 1, r = t + 1;
        for(; r < e.length && n > 0;){
            let s = e[r];
            if (s === "\\") {
                r += 2;
                continue;
            }
            if ("@*+?!".includes(s) && r + 1 < e.length && e[r + 1] === "(") {
                r++, n++, r++;
                continue;
            }
            if (s === "(") n++;
            else if (s === ")" && (n--, n === 0)) return r;
            r++;
        }
        return -1;
    }
    function IC(e, t, n) {
        let r = n + 1, s = t[r];
        if ("@*#?$!-0123456789".includes(s)) return {
            part: j.parameterExpansion(s),
            endIndex: r + 1
        };
        let i = "";
        for(; r < t.length && /[a-zA-Z0-9_]/.test(t[r]);)i += t[r], r++;
        return {
            part: j.parameterExpansion(i),
            endIndex: r
        };
    }
    function RC(e, t, n, r = false) {
        let s = n + 2, i = false;
        t[s] === "!" && (i = true, s++);
        let o = false;
        t[s] === "#" && !/[}:#%/^,]/.test(t[s + 1] || "}") && (o = true, s++);
        let a = "", l = t[s];
        if (/[@*#?$!-]/.test(l) && !/[a-zA-Z0-9_]/.test(t[s + 1] || "")) a = l, s++;
        else for(; s < t.length && /[a-zA-Z0-9_]/.test(t[s]);)a += t[s], s++;
        if (t[s] === "[") {
            let u = ya(e, t, s, "[", "]");
            if (a += t.slice(s, u + 1), s = u + 1, t[s] === "[") {
                let f = 1, p = s;
                for(; p < t.length && f > 0;)t[p] === "{" ? f++ : t[p] === "}" && f--, f > 0 && p++;
                let d = t.slice(n + 2, p);
                return {
                    part: j.parameterExpansion("", {
                        type: "BadSubstitution",
                        text: d
                    }),
                    endIndex: p + 1
                };
            }
        }
        if (a === "" && !i && !o && t[s] !== "}") {
            let u = 1, f = s;
            for(; f < t.length && u > 0;)t[f] === "{" ? u++ : t[f] === "}" && u--, u > 0 && f++;
            if (u > 0) throw new Ge("unexpected EOF while looking for matching '}'", 0, 0);
            let p = t.slice(n + 2, f);
            return {
                part: j.parameterExpansion("", {
                    type: "BadSubstitution",
                    text: p
                }),
                endIndex: f + 1
            };
        }
        let c = null;
        if (i) {
            let u = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
            if (u) if (s < t.length && t[s] !== "}" && /[:=\-+?#%/^,@]/.test(t[s])) {
                let f = Pa(e, t, s, a, r);
                f.operation ? (c = {
                    type: "Indirection",
                    innerOp: f.operation
                }, s = f.endIndex) : (c = {
                    type: "ArrayKeys",
                    array: u[1],
                    star: u[2] === "*"
                }, a = "");
            } else c = {
                type: "ArrayKeys",
                array: u[1],
                star: u[2] === "*"
            }, a = "";
            else if (t[s] === "*" || t[s] === "@" && !/[QPaAEKkuUL]/.test(t[s + 1] || "")) {
                let f = t[s];
                s++, c = {
                    type: "VarNamePrefix",
                    prefix: a,
                    star: f === "*"
                }, a = "";
            } else if (s < t.length && t[s] !== "}" && /[:=\-+?#%/^,@]/.test(t[s])) {
                let f = Pa(e, t, s, a, r);
                f.operation ? (c = {
                    type: "Indirection",
                    innerOp: f.operation
                }, s = f.endIndex) : c = {
                    type: "Indirection"
                };
            } else c = {
                type: "Indirection"
            };
        } else if (o) if (t[s] === ":") for(c = {
            type: "LengthSliceError"
        }; s < t.length && t[s] !== "}";)s++;
        else t[s] !== "}" && /[-+=?]/.test(t[s]) ? e.error(`\${#${a}${t.slice(s, t.indexOf("}", s))}}: bad substitution`) : t[s] === "/" ? e.error(`\${#${a}${t.slice(s, t.indexOf("}", s))}}: bad substitution`) : c = {
            type: "Length"
        };
        if (!c && s < t.length && t[s] !== "}") {
            let u = Pa(e, t, s, a, r);
            c = u.operation, s = u.endIndex;
        }
        if (s < t.length && t[s] !== "}") {
            let u = t[s];
            if (!/[:\-+=?#%/^,@[]/.test(u)) {
                let f = s;
                for(; f < t.length && t[f] !== "}";)f++;
                let p = t.slice(n, f + 1);
                e.error(`\${${p.slice(2, -1)}}: bad substitution`);
            }
        }
        for(; s < t.length && t[s] !== "}";)s++;
        if (s >= t.length) throw new Ge("unexpected EOF while looking for matching '}'", 0, 0);
        return {
            part: j.parameterExpansion(a, c),
            endIndex: s + 1
        };
    }
    function Pa(e, t, n, r, s = false) {
        let i = n, o = t[i], a = t[i + 1] || "";
        if (o === ":") {
            let l = a;
            if ("-=?+".includes(l)) {
                i += 2;
                let b = Nn(e, t, i), y = t.slice(i, b), w = nn(e, y, false, false, true, false, s, false, false, true), E = j.word(w.length > 0 ? w : [
                    j.literal("")
                ]);
                if (l === "-") return {
                    operation: {
                        type: "DefaultValue",
                        word: E,
                        checkEmpty: true
                    },
                    endIndex: b
                };
                if (l === "=") return {
                    operation: {
                        type: "AssignDefault",
                        word: E,
                        checkEmpty: true
                    },
                    endIndex: b
                };
                if (l === "?") return {
                    operation: {
                        type: "ErrorIfUnset",
                        word: E,
                        checkEmpty: true
                    },
                    endIndex: b
                };
                if (l === "+") return {
                    operation: {
                        type: "UseAlternative",
                        word: E,
                        checkEmpty: true
                    },
                    endIndex: b
                };
            }
            i++;
            let c = Nn(e, t, i), u = t.slice(i, c), f = -1, p = 0, d = 0;
            for(let g = 0; g < u.length; g++){
                let b = u[g];
                if (b === "(" || b === "[") p++;
                else if (b === ")" || b === "]") p--;
                else if (b === "?" && p === 0) d++;
                else if (b === ":" && p === 0) if (d > 0) d--;
                else {
                    f = g;
                    break;
                }
            }
            let m = f >= 0 ? u.slice(0, f) : u, h = f >= 0 ? u.slice(f + 1) : null;
            return {
                operation: {
                    type: "Substring",
                    offset: ba(e, m),
                    length: h !== null ? ba(e, h) : null
                },
                endIndex: c
            };
        }
        if ("-=?+".includes(o)) {
            i++;
            let l = Nn(e, t, i), c = t.slice(i, l), u = nn(e, c, false, false, true, false, s, false, false, true), f = j.word(u.length > 0 ? u : [
                j.literal("")
            ]);
            if (o === "-") return {
                operation: {
                    type: "DefaultValue",
                    word: f,
                    checkEmpty: false
                },
                endIndex: l
            };
            if (o === "=") return {
                operation: {
                    type: "AssignDefault",
                    word: f,
                    checkEmpty: false
                },
                endIndex: l
            };
            if (o === "?") return {
                operation: {
                    type: "ErrorIfUnset",
                    word: c ? f : null,
                    checkEmpty: false
                },
                endIndex: l
            };
            if (o === "+") return {
                operation: {
                    type: "UseAlternative",
                    word: f,
                    checkEmpty: false
                },
                endIndex: l
            };
        }
        if (o === "#" || o === "%") {
            let l = a === o, c = o === "#" ? "prefix" : "suffix";
            i += l ? 2 : 1;
            let u = Nn(e, t, i), f = t.slice(i, u), p = nn(e, f, false, false, false);
            return {
                operation: {
                    type: "PatternRemoval",
                    pattern: j.word(p.length > 0 ? p : [
                        j.literal("")
                    ]),
                    side: c,
                    greedy: l
                },
                endIndex: u
            };
        }
        if (o === "/") {
            let l = a === "/";
            i += l ? 2 : 1;
            let c = null;
            t[i] === "#" ? (c = "start", i++) : t[i] === "%" && (c = "end", i++);
            let u;
            c !== null && (t[i] === "/" || t[i] === "}") ? u = i : u = Rm(e, t, i);
            let f = t.slice(i, u), p = nn(e, f, false, false, false), d = j.word(p.length > 0 ? p : [
                j.literal("")
            ]), m = null, h = u;
            if (t[u] === "/") {
                let g = u + 1, b = Nn(e, t, g), y = t.slice(g, b), w = nn(e, y, false, false, false);
                m = j.word(w.length > 0 ? w : [
                    j.literal("")
                ]), h = b;
            }
            return {
                operation: {
                    type: "PatternReplacement",
                    pattern: d,
                    replacement: m,
                    all: l,
                    anchor: c
                },
                endIndex: h
            };
        }
        if (o === "^" || o === ",") {
            let l = a === o, c = o === "^" ? "upper" : "lower";
            i += l ? 2 : 1;
            let u = Nn(e, t, i), f = t.slice(i, u), p = f ? j.word([
                j.literal(f)
            ]) : null;
            return {
                operation: {
                    type: "CaseModification",
                    direction: c,
                    all: l,
                    pattern: p
                },
                endIndex: u
            };
        }
        return o === "@" && /[QPaAEKkuUL]/.test(a) ? {
            operation: {
                type: "Transform",
                operator: a
            },
            endIndex: i + 2
        } : {
            operation: null,
            endIndex: i
        };
    }
    function Ta(e, t, n, r = false) {
        let s = n + 1;
        if (s >= t.length) return {
            part: j.literal("$"),
            endIndex: s
        };
        let i = t[s];
        if (i === "(" && t[s + 1] === "(") return e.isDollarDparenSubshell(t, n) ? e.parseCommandSubstitution(t, n) : e.parseArithmeticExpansion(t, n);
        if (i === "[") {
            let o = 1, a = s + 1;
            for(; a < t.length && o > 0;)t[a] === "[" ? o++ : t[a] === "]" && o--, o > 0 && a++;
            if (o === 0) {
                let l = t.slice(s + 1, a), c = he(e, l);
                return {
                    part: j.arithmeticExpansion(c),
                    endIndex: a + 1
                };
            }
        }
        return i === "(" ? e.parseCommandSubstitution(t, n) : i === "{" ? RC(e, t, n, r) : /[a-zA-Z_0-9@*#?$!-]/.test(i) ? IC(e, t, n) : {
            part: j.literal("$"),
            endIndex: s
        };
    }
    function jm(e, t) {
        let n = [], r = 0, s = "", i = ()=>{
            s && (n.push(j.literal(s)), s = "");
        };
        for(; r < t.length;){
            let o = t[r];
            if (o === "\\" && r + 1 < t.length) {
                let a = t[r + 1];
                if (a === "$" || a === "`" || a === '"' || a === "\\") {
                    s += a, r += 2;
                    continue;
                }
                s += o, r++;
                continue;
            }
            if (o === "$") {
                i();
                let { part: a, endIndex: l } = Ta(e, t, r, true);
                a && n.push(a), r = l;
                continue;
            }
            if (o === "`") {
                i();
                let { part: a, endIndex: l } = e.parseBacktickSubstitution(t, r, true);
                n.push(a), r = l;
                continue;
            }
            s += o, r++;
        }
        return i(), n;
    }
    function PC(e, t, n) {
        let r = [], s = n, i = "", o = ()=>{
            i && (r.push(j.literal(i)), i = "");
        };
        for(; s < t.length && t[s] !== '"';){
            let a = t[s];
            if (a === "\\" && s + 1 < t.length) {
                let l = t[s + 1];
                if ('"\\$`\n'.includes(l)) {
                    i += l, s += 2;
                    continue;
                }
                i += a, s++;
                continue;
            }
            if (a === "$") {
                o();
                let { part: l, endIndex: c } = Ta(e, t, s, true);
                l && r.push(l), s = c;
                continue;
            }
            if (a === "`") {
                o();
                let { part: l, endIndex: c } = e.parseBacktickSubstitution(t, s, true);
                r.push(l), s = c;
                continue;
            }
            i += a, s++;
        }
        return o(), {
            part: j.doubleQuoted(r),
            endIndex: s
        };
    }
    function nn(e, t, n = false, r = false, s = false, i = false, o = false, a = false, l = false, c = false) {
        if (r) return [
            j.singleQuoted(t)
        ];
        if (n) {
            let m = jm(e, t);
            return [
                j.doubleQuoted(m)
            ];
        }
        if (t.length >= 2 && t[0] === '"' && t[t.length - 1] === '"') {
            let m = t.slice(1, -1), h = false;
            for(let g = 0; g < m.length; g++){
                if (m[g] === '"') {
                    h = true;
                    break;
                }
                m[g] === "\\" && g + 1 < m.length && g++;
            }
            if (!h) {
                let g = jm(e, m);
                return [
                    j.doubleQuoted(g)
                ];
            }
        }
        let u = [], f = 0, p = "", d = ()=>{
            p && (u.push(j.literal(p)), p = "");
        };
        for(; f < t.length;){
            let m = t[f];
            if (m === "\\" && f + 1 < t.length) {
                let h = t[f + 1];
                if (l) {
                    d(), u.push(j.escaped(h)), f += 2;
                    continue;
                }
                let g = i ? h === "$" || h === "`" || h === `
` : h === "$" || h === "`" || h === '"' || h === "'" || h === `
` || c && h === "}", b = o ? "*?[]\\".includes(h) : "*?[]\\(){}.^+".includes(h);
                g ? p += h : b ? (d(), u.push(j.escaped(h))) : p += `\\${h}`, f += 2;
                continue;
            }
            if (m === "'" && !o && !i) {
                d();
                let h = t.indexOf("'", f + 1);
                if (h === -1) {
                    p += t.slice(f);
                    break;
                }
                u.push(j.singleQuoted(t.slice(f + 1, h))), f = h + 1;
                continue;
            }
            if (m === '"' && !i) {
                d();
                let { part: h, endIndex: g } = PC(e, t, f + 1);
                u.push(h), f = g + 1;
                continue;
            }
            if (m === "$" && t[f + 1] === "'") {
                d();
                let { part: h, endIndex: g } = Tm(e, t, f + 2);
                u.push(h), f = g;
                continue;
            }
            if (m === "$") {
                d();
                let { part: h, endIndex: g } = Ta(e, t, f);
                h && u.push(h), f = g;
                continue;
            }
            if (m === "`") {
                d();
                let { part: h, endIndex: g } = e.parseBacktickSubstitution(t, f);
                u.push(h), f = g;
                continue;
            }
            if (m === "~") {
                let h = f > 0 ? t[f - 1] : "";
                if (f === 0 || h === "=" || s && h === ":") {
                    let b = Im(e, t, f), y = t[b];
                    if (y === void 0 || y === "/" || y === ":") {
                        d();
                        let w = t.slice(f + 1, b) || null;
                        u.push({
                            type: "TildeExpansion",
                            user: w
                        }), f = b;
                        continue;
                    }
                }
            }
            if ("@*+?!".includes(m) && f + 1 < t.length && t[f + 1] === "(") {
                let h = $C(t, f + 1);
                if (h !== -1) {
                    d();
                    let g = t.slice(f, h + 1);
                    u.push({
                        type: "Glob",
                        pattern: g
                    }), f = h + 1;
                    continue;
                }
            }
            if (m === "*" || m === "?" || m === "[") {
                d();
                let { pattern: h, endIndex: g } = Pm(e, t, f);
                u.push({
                    type: "Glob",
                    pattern: h
                }), f = g;
                continue;
            }
            if (m === "{" && !s && !a) {
                let h = Om(e, t, f, nn);
                if (h) {
                    d(), u.push(h.part), f = h.endIndex;
                    continue;
                }
            }
            p += m, f++;
        }
        return d(), u;
    }
    var Hm = v(()=>{
        Cn();
        Je();
        An();
        xa();
    });
    function Vm(e, t) {
        let n = e.length, r = t + 3, s = 2, i = false, o = false;
        for(; r < n && s > 0;){
            let a = e[r];
            if (i) {
                a === "'" && (i = false), r++;
                continue;
            }
            if (o) {
                if (a === "\\") {
                    r += 2;
                    continue;
                }
                a === '"' && (o = false), r++;
                continue;
            }
            if (a === "'") {
                i = true, r++;
                continue;
            }
            if (a === '"') {
                o = true, r++;
                continue;
            }
            if (a === "\\") {
                r += 2;
                continue;
            }
            if (a === "(") {
                s++, r++;
                continue;
            }
            if (a === ")") {
                if (s--, s === 1) {
                    let l = r + 1;
                    return !(l < n && e[l] === ")");
                }
                if (s === 0) return false;
                r++;
                continue;
            }
            if (s === 1 && (a === "|" && r + 1 < n && e[r + 1] === "|" || a === "&" && r + 1 < n && e[r + 1] === "&" || a === "|" && r + 1 < n && e[r + 1] !== "|")) return true;
            r++;
        }
        return false;
    }
    function qm(e, t, n, r) {
        let s = t + 2, i = 1, o = s, a = false, l = false, c = 0, u = false, f = "";
        for(; o < e.length && i > 0;){
            let h = e[o];
            a ? h === "'" && (a = false) : l ? h === "\\" && o + 1 < e.length ? o++ : h === '"' && (l = false) : h === "'" ? (a = true, f = "") : h === '"' ? (l = true, f = "") : h === "\\" && o + 1 < e.length ? (o++, f = "") : /[a-zA-Z_]/.test(h) ? f += h : (f === "case" ? (c++, u = false) : f === "in" && c > 0 ? u = true : f === "esac" && c > 0 && (c--, u = false), f = "", h === "(" ? o > 0 && e[o - 1] === "$" ? i++ : u || i++ : h === ")" ? u ? u = false : i-- : h === ";" && c > 0 && o + 1 < e.length && e[o + 1] === ";" && (u = true)), i > 0 && o++;
        }
        i > 0 && r("unexpected EOF while looking for matching `)'");
        let p = e.slice(s, o), m = n().parse(p);
        return {
            part: j.commandSubstitution(m, false),
            endIndex: o + 1
        };
    }
    function Gm(e, t, n, r, s) {
        let o = t + 1, a = "";
        for(; o < e.length && e[o] !== "`";)if (e[o] === "\\") {
            let u = e[o + 1];
            u === "$" || u === "`" || u === "\\" || u === `
` || n && u === '"' ? (u !== `
` && (a += u), o += 2) : (a += e[o], o++);
        } else a += e[o], o++;
        o >= e.length && s("unexpected EOF while looking for matching ``'");
        let c = r().parse(a);
        return {
            part: j.commandSubstitution(c, true),
            endIndex: o + 1
        };
    }
    var Zm = v(()=>{
        Cn();
    });
    function Bt(e) {
        return new se().parse(e);
    }
    var se, Fe = v(()=>{
        Cn();
        Je();
        Lm();
        Mm();
        zm();
        Hm();
        tn();
        Zm();
        An();
        An();
        se = class e {
            tokens = [];
            pos = 0;
            pendingHeredocs = [];
            parseIterations = 0;
            _input = "";
            getInput() {
                return this._input;
            }
            checkIterationLimit() {
                if (this.parseIterations++, this.parseIterations > um) throw new Ge("Maximum parse iterations exceeded (possible infinite loop)", this.current().line, this.current().column);
            }
            parse(t) {
                if (t.length > da) throw new Ge(`Input too large: ${t.length} bytes exceeds limit of ${da}`, 1, 1);
                this._input = t;
                let n = new Zs(t);
                if (this.tokens = n.tokenize(), this.tokens.length > ha) throw new Ge(`Too many tokens: ${this.tokens.length} exceeds limit of ${ha}`, 1, 1);
                return this.pos = 0, this.pendingHeredocs = [], this.parseIterations = 0, this.parseScript();
            }
            parseTokens(t) {
                return this.tokens = t, this.pos = 0, this.pendingHeredocs = [], this.parseScript();
            }
            current() {
                return this.tokens[this.pos] || this.tokens[this.tokens.length - 1];
            }
            peek(t = 0) {
                return this.tokens[this.pos + t] || this.tokens[this.tokens.length - 1];
            }
            advance() {
                let t = this.current();
                return this.pos < this.tokens.length - 1 && this.pos++, t;
            }
            getPos() {
                return this.pos;
            }
            check(t, n, r, s, ...i) {
                let o = this.tokens[this.pos]?.type;
                return o === t || n !== void 0 && o === n || r !== void 0 && o === r || s !== void 0 && o === s ? true : i.length > 0 ? i.includes(o) : false;
            }
            expect(t, n) {
                if (this.check(t)) return this.advance();
                let r = this.current();
                throw new Ge(n || `Expected ${t}, got ${r.type}`, r.line, r.column, r);
            }
            error(t) {
                let n = this.current();
                throw new Ge(t, n.line, n.column, n);
            }
            skipNewlines() {
                for(; this.check(x.NEWLINE, x.COMMENT);)this.check(x.NEWLINE) ? (this.advance(), this.processHeredocs()) : this.advance();
            }
            skipSeparators(t = true) {
                for(;;){
                    if (this.check(x.NEWLINE)) {
                        this.advance(), this.processHeredocs();
                        continue;
                    }
                    if (this.check(x.SEMICOLON, x.COMMENT)) {
                        this.advance();
                        continue;
                    }
                    if (t && this.check(x.DSEMI, x.SEMI_AND, x.SEMI_SEMI_AND)) {
                        this.advance();
                        continue;
                    }
                    break;
                }
            }
            addPendingHeredoc(t, n, r, s) {
                this.pendingHeredocs.push({
                    redirect: t,
                    delimiter: n,
                    stripTabs: r,
                    quoted: s
                });
            }
            processHeredocs() {
                for (let t of this.pendingHeredocs)if (this.check(x.HEREDOC_CONTENT)) {
                    let n = this.advance(), r;
                    t.quoted ? r = j.word([
                        j.literal(n.value)
                    ]) : r = this.parseWordFromString(n.value, false, false, false, true), t.redirect.target = j.hereDoc(t.delimiter, r, t.stripTabs, t.quoted);
                }
                this.pendingHeredocs = [];
            }
            isStatementEnd() {
                return this.check(x.EOF, x.NEWLINE, x.SEMICOLON, x.AMP, x.AND_AND, x.OR_OR, x.RPAREN, x.RBRACE, x.DSEMI, x.SEMI_AND, x.SEMI_SEMI_AND);
            }
            isCommandStart() {
                let t = this.current().type;
                return t === x.WORD || t === x.NAME || t === x.NUMBER || t === x.ASSIGNMENT_WORD || t === x.IF || t === x.FOR || t === x.WHILE || t === x.UNTIL || t === x.CASE || t === x.LPAREN || t === x.LBRACE || t === x.DPAREN_START || t === x.DBRACK_START || t === x.FUNCTION || t === x.BANG || t === x.TIME || t === x.IN || t === x.LESS || t === x.GREAT || t === x.DLESS || t === x.DGREAT || t === x.LESSAND || t === x.GREATAND || t === x.LESSGREAT || t === x.DLESSDASH || t === x.CLOBBER || t === x.TLESS || t === x.AND_GREAT || t === x.AND_DGREAT;
            }
            parseScript() {
                let t = [], r = 0;
                for(this.skipNewlines(); !this.check(x.EOF);){
                    r++, r > 1e4 && this.error("Parser stuck: too many iterations (>10000)");
                    let s = this.checkUnexpectedToken();
                    if (s) {
                        t.push(s), this.skipSeparators(false);
                        continue;
                    }
                    let i = this.pos, o = this.parseStatement();
                    o && t.push(o), this.skipSeparators(false), this.check(x.DSEMI, x.SEMI_AND, x.SEMI_SEMI_AND) && this.error(`syntax error near unexpected token \`${this.current().value}'`), this.pos === i && !this.check(x.EOF) && this.advance();
                }
                return j.script(t);
            }
            checkUnexpectedToken() {
                let t = this.current().type, n = this.current().value;
                if ((t === x.DO || t === x.DONE || t === x.THEN || t === x.ELSE || t === x.ELIF || t === x.FI || t === x.ESAC) && this.error(`syntax error near unexpected token \`${n}'`), t === x.RBRACE || t === x.RPAREN) {
                    let r = `syntax error near unexpected token \`${n}'`;
                    return this.advance(), j.statement([
                        j.pipeline([
                            j.simpleCommand(null, [], [], [])
                        ])
                    ], [], false, {
                        message: r,
                        token: n
                    });
                }
                return (t === x.DSEMI || t === x.SEMI_AND || t === x.SEMI_SEMI_AND) && this.error(`syntax error near unexpected token \`${n}'`), t === x.SEMICOLON && this.error(`syntax error near unexpected token \`${n}'`), (t === x.PIPE || t === x.PIPE_AMP) && this.error(`syntax error near unexpected token \`${n}'`), null;
            }
            parseStatement() {
                if (this.skipNewlines(), !this.isCommandStart()) return null;
                let t = this.current().start, n = [], r = [], s = false, i = this.parsePipeline();
                for(n.push(i); this.check(x.AND_AND, x.OR_OR);){
                    let l = this.advance();
                    r.push(l.type === x.AND_AND ? "&&" : "||"), this.skipNewlines();
                    let c = this.parsePipeline();
                    n.push(c);
                }
                this.check(x.AMP) && (this.advance(), s = true);
                let o = this.pos > 0 ? this.tokens[this.pos - 1].end : t, a = this._input.slice(t, o);
                return j.statement(n, r, s, void 0, a);
            }
            parsePipeline() {
                let t = false, n = false;
                this.check(x.TIME) && (this.advance(), t = true, this.check(x.WORD, x.NAME) && this.current().value === "-p" && (this.advance(), n = true));
                let r = 0;
                for(; this.check(x.BANG);)this.advance(), r++;
                let s = r % 2 === 1, i = [], o = [], a = this.parseCommand();
                for(i.push(a); this.check(x.PIPE, x.PIPE_AMP);){
                    let l = this.advance();
                    this.skipNewlines(), o.push(l.type === x.PIPE_AMP);
                    let c = this.parseCommand();
                    i.push(c);
                }
                return j.pipeline(i, s, t, n, o.length > 0 ? o : void 0);
            }
            parseCommand() {
                return this.check(x.IF) ? Sa(this) : this.check(x.FOR) ? Aa(this) : this.check(x.WHILE) ? Ca(this) : this.check(x.UNTIL) ? Na(this) : this.check(x.CASE) ? ka(this) : this.check(x.LPAREN) ? va(this) : this.check(x.LBRACE) ? $a(this) : this.check(x.DPAREN_START) ? this.dparenClosesWithSpacedParens() ? this.parseNestedSubshellsFromDparen() : this.parseArithmeticCommand() : this.check(x.DBRACK_START) ? this.parseConditionalCommand() : this.check(x.FUNCTION) ? this.parseFunctionDef() : this.check(x.NAME, x.WORD) && this.peek(1).type === x.LPAREN && this.peek(2).type === x.RPAREN ? this.parseFunctionDef() : _m(this);
            }
            dparenClosesWithSpacedParens() {
                let t = 1, n = 1;
                for(; n < this.tokens.length - this.pos;){
                    let r = this.peek(n);
                    if (r.type === x.EOF) return false;
                    if (r.type === x.DPAREN_START || r.type === x.LPAREN) t++;
                    else if (r.type === x.DPAREN_END) {
                        if (t -= 2, t <= 0) return false;
                    } else if (r.type === x.RPAREN && (t--, t === 0 && this.peek(n + 1).type === x.RPAREN)) return true;
                    n++;
                }
                return false;
            }
            parseNestedSubshellsFromDparen() {
                this.advance();
                let t = this.parseCompoundList();
                this.expect(x.RPAREN), this.expect(x.RPAREN);
                let n = this.parseOptionalRedirections(), r = j.subshell(t, []);
                return j.subshell([
                    j.statement([
                        j.pipeline([
                            r
                        ], false, false, false)
                    ])
                ], n);
            }
            isWord() {
                let t = this.current().type;
                return t === x.WORD || t === x.NAME || t === x.NUMBER || t === x.IF || t === x.FOR || t === x.WHILE || t === x.UNTIL || t === x.CASE || t === x.FUNCTION || t === x.ELSE || t === x.ELIF || t === x.FI || t === x.THEN || t === x.DO || t === x.DONE || t === x.ESAC || t === x.IN || t === x.SELECT || t === x.TIME || t === x.COPROC || t === x.BANG;
            }
            parseWord() {
                let t = this.advance();
                return this.parseWordFromString(t.value, t.quoted, t.singleQuoted);
            }
            parseWordNoBraceExpansion() {
                let t = this.advance();
                return this.parseWordFromString(t.value, t.quoted, t.singleQuoted, false, false, true);
            }
            parseWordForRegex() {
                let t = this.advance();
                return this.parseWordFromString(t.value, t.quoted, t.singleQuoted, false, false, true, true);
            }
            parseWordFromString(t, n = false, r = false, s = false, i = false, o = false, a = false) {
                let l = nn(this, t, n, r, s, i, false, o, a);
                return j.word(l);
            }
            parseCommandSubstitution(t, n) {
                return qm(t, n, ()=>new e(), (r)=>this.error(r));
            }
            parseBacktickSubstitution(t, n, r = false) {
                return Gm(t, n, r, ()=>new e(), (s)=>this.error(s));
            }
            isDollarDparenSubshell(t, n) {
                return Vm(t, n);
            }
            parseArithmeticExpansion(t, n) {
                let r = n + 3, s = 1, i = 0, o = r;
                for(; o < t.length - 1 && s > 0;)t[o] === "$" && t[o + 1] === "(" ? t[o + 2] === "(" ? (s++, o += 3) : (i++, o += 2) : t[o] === "(" && t[o + 1] === "(" ? (s++, o += 2) : t[o] === ")" && t[o + 1] === ")" ? i > 0 ? (i--, o++) : (s--, s > 0 && (o += 2)) : t[o] === "(" ? (i++, o++) : (t[o] === ")" && i > 0 && i--, o++);
                let a = t.slice(r, o), l = this.parseArithmeticExpression(a);
                return {
                    part: j.arithmeticExpansion(l),
                    endIndex: o + 2
                };
            }
            parseArithmeticCommand() {
                let t = this.expect(x.DPAREN_START), n = "", r = 1, s = 0, i = false, o = false;
                for(; r > 0 && !this.check(x.EOF);){
                    if (i) {
                        if (i = false, s > 0) {
                            s--, n += ")";
                            continue;
                        }
                        if (this.check(x.RPAREN)) {
                            r--, o = true, this.advance();
                            continue;
                        }
                        if (this.check(x.DPAREN_END)) {
                            r--, o = true;
                            continue;
                        }
                        n += ")";
                        continue;
                    }
                    if (this.check(x.DPAREN_START)) r++, n += "((", this.advance();
                    else if (this.check(x.DPAREN_END)) s >= 2 ? (s -= 2, n += "))", this.advance()) : s === 1 ? (s--, n += ")", i = true, this.advance()) : (r--, o = true, r > 0 && (n += "))"), this.advance());
                    else if (this.check(x.LPAREN)) s++, n += "(", this.advance();
                    else if (this.check(x.RPAREN)) s > 0 && s--, n += ")", this.advance();
                    else {
                        let c = this.current().value, u = n.length > 0 ? n[n.length - 1] : "";
                        n.length > 0 && !n.endsWith(" ") && !(c === "=" && /[|&^+\-*/%<>]$/.test(n)) && !(c === "<" && u === "<") && !(c === ">" && u === ">") && (n += " "), n += c, this.advance();
                    }
                }
                o || this.expect(x.DPAREN_END);
                let a = this.parseArithmeticExpression(n.trim()), l = this.parseOptionalRedirections();
                return j.arithmeticCommand(a, l, t.line);
            }
            parseConditionalCommand() {
                let t = this.expect(x.DBRACK_START), n = Ra(this);
                this.expect(x.DBRACK_END);
                let r = this.parseOptionalRedirections();
                return j.conditionalCommand(n, r, t.line);
            }
            parseFunctionDef() {
                let t;
                if (this.check(x.FUNCTION)) {
                    if (this.advance(), this.check(x.NAME) || this.check(x.WORD)) t = this.advance().value;
                    else {
                        let s = this.current();
                        throw new Ge("Expected function name", s.line, s.column, s);
                    }
                    this.check(x.LPAREN) && (this.advance(), this.expect(x.RPAREN));
                } else t = this.advance().value, t.includes("$") && this.error(`\`${t}': not a valid identifier`), this.expect(x.LPAREN), this.expect(x.RPAREN);
                this.skipNewlines();
                let n = this.parseCompoundCommandBody({
                    forFunctionBody: true
                }), r = this.parseOptionalRedirections();
                return j.functionDef(t, n, r);
            }
            parseCompoundCommandBody(t) {
                let n = t?.forFunctionBody;
                if (this.check(x.LBRACE)) return $a(this, {
                    skipRedirections: n
                });
                if (this.check(x.LPAREN)) return va(this, {
                    skipRedirections: n
                });
                if (this.check(x.IF)) return Sa(this, {
                    skipRedirections: n
                });
                if (this.check(x.FOR)) return Aa(this, {
                    skipRedirections: n
                });
                if (this.check(x.WHILE)) return Ca(this, {
                    skipRedirections: n
                });
                if (this.check(x.UNTIL)) return Na(this, {
                    skipRedirections: n
                });
                if (this.check(x.CASE)) return ka(this, {
                    skipRedirections: n
                });
                this.error("Expected compound command for function body");
            }
            parseCompoundList() {
                let t = [];
                for(this.skipNewlines(); !this.check(x.EOF, x.FI, x.ELSE, x.ELIF, x.THEN, x.DO, x.DONE, x.ESAC, x.RPAREN, x.RBRACE, x.DSEMI, x.SEMI_AND, x.SEMI_SEMI_AND) && this.isCommandStart();){
                    this.checkIterationLimit();
                    let n = this.pos, r = this.parseStatement();
                    if (r && t.push(r), this.skipSeparators(), this.pos === n && !r) break;
                }
                return t;
            }
            parseOptionalRedirections() {
                let t = [];
                for(; Xs(this);){
                    this.checkIterationLimit();
                    let n = this.pos;
                    if (t.push(Js(this)), this.pos === n) break;
                }
                return t;
            }
            parseArithmeticExpression(t) {
                return he(this, t);
            }
        };
    });
    function Da(e) {
        return DC[e] || "";
    }
    function eg(e) {
        let t = [], n = "", r = 0;
        for(; r < e.length;){
            let s = e[r];
            if (s === "[") {
                for(n += s, r++, r < e.length && (e[r] === "!" || e[r] === "^") && (n += e[r], r++), r < e.length && e[r] === "]" && (n += e[r], r++); r < e.length && e[r] !== "]";){
                    if (e[r] === "[" && r + 1 < e.length && e[r + 1] === ":") {
                        let i = e.indexOf(":]", r + 2);
                        if (i !== -1) {
                            n += e.slice(r, i + 2), r = i + 2;
                            continue;
                        }
                    }
                    if (e[r] === "\\" && r + 1 < e.length) {
                        n += e[r] + e[r + 1], r += 2;
                        continue;
                    }
                    n += e[r], r++;
                }
                r < e.length && e[r] === "]" && (n += e[r], r++);
            } else s === ":" ? (n !== "" && t.push(n), n = "", r++) : s === "\\" && r + 1 < e.length ? (n += s + e[r + 1], r += 2) : (n += s, r++);
        }
        return n !== "" && t.push(n), t;
    }
    function tg(e) {
        let t = "^";
        for(let n = 0; n < e.length; n++){
            let r = e[n];
            if (r === "*") t += "[^/]*";
            else if (r === "?") t += "[^/]";
            else if (r === "[") {
                let s = n + 1, i = "[";
                s < e.length && (e[s] === "^" || e[s] === "!") && (i += "^", s++), s < e.length && e[s] === "]" && (i += "\\]", s++);
                let o = s;
                for(; o < e.length;){
                    if (e[o] === "\\" && o + 1 < e.length) {
                        o += 2;
                        continue;
                    }
                    if (e[o] === "[" && o + 1 < e.length && e[o + 1] === ":") {
                        let l = e.indexOf(":]", o + 2);
                        if (l !== -1) {
                            o = l + 2;
                            continue;
                        }
                    }
                    if (e[o] === "]") break;
                    o++;
                }
                let a = s;
                for(; s < e.length && e[s] !== "]";){
                    if (e[s] === "[" && s + 1 < e.length && e[s + 1] === ":") {
                        let l = e.indexOf(":]", s + 2);
                        if (l !== -1) {
                            let c = e.slice(s + 2, l), u = Da(c);
                            i += u, s = l + 2;
                            continue;
                        }
                    }
                    if (e[s] === "\\" && s + 1 < e.length) {
                        i += `\\${e[s + 1]}`, s += 2;
                        continue;
                    }
                    if (e[s] === "-") {
                        let l = s === a, c = s + 1 === o;
                        l || c ? i += "\\-" : i += "-";
                    } else i += e[s];
                    s++;
                }
                i += "]", t += i, n = s;
            } else if (r === "\\" && n + 1 < e.length) {
                let s = e[n + 1];
                /[.+^${}()|\\*?[\]]/.test(s) ? t += `\\${s}` : t += s, n++;
            } else /[.+^${}()|]/.test(r) ? t += `\\${r}` : t += r;
        }
        return t += "$", new RegExp(t);
    }
    function Fa(e, t) {
        let n = 1, r = t + 1;
        for(; r < e.length && n > 0;){
            let s = e[r];
            if (s === "\\") {
                r += 2;
                continue;
            }
            if (s === "(") n++;
            else if (s === ")" && (n--, n === 0)) return r;
            r++;
        }
        return -1;
    }
    function _a(e) {
        let t = [], n = "", r = 0, s = false, i = 0;
        for(; i < e.length;){
            let o = e[i];
            if (o === "'" && !s) {
                s = true, n += "\0QUOTE_START\0", i++;
                continue;
            }
            if (o === "'" && s) {
                s = false, n += "\0QUOTE_END\0", i++;
                continue;
            }
            if (s) {
                n += o, i++;
                continue;
            }
            if (o === "\\") {
                n += o, i + 1 < e.length ? (n += e[i + 1], i += 2) : i++;
                continue;
            }
            o === "(" ? (r++, n += o) : o === ")" ? (r--, n += o) : o === "|" && r === 0 ? (t.push(n), n = "") : n += o, i++;
        }
        return t.push(n), t;
    }
    var DC, ng = v(()=>{
        DC = {
            alnum: "a-zA-Z0-9",
            alpha: "a-zA-Z",
            ascii: "\\x00-\\x7F",
            blank: " \\t",
            cntrl: "\\x00-\\x1F\\x7F",
            digit: "0-9",
            graph: "!-~",
            lower: "a-z",
            print: " -~",
            punct: "!-/:-@\\[-`{-~",
            space: " \\t\\n\\r\\f\\v",
            upper: "A-Z",
            word: "a-zA-Z0-9_",
            xdigit: "0-9a-fA-F"
        };
    });
    var rn, Ys = v(()=>{
        Pn();
        ng();
        rn = class {
            fs;
            cwd;
            globignorePatterns = [];
            hasGlobignore = false;
            globstar = false;
            nullglob = false;
            failglob = false;
            dotglob = false;
            extglob = false;
            globskipdots = true;
            constructor(t, n, r, s){
                this.fs = t, this.cwd = n, typeof s == "boolean" ? this.globstar = s : s && (this.globstar = s.globstar ?? false, this.nullglob = s.nullglob ?? false, this.failglob = s.failglob ?? false, this.dotglob = s.dotglob ?? false, this.extglob = s.extglob ?? false, this.globskipdots = s.globskipdots ?? true);
                let i = r?.GLOBIGNORE;
                i !== void 0 && i !== "" && (this.hasGlobignore = true, this.globignorePatterns = eg(i));
            }
            hasNullglob() {
                return this.nullglob;
            }
            hasFailglob() {
                return this.failglob;
            }
            filterGlobignore(t) {
                return !this.hasGlobignore && !this.globskipdots ? t : t.filter((n)=>{
                    let r = n.split("/").pop() || n;
                    if ((this.hasGlobignore || this.globskipdots) && (r === "." || r === "..")) return false;
                    if (this.hasGlobignore) {
                        for (let s of this.globignorePatterns)if (this.matchGlobignorePattern(n, s)) return false;
                    }
                    return true;
                });
            }
            matchGlobignorePattern(t, n) {
                return tg(n).test(t);
            }
            isGlobPattern(t) {
                return !!(t.includes("*") || t.includes("?") || /\[.*\]/.test(t) || this.extglob && /[@*+?!]\(/.test(t));
            }
            async expandArgs(t, n) {
                let r = t.map((o, a)=>(n?.[a] ?? false) || !this.isGlobPattern(o) ? null : this.expand(o)), s = await Promise.all(r.map((o)=>o || Promise.resolve(null))), i = [];
                for(let o = 0; o < t.length; o++){
                    let a = s[o];
                    a === null ? i.push(t[o]) : a.length > 0 ? i.push(...a) : i.push(t[o]);
                }
                return i;
            }
            async expand(t) {
                let n;
                if (t.includes("**") && this.globstar && this.isGlobstarValid(t)) n = await this.expandRecursive(t);
                else {
                    let r = t.replace(/\*\*+/g, "*");
                    n = await this.expandSimple(r);
                }
                return this.filterGlobignore(n);
            }
            isGlobstarValid(t) {
                let n = t.split("/");
                for (let r of n)if (r.includes("**") && r !== "**") return false;
                return true;
            }
            hasGlobChars(t) {
                return !!(t.includes("*") || t.includes("?") || /\[.*\]/.test(t) || this.extglob && /[@*+?!]\(/.test(t));
            }
            async expandSimple(t) {
                let n = t.startsWith("/"), r = t.split("/").filter((c)=>c !== ""), s = -1;
                for(let c = 0; c < r.length; c++)if (this.hasGlobChars(r[c])) {
                    s = c;
                    break;
                }
                if (s === -1) return [
                    t
                ];
                let i, o;
                if (s === 0) n ? (i = "/", o = "/") : (i = this.cwd, o = "");
                else {
                    let c = r.slice(0, s);
                    n ? (i = `/${c.join("/")}`, o = `/${c.join("/")}`) : (i = this.fs.resolvePath(this.cwd, c.join("/")), o = c.join("/"));
                }
                let a = r.slice(s);
                return (await this.expandSegments(i, o, a)).sort();
            }
            async expandSegments(t, n, r) {
                if (r.length === 0) return [
                    n
                ];
                let [s, ...i] = r, o = [];
                try {
                    if (this.fs.readdirWithFileTypes) {
                        let a = await this.fs.readdirWithFileTypes(t), l = [], c = [
                            ...a
                        ], u = this.dotglob || this.hasGlobignore;
                        if (s.startsWith(".") || this.dotglob) {
                            let p = a.some((m)=>m.name === "."), d = a.some((m)=>m.name === "..");
                            p || c.push({
                                name: ".",
                                isFile: false,
                                isDirectory: true,
                                isSymbolicLink: false
                            }), d || c.push({
                                name: "..",
                                isFile: false,
                                isDirectory: true,
                                isSymbolicLink: false
                            });
                        }
                        for (let p of c)if (!(p.name.startsWith(".") && !s.startsWith(".") && !u) && this.matchPattern(p.name, s)) {
                            let d = t === "/" ? `/${p.name}` : `${t}/${p.name}`, m;
                            n === "" ? m = p.name : n === "/" ? m = `/${p.name}` : m = `${n}/${p.name}`, i.length === 0 ? l.push(Promise.resolve([
                                m
                            ])) : p.isDirectory && l.push(this.expandSegments(d, m, i));
                        }
                        let f = await Promise.all(l);
                        for (let p of f)o.push(...p);
                    } else {
                        let a = await this.fs.readdir(t), l = [], c = [
                            ...a
                        ], u = this.dotglob || this.hasGlobignore;
                        (s.startsWith(".") || this.dotglob) && (a.includes(".") || c.push("."), a.includes("..") || c.push(".."));
                        for (let p of c)if (!(p.startsWith(".") && !s.startsWith(".") && !u) && this.matchPattern(p, s)) {
                            let d = t === "/" ? `/${p}` : `${t}/${p}`, m;
                            n === "" ? m = p : n === "/" ? m = `/${p}` : m = `${n}/${p}`, i.length === 0 ? l.push(Promise.resolve([
                                m
                            ])) : l.push((async ()=>{
                                try {
                                    if ((await this.fs.stat(d)).isDirectory) return this.expandSegments(d, m, i);
                                } catch  {}
                                return [];
                            })());
                        }
                        let f = await Promise.all(l);
                        for (let p of f)o.push(...p);
                    }
                } catch  {}
                return o;
            }
            async expandRecursive(t) {
                let n = [], r = t.indexOf("**"), s = t.slice(0, r).replace(/\/$/, "") || ".", o = t.slice(r + 2).replace(/^\//, "");
                return o.includes("**") && this.isGlobstarValid(o) ? (await this.walkDirectoryMultiGlobstar(s, o, n), [
                    ...new Set(n)
                ].sort()) : (await this.walkDirectory(s, o, n), n.sort());
            }
            async walkDirectoryMultiGlobstar(t, n, r) {
                let s = this.fs.resolvePath(this.cwd, t);
                try {
                    let i = this.fs.readdirWithFileTypes ? await this.fs.readdirWithFileTypes(s) : null;
                    if (i) {
                        let o = [];
                        for (let c of i){
                            let u = t === "." ? c.name : `${t}/${c.name}`;
                            c.isDirectory && o.push(u);
                        }
                        let a = t === "." ? n : `${t}/${n}`, l = await this.expandRecursive(a);
                        r.push(...l);
                        for(let c = 0; c < o.length; c += 100){
                            let u = o.slice(c, c + 100);
                            await Promise.all(u.map((f)=>this.walkDirectoryMultiGlobstar(f, n, r)));
                        }
                    } else {
                        let o = await this.fs.readdir(s), a = [];
                        for (let u of o){
                            let f = t === "." ? u : `${t}/${u}`, p = this.fs.resolvePath(this.cwd, f);
                            try {
                                (await this.fs.stat(p)).isDirectory && a.push(f);
                            } catch  {}
                        }
                        let l = t === "." ? n : `${t}/${n}`, c = await this.expandRecursive(l);
                        r.push(...c);
                        for(let u = 0; u < a.length; u += 100){
                            let f = a.slice(u, u + 100);
                            await Promise.all(f.map((p)=>this.walkDirectoryMultiGlobstar(p, n, r)));
                        }
                    }
                } catch  {}
            }
            async walkDirectory(t, n, r) {
                let s = this.fs.resolvePath(this.cwd, t);
                try {
                    if (this.fs.readdirWithFileTypes) {
                        let i = await this.fs.readdirWithFileTypes(s), o = [], a = [];
                        for (let l of i){
                            let c = t === "." ? l.name : `${t}/${l.name}`;
                            l.isDirectory ? a.push(c) : n && this.matchPattern(l.name, n) && o.push(c);
                        }
                        r.push(...o);
                        for(let l = 0; l < a.length; l += 100){
                            let c = a.slice(l, l + 100);
                            await Promise.all(c.map((u)=>this.walkDirectory(u, n, r)));
                        }
                    } else {
                        let i = await this.fs.readdir(s), o = [];
                        for(let l = 0; l < i.length; l += 100){
                            let c = i.slice(l, l + 100), u = await Promise.all(c.map(async (f)=>{
                                let p = t === "." ? f : `${t}/${f}`, d = this.fs.resolvePath(this.cwd, p);
                                try {
                                    let m = await this.fs.stat(d);
                                    return {
                                        name: f,
                                        path: p,
                                        isDirectory: m.isDirectory
                                    };
                                } catch  {
                                    return null;
                                }
                            }));
                            o.push(...u.filter((f)=>f !== null));
                        }
                        for (let l of o)!l.isDirectory && n && this.matchPattern(l.name, n) && r.push(l.path);
                        let a = o.filter((l)=>l.isDirectory);
                        for(let l = 0; l < a.length; l += 100){
                            let c = a.slice(l, l + 100);
                            await Promise.all(c.map((u)=>this.walkDirectory(u.path, n, r)));
                        }
                    }
                } catch  {}
            }
            matchPattern(t, n) {
                return this.patternToRegex(n).test(t);
            }
            patternToRegex(t) {
                let n = this.patternToRegexStr(t);
                return new RegExp(`^${n}$`);
            }
            patternToRegexStr(t) {
                let n = "", r = false;
                for(let s = 0; s < t.length; s++){
                    if (t.slice(s, s + 13) === "\0QUOTE_START\0") {
                        r = true, s += 12;
                        continue;
                    }
                    if (t.slice(s, s + 11) === "\0QUOTE_END\0") {
                        r = false, s += 10;
                        continue;
                    }
                    let i = t[s];
                    if (r) {
                        /[.+^${}()|\\*?[\]]/.test(i) ? n += `\\${i}` : n += i;
                        continue;
                    }
                    if (this.extglob && (i === "@" || i === "*" || i === "+" || i === "?" || i === "!") && s + 1 < t.length && t[s + 1] === "(") {
                        let o = Fa(t, s + 1);
                        if (o !== -1) {
                            let a = t.slice(s + 2, o), l = _a(a), c = l.map((f)=>this.patternToRegexStr(f)), u = c.length > 0 ? c.join("|") : "(?:)";
                            if (i === "@") n += `(?:${u})`;
                            else if (i === "*") n += `(?:${u})*`;
                            else if (i === "+") n += `(?:${u})+`;
                            else if (i === "?") n += `(?:${u})?`;
                            else if (i === "!") if (o < t.length - 1) {
                                let p = l.map((m)=>this.computePatternLength(m));
                                if (p.every((m)=>m !== null) && p.every((m)=>m === p[0]) && p[0] !== null) {
                                    let m = p[0];
                                    if (m === 0) n += "(?:.+)";
                                    else {
                                        let h = [];
                                        m > 0 && h.push(`.{0,${m - 1}}`), h.push(`.{${m + 1},}`), h.push(`(?!(?:${u})).{${m}}`), n += `(?:${h.join("|")})`;
                                    }
                                } else n += `(?:(?!(?:${u})).)*?`;
                            } else n += `(?!(?:${u})$).*`;
                            s = o;
                            continue;
                        }
                    }
                    if (i === "*") n += ".*";
                    else if (i === "?") n += ".";
                    else if (i === "[") {
                        let o = s + 1, a = "[";
                        o < t.length && (t[o] === "^" || t[o] === "!") && (a += "^", o++), o < t.length && t[o] === "]" && (a += "\\]", o++);
                        let l = o;
                        for(; l < t.length;){
                            if (t[l] === "\\" && l + 1 < t.length) {
                                l += 2;
                                continue;
                            }
                            if (t[l] === "[" && l + 1 < t.length && t[l + 1] === ":") {
                                let u = t.indexOf(":]", l + 2);
                                if (u !== -1) {
                                    l = u + 2;
                                    continue;
                                }
                            }
                            if (t[l] === "]") break;
                            l++;
                        }
                        let c = o;
                        for(; o < t.length && t[o] !== "]";){
                            if (t[o] === "[" && o + 1 < t.length && t[o + 1] === ":") {
                                let u = t.indexOf(":]", o + 2);
                                if (u !== -1) {
                                    let f = t.slice(o + 2, u), p = Da(f);
                                    a += p, o = u + 2;
                                    continue;
                                }
                            }
                            if (t[o] === "\\" && o + 1 < t.length) {
                                a += `\\${t[o + 1]}`, o += 2;
                                continue;
                            }
                            if (t[o] === "-") {
                                let u = o === c, f = o + 1 === l;
                                u || f ? a += "\\-" : a += "-";
                            } else a += t[o];
                            o++;
                        }
                        a += "]", n += a, s = o;
                    } else if (i === "\\" && s + 1 < t.length) {
                        let o = t[s + 1];
                        /[.+^${}()|\\*?[\]]/.test(o) ? n += `\\${o}` : n += o, s++;
                    } else /[.+^${}()|]/.test(i) ? n += `\\${i}` : n += i;
                }
                return n;
            }
            computePatternLength(t) {
                let n = 0, r = 0, s = false;
                for(; r < t.length;){
                    if (t.slice(r, r + 13) === "\0QUOTE_START\0") {
                        s = true, r += 13;
                        continue;
                    }
                    if (t.slice(r, r + 11) === "\0QUOTE_END\0") {
                        s = false, r += 11;
                        continue;
                    }
                    let i = t[r];
                    if (s) {
                        n += 1, r++;
                        continue;
                    }
                    if ((i === "@" || i === "*" || i === "+" || i === "?" || i === "!") && r + 1 < t.length && t[r + 1] === "(") {
                        let o = Fa(t, r + 1);
                        if (o !== -1) {
                            if (i === "@") {
                                let a = t.slice(r + 2, o), c = _a(a).map((u)=>this.computePatternLength(u));
                                if (c.every((u)=>u !== null) && c.every((u)=>u === c[0])) {
                                    n += c[0], r = o + 1;
                                    continue;
                                }
                                return null;
                            }
                            return null;
                        }
                    }
                    if (i === "*") return null;
                    if (i === "?") {
                        n += 1, r++;
                        continue;
                    }
                    if (i === "[") {
                        let o = t.indexOf("]", r + 1);
                        if (o !== -1) {
                            n += 1, r = o + 1;
                            continue;
                        }
                        n += 1, r++;
                        continue;
                    }
                    if (i === "\\") {
                        n += 1, r += 2;
                        continue;
                    }
                    n += 1, r++;
                }
                return n;
            }
        };
    });
    function La(e) {
        for(let t = 0; t < e.length; t++){
            if (e[t] === "\\") {
                t++;
                continue;
            }
            if (e[t] === "$") {
                let n = e[t + 1];
                if (n === "{" || n && /[a-zA-Z_]/.test(n)) return true;
            }
        }
        return false;
    }
    function FC(e) {
        if (!e.operation) return false;
        let t = e.operation, n;
        if ((t.type === "DefaultValue" || t.type === "AssignDefault" || t.type === "UseAlternative" || t.type === "ErrorIfUnset") && (n = t.word?.parts), !n) return false;
        for (let r of n)if (r.type === "DoubleQuoted" || r.type === "SingleQuoted") return true;
        return false;
    }
    function rg(e) {
        if (!e.operation) return false;
        let t = e.operation, n;
        if ((t.type === "DefaultValue" || t.type === "AssignDefault" || t.type === "UseAlternative" || t.type === "ErrorIfUnset") && (n = t.word?.parts), !n || n.length === 0) return false;
        for (let r of n)if (r.type !== "DoubleQuoted" && r.type !== "SingleQuoted") return false;
        return true;
    }
    function Lr(e) {
        let t = false, n = false, r = false, s = false, i = false, o = false, a = false;
        for (let l of e){
            if ((l.type === "SingleQuoted" || l.type === "DoubleQuoted") && (t = true, l.type === "DoubleQuoted")) for (let c of l.parts)c.type === "ParameterExpansion" && (c.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/) && (!c.operation || c.operation.type === "PatternRemoval" || c.operation.type === "PatternReplacement") && (s = true), (c.operation?.type === "VarNamePrefix" || c.operation?.type === "ArrayKeys") && (o = true), c.operation?.type === "Indirection" && (a = true));
            l.type === "CommandSubstitution" && (n = true), l.type === "ParameterExpansion" && (i = true, (l.parameter === "@" || l.parameter === "*") && (r = true), FC(l) && (t = true), (l.operation?.type === "VarNamePrefix" || l.operation?.type === "ArrayKeys") && (o = true), l.operation?.type === "Indirection" && (a = true)), l.type === "Glob" && La(l.pattern) && (i = true);
        }
        return {
            hasQuoted: t,
            hasCommandSub: n,
            hasArrayVar: r,
            hasArrayAtExpansion: s,
            hasParamExpansion: i,
            hasVarNamePrefixExpansion: o,
            hasIndirection: a
        };
    }
    var ei = v(()=>{});
    function _e(e, t) {
        let n = `${t}_`, r = [];
        for (let s of Object.keys(e.state.env))if (s.startsWith(n)) {
            let i = s.slice(n.length), o = Number.parseInt(i, 10);
            !Number.isNaN(o) && String(o) === i && r.push(o);
        }
        return r.sort((s, i)=>s - i);
    }
    function Ut(e, t) {
        let n = `${t}_`;
        for (let r of Object.keys(e.state.env))r.startsWith(n) && delete e.state.env[r];
    }
    function Pt(e, t) {
        let n = `${t}_`, r = `${t}__length`, s = [];
        for (let i of Object.keys(e.state.env))if (i !== r && i.startsWith(n)) {
            let o = i.slice(n.length);
            if (o.startsWith("_length")) continue;
            s.push(o);
        }
        return s.sort();
    }
    function ti(e) {
        return e.startsWith("'") && e.endsWith("'") || e.startsWith('"') && e.endsWith('"') ? e.slice(1, -1) : e;
    }
    function Ma(e) {
        if (e.parts.length < 2) return null;
        let t = e.parts[0], n = e.parts[1];
        if (t.type !== "Glob" || !t.pattern.startsWith("[")) return null;
        let r, s = n, i = 1;
        if (n.type === "Literal" && n.value.startsWith("]")) {
            let f = n.value.slice(1);
            if (f.startsWith("+=") || f.startsWith("=")) r = t.pattern.slice(1);
            else if (f === "") {
                if (e.parts.length < 3) return null;
                let p = e.parts[2];
                if (p.type !== "Literal" || !p.value.startsWith("=") && !p.value.startsWith("+=")) return null;
                r = t.pattern.slice(1), s = p, i = 2;
            } else return null;
        } else if (t.pattern === "[" && (n.type === "DoubleQuoted" || n.type === "SingleQuoted")) {
            if (e.parts.length < 3) return null;
            let f = e.parts[2];
            if (f.type !== "Literal" || !f.value.startsWith("]=") && !f.value.startsWith("]+=")) return null;
            if (n.type === "SingleQuoted") r = n.value;
            else {
                r = "";
                for (let p of n.parts)(p.type === "Literal" || p.type === "Escaped") && (r += p.value);
            }
            s = f, i = 2;
        } else if (t.pattern.endsWith("]")) {
            if (n.type !== "Literal" || !n.value.startsWith("=") && !n.value.startsWith("+=")) return null;
            r = t.pattern.slice(1, -1);
        } else return null;
        r = ti(r);
        let o;
        if (s.type !== "Literal") return null;
        s.value.startsWith("]=") || s.value.startsWith("]+=") ? o = s.value.slice(1) : o = s.value;
        let a = o.startsWith("+=");
        if (!a && !o.startsWith("=")) return null;
        let l = [], c = a ? 2 : 1, u = o.slice(c);
        u && l.push({
            type: "Literal",
            value: u
        });
        for(let f = i + 1; f < e.parts.length; f++){
            let p = e.parts[f];
            p.type === "BraceExpansion" ? l.push({
                type: "Literal",
                value: _C(p)
            }) : l.push(p);
        }
        return {
            key: r,
            valueParts: l,
            append: a
        };
    }
    function _C(e) {
        return `{${e.items.map((n)=>{
            if (n.type === "Range") {
                let r = n.startStr ?? String(n.start), s = n.endStr ?? String(n.end), i = `${r}..${s}`;
                return n.step && (i += `..${n.step}`), i;
            }
            return Yn(n.word);
        }).join(",")}}`;
    }
    function Yn(e) {
        let t = "";
        for (let n of e.parts)switch(n.type){
            case "Literal":
                t += n.value;
                break;
            case "Glob":
                t += n.pattern;
                break;
            case "SingleQuoted":
                t += n.value;
                break;
            case "DoubleQuoted":
                for (let r of n.parts)(r.type === "Literal" || r.type === "Escaped") && (t += r.value);
                break;
            case "Escaped":
                t += n.value;
                break;
            case "BraceExpansion":
                t += "{", t += n.items.map((r)=>r.type === "Range" ? `${r.startStr}..${r.endStr}${r.step ? `..${r.step}` : ""}` : Yn(r.word)).join(","), t += "}";
                break;
            case "TildeExpansion":
                t += "~", n.user && (t += n.user);
                break;
        }
        return t;
    }
    var $t = v(()=>{});
    function Ue(e) {
        return e.IFS ?? ` 	
`;
    }
    function Ze(e) {
        return e.IFS === "";
    }
    function ni(e) {
        let t = Ue(e);
        if (t === "") return true;
        for (let n of t)if (n !== " " && n !== "	" && n !== `
`) return false;
        return true;
    }
    function sg(e) {
        return e.split("").map((t)=>/[\\^$.*+?()[\]{}|-]/.test(t) ? `\\${t}` : t === "	" ? "\\t" : t === `
` ? "\\n" : t).join("");
    }
    function oe(e) {
        let t = e.IFS;
        return t === void 0 ? " " : t[0] || "";
    }
    function MC(e) {
        return LC.includes(e);
    }
    function Wa(e) {
        let t = new Set(), n = new Set();
        for (let r of e)MC(r) ? t.add(r) : n.add(r);
        return {
            whitespace: t,
            nonWhitespace: n
        };
    }
    function Ba(e, t, n, r) {
        if (t === "") return e === "" ? {
            words: [],
            wordStarts: []
        } : {
            words: [
                e
            ],
            wordStarts: [
                0
            ]
        };
        let { whitespace: s, nonWhitespace: i } = Wa(t), o = [], a = [], l = 0;
        for(; l < e.length && s.has(e[l]);)l++;
        if (l >= e.length) return {
            words: [],
            wordStarts: []
        };
        if (i.has(e[l])) for(o.push(""), a.push(l), l++; l < e.length && s.has(e[l]);)l++;
        for(; l < e.length && !(n !== void 0 && o.length >= n);){
            let c = l;
            for(a.push(c); l < e.length;){
                let u = e[l];
                if (!r && u === "\\") {
                    l++, l < e.length && l++;
                    continue;
                }
                if (s.has(u) || i.has(u)) break;
                l++;
            }
            if (o.push(e.substring(c, l)), l >= e.length) break;
            for(; l < e.length && s.has(e[l]);)l++;
            if (l < e.length && i.has(e[l])) {
                for(l++; l < e.length && s.has(e[l]);)l++;
                for(; l < e.length && i.has(e[l]) && !(n !== void 0 && o.length >= n);)for(o.push(""), a.push(l), l++; l < e.length && s.has(e[l]);)l++;
            }
        }
        return {
            words: o,
            wordStarts: a
        };
    }
    function ri(e, t) {
        if (t === "") return {
            words: e ? [
                e
            ] : [],
            hadLeadingDelimiter: false,
            hadTrailingDelimiter: false
        };
        if (e === "") return {
            words: [],
            hadLeadingDelimiter: false,
            hadTrailingDelimiter: false
        };
        let { whitespace: n, nonWhitespace: r } = Wa(t), s = [], i = 0, o = false, a = false, l = i;
        for(; i < e.length && n.has(e[i]);)i++;
        if (i > l && (o = true), i >= e.length) return {
            words: [],
            hadLeadingDelimiter: true,
            hadTrailingDelimiter: true
        };
        if (r.has(e[i])) for(s.push(""), i++; i < e.length && n.has(e[i]);)i++;
        for(; i < e.length;){
            let c = i;
            for(; i < e.length;){
                let f = e[i];
                if (n.has(f) || r.has(f)) break;
                i++;
            }
            if (s.push(e.substring(c, i)), i >= e.length) {
                a = false;
                break;
            }
            let u = i;
            for(; i < e.length && n.has(e[i]);)i++;
            if (i < e.length && r.has(e[i])) {
                for(i++; i < e.length && n.has(e[i]);)i++;
                for(; i < e.length && r.has(e[i]);)for(s.push(""), i++; i < e.length && n.has(e[i]);)i++;
            }
            i >= e.length && i > u && (a = true);
        }
        return {
            words: s,
            hadLeadingDelimiter: o,
            hadTrailingDelimiter: a
        };
    }
    function Ae(e, t) {
        return ri(e, t).words;
    }
    function WC(e, t) {
        for (let n of e)if (t.has(n)) return true;
        return false;
    }
    function ig(e, t, n) {
        if (t === "") return e;
        let { whitespace: r, nonWhitespace: s } = Wa(t), i = e.length;
        for(; i > 0 && r.has(e[i - 1]);){
            if (!n && i >= 2) {
                let a = 0, l = i - 2;
                for(; l >= 0 && e[l] === "\\";)a++, l--;
                if (a % 2 === 1) break;
            }
            i--;
        }
        let o = e.substring(0, i);
        if (o.length >= 1 && s.has(o[o.length - 1])) {
            if (!n && o.length >= 2) {
                let l = 0, c = o.length - 2;
                for(; c >= 0 && o[c] === "\\";)l++, c--;
                if (l % 2 === 1) return o;
            }
            let a = o.substring(0, o.length - 1);
            if (!WC(a, s)) return a;
        }
        return o;
    }
    var LC, St = v(()=>{
        LC = ` 	
`;
    });
    function Se(e, t) {
        return e.state.namerefs?.has(t) ?? false;
    }
    function Zt(e, t) {
        e.state.namerefs ??= new Set(), e.state.namerefs.add(t);
    }
    function og(e, t) {
        e.state.namerefs?.delete(t), e.state.boundNamerefs?.delete(t), e.state.invalidNamerefs?.delete(t);
    }
    function ag(e, t) {
        e.state.invalidNamerefs ??= new Set(), e.state.invalidNamerefs.add(t);
    }
    function lg(e, t) {
        return e.state.invalidNamerefs?.has(t) ?? false;
    }
    function Ua(e, t) {
        e.state.boundNamerefs ??= new Set(), e.state.boundNamerefs.add(t);
    }
    function si(e, t) {
        let n = t.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
        if (n) {
            let s = n[1], i = Object.keys(e.state.env).some((a)=>a.startsWith(`${s}_`) && !a.includes("__")), o = e.state.associativeArrays?.has(s) ?? false;
            return i || o;
        }
        return Object.keys(e.state.env).some((s)=>s.startsWith(`${t}_`) && !s.includes("__")) ? true : e.state.env[t] !== void 0;
    }
    function st(e, t, n = 100) {
        if (!Se(e, t) || lg(e, t)) return t;
        let r = new Set(), s = t;
        for(; n-- > 0;){
            if (r.has(s)) return;
            if (r.add(s), !Se(e, s)) return s;
            let i = e.state.env[s];
            if (i === void 0 || i === "" || !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(i)) return s;
            s = i;
        }
    }
    function kn(e, t) {
        if (Se(e, t)) return e.state.env[t];
    }
    function cg(e, t, n, r = 100) {
        if (!Se(e, t) || lg(e, t)) return t;
        let s = new Set(), i = t;
        for(; r-- > 0;){
            if (s.has(i)) return;
            if (s.add(i), !Se(e, i)) return i;
            let o = e.state.env[i];
            if (o === void 0 || o === "") return n !== void 0 ? /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(n) && si(e, n) ? i : null : i;
            if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(o)) return i;
            i = o;
        }
    }
    var Tt = v(()=>{});
    function BC(e, t) {
        let n = t.replace(/\$\{([a-zA-Z_][a-zA-Z0-9_]*)\}/g, (r, s)=>e.state.env[s] ?? "");
        return n = n.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (r, s)=>e.state.env[s] ?? ""), n;
    }
    function te(e, t) {
        return t === "FUNCNAME" ? (e.state.funcNameStack ?? []).map((i, o)=>[
                o,
                i
            ]) : t === "BASH_LINENO" ? (e.state.callLineStack ?? []).map((i, o)=>[
                o,
                String(i)
            ]) : t === "BASH_SOURCE" ? (e.state.sourceStack ?? []).map((i, o)=>[
                o,
                i
            ]) : e.state.associativeArrays?.has(t) ? Pt(e, t).map((i)=>[
                i,
                e.state.env[`${t}_${i}`]
            ]) : _e(e, t).map((s)=>[
                s,
                e.state.env[`${t}_${s}`]
            ]);
    }
    function Qt(e, t) {
        return t === "FUNCNAME" ? (e.state.funcNameStack?.length ?? 0) > 0 : t === "BASH_LINENO" ? (e.state.callLineStack?.length ?? 0) > 0 : t === "BASH_SOURCE" ? (e.state.sourceStack?.length ?? 0) > 0 : e.state.associativeArrays?.has(t) ? Pt(e, t).length > 0 : _e(e, t).length > 0;
    }
    async function me(e, t, n = true, r = false) {
        switch(t){
            case "?":
                return String(e.state.lastExitCode);
            case "$":
                return String(process.pid);
            case "#":
                return e.state.env["#"] || "0";
            case "@":
                return e.state.env["@"] || "";
            case "_":
                return e.state.lastArg;
            case "-":
                {
                    let o = "";
                    return o += "h", e.state.options.errexit && (o += "e"), e.state.options.noglob && (o += "f"), e.state.options.nounset && (o += "u"), e.state.options.verbose && (o += "v"), e.state.options.xtrace && (o += "x"), o += "B", e.state.options.noclobber && (o += "C"), o += "s", o;
                }
            case "*":
                {
                    let o = Number.parseInt(e.state.env["#"] || "0", 10);
                    if (o === 0) return "";
                    let a = [];
                    for(let l = 1; l <= o; l++)a.push(e.state.env[String(l)] || "");
                    return a.join(oe(e.state.env));
                }
            case "0":
                return e.state.env[0] || "bash";
            case "PWD":
                return e.state.env.PWD !== void 0 ? e.state.env.PWD : "";
            case "OLDPWD":
                return e.state.env.OLDPWD !== void 0 ? e.state.env.OLDPWD : "";
            case "PPID":
                {
                    let { ppid: o } = Dr();
                    return String(o);
                }
            case "UID":
                {
                    let { uid: o } = Dr();
                    return String(o);
                }
            case "EUID":
                return String(process.geteuid?.() ?? Dr().uid);
            case "RANDOM":
                return String(Math.floor(Math.random() * 32768));
            case "SECONDS":
                return String(Math.floor((Date.now() - e.state.startTime) / 1e3));
            case "BASH_VERSION":
                return rm;
            case "!":
                return String(e.state.lastBackgroundPid);
            case "BASHPID":
                return String(e.state.bashPid);
            case "LINENO":
                return String(e.state.currentLine);
            case "FUNCNAME":
                {
                    let o = e.state.funcNameStack?.[0];
                    if (o !== void 0) return o;
                    if (n && e.state.options.nounset) throw new tt("FUNCNAME");
                    return "";
                }
            case "BASH_LINENO":
                {
                    let o = e.state.callLineStack?.[0];
                    if (o !== void 0) return String(o);
                    if (n && e.state.options.nounset) throw new tt("BASH_LINENO");
                    return "";
                }
            case "BASH_SOURCE":
                {
                    let o = e.state.sourceStack?.[0];
                    if (o !== void 0) return o;
                    if (n && e.state.options.nounset) throw new tt("BASH_SOURCE");
                    return "";
                }
        }
        if (/^[a-zA-Z_][a-zA-Z0-9_]*\[\]$/.test(t)) throw new nt(`\${${t}}`);
        let s = t.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
        if (s) {
            let o = s[1], a = s[2];
            if (Se(e, o)) {
                let f = st(e, o);
                if (f && f !== o) {
                    if (f.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/)) return "";
                    o = f;
                }
            }
            if (a === "@" || a === "*") {
                let f = te(e, o);
                if (f.length > 0) return f.map(([, d])=>d).join(" ");
                let p = e.state.env[o];
                return p !== void 0 ? p : "";
            }
            if (o === "FUNCNAME") {
                let f = Number.parseInt(a, 10);
                return !Number.isNaN(f) && f >= 0 ? e.state.funcNameStack?.[f] ?? "" : "";
            }
            if (o === "BASH_LINENO") {
                let f = Number.parseInt(a, 10);
                if (!Number.isNaN(f) && f >= 0) {
                    let p = e.state.callLineStack?.[f];
                    return p !== void 0 ? String(p) : "";
                }
                return "";
            }
            if (o === "BASH_SOURCE") {
                let f = Number.parseInt(a, 10);
                return !Number.isNaN(f) && f >= 0 ? e.state.sourceStack?.[f] ?? "" : "";
            }
            if (e.state.associativeArrays?.has(o)) {
                let f = ti(a);
                f = BC(e, f);
                let p = e.state.env[`${o}_${f}`];
                if (p === void 0 && n && e.state.options.nounset) throw new tt(`${o}[${a}]`);
                return p || "";
            }
            let c;
            if (/^-?\d+$/.test(a)) c = Number.parseInt(a, 10);
            else try {
                let f = new se(), p = he(f, a);
                c = await Q(e, p.expression);
            } catch  {
                let f = e.state.env[a];
                c = f ? Number.parseInt(f, 10) : 0, Number.isNaN(c) && (c = 0);
            }
            if (c < 0) {
                let f = te(e, o), p = e.state.currentLine;
                if (f.length === 0) return e.state.expansionStderr = (e.state.expansionStderr || "") + `bash: line ${p}: ${o}: bad array subscript
`, "";
                let m = Math.max(...f.map(([g])=>typeof g == "number" ? g : 0)) + 1 + c;
                return m < 0 ? (e.state.expansionStderr = (e.state.expansionStderr || "") + `bash: line ${p}: ${o}: bad array subscript
`, "") : e.state.env[`${o}_${m}`] || "";
            }
            let u = e.state.env[`${o}_${c}`];
            if (u !== void 0) return u;
            if (c === 0) {
                let f = e.state.env[o];
                if (f !== void 0) return f;
            }
            if (n && e.state.options.nounset) throw new tt(`${o}[${c}]`);
            return "";
        }
        if (/^[1-9][0-9]*$/.test(t)) {
            let o = e.state.env[t];
            if (o === void 0 && n && e.state.options.nounset) throw new tt(t);
            return o || "";
        }
        if (Se(e, t)) {
            let o = st(e, t);
            if (o === void 0) return "";
            if (o !== t) return await me(e, o, n, r);
            let a = e.state.env[t];
            if ((a === void 0 || a === "") && n && e.state.options.nounset) throw new tt(t);
            return a || "";
        }
        let i = e.state.env[t];
        if (i !== void 0) return e.state.tempEnvBindings?.some((o)=>o.has(t)) && (e.state.accessedTempEnvVars = e.state.accessedTempEnvVars || new Set(), e.state.accessedTempEnvVars.add(t)), i;
        if (Qt(e, t)) {
            let o = e.state.env[`${t}_0`];
            return o !== void 0 ? o : "";
        }
        if (n && e.state.options.nounset) throw new tt(t);
        return "";
    }
    async function zt(e, t) {
        if ((new Set([
            "?",
            "$",
            "#",
            "_",
            "-",
            "0",
            "PPID",
            "UID",
            "EUID",
            "RANDOM",
            "SECONDS",
            "BASH_VERSION",
            "!",
            "BASHPID",
            "LINENO"
        ])).has(t)) return true;
        if (t === "@" || t === "*") return Number.parseInt(e.state.env["#"] || "0", 10) > 0;
        if (t === "PWD" || t === "OLDPWD") return t in e.state.env;
        let r = t.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
        if (r) {
            let s = r[1], i = r[2];
            if (Se(e, s)) {
                let l = st(e, s);
                if (l && l !== s) {
                    if (l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/)) return false;
                    s = l;
                }
            }
            if (i === "@" || i === "*") return te(e, s).length > 0 ? true : s in e.state.env;
            if (e.state.associativeArrays?.has(s)) {
                let l = ti(i);
                return `${s}_${l}` in e.state.env;
            }
            let a;
            if (/^-?\d+$/.test(i)) a = Number.parseInt(i, 10);
            else try {
                let l = new se(), c = he(l, i);
                a = await Q(e, c.expression);
            } catch  {
                let l = e.state.env[i];
                a = l ? Number.parseInt(l, 10) : 0, Number.isNaN(a) && (a = 0);
            }
            if (a < 0) {
                let l = te(e, s);
                if (l.length === 0) return false;
                let u = Math.max(...l.map(([f])=>typeof f == "number" ? f : 0)) + 1 + a;
                return u < 0 ? false : `${s}_${u}` in e.state.env;
            }
            return `${s}_${a}` in e.state.env;
        }
        if (Se(e, t)) {
            let s = st(e, t);
            return s === void 0 || s === t ? t in e.state.env : zt(e, s);
        }
        return !!(t in e.state.env || Qt(e, t));
    }
    var ht = v(()=>{
        Je();
        Fe();
        ca();
        it();
        de();
        $t();
        St();
        Tt();
    });
    async function ug(e, t) {
        let n = "", r = 0;
        for(; r < t.length;){
            if (t[r] === "$") {
                if (t[r + 1] === "{") {
                    let s = 1, i = r + 2;
                    for(; i < t.length && s > 0;)t[i] === "{" ? s++ : t[i] === "}" && s--, i++;
                    n += t.slice(r, i), r = i;
                    continue;
                }
                if (t[r + 1] === "(") {
                    let s = 1, i = r + 2;
                    for(; i < t.length && s > 0;)t[i] === "(" ? s++ : t[i] === ")" && s--, i++;
                    n += t.slice(r, i), r = i;
                    continue;
                }
                if (/[a-zA-Z_]/.test(t[r + 1] || "")) {
                    let s = r + 1;
                    for(; s < t.length && /[a-zA-Z0-9_]/.test(t[s]);)s++;
                    let i = t.slice(r + 1, s), o = await me(e, i);
                    n += o, r = s;
                    continue;
                }
                if (/[0-9]/.test(t[r + 1] || "")) {
                    let s = r + 1;
                    for(; s < t.length && /[0-9]/.test(t[s]);)s++;
                    let i = t.slice(r + 1, s), o = await me(e, i);
                    n += o, r = s;
                    continue;
                }
                if (/[*@#?\-!$]/.test(t[r + 1] || "")) {
                    let s = t[r + 1], i = await me(e, s);
                    n += i, r += 2;
                    continue;
                }
            }
            if (t[r] === '"') {
                for(n += '"', r++; r < t.length && t[r] !== '"';)if (t[r] === "$" && /[a-zA-Z_]/.test(t[r + 1] || "")) {
                    let s = r + 1;
                    for(; s < t.length && /[a-zA-Z0-9_]/.test(t[s]);)s++;
                    let i = t.slice(r + 1, s), o = await me(e, i);
                    n += o, r = s;
                } else t[r] === "\\" ? (n += t[r], r++, r < t.length && (n += t[r], r++)) : (n += t[r], r++);
                r < t.length && (n += '"', r++);
                continue;
            }
            n += t[r], r++;
        }
        return n;
    }
    async function za(e, t) {
        let n = t, r = t.startsWith('"') && t.endsWith('"'), s = t.startsWith("'") && t.endsWith("'");
        if ((r || s) && (n = t.slice(1, -1)), s) return n;
        let i = "", o = 0;
        for(; o < n.length;)if (n[o] === "$") if (n[o + 1] === "(") {
            let a = 1, l = o + 2;
            for(; l < n.length && a > 0;)n[l] === "(" && n[l - 1] === "$" || n[l] === "(" ? a++ : n[l] === ")" && a--, l++;
            let c = n.slice(o + 2, l - 1);
            if (e.execFn) {
                let u = await e.execFn(c);
                i += u.stdout.replace(/\n+$/, ""), u.stderr && (e.state.expansionStderr = (e.state.expansionStderr || "") + u.stderr);
            }
            o = l;
        } else if (n[o + 1] === "{") {
            let a = 1, l = o + 2;
            for(; l < n.length && a > 0;)n[l] === "{" ? a++ : n[l] === "}" && a--, l++;
            let c = n.slice(o + 2, l - 1), u = await me(e, c);
            i += u, o = l;
        } else if (/[a-zA-Z_]/.test(n[o + 1] || "")) {
            let a = o + 1;
            for(; a < n.length && /[a-zA-Z0-9_]/.test(n[a]);)a++;
            let l = n.slice(o + 1, a), c = await me(e, l);
            i += c, o = a;
        } else i += n[o], o++;
        else if (n[o] === "`") {
            let a = o + 1;
            for(; a < n.length && n[a] !== "`";)a++;
            let l = n.slice(o + 1, a);
            if (e.execFn) {
                let c = await e.execFn(l);
                i += c.stdout.replace(/\n+$/, ""), c.stderr && (e.state.expansionStderr = (e.state.expansionStderr || "") + c.stderr);
            }
            o = a + 1;
        } else i += n[o], o++;
        return i;
    }
    var fg = v(()=>{
        ht();
    });
    function UC(e, t, n, r, s) {
        let i = n ?? 1;
        i === 0 && (i = 1);
        let o = Math.abs(i), a = [], l = 0;
        r?.match(/^-?0\d/) && (l = Math.max(l, r.replace(/^-/, "").length)), s?.match(/^-?0\d/) && (l = Math.max(l, s.replace(/^-/, "").length));
        let c = (u)=>{
            if (l > 0) {
                let f = u < 0, p = String(Math.abs(u)).padStart(l, "0");
                return f ? `-${p}` : p;
            }
            return String(u);
        };
        if (e <= t) for(let u = e, f = 0; u <= t && f < ii; u += o, f++)a.push(c(u));
        else for(let u = e, f = 0; u >= t && f < ii; u -= o, f++)a.push(c(u));
        return a;
    }
    function zC(e, t, n) {
        let r = n ?? 1;
        r === 0 && (r = 1);
        let s = e.charCodeAt(0), i = t.charCodeAt(0), o = Math.abs(r), a = e >= "A" && e <= "Z", l = e >= "a" && e <= "z", c = t >= "A" && t <= "Z", u = t >= "a" && t <= "z";
        if (a && u || l && c) {
            let p = n !== void 0 ? `..${n}` : "";
            throw new Fn(`{${e}..${t}${p}}: invalid sequence`);
        }
        let f = [];
        if (s <= i) for(let p = s, d = 0; p <= i && d < ii; p += o, d++)f.push(String.fromCharCode(p));
        else for(let p = s, d = 0; p >= i && d < ii; p -= o, d++)f.push(String.fromCharCode(p));
        return f;
    }
    function ja(e, t, n, r, s) {
        let i = n !== void 0 ? `..${n}` : "";
        return typeof e == "number" && typeof t == "number" ? {
            expanded: UC(e, t, n, r, s),
            literal: `{${e}..${t}${i}}`
        } : typeof e == "string" && typeof t == "string" ? {
            expanded: zC(e, t, n),
            literal: `{${e}..${t}${i}}`
        } : {
            expanded: null,
            literal: `{${e}..${t}${i}}`
        };
    }
    var ii, pg = v(()=>{
        de();
        ii = 1e4;
    });
    function dg(e) {
        if (e.statements.length !== 1) return null;
        let t = e.statements[0];
        if (t.operators.length !== 0 || t.pipelines.length !== 1) return null;
        let n = t.pipelines[0];
        if (n.negated || n.commands.length !== 1) return null;
        let r = n.commands[0];
        if (r.type !== "SimpleCommand") return null;
        let s = r;
        if (s.name !== null || s.args.length !== 0 || s.assignments.length !== 0 || s.redirections.length !== 1) return null;
        let i = s.redirections[0];
        return i.operator !== "<" || i.target.type !== "Word" ? null : {
            target: i.target
        };
    }
    var hg = v(()=>{});
    function jt(e, t) {
        return !!(/[*?[]/.test(e) || t && /[@*+?!]\(/.test(e));
    }
    function Ha(e) {
        let t = "", n = 0;
        for(; n < e.length;)e[n] === "\\" && n + 1 < e.length ? (t += e[n + 1], n += 2) : (t += e[n], n++);
        return t;
    }
    function mt(e) {
        return e.replace(/([*?[\]\\()|])/g, "\\$1");
    }
    function er(e) {
        return e.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
    }
    var tr = v(()=>{});
    function pe(e) {
        return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    var nr = v(()=>{});
    function ce(e, t, n = false) {
        let r = "", s = 0;
        for(; s < e.length;){
            let i = e[s];
            if (n && (i === "@" || i === "*" || i === "+" || i === "?" || i === "!") && s + 1 < e.length && e[s + 1] === "(") {
                let o = jC(e, s + 1);
                if (o !== -1) {
                    let a = e.slice(s + 2, o), c = HC(a).map((f)=>ce(f, t, n)), u = c.length > 0 ? c.join("|") : "(?:)";
                    i === "@" ? r += `(?:${u})` : i === "*" ? r += `(?:${u})*` : i === "+" ? r += `(?:${u})+` : i === "?" ? r += `(?:${u})?` : i === "!" && (r += `(?!(?:${u})$).*`), s = o + 1;
                    continue;
                }
            }
            if (i === "\\") if (s + 1 < e.length) {
                let o = e[s + 1];
                /[\\^$.|+(){}[\]*?]/.test(o) ? r += `\\${o}` : r += o, s += 2;
            } else r += "\\\\", s++;
            else if (i === "*") r += t ? ".*" : ".*?", s++;
            else if (i === "?") r += ".", s++;
            else if (i === "[") {
                let o = VC(e, s);
                if (o === -1) r += "\\[", s++;
                else {
                    let a = e.slice(s + 1, o);
                    r += qC(a), s = o + 1;
                }
            } else /[\^$.|+(){}]/.test(i) ? (r += `\\${i}`, s++) : (r += i, s++);
        }
        return r;
    }
    function jC(e, t) {
        let n = 1, r = t + 1;
        for(; r < e.length && n > 0;){
            let s = e[r];
            if (s === "\\") {
                r += 2;
                continue;
            }
            if (s === "(") n++;
            else if (s === ")" && (n--, n === 0)) return r;
            r++;
        }
        return -1;
    }
    function HC(e) {
        let t = [], n = "", r = 0, s = 0;
        for(; s < e.length;){
            let i = e[s];
            if (i === "\\") {
                n += i, s + 1 < e.length ? (n += e[s + 1], s += 2) : s++;
                continue;
            }
            i === "(" ? (r++, n += i) : i === ")" ? (r--, n += i) : i === "|" && r === 0 ? (t.push(n), n = "") : n += i, s++;
        }
        return t.push(n), t;
    }
    function VC(e, t) {
        let n = t + 1;
        for(n < e.length && e[n] === "^" && n++, n < e.length && e[n] === "]" && n++; n < e.length;){
            if (e[n] === "\\" && n + 1 < e.length) {
                n += 2;
                continue;
            }
            if (e[n] === "]") return n;
            if (e[n] === "'") {
                let r = e.indexOf("'", n + 1);
                if (r !== -1) {
                    n = r + 1;
                    continue;
                }
            }
            if (e[n] === "[" && n + 1 < e.length && e[n + 1] === ":") {
                let r = e.indexOf(":]", n + 2);
                if (r !== -1) {
                    n = r + 2;
                    continue;
                }
            }
            n++;
        }
        return -1;
    }
    function qC(e) {
        let t = "[", n = 0;
        for((e[0] === "^" || e[0] === "!") && (t += "^", n++); n < e.length;){
            if (e[n] === "'") {
                let s = e.indexOf("'", n + 1);
                if (s !== -1) {
                    let i = e.slice(n + 1, s);
                    for (let o of i)o === "\\" ? t += "\\\\" : o === "]" ? t += "\\]" : o === "^" && t === "[" ? t += "\\^" : t += o;
                    n = s + 1;
                    continue;
                }
            }
            if (e[n] === "[" && n + 1 < e.length && e[n + 1] === ":") {
                let s = e.indexOf(":]", n + 2);
                if (s !== -1) {
                    let i = e.slice(n + 2, s);
                    t += ZC(i), n = s + 2;
                    continue;
                }
            }
            let r = e[n];
            r === "\\" ? n + 1 < e.length ? (t += `\\${e[n + 1]}`, n += 2) : (t += "\\\\", n++) : r === "-" && n > 0 && n < e.length - 1 ? (t += "-", n++) : r === "^" && n === 0 ? (t += "^", n++) : (r === "]" && n === 0 ? t += "\\]" : t += r, n++);
        }
        return t += "]", t;
    }
    function ZC(e) {
        return GC[e] ?? "";
    }
    var GC, rr = v(()=>{
        GC = {
            alnum: "a-zA-Z0-9",
            alpha: "a-zA-Z",
            ascii: "\\x00-\\x7F",
            blank: " \\t",
            cntrl: "\\x00-\\x1F\\x7F",
            digit: "0-9",
            graph: "!-~",
            lower: "a-z",
            print: " -~",
            punct: "!-/:-@\\[-`{-~",
            space: " \\t\\n\\r\\f\\v",
            upper: "A-Z",
            word: "a-zA-Z0-9_",
            xdigit: "0-9A-Fa-f"
        };
    });
    function Kt(e, t, n, r) {
        if (n === "prefix") return e.replace(new RegExp(`^${t}`, "s"), "");
        let s = new RegExp(`${t}$`, "s");
        if (r) return e.replace(s, "");
        for(let i = e.length; i >= 0; i--){
            let o = e.slice(i);
            if (s.test(o)) return e.slice(0, i);
        }
        return e;
    }
    function sr(e, t) {
        let n = Object.keys(e.state.env), r = new Set(), s = e.state.associativeArrays ?? new Set(), i = new Set();
        for (let a of n){
            let l = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_\d+$/);
            l && i.add(l[1]);
            let c = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
            c && i.add(c[1]);
        }
        let o = (a)=>{
            for (let l of s){
                let c = `${l}_`;
                if (a.startsWith(c) && a !== l) return true;
            }
            return false;
        };
        for (let a of n)if (a.startsWith(t)) if (a.includes("__")) {
            let l = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
            l?.[1].startsWith(t) && r.add(l[1]);
        } else if (/_\d+$/.test(a)) {
            let l = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_\d+$/);
            l?.[1].startsWith(t) && r.add(l[1]);
        } else o(a) || r.add(a);
        return [
            ...r
        ].sort();
    }
    var vn = v(()=>{});
    function QC(e, t) {
        let n = (i, o = 2)=>String(i).padStart(o, "0");
        if (e === "") {
            let i = n(t.getHours()), o = n(t.getMinutes()), a = n(t.getSeconds());
            return `${i}:${o}:${a}`;
        }
        let r = "", s = 0;
        for(; s < e.length;)if (e[s] === "%") {
            if (s + 1 >= e.length) {
                r += "%", s++;
                continue;
            }
            let i = e[s + 1];
            switch(i){
                case "H":
                    r += n(t.getHours());
                    break;
                case "M":
                    r += n(t.getMinutes());
                    break;
                case "S":
                    r += n(t.getSeconds());
                    break;
                case "d":
                    r += n(t.getDate());
                    break;
                case "m":
                    r += n(t.getMonth() + 1);
                    break;
                case "Y":
                    r += t.getFullYear();
                    break;
                case "y":
                    r += n(t.getFullYear() % 100);
                    break;
                case "I":
                    {
                        let o = t.getHours() % 12;
                        o === 0 && (o = 12), r += n(o);
                        break;
                    }
                case "p":
                    r += t.getHours() < 12 ? "AM" : "PM";
                    break;
                case "P":
                    r += t.getHours() < 12 ? "am" : "pm";
                    break;
                case "%":
                    r += "%";
                    break;
                case "a":
                    {
                        r += [
                            "Sun",
                            "Mon",
                            "Tue",
                            "Wed",
                            "Thu",
                            "Fri",
                            "Sat"
                        ][t.getDay()];
                        break;
                    }
                case "b":
                    {
                        r += [
                            "Jan",
                            "Feb",
                            "Mar",
                            "Apr",
                            "May",
                            "Jun",
                            "Jul",
                            "Aug",
                            "Sep",
                            "Oct",
                            "Nov",
                            "Dec"
                        ][t.getMonth()];
                        break;
                    }
                default:
                    r += `%${i}`;
            }
            s += 2;
        } else r += e[s], s++;
        return r;
    }
    function Mr(e, t) {
        let n = "", r = 0, s = e.state.env.USER || e.state.env.LOGNAME || "user", i = e.state.env.HOSTNAME || "localhost", o = i.split(".")[0], a = e.state.env.PWD || "/", l = e.state.env.HOME || "/", c = a.startsWith(l) ? `~${a.slice(l.length)}` : a, u = a.split("/").pop() || a, f = new Date(), p = [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ], d = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ], m = e.state.env.__COMMAND_NUMBER || "1";
        for(; r < t.length;){
            let h = t[r];
            if (h === "\\") {
                if (r + 1 >= t.length) {
                    n += "\\", r++;
                    continue;
                }
                let g = t[r + 1];
                if (g >= "0" && g <= "7") {
                    let b = "", y = r + 1;
                    for(; y < t.length && y < r + 4 && t[y] >= "0" && t[y] <= "7";)b += t[y], y++;
                    let w = Number.parseInt(b, 8) % 256;
                    n += String.fromCharCode(w), r = y;
                    continue;
                }
                switch(g){
                    case "\\":
                        n += "\\", r += 2;
                        break;
                    case "a":
                        n += "\x07", r += 2;
                        break;
                    case "e":
                        n += "\x1B", r += 2;
                        break;
                    case "n":
                        n += `
`, r += 2;
                        break;
                    case "r":
                        n += "\r", r += 2;
                        break;
                    case "$":
                        n += "$", r += 2;
                        break;
                    case "[":
                    case "]":
                        r += 2;
                        break;
                    case "u":
                        n += s, r += 2;
                        break;
                    case "h":
                        n += o, r += 2;
                        break;
                    case "H":
                        n += i, r += 2;
                        break;
                    case "w":
                        n += c, r += 2;
                        break;
                    case "W":
                        n += u, r += 2;
                        break;
                    case "d":
                        {
                            let b = String(f.getDate()).padStart(2, " ");
                            n += `${p[f.getDay()]} ${d[f.getMonth()]} ${b}`, r += 2;
                            break;
                        }
                    case "t":
                        {
                            let b = String(f.getHours()).padStart(2, "0"), y = String(f.getMinutes()).padStart(2, "0"), w = String(f.getSeconds()).padStart(2, "0");
                            n += `${b}:${y}:${w}`, r += 2;
                            break;
                        }
                    case "T":
                        {
                            let b = f.getHours() % 12;
                            b === 0 && (b = 12);
                            let y = String(b).padStart(2, "0"), w = String(f.getMinutes()).padStart(2, "0"), E = String(f.getSeconds()).padStart(2, "0");
                            n += `${y}:${w}:${E}`, r += 2;
                            break;
                        }
                    case "@":
                        {
                            let b = f.getHours() % 12;
                            b === 0 && (b = 12);
                            let y = String(b).padStart(2, "0"), w = String(f.getMinutes()).padStart(2, "0"), E = f.getHours() < 12 ? "AM" : "PM";
                            n += `${y}:${w} ${E}`, r += 2;
                            break;
                        }
                    case "A":
                        {
                            let b = String(f.getHours()).padStart(2, "0"), y = String(f.getMinutes()).padStart(2, "0");
                            n += `${b}:${y}`, r += 2;
                            break;
                        }
                    case "D":
                        if (r + 2 < t.length && t[r + 2] === "{") {
                            let b = t.indexOf("}", r + 3);
                            if (b !== -1) {
                                let y = t.slice(r + 3, b);
                                n += QC(y, f), r = b + 1;
                            } else n += "\\D", r += 2;
                        } else n += "\\D", r += 2;
                        break;
                    case "s":
                        n += "bash", r += 2;
                        break;
                    case "v":
                        n += "5.0", r += 2;
                        break;
                    case "V":
                        n += "5.0.0", r += 2;
                        break;
                    case "j":
                        n += "0", r += 2;
                        break;
                    case "l":
                        n += "tty", r += 2;
                        break;
                    case "#":
                        n += m, r += 2;
                        break;
                    case "!":
                        n += m, r += 2;
                        break;
                    case "x":
                        n += "\\x", r += 2;
                        break;
                    default:
                        n += `\\${g}`, r += 2;
                }
            } else n += h, r++;
        }
        return n;
    }
    var Va = v(()=>{});
    function sn(e) {
        if (e === "") return "''";
        if (/[\n\r\t\x00-\x1f\x7f']/.test(e)) {
            let n = "$'";
            for (let r of e)switch(r){
                case "'":
                    n += "\\'";
                    break;
                case "\\":
                    n += "\\\\";
                    break;
                case `
`:
                    n += "\\n";
                    break;
                case "\r":
                    n += "\\r";
                    break;
                case "	":
                    n += "\\t";
                    break;
                default:
                    {
                        let s = r.charCodeAt(0);
                        s < 32 || s === 127 ? n += `\\${s.toString(8).padStart(3, "0")}` : n += r;
                    }
            }
            return `${n}'`;
        }
        return `'${e}'`;
    }
    var qa = v(()=>{});
    function gt(e, t) {
        e.state.readonlyVars = e.state.readonlyVars || new Set(), e.state.readonlyVars.add(t);
    }
    function Ht(e, t) {
        return e.state.readonlyVars?.has(t) ?? false;
    }
    function je(e, t, n = "bash") {
        if (Ht(e, t)) {
            let r = `${n}: ${t}: readonly variable
`;
            throw new ae(1, "", r);
        }
        return null;
    }
    function Ot(e, t) {
        let n = e.state.exportedVars?.has(t) ?? false;
        if (e.state.exportedVars = e.state.exportedVars || new Set(), e.state.exportedVars.add(t), e.state.localScopes.length > 0 && e.state.localScopes[e.state.localScopes.length - 1].has(t) && !n) {
            for(e.state.localExportedVars || (e.state.localExportedVars = []); e.state.localExportedVars.length < e.state.localScopes.length;)e.state.localExportedVars.push(new Set());
            e.state.localExportedVars[e.state.localExportedVars.length - 1].add(t);
        }
    }
    function oi(e, t) {
        e.state.exportedVars?.delete(t);
    }
    var on$1 = v(()=>{
        de();
    });
    function an(e, t) {
        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t)) return "";
        let n = "", r = e.state.env[`${t}__length`] !== void 0 || Object.keys(e.state.env).some((i)=>i.startsWith(`${t}_`) && /^[0-9]+$/.test(i.slice(t.length + 1))), s = e.state.associativeArrays?.has(t) ?? false;
        return r && !s && (n += "a"), s && (n += "A"), e.state.integerVars?.has(t) && (n += "i"), Se(e, t) && (n += "n"), Ht(e, t) && (n += "r"), e.state.exportedVars?.has(t) && (n += "x"), n;
    }
    var ai = v(()=>{
        Tt();
        on$1();
    });
    async function mg(e, t, n, r) {
        return (n.isUnset || t.checkEmpty && n.isEmpty) && t.word ? r(e, t.word.parts, n.inDoubleQuotes) : n.effectiveValue;
    }
    async function gg(e, t, n, r, s) {
        if ((r.isUnset || n.checkEmpty && r.isEmpty) && n.word) {
            let o = await s(e, n.word.parts, r.inDoubleQuotes), a = t.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
            if (a) {
                let [, l, c] = a, u;
                if (/^\d+$/.test(c)) u = Number.parseInt(c, 10);
                else {
                    try {
                        let p = new se(), d = he(p, c);
                        u = await Q(e, d.expression);
                    } catch  {
                        let p = e.state.env[c];
                        u = p ? Number.parseInt(p, 10) : 0;
                    }
                    Number.isNaN(u) && (u = 0);
                }
                e.state.env[`${l}_${u}`] = o;
                let f = Number.parseInt(e.state.env[`${l}__length`] || "0", 10);
                u >= f && (e.state.env[`${l}__length`] = String(u + 1));
            } else e.state.env[t] = o;
            return o;
        }
        return r.effectiveValue;
    }
    async function yg(e, t, n, r, s) {
        if (r.isUnset || n.checkEmpty && r.isEmpty) {
            let o = n.word ? await s(e, n.word.parts, r.inDoubleQuotes) : `${t}: parameter null or not set`;
            throw new ae(1, "", `bash: ${o}
`);
        }
        return r.effectiveValue;
    }
    async function bg(e, t, n, r) {
        return !(n.isUnset || t.checkEmpty && n.isEmpty) && t.word ? r(e, t.word.parts, n.inDoubleQuotes) : "";
    }
    async function wg(e, t, n, r, s) {
        let i = "", o = e.state.shoptOptions.extglob;
        if (n.pattern) for (let l of n.pattern.parts)if (l.type === "Glob") i += ce(l.pattern, n.greedy, o);
        else if (l.type === "Literal") i += ce(l.value, n.greedy, o);
        else if (l.type === "SingleQuoted" || l.type === "Escaped") i += pe(l.value);
        else if (l.type === "DoubleQuoted") {
            let c = await r(e, l.parts);
            i += pe(c);
        } else if (l.type === "ParameterExpansion") {
            let c = await s(e, l);
            i += ce(c, n.greedy, o);
        } else {
            let c = await s(e, l);
            i += pe(c);
        }
        if (n.side === "prefix") return t.replace(new RegExp(`^${i}`, "s"), "");
        let a = new RegExp(`${i}$`, "s");
        if (n.greedy) return t.replace(a, "");
        for(let l = t.length; l >= 0; l--){
            let c = t.slice(l);
            if (a.test(c)) return t.slice(0, l);
        }
        return t;
    }
    async function xg(e, t, n, r, s) {
        let i = "", o = e.state.shoptOptions.extglob;
        if (n.pattern) for (let c of n.pattern.parts)if (c.type === "Glob") i += ce(c.pattern, true, o);
        else if (c.type === "Literal") i += ce(c.value, true, o);
        else if (c.type === "SingleQuoted" || c.type === "Escaped") i += pe(c.value);
        else if (c.type === "DoubleQuoted") {
            let u = await r(e, c.parts);
            i += pe(u);
        } else if (c.type === "ParameterExpansion") {
            let u = await s(e, c);
            i += ce(u, true, o);
        } else {
            let u = await s(e, c);
            i += pe(u);
        }
        let a = n.replacement ? await r(e, n.replacement.parts) : "";
        if (n.anchor === "start" ? i = `^${i}` : n.anchor === "end" && (i = `${i}$`), i === "") return t;
        let l = n.all ? "gs" : "s";
        try {
            let c = new RegExp(i, l);
            if (n.all) {
                let u = "", f = 0, p = c.exec(t);
                for(; p !== null && !(p[0].length === 0 && p.index === t.length);)u += t.slice(f, p.index) + a, f = p.index + p[0].length, p[0].length === 0 && f++, p = c.exec(t);
                return u += t.slice(f), u;
            }
            return t.replace(c, a);
        } catch  {
            return t;
        }
    }
    function Eg(e, t, n) {
        let r = t.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
        if (r) {
            let s = r[1], i = te(e, s);
            return i.length > 0 ? String(i.length) : e.state.env[s] !== void 0 ? "1" : "0";
        }
        if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t) && Qt(e, t)) {
            if (t === "FUNCNAME") {
                let i = e.state.funcNameStack?.[0] || "";
                return String([
                    ...i
                ].length);
            }
            if (t === "BASH_LINENO") {
                let i = e.state.callLineStack?.[0];
                return String(i !== void 0 ? [
                    ...String(i)
                ].length : 0);
            }
            let s = e.state.env[`${t}_0`] || "";
            return String([
                ...s
            ].length);
        }
        return String([
            ...n
        ].length);
    }
    async function Sg(e, t, n, r) {
        let s = await Q(e, r.offset.expression), i = r.length ? await Q(e, r.length.expression) : void 0;
        if (t === "@" || t === "*") {
            let c = Number.parseInt(e.state.env["#"] || "0", 10), u = [];
            for(let m = 1; m <= c; m++)u.push(e.state.env[String(m)] || "");
            let f = e.state.env[0] || "bash", p, d;
            if (s <= 0) if (p = [
                f,
                ...u
            ], s < 0) {
                if (d = p.length + s, d < 0) return "";
            } else d = 0;
            else p = u, d = s - 1;
            if (d < 0 || d >= p.length) return "";
            if (i !== void 0) {
                let m = i < 0 ? p.length + i : d + i;
                return p.slice(d, Math.max(d, m)).join(" ");
            }
            return p.slice(d).join(" ");
        }
        let o = t.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
        if (o) {
            let c = o[1];
            if (e.state.associativeArrays?.has(c)) throw new ae(1, "", `bash: \${${c}[@]: 0: 3}: bad substitution
`);
            let u = te(e, c), f = 0;
            if (s < 0) {
                if (u.length > 0) {
                    let p = u[u.length - 1][0], m = (typeof p == "number" ? p : 0) + 1 + s;
                    if (m < 0 || (f = u.findIndex(([h])=>typeof h == "number" && h >= m), f < 0)) return "";
                }
            } else if (f = u.findIndex(([p])=>typeof p == "number" && p >= s), f < 0) return "";
            if (i !== void 0) {
                if (i < 0) throw new Ee(`${o[1]}[@]: substring expression < 0`);
                return u.slice(f, f + i).map(([, p])=>p).join(" ");
            }
            return u.slice(f).map(([, p])=>p).join(" ");
        }
        let a = [
            ...n
        ], l = s;
        if (l < 0 && (l = Math.max(0, a.length + l)), i !== void 0) {
            if (i < 0) {
                let c = a.length + i;
                return a.slice(l, Math.max(l, c)).join("");
            }
            return a.slice(l, l + i).join("");
        }
        return a.slice(l).join("");
    }
    async function Ag(e, t, n, r, s) {
        if (n.pattern) {
            let i = e.state.shoptOptions.extglob, o = "";
            for (let f of n.pattern.parts)if (f.type === "Glob") o += ce(f.pattern, true, i);
            else if (f.type === "Literal") o += ce(f.value, true, i);
            else if (f.type === "SingleQuoted" || f.type === "Escaped") o += pe(f.value);
            else if (f.type === "DoubleQuoted") {
                let p = await r(e, f.parts);
                o += pe(p);
            } else if (f.type === "ParameterExpansion") {
                let p = await s(e, f);
                o += ce(p, true, i);
            }
            let a = new RegExp(`^(?:${o})$`), l = n.direction === "upper" ? (f)=>f.toUpperCase() : (f)=>f.toLowerCase(), c = "", u = false;
            for (let f of t)!n.all && u ? c += f : a.test(f) ? (c += l(f), u = true) : c += f;
            return c;
        }
        return n.direction === "upper" ? n.all ? t.toUpperCase() : t.charAt(0).toUpperCase() + t.slice(1) : n.all ? t.toLowerCase() : t.charAt(0).toLowerCase() + t.slice(1);
    }
    function Cg(e, t, n, r, s) {
        let i = t.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
        if (i && s.operator === "Q") return te(e, i[1]).map(([, c])=>sn(c)).join(" ");
        if (i && s.operator === "a") return an(e, i[1]);
        let o = t.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[.+\]$/);
        if (o && s.operator === "a") return an(e, o[1]);
        switch(s.operator){
            case "Q":
                return r ? "" : sn(n);
            case "P":
                return Mr(e, n);
            case "a":
                return an(e, t);
            case "A":
                return r ? "" : `${t}=${sn(n)}`;
            case "E":
                return n.replace(/\\([\\abefnrtv'"?])/g, (a, l)=>{
                    switch(l){
                        case "\\":
                            return "\\";
                        case "a":
                            return "\x07";
                        case "b":
                            return "\b";
                        case "e":
                            return "\x1B";
                        case "f":
                            return "\f";
                        case "n":
                            return `
`;
                        case "r":
                            return "\r";
                        case "t":
                            return "	";
                        case "v":
                            return "\v";
                        case "'":
                            return "'";
                        case '"':
                            return '"';
                        case "?":
                            return "?";
                        default:
                            return l;
                    }
                });
            case "K":
            case "k":
                return r ? "" : sn(n);
            case "u":
                return n.charAt(0).toUpperCase() + n.slice(1);
            case "U":
                return n.toUpperCase();
            case "L":
                return n.toLowerCase();
            default:
                return n;
        }
    }
    async function Ng(e, t, n, r, s, i, o = false) {
        if (Se(e, t)) return kn(e, t) || "";
        let a = /^[a-zA-Z_][a-zA-Z0-9_]*\[([@*])\]$/.test(t);
        if (r) {
            if (s.innerOp?.type === "UseAlternative") return "";
            throw new nt(`\${!${t}}`);
        }
        let l = n;
        if (a && (l === "" || l.includes(" "))) throw new nt(`\${!${t}}`);
        let c = l.match(/^[a-zA-Z_][a-zA-Z0-9_]*\[(.+)\]$/);
        if (c && c[1].includes("~")) throw new nt(`\${!${t}}`);
        if (s.innerOp) {
            let u = {
                type: "ParameterExpansion",
                parameter: l,
                operation: s.innerOp
            };
            return i(e, u, o);
        }
        return await me(e, l);
    }
    function kg(e, t) {
        let r = te(e, t.array).map(([s])=>String(s));
        return t.star ? r.join(oe(e.state.env)) : r.join(" ");
    }
    function vg(e, t) {
        let n = sr(e, t.prefix);
        return t.star ? n.join(oe(e.state.env)) : n.join(" ");
    }
    function $g(e, t, n, r) {
        let s = Number.parseInt(e.state.env["#"] || "0", 10), i = t.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
        if (t === "*") return {
            isEmpty: s === 0,
            effectiveValue: n
        };
        if (t === "@") return {
            isEmpty: s === 0 || s === 1 && e.state.env[1] === "",
            effectiveValue: n
        };
        if (i) {
            let [, o, a] = i, l = te(e, o);
            if (l.length === 0) return {
                isEmpty: true,
                effectiveValue: ""
            };
            if (a === "*") {
                let c = oe(e.state.env), u = l.map(([, f])=>f).join(c);
                return {
                    isEmpty: r ? u === "" : false,
                    effectiveValue: u
                };
            }
            return {
                isEmpty: l.length === 1 && l.every(([, c])=>c === ""),
                effectiveValue: l.map(([, c])=>c).join(" ")
            };
        }
        return {
            isEmpty: n === "",
            effectiveValue: n
        };
    }
    var Ig = v(()=>{
        Je();
        Fe();
        it();
        de();
        St();
        Tt();
        nr();
        rr();
        vn();
        Va();
        qa();
        ht();
        ai();
    });
    function Rg(e) {
        let t = 0;
        for(; t < e.length;){
            let n = e[t];
            if (n === "\\" && t + 1 < e.length) {
                t += 2;
                continue;
            }
            if (n === "'") {
                let r = e.indexOf("'", t + 1);
                if (r !== -1) {
                    t = r + 1;
                    continue;
                }
            }
            if (n === "$" && t + 1 < e.length && e[t + 1] === "(" || n === "`") return true;
            t++;
        }
        return false;
    }
    function Pg(e, t) {
        let n = 1, r = t, s = false, i = false;
        for(; r < e.length && n > 0;){
            let o = e[r];
            if (o === "\\" && !s && r + 1 < e.length) {
                r += 2;
                continue;
            }
            if (o === "'" && !i) {
                s = !s, r++;
                continue;
            }
            if (o === '"' && !s) {
                i = !i, r++;
                continue;
            }
            if (!s && !i) {
                if (o === "(") n++;
                else if (o === ")" && (n--, n === 0)) return r;
            }
            r++;
        }
        return -1;
    }
    async function li(e, t) {
        let n = new se(), r;
        try {
            r = n.parse(t);
        } catch  {
            return "";
        }
        let s = e.state.bashPid;
        e.state.bashPid = e.state.nextVirtualPid++;
        let i = {
            ...e.state.env
        }, o = e.state.cwd, a = e.state.suppressVerbose;
        e.state.suppressVerbose = true;
        try {
            let l = await e.executeScript(r), c = l.exitCode;
            return e.state.env = i, e.state.cwd = o, e.state.suppressVerbose = a, e.state.lastExitCode = c, e.state.env["?"] = String(c), l.stderr && (e.state.expansionStderr = (e.state.expansionStderr || "") + l.stderr), e.state.bashPid = s, l.stdout.replace(/\n+$/, "");
        } catch (l) {
            if (e.state.env = i, e.state.cwd = o, e.state.bashPid = s, e.state.suppressVerbose = a, l instanceof ne) throw l;
            return l instanceof ae ? (e.state.lastExitCode = l.exitCode, e.state.env["?"] = String(l.exitCode), l.stdout?.replace(/\n+$/, "") ?? "") : "";
        }
    }
    function Ga(e, t) {
        let n = "", r = 0;
        for(; r < t.length;){
            let s = t[r];
            if (s === "'") {
                let i = t.indexOf("'", r + 1);
                if (i !== -1) {
                    let o = t.slice(r + 1, i);
                    n += mt(o), r = i + 1;
                    continue;
                }
            }
            if (s === '"') {
                let i = -1, o = r + 1;
                for(; o < t.length;){
                    if (t[o] === "\\") {
                        o += 2;
                        continue;
                    }
                    if (t[o] === '"') {
                        i = o;
                        break;
                    }
                    o++;
                }
                if (i !== -1) {
                    let a = t.slice(r + 1, i), l = KC(e, a);
                    n += mt(l), r = i + 1;
                    continue;
                }
            }
            if (s === "$" && r + 1 < t.length) {
                let i = t[r + 1];
                if (i === "{") {
                    let o = t.indexOf("}", r + 2);
                    if (o !== -1) {
                        let a = t.slice(r + 2, o);
                        n += e.state.env[a] ?? "", r = o + 1;
                        continue;
                    }
                } else if (/[a-zA-Z_]/.test(i)) {
                    let o = r + 1;
                    for(; o < t.length && /[a-zA-Z0-9_]/.test(t[o]);)o++;
                    let a = t.slice(r + 1, o);
                    n += e.state.env[a] ?? "", r = o;
                    continue;
                }
            }
            if (s === "\\" && r + 1 < t.length) {
                n += s + t[r + 1], r += 2;
                continue;
            }
            n += s, r++;
        }
        return n;
    }
    function KC(e, t) {
        let n = "", r = 0;
        for(; r < t.length;){
            let s = t[r];
            if (s === "\\" && r + 1 < t.length) {
                let i = t[r + 1];
                if (i === "$" || i === "`" || i === "\\" || i === '"') {
                    n += i, r += 2;
                    continue;
                }
                n += s, r++;
                continue;
            }
            if (s === "$" && r + 1 < t.length) {
                let i = t[r + 1];
                if (i === "{") {
                    let o = t.indexOf("}", r + 2);
                    if (o !== -1) {
                        let a = t.slice(r + 2, o);
                        n += e.state.env[a] ?? "", r = o + 1;
                        continue;
                    }
                } else if (/[a-zA-Z_]/.test(i)) {
                    let o = r + 1;
                    for(; o < t.length && /[a-zA-Z0-9_]/.test(t[o]);)o++;
                    let a = t.slice(r + 1, o);
                    n += e.state.env[a] ?? "", r = o;
                    continue;
                }
            }
            n += s, r++;
        }
        return n;
    }
    async function Tg(e, t) {
        let n = "", r = 0;
        for(; r < t.length;){
            let s = t[r];
            if (s === "'") {
                let i = t.indexOf("'", r + 1);
                if (i !== -1) {
                    let o = t.slice(r + 1, i);
                    n += mt(o), r = i + 1;
                    continue;
                }
            }
            if (s === '"') {
                let i = -1, o = r + 1;
                for(; o < t.length;){
                    if (t[o] === "\\") {
                        o += 2;
                        continue;
                    }
                    if (t[o] === '"') {
                        i = o;
                        break;
                    }
                    o++;
                }
                if (i !== -1) {
                    let a = t.slice(r + 1, i), l = await XC(e, a);
                    n += mt(l), r = i + 1;
                    continue;
                }
            }
            if (s === "$" && r + 1 < t.length && t[r + 1] === "(") {
                let i = Pg(t, r + 2);
                if (i !== -1) {
                    let o = t.slice(r + 2, i), a = await li(e, o);
                    n += a, r = i + 1;
                    continue;
                }
            }
            if (s === "`") {
                let i = t.indexOf("`", r + 1);
                if (i !== -1) {
                    let o = t.slice(r + 1, i), a = await li(e, o);
                    n += a, r = i + 1;
                    continue;
                }
            }
            if (s === "$" && r + 1 < t.length) {
                let i = t[r + 1];
                if (i === "{") {
                    let o = t.indexOf("}", r + 2);
                    if (o !== -1) {
                        let a = t.slice(r + 2, o);
                        n += e.state.env[a] ?? "", r = o + 1;
                        continue;
                    }
                } else if (/[a-zA-Z_]/.test(i)) {
                    let o = r + 1;
                    for(; o < t.length && /[a-zA-Z0-9_]/.test(t[o]);)o++;
                    let a = t.slice(r + 1, o);
                    n += e.state.env[a] ?? "", r = o;
                    continue;
                }
            }
            if (s === "\\" && r + 1 < t.length) {
                n += s + t[r + 1], r += 2;
                continue;
            }
            n += s, r++;
        }
        return n;
    }
    async function XC(e, t) {
        let n = "", r = 0;
        for(; r < t.length;){
            let s = t[r];
            if (s === "\\" && r + 1 < t.length) {
                let i = t[r + 1];
                if (i === "$" || i === "`" || i === "\\" || i === '"') {
                    n += i, r += 2;
                    continue;
                }
                n += s, r++;
                continue;
            }
            if (s === "$" && r + 1 < t.length && t[r + 1] === "(") {
                let i = Pg(t, r + 2);
                if (i !== -1) {
                    let o = t.slice(r + 2, i), a = await li(e, o);
                    n += a, r = i + 1;
                    continue;
                }
            }
            if (s === "`") {
                let i = t.indexOf("`", r + 1);
                if (i !== -1) {
                    let o = t.slice(r + 1, i), a = await li(e, o);
                    n += a, r = i + 1;
                    continue;
                }
            }
            if (s === "$" && r + 1 < t.length) {
                let i = t[r + 1];
                if (i === "{") {
                    let o = t.indexOf("}", r + 2);
                    if (o !== -1) {
                        let a = t.slice(r + 2, o);
                        n += e.state.env[a] ?? "", r = o + 1;
                        continue;
                    }
                } else if (/[a-zA-Z_]/.test(i)) {
                    let o = r + 1;
                    for(; o < t.length && /[a-zA-Z0-9_]/.test(t[o]);)o++;
                    let a = t.slice(r + 1, o);
                    n += e.state.env[a] ?? "", r = o;
                    continue;
                }
            }
            n += s, r++;
        }
        return n;
    }
    var Og = v(()=>{
        Fe();
        de();
        tr();
    });
    function Dg(e, t) {
        if (!t.startsWith("~")) return t;
        let n = e.state.env.HOME !== void 0 ? e.state.env.HOME : "/home/user";
        if (t === "~" || t.startsWith("~/")) return n + t.slice(1);
        let r = 1;
        for(; r < t.length && /[a-zA-Z0-9_-]/.test(t[r]);)r++;
        let s = t.slice(1, r), i = t.slice(r);
        return i !== "" && !i.startsWith("/") ? t : s === "root" ? `/root${i}` : t;
    }
    var Fg = v(()=>{});
    async function JC(e, t, n, r) {
        let s = "";
        for (let i of t.parts)if (i.type === "Glob") s += ce(i.pattern, true, e.state.shoptOptions.extglob);
        else if (i.type === "Literal") s += ce(i.value, true, e.state.shoptOptions.extglob);
        else if (i.type === "SingleQuoted" || i.type === "Escaped") s += pe(i.value);
        else if (i.type === "DoubleQuoted") {
            let o = await n(e, i.parts);
            s += pe(o);
        } else if (i.type === "ParameterExpansion") {
            let o = await r(e, i);
            s += ce(o, true, e.state.shoptOptions.extglob);
        } else {
            let o = await r(e, i);
            s += pe(o);
        }
        return s;
    }
    async function _g(e, t, n, r) {
        if (t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let s = t[0];
        if (s.parts.length !== 1 || s.parts[0].type !== "ParameterExpansion" || s.parts[0].operation?.type !== "PatternReplacement") return null;
        let i = s.parts[0], o = i.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
        if (!o) return null;
        let a = o[1], l = o[2] === "*", c = i.operation, u = te(e, a), f = u.map(([, g])=>g);
        if (u.length === 0) {
            let g = e.state.env[a];
            g !== void 0 && f.push(g);
        }
        if (f.length === 0) return {
            values: [],
            quoted: true
        };
        let p = "";
        c.pattern && (p = await JC(e, c.pattern, n, r));
        let d = c.replacement ? await n(e, c.replacement.parts) : "", m = p;
        c.anchor === "start" ? m = `^${p}` : c.anchor === "end" && (m = `${p}$`);
        let h = [];
        try {
            let g = new RegExp(m, c.all ? "g" : "");
            for (let b of f)h.push(b.replace(g, d));
        } catch  {
            h.push(...f);
        }
        if (l) {
            let g = oe(e.state.env);
            return {
                values: [
                    h.join(g)
                ],
                quoted: true
            };
        }
        return {
            values: h,
            quoted: true
        };
    }
    async function Lg(e, t, n, r) {
        if (t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let s = t[0];
        if (s.parts.length !== 1 || s.parts[0].type !== "ParameterExpansion" || s.parts[0].operation?.type !== "PatternRemoval") return null;
        let i = s.parts[0], o = i.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
        if (!o) return null;
        let a = o[1], l = o[2] === "*", c = i.operation, u = te(e, a), f = u.map(([, h])=>h);
        if (u.length === 0) {
            let h = e.state.env[a];
            h !== void 0 && f.push(h);
        }
        if (f.length === 0) return {
            values: [],
            quoted: true
        };
        let p = "", d = e.state.shoptOptions.extglob;
        if (c.pattern) for (let h of c.pattern.parts)if (h.type === "Glob") p += ce(h.pattern, c.greedy, d);
        else if (h.type === "Literal") p += ce(h.value, c.greedy, d);
        else if (h.type === "SingleQuoted" || h.type === "Escaped") p += pe(h.value);
        else if (h.type === "DoubleQuoted") {
            let g = await n(e, h.parts);
            p += pe(g);
        } else if (h.type === "ParameterExpansion") {
            let g = await r(e, h);
            p += ce(g, c.greedy, d);
        } else {
            let g = await r(e, h);
            p += pe(g);
        }
        let m = [];
        for (let h of f)m.push(Kt(h, p, c.side, c.greedy));
        if (l) {
            let h = oe(e.state.env);
            return {
                values: [
                    m.join(h)
                ],
                quoted: true
            };
        }
        return {
            values: m,
            quoted: true
        };
    }
    var Mg = v(()=>{
        St();
        nr();
        rr();
        vn();
        ht();
    });
    async function Wg(e, t) {
        if (t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let n = t[0];
        if (n.parts.length !== 1 || n.parts[0].type !== "ParameterExpansion" || n.parts[0].operation?.type !== "DefaultValue" && n.parts[0].operation?.type !== "UseAlternative" && n.parts[0].operation?.type !== "AssignDefault") return null;
        let r = n.parts[0], s = r.operation, i = r.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/), o, a = false;
        if (i) {
            let l = i[1];
            a = i[2] === "*";
            let c = te(e, l), u = c.length > 0 || e.state.env[l] !== void 0, f = c.length === 0 || c.length === 1 && c.every(([, d])=>d === ""), p = s.checkEmpty ?? false;
            if (s.type === "UseAlternative" ? o = u && !(p && f) : o = !u || p && f, !o) {
                if (c.length > 0) {
                    let m = c.map(([, h])=>h);
                    if (a) {
                        let h = oe(e.state.env);
                        return {
                            values: [
                                m.join(h)
                            ],
                            quoted: true
                        };
                    }
                    return {
                        values: m,
                        quoted: true
                    };
                }
                let d = e.state.env[l];
                return d !== void 0 ? {
                    values: [
                        d
                    ],
                    quoted: true
                } : {
                    values: [],
                    quoted: true
                };
            }
        } else {
            let l = r.parameter, c = await zt(e, l), u = await me(e, l), f = u === "", p = s.checkEmpty ?? false;
            if (s.type === "UseAlternative" ? o = c && !(p && f) : o = !c || p && f, !o) return {
                values: [
                    u
                ],
                quoted: true
            };
        }
        if (o && s.word) {
            let l = s.word.parts, c = null, u = false;
            for (let f of l)if (f.type === "ParameterExpansion" && !f.operation) {
                let p = f.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
                if (p) {
                    c = p[1], u = p[2] === "*";
                    break;
                }
            }
            if (c) {
                let f = te(e, c);
                if (f.length > 0) {
                    let d = f.map(([, m])=>m);
                    if (u || a) {
                        let m = oe(e.state.env);
                        return {
                            values: [
                                d.join(m)
                            ],
                            quoted: true
                        };
                    }
                    return {
                        values: d,
                        quoted: true
                    };
                }
                let p = e.state.env[c];
                return p !== void 0 ? {
                    values: [
                        p
                    ],
                    quoted: true
                } : {
                    values: [],
                    quoted: true
                };
            }
        }
        return null;
    }
    async function Bg(e, t, n, r, s) {
        if (!n || t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let i = t[0], o = -1, a = "", l = false, c = null;
        for(let h = 0; h < i.parts.length; h++){
            let g = i.parts[h];
            if (g.type === "ParameterExpansion" && (g.operation?.type === "PatternRemoval" || g.operation?.type === "PatternReplacement")) {
                let b = g.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
                if (b) {
                    o = h, a = b[1], l = b[2] === "*", c = g.operation;
                    break;
                }
            }
        }
        if (o === -1 || o === 0 && o === i.parts.length - 1) return null;
        let u = "";
        for(let h = 0; h < o; h++)u += await r(e, i.parts[h]);
        let f = "";
        for(let h = o + 1; h < i.parts.length; h++)f += await r(e, i.parts[h]);
        let p = te(e, a), d = p.map(([, h])=>h);
        if (p.length === 0) {
            let h = e.state.env[a];
            if (h !== void 0) d = [
                h
            ];
            else {
                if (l) return {
                    values: [
                        u + f
                    ],
                    quoted: true
                };
                let g = u + f;
                return {
                    values: g ? [
                        g
                    ] : [],
                    quoted: true
                };
            }
        }
        if (c?.type === "PatternRemoval") {
            let h = c, g = "", b = e.state.shoptOptions.extglob;
            if (h.pattern) for (let y of h.pattern.parts)if (y.type === "Glob") g += ce(y.pattern, h.greedy, b);
            else if (y.type === "Literal") g += ce(y.value, h.greedy, b);
            else if (y.type === "SingleQuoted" || y.type === "Escaped") g += pe(y.value);
            else if (y.type === "DoubleQuoted") {
                let w = await s(e, y.parts);
                g += pe(w);
            } else if (y.type === "ParameterExpansion") {
                let w = await r(e, y);
                g += ce(w, h.greedy, b);
            } else {
                let w = await r(e, y);
                g += pe(w);
            }
            d = d.map((y)=>Kt(y, g, h.side, h.greedy));
        } else if (c?.type === "PatternReplacement") {
            let h = c, g = "";
            if (h.pattern) for (let w of h.pattern.parts)if (w.type === "Glob") g += ce(w.pattern, true, e.state.shoptOptions.extglob);
            else if (w.type === "Literal") g += ce(w.value, true, e.state.shoptOptions.extglob);
            else if (w.type === "SingleQuoted" || w.type === "Escaped") g += pe(w.value);
            else if (w.type === "DoubleQuoted") {
                let E = await s(e, w.parts);
                g += pe(E);
            } else if (w.type === "ParameterExpansion") {
                let E = await r(e, w);
                g += ce(E, true, e.state.shoptOptions.extglob);
            } else {
                let E = await r(e, w);
                g += pe(E);
            }
            let b = h.replacement ? await s(e, h.replacement.parts) : "", y = g;
            h.anchor === "start" ? y = `^${g}` : h.anchor === "end" && (y = `${g}$`);
            try {
                let w = new RegExp(y, h.all ? "g" : "");
                d = d.map((E)=>E.replace(w, b));
            } catch  {}
        }
        if (l) {
            let h = oe(e.state.env);
            return {
                values: [
                    u + d.join(h) + f
                ],
                quoted: true
            };
        }
        return d.length === 1 ? {
            values: [
                u + d[0] + f
            ],
            quoted: true
        } : {
            values: [
                u + d[0],
                ...d.slice(1, -1),
                d[d.length - 1] + f
            ],
            quoted: true
        };
    }
    async function Ug(e, t, n, r) {
        if (!n || t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let s = t[0], i = -1, o = "", a = false;
        for(let d = 0; d < s.parts.length; d++){
            let m = s.parts[d];
            if (m.type === "ParameterExpansion" && !m.operation) {
                let h = m.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
                if (h) {
                    i = d, o = h[1], a = h[2] === "*";
                    break;
                }
            }
        }
        if (i === -1) return null;
        let l = "";
        for(let d = 0; d < i; d++)l += await r(e, s.parts[d]);
        let c = "";
        for(let d = i + 1; d < s.parts.length; d++)c += await r(e, s.parts[d]);
        let u = te(e, o), f = u.map(([, d])=>d);
        if (u.length === 0) {
            let d = e.state.env[o];
            if (d !== void 0) return {
                values: [
                    l + d + c
                ],
                quoted: true
            };
            if (a) return {
                values: [
                    l + c
                ],
                quoted: true
            };
            let m = l + c;
            return {
                values: m ? [
                    m
                ] : [],
                quoted: true
            };
        }
        if (a) {
            let d = oe(e.state.env);
            return {
                values: [
                    l + f.join(d) + c
                ],
                quoted: true
            };
        }
        return f.length === 1 ? {
            values: [
                l + f[0] + c
            ],
            quoted: true
        } : {
            values: [
                l + f[0],
                ...f.slice(1, -1),
                f[f.length - 1] + c
            ],
            quoted: true
        };
    }
    var zg = v(()=>{
        St();
        nr();
        rr();
        vn();
        ht();
    });
    async function jg(e, t, n) {
        if (t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let r = t[0];
        if (r.parts.length !== 1 || r.parts[0].type !== "ParameterExpansion" || r.parts[0].operation?.type !== "Substring") return null;
        let s = r.parts[0], i = s.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
        if (!i) return null;
        let o = i[1], a = i[2] === "*", l = s.operation;
        if (e.state.associativeArrays?.has(o)) throw new ae(1, "", `bash: \${${o}[@]: 0: 3}: bad substitution
`);
        let c = l.offset ? await n(e, l.offset.expression) : 0, u = l.length ? await n(e, l.length.expression) : void 0, f = te(e, o), p = 0;
        if (c < 0) {
            if (f.length > 0) {
                let m = f[f.length - 1][0], g = (typeof m == "number" ? m : 0) + 1 + c;
                if (g < 0) return {
                    values: [],
                    quoted: true
                };
                p = f.findIndex(([b])=>typeof b == "number" && b >= g), p < 0 && (p = f.length);
            }
        } else p = f.findIndex(([m])=>typeof m == "number" && m >= c), p < 0 && (p = f.length);
        let d;
        if (u !== void 0) {
            if (u < 0) throw new Ee(`${o}[@]: substring expression < 0`);
            d = f.slice(p, p + u).map(([, m])=>m);
        } else d = f.slice(p).map(([, m])=>m);
        if (d.length === 0) return {
            values: [],
            quoted: true
        };
        if (a) {
            let m = oe(e.state.env);
            return {
                values: [
                    d.join(m)
                ],
                quoted: true
            };
        }
        return {
            values: d,
            quoted: true
        };
    }
    function Hg(e, t) {
        if (t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let n = t[0];
        if (n.parts.length !== 1 || n.parts[0].type !== "ParameterExpansion" || n.parts[0].operation?.type !== "Transform") return null;
        let r = n.parts[0], s = r.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
        if (!s) return null;
        let i = s[1], o = s[2] === "*", a = r.operation, l = te(e, i);
        if (l.length === 0) {
            let f = e.state.env[i];
            if (f !== void 0) {
                let p;
                switch(a.operator){
                    case "a":
                        p = "";
                        break;
                    case "P":
                        p = Mr(e, f);
                        break;
                    case "Q":
                        p = sn(f);
                        break;
                    default:
                        p = f;
                }
                return {
                    values: [
                        p
                    ],
                    quoted: true
                };
            }
            return o ? {
                values: [
                    ""
                ],
                quoted: true
            } : {
                values: [],
                quoted: true
            };
        }
        let c = an(e, i), u;
        switch(a.operator){
            case "a":
                u = l.map(()=>c);
                break;
            case "P":
                u = l.map(([, f])=>Mr(e, f));
                break;
            case "Q":
                u = l.map(([, f])=>sn(f));
                break;
            case "u":
                u = l.map(([, f])=>f.charAt(0).toUpperCase() + f.slice(1));
                break;
            case "U":
                u = l.map(([, f])=>f.toUpperCase());
                break;
            case "L":
                u = l.map(([, f])=>f.toLowerCase());
                break;
            default:
                u = l.map(([, f])=>f);
        }
        if (o) {
            let f = oe(e.state.env);
            return {
                values: [
                    u.join(f)
                ],
                quoted: true
            };
        }
        return {
            values: u,
            quoted: true
        };
    }
    var Vg = v(()=>{
        de();
        St();
        Va();
        qa();
        ht();
        ai();
    });
    function qg(e, t) {
        if (t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let n = t[0];
        if (n.parts.length !== 1 || n.parts[0].type !== "ParameterExpansion") return null;
        let r = n.parts[0];
        if (r.operation) return null;
        let s = r.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(@)\]$/);
        if (!s) return null;
        let i = s[1];
        if (Se(e, i)) {
            let l = kn(e, i);
            if (l?.endsWith("[@]") || l?.endsWith("[*]")) return {
                values: [],
                quoted: true
            };
        }
        let o = te(e, i);
        if (o.length > 0) return {
            values: o.map(([, l])=>l),
            quoted: true
        };
        let a = e.state.env[i];
        return a !== void 0 ? {
            values: [
                a
            ],
            quoted: true
        } : {
            values: [],
            quoted: true
        };
    }
    function Gg(e, t) {
        if (t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let n = t[0];
        if (n.parts.length !== 1 || n.parts[0].type !== "ParameterExpansion" || n.parts[0].operation) return null;
        let s = n.parts[0].parameter;
        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s) || !Se(e, s)) return null;
        let i = kn(e, s);
        if (!i) return null;
        let o = i.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(@)\]$/);
        if (!o) return null;
        let a = o[1], l = te(e, a);
        if (l.length > 0) return {
            values: l.map(([, u])=>u),
            quoted: true
        };
        let c = e.state.env[a];
        return c !== void 0 ? {
            values: [
                c
            ],
            quoted: true
        } : {
            values: [],
            quoted: true
        };
    }
    var Zg = v(()=>{
        Tt();
        ht();
    });
    async function Qg(e, t, n, r, s) {
        if (!n || t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let i = t[0];
        if (i.parts.length !== 1 || i.parts[0].type !== "ParameterExpansion" || i.parts[0].operation?.type !== "Indirection") return null;
        let o = i.parts[0], a = o.operation, l = await me(e, o.parameter), c = l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
        if (!c) {
            if (!a.innerOp && (l === "@" || l === "*")) {
                let m = Number.parseInt(e.state.env["#"] || "0", 10), h = [];
                for(let g = 1; g <= m; g++)h.push(e.state.env[String(g)] || "");
                return l === "*" ? {
                    values: [
                        h.join(oe(e.state.env))
                    ],
                    quoted: true
                } : {
                    values: h,
                    quoted: true
                };
            }
            return null;
        }
        let u = c[1], f = c[2] === "*", p = te(e, u);
        if (a.innerOp) {
            if (a.innerOp.type === "Substring") return YC(e, p, u, f, a.innerOp);
            if (a.innerOp.type === "DefaultValue" || a.innerOp.type === "UseAlternative" || a.innerOp.type === "AssignDefault" || a.innerOp.type === "ErrorIfUnset") return eN(e, p, u, f, a.innerOp, s);
            if (a.innerOp.type === "Transform" && a.innerOp.operator === "a") {
                let h = an(e, u), g = p.map(()=>h);
                return f ? {
                    values: [
                        g.join(oe(e.state.env))
                    ],
                    quoted: true
                } : {
                    values: g,
                    quoted: true
                };
            }
            let m = [];
            for (let [, h] of p){
                let g = {
                    type: "ParameterExpansion",
                    parameter: "_indirect_elem_",
                    operation: a.innerOp
                }, b = e.state.env._indirect_elem_;
                e.state.env._indirect_elem_ = h;
                try {
                    let y = await r(e, g, true);
                    m.push(y);
                } finally{
                    b !== void 0 ? e.state.env._indirect_elem_ = b : delete e.state.env._indirect_elem_;
                }
            }
            return f ? {
                values: [
                    m.join(oe(e.state.env))
                ],
                quoted: true
            } : {
                values: m,
                quoted: true
            };
        }
        if (p.length > 0) {
            let m = p.map(([, h])=>h);
            return f ? {
                values: [
                    m.join(oe(e.state.env))
                ],
                quoted: true
            } : {
                values: m,
                quoted: true
            };
        }
        let d = e.state.env[u];
        return d !== void 0 ? {
            values: [
                d
            ],
            quoted: true
        } : {
            values: [],
            quoted: true
        };
    }
    async function YC(e, t, n, r, s) {
        let i = s.offset ? await Q(e, s.offset.expression) : 0, o = s.length ? await Q(e, s.length.expression) : void 0, a = 0;
        if (i < 0) {
            if (t.length > 0) {
                let u = t[t.length - 1][0], p = (typeof u == "number" ? u : 0) + 1 + i;
                if (p < 0) return {
                    values: [],
                    quoted: true
                };
                if (a = t.findIndex(([d])=>typeof d == "number" && d >= p), a < 0) return {
                    values: [],
                    quoted: true
                };
            }
        } else if (a = t.findIndex(([u])=>typeof u == "number" && u >= i), a < 0) return {
            values: [],
            quoted: true
        };
        let l;
        if (o !== void 0) {
            if (o < 0) throw new Ee(`${n}[@]: substring expression < 0`);
            l = t.slice(a, a + o);
        } else l = t.slice(a);
        let c = l.map(([, u])=>u);
        return r ? {
            values: [
                c.join(oe(e.state.env))
            ],
            quoted: true
        } : {
            values: c,
            quoted: true
        };
    }
    async function eN(e, t, n, r, s, i) {
        let o = s.checkEmpty ?? false, a = t.map(([, u])=>u), l = t.length === 0, c = t.length === 0;
        if (s.type === "UseAlternative") return !c && !(o && l) && s.word ? {
            values: [
                await i(e, s.word.parts, true)
            ],
            quoted: true
        } : {
            values: [],
            quoted: true
        };
        if (s.type === "DefaultValue") return (c || o && l) && s.word ? {
            values: [
                await i(e, s.word.parts, true)
            ],
            quoted: true
        } : r ? {
            values: [
                a.join(oe(e.state.env))
            ],
            quoted: true
        } : {
            values: a,
            quoted: true
        };
        if (s.type === "AssignDefault") {
            if ((c || o && l) && s.word) {
                let f = await i(e, s.word.parts, true);
                return e.state.env[`${n}_0`] = f, e.state.env[`${n}__length`] = "1", {
                    values: [
                        f
                    ],
                    quoted: true
                };
            }
            return r ? {
                values: [
                    a.join(oe(e.state.env))
                ],
                quoted: true
            } : {
                values: a,
                quoted: true
            };
        }
        return r ? {
            values: [
                a.join(oe(e.state.env))
            ],
            quoted: true
        } : {
            values: a,
            quoted: true
        };
    }
    async function Kg(e, t) {
        if (t.length !== 1 || t[0].type !== "ParameterExpansion" || t[0].operation?.type !== "UseAlternative" && t[0].operation?.type !== "DefaultValue") return null;
        let n = t[0], r = n.operation, s = r?.word;
        if (!s || s.parts.length !== 1 || s.parts[0].type !== "DoubleQuoted") return null;
        let i = s.parts[0];
        if (i.parts.length !== 1 || i.parts[0].type !== "ParameterExpansion" || i.parts[0].operation?.type !== "Indirection") return null;
        let o = i.parts[0], l = (await me(e, o.parameter)).match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
        if (!l) return null;
        let c = await zt(e, n.parameter), u = await me(e, n.parameter) === "", f = r.checkEmpty ?? false, p;
        if (r.type === "UseAlternative" ? p = c && !(f && u) : p = !c || f && u, p) {
            let d = l[1], m = l[2] === "*", h = te(e, d);
            if (h.length > 0) {
                let b = h.map(([, y])=>y);
                return m ? {
                    values: [
                        b.join(oe(e.state.env))
                    ],
                    quoted: true
                } : {
                    values: b,
                    quoted: true
                };
            }
            let g = e.state.env[d];
            return g !== void 0 ? {
                values: [
                    g
                ],
                quoted: true
            } : {
                values: [],
                quoted: true
            };
        }
        return {
            values: [],
            quoted: false
        };
    }
    async function Xg(e, t) {
        if (t.length !== 1 || t[0].type !== "ParameterExpansion" || t[0].operation?.type !== "Indirection") return null;
        let n = t[0], s = n.operation.innerOp;
        if (!s || s.type !== "UseAlternative" && s.type !== "DefaultValue") return null;
        let i = s.word;
        if (!i || i.parts.length !== 1 || i.parts[0].type !== "DoubleQuoted") return null;
        let o = i.parts[0];
        if (o.parts.length !== 1 || o.parts[0].type !== "ParameterExpansion" || o.parts[0].operation?.type !== "Indirection") return null;
        let a = o.parts[0], c = (await me(e, a.parameter)).match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
        if (!c) return null;
        let u = await me(e, n.parameter), f = await zt(e, n.parameter), p = u === "", d = s.checkEmpty ?? false, m;
        if (s.type === "UseAlternative" ? m = f && !(d && p) : m = !f || d && p, m) {
            let h = c[1], g = c[2] === "*", b = te(e, h);
            if (b.length > 0) {
                let w = b.map(([, E])=>E);
                return g ? {
                    values: [
                        w.join(oe(e.state.env))
                    ],
                    quoted: true
                } : {
                    values: w,
                    quoted: true
                };
            }
            let y = e.state.env[h];
            return y !== void 0 ? {
                values: [
                    y
                ],
                quoted: true
            } : {
                values: [],
                quoted: true
            };
        }
        return {
            values: [],
            quoted: false
        };
    }
    var Jg = v(()=>{
        it();
        de();
        St();
        ht();
        ai();
    });
    function Yg(e) {
        let t = Number.parseInt(e.state.env["#"] || "0", 10), n = [];
        for(let r = 1; r <= t; r++)n.push(e.state.env[String(r)] || "");
        return n;
    }
    async function e0(e, t, n, r) {
        if (t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let s = t[0], i = -1, o = false;
        for(let y = 0; y < s.parts.length; y++){
            let w = s.parts[y];
            if (w.type === "ParameterExpansion" && (w.parameter === "@" || w.parameter === "*") && w.operation?.type === "Substring") {
                i = y, o = w.parameter === "*";
                break;
            }
        }
        if (i === -1) return null;
        let l = s.parts[i].operation, c = l.offset ? await n(e, l.offset.expression) : 0, u = l.length ? await n(e, l.length.expression) : void 0, f = Number.parseInt(e.state.env["#"] || "0", 10), p = [];
        for(let y = 1; y <= f; y++)p.push(e.state.env[String(y)] || "");
        let d = e.state.env[0] || "bash", m;
        if (c <= 0) {
            let y = [
                d,
                ...p
            ], w = y.length + c;
            if (w < 0) m = [];
            else {
                let E = c < 0 ? w : 0;
                if (u !== void 0) {
                    let C = u < 0 ? y.length + u : E + u;
                    m = y.slice(E, Math.max(E, C));
                } else m = y.slice(E);
            }
        } else {
            let y = c - 1;
            if (y >= p.length) m = [];
            else if (u !== void 0) {
                let w = u < 0 ? p.length + u : y + u;
                m = p.slice(y, Math.max(y, w));
            } else m = p.slice(y);
        }
        let h = "";
        for(let y = 0; y < i; y++)h += await r(e, s.parts[y]);
        let g = "";
        for(let y = i + 1; y < s.parts.length; y++)g += await r(e, s.parts[y]);
        if (m.length === 0) {
            let y = h + g;
            return {
                values: y ? [
                    y
                ] : [],
                quoted: true
            };
        }
        if (o) {
            let y = oe(e.state.env);
            return {
                values: [
                    h + m.join(y) + g
                ],
                quoted: true
            };
        }
        return m.length === 1 ? {
            values: [
                h + m[0] + g
            ],
            quoted: true
        } : {
            values: [
                h + m[0],
                ...m.slice(1, -1),
                m[m.length - 1] + g
            ],
            quoted: true
        };
    }
    async function t0(e, t, n, r) {
        if (t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let s = t[0], i = -1, o = false;
        for(let b = 0; b < s.parts.length; b++){
            let y = s.parts[b];
            if (y.type === "ParameterExpansion" && (y.parameter === "@" || y.parameter === "*") && y.operation?.type === "PatternReplacement") {
                i = b, o = y.parameter === "*";
                break;
            }
        }
        if (i === -1) return null;
        let l = s.parts[i].operation, c = Yg(e), u = "";
        for(let b = 0; b < i; b++)u += await n(e, s.parts[b]);
        let f = "";
        for(let b = i + 1; b < s.parts.length; b++)f += await n(e, s.parts[b]);
        if (c.length === 0) {
            let b = u + f;
            return {
                values: b ? [
                    b
                ] : [],
                quoted: true
            };
        }
        let p = "";
        if (l.pattern) for (let b of l.pattern.parts)if (b.type === "Glob") p += ce(b.pattern, true, e.state.shoptOptions.extglob);
        else if (b.type === "Literal") p += ce(b.value, true, e.state.shoptOptions.extglob);
        else if (b.type === "SingleQuoted" || b.type === "Escaped") p += pe(b.value);
        else if (b.type === "DoubleQuoted") {
            let y = await r(e, b.parts);
            p += pe(y);
        } else if (b.type === "ParameterExpansion") {
            let y = await n(e, b);
            p += ce(y, true, e.state.shoptOptions.extglob);
        } else {
            let y = await n(e, b);
            p += pe(y);
        }
        let d = l.replacement ? await r(e, l.replacement.parts) : "", m = p;
        l.anchor === "start" ? m = `^${p}` : l.anchor === "end" && (m = `${p}$`);
        let h = [];
        try {
            let b = new RegExp(m, l.all ? "g" : "");
            for (let y of c)h.push(y.replace(b, d));
        } catch  {
            h.push(...c);
        }
        if (o) {
            let b = oe(e.state.env);
            return {
                values: [
                    u + h.join(b) + f
                ],
                quoted: true
            };
        }
        return h.length === 1 ? {
            values: [
                u + h[0] + f
            ],
            quoted: true
        } : {
            values: [
                u + h[0],
                ...h.slice(1, -1),
                h[h.length - 1] + f
            ],
            quoted: true
        };
    }
    async function n0(e, t, n, r) {
        if (t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let s = t[0], i = -1, o = false;
        for(let g = 0; g < s.parts.length; g++){
            let b = s.parts[g];
            if (b.type === "ParameterExpansion" && (b.parameter === "@" || b.parameter === "*") && b.operation?.type === "PatternRemoval") {
                i = g, o = b.parameter === "*";
                break;
            }
        }
        if (i === -1) return null;
        let l = s.parts[i].operation, c = Yg(e), u = "";
        for(let g = 0; g < i; g++)u += await n(e, s.parts[g]);
        let f = "";
        for(let g = i + 1; g < s.parts.length; g++)f += await n(e, s.parts[g]);
        if (c.length === 0) {
            let g = u + f;
            return {
                values: g ? [
                    g
                ] : [],
                quoted: true
            };
        }
        let p = "", d = e.state.shoptOptions.extglob;
        if (l.pattern) for (let g of l.pattern.parts)if (g.type === "Glob") p += ce(g.pattern, l.greedy, d);
        else if (g.type === "Literal") p += ce(g.value, l.greedy, d);
        else if (g.type === "SingleQuoted" || g.type === "Escaped") p += pe(g.value);
        else if (g.type === "DoubleQuoted") {
            let b = await r(e, g.parts);
            p += pe(b);
        } else if (g.type === "ParameterExpansion") {
            let b = await n(e, g);
            p += ce(b, l.greedy, d);
        } else {
            let b = await n(e, g);
            p += pe(b);
        }
        let m = [];
        for (let g of c)m.push(Kt(g, p, l.side, l.greedy));
        if (o) {
            let g = oe(e.state.env);
            return {
                values: [
                    u + m.join(g) + f
                ],
                quoted: true
            };
        }
        return m.length === 1 ? {
            values: [
                u + m[0] + f
            ],
            quoted: true
        } : {
            values: [
                u + m[0],
                ...m.slice(1, -1),
                m[m.length - 1] + f
            ],
            quoted: true
        };
    }
    async function r0(e, t, n) {
        if (t.length !== 1 || t[0].type !== "DoubleQuoted") return null;
        let r = t[0], s = -1, i = false;
        for(let p = 0; p < r.parts.length; p++){
            let d = r.parts[p];
            if (d.type === "ParameterExpansion" && (d.parameter === "@" || d.parameter === "*")) {
                s = p, i = d.parameter === "*";
                break;
            }
        }
        if (s === -1) return null;
        let o = r.parts[s];
        if (o.type === "ParameterExpansion" && o.operation) return null;
        let a = Number.parseInt(e.state.env["#"] || "0", 10), l = "";
        for(let p = 0; p < s; p++)l += await n(e, r.parts[p]);
        let c = "";
        for(let p = s + 1; p < r.parts.length; p++)c += await n(e, r.parts[p]);
        if (a === 0) {
            if (i) return {
                values: [
                    l + c
                ],
                quoted: true
            };
            let p = l + c;
            return {
                values: p ? [
                    p
                ] : [],
                quoted: true
            };
        }
        let u = [];
        for(let p = 1; p <= a; p++)u.push(e.state.env[String(p)] || "");
        if (i) {
            let p = oe(e.state.env);
            return {
                values: [
                    l + u.join(p) + c
                ],
                quoted: true
            };
        }
        return u.length === 1 ? {
            values: [
                l + u[0] + c
            ],
            quoted: true
        } : {
            values: [
                l + u[0],
                ...u.slice(1, -1),
                u[u.length - 1] + c
            ],
            quoted: true
        };
    }
    var s0 = v(()=>{
        St();
        nr();
        rr();
        vn();
    });
    function tN(e) {
        return new rn(e.fs, e.state.cwd, e.state.env, {
            globstar: e.state.shoptOptions.globstar,
            nullglob: e.state.shoptOptions.nullglob,
            failglob: e.state.shoptOptions.failglob,
            dotglob: e.state.shoptOptions.dotglob,
            extglob: e.state.shoptOptions.extglob,
            globskipdots: e.state.shoptOptions.globskipdots
        });
    }
    async function ci(e, t) {
        if (e.state.options.noglob) return t;
        let n = tN(e), r = [];
        for (let s of t)if (jt(s, e.state.shoptOptions.extglob)) {
            let i = await n.expand(s);
            if (i.length > 0) r.push(...i);
            else {
                if (n.hasFailglob()) throw new _t(s);
                n.hasNullglob() || r.push(s);
            }
        } else r.push(s);
        return r;
    }
    async function i0(e, t, n, r) {
        let s = -1, i = "", o = false;
        for(let y = 0; y < t.length; y++){
            let w = t[y];
            if (w.type === "ParameterExpansion" && w.operation?.type === "PatternReplacement") {
                let E = w.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
                if (E) {
                    s = y, i = E[1], o = E[2] === "*";
                    break;
                }
            }
        }
        if (s === -1) return null;
        let l = t[s].operation, c = te(e, i), u = c.map(([, y])=>y);
        if (c.length === 0) {
            let y = e.state.env[i];
            y !== void 0 && (u = [
                y
            ]);
        }
        if (u.length === 0) return {
            values: [],
            quoted: false
        };
        let f = "";
        if (l.pattern) for (let y of l.pattern.parts)if (y.type === "Glob") f += ce(y.pattern, true, e.state.shoptOptions.extglob);
        else if (y.type === "Literal") f += ce(y.value, true, e.state.shoptOptions.extglob);
        else if (y.type === "SingleQuoted" || y.type === "Escaped") f += pe(y.value);
        else if (y.type === "DoubleQuoted") {
            let w = await n(e, y.parts);
            f += pe(w);
        } else if (y.type === "ParameterExpansion") {
            let w = await r(e, y);
            f += ce(w, true, e.state.shoptOptions.extglob);
        } else {
            let w = await r(e, y);
            f += pe(w);
        }
        let p = l.replacement ? await n(e, l.replacement.parts) : "", d = f;
        l.anchor === "start" ? d = `^${f}` : l.anchor === "end" && (d = `${f}$`);
        let m = [];
        try {
            let y = new RegExp(d, l.all ? "g" : "");
            for (let w of u)m.push(w.replace(y, p));
        } catch  {
            m.push(...u);
        }
        let h = Ue(e.state.env), g = Ze(e.state.env);
        if (o) {
            let y = oe(e.state.env), w = m.join(y);
            return g ? {
                values: w ? [
                    w
                ] : [],
                quoted: false
            } : {
                values: Ae(w, h),
                quoted: false
            };
        }
        if (g) return {
            values: m,
            quoted: false
        };
        let b = [];
        for (let y of m)y === "" ? b.push("") : b.push(...Ae(y, h));
        return {
            values: b,
            quoted: false
        };
    }
    async function o0(e, t, n, r) {
        let s = -1, i = "", o = false;
        for(let b = 0; b < t.length; b++){
            let y = t[b];
            if (y.type === "ParameterExpansion" && y.operation?.type === "PatternRemoval") {
                let w = y.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
                if (w) {
                    s = b, i = w[1], o = w[2] === "*";
                    break;
                }
            }
        }
        if (s === -1) return null;
        let l = t[s].operation, c = te(e, i), u = c.map(([, b])=>b);
        if (c.length === 0) {
            let b = e.state.env[i];
            b !== void 0 && (u = [
                b
            ]);
        }
        if (u.length === 0) return {
            values: [],
            quoted: false
        };
        let f = "", p = e.state.shoptOptions.extglob;
        if (l.pattern) for (let b of l.pattern.parts)if (b.type === "Glob") f += ce(b.pattern, l.greedy, p);
        else if (b.type === "Literal") f += ce(b.value, l.greedy, p);
        else if (b.type === "SingleQuoted" || b.type === "Escaped") f += pe(b.value);
        else if (b.type === "DoubleQuoted") {
            let y = await n(e, b.parts);
            f += pe(y);
        } else if (b.type === "ParameterExpansion") {
            let y = await r(e, b);
            f += ce(y, l.greedy, p);
        } else {
            let y = await r(e, b);
            f += pe(y);
        }
        let d = [];
        for (let b of u)d.push(Kt(b, f, l.side, l.greedy));
        let m = Ue(e.state.env), h = Ze(e.state.env);
        if (o) {
            let b = oe(e.state.env), y = d.join(b);
            return h ? {
                values: y ? [
                    y
                ] : [],
                quoted: false
            } : {
                values: Ae(y, m),
                quoted: false
            };
        }
        if (h) return {
            values: d,
            quoted: false
        };
        let g = [];
        for (let b of d)b === "" ? g.push("") : g.push(...Ae(b, m));
        return {
            values: g,
            quoted: false
        };
    }
    async function a0(e, t, n, r) {
        let s = -1, i = false;
        for(let g = 0; g < t.length; g++){
            let b = t[g];
            if (b.type === "ParameterExpansion" && (b.parameter === "@" || b.parameter === "*") && b.operation?.type === "PatternRemoval") {
                s = g, i = b.parameter === "*";
                break;
            }
        }
        if (s === -1) return null;
        let a = t[s].operation, l = Number.parseInt(e.state.env["#"] || "0", 10), c = [];
        for(let g = 1; g <= l; g++)c.push(e.state.env[String(g)] || "");
        if (c.length === 0) return {
            values: [],
            quoted: false
        };
        let u = "", f = e.state.shoptOptions.extglob;
        if (a.pattern) for (let g of a.pattern.parts)if (g.type === "Glob") u += ce(g.pattern, a.greedy, f);
        else if (g.type === "Literal") u += ce(g.value, a.greedy, f);
        else if (g.type === "SingleQuoted" || g.type === "Escaped") u += pe(g.value);
        else if (g.type === "DoubleQuoted") {
            let b = await n(e, g.parts);
            u += pe(b);
        } else if (g.type === "ParameterExpansion") {
            let b = await r(e, g);
            u += ce(b, a.greedy, f);
        } else {
            let b = await r(e, g);
            u += pe(b);
        }
        let p = [];
        for (let g of c)p.push(Kt(g, u, a.side, a.greedy));
        let d = Ue(e.state.env), m = Ze(e.state.env);
        if (i) {
            let g = oe(e.state.env), b = p.join(g);
            return m ? {
                values: b ? [
                    b
                ] : [],
                quoted: false
            } : {
                values: Ae(b, d),
                quoted: false
            };
        }
        if (m) return {
            values: p,
            quoted: false
        };
        let h = [];
        for (let g of p)g === "" ? h.push("") : h.push(...Ae(g, d));
        return {
            values: h,
            quoted: false
        };
    }
    async function l0(e, t, n, r) {
        let s = -1, i = false;
        for(let w = 0; w < t.length; w++){
            let E = t[w];
            if (E.type === "ParameterExpansion" && (E.parameter === "@" || E.parameter === "*") && E.operation?.type === "Substring") {
                s = w, i = E.parameter === "*";
                break;
            }
        }
        if (s === -1) return null;
        let a = t[s].operation, l = a.offset ? await n(e, a.offset.expression) : 0, c = a.length ? await n(e, a.length.expression) : void 0, u = Number.parseInt(e.state.env["#"] || "0", 10), f = [];
        for(let w = 1; w <= u; w++)f.push(e.state.env[String(w)] || "");
        let p = e.state.env[0] || "bash", d;
        if (l <= 0) {
            let w = [
                p,
                ...f
            ], E = w.length + l;
            if (E < 0) d = [];
            else {
                let C = l < 0 ? E : 0;
                if (c !== void 0) {
                    let A = c < 0 ? w.length + c : C + c;
                    d = w.slice(C, Math.max(C, A));
                } else d = w.slice(C);
            }
        } else {
            let w = l - 1;
            if (w >= f.length) d = [];
            else if (c !== void 0) {
                let E = c < 0 ? f.length + c : w + c;
                d = f.slice(w, Math.max(w, E));
            } else d = f.slice(w);
        }
        let m = "";
        for(let w = 0; w < s; w++)m += await r(e, t[w]);
        let h = "";
        for(let w = s + 1; w < t.length; w++)h += await r(e, t[w]);
        let g = Ue(e.state.env), b = Ze(e.state.env);
        if (d.length === 0) {
            let w = m + h;
            return w ? b ? {
                values: [
                    w
                ],
                quoted: false
            } : {
                values: Ae(w, g),
                quoted: false
            } : {
                values: [],
                quoted: false
            };
        }
        let y;
        if (i) {
            let w = oe(e.state.env), E = m + d.join(w) + h;
            b ? y = E ? [
                E
            ] : [] : y = Ae(E, g);
        } else if (b) d.length === 1 ? y = [
            m + d[0] + h
        ] : y = [
            m + d[0],
            ...d.slice(1, -1),
            d[d.length - 1] + h
        ];
        else {
            y = [];
            for(let w = 0; w < d.length; w++){
                let E = d[w];
                if (w === 0 && (E = m + E), w === d.length - 1 && (E = E + h), E === "") y.push("");
                else {
                    let C = Ae(E, g);
                    y.push(...C);
                }
            }
        }
        return {
            values: await ci(e, y),
            quoted: false
        };
    }
    async function c0(e, t) {
        if (t.length !== 1 || t[0].type !== "ParameterExpansion" || t[0].parameter !== "@" && t[0].parameter !== "*" || t[0].operation) return null;
        let n = t[0].parameter === "*", r = Number.parseInt(e.state.env["#"] || "0", 10);
        if (r === 0) return {
            values: [],
            quoted: false
        };
        let s = [];
        for(let c = 1; c <= r; c++)s.push(e.state.env[String(c)] || "");
        let i = Ue(e.state.env), o = Ze(e.state.env), a = ni(e.state.env), l;
        if (n) if (o) l = s.filter((c)=>c !== "");
        else {
            let c = oe(e.state.env), u = s.join(c);
            l = Ae(u, i);
        }
        else if (o) l = s.filter((c)=>c !== "");
        else if (a) {
            l = [];
            for (let c of s){
                if (c === "") continue;
                let u = Ae(c, i);
                l.push(...u);
            }
        } else {
            l = [];
            for (let c of s)if (c === "") l.push("");
            else {
                let u = Ae(c, i);
                l.push(...u);
            }
            for(; l.length > 0 && l[l.length - 1] === "";)l.pop();
        }
        return {
            values: await ci(e, l),
            quoted: false
        };
    }
    async function u0(e, t) {
        if (t.length !== 1 || t[0].type !== "ParameterExpansion" || t[0].operation) return null;
        let n = t[0].parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
        if (!n) return null;
        let r = n[1], s = n[2] === "*", i = te(e, r), o;
        if (i.length === 0) {
            let f = e.state.env[r];
            if (f !== void 0) o = [
                f
            ];
            else return {
                values: [],
                quoted: false
            };
        } else o = i.map(([, f])=>f);
        let a = Ue(e.state.env), l = Ze(e.state.env), c = ni(e.state.env), u;
        if (s) if (l) u = o.filter((f)=>f !== "");
        else {
            let f = oe(e.state.env), p = o.join(f);
            u = Ae(p, a);
        }
        else if (l) u = o.filter((f)=>f !== "");
        else if (c) {
            u = [];
            for (let f of o){
                if (f === "") continue;
                let p = Ae(f, a);
                u.push(...p);
            }
        } else {
            u = [];
            for (let f of o)if (f === "") u.push("");
            else {
                let p = Ae(f, a);
                u.push(...p);
            }
            for(; u.length > 0 && u[u.length - 1] === "";)u.pop();
        }
        return {
            values: await ci(e, u),
            quoted: false
        };
    }
    function f0(e, t) {
        if (t.length !== 1 || t[0].type !== "ParameterExpansion" || t[0].operation?.type !== "VarNamePrefix") return null;
        let n = t[0].operation, r = sr(e, n.prefix);
        if (r.length === 0) return {
            values: [],
            quoted: false
        };
        let s = Ue(e.state.env), i = Ze(e.state.env), o;
        if (n.star) if (i) o = r;
        else {
            let a = oe(e.state.env), l = r.join(a);
            o = Ae(l, s);
        }
        else if (i) o = r;
        else {
            o = [];
            for (let a of r){
                let l = Ae(a, s);
                o.push(...l);
            }
        }
        return {
            values: o,
            quoted: false
        };
    }
    function p0(e, t) {
        if (t.length !== 1 || t[0].type !== "ParameterExpansion" || t[0].operation?.type !== "ArrayKeys") return null;
        let n = t[0].operation, s = te(e, n.array).map(([l])=>String(l));
        if (s.length === 0) return {
            values: [],
            quoted: false
        };
        let i = Ue(e.state.env), o = Ze(e.state.env), a;
        if (n.star) if (o) a = s;
        else {
            let l = oe(e.state.env), c = s.join(l);
            a = Ae(c, i);
        }
        else if (o) a = s;
        else {
            a = [];
            for (let l of s){
                let c = Ae(l, i);
                a.push(...c);
            }
        }
        return {
            values: a,
            quoted: false
        };
    }
    async function d0(e, t, n) {
        let r = -1;
        for(let p = 0; p < t.length; p++){
            let d = t[p];
            if (d.type === "ParameterExpansion" && (d.parameter === "@" || d.parameter === "*") && !d.operation) {
                r = p;
                break;
            }
        }
        if (r === -1 || t.length <= 1) return null;
        let s = Number.parseInt(e.state.env["#"] || "0", 10), i = [];
        for(let p = 1; p <= s; p++)i.push(e.state.env[String(p)] || "");
        let o = "";
        for(let p = 0; p < r; p++)o += await n(e, t[p]);
        let a = "";
        for(let p = r + 1; p < t.length; p++)a += await n(e, t[p]);
        let l = Ue(e.state.env), c = Ze(e.state.env), u = ni(e.state.env);
        if (s === 0) {
            let p = o + a;
            return {
                values: p ? [
                    p
                ] : [],
                quoted: false
            };
        }
        let f;
        {
            let p = [];
            for(let d = 0; d < i.length; d++){
                let m = i[d];
                d === 0 && (m = o + m), d === i.length - 1 && (m = m + a), p.push(m);
            }
            if (c) f = p.filter((d)=>d !== "");
            else if (u) {
                f = [];
                for (let d of p){
                    if (d === "") continue;
                    let m = Ae(d, l);
                    f.push(...m);
                }
            } else {
                f = [];
                for (let d of p)if (d === "") f.push("");
                else {
                    let m = Ae(d, l);
                    f.push(...m);
                }
                for(; f.length > 0 && f[f.length - 1] === "";)f.pop();
            }
        }
        return f.length === 0 ? {
            values: [],
            quoted: false
        } : {
            values: await ci(e, f),
            quoted: false
        };
    }
    var h0 = v(()=>{
        Ys();
        de();
        St();
        nr();
        tr();
        rr();
        vn();
        ht();
    });
    async function y0(e, t, n) {
        let r = t.parts, { hasQuoted: s, hasCommandSub: i, hasArrayVar: o, hasArrayAtExpansion: a, hasParamExpansion: l, hasVarNamePrefixExpansion: c, hasIndirection: u } = Lr(r), p = n.hasBraceExpansion(r) ? await n.expandWordWithBracesAsync(e, t) : null;
        if (p && p.length > 1) return nN(e, p, s);
        let d = await rN(e, r, a, c, u, n);
        if (d !== null) return d;
        let m = await iN(e, r, n);
        if (m !== null) return m;
        let h = await oN(e, r, n);
        if (h !== null) return h;
        let g = await lN(e, r, n.expandPart);
        if (g !== null) return g0(e, g);
        if ((i || o || l) && !Ze(e.state.env)) {
            let y = Ue(e.state.env), w = n.buildIfsCharClassPattern(y), E = await n.smartWordSplit(e, r, y, w, n.expandPart);
            return g0(e, E);
        }
        let b = await n.expandWordAsync(e, t);
        return cN(e, t, r, b, s, n.expandWordForGlobbing);
    }
    async function nN(e, t, n) {
        let r = [];
        for (let s of t)if (!(!n && s === "")) if (!n && !e.state.options.noglob && jt(s, e.state.shoptOptions.extglob)) {
            let i = await ui(e, s);
            r.push(...i);
        } else r.push(s);
        return {
            values: r,
            quoted: false
        };
    }
    async function rN(e, t, n, r, s, i) {
        if (n) {
            let o = qg(e, t);
            if (o !== null) return o;
        }
        {
            let o = Gg(e, t);
            if (o !== null) return o;
        }
        {
            let o = await Wg(e, t);
            if (o !== null) return o;
        }
        {
            let o = await Bg(e, t, n, i.expandPart, i.expandWordPartsAsync);
            if (o !== null) return o;
        }
        {
            let o = await Ug(e, t, n, i.expandPart);
            if (o !== null) return o;
        }
        {
            let o = await jg(e, t, i.evaluateArithmetic);
            if (o !== null) return o;
        }
        {
            let o = Hg(e, t);
            if (o !== null) return o;
        }
        {
            let o = await _g(e, t, i.expandWordPartsAsync, i.expandPart);
            if (o !== null) return o;
        }
        {
            let o = await Lg(e, t, i.expandWordPartsAsync, i.expandPart);
            if (o !== null) return o;
        }
        if (r && t.length === 1 && t[0].type === "DoubleQuoted") {
            let o = sN(e, t);
            if (o !== null) return o;
        }
        {
            let o = await Qg(e, t, s, i.expandParameterAsync, i.expandWordPartsAsync);
            if (o !== null) return o;
        }
        {
            let o = await Kg(e, t);
            if (o !== null) return o;
        }
        {
            let o = await Xg(e, t);
            if (o !== null) return o;
        }
        return null;
    }
    function sN(e, t) {
        let n = t[0];
        if (n.type !== "DoubleQuoted") return null;
        if (n.parts.length === 1 && n.parts[0].type === "ParameterExpansion" && n.parts[0].operation?.type === "VarNamePrefix") {
            let r = n.parts[0].operation, s = sr(e, r.prefix);
            return r.star ? {
                values: [
                    s.join(oe(e.state.env))
                ],
                quoted: true
            } : {
                values: s,
                quoted: true
            };
        }
        if (n.parts.length === 1 && n.parts[0].type === "ParameterExpansion" && n.parts[0].operation?.type === "ArrayKeys") {
            let r = n.parts[0].operation, i = te(e, r.array).map(([o])=>String(o));
            return r.star ? {
                values: [
                    i.join(oe(e.state.env))
                ],
                quoted: true
            } : {
                values: i,
                quoted: true
            };
        }
        return null;
    }
    async function iN(e, t, n) {
        {
            let r = await e0(e, t, n.evaluateArithmetic, n.expandPart);
            if (r !== null) return r;
        }
        {
            let r = await t0(e, t, n.expandPart, n.expandWordPartsAsync);
            if (r !== null) return r;
        }
        {
            let r = await n0(e, t, n.expandPart, n.expandWordPartsAsync);
            if (r !== null) return r;
        }
        {
            let r = await r0(e, t, n.expandPart);
            if (r !== null) return r;
        }
        return null;
    }
    async function oN(e, t, n) {
        {
            let r = await i0(e, t, n.expandWordPartsAsync, n.expandPart);
            if (r !== null) return r;
        }
        {
            let r = await o0(e, t, n.expandWordPartsAsync, n.expandPart);
            if (r !== null) return r;
        }
        {
            let r = await a0(e, t, n.expandWordPartsAsync, n.expandPart);
            if (r !== null) return r;
        }
        {
            let r = await l0(e, t, n.evaluateArithmetic, n.expandPart);
            if (r !== null) return r;
        }
        {
            let r = await c0(e, t);
            if (r !== null) return r;
        }
        {
            let r = await u0(e, t);
            if (r !== null) return r;
        }
        {
            let r = f0(e, t);
            if (r !== null) return r;
        }
        {
            let r = p0(e, t);
            if (r !== null) return r;
        }
        {
            let r = await d0(e, t, n.expandPart);
            if (r !== null) return r;
        }
        return null;
    }
    function m0(e) {
        if (e.type !== "DoubleQuoted") return null;
        for(let t = 0; t < e.parts.length; t++){
            let n = e.parts[t];
            if (n.type !== "ParameterExpansion" || n.operation) continue;
            let r = n.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
            if (r) return {
                type: "array",
                name: r[1],
                atIndex: t,
                isStar: r[2] === "*"
            };
            if (n.parameter === "@" || n.parameter === "*") return {
                type: "positional",
                atIndex: t,
                isStar: n.parameter === "*"
            };
        }
        return null;
    }
    async function aN(e, t, n, r) {
        let s = "";
        for(let a = 0; a < n.atIndex; a++)s += await r(e, t.parts[a]);
        let i = "";
        for(let a = n.atIndex + 1; a < t.parts.length; a++)i += await r(e, t.parts[a]);
        let o;
        if (n.type === "array") {
            if (o = te(e, n.name).map(([, l])=>l), o.length === 0) {
                let l = e.state.env[n.name];
                l !== void 0 && (o = [
                    l
                ]);
            }
        } else {
            let a = Number.parseInt(e.state.env["#"] || "0", 10);
            o = [];
            for(let l = 1; l <= a; l++)o.push(e.state.env[String(l)] || "");
        }
        if (n.isStar) {
            let a = oe(e.state.env), l = o.join(a);
            return [
                s + l + i
            ];
        }
        if (o.length === 0) {
            let a = s + i;
            return a ? [
                a
            ] : [];
        }
        return o.length === 1 ? [
            s + o[0] + i
        ] : [
            s + o[0],
            ...o.slice(1, -1),
            o[o.length - 1] + i
        ];
    }
    async function lN(e, t, n) {
        if (t.length < 2) return null;
        let r = false;
        for (let l of t)if (m0(l)) {
            r = true;
            break;
        }
        if (!r) return null;
        let s = Ue(e.state.env), i = Ze(e.state.env), o = [];
        for (let l of t){
            let c = m0(l);
            if (c && l.type === "DoubleQuoted") {
                let u = await aN(e, l, c, n);
                o.push(u);
            } else if (l.type === "DoubleQuoted" || l.type === "SingleQuoted") {
                let u = await n(e, l);
                o.push([
                    u
                ]);
            } else if (l.type === "Literal") o.push([
                l.value
            ]);
            else if (l.type === "ParameterExpansion") {
                let u = await n(e, l);
                if (i) o.push(u ? [
                    u
                ] : []);
                else {
                    let f = Ae(u, s);
                    o.push(f);
                }
            } else {
                let u = await n(e, l);
                if (i) o.push(u ? [
                    u
                ] : []);
                else {
                    let f = Ae(u, s);
                    o.push(f);
                }
            }
        }
        let a = [];
        for (let l of o)if (l.length !== 0) if (a.length === 0) a.push(...l);
        else {
            let c = a.length - 1;
            a[c] = a[c] + l[0];
            for(let u = 1; u < l.length; u++)a.push(l[u]);
        }
        return a;
    }
    async function g0(e, t) {
        if (e.state.options.noglob) return {
            values: t,
            quoted: false
        };
        let n = [];
        for (let r of t)if (jt(r, e.state.shoptOptions.extglob)) {
            let s = await ui(e, r);
            n.push(...s);
        } else n.push(r);
        return {
            values: n,
            quoted: false
        };
    }
    async function ui(e, t) {
        let n = new rn(e.fs, e.state.cwd, e.state.env, {
            globstar: e.state.shoptOptions.globstar,
            nullglob: e.state.shoptOptions.nullglob,
            failglob: e.state.shoptOptions.failglob,
            dotglob: e.state.shoptOptions.dotglob,
            extglob: e.state.shoptOptions.extglob,
            globskipdots: e.state.shoptOptions.globskipdots
        }), r = await n.expand(t);
        if (r.length > 0) return r;
        if (n.hasFailglob()) throw new _t(t);
        return n.hasNullglob() ? [] : [
            t
        ];
    }
    async function cN(e, t, n, r, s, i) {
        let o = n.some((a)=>a.type === "Glob");
        if (!e.state.options.noglob && o) {
            let a = await i(e, t);
            if (jt(a, e.state.shoptOptions.extglob)) {
                let c = await ui(e, a);
                if (c.length > 0 && c[0] !== a) return {
                    values: c,
                    quoted: false
                };
                if (c.length === 0) return {
                    values: [],
                    quoted: false
                };
            }
            let l = Ha(r);
            if (!Ze(e.state.env)) {
                let c = Ue(e.state.env);
                return {
                    values: Ae(l, c),
                    quoted: false
                };
            }
            return {
                values: [
                    l
                ],
                quoted: false
            };
        }
        if (!s && !e.state.options.noglob && jt(r, e.state.shoptOptions.extglob)) {
            let a = await i(e, t);
            if (jt(a, e.state.shoptOptions.extglob)) {
                let l = await ui(e, a);
                if (l.length > 0 && l[0] !== a) return {
                    values: l,
                    quoted: false
                };
            }
        }
        if (r === "" && !s) return {
            values: [],
            quoted: false
        };
        if (o && !s) {
            let a = Ha(r);
            if (!Ze(e.state.env)) {
                let l = Ue(e.state.env);
                return {
                    values: Ae(a, l),
                    quoted: false
                };
            }
            return {
                values: [
                    a
                ],
                quoted: false
            };
        }
        return {
            values: [
                r
            ],
            quoted: s
        };
    }
    var b0 = v(()=>{
        Ys();
        de();
        St();
        ei();
        Mg();
        zg();
        Vg();
        Zg();
        tr();
        Jg();
        vn();
        s0();
        h0();
        ht();
    });
    async function x0(e, t) {
        let n = t.operation;
        if (!n || n.type !== "DefaultValue" && n.type !== "AssignDefault" && n.type !== "UseAlternative") return null;
        let r = n.word;
        if (!r || r.parts.length === 0) return null;
        let s = await zt(e, t.parameter), o = await me(e, t.parameter, false) === "", a = n.checkEmpty ?? false, l;
        return n.type === "UseAlternative" ? l = s && !(a && o) : l = !s || a && o, l ? r.parts : null;
    }
    function uN(e) {
        return e.type === "SingleQuoted" ? true : e.type === "DoubleQuoted" ? e.parts.every((n)=>n.type === "Literal") : false;
    }
    async function fN(e, t) {
        if (t.type !== "ParameterExpansion") return null;
        let n = await x0(e, t);
        if (!n || n.length <= 1) return null;
        let r = n.some((i)=>uN(i)), s = n.some((i)=>i.type === "Literal" || i.type === "ParameterExpansion" || i.type === "CommandSubstitution" || i.type === "ArithmeticExpansion");
        return r && s ? n : null;
    }
    function pN(e) {
        return e.type === "DoubleQuoted" || e.type === "SingleQuoted" || e.type === "Literal" ? false : e.type === "Glob" ? La(e.pattern) : !(!(e.type === "ParameterExpansion" || e.type === "CommandSubstitution" || e.type === "ArithmeticExpansion") || e.type === "ParameterExpansion" && rg(e));
    }
    async function E0(e, t, n, r, s) {
        if (t.length === 1 && t[0].type === "ParameterExpansion") {
            let p = t[0], d = await x0(e, p);
            if (d && d.length > 0 && d.length > 1 && d.some((h)=>h.type === "DoubleQuoted" || h.type === "SingleQuoted") && d.some((h)=>h.type === "Literal" || h.type === "ParameterExpansion" || h.type === "CommandSubstitution" || h.type === "ArithmeticExpansion")) return w0(e, d, n, r, s);
        }
        let i = [], o = false;
        for (let p of t){
            let d = pN(p), m = p.type === "DoubleQuoted" || p.type === "SingleQuoted", h = d ? await fN(e, p) : null, g = await s(e, p);
            i.push({
                value: g,
                isSplittable: d,
                isQuoted: m,
                mixedDefaultParts: h ?? void 0
            }), d && (o = true);
        }
        if (!o) {
            let p = i.map((d)=>d.value).join("");
            return p ? [
                p
            ] : [];
        }
        let a = [], l = "", c = false, u = false, f = false;
        for (let p of i)if (!p.isSplittable) u ? p.isQuoted && p.value === "" ? (l !== "" && a.push(l), a.push(""), c = true, l = "", u = false, f = true) : p.value !== "" ? (l !== "" && a.push(l), l = p.value, u = false, f = false) : (l += p.value, f = false) : (l += p.value, f = p.isQuoted && p.value === "");
        else if (p.mixedDefaultParts) {
            let d = await w0(e, p.mixedDefaultParts, n, r, s);
            if (d.length !== 0) if (d.length === 1) l += d[0], c = true;
            else {
                l += d[0], a.push(l), c = true;
                for(let m = 1; m < d.length - 1; m++)a.push(d[m]);
                l = d[d.length - 1];
            }
            u = false, f = false;
        } else {
            let { words: d, hadLeadingDelimiter: m, hadTrailingDelimiter: h } = ri(p.value, n);
            if (f && m && l === "" && (a.push(""), c = true), d.length === 0) h && (u = true);
            else if (d.length === 1) l += d[0], c = true, u = h;
            else {
                l += d[0], a.push(l), c = true;
                for(let g = 1; g < d.length - 1; g++)a.push(d[g]);
                l = d[d.length - 1], u = h;
            }
            f = false;
        }
        return l !== "" ? a.push(l) : a.length === 0 && c && a.push(""), a;
    }
    function dN(e, t) {
        return e.length > 0 && t.includes(e[0]);
    }
    async function w0(e, t, n, r, s) {
        let i = [];
        for (let u of t){
            let p = !(u.type === "DoubleQuoted" || u.type === "SingleQuoted"), d = await s(e, u);
            i.push({
                value: d,
                isSplittable: p
            });
        }
        let o = [], a = "", l = false, c = false;
        for (let u of i)if (!u.isSplittable) c && u.value !== "" ? (a !== "" && o.push(a), a = u.value, c = false) : a += u.value;
        else {
            dN(u.value, n) && a !== "" && (o.push(a), a = "", l = true);
            let { words: p, hadTrailingDelimiter: d } = ri(u.value, n);
            if (p.length === 0) d && (c = true);
            else if (p.length === 1) a += p[0], l = true, c = d;
            else {
                a += p[0], o.push(a), l = true;
                for(let m = 1; m < p.length - 1; m++)o.push(p[m]);
                a = p[p.length - 1], c = d;
            }
        }
        return a !== "" ? o.push(a) : o.length === 0 && l && o.push(""), o;
    }
    var S0 = v(()=>{
        ht();
        St();
        ei();
    });
    function A0(e) {
        switch(e.type){
            case "Literal":
                return e.value;
            case "SingleQuoted":
                return e.value;
            case "Escaped":
                return e.value;
            default:
                return null;
        }
    }
    function C0(e) {
        switch(e.type){
            case "SingleQuoted":
            case "Escaped":
            case "DoubleQuoted":
                return true;
            case "Literal":
                return e.value === "";
            default:
                return false;
        }
    }
    var N0 = v(()=>{});
    var Ya = {};
    V(Ya, {
        escapeGlobChars: ()=>mt,
        escapeRegexChars: ()=>er,
        expandRedirectTarget: ()=>Br,
        expandWord: ()=>J,
        expandWordForPattern: ()=>Xa,
        expandWordForRegex: ()=>Ka,
        expandWordWithGlob: ()=>Ft,
        getArrayElements: ()=>te,
        getVariable: ()=>me,
        hasQuotedMultiValueAt: ()=>Wr,
        isArray: ()=>Qt,
        isWordFullyQuoted: ()=>Qa
    });
    async function Dt(e, t, n = false) {
        let r = [];
        for (let s of t)r.push(await At(e, s, n));
        return r.join("");
    }
    function hN(e) {
        return C0(e);
    }
    function Qa(e) {
        if (e.parts.length === 0) return true;
        for (let t of e.parts)if (!hN(t)) return false;
        return true;
    }
    function mN(e, t, n = false) {
        let r = A0(t);
        if (r !== null) return r;
        switch(t.type){
            case "TildeExpansion":
                return n ? t.user === null ? "~" : `~${t.user}` : t.user === null ? e.state.env.HOME !== void 0 ? e.state.env.HOME : "/home/user" : t.user === "root" ? "/root" : `~${t.user}`;
            case "Glob":
                return Ga(e, t.pattern);
            default:
                return null;
        }
    }
    async function J(e, t) {
        return Ja(e, t);
    }
    async function Ka(e, t) {
        let n = [];
        for (let r of t.parts)if (r.type === "Escaped") n.push(`\\${r.value}`);
        else if (r.type === "SingleQuoted") n.push(r.value);
        else if (r.type === "DoubleQuoted") {
            let s = await Dt(e, r.parts);
            n.push(s);
        } else if (r.type === "TildeExpansion") {
            let s = await At(e, r);
            n.push(er(s));
        } else n.push(await At(e, r));
        return n.join("");
    }
    async function Xa(e, t) {
        let n = [];
        for (let r of t.parts)if (r.type === "Escaped") {
            let s = r.value;
            "()|*?[]".includes(s) ? n.push(`\\${s}`) : n.push(s);
        } else if (r.type === "SingleQuoted") n.push(mt(r.value));
        else if (r.type === "DoubleQuoted") {
            let s = await Dt(e, r.parts);
            n.push(mt(s));
        } else n.push(await At(e, r));
        return n.join("");
    }
    async function k0(e, t) {
        let n = [];
        for (let r of t.parts)if (r.type === "SingleQuoted") n.push(mt(r.value));
        else if (r.type === "Escaped") {
            let s = r.value;
            "*?[]\\()|".includes(s) ? n.push(`\\${s}`) : n.push(s);
        } else if (r.type === "DoubleQuoted") {
            let s = await Dt(e, r.parts);
            n.push(mt(s));
        } else r.type === "Glob" ? Rg(r.pattern) ? n.push(await Tg(e, r.pattern)) : n.push(Ga(e, r.pattern)) : r.type === "Literal" ? n.push(r.value) : n.push(await At(e, r));
        return n.join("");
    }
    function pi(e) {
        for (let t of e)if (t.type === "BraceExpansion" || t.type === "DoubleQuoted" && pi(t.parts)) return true;
        return false;
    }
    async function v0(e, t, n = {
        count: 0
    }) {
        if (n.count > Za) return [
            []
        ];
        let r = [
            []
        ];
        for (let s of t)if (s.type === "BraceExpansion") {
            let i = [], o = false, a = "";
            for (let u of s.items)if (u.type === "Range") {
                let f = ja(u.start, u.end, u.step, u.startStr, u.endStr);
                if (f.expanded) for (let p of f.expanded)n.count++, i.push(p);
                else {
                    o = true, a = f.literal;
                    break;
                }
            } else {
                let f = await v0(e, u.word.parts, n);
                for (let p of f){
                    n.count++;
                    let d = [];
                    for (let m of p)typeof m == "string" ? d.push(m) : d.push(await At(e, m));
                    i.push(d.join(""));
                }
            }
            if (o) {
                for (let u of r)n.count++, u.push(a);
                continue;
            }
            if (r.length * i.length > gN || n.count > Za) return r;
            let c = [];
            for (let u of r)for (let f of i){
                if (n.count++, n.count > Za) return c.length > 0 ? c : r;
                c.push([
                    ...u,
                    f
                ]);
            }
            r = c;
        } else for (let i of r)n.count++, i.push(s);
        return r;
    }
    async function $0(e, t) {
        let n = t.parts;
        if (!pi(n)) return [
            await J(e, t)
        ];
        let r = await v0(e, n), s = [];
        for (let i of r){
            let o = [];
            for (let a of i)typeof a == "string" ? o.push(a) : o.push(await At(e, a));
            s.push(Dg(e, o.join("")));
        }
        return s;
    }
    function yN() {
        return {
            expandWordAsync: Ja,
            expandWordForGlobbing: k0,
            expandWordWithBracesAsync: $0,
            expandWordPartsAsync: Dt,
            expandPart: At,
            expandParameterAsync: fi,
            hasBraceExpansion: pi,
            evaluateArithmetic: Q,
            buildIfsCharClassPattern: sg,
            smartWordSplit: E0
        };
    }
    async function Ft(e, t) {
        return y0(e, t, yN());
    }
    function bN(e) {
        for (let t of e){
            if (t.type === "ParameterExpansion") return t.parameter;
            if (t.type === "Literal") return t.value;
        }
        return "";
    }
    function Wr(e, t) {
        if (Number.parseInt(e.state.env["#"] || "0", 10) < 2) return false;
        function r(s) {
            for (let i of s)if (i.type === "DoubleQuoted") {
                for (let o of i.parts)if (o.type === "ParameterExpansion" && o.parameter === "@" && !o.operation) return true;
            }
            return false;
        }
        return r(t.parts);
    }
    async function Br(e, t) {
        if (Wr(e, t)) return {
            error: `bash: $@: ambiguous redirect
`
        };
        let n = t.parts, { hasQuoted: r } = Lr(n);
        if (pi(n) && (await $0(e, t)).length > 1) return {
            error: `bash: ${n.map((d)=>d.type === "Literal" ? d.value : d.type === "BraceExpansion" ? `{${d.items.map((h)=>{
                    if (h.type === "Range") {
                        let g = h.step ? `..${h.step}` : "";
                        return `${h.startStr ?? h.start}..${h.endStr ?? h.end}${g}`;
                    }
                    return h.word.parts.map((g)=>g.type === "Literal" ? g.value : "").join("");
                }).join(",")}}` : "").join("")}: ambiguous redirect
`
        };
        let s = await Ja(e, t), { hasParamExpansion: i, hasCommandSub: o } = Lr(n);
        if ((i || o) && !r && !Ze(e.state.env)) {
            let f = Ue(e.state.env);
            if (Ae(s, f).length > 1) return {
                error: `bash: $${bN(n)}: ambiguous redirect
`
            };
        }
        if (r || e.state.options.noglob) return {
            target: s
        };
        let l = await k0(e, t);
        if (!jt(l, e.state.shoptOptions.extglob)) return {
            target: s
        };
        let c = new rn(e.fs, e.state.cwd, e.state.env, {
            globstar: e.state.shoptOptions.globstar,
            nullglob: e.state.shoptOptions.nullglob,
            failglob: e.state.shoptOptions.failglob,
            dotglob: e.state.shoptOptions.dotglob,
            extglob: e.state.shoptOptions.extglob,
            globskipdots: e.state.shoptOptions.globskipdots
        }), u = await c.expand(l);
        return u.length === 0 ? c.hasFailglob() ? {
            error: `bash: no match: ${s}
`
        } : {
            target: s
        } : u.length === 1 ? {
            target: u[0]
        } : {
            error: `bash: ${s}: ambiguous redirect
`
        };
    }
    async function Ja(e, t) {
        let n = t.parts, r = n.length;
        if (r === 1) return At(e, n[0]);
        let s = [];
        for(let i = 0; i < r; i++)s.push(await At(e, n[i]));
        return s.join("");
    }
    async function At(e, t, n = false) {
        if (t.type === "ParameterExpansion") return fi(e, t, n);
        let r = mN(e, t, n);
        if (r !== null) return r;
        switch(t.type){
            case "DoubleQuoted":
                {
                    let s = [];
                    for (let i of t.parts)s.push(await At(e, i, true));
                    return s.join("");
                }
            case "CommandSubstitution":
                {
                    let s = dg(t.body);
                    if (s) try {
                        let c = await J(e, s.target), u = c.startsWith("/") ? c : `${e.state.cwd}/${c}`, f = await e.fs.readFile(u);
                        return e.state.lastExitCode = 0, e.state.env["?"] = "0", f.replace(/\n+$/, "");
                    } catch  {
                        return e.state.lastExitCode = 1, e.state.env["?"] = "1", "";
                    }
                    let i = e.state.bashPid;
                    e.state.bashPid = e.state.nextVirtualPid++;
                    let o = {
                        ...e.state.env
                    }, a = e.state.cwd, l = e.state.suppressVerbose;
                    e.state.suppressVerbose = true;
                    try {
                        let c = await e.executeScript(t.body), u = c.exitCode;
                        return e.state.env = o, e.state.cwd = a, e.state.suppressVerbose = l, e.state.lastExitCode = u, e.state.env["?"] = String(u), c.stderr && (e.state.expansionStderr = (e.state.expansionStderr || "") + c.stderr), e.state.bashPid = i, c.stdout.replace(/\n+$/, "");
                    } catch (c) {
                        if (e.state.env = o, e.state.cwd = a, e.state.bashPid = i, e.state.suppressVerbose = l, c instanceof ne) throw c;
                        if (c instanceof ae) return e.state.lastExitCode = c.exitCode, e.state.env["?"] = String(c.exitCode), c.stderr && (e.state.expansionStderr = (e.state.expansionStderr || "") + c.stderr), c.stdout.replace(/\n+$/, "");
                        throw c;
                    }
                }
            case "ArithmeticExpansion":
                {
                    let s = t.expression.originalText;
                    if (s && /\$[a-zA-Z_][a-zA-Z0-9_]*(?![{[(])/.test(s)) {
                        let o = await ug(e, s), a = new se(), l = he(a, o);
                        return String(await Q(e, l.expression, true));
                    }
                    return String(await Q(e, t.expression.expression, true));
                }
            case "BraceExpansion":
                {
                    let s = [];
                    for (let i of t.items)if (i.type === "Range") {
                        let o = ja(i.start, i.end, i.step, i.startStr, i.endStr);
                        if (o.expanded) s.push(...o.expanded);
                        else return o.literal;
                    } else s.push(await J(e, i.word));
                    return s.join(" ");
                }
            default:
                return "";
        }
    }
    async function fi(e, t, n = false) {
        let { parameter: r } = t, { operation: s } = t, i = r.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
        if (i) {
            let [, p, d] = i;
            if (e.state.associativeArrays?.has(p) || d.includes("$(") || d.includes("`") || d.includes("${")) {
                let h = await za(e, d);
                r = `${p}[${h}]`;
            }
        } else if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r) && Se(e, r)) {
            let p = st(e, r);
            if (p && p !== r) {
                let d = p.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
                if (d) {
                    let [, m, h] = d;
                    if (e.state.associativeArrays?.has(m) || h.includes("$(") || h.includes("`") || h.includes("${")) {
                        let b = await za(e, h);
                        r = `${m}[${b}]`;
                    }
                }
            }
        }
        let o = s && (s.type === "DefaultValue" || s.type === "AssignDefault" || s.type === "UseAlternative" || s.type === "ErrorIfUnset"), a = await me(e, r, !o);
        if (!s) return a;
        let l = !await zt(e, r), { isEmpty: c, effectiveValue: u } = $g(e, r, a, n), f = {
            isUnset: l,
            isEmpty: c,
            effectiveValue: u,
            inDoubleQuotes: n
        };
        switch(s.type){
            case "DefaultValue":
                return mg(e, s, f, Dt);
            case "AssignDefault":
                return gg(e, r, s, f, Dt);
            case "ErrorIfUnset":
                return yg(e, r, s, f, Dt);
            case "UseAlternative":
                return bg(e, s, f, Dt);
            case "PatternRemoval":
                return wg(e, a, s, Dt, At);
            case "PatternReplacement":
                return xg(e, a, s, Dt, At);
            case "Length":
                return Eg(e, r, a);
            case "LengthSliceError":
                throw new nt(r);
            case "BadSubstitution":
                throw new nt(s.text);
            case "Substring":
                return Sg(e, r, a, s);
            case "CaseModification":
                return Ag(e, a, s, Dt, fi);
            case "Transform":
                return Cg(e, r, a, l, s);
            case "Indirection":
                return Ng(e, r, a, l, s, fi, n);
            case "ArrayKeys":
                return kg(e, s);
            case "VarNamePrefix":
                return vg(e, s);
            default:
                return a;
        }
    }
    var gN, Za, ot = v(()=>{
        Je();
        Fe();
        Ys();
        it();
        de();
        ei();
        fg();
        pg();
        hg();
        tr();
        Ig();
        Og();
        Fg();
        ht();
        b0();
        S0();
        St();
        Tt();
        N0();
        tr();
        ht();
        gN = 1e4, Za = 1e5;
    });
    function wN(e, t, n) {
        switch(n){
            case "+":
                return e + t;
            case "-":
                return e - t;
            case "*":
                return e * t;
            case "/":
                if (t === 0) throw new Ee("division by 0");
                return Math.trunc(e / t);
            case "%":
                if (t === 0) throw new Ee("division by 0");
                return e % t;
            case "**":
                if (t < 0) throw new Ee("exponent less than 0");
                return e ** t;
            case "<<":
                return e << t;
            case ">>":
                return e >> t;
            case "<":
                return e < t ? 1 : 0;
            case "<=":
                return e <= t ? 1 : 0;
            case ">":
                return e > t ? 1 : 0;
            case ">=":
                return e >= t ? 1 : 0;
            case "==":
                return e === t ? 1 : 0;
            case "!=":
                return e !== t ? 1 : 0;
            case "&":
                return e & t;
            case "|":
                return e | t;
            case "^":
                return e ^ t;
            case ",":
                return t;
            default:
                return 0;
        }
    }
    function I0(e, t, n) {
        switch(n){
            case "=":
                return t;
            case "+=":
                return e + t;
            case "-=":
                return e - t;
            case "*=":
                return e * t;
            case "/=":
                return t !== 0 ? Math.trunc(e / t) : 0;
            case "%=":
                return t !== 0 ? e % t : 0;
            case "<<=":
                return e << t;
            case ">>=":
                return e >> t;
            case "&=":
                return e & t;
            case "|=":
                return e | t;
            case "^=":
                return e ^ t;
            default:
                return t;
        }
    }
    function xN(e, t) {
        switch(t){
            case "-":
                return -e;
            case "+":
                return +e;
            case "!":
                return e === 0 ? 1 : 0;
            case "~":
                return ~e;
            default:
                return e;
        }
    }
    async function EN(e, t) {
        let n = e.state.env[t];
        if (n !== void 0) return n;
        let r = e.state.env[`${t}_0`];
        return r !== void 0 ? r : await me(e, t);
    }
    function SN(e) {
        if (!e) return 0;
        let t = Number.parseInt(e, 10);
        if (!Number.isNaN(t) && /^-?\d+$/.test(e.trim())) return t;
        let n = e.trim();
        if (!n) return 0;
        try {
            let r = new se(), { expr: s, pos: i } = Et(r, n, 0);
            if (i < n.length) {
                let o = n.slice(i).trim().split(/\s+/)[0];
                throw new Ee(`${n}: syntax error in expression (error token is "${o}")`);
            }
            return s.type === "ArithNumber" ? s.value : t || 0;
        } catch (r) {
            if (r instanceof Ee) throw r;
            let s = n.split(/\s+/).slice(1)[0] || n;
            throw new Ee(`${n}: syntax error in expression (error token is "${s}")`);
        }
    }
    async function el(e, t) {
        if (!t) return 0;
        let n = Number.parseInt(t, 10);
        if (!Number.isNaN(n) && /^-?\d+$/.test(t.trim())) return n;
        let r = t.trim();
        if (!r) return 0;
        let s = new se(), { expr: i, pos: o } = Et(s, r, 0);
        if (o < r.length) {
            let a = r.slice(o).trim(), l = a.split(/\s+/)[0] || a;
            throw new Ee(`syntax error in expression (error token is "${l}")`, "", "");
        }
        return await Q(e, i);
    }
    async function tl(e, t, n = new Set()) {
        if (n.has(t)) return 0;
        n.add(t);
        let r = await EN(e, t);
        if (!r) return 0;
        let s = Number.parseInt(r, 10);
        if (!Number.isNaN(s) && /^-?\d+$/.test(r.trim())) return s;
        let i = r.trim();
        if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(i)) return await tl(e, i, n);
        let o = new se(), { expr: a, pos: l } = Et(o, i, 0);
        if (l < i.length) {
            let c = i.slice(l).trim(), u = c.split(/\s+/)[0] || c;
            throw new Ee(`${i}: syntax error in expression (error token is "${u}")`);
        }
        return await Q(e, a);
    }
    async function di(e, t) {
        if (t.startsWith("#")) {
            let f = t.slice(1), p = f.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
            if (p) {
                let m = p[1], h = te(e, m);
                return String(h.length);
            }
            let d = e.state.env[f] || "";
            return String(d.length);
        }
        if (t.startsWith("!")) {
            let f = t.slice(1), p = e.state.env[f] || "";
            return e.state.env[p] || "";
        }
        let n = [
            ":-",
            ":=",
            ":?",
            ":+",
            "-",
            "=",
            "?",
            "+"
        ], r = -1, s = "";
        for (let f of n){
            let p = t.indexOf(f);
            p > 0 && (r === -1 || p < r) && (r = p, s = f);
        }
        if (r === -1) return await me(e, t);
        let i = t.slice(0, r), o = t.slice(r + s.length), a = e.state.env[i], l = a === void 0, c = a === "", u = s.startsWith(":");
        switch(s){
            case ":-":
            case "-":
                return l || u && c ? o : a || "";
            case ":=":
            case "=":
                return l || u && c ? (e.state.env[i] = o, o) : a || "";
            case ":+":
            case "+":
                return !(l || u && c) ? o : "";
            case ":?":
            case "?":
                {
                    if (l || u && c) throw new Error(o || `${i}: parameter null or not set`);
                    return a || "";
                }
            default:
                return a || "";
        }
    }
    async function Q(e, t, n = false) {
        switch(t.type){
            case "ArithNumber":
                if (Number.isNaN(t.value)) throw new Ee("value too great for base");
                return t.value;
            case "ArithVariable":
                return await tl(e, t.name);
            case "ArithSpecialVar":
                {
                    let s = (await me(e, t.name)).trim();
                    if (!s) return 0;
                    let i = Number.parseInt(s, 10);
                    if (!Number.isNaN(i) && /^-?\d+$/.test(s)) return i;
                    let o = new se(), { expr: a } = Et(o, s, 0);
                    return await Q(e, a);
                }
            case "ArithNested":
                return await Q(e, t.expression);
            case "ArithCommandSubst":
                {
                    if (e.execFn) {
                        let r = await e.execFn(t.command);
                        r.stderr && (e.state.expansionStderr = (e.state.expansionStderr || "") + r.stderr);
                        let s = r.stdout.trim();
                        return Number.parseInt(s, 10) || 0;
                    }
                    return 0;
                }
            case "ArithBracedExpansion":
                {
                    let r = await di(e, t.content);
                    return Number.parseInt(r, 10) || 0;
                }
            case "ArithDynamicBase":
                {
                    let r = await di(e, t.baseExpr), s = Number.parseInt(r, 10);
                    if (s < 2 || s > 64) return 0;
                    let i = `${s}#${t.value}`;
                    return Fr(i);
                }
            case "ArithDynamicNumber":
                {
                    let s = await di(e, t.prefix) + t.suffix;
                    return Fr(s);
                }
            case "ArithArrayElement":
                {
                    let r = e.state.associativeArrays?.has(t.array), s = async (i)=>{
                        let o = e.state.env[i];
                        return o !== void 0 ? await el(e, o) : 0;
                    };
                    if (t.stringKey !== void 0) return await s(`${t.array}_${t.stringKey}`);
                    if (r && t.index?.type === "ArithVariable" && !t.index.hasDollarPrefix) return await s(`${t.array}_${t.index.name}`);
                    if (r && t.index?.type === "ArithVariable" && t.index.hasDollarPrefix) {
                        let i = await me(e, t.index.name);
                        return await s(`${t.array}_${i}`);
                    }
                    if (t.index) {
                        let i = await Q(e, t.index, n);
                        if (i < 0) {
                            let l = te(e, t.array), c = e.state.currentLine;
                            if (l.length === 0) return e.state.expansionStderr = (e.state.expansionStderr || "") + `bash: line ${c}: ${t.array}: bad array subscript
`, 0;
                            let f = Math.max(...l.map(([p])=>typeof p == "number" ? p : 0)) + 1 + i;
                            if (f < 0) return e.state.expansionStderr = (e.state.expansionStderr || "") + `bash: line ${c}: ${t.array}: bad array subscript
`, 0;
                            i = f;
                        }
                        let o = `${t.array}_${i}`, a = e.state.env[o];
                        if (a !== void 0) return el(e, a);
                        if (i === 0) {
                            let l = e.state.env[t.array];
                            if (l !== void 0) return el(e, l);
                        }
                        if (e.state.options.nounset && !Object.keys(e.state.env).some((c)=>c === t.array || c.startsWith(`${t.array}_`))) throw new tt(`${t.array}[${i}]`);
                        return 0;
                    }
                    return 0;
                }
            case "ArithDoubleSubscript":
                throw new Ee("double subscript", "", "");
            case "ArithNumberSubscript":
                throw new Ee(`${t.number}${t.errorToken}: syntax error: invalid arithmetic operator (error token is "${t.errorToken}")`);
            case "ArithSyntaxError":
                throw new Ee(t.message, "", "", true);
            case "ArithSingleQuote":
                {
                    if (n) throw new Ee(`syntax error: operand expected (error token is "'${t.content}'")`);
                    return t.value;
                }
            case "ArithBinary":
                {
                    if (t.operator === "||") return await Q(e, t.left, n) || await Q(e, t.right, n) ? 1 : 0;
                    if (t.operator === "&&") return await Q(e, t.left, n) && await Q(e, t.right, n) ? 1 : 0;
                    let r = await Q(e, t.left, n), s = await Q(e, t.right, n);
                    return wN(r, s, t.operator);
                }
            case "ArithUnary":
                {
                    let r = await Q(e, t.operand, n);
                    if (t.operator === "++" || t.operator === "--") {
                        if (t.operand.type === "ArithVariable") {
                            let s = t.operand.name, i = Number.parseInt(await me(e, s), 10) || 0, o = t.operator === "++" ? i + 1 : i - 1;
                            return e.state.env[s] = String(o), t.prefix ? o : i;
                        }
                        if (t.operand.type === "ArithArrayElement") {
                            let s = t.operand.array, i = e.state.associativeArrays?.has(s), o;
                            if (t.operand.stringKey !== void 0) o = `${s}_${t.operand.stringKey}`;
                            else if (i && t.operand.index?.type === "ArithVariable" && !t.operand.index.hasDollarPrefix) o = `${s}_${t.operand.index.name}`;
                            else if (i && t.operand.index?.type === "ArithVariable" && t.operand.index.hasDollarPrefix) {
                                let c = await me(e, t.operand.index.name);
                                o = `${s}_${c}`;
                            } else if (t.operand.index) {
                                let c = await Q(e, t.operand.index, n);
                                o = `${s}_${c}`;
                            } else return r;
                            let a = Number.parseInt(e.state.env[o] || "0", 10) || 0, l = t.operator === "++" ? a + 1 : a - 1;
                            return e.state.env[o] = String(l), t.prefix ? l : a;
                        }
                        if (t.operand.type === "ArithConcat") {
                            let s = "";
                            for (let i of t.operand.parts)s += await ir(e, i, n);
                            if (s && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s)) {
                                let i = Number.parseInt(e.state.env[s] || "0", 10) || 0, o = t.operator === "++" ? i + 1 : i - 1;
                                return e.state.env[s] = String(o), t.prefix ? o : i;
                            }
                        }
                        if (t.operand.type === "ArithDynamicElement") {
                            let s = "";
                            if (t.operand.nameExpr.type === "ArithConcat") for (let i of t.operand.nameExpr.parts)s += await ir(e, i, n);
                            else t.operand.nameExpr.type === "ArithVariable" && (s = t.operand.nameExpr.hasDollarPrefix ? await me(e, t.operand.nameExpr.name) : t.operand.nameExpr.name);
                            if (s && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s)) {
                                let i = await Q(e, t.operand.subscript, n), o = `${s}_${i}`, a = Number.parseInt(e.state.env[o] || "0", 10) || 0, l = t.operator === "++" ? a + 1 : a - 1;
                                return e.state.env[o] = String(l), t.prefix ? l : a;
                            }
                        }
                        return r;
                    }
                    return xN(r, t.operator);
                }
            case "ArithTernary":
                return await Q(e, t.condition, n) ? await Q(e, t.consequent, n) : await Q(e, t.alternate, n);
            case "ArithAssignment":
                {
                    let r = t.variable, s = r;
                    if (t.stringKey !== void 0) s = `${r}_${t.stringKey}`;
                    else if (t.subscript) {
                        let l = e.state.associativeArrays?.has(r);
                        if (l && t.subscript.type === "ArithVariable" && !t.subscript.hasDollarPrefix) s = `${r}_${t.subscript.name}`;
                        else if (l && t.subscript.type === "ArithVariable" && t.subscript.hasDollarPrefix) {
                            let c = await me(e, t.subscript.name);
                            s = `${r}_${c || "\\"}`;
                        } else if (l) {
                            let c = await Q(e, t.subscript, n);
                            s = `${r}_${c}`;
                        } else {
                            let c = await Q(e, t.subscript, n);
                            if (c < 0) {
                                let u = te(e, r);
                                u.length > 0 && (c = Math.max(...u.map(([p])=>typeof p == "number" ? p : 0)) + 1 + c);
                            }
                            s = `${r}_${c}`;
                        }
                    }
                    let i = Number.parseInt(e.state.env[s] || "0", 10) || 0, o = await Q(e, t.value, n), a = I0(i, o, t.operator);
                    return e.state.env[s] = String(a), a;
                }
            case "ArithGroup":
                return await Q(e, t.expression, n);
            case "ArithConcat":
                {
                    let r = "";
                    for (let s of t.parts)r += await ir(e, s, n);
                    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r) ? await tl(e, r) : Number.parseInt(r, 10) || 0;
                }
            case "ArithDynamicAssignment":
                {
                    let r = "";
                    if (t.target.type === "ArithConcat") for (let l of t.target.parts)r += await ir(e, l, n);
                    else t.target.type === "ArithVariable" && (r = t.target.hasDollarPrefix ? await me(e, t.target.name) : t.target.name);
                    if (!r || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r)) return 0;
                    let s = r;
                    if (t.subscript) {
                        let l = await Q(e, t.subscript, n);
                        s = `${r}_${l}`;
                    }
                    let i = Number.parseInt(e.state.env[s] || "0", 10) || 0, o = await Q(e, t.value, n), a = I0(i, o, t.operator);
                    return e.state.env[s] = String(a), a;
                }
            case "ArithDynamicElement":
                {
                    let r = "";
                    if (t.nameExpr.type === "ArithConcat") for (let a of t.nameExpr.parts)r += await ir(e, a, n);
                    else t.nameExpr.type === "ArithVariable" && (r = t.nameExpr.hasDollarPrefix ? await me(e, t.nameExpr.name) : t.nameExpr.name);
                    if (!r || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r)) return 0;
                    let s = await Q(e, t.subscript, n), i = `${r}_${s}`, o = e.state.env[i];
                    return o !== void 0 ? SN(o) : 0;
                }
            default:
                return 0;
        }
    }
    async function ir(e, t, n = false) {
        switch(t.type){
            case "ArithNumber":
                return String(t.value);
            case "ArithSingleQuote":
                return String(await Q(e, t, n));
            case "ArithVariable":
                return t.hasDollarPrefix ? await me(e, t.name) : t.name;
            case "ArithSpecialVar":
                return await me(e, t.name);
            case "ArithBracedExpansion":
                return await di(e, t.content);
            case "ArithCommandSubst":
                return e.execFn ? (await e.execFn(t.command)).stdout.trim() : "0";
            case "ArithConcat":
                {
                    let r = "";
                    for (let s of t.parts)r += await ir(e, s, n);
                    return r;
                }
            default:
                return String(await Q(e, t, n));
        }
    }
    var it = v(()=>{
        Je();
        Fe();
        de();
        ot();
    });
    var aa = [
        {
            name: "echo",
            load: async ()=>(await Promise.resolve().then(()=>(Jl(), Xl))).echoCommand
        },
        {
            name: "cat",
            load: async ()=>(await Promise.resolve().then(()=>(ec(), Yl))).catCommand
        },
        {
            name: "printf",
            load: async ()=>(await Promise.resolve().then(()=>(cc(), lc))).printfCommand
        },
        {
            name: "ls",
            load: async ()=>(await Promise.resolve().then(()=>(dc(), pc))).lsCommand
        },
        {
            name: "mkdir",
            load: async ()=>(await Promise.resolve().then(()=>(mc(), hc))).mkdirCommand
        },
        {
            name: "rmdir",
            load: async ()=>(await Promise.resolve().then(()=>(wc(), bc))).rmdirCommand
        },
        {
            name: "touch",
            load: async ()=>(await Promise.resolve().then(()=>(Ec(), xc))).touchCommand
        },
        {
            name: "rm",
            load: async ()=>(await Promise.resolve().then(()=>(Ac(), Sc))).rmCommand
        },
        {
            name: "cp",
            load: async ()=>(await Promise.resolve().then(()=>(Nc(), Cc))).cpCommand
        },
        {
            name: "mv",
            load: async ()=>(await Promise.resolve().then(()=>(vc(), kc))).mvCommand
        },
        {
            name: "ln",
            load: async ()=>(await Promise.resolve().then(()=>(Ic(), $c))).lnCommand
        },
        {
            name: "chmod",
            load: async ()=>(await Promise.resolve().then(()=>(Tc(), Pc))).chmodCommand
        },
        {
            name: "pwd",
            load: async ()=>(await Promise.resolve().then(()=>(Dc(), Oc))).pwdCommand
        },
        {
            name: "readlink",
            load: async ()=>(await Promise.resolve().then(()=>(_c(), Fc))).readlinkCommand
        },
        {
            name: "head",
            load: async ()=>(await Promise.resolve().then(()=>(Bc(), Wc))).headCommand
        },
        {
            name: "tail",
            load: async ()=>(await Promise.resolve().then(()=>(zc(), Uc))).tailCommand
        },
        {
            name: "wc",
            load: async ()=>(await Promise.resolve().then(()=>(Vc(), Hc))).wcCommand
        },
        {
            name: "stat",
            load: async ()=>(await Promise.resolve().then(()=>(Zc(), Gc))).statCommand
        },
        {
            name: "grep",
            load: async ()=>(await Promise.resolve().then(()=>(os(), is))).grepCommand
        },
        {
            name: "fgrep",
            load: async ()=>(await Promise.resolve().then(()=>(os(), is))).fgrepCommand
        },
        {
            name: "egrep",
            load: async ()=>(await Promise.resolve().then(()=>(os(), is))).egrepCommand
        },
        {
            name: "rg",
            load: async ()=>(await Promise.resolve().then(()=>(gu(), mu))).rgCommand
        },
        {
            name: "sed",
            load: async ()=>(await Promise.resolve().then(()=>(vu(), ku))).sedCommand
        },
        {
            name: "awk",
            load: async ()=>(await Promise.resolve().then(()=>(of(), sf))).awkCommand2
        },
        {
            name: "sort",
            load: async ()=>(await Promise.resolve().then(()=>(gf(), mf))).sortCommand
        },
        {
            name: "uniq",
            load: async ()=>(await Promise.resolve().then(()=>(bf(), yf))).uniqCommand
        },
        {
            name: "comm",
            load: async ()=>(await Promise.resolve().then(()=>(xf(), wf))).commCommand
        },
        {
            name: "cut",
            load: async ()=>(await Promise.resolve().then(()=>(Sf(), Ef))).cutCommand
        },
        {
            name: "paste",
            load: async ()=>(await Promise.resolve().then(()=>(Nf(), Cf))).pasteCommand
        },
        {
            name: "tr",
            load: async ()=>(await Promise.resolve().then(()=>($f(), vf))).trCommand
        },
        {
            name: "rev",
            load: async ()=>(await Promise.resolve().then(()=>(Rf(), If))).rev
        },
        {
            name: "nl",
            load: async ()=>(await Promise.resolve().then(()=>(Of(), Tf))).nl
        },
        {
            name: "fold",
            load: async ()=>(await Promise.resolve().then(()=>(_f(), Ff))).fold
        },
        {
            name: "expand",
            load: async ()=>(await Promise.resolve().then(()=>(Wf(), Mf))).expand
        },
        {
            name: "unexpand",
            load: async ()=>(await Promise.resolve().then(()=>(jf(), zf))).unexpand
        },
        {
            name: "strings",
            load: async ()=>(await Promise.resolve().then(()=>(Gf(), qf))).strings
        },
        {
            name: "split",
            load: async ()=>(await Promise.resolve().then(()=>(Kf(), Qf))).split
        },
        {
            name: "column",
            load: async ()=>(await Promise.resolve().then(()=>(Yf(), Jf))).column
        },
        {
            name: "join",
            load: async ()=>(await Promise.resolve().then(()=>(tp(), ep))).join
        },
        {
            name: "tee",
            load: async ()=>(await Promise.resolve().then(()=>(rp(), np))).teeCommand
        },
        {
            name: "find",
            load: async ()=>(await Promise.resolve().then(()=>(pp(), fp))).findCommand
        },
        {
            name: "basename",
            load: async ()=>(await Promise.resolve().then(()=>(hp(), dp))).basenameCommand
        },
        {
            name: "dirname",
            load: async ()=>(await Promise.resolve().then(()=>(gp(), mp))).dirnameCommand
        },
        {
            name: "tree",
            load: async ()=>(await Promise.resolve().then(()=>(wp(), bp))).treeCommand
        },
        {
            name: "du",
            load: async ()=>(await Promise.resolve().then(()=>(Sp(), Ep))).duCommand
        },
        {
            name: "env",
            load: async ()=>(await Promise.resolve().then(()=>(xo(), wo))).envCommand
        },
        {
            name: "printenv",
            load: async ()=>(await Promise.resolve().then(()=>(xo(), wo))).printenvCommand
        },
        {
            name: "alias",
            load: async ()=>(await Promise.resolve().then(()=>(So(), Eo))).aliasCommand
        },
        {
            name: "unalias",
            load: async ()=>(await Promise.resolve().then(()=>(So(), Eo))).unaliasCommand
        },
        {
            name: "history",
            load: async ()=>(await Promise.resolve().then(()=>(Np(), Cp))).historyCommand
        },
        {
            name: "xargs",
            load: async ()=>(await Promise.resolve().then(()=>(vp(), kp))).xargsCommand
        },
        {
            name: "true",
            load: async ()=>(await Promise.resolve().then(()=>(Co(), Ao))).trueCommand
        },
        {
            name: "false",
            load: async ()=>(await Promise.resolve().then(()=>(Co(), Ao))).falseCommand
        },
        {
            name: "clear",
            load: async ()=>(await Promise.resolve().then(()=>(Ip(), $p))).clearCommand
        },
        {
            name: "bash",
            load: async ()=>(await Promise.resolve().then(()=>(ko(), No))).bashCommand
        },
        {
            name: "sh",
            load: async ()=>(await Promise.resolve().then(()=>(ko(), No))).shCommand
        },
        {
            name: "jq",
            load: async ()=>(await Promise.resolve().then(()=>(nd(), td))).jqCommand
        },
        {
            name: "base64",
            load: async ()=>(await Promise.resolve().then(()=>(id(), sd))).base64Command
        },
        {
            name: "diff",
            load: async ()=>(await Promise.resolve().then(()=>(ld(), ad))).diffCommand
        },
        {
            name: "date",
            load: async ()=>(await Promise.resolve().then(()=>(ud(), cd))).dateCommand
        },
        {
            name: "sleep",
            load: async ()=>(await Promise.resolve().then(()=>(pd(), fd))).sleepCommand
        },
        {
            name: "timeout",
            load: async ()=>(await Promise.resolve().then(()=>(hd(), dd))).timeoutCommand
        },
        {
            name: "time",
            load: async ()=>(await Promise.resolve().then(()=>(gd(), md))).timeCommand
        },
        {
            name: "seq",
            load: async ()=>(await Promise.resolve().then(()=>(bd(), yd))).seqCommand
        },
        {
            name: "expr",
            load: async ()=>(await Promise.resolve().then(()=>(xd(), wd))).exprCommand
        },
        {
            name: "md5sum",
            load: async ()=>(await Promise.resolve().then(()=>(Ad(), Sd))).md5sumCommand
        },
        {
            name: "sha1sum",
            load: async ()=>(await Promise.resolve().then(()=>(Nd(), Cd))).sha1sumCommand
        },
        {
            name: "sha256sum",
            load: async ()=>(await Promise.resolve().then(()=>(vd(), kd))).sha256sumCommand
        },
        {
            name: "file",
            load: async ()=>(await Promise.resolve().then(()=>(xh(), wh))).fileCommand
        },
        {
            name: "html-to-markdown",
            load: async ()=>(await Promise.resolve().then(()=>(Sh(), Eh))).htmlToMarkdownCommand
        },
        {
            name: "help",
            load: async ()=>(await Promise.resolve().then(()=>(Ch(), Ah))).helpCommand
        },
        {
            name: "which",
            load: async ()=>(await Promise.resolve().then(()=>(kh(), Nh))).whichCommand
        },
        {
            name: "tac",
            load: async ()=>(await Promise.resolve().then(()=>($h(), vh))).tac
        },
        {
            name: "hostname",
            load: async ()=>(await Promise.resolve().then(()=>(Rh(), Ih))).hostname
        },
        {
            name: "whoami",
            load: async ()=>(await Promise.resolve().then(()=>(Th(), Ph))).whoami
        },
        {
            name: "od",
            load: async ()=>(await Promise.resolve().then(()=>(Dh(), Oh))).od
        },
        {
            name: "gzip",
            load: async ()=>(await Promise.resolve().then(()=>(Hs(), js))).gzipCommand
        },
        {
            name: "gunzip",
            load: async ()=>(await Promise.resolve().then(()=>(Hs(), js))).gunzipCommand
        },
        {
            name: "zcat",
            load: async ()=>(await Promise.resolve().then(()=>(Hs(), js))).zcatCommand
        }
    ], Kh = [
        {
            name: "curl",
            load: async ()=>(await Promise.resolve().then(()=>(Zh(), Gh))).curlCommand
        }
    ], Qh = new Map();
    function Xh(e) {
        return {
            name: e.name,
            async execute (t, n) {
                let r = Qh.get(e.name);
                return r || (r = await e.load(), Qh.set(e.name, r)), r.execute(t, n);
            }
        };
    }
    function Jh(e) {
        return (e ? aa.filter((n)=>e.includes(n.name)) : aa).map(Xh);
    }
    function Yh() {
        return Kh.map(Xh);
    }
    function em(e) {
        return "load" in e && typeof e.load == "function";
    }
    function GA(e, t) {
        return {
            name: e,
            execute: t
        };
    }
    function tm(e) {
        let t = null;
        return {
            name: e.name,
            async execute (n, r) {
                return t || (t = await e.load()), t.execute(n, r);
            }
        };
    }
    var ZA = new TextEncoder(), QA = new TextDecoder();
    function la(e, t) {
        if (e instanceof Uint8Array) return e;
        if (t === "base64") return Uint8Array.from(atob(e), (n)=>n.charCodeAt(0));
        if (t === "hex") {
            let n = new Uint8Array(e.length / 2);
            for(let r = 0; r < e.length; r += 2)n[r / 2] = parseInt(e.slice(r, r + 2), 16);
            return n;
        }
        return t === "binary" || t === "latin1" ? Uint8Array.from(e, (n)=>n.charCodeAt(0)) : ZA.encode(e);
    }
    function nm(e, t) {
        return t === "base64" ? btoa(String.fromCharCode(...e)) : t === "hex" ? Array.from(e).map((n)=>n.toString(16).padStart(2, "0")).join("") : t === "binary" || t === "latin1" ? String.fromCharCode(...e) : QA.decode(e);
    }
    function Vs(e) {
        if (e != null) return typeof e == "string" ? e : e.encoding ?? void 0;
    }
    var qs = new TextEncoder();
    function KA(e) {
        return typeof e == "object" && e !== null && !(e instanceof Uint8Array) && "content" in e;
    }
    var En = class {
        data = new Map();
        constructor(t){
            if (this.data.set("/", {
                type: "directory",
                mode: 493,
                mtime: new Date()
            }), t) for (let [n, r] of Object.entries(t))KA(r) ? this.writeFileSync(n, r.content, void 0, {
                mode: r.mode,
                mtime: r.mtime
            }) : this.writeFileSync(n, r);
        }
        normalizePath(t) {
            if (!t || t === "/") return "/";
            let n = t.endsWith("/") && t !== "/" ? t.slice(0, -1) : t;
            n.startsWith("/") || (n = `/${n}`);
            let r = n.split("/").filter((i)=>i && i !== "."), s = [];
            for (let i of r)i === ".." ? s.pop() : s.push(i);
            return `/${s.join("/")}` || "/";
        }
        dirname(t) {
            let n = this.normalizePath(t);
            if (n === "/") return "/";
            let r = n.lastIndexOf("/");
            return r === 0 ? "/" : n.slice(0, r);
        }
        ensureParentDirs(t) {
            let n = this.dirname(t);
            n !== "/" && (this.data.has(n) || (this.ensureParentDirs(n), this.data.set(n, {
                type: "directory",
                mode: 493,
                mtime: new Date()
            })));
        }
        writeFileSync(t, n, r, s) {
            let i = this.normalizePath(t);
            this.ensureParentDirs(i);
            let o = Vs(r), a = la(n, o);
            this.data.set(i, {
                type: "file",
                content: a,
                mode: s?.mode ?? 420,
                mtime: s?.mtime ?? new Date()
            });
        }
        async readFile(t, n) {
            let r = await this.readFileBuffer(t), s = Vs(n);
            return nm(r, s);
        }
        async readFileBuffer(t) {
            let n = this.resolvePathWithSymlinks(t), r = this.data.get(n);
            if (!r) throw new Error(`ENOENT: no such file or directory, open '${t}'`);
            if (r.type !== "file") throw new Error(`EISDIR: illegal operation on a directory, read '${t}'`);
            return r.content instanceof Uint8Array ? r.content : qs.encode(r.content);
        }
        async writeFile(t, n, r) {
            this.writeFileSync(t, n, r);
        }
        async appendFile(t, n, r) {
            let s = this.normalizePath(t), i = this.data.get(s);
            if (i && i.type === "directory") throw new Error(`EISDIR: illegal operation on a directory, write '${t}'`);
            let o = Vs(r), a = la(n, o);
            if (i?.type === "file") {
                let l = i.content instanceof Uint8Array ? i.content : qs.encode(i.content), c = new Uint8Array(l.length + a.length);
                c.set(l), c.set(a, l.length), this.data.set(s, {
                    type: "file",
                    content: c,
                    mode: i.mode,
                    mtime: new Date()
                });
            } else this.writeFileSync(t, n, r);
        }
        async exists(t) {
            try {
                let n = this.resolvePathWithSymlinks(t);
                return this.data.has(n);
            } catch  {
                return false;
            }
        }
        async stat(t) {
            let n = this.resolvePathWithSymlinks(t), r = this.data.get(n);
            if (!r) throw new Error(`ENOENT: no such file or directory, stat '${t}'`);
            let s = 0;
            return r.type === "file" && r.content && (r.content instanceof Uint8Array ? s = r.content.length : s = qs.encode(r.content).length), {
                isFile: r.type === "file",
                isDirectory: r.type === "directory",
                isSymbolicLink: false,
                mode: r.mode,
                size: s,
                mtime: r.mtime || new Date()
            };
        }
        async lstat(t) {
            let n = this.resolveIntermediateSymlinks(t), r = this.data.get(n);
            if (!r) throw new Error(`ENOENT: no such file or directory, lstat '${t}'`);
            if (r.type === "symlink") return {
                isFile: false,
                isDirectory: false,
                isSymbolicLink: true,
                mode: r.mode,
                size: r.target.length,
                mtime: r.mtime || new Date()
            };
            let s = 0;
            return r.type === "file" && r.content && (r.content instanceof Uint8Array ? s = r.content.length : s = qs.encode(r.content).length), {
                isFile: r.type === "file",
                isDirectory: r.type === "directory",
                isSymbolicLink: false,
                mode: r.mode,
                size: s,
                mtime: r.mtime || new Date()
            };
        }
        resolveSymlink(t, n) {
            if (n.startsWith("/")) return this.normalizePath(n);
            let r = this.dirname(t);
            return this.normalizePath(r === "/" ? `/${n}` : `${r}/${n}`);
        }
        resolveIntermediateSymlinks(t) {
            let n = this.normalizePath(t);
            if (n === "/") return "/";
            let r = n.slice(1).split("/");
            if (r.length <= 1) return n;
            let s = "", i = new Set();
            for(let o = 0; o < r.length - 1; o++){
                let a = r[o];
                s = `${s}/${a}`;
                let l = this.data.get(s), c = 0, u = 40;
                for(; l && l.type === "symlink" && c < u;){
                    if (i.has(s)) throw new Error(`ELOOP: too many levels of symbolic links, lstat '${t}'`);
                    i.add(s), s = this.resolveSymlink(s, l.target), l = this.data.get(s), c++;
                }
                if (c >= u) throw new Error(`ELOOP: too many levels of symbolic links, lstat '${t}'`);
            }
            return `${s}/${r[r.length - 1]}`;
        }
        resolvePathWithSymlinks(t) {
            let n = this.normalizePath(t);
            if (n === "/") return "/";
            let r = n.slice(1).split("/"), s = "", i = new Set();
            for (let o of r){
                s = `${s}/${o}`;
                let a = this.data.get(s), l = 0, c = 40;
                for(; a && a.type === "symlink" && l < c;){
                    if (i.has(s)) throw new Error(`ELOOP: too many levels of symbolic links, open '${t}'`);
                    i.add(s), s = this.resolveSymlink(s, a.target), a = this.data.get(s), l++;
                }
                if (l >= c) throw new Error(`ELOOP: too many levels of symbolic links, open '${t}'`);
            }
            return s;
        }
        async mkdir(t, n) {
            this.mkdirSync(t, n);
        }
        mkdirSync(t, n) {
            let r = this.normalizePath(t);
            if (this.data.has(r)) {
                if (this.data.get(r)?.type === "file") throw new Error(`EEXIST: file already exists, mkdir '${t}'`);
                if (!n?.recursive) throw new Error(`EEXIST: directory already exists, mkdir '${t}'`);
                return;
            }
            let s = this.dirname(r);
            if (s !== "/" && !this.data.has(s)) if (n?.recursive) this.mkdirSync(s, {
                recursive: true
            });
            else throw new Error(`ENOENT: no such file or directory, mkdir '${t}'`);
            this.data.set(r, {
                type: "directory",
                mode: 493,
                mtime: new Date()
            });
        }
        async readdir(t) {
            return (await this.readdirWithFileTypes(t)).map((r)=>r.name);
        }
        async readdirWithFileTypes(t) {
            let n = this.normalizePath(t), r = this.data.get(n);
            if (!r) throw new Error(`ENOENT: no such file or directory, scandir '${t}'`);
            let s = new Set();
            for(; r && r.type === "symlink";){
                if (s.has(n)) throw new Error(`ELOOP: too many levels of symbolic links, scandir '${t}'`);
                s.add(n), n = this.resolveSymlink(n, r.target), r = this.data.get(n);
            }
            if (!r) throw new Error(`ENOENT: no such file or directory, scandir '${t}'`);
            if (r.type !== "directory") throw new Error(`ENOTDIR: not a directory, scandir '${t}'`);
            let i = n === "/" ? "/" : `${n}/`, o = new Map();
            for (let [a, l] of this.data.entries())if (a !== n && a.startsWith(i)) {
                let c = a.slice(i.length), u = c.split("/")[0];
                u && !c.includes("/", u.length) && !o.has(u) && o.set(u, {
                    name: u,
                    isFile: l.type === "file",
                    isDirectory: l.type === "directory",
                    isSymbolicLink: l.type === "symlink"
                });
            }
            return Array.from(o.values()).sort((a, l)=>a.name < l.name ? -1 : a.name > l.name ? 1 : 0);
        }
        async rm(t, n) {
            let r = this.normalizePath(t), s = this.data.get(r);
            if (!s) {
                if (n?.force) return;
                throw new Error(`ENOENT: no such file or directory, rm '${t}'`);
            }
            if (s.type === "directory") {
                let i = await this.readdir(r);
                if (i.length > 0) {
                    if (!n?.recursive) throw new Error(`ENOTEMPTY: directory not empty, rm '${t}'`);
                    for (let o of i){
                        let a = r === "/" ? `/${o}` : `${r}/${o}`;
                        await this.rm(a, n);
                    }
                }
            }
            this.data.delete(r);
        }
        async cp(t, n, r) {
            let s = this.normalizePath(t), i = this.normalizePath(n), o = this.data.get(s);
            if (!o) throw new Error(`ENOENT: no such file or directory, cp '${t}'`);
            if (o.type === "file") this.ensureParentDirs(i), this.data.set(i, {
                ...o
            });
            else if (o.type === "directory") {
                if (!r?.recursive) throw new Error(`EISDIR: is a directory, cp '${t}'`);
                await this.mkdir(i, {
                    recursive: true
                });
                let a = await this.readdir(s);
                for (let l of a){
                    let c = s === "/" ? `/${l}` : `${s}/${l}`, u = i === "/" ? `/${l}` : `${i}/${l}`;
                    await this.cp(c, u, r);
                }
            }
        }
        async mv(t, n) {
            await this.cp(t, n, {
                recursive: true
            }), await this.rm(t, {
                recursive: true
            });
        }
        getAllPaths() {
            return Array.from(this.data.keys());
        }
        resolvePath(t, n) {
            if (n.startsWith("/")) return this.normalizePath(n);
            let r = t === "/" ? `/${n}` : `${t}/${n}`;
            return this.normalizePath(r);
        }
        async chmod(t, n) {
            let r = this.normalizePath(t), s = this.data.get(r);
            if (!s) throw new Error(`ENOENT: no such file or directory, chmod '${t}'`);
            s.mode = n;
        }
        async symlink(t, n) {
            let r = this.normalizePath(n);
            if (this.data.has(r)) throw new Error(`EEXIST: file already exists, symlink '${n}'`);
            this.ensureParentDirs(r), this.data.set(r, {
                type: "symlink",
                target: t,
                mode: 511,
                mtime: new Date()
            });
        }
        async link(t, n) {
            let r = this.normalizePath(t), s = this.normalizePath(n), i = this.data.get(r);
            if (!i) throw new Error(`ENOENT: no such file or directory, link '${t}'`);
            if (i.type !== "file") throw new Error(`EPERM: operation not permitted, link '${t}'`);
            if (this.data.has(s)) throw new Error(`EEXIST: file already exists, link '${n}'`);
            this.ensureParentDirs(s), this.data.set(s, {
                type: "file",
                content: i.content,
                mode: i.mode,
                mtime: i.mtime
            });
        }
        async readlink(t) {
            let n = this.normalizePath(t), r = this.data.get(n);
            if (!r) throw new Error(`ENOENT: no such file or directory, readlink '${t}'`);
            if (r.type !== "symlink") throw new Error(`EINVAL: invalid argument, readlink '${t}'`);
            return r.target;
        }
        async realpath(t) {
            let n = this.resolvePathWithSymlinks(t);
            if (!this.data.has(n)) throw new Error(`ENOENT: no such file or directory, realpath '${t}'`);
            return n;
        }
        async utimes(t, n, r) {
            let s = this.normalizePath(t), i = this.resolvePathWithSymlinks(s), o = this.data.get(i);
            if (!o) throw new Error(`ENOENT: no such file or directory, utimes '${t}'`);
            o.mtime = r;
        }
    };
    ca();
    function XA(e) {
        let t = e;
        return typeof t.mkdirSync == "function" && typeof t.writeFileSync == "function";
    }
    function JA(e, t) {
        e.mkdirSync("/bin", {
            recursive: true
        }), e.mkdirSync("/usr/bin", {
            recursive: true
        }), t && (e.mkdirSync("/home/user", {
            recursive: true
        }), e.mkdirSync("/tmp", {
            recursive: true
        }));
    }
    function YA(e) {
        e.mkdirSync("/dev", {
            recursive: true
        }), e.writeFileSync("/dev/null", ""), e.writeFileSync("/dev/zero", new Uint8Array(0)), e.writeFileSync("/dev/stdin", ""), e.writeFileSync("/dev/stdout", ""), e.writeFileSync("/dev/stderr", "");
    }
    function eC(e) {
        e.mkdirSync("/proc/self/fd", {
            recursive: true
        }), e.writeFileSync("/proc/version", `${sm}
`), e.writeFileSync("/proc/self/exe", "/bin/bash"), e.writeFileSync("/proc/self/cmdline", "bash\0"), e.writeFileSync("/proc/self/comm", `bash
`), e.writeFileSync("/proc/self/status", im()), e.writeFileSync("/proc/self/fd/0", "/dev/stdin"), e.writeFileSync("/proc/self/fd/1", "/dev/stdout"), e.writeFileSync("/proc/self/fd/2", "/dev/stderr");
    }
    function om(e, t) {
        XA(e) && (JA(e, t), YA(e), eC(e));
    }
    de();
    var tC = [
        "allexport",
        "errexit",
        "noglob",
        "noclobber",
        "noexec",
        "nounset",
        "pipefail",
        "posix",
        "verbose",
        "xtrace"
    ], nC = [
        "braceexpand",
        "hashall",
        "interactive-comments"
    ];
    function ua(e) {
        let t = [], n = [
            ...nC.map((r)=>({
                    name: r,
                    enabled: true
                })),
            ...tC.map((r)=>({
                    name: r,
                    enabled: e[r]
                }))
        ].sort((r, s)=>r.name.localeCompare(s.name));
        for (let r of n)r.enabled && t.push(r.name);
        return t.join(":");
    }
    function Jn(e) {
        e.state.env.SHELLOPTS = ua(e.state.options);
    }
    var rC = [
        "dotglob",
        "expand_aliases",
        "extglob",
        "failglob",
        "globskipdots",
        "globstar",
        "lastpipe",
        "nocaseglob",
        "nocasematch",
        "nullglob",
        "xpg_echo"
    ];
    function fa(e) {
        let t = [];
        for (let n of rC)e[n] && t.push(n);
        return t.join(":");
    }
    function pa(e) {
        e.state.env.BASHOPTS = fa(e.state.shoptOptions);
    }
    An();
    Fe();
    An();
    var OC = "BASH_ALIAS_";
    function Qm(e) {
        return e.parts.length !== 1 ? false : e.parts[0].type === "Literal";
    }
    function Km(e) {
        if (e.parts.length !== 1) return null;
        let t = e.parts[0];
        return t.type === "Literal" ? t.value : null;
    }
    function Xm(e, t) {
        return e.env[`${OC}${t}`];
    }
    function Oa(e, t, n) {
        if (!t.name || !Qm(t.name)) return t;
        let r = Km(t.name);
        if (!r) return t;
        let s = Xm(e, r);
        if (!s || n.has(r)) return t;
        try {
            n.add(r);
            let i = new se(), o = s, a = s.endsWith(" ");
            if (!a) for (let f of t.args){
                let p = Ym(f);
                o += ` ${p}`;
            }
            let l;
            try {
                l = i.parse(o);
            } catch (f) {
                if (f instanceof Ge) throw f;
                return t;
            }
            if (l.statements.length !== 1 || l.statements[0].pipelines.length !== 1 || l.statements[0].pipelines[0].commands.length !== 1) return Jm(t, s);
            let c = l.statements[0].pipelines[0].commands[0];
            if (c.type !== "SimpleCommand") return Jm(t, s);
            let u = {
                ...c,
                assignments: [
                    ...t.assignments,
                    ...c.assignments
                ],
                redirections: [
                    ...c.redirections,
                    ...t.redirections
                ],
                line: t.line
            };
            if (a && t.args.length > 0 && (u = {
                ...u,
                args: [
                    ...u.args,
                    ...t.args
                ]
            }, u.args.length > 0)) {
                let f = u.args[0];
                if (Qm(f)) {
                    let p = Km(f);
                    if (p && Xm(e, p)) {
                        let d = {
                            type: "SimpleCommand",
                            name: f,
                            args: u.args.slice(1),
                            assignments: [],
                            redirections: []
                        }, m = Oa(e, d, n);
                        m !== d && (u = {
                            ...u,
                            name: m.name,
                            args: [
                                ...m.args
                            ]
                        });
                    }
                }
            }
            return u;
        } catch (i) {
            throw n.delete(r), i;
        }
    }
    function Jm(e, t) {
        let n = t;
        for (let o of e.args){
            let a = Ym(o);
            n += ` ${a}`;
        }
        let r = new se(), s = r.parseWordFromString("eval", false, false), i = r.parseWordFromString(`'${n.replace(/'/g, "'\\''")}'`, false, false);
        return {
            type: "SimpleCommand",
            name: s,
            args: [
                i
            ],
            assignments: e.assignments,
            redirections: e.redirections,
            line: e.line
        };
    }
    function Ym(e) {
        let t = "";
        for (let n of e.parts)switch(n.type){
            case "Literal":
                t += n.value.replace(/([\s"'$`\\*?[\]{}()<>|&;#!])/g, "\\$1");
                break;
            case "SingleQuoted":
                t += `'${n.value}'`;
                break;
            case "DoubleQuoted":
                t += `"${n.parts.map((r)=>r.type === "Literal" ? r.value : `$${r.type}`).join("")}"`;
                break;
            case "ParameterExpansion":
                t += `\${${n.parameter}}`;
                break;
            case "CommandSubstitution":
                t += "$(...)";
                break;
            case "ArithmeticExpansion":
                t += `$((${n.expression}))`;
                break;
            case "Glob":
                t += n.pattern;
                break;
        }
        return t;
    }
    it();
    ot();
    $t();
    async function R0(e, t) {
        let n = t.parts.map((u)=>u.type === "Literal" ? u.value : "\0").join(""), r = n.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\(/);
        if (!r || !n.endsWith(")")) return null;
        let s = r[1], i = [], o = false, a = "", l = false;
        for (let u of t.parts)if (u.type === "Literal") {
            let f = u.value;
            if (!o) {
                let p = f.indexOf("=(");
                p !== -1 && (o = true, f = f.slice(p + 2));
            }
            if (o) {
                f.endsWith(")") && (f = f.slice(0, -1));
                let p = f.split(/(\s+)/);
                for (let d of p)/^\s+$/.test(d) ? (a || l) && (i.push(a), a = "", l = false) : d && (a += d);
            }
        } else if (o) if (u.type === "BraceExpansion") if (/^\[.+\]=/.test(a)) a += Yn({
            parts: [
                u
            ]
        });
        else {
            (a || l) && (i.push(a), a = "", l = false);
            let p = await Ft(e, {
                type: "Word",
                parts: [
                    u
                ]
            });
            i.push(...p.values);
        }
        else {
            (u.type === "SingleQuoted" || u.type === "DoubleQuoted" || u.type === "Escaped") && (l = true);
            let f = await J(e, {
                parts: [
                    u
                ]
            });
            a += f;
        }
        (a || l) && i.push(a);
        let c = i.map((u)=>/^\[.+\]=/.test(u) ? u : u === "" ? "''" : /[\s"'\\$`!*?[\]{}|&;<>()]/.test(u) && !u.startsWith("'") && !u.startsWith('"') ? `'${u.replace(/'/g, "'\\''")}'` : u);
        return `${s}=(${c.join(" ")})`;
    }
    async function P0(e, t) {
        let n = -1, r = -1, s = false;
        for(let h = 0; h < t.parts.length; h++){
            let g = t.parts[h];
            if (g.type === "Literal") {
                let b = g.value.indexOf("+=");
                if (b !== -1) {
                    let w = g.value.slice(0, b);
                    if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(w)) {
                        n = h, r = b, s = true;
                        break;
                    }
                    if (/^[a-zA-Z_][a-zA-Z0-9_]*\[[^\]]+\]$/.test(w)) {
                        n = h, r = b, s = true;
                        break;
                    }
                }
                let y = g.value.indexOf("=");
                if (y !== -1 && (y === 0 || g.value[y - 1] !== "+")) {
                    let w = g.value.slice(0, y);
                    if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(w) || /^[a-zA-Z_][a-zA-Z0-9_]*\[[^\]]+\]$/.test(w)) {
                        n = h, r = y;
                        break;
                    }
                }
            }
        }
        if (n === -1) return null;
        let i = t.parts.slice(0, n), o = t.parts[n];
        if (o.type !== "Literal") return null;
        let a = s ? 2 : 1, l = o.value.slice(0, r), c = o.value.slice(r + a), u = t.parts.slice(n + 1), f = "";
        for (let h of i)f += await J(e, {
            parts: [
                h
            ]
        });
        f += l;
        let p = {
            parts: c !== "" ? [
                {
                    type: "Literal",
                    value: c
                },
                ...u
            ] : u
        }, d = p.parts.length > 0 ? await J(e, p) : "";
        return `${f}${s ? "+=" : "="}${d}`;
    }
    var AN = [
        "tar",
        "yq",
        "xan",
        "sqlite3",
        "python3",
        "python"
    ];
    function T0(e) {
        return AN.includes(e);
    }
    de();
    de();
    var le = Object.freeze({
        stdout: "",
        stderr: "",
        exitCode: 0
    });
    function ue(e = "") {
        return {
            stdout: e,
            stderr: "",
            exitCode: 0
        };
    }
    function M(e, t = 1) {
        return {
            stdout: "",
            stderr: e,
            exitCode: t
        };
    }
    function W(e, t, n) {
        return {
            stdout: e,
            stderr: t,
            exitCode: n
        };
    }
    function Le(e) {
        return {
            stdout: "",
            stderr: "",
            exitCode: e ? 0 : 1
        };
    }
    function Xt(e, t, n = "", r = "") {
        throw new ne(e, t, n, r);
    }
    function nl(e, t) {
        if (e.state.loopDepth === 0) {
            if (e.state.parentHasLoopContext) throw new Lt();
            return le;
        }
        if (t.length > 1) throw new ae(1, "", `bash: break: too many arguments
`);
        let n = 1;
        if (t.length > 0) {
            let r = Number.parseInt(t[0], 10);
            if (Number.isNaN(r) || r < 1) throw new ae(128, "", `bash: break: ${t[0]}: numeric argument required
`);
            n = r;
        }
        throw new Qe(n);
    }
    async function rl(e, t) {
        let n, r = false, s = false, i = 0;
        for(; i < t.length;)if (t[i] === "--") {
            i++;
            break;
        } else if (t[i] === "-L") s = false, i++;
        else if (t[i] === "-P") s = true, i++;
        else if (t[i].startsWith("-") && t[i] !== "-") i++;
        else break;
        let o = t.slice(i);
        if (o.length === 0 || o[0] === "~" ? n = e.state.env.HOME || "/" : o[0] === "-" ? (n = e.state.previousDir, r = true) : n = o[0], !n.startsWith("/") && !n.startsWith("./") && !n.startsWith("../") && n !== "." && n !== "..") {
            let f = e.state.env.CDPATH;
            if (f) {
                let p = f.split(":").filter((d)=>d);
                for (let d of p){
                    let m = d.startsWith("/") ? `${d}/${n}` : `${e.state.cwd}/${d}/${n}`;
                    try {
                        if ((await e.fs.stat(m)).isDirectory) {
                            n = m, r = true;
                            break;
                        }
                    } catch  {}
                }
            }
        }
        let l = (n.startsWith("/") ? n : `${e.state.cwd}/${n}`).split("/").filter((f)=>f && f !== "."), c = "";
        for (let f of l)if (f === "..") c = c.split("/").slice(0, -1).join("/") || "/";
        else {
            c = c ? `${c}/${f}` : `/${f}`;
            try {
                if (!(await e.fs.stat(c)).isDirectory) return M(`bash: cd: ${n}: Not a directory
`);
            } catch  {
                return M(`bash: cd: ${n}: No such file or directory
`);
            }
        }
        let u = c || "/";
        if (s) try {
            u = await e.fs.realpath(u);
        } catch  {}
        return e.state.previousDir = e.state.cwd, e.state.cwd = u, e.state.env.PWD = e.state.cwd, e.state.env.OLDPWD = e.state.previousDir, ue(r ? `${u}
` : "");
    }
    Fe();
    Je();
    Fe();
    it();
    ot();
    $t();
    function sl(e, t) {
        return e.fs.resolvePath(e.state.cwd, t);
    }
    var CN = [
        "-e",
        "-a",
        "-f",
        "-d",
        "-r",
        "-w",
        "-x",
        "-s",
        "-L",
        "-h",
        "-k",
        "-g",
        "-u",
        "-G",
        "-O",
        "-b",
        "-c",
        "-p",
        "-S",
        "-t",
        "-N"
    ];
    function hi(e) {
        return CN.includes(e);
    }
    async function mi(e, t, n) {
        let r = sl(e, n);
        switch(t){
            case "-e":
            case "-a":
                return e.fs.exists(r);
            case "-f":
                return await e.fs.exists(r) ? (await e.fs.stat(r)).isFile : false;
            case "-d":
                return await e.fs.exists(r) ? (await e.fs.stat(r)).isDirectory : false;
            case "-r":
                return await e.fs.exists(r) ? ((await e.fs.stat(r)).mode & 256) !== 0 : false;
            case "-w":
                return await e.fs.exists(r) ? ((await e.fs.stat(r)).mode & 128) !== 0 : false;
            case "-x":
                return await e.fs.exists(r) ? ((await e.fs.stat(r)).mode & 64) !== 0 : false;
            case "-s":
                return await e.fs.exists(r) ? (await e.fs.stat(r)).size > 0 : false;
            case "-L":
            case "-h":
                try {
                    return (await e.fs.lstat(r)).isSymbolicLink;
                } catch  {
                    return false;
                }
            case "-k":
                return await e.fs.exists(r) ? ((await e.fs.stat(r)).mode & 512) !== 0 : false;
            case "-g":
                return await e.fs.exists(r) ? ((await e.fs.stat(r)).mode & 1024) !== 0 : false;
            case "-u":
                return await e.fs.exists(r) ? ((await e.fs.stat(r)).mode & 2048) !== 0 : false;
            case "-G":
            case "-O":
                return e.fs.exists(r);
            case "-b":
                return false;
            case "-c":
                return [
                    "/dev/null",
                    "/dev/zero",
                    "/dev/random",
                    "/dev/urandom",
                    "/dev/tty",
                    "/dev/stdin",
                    "/dev/stdout",
                    "/dev/stderr"
                ].some((i)=>r === i || r.endsWith(i));
            case "-p":
                return false;
            case "-S":
                return false;
            case "-t":
                return false;
            case "-N":
                return e.fs.exists(r);
            default:
                return false;
        }
    }
    var NN = [
        "-nt",
        "-ot",
        "-ef"
    ];
    function gi(e) {
        return NN.includes(e);
    }
    async function yi(e, t, n, r) {
        let s = sl(e, n), i = sl(e, r);
        switch(t){
            case "-nt":
                try {
                    let o = await e.fs.stat(s), a = await e.fs.stat(i);
                    return o.mtime > a.mtime;
                } catch  {
                    return false;
                }
            case "-ot":
                try {
                    let o = await e.fs.stat(s), a = await e.fs.stat(i);
                    return o.mtime < a.mtime;
                } catch  {
                    return false;
                }
            case "-ef":
                try {
                    if (!await e.fs.exists(s) || !await e.fs.exists(i)) return false;
                    let o = e.fs.resolvePath(e.state.cwd, s), a = e.fs.resolvePath(e.state.cwd, i);
                    return o === a;
                } catch  {
                    return false;
                }
            default:
                return false;
        }
    }
    var kN = new Set([
        "-eq",
        "-ne",
        "-lt",
        "-le",
        "-gt",
        "-ge"
    ]);
    function bi(e) {
        return kN.has(e);
    }
    function wi(e, t, n) {
        switch(e){
            case "-eq":
                return t === n;
            case "-ne":
                return t !== n;
            case "-lt":
                return t < n;
            case "-le":
                return t <= n;
            case "-gt":
                return t > n;
            case "-ge":
                return t >= n;
        }
    }
    function Ur(e) {
        return e === "=" || e === "==" || e === "!=";
    }
    function xi(e, t, n, r = false, s = false, i = false) {
        if (r) {
            let a = or(t, n, s, i);
            return e === "!=" ? !a : a;
        }
        if (s) {
            let a = t.toLowerCase() === n.toLowerCase();
            return e === "!=" ? !a : a;
        }
        let o = t === n;
        return e === "!=" ? !o : o;
    }
    var vN = new Set([
        "-z",
        "-n"
    ]);
    function Ei(e) {
        return vN.has(e);
    }
    function Si(e, t) {
        switch(e){
            case "-z":
                return t === "";
            case "-n":
                return t !== "";
        }
    }
    Je();
    Fe();
    it();
    $t();
    async function Ai(e, t) {
        let n = t.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
        if (n) {
            let r = n[1], s = n[2];
            if (e.state.associativeArrays?.has(r)) {
                let a = s;
                return (a.startsWith("'") && a.endsWith("'") || a.startsWith('"') && a.endsWith('"')) && (a = a.slice(1, -1)), a = a.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (l, c)=>e.state.env[c] || ""), `${r}_${a}` in e.state.env;
            }
            let o;
            try {
                let a = new se(), l = he(a, s);
                o = await Q(e, l.expression);
            } catch  {
                if (/^-?\d+$/.test(s)) o = Number.parseInt(s, 10);
                else {
                    let a = e.state.env[s];
                    o = a ? Number.parseInt(a, 10) : 0;
                }
            }
            if (o < 0) {
                let a = _e(e, r), l = e.state.currentLine;
                if (a.length === 0) return e.state.expansionStderr = (e.state.expansionStderr || "") + `bash: line ${l}: ${r}: bad array subscript
`, false;
                if (o = Math.max(...a) + 1 + o, o < 0) return e.state.expansionStderr = (e.state.expansionStderr || "") + `bash: line ${l}: ${r}: bad array subscript
`, false;
            }
            return `${r}_${o}` in e.state.env;
        }
        return t in e.state.env ? true : e.state.associativeArrays?.has(t) ? Pt(e, t).length > 0 : _e(e, t).length > 0;
    }
    async function ln(e, t) {
        switch(t.type){
            case "CondBinary":
                {
                    let n = await J(e, t.left), r = t.right.parts.length > 0 && t.right.parts.every((i)=>i.type === "SingleQuoted" || i.type === "DoubleQuoted" || i.type === "Escaped" && t.operator !== "=~"), s;
                    if (t.operator === "=~") if (r) {
                        let i = await J(e, t.right);
                        s = er(i);
                    } else s = await Ka(e, t.right);
                    else Ur(t.operator) && !r ? s = await Xa(e, t.right) : s = await J(e, t.right);
                    if (Ur(t.operator)) {
                        let i = e.state.shoptOptions.nocasematch;
                        return xi(t.operator, n, s, !r, i, true);
                    }
                    if (bi(t.operator)) return wi(t.operator, await D0(e, n), await D0(e, s));
                    if (gi(t.operator)) return yi(e, t.operator, n, s);
                    switch(t.operator){
                        case "=~":
                            try {
                                let i = e.state.shoptOptions.nocasematch, o = PN(s), a = new RegExp(o, i ? "i" : ""), l = n.match(a);
                                if (Ut(e, "BASH_REMATCH"), l) for(let c = 0; c < l.length; c++)e.state.env[`BASH_REMATCH_${c}`] = l[c] || "";
                                return l !== null;
                            } catch  {
                                throw new Error("syntax error in regular expression");
                            }
                        case "<":
                            return n < s;
                        case ">":
                            return n > s;
                        default:
                            return false;
                    }
                }
            case "CondUnary":
                {
                    let n = await J(e, t.operand);
                    return hi(t.operator) ? mi(e, t.operator, n) : Ei(t.operator) ? Si(t.operator, n) : t.operator === "-v" ? await Ai(e, n) : t.operator === "-o" ? ol(e, n) : false;
                }
            case "CondNot":
                return e.state.shoptOptions.extglob && t.operand.type === "CondGroup" && t.operand.expression.type === "CondWord" ? `!(${await J(e, t.operand.expression.word)})` !== "" : !await ln(e, t.operand);
            case "CondAnd":
                return await ln(e, t.left) ? await ln(e, t.right) : false;
            case "CondOr":
                return await ln(e, t.left) ? true : await ln(e, t.right);
            case "CondGroup":
                return await ln(e, t.expression);
            case "CondWord":
                return await J(e, t.word) !== "";
            default:
                return false;
        }
    }
    async function zr(e, t) {
        if (t.length === 0) return W("", "", 1);
        if (t.length === 1) return Le(!!t[0]);
        if (t.length === 2) {
            let r = t[0], s = t[1];
            return r === "(" ? M(`test: '(' without matching ')'
`, 2) : hi(r) ? Le(await mi(e, r, s)) : Ei(r) ? Le(Si(r, s)) : r === "!" ? Le(!s) : r === "-v" ? Le(await Ai(e, s)) : r === "-o" ? Le(ol(e, s)) : r === "=" || r === "==" || r === "!=" || r === "<" || r === ">" || r === "-eq" || r === "-ne" || r === "-lt" || r === "-le" || r === "-gt" || r === "-ge" || r === "-nt" || r === "-ot" || r === "-ef" ? M(`test: ${r}: unary operator expected
`, 2) : W("", "", 1);
        }
        if (t.length === 3) {
            let r = t[0], s = t[1], i = t[2];
            if (Ur(s)) return Le(xi(s, r, i));
            if (bi(s)) {
                let o = Ci(r), a = Ci(i);
                return !o.valid || !a.valid ? W("", "", 2) : Le(wi(s, o.value, a.value));
            }
            if (gi(s)) return Le(await yi(e, s, r, i));
            switch(s){
                case "-a":
                    return Le(r !== "" && i !== "");
                case "-o":
                    return Le(r !== "" || i !== "");
                case ">":
                    return Le(r > i);
                case "<":
                    return Le(r < i);
            }
            if (r === "!") {
                let o = await zr(e, [
                    s,
                    i
                ]);
                return W("", o.stderr, o.exitCode === 0 ? 1 : o.exitCode === 1 ? 0 : o.exitCode);
            }
            if (r === "(" && i === ")") return Le(s !== "");
        }
        if (t.length === 4) {
            if (t[0] === "!") {
                let r = await zr(e, t.slice(1));
                return W("", r.stderr, r.exitCode === 0 ? 1 : r.exitCode === 1 ? 0 : r.exitCode);
            }
            if (t[0] === "(" && t[3] === ")") return zr(e, [
                t[1],
                t[2]
            ]);
        }
        let n = await _0(e, t, 0);
        return n.pos < t.length ? M(`test: too many arguments
`, 2) : Le(n.value);
    }
    async function _0(e, t, n) {
        return $N(e, t, n);
    }
    async function $N(e, t, n) {
        let { value: r, pos: s } = await O0(e, t, n);
        for(; t[s] === "-o";){
            let i = await O0(e, t, s + 1);
            r = r || i.value, s = i.pos;
        }
        return {
            value: r,
            pos: s
        };
    }
    async function O0(e, t, n) {
        let { value: r, pos: s } = await il(e, t, n);
        for(; t[s] === "-a";){
            let i = await il(e, t, s + 1);
            r = r && i.value, s = i.pos;
        }
        return {
            value: r,
            pos: s
        };
    }
    async function il(e, t, n) {
        if (t[n] === "!") {
            let { value: r, pos: s } = await il(e, t, n + 1);
            return {
                value: !r,
                pos: s
            };
        }
        return IN(e, t, n);
    }
    async function IN(e, t, n) {
        let r = t[n];
        if (r === "(") {
            let { value: i, pos: o } = await _0(e, t, n + 1);
            return {
                value: i,
                pos: t[o] === ")" ? o + 1 : o
            };
        }
        let s = t[n + 1];
        if (Ur(s)) {
            let i = r, o = t[n + 2] ?? "";
            return {
                value: xi(s, i, o),
                pos: n + 3
            };
        }
        if (bi(s)) {
            let i = Ci(r), o = Ci(t[n + 2] ?? "0");
            return !i.valid || !o.valid ? {
                value: false,
                pos: n + 3
            } : {
                value: wi(s, i.value, o.value),
                pos: n + 3
            };
        }
        if (gi(s)) {
            let i = r, o = t[n + 2] ?? "";
            return {
                value: await yi(e, s, i, o),
                pos: n + 3
            };
        }
        if (hi(r)) {
            let i = t[n + 1] ?? "";
            return {
                value: await mi(e, r, i),
                pos: n + 2
            };
        }
        if (Ei(r)) {
            let i = t[n + 1] ?? "";
            return {
                value: Si(r, i),
                pos: n + 2
            };
        }
        if (r === "-v") {
            let i = t[n + 1] ?? "";
            return {
                value: await Ai(e, i),
                pos: n + 2
            };
        }
        if (r === "-o") {
            let i = t[n + 1] ?? "";
            return {
                value: ol(e, i),
                pos: n + 2
            };
        }
        return {
            value: r !== void 0 && r !== "",
            pos: n + 1
        };
    }
    function or(e, t, n = false, r = false) {
        let s = `^${L0(t, r)}$`, i = n ? "is" : "s";
        return new RegExp(s, i).test(e);
    }
    function L0(e, t) {
        let n = "";
        for(let r = 0; r < e.length; r++){
            let s = e[r];
            if (t && (s === "@" || s === "*" || s === "+" || s === "?" || s === "!") && r + 1 < e.length && e[r + 1] === "(") {
                let i = M0(e, r + 1);
                if (i !== -1) {
                    let o = e.slice(r + 2, i), a = W0(o), l = a.map((u)=>L0(u, t)), c = l.length > 0 ? l.join("|") : "(?:)";
                    if (s === "@") n += `(?:${c})`;
                    else if (s === "*") n += `(?:${c})*`;
                    else if (s === "+") n += `(?:${c})+`;
                    else if (s === "?") n += `(?:${c})?`;
                    else if (s === "!") if (i < e.length - 1) {
                        let f = a.map((d)=>B0(d, t));
                        if (f.every((d)=>d !== null) && f.every((d)=>d === f[0]) && f[0] !== null) {
                            let d = f[0];
                            if (d === 0) n += "(?:.+)";
                            else {
                                let m = [];
                                d > 0 && m.push(`.{0,${d - 1}}`), m.push(`.{${d + 1},}`), m.push(`(?!(?:${c})).{${d}}`), n += `(?:${m.join("|")})`;
                            }
                        } else n += `(?:(?!(?:${c})).)*?`;
                    } else n += `(?!(?:${c})$).*`;
                    r = i;
                    continue;
                }
            }
            if (s === "\\") if (r + 1 < e.length) {
                let i = e[r + 1];
                /[\\^$.|+(){}[\]*?]/.test(i) ? n += `\\${i}` : n += i, r++;
            } else n += "\\\\";
            else if (s === "*") n += ".*";
            else if (s === "?") n += ".";
            else if (s === "[") {
                let i = e.indexOf("]", r + 1);
                i !== -1 ? (n += e.slice(r, i + 1), r = i) : n += "\\[";
            } else /[\\^$.|+(){}]/.test(s) ? n += `\\${s}` : n += s;
        }
        return n;
    }
    function M0(e, t) {
        let n = 1, r = t + 1;
        for(; r < e.length && n > 0;){
            let s = e[r];
            if (s === "\\") {
                r += 2;
                continue;
            }
            if (s === "(") n++;
            else if (s === ")" && (n--, n === 0)) return r;
            r++;
        }
        return -1;
    }
    function W0(e) {
        let t = [], n = "", r = 0, s = 0;
        for(; s < e.length;){
            let i = e[s];
            if (i === "\\") {
                n += i, s + 1 < e.length ? (n += e[s + 1], s += 2) : s++;
                continue;
            }
            i === "(" ? (r++, n += i) : i === ")" ? (r--, n += i) : i === "|" && r === 0 ? (t.push(n), n = "") : n += i, s++;
        }
        return t.push(n), t;
    }
    function B0(e, t) {
        let n = 0, r = 0;
        for(; r < e.length;){
            let s = e[r];
            if (t && (s === "@" || s === "*" || s === "+" || s === "?" || s === "!") && r + 1 < e.length && e[r + 1] === "(") {
                let i = M0(e, r + 1);
                if (i !== -1) {
                    if (s === "@") {
                        let o = e.slice(r + 2, i), l = W0(o).map((c)=>B0(c, t));
                        if (l.every((c)=>c !== null) && l.every((c)=>c === l[0])) {
                            n += l[0], r = i + 1;
                            continue;
                        }
                        return null;
                    }
                    return null;
                }
            }
            if (s === "*") return null;
            if (s === "?") {
                n += 1, r++;
                continue;
            }
            if (s === "[") {
                let i = e.indexOf("]", r + 1);
                if (i !== -1) {
                    n += 1, r = i + 1;
                    continue;
                }
                n += 1, r++;
                continue;
            }
            if (s === "\\") {
                n += 1, r += 2;
                continue;
            }
            n += 1, r++;
        }
        return n;
    }
    function ol(e, t) {
        let r = {
            errexit: ()=>e.state.options.errexit === true,
            nounset: ()=>e.state.options.nounset === true,
            pipefail: ()=>e.state.options.pipefail === true,
            xtrace: ()=>e.state.options.xtrace === true,
            e: ()=>e.state.options.errexit === true,
            u: ()=>e.state.options.nounset === true,
            x: ()=>e.state.options.xtrace === true
        }[t];
        return r ? r() : false;
    }
    async function D0(e, t) {
        if (t = t.trim(), t === "") return 0;
        if (/^[+-]?(\d+#[a-zA-Z0-9@_]+|0[xX][0-9a-fA-F]+|0[0-7]+|\d+)$/.test(t)) return F0(t);
        try {
            let n = new se(), r = he(n, t);
            return await Q(e, r.expression);
        } catch  {
            return F0(t);
        }
    }
    function RN(e, t) {
        let n = 0;
        for (let r of e){
            let s;
            if (r >= "0" && r <= "9") s = r.charCodeAt(0) - 48;
            else if (r >= "a" && r <= "z") s = r.charCodeAt(0) - 97 + 10;
            else if (r >= "A" && r <= "Z") s = r.charCodeAt(0) - 65 + 36;
            else if (r === "@") s = 62;
            else if (r === "_") s = 63;
            else return Number.NaN;
            if (s >= t) return Number.NaN;
            n = n * t + s;
        }
        return n;
    }
    function F0(e) {
        if (e = e.trim(), e === "") return 0;
        let t = false;
        e.startsWith("-") ? (t = true, e = e.slice(1)) : e.startsWith("+") && (e = e.slice(1));
        let n, r = e.match(/^(\d+)#([a-zA-Z0-9@_]+)$/);
        if (r) {
            let s = Number.parseInt(r[1], 10);
            s >= 2 && s <= 64 ? n = RN(r[2], s) : n = 0;
        } else /^0[xX][0-9a-fA-F]+$/.test(e) ? n = Number.parseInt(e, 16) : /^0[0-7]+$/.test(e) ? n = Number.parseInt(e, 8) : n = Number.parseInt(e, 10);
        return Number.isNaN(n) && (n = 0), t ? -n : n;
    }
    function Ci(e) {
        if (e = e.trim(), e === "") return {
            value: 0,
            valid: true
        };
        let t = false;
        if (e.startsWith("-") ? (t = true, e = e.slice(1)) : e.startsWith("+") && (e = e.slice(1)), !/^\d+$/.test(e)) return {
            value: 0,
            valid: false
        };
        let n = Number.parseInt(e, 10);
        return Number.isNaN(n) ? {
            value: 0,
            valid: false
        } : {
            value: t ? -n : n,
            valid: true
        };
    }
    function PN(e) {
        let t = "", n = 0;
        for(; n < e.length;)if (e[n] === "\\" && n + 1 < e.length) t += e[n] + e[n + 1], n += 2;
        else if (e[n] === "[") {
            let r = TN(e, n);
            t += r.converted, n = r.endIndex;
        } else t += e[n], n++;
        return t;
    }
    function TN(e, t) {
        let n = t + 1, r = "[";
        n < e.length && (e[n] === "^" || e[n] === "!") && (r += "^", n++);
        let s = false;
        n < e.length && e[n] === "]" && (s = true, n++);
        let i = false;
        n < e.length && e[n] === "[" && n + 1 < e.length && e[n + 1] !== ":" && (i = true, n++);
        let o = "", a = false;
        for(; n < e.length;){
            let l = e[n];
            if (l === "]") {
                a = true, n++;
                break;
            }
            if (l === "[" && n + 1 < e.length && e[n + 1] === ":") {
                let c = e.indexOf(":]", n + 2);
                if (c !== -1) {
                    let u = e.slice(n + 2, c);
                    o += ON(u), n = c + 2;
                    continue;
                }
            }
            if (l === "[" && n + 1 < e.length) {
                let c = e[n + 1];
                if (c === "." || c === "=") {
                    let u = `${c}]`, f = e.indexOf(u, n + 2);
                    if (f !== -1) {
                        let p = e.slice(n + 2, f);
                        o += p, n = f + 2;
                        continue;
                    }
                }
            }
            if (l === "\\" && n + 1 < e.length) {
                o += l + e[n + 1], n += 2;
                continue;
            }
            o += l, n++;
        }
        return a ? (s && (r += "\\]"), i && (r += "\\["), r += o, r += "]", {
            converted: r,
            endIndex: n
        }) : {
            converted: "\\[",
            endIndex: t + 1
        };
    }
    function ON(e) {
        return {
            alnum: "a-zA-Z0-9",
            alpha: "a-zA-Z",
            ascii: "\\x00-\\x7F",
            blank: " \\t",
            cntrl: "\\x00-\\x1F\\x7F",
            digit: "0-9",
            graph: "!-~",
            lower: "a-z",
            print: " -~",
            punct: "!-/:-@\\[-`{-~",
            space: " \\t\\n\\r\\f\\v",
            upper: "A-Z",
            word: "a-zA-Z0-9_",
            xdigit: "0-9A-Fa-f"
        }[e] ?? "";
    }
    ot();
    Je();
    Fe();
    it();
    on$1();
    function Vt(e) {
        let t = [], n = "", r = false, s = false, i = false, o = false;
        for (let a of e){
            if (i) {
                n += a, i = false, o = true;
                continue;
            }
            if (a === "\\") {
                i = true;
                continue;
            }
            if (a === "'" && !s) {
                r || (o = true), r = !r;
                continue;
            }
            if (a === '"' && !r) {
                s || (o = true), s = !s;
                continue;
            }
            if ((a === " " || a === "	" || a === `
`) && !r && !s) {
                o && (t.push(n), n = "", o = false);
                continue;
            }
            n += a, o = true;
        }
        return o && t.push(n), t;
    }
    function Ni(e) {
        let t = [], n = 0;
        for(; n < e.length;){
            for(; n < e.length && /\s/.test(e[n]);)n++;
            if (n >= e.length) break;
            if (e[n] !== "[") {
                n++;
                continue;
            }
            n++;
            let r = "";
            if (e[n] === "'" || e[n] === '"') {
                let i = e[n];
                for(n++; n < e.length && e[n] !== i;)r += e[n], n++;
                e[n] === i && n++;
            } else for(; n < e.length && e[n] !== "]" && e[n] !== "=";)r += e[n], n++;
            for(; n < e.length && e[n] !== "]";)n++;
            if (e[n] === "]" && n++, e[n] !== "=") continue;
            n++;
            let s = "";
            if (e[n] === "'" || e[n] === '"') {
                let i = e[n];
                for(n++; n < e.length && e[n] !== i;)e[n] === "\\" && n + 1 < e.length && n++, s += e[n], n++;
                e[n] === i && n++;
            } else for(; n < e.length && !/\s/.test(e[n]);)s += e[n], n++;
            t.push([
                r,
                s
            ]);
        }
        return t;
    }
    function U0(e) {
        let t = e.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
        if (t) return {
            name: t[1],
            isArray: true,
            arrayElements: Vt(t[2])
        };
        let n = e.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([^\]]+)\]=(.*)$/s);
        if (n) return {
            name: n[1],
            isArray: false,
            arrayIndex: n[2],
            value: n[3]
        };
        if (e.includes("=")) {
            let r = e.indexOf("=");
            return {
                name: e.slice(0, r),
                isArray: false,
                value: e.slice(r + 1)
            };
        }
        return {
            name: e,
            isArray: false
        };
    }
    async function DN(e, t) {
        try {
            let n = new se(), r = he(n, t);
            return await Q(e, r.expression);
        } catch  {
            let n = parseInt(t, 10);
            return Number.isNaN(n) ? 0 : n;
        }
    }
    async function z0(e, t, n = {}) {
        let { name: r, isArray: s, arrayElements: i, value: o, arrayIndex: a } = t, { makeReadonly: l = false, checkReadonly: c = true } = n;
        if (c) {
            je(e, r);
        }
        if (s && i) {
            for(let u = 0; u < i.length; u++)e.state.env[`${r}_${u}`] = i[u];
            e.state.env[`${r}__length`] = String(i.length);
        } else if (a !== void 0 && o !== void 0) {
            let u = await DN(e, a);
            e.state.env[`${r}_${u}`] = o;
            let f = parseInt(e.state.env[`${r}__length`] ?? "0", 10);
            u >= f && (e.state.env[`${r}__length`] = String(u + 1));
        } else o !== void 0 && (e.state.env[r] = o);
        return l && gt(e, r), null;
    }
    function cn(e, t) {
        e.state.localVarDepth = e.state.localVarDepth || new Map(), e.state.localVarDepth.set(t, e.state.callDepth);
    }
    function ar(e, t) {
        return e.state.localVarDepth?.get(t);
    }
    function ki(e, t) {
        e.state.localVarDepth?.delete(t);
    }
    function j0(e, t, n) {
        e.state.localVarStack = e.state.localVarStack || new Map();
        let r = e.state.localVarStack.get(t) || [];
        r.push({
            value: n,
            scopeIndex: e.state.localScopes.length - 1
        }), e.state.localVarStack.set(t, r);
    }
    function vi(e, t) {
        let n = e.state.localVarStack?.get(t);
        if (!(!n || n.length === 0)) return n.pop();
    }
    function H0(e, t) {
        if (e.state.localVarStack) for (let [n, r] of e.state.localVarStack.entries()){
            for(; r.length > 0 && r[r.length - 1].scopeIndex === t;)r.pop();
            r.length === 0 && e.state.localVarStack.delete(n);
        }
    }
    de();
    ot();
    var al = new Set([
        ":",
        ".",
        "break",
        "continue",
        "eval",
        "exec",
        "exit",
        "export",
        "readonly",
        "return",
        "set",
        "shift",
        "trap",
        "unset"
    ]);
    function V0(e) {
        return al.has(e);
    }
    var ll = new Set([
        "if",
        "then",
        "else",
        "elif",
        "fi",
        "case",
        "esac",
        "for",
        "select",
        "while",
        "until",
        "do",
        "done",
        "in",
        "function",
        "{",
        "}",
        "time",
        "[[",
        "]]",
        "!"
    ]), jr = new Set([
        ":",
        "true",
        "false",
        "cd",
        "export",
        "unset",
        "exit",
        "local",
        "set",
        "break",
        "continue",
        "return",
        "eval",
        "shift",
        "getopts",
        "compgen",
        "complete",
        "compopt",
        "pushd",
        "popd",
        "dirs",
        "source",
        ".",
        "read",
        "mapfile",
        "readarray",
        "declare",
        "typeset",
        "readonly",
        "let",
        "command",
        "shopt",
        "exec",
        "test",
        "[",
        "echo",
        "printf",
        "pwd",
        "alias",
        "unalias",
        "type",
        "hash",
        "ulimit",
        "umask",
        "trap",
        "times",
        "wait",
        "kill",
        "jobs",
        "fg",
        "bg",
        "disown",
        "suspend",
        "fc",
        "history",
        "help",
        "enable",
        "builtin",
        "caller"
    ]);
    ot();
    async function $n(e, t, n, r) {
        try {
            if ((await e.fs.stat(t)).isDirectory) return `bash: ${n}: Is a directory
`;
            if (r.checkNoclobber && e.state.options.noclobber && !r.isClobber && n !== "/dev/null") return `bash: ${n}: cannot overwrite existing file
`;
        } catch  {}
        return null;
    }
    function He(e) {
        for(let t = 0; t < e.length; t++)if (e.charCodeAt(t) > 255) return "utf8";
        return "binary";
    }
    function FN(e) {
        if (!e.startsWith("__rw__:")) return null;
        let t = e.slice(7), n = t.indexOf(":");
        if (n === -1) return null;
        let r = Number.parseInt(t.slice(0, n), 10);
        if (Number.isNaN(r) || r < 0) return null;
        let s = n + 1, i = t.slice(s, s + r), o = s + r + 1, a = t.slice(o), l = a.indexOf(":");
        if (l === -1) return null;
        let c = Number.parseInt(a.slice(0, l), 10);
        if (Number.isNaN(c) || c < 0) return null;
        let u = a.slice(l + 1);
        return {
            path: i,
            position: c,
            content: u
        };
    }
    async function q0(e, t) {
        let n = new Map();
        for(let r = 0; r < t.length; r++){
            let s = t[r];
            if (s.target.type === "HereDoc") continue;
            if (s.operator === ">&" || s.operator === "<&") {
                if (Wr(e, s.target)) return {
                    targets: n,
                    error: `bash: $@: ambiguous redirect
`
                };
                n.set(r, await J(e, s.target));
            } else {
                let o = await Br(e, s.target);
                if ("error" in o) return {
                    targets: n,
                    error: o.error
                };
                n.set(r, o.target);
            }
        }
        return {
            targets: n
        };
    }
    function _N(e) {
        e.state.nextFd === void 0 && (e.state.nextFd = 10);
        let t = e.state.nextFd;
        return e.state.nextFd++, t;
    }
    async function $i(e, t) {
        for (let n of t){
            if (!n.fdVariable) continue;
            if (e.state.fileDescriptors || (e.state.fileDescriptors = new Map()), (n.operator === ">&" || n.operator === "<&") && n.target.type === "Word" && await J(e, n.target) === "-") {
                let i = e.state.env[n.fdVariable];
                if (i !== void 0) {
                    let o = Number.parseInt(i, 10);
                    Number.isNaN(o) || e.state.fileDescriptors.delete(o);
                }
                continue;
            }
            let r = _N(e);
            if (e.state.env[n.fdVariable] = String(r), n.target.type === "Word") {
                let s = await J(e, n.target);
                if (n.operator === ">&" || n.operator === "<&") {
                    let i = Number.parseInt(s, 10);
                    if (!Number.isNaN(i)) {
                        let o = e.state.fileDescriptors.get(i);
                        o !== void 0 && e.state.fileDescriptors.set(r, o);
                        continue;
                    }
                }
                if (n.operator === ">" || n.operator === ">>" || n.operator === ">|" || n.operator === "&>" || n.operator === "&>>") {
                    let i = e.fs.resolvePath(e.state.cwd, s);
                    (n.operator === ">" || n.operator === ">|" || n.operator === "&>") && await e.fs.writeFile(i, "", "binary"), e.state.fileDescriptors.set(r, `__file__:${i}`);
                } else if (n.operator === "<<<") e.state.fileDescriptors.set(r, `${s}
`);
                else if (n.operator === "<" || n.operator === "<>") try {
                    let i = e.fs.resolvePath(e.state.cwd, s), o = await e.fs.readFile(i);
                    e.state.fileDescriptors.set(r, o);
                } catch  {
                    return W("", `bash: ${s}: No such file or directory
`, 1);
                }
            }
        }
        return null;
    }
    async function qt(e, t) {
        for (let n of t){
            if (n.target.type === "HereDoc") continue;
            let r = n.operator === ">&";
            if (n.operator !== ">" && n.operator !== ">|" && n.operator !== "&>" && !r) continue;
            let s;
            if (r) {
                if (s = await J(e, n.target), s === "-" || !Number.isNaN(Number.parseInt(s, 10)) || n.fd != null) continue;
            } else {
                let a = await Br(e, n.target);
                if ("error" in a) return W("", a.error, 1);
                s = a.target;
            }
            let i = e.fs.resolvePath(e.state.cwd, s), o = n.operator === ">|";
            try {
                let a = await e.fs.stat(i);
                if (a.isDirectory) return W("", `bash: ${s}: Is a directory
`, 1);
                if (e.state.options.noclobber && !o && !a.isDirectory && s !== "/dev/null") return W("", `bash: ${s}: cannot overwrite existing file
`, 1);
            } catch  {}
            if (s !== "/dev/null" && s !== "/dev/stdout" && s !== "/dev/stderr" && s !== "/dev/full" && await e.fs.writeFile(i, "", "binary"), s === "/dev/full") return W("", `bash: /dev/full: No space left on device
`, 1);
        }
        return null;
    }
    async function $e(e, t, n, r) {
        let { stdout: s, stderr: i, exitCode: o } = t;
        for(let c = 0; c < n.length; c++){
            let u = n[c];
            if (u.target.type === "HereDoc") continue;
            let f, p = r?.get(c);
            if (p !== void 0) f = p;
            else if (u.operator === ">&" || u.operator === "<&") {
                if (Wr(e, u.target)) {
                    i += `bash: $@: ambiguous redirect
`, o = 1, s = "";
                    continue;
                }
                f = await J(e, u.target);
            } else {
                let m = await Br(e, u.target);
                if ("error" in m) {
                    i += m.error, o = 1, s = "";
                    continue;
                }
                f = m.target;
            }
            if (!u.fdVariable) switch(u.operator){
                case ">":
                case ">|":
                    {
                        let d = u.fd ?? 1, m = u.operator === ">|";
                        if (d === 1) {
                            if (f === "/dev/stdout") break;
                            if (f === "/dev/stderr") {
                                i += s, s = "";
                                break;
                            }
                            if (f === "/dev/full") {
                                i += `bash: echo: write error: No space left on device
`, o = 1, s = "";
                                break;
                            }
                            let h = e.fs.resolvePath(e.state.cwd, f), g = await $n(e, h, f, {
                                checkNoclobber: true,
                                isClobber: m
                            });
                            if (g) {
                                i += g, o = 1, s = "";
                                break;
                            }
                            await e.fs.writeFile(h, s, He(s)), s = "";
                        } else if (d === 2) {
                            if (f === "/dev/stderr") break;
                            if (f === "/dev/stdout") {
                                s += i, i = "";
                                break;
                            }
                            if (f === "/dev/full") {
                                i += `bash: echo: write error: No space left on device
`, o = 1;
                                break;
                            }
                            if (f === "/dev/null") i = "";
                            else {
                                let h = e.fs.resolvePath(e.state.cwd, f), g = await $n(e, h, f, {
                                    checkNoclobber: true,
                                    isClobber: m
                                });
                                if (g) {
                                    i += g, o = 1;
                                    break;
                                }
                                await e.fs.writeFile(h, i, He(i)), i = "";
                            }
                        }
                        break;
                    }
                case ">>":
                    {
                        let d = u.fd ?? 1;
                        if (d === 1) {
                            if (f === "/dev/stdout") break;
                            if (f === "/dev/stderr") {
                                i += s, s = "";
                                break;
                            }
                            if (f === "/dev/full") {
                                i += `bash: echo: write error: No space left on device
`, o = 1, s = "";
                                break;
                            }
                            let m = e.fs.resolvePath(e.state.cwd, f), h = await $n(e, m, f, {});
                            if (h) {
                                i += h, o = 1, s = "";
                                break;
                            }
                            await e.fs.appendFile(m, s, He(s)), s = "";
                        } else if (d === 2) {
                            if (f === "/dev/stderr") break;
                            if (f === "/dev/stdout") {
                                s += i, i = "";
                                break;
                            }
                            if (f === "/dev/full") {
                                i += `bash: echo: write error: No space left on device
`, o = 1;
                                break;
                            }
                            let m = e.fs.resolvePath(e.state.cwd, f), h = await $n(e, m, f, {});
                            if (h) {
                                i += h, o = 1;
                                break;
                            }
                            await e.fs.appendFile(m, i, He(i)), i = "";
                        }
                        break;
                    }
                case ">&":
                case "<&":
                    {
                        let d = u.fd ?? 1;
                        if (f === "-") break;
                        if (f.endsWith("-")) {
                            let m = f.slice(0, -1), h = Number.parseInt(m, 10);
                            if (!Number.isNaN(h)) {
                                let g = e.state.fileDescriptors?.get(h);
                                g !== void 0 ? (e.state.fileDescriptors || (e.state.fileDescriptors = new Map()), e.state.fileDescriptors.set(d, g), h >= 3 && e.state.fileDescriptors?.delete(h)) : h === 1 || h === 2 ? (e.state.fileDescriptors || (e.state.fileDescriptors = new Map()), e.state.fileDescriptors.set(d, `__dupout__:${h}`)) : h === 0 ? (e.state.fileDescriptors || (e.state.fileDescriptors = new Map()), e.state.fileDescriptors.set(d, `__dupin__:${h}`)) : h >= 3 && (i += `bash: ${h}: Bad file descriptor
`, o = 1);
                            }
                            break;
                        }
                        if (f === "2" || f === "&2") d === 1 && (i += s, s = "");
                        else if (f === "1" || f === "&1") s += i, i = "";
                        else {
                            let m = Number.parseInt(f, 10);
                            if (Number.isNaN(m)) {
                                if (u.operator === ">&") {
                                    let h = e.fs.resolvePath(e.state.cwd, f), g = await $n(e, h, f, {
                                        checkNoclobber: true
                                    });
                                    if (g) {
                                        i = g, o = 1, s = "";
                                        break;
                                    }
                                    if (u.fd == null) {
                                        let b = s + i;
                                        await e.fs.writeFile(h, b, He(b)), s = "", i = "";
                                    } else d === 1 ? (await e.fs.writeFile(h, s, He(s)), s = "") : d === 2 && (await e.fs.writeFile(h, i, He(i)), i = "");
                                }
                            } else {
                                let h = e.state.fileDescriptors?.get(m);
                                if (h?.startsWith("__file__:")) {
                                    let g = h.slice(9);
                                    d === 1 ? (await e.fs.appendFile(g, s, He(s)), s = "") : d === 2 && (await e.fs.appendFile(g, i, He(i)), i = "");
                                } else if (h?.startsWith("__rw__:")) {
                                    let g = FN(h);
                                    g && (d === 1 ? (await e.fs.appendFile(g.path, s, He(s)), s = "") : d === 2 && (await e.fs.appendFile(g.path, i, He(i)), i = ""));
                                } else if (h?.startsWith("__dupout__:")) {
                                    let g = Number.parseInt(h.slice(11), 10);
                                    if (g !== 1) if (g === 2) d === 1 && (i += s, s = "");
                                    else {
                                        let b = e.state.fileDescriptors?.get(g);
                                        if (b?.startsWith("__file__:")) {
                                            let y = b.slice(9);
                                            d === 1 ? (await e.fs.appendFile(y, s, He(s)), s = "") : d === 2 && (await e.fs.appendFile(y, i, He(i)), i = "");
                                        }
                                    }
                                } else h?.startsWith("__dupin__:") ? (i += `bash: ${m}: Bad file descriptor
`, o = 1, s = "") : m >= 3 && (i += `bash: ${m}: Bad file descriptor
`, o = 1, s = "");
                            }
                        }
                        break;
                    }
                case "&>":
                    {
                        if (f === "/dev/full") {
                            i = `bash: echo: write error: No space left on device
`, o = 1, s = "";
                            break;
                        }
                        let d = e.fs.resolvePath(e.state.cwd, f), m = await $n(e, d, f, {
                            checkNoclobber: true
                        });
                        if (m) {
                            i = m, o = 1, s = "";
                            break;
                        }
                        let h = s + i;
                        await e.fs.writeFile(d, h, He(h)), s = "", i = "";
                        break;
                    }
                case "&>>":
                    {
                        if (f === "/dev/full") {
                            i = `bash: echo: write error: No space left on device
`, o = 1, s = "";
                            break;
                        }
                        let d = e.fs.resolvePath(e.state.cwd, f), m = await $n(e, d, f, {});
                        if (m) {
                            i = m, o = 1, s = "";
                            break;
                        }
                        let h = s + i;
                        await e.fs.appendFile(d, h, He(h)), s = "", i = "";
                        break;
                    }
            }
        }
        let a = e.state.fileDescriptors?.get(1);
        if (a) {
            if (a === "__dupout__:2") i += s, s = "";
            else if (a.startsWith("__file__:")) {
                let c = a.slice(9);
                await e.fs.appendFile(c, s, He(s)), s = "";
            } else if (a.startsWith("__file_append__:")) {
                let c = a.slice(16);
                await e.fs.appendFile(c, s, He(s)), s = "";
            }
        }
        let l = e.state.fileDescriptors?.get(2);
        if (l) {
            if (l === "__dupout__:1") s += i, i = "";
            else if (l.startsWith("__file__:")) {
                let c = l.slice(9);
                await e.fs.appendFile(c, i, He(i)), i = "";
            } else if (l.startsWith("__file_append__:")) {
                let c = l.slice(16);
                await e.fs.appendFile(c, i, He(i)), i = "";
            }
        }
        return W(s, i, o);
    }
    function G0(e, t) {
        if (e.state.options.posix && al.has(t.name)) {
            let r = `bash: line ${e.state.currentLine}: \`${t.name}': is a special builtin
`;
            throw new ae(2, "", r);
        }
        let n = {
            ...t,
            sourceFile: t.sourceFile ?? e.state.currentSource ?? "main"
        };
        return e.state.functions.set(t.name, n), le;
    }
    async function LN(e, t) {
        let n = "";
        for (let r of t)if ((r.operator === "<<" || r.operator === "<<-") && r.target.type === "HereDoc") {
            let s = r.target, i = await J(e, s.content);
            s.stripTabs && (i = i.split(`
`).map((a)=>a.replace(/^\t+/, "")).join(`
`)), (r.fd ?? 0) === 0 && (n = i);
        } else if (r.operator === "<<<" && r.target.type === "Word") n = `${await J(e, r.target)}
`;
        else if (r.operator === "<" && r.target.type === "Word") {
            let s = await J(e, r.target), i = e.fs.resolvePath(e.state.cwd, s);
            try {
                n = await e.fs.readFile(i);
            } catch  {}
        }
        return n;
    }
    async function Ii(e, t, n, r = "", s) {
        e.state.callDepth++, e.state.callDepth > e.limits.maxCallDepth && (e.state.callDepth--, Xt(`${t.name}: maximum recursion depth (${e.limits.maxCallDepth}) exceeded, increase executionLimits.maxCallDepth`, "recursion")), e.state.funcNameStack || (e.state.funcNameStack = []), e.state.callLineStack || (e.state.callLineStack = []), e.state.sourceStack || (e.state.sourceStack = []), e.state.funcNameStack.unshift(t.name), e.state.callLineStack.unshift(e.state.currentLine), e.state.sourceStack.unshift(t.sourceFile ?? "main"), e.state.localScopes.push(new Map()), e.state.localExportedVars || (e.state.localExportedVars = []), e.state.localExportedVars.push(new Set());
        let i = {};
        for(let c = 0; c < n.length; c++)i[String(c + 1)] = e.state.env[String(c + 1)], e.state.env[String(c + 1)] = n[c];
        i["@"] = e.state.env["@"], i["#"] = e.state.env["#"], e.state.env["@"] = n.join(" "), e.state.env["#"] = String(n.length);
        let o = ()=>{
            let c = e.state.localScopes.length - 1, u = e.state.localScopes.pop();
            if (u) for (let [f, p] of u)p === void 0 ? delete e.state.env[f] : e.state.env[f] = p;
            if (H0(e, c), e.state.fullyUnsetLocals) for (let [f, p] of e.state.fullyUnsetLocals.entries())p === c && e.state.fullyUnsetLocals.delete(f);
            if (e.state.localExportedVars && e.state.localExportedVars.length > 0) {
                let f = e.state.localExportedVars.pop();
                if (f) for (let p of f)e.state.exportedVars?.delete(p);
            }
            for (let [f, p] of Object.entries(i))p === void 0 ? delete e.state.env[f] : e.state.env[f] = p;
            e.state.funcNameStack?.shift(), e.state.callLineStack?.shift(), e.state.sourceStack?.shift(), e.state.callDepth--;
        }, { targets: a, error: l } = await q0(e, t.redirections);
        if (l) return o(), W("", l, 1);
        try {
            let c = await LN(e, t.redirections), u = r || c, f = await e.executeCommand(t.body, u);
            return o(), $e(e, f, t.redirections, a);
        } catch (c) {
            if (o(), c instanceof Ve) {
                let u = W(c.stdout, c.stderr, c.exitCode);
                return $e(e, u, t.redirections, a);
            }
            throw c;
        }
    }
    var Q0 = [
        "!",
        "[[",
        "]]",
        "case",
        "do",
        "done",
        "elif",
        "else",
        "esac",
        "fi",
        "for",
        "function",
        "if",
        "in",
        "then",
        "time",
        "until",
        "while",
        "{",
        "}"
    ], ul = [
        ".",
        ":",
        "[",
        "alias",
        "bg",
        "bind",
        "break",
        "builtin",
        "caller",
        "cd",
        "command",
        "compgen",
        "complete",
        "compopt",
        "continue",
        "declare",
        "dirs",
        "disown",
        "echo",
        "enable",
        "eval",
        "exec",
        "exit",
        "export",
        "false",
        "fc",
        "fg",
        "getopts",
        "hash",
        "help",
        "history",
        "jobs",
        "kill",
        "let",
        "local",
        "logout",
        "mapfile",
        "popd",
        "printf",
        "pushd",
        "pwd",
        "read",
        "readarray",
        "readonly",
        "return",
        "set",
        "shift",
        "shopt",
        "source",
        "suspend",
        "test",
        "times",
        "trap",
        "true",
        "type",
        "typeset",
        "ulimit",
        "umask",
        "unalias",
        "unset",
        "wait"
    ], MN = [
        "autocd",
        "assoc_expand_once",
        "cdable_vars",
        "cdspell",
        "checkhash",
        "checkjobs",
        "checkwinsize",
        "cmdhist",
        "compat31",
        "compat32",
        "compat40",
        "compat41",
        "compat42",
        "compat43",
        "compat44",
        "complete_fullquote",
        "direxpand",
        "dirspell",
        "dotglob",
        "execfail",
        "expand_aliases",
        "extdebug",
        "extglob",
        "extquote",
        "failglob",
        "force_fignore",
        "globasciiranges",
        "globstar",
        "gnu_errfmt",
        "histappend",
        "histreedit",
        "histverify",
        "hostcomplete",
        "huponexit",
        "inherit_errexit",
        "interactive_comments",
        "lastpipe",
        "lithist",
        "localvar_inherit",
        "localvar_unset",
        "login_shell",
        "mailwarn",
        "no_empty_cmd_completion",
        "nocaseglob",
        "nocasematch",
        "nullglob",
        "progcomp",
        "progcomp_alias",
        "promptvars",
        "restricted_shell",
        "shift_verbose",
        "sourcepath",
        "xpg_echo"
    ], WN = ul;
    async function fl(e, t) {
        let n = [], r = null, s = "", i = "", o = null, a = false, l = false, c = false, u = null, f = null, p = null, d = [], m = [
            "alias",
            "arrayvar",
            "binding",
            "builtin",
            "command",
            "directory",
            "disabled",
            "enabled",
            "export",
            "file",
            "function",
            "group",
            "helptopic",
            "hostname",
            "job",
            "keyword",
            "running",
            "service",
            "setopt",
            "shopt",
            "signal",
            "stopped",
            "user",
            "variable"
        ];
        for(let E = 0; E < t.length; E++){
            let C = t[E];
            if (C === "-v") n.push("variable");
            else if (C === "-e") n.push("export");
            else if (C === "-f") n.push("file");
            else if (C === "-d") n.push("directory");
            else if (C === "-k") n.push("keyword");
            else if (C === "-A") {
                if (E++, E >= t.length) return M(`compgen: -A: option requires an argument
`, 2);
                let A = t[E];
                if (!m.includes(A)) return M(`compgen: ${A}: invalid action name
`, 2);
                n.push(A);
            } else if (C === "-W") {
                if (E++, E >= t.length) return M(`compgen: -W: option requires an argument
`, 2);
                r = t[E];
            } else if (C === "-P") {
                if (E++, E >= t.length) return M(`compgen: -P: option requires an argument
`, 2);
                s = t[E];
            } else if (C === "-S") {
                if (E++, E >= t.length) return M(`compgen: -S: option requires an argument
`, 2);
                i = t[E];
            } else if (C === "-o") {
                if (E++, E >= t.length) return M(`compgen: -o: option requires an argument
`, 2);
                let A = t[E];
                if (A === "plusdirs") a = true;
                else if (A === "dirnames") l = true;
                else if (A === "default") c = true;
                else if (!(A === "filenames" || A === "nospace" || A === "bashdefault" || A === "noquote")) return M(`compgen: ${A}: invalid option name
`, 2);
            } else if (C === "-F") {
                if (E++, E >= t.length) return M(`compgen: -F: option requires an argument
`, 2);
                f = t[E];
            } else if (C === "-C") {
                if (E++, E >= t.length) return M(`compgen: -C: option requires an argument
`, 2);
                p = t[E];
            } else if (C === "-X") {
                if (E++, E >= t.length) return M(`compgen: -X: option requires an argument
`, 2);
                u = t[E];
            } else if (C === "-G") {
                if (E++, E >= t.length) return M(`compgen: -G: option requires an argument
`, 2);
            } else if (C === "--") {
                d.push(...t.slice(E + 1));
                break;
            } else C.startsWith("-") || d.push(C);
        }
        o = d[0] ?? null;
        let h = [];
        if (l) {
            let E = await cl(e, o);
            h.push(...E);
        }
        if (c) {
            let E = await Z0(e, o);
            h.push(...E);
        }
        for (let E of n)if (E === "variable") {
            let C = BN(e, o);
            h.push(...C);
        } else if (E === "export") {
            let C = UN(e, o);
            h.push(...C);
        } else if (E === "function") {
            let C = zN(e, o);
            h.push(...C);
        } else if (E === "builtin") {
            let C = jN(o);
            h.push(...C);
        } else if (E === "keyword") {
            let C = HN(o);
            h.push(...C);
        } else if (E === "alias") {
            let C = VN(e, o);
            h.push(...C);
        } else if (E === "shopt") {
            let C = qN(o);
            h.push(...C);
        } else if (E === "helptopic") {
            let C = GN(o);
            h.push(...C);
        } else if (E === "directory") {
            let C = await cl(e, o);
            h.push(...C);
        } else if (E === "file") {
            let C = await Z0(e, o);
            h.push(...C);
        } else if (E === "user") {
            let C = ZN();
            h.push(...C);
        } else if (E === "command") {
            let C = await QN(e, o);
            h.push(...C);
        }
        if (r !== null) try {
            let E = await KN(e, r), C = XN(e, E);
            for (let A of C)(o === null || A.startsWith(o)) && h.push(A);
        } catch  {
            return W("", "", 1);
        }
        if (a) {
            let E = await cl(e, o);
            for (let C of E)h.includes(C) || h.push(C);
        }
        let g = "";
        if (f !== null) {
            let E = e.state.functions.get(f);
            if (E) {
                let C = {};
                C.COMP_WORDS__length = e.state.env.COMP_WORDS__length, e.state.env.COMP_WORDS__length = "0", C.COMP_CWORD = e.state.env.COMP_CWORD, e.state.env.COMP_CWORD = "-1", C.COMP_LINE = e.state.env.COMP_LINE, e.state.env.COMP_LINE = "", C.COMP_POINT = e.state.env.COMP_POINT, e.state.env.COMP_POINT = "0";
                let A = {};
                for (let O of Object.keys(e.state.env))(O === "COMPREPLY" || O.startsWith("COMPREPLY_") || O === "COMPREPLY__length") && (A[O] = e.state.env[O], delete e.state.env[O]);
                let I = [
                    "compgen",
                    d[0] ?? "",
                    ""
                ];
                try {
                    let O = await Ii(e, E, I, "");
                    if (O.exitCode !== 0) return lr(e, C), lr(e, A), W("", O.stderr, 1);
                    g = O.stdout;
                    let L = JN(e);
                    h.push(...L);
                } catch  {
                    return lr(e, C), lr(e, A), W("", "", 1);
                }
                lr(e, C), lr(e, A);
            }
        }
        if (p !== null) try {
            let E = Bt(p), C = await e.executeScript(E);
            if (C.exitCode !== 0) return W("", C.stderr, C.exitCode);
            if (C.stdout) {
                let A = C.stdout.split(`
`);
                for (let I of A)I.length > 0 && h.push(I);
            }
        } catch (E) {
            if (E.name === "ParseException") return M(`compgen: -C: ${E.message}
`, 2);
            throw E;
        }
        let b = h;
        if (u !== null) {
            let E = u.startsWith("!"), C = E ? u.slice(1) : u;
            b = h.filter((A)=>{
                let I = or(A, C, false, true);
                return E ? I : !I;
            });
        }
        if (b.length === 0 && o !== null) return W(g, "", 1);
        let y = b.map((E)=>`${s}${E}${i}`).join(`
`), w = g + (y ? `${y}
` : "");
        return ue(w);
    }
    function BN(e, t) {
        let n = new Set();
        for (let s of Object.keys(e.state.env)){
            if (s.includes("_") && /^[a-zA-Z_][a-zA-Z0-9_]*_\d+$/.test(s) || s.endsWith("__length")) continue;
            let i = s.split("_")[0];
            /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s) ? n.add(s) : i && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(i) && e.state.env[`${i}__length`] !== void 0 && n.add(i);
        }
        let r = Array.from(n);
        return t !== null && (r = r.filter((s)=>s.startsWith(t))), r.sort();
    }
    function UN(e, t) {
        let n = e.state.exportedVars ?? new Set(), r = Array.from(n);
        return t !== null && (r = r.filter((s)=>s.startsWith(t))), r = r.filter((s)=>s.includes("_") && /^[a-zA-Z_][a-zA-Z0-9_]*_\d+$/.test(s) || s.endsWith("__length") ? false : e.state.env[s] !== void 0), r.sort();
    }
    function zN(e, t) {
        let n = Array.from(e.state.functions.keys());
        return t !== null && (n = n.filter((r)=>r.startsWith(t))), n.sort();
    }
    function jN(e) {
        let t = [
            ...ul
        ];
        return e !== null && (t = t.filter((n)=>n.startsWith(e))), t.sort();
    }
    function HN(e) {
        let t = [
            ...Q0
        ];
        return e !== null && (t = t.filter((n)=>n.startsWith(e))), t.sort();
    }
    function VN(e, t) {
        let n = [];
        for (let s of Object.keys(e.state.env))if (s.startsWith("BASH_ALIAS_")) {
            let i = s.slice(11);
            n.push(i);
        }
        let r = n;
        return t !== null && (r = r.filter((s)=>s.startsWith(t))), r.sort();
    }
    function qN(e) {
        let t = [
            ...MN
        ];
        return e !== null && (t = t.filter((n)=>n.startsWith(e))), t.sort();
    }
    function GN(e) {
        let t = [
            ...WN
        ];
        return e !== null && (t = t.filter((n)=>n.startsWith(e))), t.sort();
    }
    async function cl(e, t) {
        let n = [];
        try {
            let r = e.state.cwd, s = t ?? "";
            if (t) {
                let o = t.lastIndexOf("/");
                if (o !== -1) {
                    let a = t.slice(0, o) || "/";
                    s = t.slice(o + 1), a.startsWith("/") ? r = a : r = `${e.state.cwd}/${a}`;
                }
            }
            let i = await e.fs.readdir(r);
            for (let o of i){
                let a = `${r}/${o}`;
                try {
                    if ((await e.fs.stat(a)).isDirectory && (!s || o.startsWith(s))) if (t?.includes("/")) {
                        let c = t.lastIndexOf("/"), u = t.slice(0, c + 1);
                        n.push(u + o);
                    } else n.push(o);
                } catch  {}
            }
        } catch  {}
        return n.sort();
    }
    async function Z0(e, t) {
        let n = [];
        try {
            let r = e.state.cwd, s = t ?? "";
            if (t) {
                let o = t.lastIndexOf("/");
                if (o !== -1) {
                    let a = t.slice(0, o) || "/";
                    s = t.slice(o + 1), a.startsWith("/") ? r = a : r = `${e.state.cwd}/${a}`;
                }
            }
            let i = await e.fs.readdir(r);
            for (let o of i)if (!s || o.startsWith(s)) if (t?.includes("/")) {
                let a = t.lastIndexOf("/"), l = t.slice(0, a + 1);
                n.push(l + o);
            } else n.push(o);
        } catch  {}
        return n.sort();
    }
    function ZN(e) {
        return [
            "root",
            "nobody"
        ];
    }
    async function QN(e, t) {
        let n = new Set();
        for (let i of ul)n.add(i);
        for (let i of e.state.functions.keys())n.add(i);
        for (let i of Object.keys(e.state.env))i.startsWith("BASH_ALIAS_") && n.add(i.slice(11));
        for (let i of Q0)n.add(i);
        let r = e.state.env.PATH ?? "/usr/bin:/bin";
        for (let i of r.split(":"))if (i) try {
            let o = await e.fs.readdir(i);
            for (let a of o)n.add(a);
        } catch  {}
        let s = Array.from(n);
        return t !== null && (s = s.filter((i)=>i.startsWith(t))), s.sort();
    }
    async function KN(e, t) {
        let r = new se().parseWordFromString(t, false, false);
        return await J(e, r);
    }
    function XN(e, t) {
        let n = e.state.env.IFS ?? ` 	
`;
        if (n.length === 0) return [
            t
        ];
        let r = new Set(n.split("")), s = [], i = "", o = 0;
        for(; o < t.length;){
            let a = t[o];
            if (a === "\\" && o + 1 < t.length) {
                let l = t[o + 1];
                i += l, o += 2;
            } else r.has(a) ? (i.length > 0 && (s.push(i), i = ""), o++) : (i += a, o++);
        }
        return i.length > 0 && s.push(i), s;
    }
    function lr(e, t) {
        for (let [n, r] of Object.entries(t))r === void 0 ? delete e.state.env[n] : e.state.env[n] = r;
    }
    function JN(e) {
        let t = [];
        if (e.state.env["COMPREPLY__length"] !== void 0) {
            let s = te(e, "COMPREPLY");
            for (let [, i] of s)t.push(i);
        } else e.state.env.COMPREPLY !== void 0 && t.push(e.state.env.COMPREPLY);
        return t;
    }
    var YN = [
        "bashdefault",
        "default",
        "dirnames",
        "filenames",
        "noquote",
        "nosort",
        "nospace",
        "plusdirs"
    ];
    function dl(e, t) {
        e.state.completionSpecs || (e.state.completionSpecs = new Map());
        let n = false, r = false, s = false, i, o, a, l = [], c = [], u = [];
        for(let f = 0; f < t.length; f++){
            let p = t[f];
            if (p === "-p") n = true;
            else if (p === "-r") r = true;
            else if (p === "-D") s = true;
            else if (p === "-W") {
                if (f++, f >= t.length) return M(`complete: -W: option requires an argument
`, 2);
                i = t[f];
            } else if (p === "-F") {
                if (f++, f >= t.length) return M(`complete: -F: option requires an argument
`, 2);
                o = t[f];
            } else if (p === "-o") {
                if (f++, f >= t.length) return M(`complete: -o: option requires an argument
`, 2);
                let d = t[f];
                if (!YN.includes(d)) return M(`complete: ${d}: invalid option name
`, 2);
                l.push(d);
            } else if (p === "-A") {
                if (f++, f >= t.length) return M(`complete: -A: option requires an argument
`, 2);
                c.push(t[f]);
            } else if (p === "-C") {
                if (f++, f >= t.length) return M(`complete: -C: option requires an argument
`, 2);
                a = t[f];
            } else if (p === "-G") {
                if (f++, f >= t.length) return M(`complete: -G: option requires an argument
`, 2);
            } else if (p === "-P") {
                if (f++, f >= t.length) return M(`complete: -P: option requires an argument
`, 2);
            } else if (p === "-S") {
                if (f++, f >= t.length) return M(`complete: -S: option requires an argument
`, 2);
            } else if (p === "-X") {
                if (f++, f >= t.length) return M(`complete: -X: option requires an argument
`, 2);
            } else if (p === "--") {
                u.push(...t.slice(f + 1));
                break;
            } else p.startsWith("-") || u.push(p);
        }
        if (r) {
            if (u.length === 0) return e.state.completionSpecs.clear(), ue("");
            for (let f of u)e.state.completionSpecs.delete(f);
            return ue("");
        }
        if (n) return u.length === 0 ? pl(e) : pl(e, u);
        if (t.length === 0 || u.length === 0 && !i && !o && !a && l.length === 0 && c.length === 0 && !s) return pl(e);
        if (o && u.length === 0 && !s) return M(`complete: -F: option requires a command name
`, 2);
        if (s) {
            let f = {
                isDefault: true
            };
            return i !== void 0 && (f.wordlist = i), o !== void 0 && (f.function = o), a !== void 0 && (f.command = a), l.length > 0 && (f.options = l), c.length > 0 && (f.actions = c), e.state.completionSpecs.set("__default__", f), ue("");
        }
        for (let f of u){
            let p = {};
            i !== void 0 && (p.wordlist = i), o !== void 0 && (p.function = o), a !== void 0 && (p.command = a), l.length > 0 && (p.options = l), c.length > 0 && (p.actions = c), e.state.completionSpecs.set(f, p);
        }
        return ue("");
    }
    function pl(e, t) {
        let n = e.state.completionSpecs;
        if (!n || n.size === 0) {
            if (t && t.length > 0) {
                let i = "";
                for (let o of t)i += `complete: ${o}: no completion specification
`;
                return W("", i, 1);
            }
            return ue("");
        }
        let r = [], s = t || Array.from(n.keys());
        for (let i of s){
            if (i === "__default__") continue;
            let o = n.get(i);
            if (!o) {
                if (t) return W(r.join(`
`) + (r.length > 0 ? `
` : ""), `complete: ${i}: no completion specification
`, 1);
                continue;
            }
            let a = "complete";
            if (o.options) for (let l of o.options)a += ` -o ${l}`;
            if (o.actions) for (let l of o.actions)a += ` -A ${l}`;
            o.wordlist !== void 0 && (o.wordlist.includes(" ") || o.wordlist.includes("'") ? a += ` -W '${o.wordlist}'` : a += ` -W ${o.wordlist}`), o.function !== void 0 && (a += ` -F ${o.function}`), o.isDefault && (a += " -D"), a += ` ${i}`, r.push(a);
        }
        return r.length === 0 ? ue("") : ue(`${r.join(`
`)}
`);
    }
    var K0 = [
        "bashdefault",
        "default",
        "dirnames",
        "filenames",
        "noquote",
        "nosort",
        "nospace",
        "plusdirs"
    ];
    function hl(e, t) {
        e.state.completionSpecs || (e.state.completionSpecs = new Map());
        let n = false, r = false, s = [], i = [], o = [];
        for(let a = 0; a < t.length; a++){
            let l = t[a];
            if (l === "-D") n = true;
            else if (l === "-E") r = true;
            else if (l === "-o") {
                if (a++, a >= t.length) return M(`compopt: -o: option requires an argument
`, 2);
                let c = t[a];
                if (!K0.includes(c)) return M(`compopt: ${c}: invalid option name
`, 2);
                s.push(c);
            } else if (l === "+o") {
                if (a++, a >= t.length) return M(`compopt: +o: option requires an argument
`, 2);
                let c = t[a];
                if (!K0.includes(c)) return M(`compopt: ${c}: invalid option name
`, 2);
                i.push(c);
            } else if (l === "--") {
                o.push(...t.slice(a + 1));
                break;
            } else !l.startsWith("-") && !l.startsWith("+") && o.push(l);
        }
        if (n) {
            let a = e.state.completionSpecs.get("__default__") ?? {
                isDefault: true
            }, l = new Set(a.options ?? []);
            for (let c of s)l.add(c);
            for (let c of i)l.delete(c);
            return a.options = l.size > 0 ? Array.from(l) : void 0, e.state.completionSpecs.set("__default__", a), ue("");
        }
        if (r) {
            let a = e.state.completionSpecs.get("__empty__") ?? {}, l = new Set(a.options ?? []);
            for (let c of s)l.add(c);
            for (let c of i)l.delete(c);
            return a.options = l.size > 0 ? Array.from(l) : void 0, e.state.completionSpecs.set("__empty__", a), ue("");
        }
        if (o.length > 0) {
            for (let a of o){
                let l = e.state.completionSpecs.get(a) ?? {}, c = new Set(l.options ?? []);
                for (let u of s)c.add(u);
                for (let u of i)c.delete(u);
                l.options = c.size > 0 ? Array.from(c) : void 0, e.state.completionSpecs.set(a, l);
            }
            return ue("");
        }
        return M(`compopt: not currently executing completion function
`, 1);
    }
    de();
    function ml(e, t) {
        if (e.state.loopDepth === 0) {
            if (e.state.parentHasLoopContext) throw new Lt();
            return le;
        }
        if (t.length > 1) throw new ae(1, "", `bash: continue: too many arguments
`);
        let n = 1;
        if (t.length > 0) {
            let r = Number.parseInt(t[0], 10);
            if (Number.isNaN(r) || r < 1) throw new ae(1, "", `bash: continue: ${t[0]}: numeric argument required
`);
            n = r;
        }
        throw new Ke(n);
    }
    Je();
    Fe();
    it();
    $t();
    Tt();
    on$1();
    function Te(e, t) {
        let n = e.state.env.HOME || "/home/user";
        return t.split(":").map((i)=>i === "~" ? n : i === "~root" ? "/root" : i.startsWith("~/") ? n + i.slice(1) : i.startsWith("~root/") ? `/root${i.slice(5)}` : i).join(":");
    }
    $t();
    Tt();
    function gl(e) {
        for(let t = 0; t < e.length; t++){
            let n = e.charCodeAt(t);
            if (n < 32 || n === 127) return true;
        }
        return false;
    }
    function yl(e) {
        let t = "$'";
        for(let n = 0; n < e.length; n++){
            let r = e[n], s = e.charCodeAt(n);
            s === 7 ? t += "\\a" : s === 8 ? t += "\\b" : s === 9 ? t += "\\t" : s === 10 ? t += "\\n" : s === 11 ? t += "\\v" : s === 12 ? t += "\\f" : s === 13 ? t += "\\r" : s === 27 ? t += "\\e" : s === 39 ? t += "\\'" : s === 92 ? t += "\\\\" : s < 32 || s === 127 ? t += `\\${s.toString(8).padStart(3, "0")}` : t += r;
        }
        return t += "'", t;
    }
    function Ri(e) {
        return gl(e) ? yl(e) : /^[a-zA-Z0-9_/.:\-@%+,=]*$/.test(e) ? e : `'${e.replace(/'/g, "'\\''")}'`;
    }
    function In(e) {
        return gl(e) ? yl(e) : `"${e.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    function bl(e) {
        return gl(e) ? yl(e) : `"${e.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    function X0(e, t) {
        let n = "";
        return e.state.integerVars?.has(t) && (n += "i"), e.state.lowercaseVars?.has(t) && (n += "l"), Se(e, t) && (n += "n"), e.state.readonlyVars?.has(t) && (n += "r"), e.state.uppercaseVars?.has(t) && (n += "u"), e.state.exportedVars?.has(t) && (n += "x"), n === "" ? "--" : `-${n}`;
    }
    function wl(e) {
        return e === "" ? "''" : /[\s'\\]/.test(e) ? `'${e.replace(/'/g, "'\\''")}'` : e;
    }
    function J0(e, t) {
        let n = "", r = "", s = false;
        for (let i of t){
            let o = X0(e, i);
            if (e.state.associativeArrays?.has(i)) {
                let u = Pt(e, i);
                if (u.length === 0) n += `declare -A ${i}=()
`;
                else {
                    let f = u.map((p)=>{
                        let d = e.state.env[`${i}_${p}`] ?? "", m = wl(d);
                        return `['${p}']=${m}`;
                    });
                    n += `declare -A ${i}=(${f.join(" ")})
`;
                }
                continue;
            }
            let l = _e(e, i);
            if (l.length > 0) {
                let u = l.map((f)=>{
                    let p = e.state.env[`${i}_${f}`] ?? "";
                    return `[${f}]=${In(p)}`;
                });
                n += `declare -a ${i}=(${u.join(" ")})
`;
                continue;
            }
            if (e.state.env[`${i}__length`] !== void 0) {
                n += `declare -a ${i}=()
`;
                continue;
            }
            let c = e.state.env[i];
            if (c !== void 0) n += `declare ${o} ${i}=${bl(c)}
`;
            else {
                let u = e.state.declaredVars?.has(i), f = e.state.localVarDepth?.has(i);
                u || f ? n += `declare ${o} ${i}
` : (r += `bash: declare: ${i}: not found
`, s = true);
            }
        }
        return W(n, r, s ? 1 : 0);
    }
    function Y0(e, t) {
        let { filterExport: n, filterReadonly: r, filterNameref: s, filterIndexedArray: i, filterAssocArray: o } = t, a = n || r || s || i || o, l = "", c = new Set();
        for (let f of Object.keys(e.state.env)){
            if (f.startsWith("BASH_")) continue;
            if (f.endsWith("__length")) {
                let d = f.slice(0, -8);
                c.add(d);
                continue;
            }
            let p = f.lastIndexOf("_");
            if (p > 0) {
                let d = f.slice(0, p), m = f.slice(p + 1);
                if (/^\d+$/.test(m) || e.state.associativeArrays?.has(d)) {
                    c.add(d);
                    continue;
                }
            }
            c.add(f);
        }
        if (e.state.localVarDepth) for (let f of e.state.localVarDepth.keys())c.add(f);
        if (e.state.associativeArrays) for (let f of e.state.associativeArrays)c.add(f);
        let u = Array.from(c).sort();
        for (let f of u){
            let p = X0(e, f), d = e.state.associativeArrays?.has(f), m = _e(e, f), h = !d && (m.length > 0 || e.state.env[`${f}__length`] !== void 0);
            if (a && (o && !d || i && !h || n && !e.state.exportedVars?.has(f) || r && !e.state.readonlyVars?.has(f) || s && !Se(e, f))) continue;
            if (d) {
                let b = Pt(e, f);
                if (b.length === 0) l += `declare -A ${f}=()
`;
                else {
                    let y = b.map((w)=>{
                        let E = e.state.env[`${f}_${w}`] ?? "", C = wl(E);
                        return `['${w}']=${C}`;
                    });
                    l += `declare -A ${f}=(${y.join(" ")})
`;
                }
                continue;
            }
            if (m.length > 0) {
                let b = m.map((y)=>{
                    let w = e.state.env[`${f}_${y}`] ?? "";
                    return `[${y}]=${In(w)}`;
                });
                l += `declare -a ${f}=(${b.join(" ")})
`;
                continue;
            }
            if (e.state.env[`${f}__length`] !== void 0) {
                l += `declare -a ${f}=()
`;
                continue;
            }
            let g = e.state.env[f];
            g !== void 0 && (l += `declare ${p} ${f}=${bl(g)}
`);
        }
        return ue(l);
    }
    function ey(e) {
        let t = "", n = Array.from(e.state.associativeArrays ?? []).sort();
        for (let r of n){
            let s = Pt(e, r);
            if (s.length === 0) t += `declare -A ${r}=()
`;
            else {
                let i = s.map((o)=>{
                    let a = e.state.env[`${r}_${o}`] ?? "", l = wl(a);
                    return `['${o}']=${l}`;
                });
                t += `declare -A ${r}=(${i.join(" ")})
`;
            }
        }
        return ue(t);
    }
    function ty(e) {
        let t = "", n = new Set();
        for (let s of Object.keys(e.state.env)){
            if (s.startsWith("BASH_")) continue;
            if (s.endsWith("__length")) {
                let o = s.slice(0, -8);
                e.state.associativeArrays?.has(o) || n.add(o);
                continue;
            }
            let i = s.lastIndexOf("_");
            if (i > 0) {
                let o = s.slice(0, i), a = s.slice(i + 1);
                /^\d+$/.test(a) && (e.state.associativeArrays?.has(o) || n.add(o));
            }
        }
        let r = Array.from(n).sort();
        for (let s of r){
            let i = _e(e, s);
            if (i.length === 0) t += `declare -a ${s}=()
`;
            else {
                let o = i.map((a)=>{
                    let l = e.state.env[`${s}_${a}`] ?? "";
                    return `[${a}]=${In(l)}`;
                });
                t += `declare -a ${s}=(${o.join(" ")})
`;
            }
        }
        return ue(t);
    }
    function ny(e) {
        let t = "", n = new Set();
        for (let s of Object.keys(e.state.env)){
            if (s.startsWith("BASH_")) continue;
            if (s.endsWith("__length")) {
                let o = s.slice(0, -8);
                n.add(o);
                continue;
            }
            let i = s.lastIndexOf("_");
            if (i > 0) {
                let o = s.slice(0, i), a = s.slice(i + 1);
                if (/^\d+$/.test(a) || e.state.associativeArrays?.has(o)) {
                    n.add(o);
                    continue;
                }
            }
            n.add(s);
        }
        let r = Array.from(n).sort();
        for (let s of r){
            if (e.state.associativeArrays?.has(s) || _e(e, s).length > 0 || e.state.env[`${s}__length`] !== void 0) continue;
            let a = e.state.env[s];
            a !== void 0 && (t += `${s}=${Ri(a)}
`);
        }
        return ue(t);
    }
    function xl(e, t) {
        e.state.integerVars ??= new Set(), e.state.integerVars.add(t);
    }
    function Hr(e, t) {
        return e.state.integerVars?.has(t) ?? false;
    }
    function El(e, t) {
        e.state.lowercaseVars ??= new Set(), e.state.lowercaseVars.add(t), e.state.uppercaseVars?.delete(t);
    }
    function ek(e, t) {
        return e.state.lowercaseVars?.has(t) ?? false;
    }
    function Sl(e, t) {
        e.state.uppercaseVars ??= new Set(), e.state.uppercaseVars.add(t), e.state.lowercaseVars?.delete(t);
    }
    function tk(e, t) {
        return e.state.uppercaseVars?.has(t) ?? false;
    }
    function cr(e, t, n) {
        return ek(e, t) ? n.toLowerCase() : tk(e, t) ? n.toUpperCase() : n;
    }
    async function ry(e, t) {
        try {
            let n = new se(), r = he(n, t), s = await Q(e, r.expression);
            return String(s);
        } catch  {
            return "0";
        }
    }
    function nk(e) {
        let t = e.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
        if (!t) return null;
        let n = t[0], r = n.length;
        if (e[r] !== "[") return null;
        let s = 0, i = r + 1;
        for(; r < e.length; r++)if (e[r] === "[") s++;
        else if (e[r] === "]" && (s--, s === 0)) break;
        if (s !== 0) return null;
        let o = e.slice(i, r);
        if (r++, e[r] !== "=") return null;
        r++;
        let a = e.slice(r);
        return {
            name: n,
            indexExpr: o,
            value: a
        };
    }
    async function Al(e, t) {
        let n = false, r = false, s = false, i = false, o = false, a = false, l = false, c = false, u = false, f = false, p = false, d = false, m = false, h = false, g = false, b = [];
        for(let L = 0; L < t.length; L++){
            let D = t[L];
            if (D === "-a") n = true;
            else if (D === "-A") r = true;
            else if (D === "-r") s = true;
            else if (D === "-x") i = true;
            else if (D === "-p") o = true;
            else if (D === "-n") a = true;
            else if (D === "+n") l = true;
            else if (D === "+a") c = true;
            else if (D === "+x") u = true;
            else if (D === "--") {
                b.push(...t.slice(L + 1));
                break;
            } else if (D.startsWith("+")) {
                for (let $ of D.slice(1))if ($ === "n") l = true;
                else if ($ === "a") c = true;
                else if ($ === "x") u = true;
                else if ($ !== "r") {
                    if ($ !== "i") {
                        if (!($ === "f" || $ === "F")) return W("", `bash: typeset: +${$}: invalid option
`, 2);
                    }
                }
            } else if (D === "-i") f = true;
            else if (D === "-l") p = true;
            else if (D === "-u") d = true;
            else if (D === "-f") m = true;
            else if (D === "-F") h = true;
            else if (D === "-g") g = true;
            else if (D.startsWith("-")) for (let $ of D.slice(1))if ($ === "a") n = true;
            else if ($ === "A") r = true;
            else if ($ === "r") s = true;
            else if ($ === "x") i = true;
            else if ($ === "p") o = true;
            else if ($ === "n") a = true;
            else if ($ === "i") f = true;
            else if ($ === "l") p = true;
            else if ($ === "u") d = true;
            else if ($ === "f") m = true;
            else if ($ === "F") h = true;
            else if ($ === "g") g = true;
            else return W("", `bash: typeset: -${$}: invalid option
`, 2);
            else b.push(D);
        }
        let w = e.state.localScopes.length > 0 && !g, E = (L)=>{
            if (!w) return;
            let D = e.state.localScopes[e.state.localScopes.length - 1];
            D.has(L) || D.set(L, e.state.env[L]);
        }, C = (L)=>{
            if (!w) return;
            let D = e.state.localScopes[e.state.localScopes.length - 1];
            D.has(L) || D.set(L, e.state.env[L]);
            let $ = `${L}_`;
            for (let P of Object.keys(e.state.env))P.startsWith($) && !P.includes("__") && (D.has(P) || D.set(P, e.state.env[P]));
            let N = `${L}__length`;
            e.state.env[N] !== void 0 && !D.has(N) && D.set(N, e.state.env[N]);
        }, A = (L)=>{
            w && cn(e, L);
        };
        if (h) {
            if (b.length === 0) {
                let $ = Array.from(e.state.functions.keys()).sort(), N = "";
                for (let P of $)N += `declare -f ${P}
`;
                return ue(N);
            }
            let L = true, D = "";
            for (let $ of b)e.state.functions.has($) ? D += `${$}
` : L = false;
            return W(D, "", L ? 0 : 1);
        }
        if (m) {
            if (b.length === 0) {
                let D = "", $ = Array.from(e.state.functions.keys()).sort();
                for (let N of $)D += `${N} ()
{
    # function body
}
`;
                return ue(D);
            }
            let L = true;
            for (let D of b)e.state.functions.has(D) || (L = false);
            return W("", "", L ? 0 : 1);
        }
        if (o && b.length > 0) return J0(e, b);
        if (o && b.length === 0) return Y0(e, {
            filterExport: i,
            filterReadonly: s,
            filterNameref: a,
            filterIndexedArray: n,
            filterAssocArray: r
        });
        if (b.length === 0 && r && !o) return ey(e);
        if (b.length === 0 && n && !o) return ty(e);
        if (b.length === 0 && !o) return ny(e);
        let I = "", O = 0;
        for (let L of b){
            let D = L.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
            if (D && !c) {
                let k = D[1], R = D[2];
                if (r && _e(e, k).length > 0) {
                    I += `bash: declare: ${k}: cannot convert indexed to associative array
`, O = 1;
                    continue;
                }
                if ((n || !r && !n) && e.state.associativeArrays?.has(k)) {
                    I += `bash: declare: ${k}: cannot convert associative to indexed array
`, O = 1;
                    continue;
                }
                if (C(k), r && (e.state.associativeArrays ??= new Set(), e.state.associativeArrays.add(k)), Ut(e, k), delete e.state.env[k], delete e.state.env[`${k}__length`], r && R.includes("[")) {
                    let T = Ni(R);
                    for (let [Y, ie] of T){
                        let K = Te(e, ie);
                        e.state.env[`${k}_${Y}`] = K;
                    }
                } else if (r) {
                    let T = Vt(R);
                    for(let Y = 0; Y < T.length; Y += 2){
                        let ie = T[Y], K = Y + 1 < T.length ? Te(e, T[Y + 1]) : "";
                        e.state.env[`${k}_${ie}`] = K;
                    }
                } else {
                    let T = Vt(R);
                    if (T.some((ie)=>/^\[[^\]]+\]=/.test(ie))) {
                        let ie = 0;
                        for (let K of T){
                            let B = K.match(/^\[([^\]]+)\]=(.*)$/);
                            if (B) {
                                let q = B[1], be = B[2], ee = Te(e, be), ge;
                                if (/^-?\d+$/.test(q)) ge = Number.parseInt(q, 10);
                                else try {
                                    let U = new se(), ye = he(U, q);
                                    ge = await Q(e, ye.expression);
                                } catch  {
                                    ge = 0;
                                }
                                e.state.env[`${k}_${ge}`] = ee, ie = ge + 1;
                            } else {
                                let q = Te(e, K);
                                e.state.env[`${k}_${ie}`] = q, ie++;
                            }
                        }
                    } else {
                        for(let ie = 0; ie < T.length; ie++)e.state.env[`${k}_${ie}`] = T[ie];
                        e.state.env[`${k}__length`] = String(T.length);
                    }
                }
                A(k), s && gt(e, k), i && Ot(e, k);
                continue;
            }
            if (l) {
                let k = L.includes("=") ? L.slice(0, L.indexOf("=")) : L;
                if (og(e, k), !L.includes("=")) continue;
            }
            if (u) {
                let k = L.includes("=") ? L.slice(0, L.indexOf("=")) : L;
                if (oi(e, k), !L.includes("=")) continue;
            }
            let $ = nk(L);
            if ($) {
                let { name: k, indexExpr: R, value: T } = $;
                je(e, k);
                C(k);
                let ie;
                try {
                    let B = new se(), q = he(B, R);
                    ie = await Q(e, q.expression);
                } catch  {
                    let B = parseInt(R, 10);
                    ie = Number.isNaN(B) ? 0 : B;
                }
                e.state.env[`${k}_${ie}`] = T;
                let K = parseInt(e.state.env[`${k}__length`] ?? "0", 10);
                ie >= K && (e.state.env[`${k}__length`] = String(ie + 1)), A(k), s && gt(e, k), i && Ot(e, k);
                continue;
            }
            let N = L.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
            if (N && !c) {
                let k = N[1], R = N[2];
                je(e, k);
                C(k);
                let Y = Vt(R);
                if (e.state.associativeArrays?.has(k)) {
                    let ie = Ni(R);
                    for (let [K, B] of ie){
                        let q = Te(e, B);
                        e.state.env[`${k}_${K}`] = q;
                    }
                } else {
                    let ie = _e(e, k), K = 0;
                    if (ie.length === 0 && e.state.env[k] !== void 0) {
                        let q = e.state.env[k];
                        e.state.env[`${k}_0`] = q, delete e.state.env[k], K = 1;
                    } else ie.length > 0 && (K = Math.max(...ie) + 1);
                    for(let q = 0; q < Y.length; q++)e.state.env[`${k}_${K + q}`] = Te(e, Y[q]);
                    let B = K + Y.length;
                    e.state.env[`${k}__length`] = String(B);
                }
                A(k), s && gt(e, k), i && Ot(e, k);
                continue;
            }
            let P = L.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
            if (P) {
                let k = P[1], R = Te(e, P[2]);
                je(e, k);
                E(k), f && xl(e, k), p && El(e, k), d && Sl(e, k);
                let ie = _e(e, k).length > 0 || e.state.associativeArrays?.has(k);
                if (Hr(e, k)) {
                    let K = e.state.env[k] ?? "0", B = parseInt(K, 10) || 0, q = parseInt(await ry(e, R), 10) || 0;
                    R = String(B + q), e.state.env[k] = R;
                } else if (ie) {
                    R = cr(e, k, R);
                    let K = `${k}_0`, B = e.state.env[K] ?? "";
                    e.state.env[K] = B + R;
                } else {
                    R = cr(e, k, R);
                    let K = e.state.env[k] ?? "";
                    e.state.env[k] = K + R;
                }
                A(k), s && gt(e, k), i && Ot(e, k), e.state.options.allexport && !u && (e.state.exportedVars = e.state.exportedVars || new Set(), e.state.exportedVars.add(k));
                continue;
            }
            if (L.includes("=")) {
                let k = L.indexOf("="), R = L.slice(0, k), T = L.slice(k + 1);
                if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(R)) {
                    I += `bash: typeset: \`${R}': not a valid identifier
`, O = 1;
                    continue;
                }
                je(e, R);
                if (E(R), a) {
                    if (T !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(T)) {
                        I += `bash: declare: \`${T}': invalid variable name for name reference
`, O = 1;
                        continue;
                    }
                    e.state.env[R] = T, Zt(e, R), T !== "" && si(e, T) && Ua(e, R), A(R), s && gt(e, R), i && Ot(e, R);
                    continue;
                }
                if (f && xl(e, R), p && El(e, R), d && Sl(e, R), Hr(e, R) && (T = await ry(e, T)), T = cr(e, R, T), Se(e, R)) {
                    let ie = st(e, R);
                    ie && ie !== R ? e.state.env[ie] = T : e.state.env[R] = T;
                } else e.state.env[R] = T;
                A(R), s && gt(e, R), i && Ot(e, R), e.state.options.allexport && !u && (e.state.exportedVars = e.state.exportedVars || new Set(), e.state.exportedVars.add(R));
            } else {
                let k = L;
                if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(k)) {
                    I += `bash: typeset: \`${k}': not a valid identifier
`, O = 1;
                    continue;
                }
                if (n || r ? C(k) : E(k), a) {
                    Zt(e, k);
                    let T = e.state.env[k];
                    T !== void 0 && T !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(T) ? ag(e, k) : T && si(e, T) && Ua(e, k), A(k), s && gt(e, k), i && Ot(e, k);
                    continue;
                }
                if (f && xl(e, k), p && El(e, k), d && Sl(e, k), r) {
                    if (_e(e, k).length > 0) {
                        I += `bash: declare: ${k}: cannot convert indexed to associative array
`, O = 1;
                        continue;
                    }
                    e.state.associativeArrays ??= new Set(), e.state.associativeArrays.add(k);
                }
                let R = Object.keys(e.state.env).some((T)=>T.startsWith(`${k}_`) && !T.startsWith(`${k}__length`));
                !(k in e.state.env) && !R && (n || r ? e.state.env[`${k}__length`] = "0" : (e.state.declaredVars ??= new Set(), e.state.declaredVars.add(k))), A(k), s && gt(e, k), i && Ot(e, k);
            }
        }
        return W("", I, O);
    }
    async function Cl(e, t) {
        let i = [];
        for(let o = 0; o < t.length; o++){
            let a = t[o];
            if (a === "-a") ;
            else if (a === "-A") ;
            else if (a === "-p") ;
            else if (a === "--") {
                i.push(...t.slice(o + 1));
                break;
            } else a.startsWith("-") || i.push(a);
        }
        if (i.length === 0) {
            let o = "", a = Array.from(e.state.readonlyVars || []).sort();
            for (let l of a){
                let c = e.state.env[l];
                if (c !== void 0) {
                    let u = c.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
                    o += `declare -r ${l}="${u}"
`;
                }
            }
            return ue(o);
        }
        for (let o of i){
            let a = o.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
            if (a) {
                let f = a[1], p = a[2];
                je(e, f);
                let m = Vt(p);
                if (e.state.associativeArrays?.has(f)) {
                    let h = Ni(p);
                    for (let [g, b] of h){
                        let y = Te(e, b);
                        e.state.env[`${f}_${g}`] = y;
                    }
                } else {
                    let h = _e(e, f), g = 0;
                    if (h.length === 0 && e.state.env[f] !== void 0) {
                        let y = e.state.env[f];
                        e.state.env[`${f}_0`] = y, delete e.state.env[f], g = 1;
                    } else h.length > 0 && (g = Math.max(...h) + 1);
                    for(let y = 0; y < m.length; y++)e.state.env[`${f}_${g + y}`] = Te(e, m[y]);
                    let b = g + m.length;
                    e.state.env[`${f}__length`] = String(b);
                }
                gt(e, f);
                continue;
            }
            let l = o.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
            if (l) {
                let f = l[1], p = Te(e, l[2]);
                je(e, f);
                let m = e.state.env[f] ?? "";
                e.state.env[f] = m + p, gt(e, f);
                continue;
            }
            let c = U0(o);
            if (c.value === void 0 && !c.isArray) {
                gt(e, c.name);
                continue;
            }
            let u = await z0(e, c, {
                makeReadonly: true
            });
            if (u) return u;
        }
        return le;
    }
    function Nl(e) {
        return e.state.directoryStack ??= [], e.state.directoryStack;
    }
    function Vr(e, t) {
        return t && e === t ? "~" : t && e.startsWith(`${t}/`) ? `~${e.slice(t.length)}` : e;
    }
    function rk(e) {
        let t = e.split("/").filter((r)=>r && r !== "."), n = [];
        for (let r of t)r === ".." ? n.pop() : n.push(r);
        return `/${n.join("/")}`;
    }
    async function kl(e, t) {
        let n = Nl(e), r;
        for(let a = 0; a < t.length; a++){
            let l = t[a];
            if (l === "--") {
                if (a + 1 < t.length) {
                    if (r !== void 0) return M(`bash: pushd: too many arguments
`, 2);
                    r = t[a + 1], a++;
                }
            } else {
                if (l.startsWith("-") && l !== "-") return M(`bash: pushd: ${l}: invalid option
`, 2);
                if (r !== void 0) return M(`bash: pushd: too many arguments
`, 2);
                r = l;
            }
        }
        if (r === void 0) {
            if (n.length < 2) return M(`bash: pushd: no other directory
`, 1);
            let a = n[0];
            n[0] = n[1], n[1] = a, r = n[0];
        }
        let s;
        if (r.startsWith("/")) s = r;
        else if (r === "..") {
            let a = e.state.cwd.split("/").filter((l)=>l);
            a.pop(), s = `/${a.join("/")}`;
        } else r === "." ? s = e.state.cwd : r.startsWith("~") ? s = (e.state.env.HOME || "/") + r.slice(1) : s = `${e.state.cwd}/${r}`;
        s = rk(s);
        try {
            if (!(await e.fs.stat(s)).isDirectory) return M(`bash: pushd: ${r}: Not a directory
`, 1);
        } catch  {
            return M(`bash: pushd: ${r}: No such file or directory
`, 1);
        }
        n.unshift(e.state.cwd), e.state.previousDir = e.state.cwd, e.state.cwd = s, e.state.env.PWD = s, e.state.env.OLDPWD = e.state.previousDir;
        let i = e.state.env.HOME || "", o = `${[
            s,
            ...n
        ].map((a)=>Vr(a, i)).join(" ")}
`;
        return ue(o);
    }
    function vl(e, t) {
        let n = Nl(e);
        for (let o of t)if (o !== "--") return o.startsWith("-") && o !== "-" ? M(`bash: popd: ${o}: invalid option
`, 2) : M(`bash: popd: too many arguments
`, 2);
        if (n.length === 0) return M(`bash: popd: directory stack empty
`, 1);
        let r = n.shift();
        if (!r) return M(`bash: popd: directory stack empty
`, 1);
        e.state.previousDir = e.state.cwd, e.state.cwd = r, e.state.env.PWD = r, e.state.env.OLDPWD = e.state.previousDir;
        let s = e.state.env.HOME || "", i = `${[
            r,
            ...n
        ].map((o)=>Vr(o, s)).join(" ")}
`;
        return ue(i);
    }
    function $l(e, t) {
        let n = Nl(e), r = false, s = false, i = false, o = false;
        for (let u of t)if (u !== "--") if (u.startsWith("-")) for (let f of u.slice(1))if (f === "c") r = true;
        else if (f === "l") s = true;
        else if (f === "p") i = true;
        else if (f === "v") i = true, o = true;
        else return M(`bash: dirs: -${f}: invalid option
`, 2);
        else return M(`bash: dirs: too many arguments
`, 1);
        if (r) return e.state.directoryStack = [], le;
        let a = [
            e.state.cwd,
            ...n
        ], l = e.state.env.HOME || "", c;
        return o ? (c = a.map((u, f)=>{
            let p = s ? u : Vr(u, l);
            return ` ${f}  ${p}`;
        }).join(`
`), c += `
`) : i ? c = a.map((u)=>s ? u : Vr(u, l)).join(`
`) + `
` : c = a.map((u)=>s ? u : Vr(u, l)).join(" ") + `
`, ue(c);
    }
    Fe();
    de();
    async function Pi(e, t, n) {
        let r = t;
        if (r.length > 0) {
            let a = r[0];
            if (a === "--") r = r.slice(1);
            else if (a.startsWith("-") && a !== "-" && a.length > 1) return M(`bash: eval: ${a}: invalid option
eval: usage: eval [arg ...]
`, 2);
        }
        if (r.length === 0) return le;
        let s = r.join(" ");
        if (s.trim() === "") return le;
        let i = e.state.groupStdin, o = n ?? e.state.groupStdin;
        o !== void 0 && (e.state.groupStdin = o);
        try {
            let a = Bt(s);
            return await e.executeScript(a);
        } catch (a) {
            if (a instanceof Qe || a instanceof Ke || a instanceof Ve || a instanceof ae) throw a;
            if (a.name === "ParseException") return M(`bash: eval: ${a.message}
`);
            throw a;
        } finally{
            e.state.groupStdin = i;
        }
    }
    de();
    function Il(e, t) {
        let n, r = "";
        if (t.length === 0) n = e.state.lastExitCode;
        else {
            let s = t[0], i = Number.parseInt(s, 10);
            s === "" || Number.isNaN(i) || !/^-?\d+$/.test(s) ? (r = `bash: exit: ${s}: numeric argument required
`, n = 2) : n = (i % 256 + 256) % 256;
        }
        throw new ae(n, "", r);
    }
    on$1();
    function Rl(e, t) {
        let n = false, r = [];
        for (let o of t)o === "-n" ? n = true : o === "-p" || o === "--" || r.push(o);
        if (r.length === 0 && !n) {
            let o = "", a = e.state.exportedVars ?? new Set(), l = Array.from(a).sort();
            for (let c of l){
                let u = e.state.env[c];
                if (u !== void 0) {
                    let f = u.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
                    o += `declare -x ${c}="${f}"
`;
                }
            }
            return ue(o);
        }
        if (n) {
            for (let o of r){
                let a, l;
                if (o.includes("=")) {
                    let c = o.indexOf("=");
                    a = o.slice(0, c), l = Te(e, o.slice(c + 1)), e.state.env[a] = l;
                } else a = o;
                oi(e, a);
            }
            return le;
        }
        let s = "", i = 0;
        for (let o of r){
            let a, l, c = false, u = o.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
            if (u) a = u[1], l = Te(e, u[2]), c = true;
            else if (o.includes("=")) {
                let f = o.indexOf("=");
                a = o.slice(0, f), l = Te(e, o.slice(f + 1));
            } else a = o;
            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(a)) {
                s += `bash: export: \`${o}': not a valid identifier
`, i = 1;
                continue;
            }
            if (l !== void 0) if (c) {
                let f = e.state.env[a] ?? "";
                e.state.env[a] = f + l;
            } else e.state.env[a] = l;
            else a in e.state.env || (e.state.env[a] = "");
            Ot(e, a);
        }
        return W("", s, i);
    }
    function Ti(e, t) {
        if (t.length < 2) return M(`bash: getopts: usage: getopts optstring name [arg ...]
`);
        let n = t[0], r = t[1], s = !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r), i = n.startsWith(":"), o = i ? n.slice(1) : n, a;
        if (t.length > 2) a = t.slice(2);
        else {
            let h = Number.parseInt(e.state.env["#"] || "0", 10);
            a = [];
            for(let g = 1; g <= h; g++)a.push(e.state.env[String(g)] || "");
        }
        let l = Number.parseInt(e.state.env.OPTIND || "1", 10);
        l < 1 && (l = 1);
        let c = Number.parseInt(e.state.env.__GETOPTS_CHARINDEX || "0", 10);
        if (e.state.env.OPTARG = "", l > a.length) return s || (e.state.env[r] = "?"), e.state.env.OPTIND = String(a.length + 1), e.state.env.__GETOPTS_CHARINDEX = "0", {
            exitCode: s ? 2 : 1,
            stdout: "",
            stderr: ""
        };
        let u = a[l - 1];
        if (!u || u === "-" || !u.startsWith("-")) return s || (e.state.env[r] = "?"), {
            exitCode: s ? 2 : 1,
            stdout: "",
            stderr: ""
        };
        if (u === "--") return e.state.env.OPTIND = String(l + 1), e.state.env.__GETOPTS_CHARINDEX = "0", s || (e.state.env[r] = "?"), {
            exitCode: s ? 2 : 1,
            stdout: "",
            stderr: ""
        };
        let f = c === 0 ? 1 : c, p = u[f];
        if (!p) return e.state.env.OPTIND = String(l + 1), e.state.env.__GETOPTS_CHARINDEX = "0", Ti(e, t);
        let d = o.indexOf(p);
        if (d === -1) {
            let h = "";
            return i ? e.state.env.OPTARG = p : h = `bash: illegal option -- ${p}
`, s || (e.state.env[r] = "?"), f + 1 < u.length ? (e.state.env.__GETOPTS_CHARINDEX = String(f + 1), e.state.env.OPTIND = String(l)) : (e.state.env.OPTIND = String(l + 1), e.state.env.__GETOPTS_CHARINDEX = "0"), {
                exitCode: s ? 2 : 0,
                stdout: "",
                stderr: h
            };
        }
        if (d + 1 < o.length && o[d + 1] === ":") if (f + 1 < u.length) e.state.env.OPTARG = u.slice(f + 1), e.state.env.OPTIND = String(l + 1), e.state.env.__GETOPTS_CHARINDEX = "0";
        else {
            if (l >= a.length) {
                let h = "";
                return i ? (e.state.env.OPTARG = p, s || (e.state.env[r] = ":")) : (h = `bash: option requires an argument -- ${p}
`, s || (e.state.env[r] = "?")), e.state.env.OPTIND = String(l + 1), e.state.env.__GETOPTS_CHARINDEX = "0", {
                    exitCode: s ? 2 : 0,
                    stdout: "",
                    stderr: h
                };
            }
            e.state.env.OPTARG = a[l], e.state.env.OPTIND = String(l + 2), e.state.env.__GETOPTS_CHARINDEX = "0";
        }
        else f + 1 < u.length ? (e.state.env.__GETOPTS_CHARINDEX = String(f + 1), e.state.env.OPTIND = String(l)) : (e.state.env.OPTIND = String(l + 1), e.state.env.__GETOPTS_CHARINDEX = "0");
        return s || (e.state.env[r] = p), {
            exitCode: s ? 2 : 0,
            stdout: "",
            stderr: ""
        };
    }
    async function Pl(e, t) {
        e.state.hashTable || (e.state.hashTable = new Map());
        let n = false, r = false, s = false, i = false, o = false, a = "", l = [], c = 0;
        for(; c < t.length;){
            let m = t[c];
            if (m === "--") {
                c++, l.push(...t.slice(c));
                break;
            }
            if (m === "-r") n = true, c++;
            else if (m === "-d") r = true, c++;
            else if (m === "-l") s = true, c++;
            else if (m === "-t") o = true, c++;
            else if (m === "-p") {
                if (i = true, c++, c >= t.length) return M(`bash: hash: -p: option requires an argument
`, 1);
                a = t[c], c++;
            } else if (m.startsWith("-") && m.length > 1) {
                for (let h of m.slice(1))if (h === "r") n = true;
                else if (h === "d") r = true;
                else if (h === "l") s = true;
                else if (h === "t") o = true;
                else return h === "p" ? M(`bash: hash: -p: option requires an argument
`, 1) : M(`bash: hash: -${h}: invalid option
`, 1);
                c++;
            } else l.push(m), c++;
        }
        if (n) return e.state.hashTable.clear(), le;
        if (r) {
            if (l.length === 0) return M(`bash: hash: -d: option requires an argument
`, 1);
            let m = false, h = "";
            for (let g of l)e.state.hashTable.has(g) ? e.state.hashTable.delete(g) : (h += `bash: hash: ${g}: not found
`, m = true);
            return m ? M(h, 1) : le;
        }
        if (o) {
            if (l.length === 0) return M(`bash: hash: -t: option requires an argument
`, 1);
            let m = "", h = false, g = "";
            for (let b of l){
                let y = e.state.hashTable.get(b);
                y ? l.length > 1 ? m += `${b}	${y}
` : m += `${y}
` : (g += `bash: hash: ${b}: not found
`, h = true);
            }
            return h ? {
                exitCode: 1,
                stdout: m,
                stderr: g
            } : ue(m);
        }
        if (i) {
            if (l.length === 0) return M(`bash: hash: usage: hash [-lr] [-p pathname] [-dt] [name ...]
`, 1);
            let m = l[0];
            return e.state.hashTable.set(m, a), le;
        }
        if (l.length === 0) {
            if (e.state.hashTable.size === 0) return ue(`hash: hash table empty
`);
            let m = "";
            if (s) for (let [h, g] of e.state.hashTable)m += `builtin hash -p ${g} ${h}
`;
            else {
                m = `hits	command
`;
                for (let [, h] of e.state.hashTable)m += `   1	${h}
`;
            }
            return ue(m);
        }
        let u = false, f = "", d = (e.state.env.PATH || "/usr/bin:/bin").split(":");
        for (let m of l){
            if (m.includes("/")) {
                f += `bash: hash: ${m}: cannot use / in name
`, u = true;
                continue;
            }
            let h = false;
            for (let g of d){
                if (!g) continue;
                let b = `${g}/${m}`;
                if (await e.fs.exists(b)) {
                    e.state.hashTable.set(m, b), h = true;
                    break;
                }
            }
            h || (f += `bash: hash: ${m}: not found
`, u = true);
        }
        return u ? M(f, 1) : le;
    }
    var sy = {
        ":": [
            ": [arguments]",
            `Null command.
    No effect; the command does nothing.
    Exit Status:
    Always succeeds.`
        ],
        ".": [
            ". filename [arguments]",
            `Execute commands from a file in the current shell.
    Read and execute commands from FILENAME in the current shell.
    The entries in $PATH are used to find the directory containing FILENAME.
    Exit Status:
    Returns the status of the last command executed in FILENAME.`
        ],
        "[": [
            "[ arg... ]",
            `Evaluate conditional expression.
    This is a synonym for the "test" builtin, but the last argument must
    be a literal \`]', to match the opening \`['.`
        ],
        alias: [
            "alias [-p] [name[=value] ... ]",
            `Define or display aliases.
    Without arguments, \`alias' prints the list of aliases in the reusable
    form \`alias NAME=VALUE' on standard output.
    Exit Status:
    alias returns true unless a NAME is supplied for which no alias has been
    defined.`
        ],
        bg: [
            "bg [job_spec ...]",
            `Move jobs to the background.
    Place the jobs identified by each JOB_SPEC in the background, as if they
    had been started with \`&'.`
        ],
        break: [
            "break [n]",
            `Exit for, while, or until loops.
    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing
    loops.
    Exit Status:
    The exit status is 0 unless N is not greater than or equal to 1.`
        ],
        builtin: [
            "builtin [shell-builtin [arg ...]]",
            `Execute shell builtins.
    Execute SHELL-BUILTIN with arguments ARGs without performing command
    lookup.  This is useful when you wish to reimplement a shell builtin
    as a shell function, but need to execute the builtin within the function.
    Exit Status:
    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is
    not a shell builtin.`
        ],
        caller: [
            "caller [expr]",
            `Return the context of the current subroutine call.
    Without EXPR, returns "$line $filename".  With EXPR, returns
    "$line $subroutine $filename"; this extra information can be used to
    provide a stack trace.
    Exit Status:
    Returns 0 unless the shell is not executing a subroutine call or
    EXPR is invalid.`
        ],
        cd: [
            "cd [-L|-P] [dir]",
            `Change the shell working directory.
    Change the current directory to DIR.  The default DIR is the value of the
    HOME shell variable.

    The variable CDPATH defines the search path for the directory containing
    DIR.  Alternative directory names in CDPATH are separated by a colon (:).
    A null directory name is the same as the current directory.  If DIR begins
    with a slash (/), then CDPATH is not used.

    If the directory is not found, and the shell option \`cdable_vars' is set,
    the word is assumed to be a variable name.  If that variable has a value,
    its value is used for DIR.

    Options:
      -L	force symbolic links to be followed
      -P	use the physical directory structure without following symbolic
    	links

    The default is to follow symbolic links, as if \`-L' were specified.

    Exit Status:
    Returns 0 if the directory is changed; non-zero otherwise.`
        ],
        command: [
            "command [-pVv] command [arg ...]",
            `Execute a simple command or display information about commands.
    Runs COMMAND with ARGS suppressing shell function lookup, or display
    information about the specified COMMANDs.

    Options:
      -p	use a default value for PATH that is guaranteed to find all of
    	the standard utilities
      -v	print a description of COMMAND similar to the \`type' builtin
      -V	print a more verbose description of each COMMAND

    Exit Status:
    Returns exit status of COMMAND, or failure if COMMAND is not found.`
        ],
        compgen: [
            "compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]",
            `Display possible completions depending on the options.
    Intended to be used from within a shell function generating possible
    completions.  If the optional WORD argument is supplied, matches against
    WORD are generated.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`
        ],
        complete: [
            "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]",
            `Specify how arguments are to be completed.
    For each NAME, specify how arguments are to be completed.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`
        ],
        continue: [
            "continue [n]",
            `Resume for, while, or until loops.
    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.
    If N is specified, resumes the Nth enclosing loop.
    Exit Status:
    The exit status is 0 unless N is not greater than or equal to 1.`
        ],
        declare: [
            "declare [-aAfFgilnrtux] [-p] [name[=value] ...]",
            `Set variable values and attributes.
    Declare variables and give them attributes.  If no NAMEs are given,
    display the attributes and values of all variables.

    Options:
      -a	to make NAMEs indexed arrays (if supported)
      -A	to make NAMEs associative arrays (if supported)
      -i	to make NAMEs have the \`integer' attribute
      -l	to convert the value of each NAME to lower case on assignment
      -n	make NAME a reference to the variable named by its value
      -r	to make NAMEs readonly
      -t	to make NAMEs have the \`trace' attribute
      -u	to convert the value of each NAME to upper case on assignment
      -x	to make NAMEs export

    Exit Status:
    Returns success unless an invalid option is supplied or a variable
    assignment error occurs.`
        ],
        dirs: [
            "dirs [-clpv] [+N] [-N]",
            `Display directory stack.
    Display the list of currently remembered directories.  Directories
    find their way onto the list with the \`pushd' command; you can get
    back up through the list with the \`popd' command.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`
        ],
        disown: [
            "disown [-h] [-ar] [jobspec ...]",
            `Remove jobs from current shell.
    Without any JOBSPECs, remove the current job.`
        ],
        echo: [
            "echo [-neE] [arg ...]",
            `Write arguments to the standard output.
    Display the ARGs, separated by a single space character and followed by a
    newline, on the standard output.

    Options:
      -n	do not append a newline
      -e	enable interpretation of the following backslash escapes
      -E	explicitly suppress interpretation of backslash escapes

    Exit Status:
    Returns success unless a write error occurs.`
        ],
        enable: [
            "enable [-a] [-dnps] [-f filename] [name ...]",
            `Enable and disable shell builtins.
    Enables and disables builtin shell commands.
    Exit Status:
    Returns success unless NAME is not a shell builtin or an error occurs.`
        ],
        eval: [
            "eval [arg ...]",
            `Execute arguments as a shell command.
    Combine ARGs into a single string, use the result as input to the shell,
    and execute the resulting commands.
    Exit Status:
    Returns exit status of command or success if command is null.`
        ],
        exec: [
            "exec [-cl] [-a name] [command [arguments ...]] [redirection ...]",
            `Replace the shell with the given command.
    Execute COMMAND, replacing this shell with the specified program.
    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,
    any redirections take effect in the current shell.
    Exit Status:
    Returns success unless COMMAND is not found or a redirection error occurs.`
        ],
        exit: [
            "exit [n]",
            `Exit the shell.
    Exits the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.`
        ],
        export: [
            "export [-fn] [name[=value] ...] or export -p",
            `Set export attribute for shell variables.
    Marks each NAME for automatic export to the environment of subsequently
    executed commands.  If VALUE is supplied, assign VALUE before exporting.

    Options:
      -f	refer to shell functions
      -n	remove the export property from each NAME
      -p	display a list of all exported variables and functions

    Exit Status:
    Returns success unless an invalid option is given or NAME is invalid.`
        ],
        false: [
            "false",
            `Return an unsuccessful result.
    Exit Status:
    Always fails.`
        ],
        fc: [
            "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]",
            `Display or execute commands from the history list.
    Exit Status:
    Returns success or status of executed command.`
        ],
        fg: [
            "fg [job_spec]",
            `Move job to the foreground.
    Place the job identified by JOB_SPEC in the foreground, making it the
    current job.`
        ],
        getopts: [
            "getopts optstring name [arg]",
            `Parse option arguments.
    Getopts is used by shell procedures to parse positional parameters
    as options.

    OPTSTRING contains the option letters to be recognized; if a letter
    is followed by a colon, the option is expected to have an argument,
    which should be separated from it by white space.
    Exit Status:
    Returns success if an option is found; fails if the end of options is
    encountered or an error occurs.`
        ],
        hash: [
            "hash [-lr] [-p pathname] [-dt] [name ...]",
            `Remember or display program locations.
    Determine and remember the full pathname of each command NAME.
    Exit Status:
    Returns success unless NAME is not found or an invalid option is given.`
        ],
        help: [
            "help [-s] [pattern ...]",
            `Display information about builtin commands.
    Displays brief summaries of builtin commands.  If PATTERN is
    specified, gives detailed help on all commands matching PATTERN,
    otherwise the list of help topics is printed.

    Options:
      -s	output only a short usage synopsis for each topic matching
    	PATTERN

    Exit Status:
    Returns success unless PATTERN is not found.`
        ],
        history: [
            "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]",
            `Display or manipulate the history list.
    Display the history list with line numbers, prefixing each modified
    entry with a \`*'.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`
        ],
        jobs: [
            "jobs [-lnprs] [jobspec ...] or jobs -x command [args]",
            `Display status of jobs.
    Lists the active jobs.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`
        ],
        kill: [
            "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]",
            `Send a signal to a job.
    Send the processes identified by PID or JOBSPEC the signal named by
    SIGSPEC or SIGNUM.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`
        ],
        let: [
            "let arg [arg ...]",
            `Evaluate arithmetic expressions.
    Evaluate each ARG as an arithmetic expression.  Evaluation is done in
    fixed-width integers with no check for overflow, though division by 0
    is trapped and flagged as an error.
    Exit Status:
    If the last ARG evaluates to 0, let returns 1; 0 is returned otherwise.`
        ],
        local: [
            "local [option] name[=value] ...",
            `Define local variables.
    Create a local variable called NAME, and give it VALUE.  OPTION can
    be any option accepted by \`declare'.

    Local can only be used within a function; it makes the variable NAME
    have a visible scope restricted to that function and its children.
    Exit Status:
    Returns success unless an invalid option is supplied, a variable
    assignment error occurs, or the shell is not executing a function.`
        ],
        logout: [
            "logout [n]",
            `Exit a login shell.
    Exits a login shell with exit status N.  Returns an error if not executed
    in a login shell.`
        ],
        mapfile: [
            "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]",
            `Read lines from the standard input into an indexed array variable.
    Read lines from the standard input into the indexed array variable ARRAY,
    or from file descriptor FD if the -u option is supplied.

    Options:
      -d delim	Use DELIM to terminate lines, instead of newline
      -n count	Copy at most COUNT lines
      -O origin	Begin assigning to ARRAY at index ORIGIN
      -s count	Discard the first COUNT lines read
      -t	Remove a trailing DELIM from each line read (default newline)
      -u fd	Read lines from file descriptor FD instead of standard input

    Exit Status:
    Returns success unless an invalid option is given or ARRAY is readonly.`
        ],
        popd: [
            "popd [-n] [+N | -N]",
            `Remove directories from stack.
    Removes entries from the directory stack.
    Exit Status:
    Returns success unless an invalid argument is supplied or the directory
    change fails.`
        ],
        printf: [
            "printf [-v var] format [arguments]",
            `Formats and prints ARGUMENTS under control of the FORMAT.

    Options:
      -v var	assign the output to shell variable VAR rather than
    		display it on the standard output

    FORMAT is a character string which contains three types of objects: plain
    characters, which are simply copied to standard output; character escape
    sequences, which are converted and copied to the standard output; and
    format specifications, each of which causes printing of the next successive
    argument.
    Exit Status:
    Returns success unless an invalid option is given or a write or assignment
    error occurs.`
        ],
        pushd: [
            "pushd [-n] [+N | -N | dir]",
            `Add directories to stack.
    Adds a directory to the top of the directory stack, or rotates
    the stack, making the new top of the stack the current working
    directory.
    Exit Status:
    Returns success unless an invalid argument is supplied or the directory
    change fails.`
        ],
        pwd: [
            "pwd [-LP]",
            `Print the name of the current working directory.

    Options:
      -L	print the value of $PWD if it names the current working
    	directory
      -P	print the physical directory, without any symbolic links

    By default, \`pwd' behaves as if \`-L' were specified.
    Exit Status:
    Returns 0 unless an invalid option is given or the current directory
    cannot be read.`
        ],
        read: [
            "read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]",
            `Read a line from the standard input and split it into fields.
    Reads a single line from the standard input, or from file descriptor FD
    if the -u option is supplied.  The line is split into fields as with word
    splitting, and the first word is assigned to the first NAME, the second
    word to the second NAME, and so on, with any leftover words assigned to
    the last NAME.
    Exit Status:
    The return code is zero, unless end-of-file is encountered, read times out,
    or an invalid file descriptor is supplied as the argument to -u.`
        ],
        readarray: [
            "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]",
            "Read lines from a file into an array variable.\n    A synonym for `mapfile'."
        ],
        readonly: [
            "readonly [-aAf] [name[=value] ...] or readonly -p",
            `Mark shell variables as unchangeable.
    Mark each NAME as read-only; the values of these NAMEs may not be
    changed by subsequent assignment.
    Exit Status:
    Returns success unless an invalid option is given or NAME is invalid.`
        ],
        return: [
            "return [n]",
            `Return from a shell function.
    Causes a function or sourced script to exit with the return value
    specified by N.  If N is omitted, the return status is that of the
    last command executed within the function or script.
    Exit Status:
    Returns N, or failure if the shell is not executing a function or script.`
        ],
        set: [
            "set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]",
            `Set or unset values of shell options and positional parameters.
    Change the value of shell attributes and positional parameters, or
    display the names and values of shell variables.

    Options:
      -e  Exit immediately if a command exits with a non-zero status.
      -u  Treat unset variables as an error when substituting.
      -x  Print commands and their arguments as they are executed.
      -o option-name
          Set the variable corresponding to option-name

    Exit Status:
    Returns success unless an invalid option is given.`
        ],
        shift: [
            "shift [n]",
            `Shift positional parameters.
    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is
    not given, it is assumed to be 1.
    Exit Status:
    Returns success unless N is negative or greater than $#.`
        ],
        shopt: [
            "shopt [-pqsu] [-o] [optname ...]",
            `Set and unset shell options.
    Change the setting of each shell option OPTNAME.  Without any option
    arguments, list each supplied OPTNAME, or all shell options if no
    OPTNAMEs are given, with an indication of whether or not each is set.

    Options:
      -o	restrict OPTNAMEs to those defined for use with \`set -o'
      -p	print each shell option with an indication of its status
      -q	suppress output
      -s	enable (set) each OPTNAME
      -u	disable (unset) each OPTNAME

    Exit Status:
    Returns success if OPTNAME is enabled; fails if an invalid option is
    given or OPTNAME is disabled.`
        ],
        source: [
            "source filename [arguments]",
            `Execute commands from a file in the current shell.
    Read and execute commands from FILENAME in the current shell.
    The entries in $PATH are used to find the directory containing FILENAME.
    Exit Status:
    Returns the status of the last command executed in FILENAME.`
        ],
        suspend: [
            "suspend [-f]",
            `Suspend shell execution.
    Suspend the execution of this shell until it receives a SIGCONT signal.`
        ],
        test: [
            "test [expr]",
            `Evaluate conditional expression.
    Exits with a status of 0 (true) or 1 (false) depending on
    the evaluation of EXPR.  Expressions may be unary or binary.
    Exit Status:
    Returns success if EXPR evaluates to true; fails if EXPR evaluates to
    false or an invalid argument is given.`
        ],
        times: [
            "times",
            `Display process times.
    Prints the accumulated user and system times for the shell and all of its
    child processes.
    Exit Status:
    Always succeeds.`
        ],
        trap: [
            "trap [-lp] [[arg] signal_spec ...]",
            `Trap signals and other events.
    Defines and activates handlers to be run when the shell receives signals
    or other conditions.
    Exit Status:
    Returns success unless a SIGSPEC is invalid or an invalid option is given.`
        ],
        true: [
            "true",
            `Return a successful result.
    Exit Status:
    Always succeeds.`
        ],
        type: [
            "type [-afptP] name [name ...]",
            `Display information about command type.
    For each NAME, indicate how it would be interpreted if used as a
    command name.

    Options:
      -a	display all locations containing an executable named NAME
      -f	suppress shell function lookup
      -P	force a PATH search for each NAME, even if it is an alias,
    	builtin, or function, and returns the name of the disk file
    	that would be executed
      -p	returns either the name of the disk file that would be executed,
    	or nothing if \`type -t NAME' would not return \`file'
      -t	output a single word which is one of \`alias', \`keyword',
    	\`function', \`builtin', \`file' or \`', if NAME is an alias,
    	shell reserved word, shell function, shell builtin, disk file,
    	or not found, respectively

    Exit Status:
    Returns success if all of the NAMEs are found; fails if any are not found.`
        ],
        typeset: [
            "typeset [-aAfFgilnrtux] [-p] name[=value] ...",
            "Set variable values and attributes.\n    A synonym for `declare'."
        ],
        ulimit: [
            "ulimit [-SHabcdefiklmnpqrstuvxPT] [limit]",
            `Modify shell resource limits.
    Provides control over the resources available to the shell and processes
    it creates, on systems that allow such control.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`
        ],
        umask: [
            "umask [-p] [-S] [mode]",
            `Display or set file mode mask.
    Sets the user file-creation mask to MODE.  If MODE is omitted, prints
    the current value of the mask.
    Exit Status:
    Returns success unless MODE is invalid or an invalid option is given.`
        ],
        unalias: [
            "unalias [-a] name [name ...]",
            `Remove each NAME from the list of defined aliases.
    Exit Status:
    Returns success unless a NAME is not an existing alias.`
        ],
        unset: [
            "unset [-f] [-v] [-n] [name ...]",
            `Unset values and attributes of shell variables and functions.
    For each NAME, remove the corresponding variable or function.

    Options:
      -f	treat each NAME as a shell function
      -v	treat each NAME as a shell variable
      -n	treat each NAME as a name reference and unset the variable itself
    	rather than the variable it references

    Without options, unset first tries to unset a variable, and if that fails,
    tries to unset a function.
    Exit Status:
    Returns success unless an invalid option is given or a NAME is read-only.`
        ],
        wait: [
            "wait [-fn] [id ...]",
            `Wait for job completion and return exit status.
    Waits for each process identified by an ID, which may be a process ID or a
    job specification, and reports its termination status.
    Exit Status:
    Returns the status of the last ID; fails if ID is invalid or an invalid
    option is given.`
        ]
    }, iy = Object.keys(sy).sort();
    function Tl(e, t) {
        let n = false, r = [], s = 0;
        for(; s < t.length;){
            let l = t[s];
            if (l === "--") {
                for(s++; s < t.length;)r.push(t[s]), s++;
                break;
            }
            if (l.startsWith("-") && l.length > 1) {
                for(let c = 1; c < l.length; c++){
                    let u = l[c];
                    if (u === "s") n = true;
                    else return M(`bash: help: -${u}: invalid option
`, 2);
                }
                s++;
            } else r.push(l), s++;
        }
        if (r.length === 0) return ik();
        let i = "", o = false, a = "";
        for (let l of r){
            let c = sk(l);
            if (c.length === 0) {
                a += `bash: help: no help topics match \`${l}'.  Try \`help help' or \`man -k ${l}' or \`info ${l}'.
`, o = true;
                continue;
            }
            for (let u of c){
                let [f, p] = sy[u];
                n ? i += `${u}: ${f}
` : i += `${u}: ${f}
${p}
`;
            }
        }
        return {
            exitCode: o ? 1 : 0,
            stdout: i,
            stderr: a
        };
    }
    function sk(e) {
        let t = e.replace(/[.+^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*").replace(/\?/g, "."), n = new RegExp(`^${t}$`);
        return iy.filter((r)=>n.test(r));
    }
    function ik() {
        let e = [];
        e.push("just-bash shell builtins"), e.push("These shell commands are defined internally. Type `help' to see this list."), e.push("Type `help name' to find out more about the function `name'."), e.push("");
        let t = 36, n = iy.slice(), r = Math.ceil(n.length / 2);
        for(let s = 0; s < r; s++){
            let i = n[s] || "", o = n[s + r] || "", a = i.padEnd(t);
            e.push(o ? `${a}${o}` : i);
        }
        return ue(`${e.join(`
`)}
`);
    }
    Fe();
    it();
    function ok(e) {
        let t = [], n = "", r = 0;
        for (let s of e){
            for (let i of s)i === "(" ? r++ : i === ")" && r--;
            n ? n += ` ${s}` : n = s, r === 0 && (t.push(n), n = "");
        }
        return n && t.push(n), t;
    }
    async function Ol(e, t) {
        if (t.length === 0) return M(`bash: let: expression expected
`);
        let n = ok(t), r = 0;
        for (let s of n)try {
            let o = Bt(`(( ${s} ))`).statements[0];
            if (o && o.pipelines.length > 0 && o.pipelines[0].commands.length > 0) {
                let a = o.pipelines[0].commands[0];
                a.type === "ArithmeticCommand" && (r = await Q(e, a.expression.expression));
            }
        } catch (i) {
            return M(`bash: let: ${s}: ${i.message}
`);
        }
        return W("", "", r === 0 ? 1 : 0);
    }
    Je();
    Fe();
    it();
    $t();
    Tt();
    on$1();
    async function Dl(e, t) {
        if (e.state.localScopes.length === 0) return M(`bash: local: can only be used in a function
`);
        let n = e.state.localScopes[e.state.localScopes.length - 1], r = "", s = 0, i = false, o = false, l = [];
        for (let c of t)if (c === "-n") i = true;
        else if (c === "-a") o = true;
        else if (c === "-p") ;
        else if (c.startsWith("-") && !c.includes("=")) for (let u of c.slice(1))u === "n" ? i = true : u === "a" ? o = true : u === "p" && (true);
        else l.push(c);
        if (l.length === 0) {
            let c = "", u = Array.from(n.keys()).filter((f)=>!f.includes("_") || !f.match(/_\d+$/)).filter((f)=>!f.includes("__length")).sort();
            for (let f of u){
                let p = e.state.env[f];
                p !== void 0 && (c += `${f}=${p}
`);
            }
            return W(c, "", 0);
        }
        for (let c of l){
            let u, f, p = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
            if (p) {
                u = p[1];
                let b = p[2];
                if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(u)) {
                    r += `bash: local: \`${c}': not a valid identifier
`, s = 1;
                    continue;
                }
                if (je(e, u, "bash"), !n.has(u)) {
                    n.set(u, e.state.env[u]);
                    let E = `${u}_`;
                    for (let C of Object.keys(e.state.env))C.startsWith(E) && !C.includes("__") && (n.has(C) || n.set(C, e.state.env[C]));
                }
                let y = `${u}_`;
                for (let E of Object.keys(e.state.env))E.startsWith(y) && !E.includes("__") && delete e.state.env[E];
                let w = Vt(b);
                for(let E = 0; E < w.length; E++)e.state.env[`${u}_${E}`] = w[E];
                e.state.env[`${u}__length`] = String(w.length), cn(e, u), i && Zt(e, u);
                continue;
            }
            let d = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
            if (d) {
                u = d[1];
                let b = d[2];
                if (je(e, u, "bash"), !n.has(u)) {
                    n.set(u, e.state.env[u]);
                    let A = `${u}_`;
                    for (let O of Object.keys(e.state.env))O.startsWith(A) && !O.includes("__") && (n.has(O) || n.set(O, e.state.env[O]));
                    let I = `${u}__length`;
                    e.state.env[I] !== void 0 && !n.has(I) && n.set(I, e.state.env[I]);
                }
                let y = Vt(b), w = _e(e, u), E = 0;
                if (w.length === 0 && e.state.env[u] !== void 0) {
                    let A = e.state.env[u];
                    e.state.env[`${u}_0`] = A, delete e.state.env[u], E = 1;
                } else w.length > 0 && (E = Math.max(...w) + 1);
                for(let A = 0; A < y.length; A++)e.state.env[`${u}_${E + A}`] = Te(e, y[A]);
                let C = E + y.length;
                e.state.env[`${u}__length`] = String(C), cn(e, u), i && Zt(e, u);
                continue;
            }
            let m = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
            if (m) {
                u = m[1];
                let b = Te(e, m[2]);
                je(e, u, "bash"), n.has(u) || n.set(u, e.state.env[u]);
                let y = e.state.env[u] ?? "";
                e.state.env[u] = y + b, cn(e, u), i && Zt(e, u);
                continue;
            }
            let h = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([^\]]+)\]=(.*)$/s);
            if (h) {
                u = h[1];
                let b = h[2], y = Te(e, h[3]);
                if (je(e, u, "bash"), !n.has(u)) {
                    n.set(u, e.state.env[u]);
                    let C = `${u}_`;
                    for (let I of Object.keys(e.state.env))I.startsWith(C) && !I.includes("__") && (n.has(I) || n.set(I, e.state.env[I]));
                    let A = `${u}__length`;
                    e.state.env[A] !== void 0 && !n.has(A) && n.set(A, e.state.env[A]);
                }
                let w;
                try {
                    let C = new se(), A = he(C, b);
                    w = await Q(e, A.expression);
                } catch  {
                    let C = parseInt(b, 10);
                    w = Number.isNaN(C) ? 0 : C;
                }
                e.state.env[`${u}_${w}`] = y;
                let E = parseInt(e.state.env[`${u}__length`] ?? "0", 10);
                w >= E && (e.state.env[`${u}__length`] = String(w + 1)), cn(e, u), i && Zt(e, u);
                continue;
            }
            if (c.includes("=")) {
                let b = c.indexOf("=");
                u = c.slice(0, b), f = Te(e, c.slice(b + 1));
            } else u = c;
            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(u)) {
                r += `bash: local: \`${c}': not a valid identifier
`, s = 1;
                continue;
            }
            let g = n.has(u);
            if (f !== void 0) {
                let b = e.state.env[u];
                if (e.state.tempEnvBindings) {
                    let y = e.state.accessedTempEnvVars?.has(u), w = e.state.mutatedTempEnvVars?.has(u);
                    if (!y && !w) for(let E = e.state.tempEnvBindings.length - 1; E >= 0; E--){
                        let C = e.state.tempEnvBindings[E];
                        if (C.has(u)) {
                            b = C.get(u);
                            break;
                        }
                    }
                }
                j0(e, u, b);
            }
            if (!g) {
                let b = e.state.env[u];
                if (e.state.tempEnvBindings) for(let y = e.state.tempEnvBindings.length - 1; y >= 0; y--){
                    let w = e.state.tempEnvBindings[y];
                    if (w.has(u)) {
                        b = w.get(u);
                        break;
                    }
                }
                if (n.set(u, b), o) {
                    let y = `${u}_`;
                    for (let E of Object.keys(e.state.env))E.startsWith(y) && !E.includes("__") && (n.has(E) || n.set(E, e.state.env[E]));
                    let w = `${u}__length`;
                    e.state.env[w] !== void 0 && !n.has(w) && n.set(w, e.state.env[w]);
                }
            }
            if (o && f === void 0) {
                let b = `${u}_`;
                for (let y of Object.keys(e.state.env))y.startsWith(b) && !y.includes("__") && delete e.state.env[y];
                e.state.env[`${u}__length`] = "0";
            } else if (f !== void 0) {
                if (je(e, u, "bash"), i && f !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(f)) {
                    r += `bash: local: \`${f}': invalid variable name for name reference
`, s = 1;
                    continue;
                }
                e.state.env[u] = f, e.state.options.allexport && (e.state.exportedVars = e.state.exportedVars || new Set(), e.state.exportedVars.add(u));
            } else {
                let b = e.state.tempEnvBindings?.some((y)=>y.has(u));
                !g && !b && delete e.state.env[u];
            }
            cn(e, u), i && Zt(e, u);
        }
        return W("", r, s);
    }
    $t();
    function Fl(e, t, n) {
        let r = `
`, s = 0, i = 0, o = 0, a = false, l = "MAPFILE", c = 0;
        for(; c < t.length;){
            let b = t[c];
            b === "-d" && c + 1 < t.length ? (r = t[c + 1] === "" ? "\0" : t[c + 1] || `
`, c += 2) : b === "-n" && c + 1 < t.length ? (s = Number.parseInt(t[c + 1], 10) || 0, c += 2) : b === "-O" && c + 1 < t.length ? (i = Number.parseInt(t[c + 1], 10) || 0, c += 2) : b === "-s" && c + 1 < t.length ? (o = Number.parseInt(t[c + 1], 10) || 0, c += 2) : b === "-t" ? (a = true, c++) : b === "-u" || b === "-C" || b === "-c" ? c += 2 : (b.startsWith("-") || (l = b), c++);
        }
        let u = n;
        !u && e.state.groupStdin !== void 0 && (u = e.state.groupStdin);
        let f = [], p = u, d = 0, m = 0;
        for(; p.length > 0;){
            let b = p.indexOf(r);
            if (b === -1) {
                if (p.length > 0) {
                    if (m < o) m++;
                    else if (s === 0 || d < s) {
                        let E = p, C = E.indexOf("\0");
                        C !== -1 && (E = E.substring(0, C)), f.push(E), d++;
                    }
                }
                break;
            }
            let y = p.substring(0, b), w = y.indexOf("\0");
            if (w !== -1 && (y = y.substring(0, w)), !a && r !== "\0" && (y += r), p = p.substring(b + r.length), m < o) {
                m++;
                continue;
            }
            if (s > 0 && d >= s) break;
            f.push(y), d++;
        }
        i === 0 && Ut(e, l);
        for(let b = 0; b < f.length; b++)e.state.env[`${l}_${i + b}`] = f[b];
        let h = parseInt(e.state.env[`${l}__length`] || "0", 10), g = i + f.length;
        return e.state.env[`${l}__length`] = String(Math.max(h, g)), e.state.groupStdin !== void 0 && !n && (e.state.groupStdin = ""), W("", "", 0);
    }
    $t();
    St();
    function ak(e) {
        if (!e.startsWith("__rw__:")) return null;
        let t = e.slice(7), n = t.indexOf(":");
        if (n === -1) return null;
        let r = Number.parseInt(t.slice(0, n), 10);
        if (Number.isNaN(r) || r < 0) return null;
        let s = n + 1, i = t.slice(s, s + r), o = s + r + 1, a = t.slice(o), l = a.indexOf(":");
        if (l === -1) return null;
        let c = Number.parseInt(a.slice(0, l), 10);
        if (Number.isNaN(c) || c < 0) return null;
        let u = a.slice(l + 1);
        return {
            path: i,
            position: c,
            content: u
        };
    }
    function lk(e, t, n) {
        return `__rw__:${e.length}:${e}:${t}:${n}`;
    }
    function _l(e, t, n, r = -1) {
        let s = false, i = `
`, a = -1, l = -1, c = null, u = -1, f = -1, p = [], d = 0, m = false, h = ($, N)=>{
            let P = 1;
            for(; P < $.length;){
                let k = $[P];
                if (k === "r") s = true, P++;
                else if (k === "s") P++;
                else {
                    if (k === "d") return P + 1 < $.length ? (i = $.substring(P + 1), {
                        nextArgIndex: N + 1
                    }) : N + 1 < t.length ? (i = t[N + 1], {
                        nextArgIndex: N + 2
                    }) : {
                        nextArgIndex: N + 1
                    };
                    if (k === "n") {
                        if (P + 1 < $.length) {
                            let R = $.substring(P + 1);
                            return a = Number.parseInt(R, 10), (Number.isNaN(a) || a < 0) && (m = true, a = 0), {
                                nextArgIndex: N + 1
                            };
                        } else if (N + 1 < t.length) return a = Number.parseInt(t[N + 1], 10), (Number.isNaN(a) || a < 0) && (m = true, a = 0), {
                            nextArgIndex: N + 2
                        };
                        return {
                            nextArgIndex: N + 1
                        };
                    } else if (k === "N") {
                        if (P + 1 < $.length) {
                            let R = $.substring(P + 1);
                            return l = Number.parseInt(R, 10), (Number.isNaN(l) || l < 0) && (m = true, l = 0), {
                                nextArgIndex: N + 1
                            };
                        } else if (N + 1 < t.length) return l = Number.parseInt(t[N + 1], 10), (Number.isNaN(l) || l < 0) && (m = true, l = 0), {
                            nextArgIndex: N + 2
                        };
                        return {
                            nextArgIndex: N + 1
                        };
                    } else {
                        if (k === "a") return P + 1 < $.length ? (c = $.substring(P + 1), {
                            nextArgIndex: N + 1
                        }) : N + 1 < t.length ? (c = t[N + 1], {
                            nextArgIndex: N + 2
                        }) : {
                            nextArgIndex: N + 1
                        };
                        if (k === "p") return P + 1 < $.length ? ($.substring(P + 1), {
                            nextArgIndex: N + 1
                        }) : N + 1 < t.length ? (t[N + 1], {
                            nextArgIndex: N + 2
                        }) : {
                            nextArgIndex: N + 1
                        };
                        if (k === "u") {
                            if (P + 1 < $.length) {
                                let R = $.substring(P + 1);
                                return u = Number.parseInt(R, 10), Number.isNaN(u) || u < 0 ? {
                                    nextArgIndex: -2
                                } : {
                                    nextArgIndex: N + 1
                                };
                            } else if (N + 1 < t.length) return u = Number.parseInt(t[N + 1], 10), Number.isNaN(u) || u < 0 ? {
                                nextArgIndex: -2
                            } : {
                                nextArgIndex: N + 2
                            };
                            return {
                                nextArgIndex: N + 1
                            };
                        } else if (k === "t") {
                            if (P + 1 < $.length) {
                                let R = $.substring(P + 1);
                                return f = Number.parseFloat(R), Number.isNaN(f) && (f = 0), {
                                    nextArgIndex: N + 1
                                };
                            } else if (N + 1 < t.length) return f = Number.parseFloat(t[N + 1]), Number.isNaN(f) && (f = 0), {
                                nextArgIndex: N + 2
                            };
                            return {
                                nextArgIndex: N + 1
                            };
                        } else if (k === "e" || k === "i" || k === "P") {
                            if (k === "i" && N + 1 < t.length) return {
                                nextArgIndex: N + 2
                            };
                            P++;
                        } else P++;
                    }
                }
            }
            return {
                nextArgIndex: N + 1
            };
        };
        for(; d < t.length;){
            let $ = t[d];
            if ($.startsWith("-") && $.length > 1 && $ !== "--") {
                let N = h($, d);
                if (N.nextArgIndex === -1) return {
                    stdout: "",
                    stderr: "",
                    exitCode: 2
                };
                if (N.nextArgIndex === -2) return {
                    stdout: "",
                    stderr: "",
                    exitCode: 1
                };
                d = N.nextArgIndex;
            } else if ($ === "--") for(d++; d < t.length;)p.push(t[d]), d++;
            else p.push($), d++;
        }
        if (m) return W("", "", 1);
        if (p.length === 0 && c === null && p.push("REPLY"), f === 0) {
            if (c) Ut(e, c);
            else {
                for (let $ of p)e.state.env[$] = "";
                p.length === 0 && (e.state.env.REPLY = "");
            }
            return W("", "", 0);
        }
        if (f < 0 && f !== -1) return W("", "", 1);
        let g = n;
        u >= 0 ? e.state.fileDescriptors ? g = e.state.fileDescriptors.get(u) || "" : g = "" : !g && e.state.groupStdin !== void 0 && (g = e.state.groupStdin);
        let b = i === "" ? "\0" : i, y = "", w = 0, E = true, C = ($)=>{
            if (u >= 0 && e.state.fileDescriptors) e.state.fileDescriptors.set(u, g.substring($));
            else if (r >= 0 && e.state.fileDescriptors) {
                let N = e.state.fileDescriptors.get(r);
                if (N?.startsWith("__rw__:")) {
                    let P = ak(N);
                    if (P) {
                        let k = P.position + $;
                        e.state.fileDescriptors.set(r, lk(P.path, k, P.content));
                    }
                }
            } else e.state.groupStdin !== void 0 && !n && (e.state.groupStdin = g.substring($));
        };
        if (l >= 0) {
            let $ = Math.min(l, g.length);
            y = g.substring(0, $), w = $, E = $ >= l, C(w);
            let N = p[0] || "REPLY";
            e.state.env[N] = y;
            for(let P = 1; P < p.length; P++)e.state.env[p[P]] = "";
            return W("", "", E ? 0 : 1);
        } else if (a >= 0) {
            let $ = 0, N = 0, P = false;
            for(; N < g.length && $ < a;){
                let k = g[N];
                if (k === b) {
                    w = N + 1, P = true;
                    break;
                }
                if (!s && k === "\\" && N + 1 < g.length) {
                    let R = g[N + 1];
                    if (R === b && b === `
`) {
                        N += 2, w = N;
                        continue;
                    }
                    if (R === b) {
                        N += 2, $++, y += R, w = N;
                        continue;
                    }
                    y += R, N += 2, $++, w = N;
                } else y += k, N++, $++, w = N;
            }
            E = $ >= a || P, C(w);
        } else {
            w = 0;
            let $ = 0;
            for(; $ < g.length;){
                let N = g[$];
                if (N === b) {
                    w = $ + b.length, E = true;
                    break;
                }
                if (!s && N === "\\" && $ + 1 < g.length) {
                    let P = g[$ + 1];
                    if (P === `
`) {
                        $ += 2;
                        continue;
                    }
                    if (P === b) {
                        y += P, $ += 2;
                        continue;
                    }
                    y += N, y += P, $ += 2;
                    continue;
                }
                y += N, $++;
            }
            if ($ >= g.length && (E = false, w = $, y.length === 0 && g.length === 0)) {
                for (let N of p)e.state.env[N] = "";
                return c && Ut(e, c), W("", "", 1);
            }
            C(w);
        }
        b === `
` && y.endsWith(`
`) && (y = y.slice(0, -1));
        let A = ($)=>s ? $ : $.replace(/\\(.)/g, "$1");
        if (p.length === 1 && p[0] === "REPLY") return e.state.env.REPLY = A(y), W("", "", E ? 0 : 1);
        let I = Ue(e.state.env);
        if (c) {
            let { words: $ } = Ba(y, I, void 0, s);
            Ut(e, c);
            for(let N = 0; N < $.length; N++)e.state.env[`${c}_${N}`] = A($[N]);
            return W("", "", E ? 0 : 1);
        }
        let O = p.length, { words: L, wordStarts: D } = Ba(y, I, O, s);
        for(let $ = 0; $ < p.length; $++){
            let N = p[$];
            if ($ < p.length - 1) e.state.env[N] = A(L[$] ?? "");
            else if ($ < D.length) {
                let P = y.substring(D[$]);
                P = ig(P, I, s), P = A(P), e.state.env[N] = P;
            } else e.state.env[N] = "";
        }
        return W("", "", E ? 0 : 1);
    }
    de();
    function Ll(e, t) {
        if (e.state.callDepth === 0 && e.state.sourceDepth === 0) return M("bash: return: can only `return' from a function or sourced script\n");
        let n = e.state.lastExitCode;
        if (t.length > 0) {
            let r = t[0], s = Number.parseInt(r, 10);
            if (r === "" || Number.isNaN(s) || !/^-?\d+$/.test(r)) return M(`bash: return: ${r}: numeric argument required
`, 2);
            n = (s % 256 + 256) % 256;
        }
        throw new Ve(n);
    }
    de();
    $t();
    var Oi = `set: usage: set [-eux] [+eux] [-o option] [+o option]
Options:
  -e            Exit immediately if a command exits with non-zero status
  +e            Disable -e
  -u            Treat unset variables as an error when substituting
  +u            Disable -u
  -x            Print commands and their arguments as they are executed
  +x            Disable -x
  -o errexit    Same as -e
  +o errexit    Disable errexit
  -o nounset    Same as -u
  +o nounset    Disable nounset
  -o pipefail   Return status of last failing command in pipeline
  +o pipefail   Disable pipefail
  -o xtrace     Same as -x
  +o xtrace     Disable xtrace
`, oy = {
        e: "errexit",
        u: "nounset",
        x: "xtrace",
        v: "verbose",
        f: "noglob",
        C: "noclobber",
        a: "allexport",
        n: "noexec",
        h: null,
        b: null,
        m: null,
        B: null,
        H: null,
        P: null,
        T: null,
        E: null,
        p: null
    }, ay = {
        errexit: "errexit",
        pipefail: "pipefail",
        nounset: "nounset",
        xtrace: "xtrace",
        verbose: "verbose",
        noclobber: "noclobber",
        noglob: "noglob",
        allexport: "allexport",
        noexec: "noexec",
        posix: "posix",
        vi: "vi",
        emacs: "emacs",
        notify: null,
        monitor: null,
        braceexpand: null,
        histexpand: null,
        physical: null,
        functrace: null,
        errtrace: null,
        privileged: null,
        hashall: null,
        ignoreeof: null,
        "interactive-comments": null,
        keyword: null,
        onecmd: null
    }, ly = [
        "errexit",
        "nounset",
        "pipefail",
        "verbose",
        "xtrace",
        "posix",
        "allexport",
        "noclobber",
        "noglob",
        "noexec",
        "vi",
        "emacs"
    ], cy = [
        "braceexpand",
        "errtrace",
        "functrace",
        "hashall",
        "histexpand",
        "history",
        "ignoreeof",
        "interactive-comments",
        "keyword",
        "monitor",
        "nolog",
        "notify",
        "onecmd",
        "physical",
        "privileged"
    ];
    function uy(e, t, n) {
        t !== null && (n && (t === "vi" ? e.state.options.emacs = false : t === "emacs" && (e.state.options.vi = false)), e.state.options[t] = n, Jn(e));
    }
    function ck(e, t) {
        return t + 1 < e.length && !e[t + 1].startsWith("-") && !e[t + 1].startsWith("+");
    }
    function uk(e, t) {
        let n = _e(e, t);
        if (n.length === 0) return `${t}=()`;
        let r = n.map((s)=>{
            let i = e.state.env[`${t}_${s}`] ?? "";
            return `[${s}]=${In(i)}`;
        });
        return `${t}=(${r.join(" ")})`;
    }
    function fk(e) {
        return /^[a-zA-Z0-9_]+$/.test(e) ? e : `"${e.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    function pk(e, t) {
        let n = Pt(e, t);
        if (n.length === 0) return `${t}=()`;
        let r = n.map((s)=>{
            let i = e.state.env[`${t}_${s}`] ?? "";
            return `[${fk(s)}]=${In(i)}`;
        });
        return `${t}=(${r.join(" ")} )`;
    }
    function dk(e) {
        let t = new Set(), n = e.state.associativeArrays ?? new Set();
        for (let r of Object.keys(e.state.env)){
            let s = r.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_(\d+)$/);
            if (s) {
                let i = s[1];
                n.has(i) || t.add(i);
            }
        }
        return t;
    }
    function hk(e) {
        return e.state.associativeArrays ?? new Set();
    }
    function Wl(e, t) {
        if (t.includes("--help")) return ue(Oi);
        if (t.length === 0) {
            let r = dk(e), s = hk(e), i = (l)=>{
                for (let c of s){
                    let u = `${c}_`, f = `${c}__length`;
                    if (l !== f && l.startsWith(u)) {
                        if (l.slice(u.length).startsWith("_length")) continue;
                        return true;
                    }
                }
                return false;
            }, o = [];
            for (let [l, c] of Object.entries(e.state.env)){
                if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(l) || r.has(l) || s.has(l)) continue;
                let u = l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_(\d+)$/);
                if (u && r.has(u[1])) continue;
                let f = l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
                f && r.has(f[1]) || i(l) || f && s.has(f[1]) || o.push([
                    l,
                    c
                ]);
            }
            let a = [];
            for (let [l, c] of o.sort(([u], [f])=>u < f ? -1 : u > f ? 1 : 0))a.push(`${l}=${Ri(c)}`);
            for (let l of [
                ...r
            ].sort((c, u)=>c < u ? -1 : c > u ? 1 : 0))a.push(uk(e, l));
            for (let l of [
                ...s
            ].sort((c, u)=>c < u ? -1 : c > u ? 1 : 0))a.push(pk(e, l));
            return a.sort((l, c)=>{
                let u = l.split("=")[0], f = c.split("=")[0];
                return u < f ? -1 : u > f ? 1 : 0;
            }), ue(a.length > 0 ? `${a.join(`
`)}
` : "");
        }
        let n = 0;
        for(; n < t.length;){
            let r = t[n];
            if ((r === "-o" || r === "+o") && ck(t, n)) {
                let s = t[n + 1];
                if (!(s in ay)) {
                    let i = `bash: set: ${s}: invalid option name
${Oi}`;
                    if (e.state.options.posix) throw new xt(1, "", i);
                    return M(i);
                }
                uy(e, ay[s], r === "-o"), n += 2;
                continue;
            }
            if (r === "-o") {
                let s = ly.map((a)=>`${a.padEnd(16)}${e.state.options[a] ? "on" : "off"}`), i = cy.map((a)=>`${a.padEnd(16)}off`), o = [
                    ...s,
                    ...i
                ].sort();
                return ue(`${o.join(`
`)}
`);
            }
            if (r === "+o") {
                let s = ly.map((a)=>`set ${e.state.options[a] ? "-o" : "+o"} ${a}`), i = cy.map((a)=>`set +o ${a}`), o = [
                    ...s,
                    ...i
                ].sort();
                return ue(`${o.join(`
`)}
`);
            }
            if (r.length > 1 && (r[0] === "-" || r[0] === "+") && r[1] !== "-") {
                let s = r[0] === "-";
                for(let i = 1; i < r.length; i++){
                    let o = r[i];
                    if (!(o in oy)) {
                        let a = `bash: set: ${r[0]}${o}: invalid option
${Oi}`;
                        if (e.state.options.posix) throw new xt(1, "", a);
                        return M(a);
                    }
                    uy(e, oy[o], s);
                }
                n++;
                continue;
            }
            if (r === "--") return Ml(e, t.slice(n + 1)), le;
            if (r === "-") {
                if (e.state.options.xtrace = false, e.state.options.verbose = false, Jn(e), n + 1 < t.length) return Ml(e, t.slice(n + 1)), le;
                n++;
                continue;
            }
            if (r === "+") {
                n++;
                continue;
            }
            if (r.startsWith("-") || r.startsWith("+")) {
                let s = `bash: set: ${r}: invalid option
${Oi}`;
                if (e.state.options.posix) throw new xt(1, "", s);
                return M(s);
            }
            return Ml(e, t.slice(n)), le;
        }
        return le;
    }
    function Ml(e, t) {
        let n = 1;
        for(; e.state.env[String(n)] !== void 0;)delete e.state.env[String(n)], n++;
        for(let r = 0; r < t.length; r++)e.state.env[String(r + 1)] = t[r];
        e.state.env["#"] = String(t.length), e.state.env["@"] = t.join(" "), e.state.env["*"] = t.join(" ");
    }
    de();
    function Bl(e, t) {
        let n = 1;
        if (t.length > 0) {
            let o = Number.parseInt(t[0], 10);
            if (Number.isNaN(o) || o < 0) {
                let a = `bash: shift: ${t[0]}: numeric argument required
`;
                if (e.state.options.posix) throw new xt(1, "", a);
                return M(a);
            }
            n = o;
        }
        let r = Number.parseInt(e.state.env["#"] || "0", 10);
        if (n > r) {
            let o = `bash: shift: shift count out of range
`;
            if (e.state.options.posix) throw new xt(1, "", o);
            return M(o);
        }
        if (n === 0) return le;
        let s = [];
        for(let o = 1; o <= r; o++)s.push(e.state.env[String(o)] || "");
        let i = s.slice(n);
        for(let o = 1; o <= r; o++)delete e.state.env[String(o)];
        for(let o = 0; o < i.length; o++)e.state.env[String(o + 1)] = i[o];
        return e.state.env["#"] = String(i.length), e.state.env["@"] = i.join(" "), le;
    }
    Fe();
    de();
    async function Ul(e, t) {
        let n = t;
        if (n.length > 0 && n[0] === "--" && (n = n.slice(1)), n.length === 0) return W("", `bash: source: filename argument required
`, 2);
        let r = n[0], s = null, i = null;
        if (r.includes("/")) {
            let c = e.fs.resolvePath(e.state.cwd, r);
            try {
                i = await e.fs.readFile(c), s = c;
            } catch  {}
        } else {
            let u = (e.state.env.PATH || "").split(":").filter((f)=>f);
            for (let f of u){
                let p = e.fs.resolvePath(e.state.cwd, `${f}/${r}`);
                try {
                    if ((await e.fs.stat(p)).isDirectory) continue;
                    i = await e.fs.readFile(p), s = p;
                    break;
                } catch  {}
            }
            if (i === null) {
                let f = e.fs.resolvePath(e.state.cwd, r);
                try {
                    i = await e.fs.readFile(f), s = f;
                } catch  {}
            }
        }
        if (i === null) return M(`bash: ${r}: No such file or directory
`);
        let o = {};
        if (n.length > 1) {
            for(let u = 1; u <= 9; u++)o[String(u)] = e.state.env[String(u)];
            o["#"] = e.state.env["#"], o["@"] = e.state.env["@"];
            let c = n.slice(1);
            e.state.env["#"] = String(c.length), e.state.env["@"] = c.join(" ");
            for(let u = 0; u < c.length && u < 9; u++)e.state.env[String(u + 1)] = c[u];
            for(let u = c.length + 1; u <= 9; u++)delete e.state.env[String(u)];
        }
        let a = e.state.currentSource, l = ()=>{
            if (e.state.sourceDepth--, e.state.currentSource = a, n.length > 1) for (let [c, u] of Object.entries(o))u === void 0 ? delete e.state.env[c] : e.state.env[c] = u;
        };
        e.state.sourceDepth++, e.state.currentSource = r;
        try {
            let c = Bt(i), u = await e.executeScript(c);
            return l(), u;
        } catch (c) {
            if (l(), c instanceof ae) throw c;
            if (c instanceof Ve) return W(c.stdout, c.stderr, c.exitCode);
            if (c.name === "ParseException") return M(`bash: ${r}: ${c.message}
`);
            throw c;
        }
    }
    Je();
    Fe();
    it();
    ht();
    ot();
    Tt();
    on$1();
    function fy(e) {
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e);
    }
    function mk(e) {
        return e.startsWith("'") && e.endsWith("'") || e.startsWith('"') && e.endsWith('"');
    }
    async function py(e, t) {
        if (mk(t)) return null;
        try {
            let n = new se(), r = he(n, t);
            return await Q(e, r.expression);
        } catch  {
            let n = parseInt(t, 10);
            return Number.isNaN(n) ? 0 : n;
        }
    }
    function dy(e, t) {
        if (e.state.localVarStack?.has(t)) {
            let r = vi(e, t);
            if (r) {
                r.value === void 0 ? delete e.state.env[t] : e.state.env[t] = r.value;
                let s = e.state.localVarStack?.get(t);
                if (!s || s.length === 0) ki(e, t), e.state.localVarStack?.delete(t), e.state.fullyUnsetLocals = e.state.fullyUnsetLocals || new Map(), e.state.fullyUnsetLocals.set(t, r.scopeIndex), zl(e, t);
                else {
                    let i = s[s.length - 1];
                    e.state.localVarDepth = e.state.localVarDepth || new Map(), e.state.localVarDepth.set(t, i.scopeIndex + 1);
                }
                return true;
            }
            return delete e.state.env[t], ki(e, t), e.state.localVarStack?.delete(t), e.state.fullyUnsetLocals = e.state.fullyUnsetLocals || new Map(), e.state.fullyUnsetLocals.set(t, 0), true;
        }
        for(let r = e.state.localScopes.length - 1; r >= 0; r--){
            let s = e.state.localScopes[r];
            if (s.has(t)) {
                let i = s.get(t);
                i === void 0 ? delete e.state.env[t] : e.state.env[t] = i, s.delete(t);
                let o = false;
                for(let a = r - 1; a >= 0; a--)if (e.state.localScopes[a].has(t)) {
                    e.state.localVarDepth && e.state.localVarDepth.set(t, a + 1), o = true;
                    break;
                }
                return o || ki(e, t), true;
            }
        }
        return false;
    }
    function zl(e, t) {
        if (!e.state.tempEnvBindings || e.state.tempEnvBindings.length === 0) return false;
        for(let n = e.state.tempEnvBindings.length - 1; n >= 0; n--){
            let r = e.state.tempEnvBindings[n];
            if (r.has(t)) {
                let s = r.get(t);
                return s === void 0 ? delete e.state.env[t] : e.state.env[t] = s, r.delete(t), true;
            }
        }
        return false;
    }
    async function hy(e, t) {
        if (t.startsWith("'") && t.endsWith("'")) return t.slice(1, -1);
        if (t.startsWith('"') && t.endsWith('"')) {
            let n = t.slice(1, -1), s = new se().parseWordFromString(n, true, false);
            return J(e, s);
        }
        if (t.includes("$")) {
            let r = new se().parseWordFromString(t, false, false);
            return J(e, r);
        }
        return t;
    }
    async function jl(e, t) {
        let n = "both", r = "", s = 0;
        for (let i of t){
            if (i === "-v") {
                n = "variable";
                continue;
            }
            if (i === "-f") {
                n = "function";
                continue;
            }
            if (n === "function") {
                e.state.functions.delete(i);
                continue;
            }
            if (n === "variable") {
                let c = i.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
                if (c) {
                    let p = c[1], d = c[2];
                    if (d === "@" || d === "*") {
                        let w = te(e, p);
                        for (let [E] of w)delete e.state.env[`${p}_${E}`];
                        delete e.state.env[p];
                        continue;
                    }
                    let m = e.state.associativeArrays?.has(p);
                    if (m) {
                        let w = await hy(e, d);
                        delete e.state.env[`${p}_${w}`];
                        continue;
                    }
                    let h = Qt(e, p), g = e.state.declaredVars?.has(p);
                    if ((p in e.state.env || g) && !h && !m) {
                        r += `bash: unset: ${p}: not an array variable
`, s = 1;
                        continue;
                    }
                    let y = await py(e, d);
                    if (y === null && h) {
                        r += `bash: unset: ${d}: not a valid identifier
`, s = 1;
                        continue;
                    }
                    if (y === null) continue;
                    if (y < 0) {
                        let w = te(e, p), E = w.length, C = e.state.currentLine;
                        if (E === 0) {
                            r += `bash: line ${C}: unset: [${y}]: bad array subscript
`, s = 1;
                            continue;
                        }
                        let A = E + y;
                        if (A < 0) {
                            r += `bash: line ${C}: unset: [${y}]: bad array subscript
`, s = 1;
                            continue;
                        }
                        let I = w[A][0];
                        delete e.state.env[`${p}_${I}`];
                        continue;
                    }
                    delete e.state.env[`${p}_${y}`];
                    continue;
                }
                if (!fy(i)) {
                    r += `bash: unset: \`${i}': not a valid identifier
`, s = 1;
                    continue;
                }
                let u = i;
                if (Se(e, i)) {
                    let p = st(e, i);
                    p && p !== i && (u = p);
                }
                if (Ht(e, u)) {
                    r += `bash: unset: ${u}: cannot unset: readonly variable
`, s = 1;
                    continue;
                }
                let f = ar(e, u);
                if (f !== void 0 && f !== e.state.callDepth) dy(e, u);
                else if (e.state.fullyUnsetLocals?.has(u)) delete e.state.env[u];
                else if (f !== void 0) {
                    let p = e.state.accessedTempEnvVars?.has(u), d = e.state.mutatedTempEnvVars?.has(u);
                    if ((p || d) && e.state.localVarStack?.has(u)) {
                        let m = vi(e, u);
                        m ? m.value === void 0 ? delete e.state.env[u] : e.state.env[u] = m.value : delete e.state.env[u];
                    } else delete e.state.env[u];
                } else zl(e, u) || delete e.state.env[u];
                e.state.exportedVars?.delete(u);
                continue;
            }
            let o = i.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
            if (o) {
                let c = o[1], u = o[2];
                if (u === "@" || u === "*") {
                    let h = te(e, c);
                    for (let [g] of h)delete e.state.env[`${c}_${g}`];
                    delete e.state.env[c];
                    continue;
                }
                let f = e.state.associativeArrays?.has(c);
                if (f) {
                    let h = await hy(e, u);
                    delete e.state.env[`${c}_${h}`];
                    continue;
                }
                let p = Qt(e, c);
                if (c in e.state.env && !p && !f) {
                    r += `bash: unset: ${c}: not an array variable
`, s = 1;
                    continue;
                }
                let m = await py(e, u);
                if (m === null && p) {
                    r += `bash: unset: ${u}: not a valid identifier
`, s = 1;
                    continue;
                }
                if (m === null) continue;
                if (m < 0) {
                    let h = te(e, c), g = h.length, b = e.state.currentLine;
                    if (g === 0) {
                        r += `bash: line ${b}: unset: [${m}]: bad array subscript
`, s = 1;
                        continue;
                    }
                    let y = g + m;
                    if (y < 0) {
                        r += `bash: line ${b}: unset: [${m}]: bad array subscript
`, s = 1;
                        continue;
                    }
                    let w = h[y][0];
                    delete e.state.env[`${c}_${w}`];
                    continue;
                }
                delete e.state.env[`${c}_${m}`];
                continue;
            }
            if (!fy(i)) {
                r += `bash: unset: \`${i}': not a valid identifier
`, s = 1;
                continue;
            }
            let a = i;
            if (Se(e, i)) {
                let c = st(e, i);
                c && c !== i && (a = c);
            }
            if (Ht(e, a)) {
                r += `bash: unset: ${a}: cannot unset: readonly variable
`, s = 1;
                continue;
            }
            let l = ar(e, a);
            if (l !== void 0 && l !== e.state.callDepth) dy(e, a);
            else if (e.state.fullyUnsetLocals?.has(a)) delete e.state.env[a];
            else if (l !== void 0) {
                let c = e.state.accessedTempEnvVars?.has(a), u = e.state.mutatedTempEnvVars?.has(a);
                if ((c || u) && e.state.localVarStack?.has(a)) {
                    let f = vi(e, a);
                    f ? f.value === void 0 ? delete e.state.env[a] : e.state.env[a] = f.value : delete e.state.env[a];
                } else delete e.state.env[a];
            } else zl(e, a) || delete e.state.env[a];
            e.state.exportedVars?.delete(a), e.state.functions.delete(i);
        }
        return W("", r, s);
    }
    var Hl = [
        "extglob",
        "dotglob",
        "nullglob",
        "failglob",
        "globstar",
        "globskipdots",
        "nocaseglob",
        "nocasematch",
        "expand_aliases",
        "lastpipe",
        "xpg_echo"
    ], gk = [
        "autocd",
        "cdable_vars",
        "cdspell",
        "checkhash",
        "checkjobs",
        "checkwinsize",
        "cmdhist",
        "compat31",
        "compat32",
        "compat40",
        "compat41",
        "compat42",
        "compat43",
        "compat44",
        "complete_fullquote",
        "direxpand",
        "dirspell",
        "execfail",
        "extdebug",
        "extquote",
        "force_fignore",
        "globasciiranges",
        "gnu_errfmt",
        "histappend",
        "histreedit",
        "histverify",
        "hostcomplete",
        "huponexit",
        "inherit_errexit",
        "interactive_comments",
        "lithist",
        "localvar_inherit",
        "localvar_unset",
        "login_shell",
        "mailwarn",
        "no_empty_cmd_completion",
        "progcomp",
        "progcomp_alias",
        "promptvars",
        "restricted_shell",
        "shift_verbose",
        "sourcepath"
    ];
    function Di(e) {
        return Hl.includes(e);
    }
    function yk(e) {
        return gk.includes(e);
    }
    function my(e, t) {
        let n = false, r = false, s = false, i = false, o = false, a = [], l = 0;
        for(; l < t.length;){
            let p = t[l];
            if (p === "--") {
                l++;
                break;
            }
            if (p.startsWith("-") && p.length > 1) {
                for(let d = 1; d < p.length; d++){
                    let m = p[d];
                    switch(m){
                        case "s":
                            n = true;
                            break;
                        case "u":
                            r = true;
                            break;
                        case "p":
                            s = true;
                            break;
                        case "q":
                            i = true;
                            break;
                        case "o":
                            o = true;
                            break;
                        default:
                            return {
                                exitCode: 2,
                                stdout: "",
                                stderr: `shopt: -${m}: invalid option
`
                            };
                    }
                }
                l++;
            } else break;
        }
        for(; l < t.length;)a.push(t[l]), l++;
        if (o) return bk(e, a, n, r, s, i);
        if (n && r) return {
            exitCode: 1,
            stdout: "",
            stderr: `shopt: cannot set and unset shell options simultaneously
`
        };
        if (a.length === 0) {
            if (n || r) {
                let d = [];
                for (let m of Hl){
                    let h = e.state.shoptOptions[m];
                    n && h ? d.push(s ? `shopt -s ${m}` : `${m}		on`) : r && !h && d.push(s ? `shopt -u ${m}` : `${m}		off`);
                }
                return {
                    exitCode: 0,
                    stdout: d.length > 0 ? `${d.join(`
`)}
` : "",
                    stderr: ""
                };
            }
            let p = [];
            for (let d of Hl){
                let m = e.state.shoptOptions[d];
                p.push(s ? `shopt ${m ? "-s" : "-u"} ${d}` : `${d}		${m ? "on" : "off"}`);
            }
            return {
                exitCode: 0,
                stdout: `${p.join(`
`)}
`,
                stderr: ""
            };
        }
        let c = false, u = "", f = [];
        for (let p of a){
            if (!Di(p) && !yk(p)) {
                u += `shopt: ${p}: invalid shell option name
`, c = true;
                continue;
            }
            if (n) Di(p) && (e.state.shoptOptions[p] = true, pa(e));
            else if (r) Di(p) && (e.state.shoptOptions[p] = false, pa(e));
            else if (Di(p)) {
                let d = e.state.shoptOptions[p];
                i ? d || (c = true) : s ? (f.push(`shopt ${d ? "-s" : "-u"} ${p}`), d || (c = true)) : (f.push(`${p}		${d ? "on" : "off"}`), d || (c = true));
            } else i ? c = true : s ? (f.push(`shopt -u ${p}`), c = true) : (f.push(`${p}		off`), c = true);
        }
        return {
            exitCode: c ? 1 : 0,
            stdout: f.length > 0 ? `${f.join(`
`)}
` : "",
            stderr: u
        };
    }
    function bk(e, t, n, r, s, i) {
        let o = {
            errexit: "errexit",
            pipefail: "pipefail",
            nounset: "nounset",
            xtrace: "xtrace",
            verbose: "verbose",
            posix: "posix",
            allexport: "allexport",
            noclobber: "noclobber",
            noglob: "noglob",
            noexec: "noexec",
            vi: "vi",
            emacs: "emacs"
        }, a = [
            "braceexpand",
            "errtrace",
            "functrace",
            "hashall",
            "histexpand",
            "history",
            "ignoreeof",
            "interactive-comments",
            "keyword",
            "monitor",
            "nolog",
            "notify",
            "onecmd",
            "physical",
            "privileged"
        ], l = [
            ...Object.keys(o),
            ...a
        ].sort();
        if (t.length === 0) {
            let p = [];
            for (let d of l){
                let h = a.includes(d) ? false : e.state.options[o[d]];
                n && !h || r && h || p.push(s ? `set ${h ? "-o" : "+o"} ${d}` : `${d}		${h ? "on" : "off"}`);
            }
            return {
                exitCode: 0,
                stdout: p.length > 0 ? `${p.join(`
`)}
` : "",
                stderr: ""
            };
        }
        let c = false, u = "", f = [];
        for (let p of t){
            let d = p in o, m = a.includes(p);
            if (!d && !m) {
                u += `shopt: ${p}: invalid option name
`, c = true;
                continue;
            }
            if (m) {
                n || r || (i ? c = true : s ? (f.push(`set +o ${p}`), c = true) : (f.push(`${p}		off`), c = true));
                continue;
            }
            let h = o[p];
            if (n) h === "vi" ? e.state.options.emacs = false : h === "emacs" && (e.state.options.vi = false), e.state.options[h] = true, Jn(e);
            else if (r) e.state.options[h] = false, Jn(e);
            else {
                let g = e.state.options[h];
                i ? g || (c = true) : s ? (f.push(`set ${g ? "-o" : "+o"} ${p}`), g || (c = true)) : (f.push(`${p}		${g ? "on" : "off"}`), g || (c = true));
            }
        }
        return {
            exitCode: c ? 1 : 0,
            stdout: f.length > 0 ? `${f.join(`
`)}
` : "",
            stderr: u
        };
    }
    async function gy(e, t, n) {
        if (t.includes("/")) {
            let o = e.fs.resolvePath(e.state.cwd, t);
            if (!await e.fs.exists(o)) return {
                error: "not_found",
                path: o
            };
            let a = o.split("/").pop() || t, l = e.commands.get(a);
            try {
                let c = await e.fs.stat(o);
                return c.isDirectory ? {
                    error: "permission_denied",
                    path: o
                } : l ? {
                    cmd: l,
                    path: o
                } : (c.mode & 73) !== 0 ? {
                    script: true,
                    path: o
                } : {
                    error: "permission_denied",
                    path: o
                };
            } catch  {
                return {
                    error: "not_found",
                    path: o
                };
            }
        }
        if (!n && e.state.hashTable) {
            let o = e.state.hashTable.get(t);
            if (o) if (await e.fs.exists(o)) {
                let a = e.commands.get(t);
                if (a) return {
                    cmd: a,
                    path: o
                };
                try {
                    let l = await e.fs.stat(o);
                    if (!l.isDirectory && (l.mode & 73) !== 0) return {
                        script: true,
                        path: o
                    };
                } catch  {}
            } else e.state.hashTable.delete(t);
        }
        let s = (n ?? e.state.env.PATH ?? "/usr/bin:/bin").split(":");
        for (let o of s){
            if (!o) continue;
            let l = `${o.startsWith("/") ? o : e.fs.resolvePath(e.state.cwd, o)}/${t}`;
            if (await e.fs.exists(l)) try {
                let c = await e.fs.stat(l);
                if (c.isDirectory) continue;
                let u = (c.mode & 73) !== 0, f = e.commands.get(t), p = o === "/bin" || o === "/usr/bin";
                if (f && p) return {
                    cmd: f,
                    path: l
                };
                if (u) {
                    if (f && !p) return {
                        script: true,
                        path: l
                    };
                    if (!f) return {
                        script: true,
                        path: l
                    };
                }
            } catch  {}
        }
        if (!await e.fs.exists("/usr/bin")) {
            let o = e.commands.get(t);
            if (o) return {
                cmd: o,
                path: `/usr/bin/${t}`
            };
        }
        return null;
    }
    async function Fi(e, t) {
        let n = [];
        if (t.includes("/")) {
            let i = e.fs.resolvePath(e.state.cwd, t);
            if (await e.fs.exists(i)) try {
                let o = await e.fs.stat(i);
                o.isDirectory || (o.mode & 73) !== 0 && n.push(t);
            } catch  {}
            return n;
        }
        let s = (e.state.env.PATH || "/usr/bin:/bin").split(":");
        for (let i of s){
            if (!i) continue;
            let a = `${i.startsWith("/") ? i : e.fs.resolvePath(e.state.cwd, i)}/${t}`;
            if (await e.fs.exists(a)) {
                try {
                    if ((await e.fs.stat(a)).isDirectory) continue;
                } catch  {
                    continue;
                }
                n.push(i.startsWith("/") ? a : `${i}/${t}`);
            }
        }
        return n;
    }
    wt();
    async function xy(e, t, n, r) {
        let s = false, i = false, o = false, a = false, l = false, c = [];
        for (let h of t)if (h.startsWith("-") && h.length > 1) for (let g of h.slice(1))g === "t" ? s = true : g === "p" ? i = true : g === "P" ? o = true : g === "a" ? a = true : g === "f" && (l = true);
        else c.push(h);
        let u = "", f = "", p = 0, d = false, m = false;
        for (let h of c){
            let g = false;
            if (o) {
                if (a) {
                    let A = await r(h);
                    if (A.length > 0) {
                        for (let I of A)u += `${I}
`;
                        d = true, g = true;
                    }
                } else {
                    let A = await n(h);
                    A && (u += `${A}
`, d = true, g = true);
                }
                g || (m = true);
                continue;
            }
            let b = !l && e.state.functions.has(h);
            if (a && b) {
                if (!i) if (s) u += `function
`;
                else {
                    let A = e.state.functions.get(h), I = A ? yy(h, A) : `${h} is a function
`;
                    u += I;
                }
                g = true;
            }
            let y = e.state.env[`BASH_ALIAS_${h}`];
            if (y !== void 0 && (a || !g) && (i || (s ? u += `alias
` : u += `${h} is aliased to \`${y}'
`), g = true, !a) || ll.has(h) && (a || !g) && (i || (s ? u += `keyword
` : u += `${h} is a shell keyword
`), g = true, !a)) continue;
            if (!a && b && !g) {
                if (!i) if (s) u += `function
`;
                else {
                    let A = e.state.functions.get(h), I = A ? yy(h, A) : `${h} is a function
`;
                    u += I;
                }
                g = true;
                continue;
            }
            if (!(jr.has(h) && (a || !g) && (i || (s ? u += `builtin
` : u += `${h} is a shell builtin
`), g = true, !a))) {
                if (a) {
                    let A = await r(h);
                    for (let I of A)i ? u += `${I}
` : s ? u += `file
` : u += `${h} is ${I}
`, d = true, g = true;
                } else if (!g) {
                    let A = await n(h);
                    A && (i ? u += `${A}
` : s ? u += `file
` : u += `${h} is ${A}
`, d = true, g = true);
                }
                if (!g && (m = true, !s && !i)) {
                    let A = true;
                    if (h.includes("/")) {
                        let I = e.fs.resolvePath(e.state.cwd, h);
                        await e.fs.exists(I) && (A = false);
                    }
                    A && (f += `bash: type: ${h}: not found
`);
                }
            }
        }
        return i ? p = m && !d ? 1 : 0 : p = m ? 1 : 0, W(u, f, p);
    }
    function yy(e, t) {
        let n;
        return t.body.type === "Group" ? n = t.body.body.map((s)=>qr(s)).join("; ") : n = qr(t.body), `${e} is a function
${e} () 
{ 
    ${n}
}
`;
    }
    function qr(e) {
        if (Array.isArray(e)) return e.map((t)=>qr(t)).join("; ");
        if (e.type === "Statement") {
            let t = [];
            for(let n = 0; n < e.pipelines.length; n++){
                let r = e.pipelines[n];
                t.push(wk(r)), e.operators[n] && t.push(e.operators[n]);
            }
            return t.join(" ");
        }
        if (e.type === "SimpleCommand") {
            let t = e, n = [];
            t.name && n.push(by(t.name));
            for (let r of t.args)n.push(by(r));
            return n.join(" ");
        }
        return e.type === "Group" ? `{ ${e.body.map((r)=>qr(r)).join("; ")}; }` : "...";
    }
    function wk(e) {
        let t = e.commands.map((n)=>qr(n));
        return (e.negated ? "! " : "") + t.join(" | ");
    }
    function by(e) {
        let t = "";
        for (let n of e.parts)n.type === "Literal" ? t += n.value : n.type === "DoubleQuoted" ? t += `"${n.parts.map((r)=>wy(r)).join("")}"` : n.type === "SingleQuoted" ? t += `'${n.value}'` : t += wy(n);
        return t;
    }
    function wy(e) {
        let t = e;
        return t.type === "Literal" ? t.value ?? "" : t.type === "Variable" ? `$${t.name}` : "";
    }
    async function Ey(e, t, n, r) {
        let s = "", i = "", o = 0;
        for (let a of t){
            if (!a) {
                o = 1;
                continue;
            }
            let l = e.state.env[`BASH_ALIAS_${a}`];
            if (l !== void 0) r ? s += `${a} is an alias for "${l}"
` : s += `alias ${a}='${l}'
`;
            else if (ll.has(a)) r ? s += `${a} is a shell keyword
` : s += `${a}
`;
            else if (jr.has(a)) r ? s += `${a} is a shell builtin
` : s += `${a}
`;
            else if (e.state.functions.has(a)) r ? s += `${a} is a function
` : s += `${a}
`;
            else if (a.includes("/")) {
                let c = e.fs.resolvePath(e.state.cwd, a), u = false;
                if (await e.fs.exists(c)) try {
                    let f = await e.fs.stat(c);
                    f.isDirectory || (f.mode & 73) !== 0 && (r ? s += `${a} is ${a}
` : s += `${a}
`, u = true);
                } catch  {}
                u || (r && (i += `${a}: not found
`), o = 1);
            } else if (e.commands.has(a)) {
                let u = (e.state.env.PATH ?? "/usr/bin:/bin").split(":"), f = null;
                for (let p of u){
                    if (!p) continue;
                    let d = `${p}/${a}`;
                    try {
                        let m = await e.fs.stat(d);
                        if (!m.isDirectory && (m.mode & 73) !== 0) {
                            f = d;
                            break;
                        }
                    } catch  {}
                }
                f || (f = `/usr/bin/${a}`), r ? s += `${a} is ${f}
` : s += `${f}
`;
            } else r && (i += `${a}: not found
`), o = 1;
        }
        return W(s, i, o);
    }
    async function Sy(e, t) {
        if (t.includes("/")) {
            let s = e.fs.resolvePath(e.state.cwd, t);
            if (await e.fs.exists(s)) {
                try {
                    let i = await e.fs.stat(s);
                    if (i.isDirectory || !((i.mode & 73) !== 0)) return null;
                } catch  {
                    return null;
                }
                return t;
            }
            return null;
        }
        let r = (e.state.env.PATH ?? "/usr/bin:/bin").split(":");
        for (let s of r){
            if (!s) continue;
            let o = `${s.startsWith("/") ? s : e.fs.resolvePath(e.state.cwd, s)}/${t}`;
            if (await e.fs.exists(o)) {
                try {
                    if ((await e.fs.stat(o)).isDirectory) continue;
                } catch  {
                    continue;
                }
                return `${s}/${t}`;
            }
        }
        if (e.commands.has(t)) {
            for (let s of r)if (s === "/usr/bin" || s === "/bin") return `${s}/${t}`;
            return `/usr/bin/${t}`;
        }
        return null;
    }
    async function Ay(e, t, n, r, s, i, o, a) {
        let { ctx: l, runCommand: c } = e;
        if (t === "export") return Rl(l, n);
        if (t === "unset") return jl(l, n);
        if (t === "exit") return Il(l, n);
        if (t === "local") return Dl(l, n);
        if (t === "set") return Wl(l, n);
        if (t === "break") return nl(l, n);
        if (t === "continue") return ml(l, n);
        if (t === "return") return Ll(l, n);
        if (t === "eval" && l.state.options.posix) return Pi(l, n, s);
        if (t === "shift") return Bl(l, n);
        if (t === "getopts") return Ti(l, n);
        if (t === "compgen") return fl(l, n);
        if (t === "complete") return dl(l, n);
        if (t === "compopt") return hl(l, n);
        if (t === "pushd") return await kl(l, n);
        if (t === "popd") return vl(l, n);
        if (t === "dirs") return $l(l, n);
        if (t === "source" || t === ".") return Ul(l, n);
        if (t === "read") return _l(l, n, s, a);
        if (t === "mapfile" || t === "readarray") return Fl(l, n, s);
        if (t === "declare" || t === "typeset") return Al(l, n);
        if (t === "readonly") return Cl(l, n);
        if (!i) {
            let u = l.state.functions.get(t);
            if (u) return Ii(l, u, n, s);
        }
        if (t === "eval") return Pi(l, n, s);
        if (t === "cd") return await rl(l, n);
        if (t === ":" || t === "true") return le;
        if (t === "false") return Le(false);
        if (t === "let") return Ol(l, n);
        if (t === "command") return xk(e, n, s);
        if (t === "builtin") return Ek(e, n, s);
        if (t === "shopt") return my(l, n);
        if (t === "exec") {
            if (n.length === 0) return le;
            let [u, ...f] = n;
            return c(u, f, [], s, false, false, -1);
        }
        if (t === "wait") return le;
        if (t === "type") return await xy(l, n, (u)=>Sy(l, u), (u)=>Fi(l, u));
        if (t === "hash") return Pl(l, n);
        if (t === "help") return Tl(l, n);
        if (t === "[" || t === "test") {
            let u = n;
            if (t === "[") {
                if (n[n.length - 1] !== "]") return M("[: missing `]'\n", 2);
                u = n.slice(0, -1);
            }
            return zr(l, u);
        }
        return null;
    }
    async function xk(e, t, n) {
        let { ctx: r, runCommand: s } = e;
        if (t.length === 0) return le;
        let i = false, o = false, a = false, l = t;
        for(; l.length > 0 && l[0].startsWith("-");){
            let f = l[0];
            if (f === "--") {
                l = l.slice(1);
                break;
            }
            for (let p of f.slice(1))p === "p" ? i = true : p === "V" ? o = true : p === "v" && (a = true);
            l = l.slice(1);
        }
        if (l.length === 0) return le;
        if (a || o) return await Ey(r, l, a, o);
        let [c, ...u] = l;
        return s(c, u, [], n, true, i, -1);
    }
    async function Ek(e, t, n) {
        let { runCommand: r } = e;
        if (t.length === 0) return le;
        let s = t;
        if (s[0] === "--" && (s = s.slice(1), s.length === 0)) return le;
        let i = s[0];
        if (!jr.has(i)) return M(`bash: builtin: ${i}: not a shell builtin
`);
        let [, ...o] = s;
        return r(i, o, [], n, true, false, -1);
    }
    async function Cy(e, t, n, r, s) {
        let { ctx: i, buildExportedEnv: o, executeUserScript: a } = e, c = await gy(i, t, s ? "/usr/bin:/bin" : void 0);
        if (!c) return T0(t) ? M(`bash: ${t}: command not available in browser environments. Exclude '${t}' from your commands or use the Node.js bundle.
`, 127) : M(`bash: ${t}: command not found
`, 127);
        if ("error" in c) return c.error === "permission_denied" ? M(`bash: ${t}: Permission denied
`, 126) : M(`bash: ${t}: No such file or directory
`, 127);
        if ("script" in c) return t.includes("/") || (i.state.hashTable || (i.state.hashTable = new Map()), i.state.hashTable.set(t, c.path)), await a(c.path, n, r);
        let { cmd: u, path: f } = c;
        t.includes("/") || (i.state.hashTable || (i.state.hashTable = new Map()), i.state.hashTable.set(t, f));
        let p = r || i.state.groupStdin || "", d = o(), m = {
            fs: i.fs,
            cwd: i.state.cwd,
            env: i.state.env,
            exportedEnv: d,
            stdin: p,
            limits: i.limits,
            exec: i.execFn,
            fetch: i.fetch,
            getRegisteredCommands: ()=>Array.from(i.commands.keys()),
            sleep: i.sleep,
            trace: i.trace,
            fileDescriptors: i.state.fileDescriptors,
            xpgEcho: i.state.shoptOptions.xpg_echo
        };
        try {
            return await u.execute(n, m);
        } catch (h) {
            return M(`${t}: ${Ne(h)}
`);
        }
    }
    it();
    de();
    ot();
    async function Vl(e, t) {
        let n = e.state.inCondition;
        e.state.inCondition = true;
        let r = "", s = "", i = 0;
        try {
            for (let o of t){
                let a = await e.executeStatement(o);
                r += a.stdout, s += a.stderr, i = a.exitCode;
            }
        } finally{
            e.state.inCondition = n;
        }
        return {
            stdout: r,
            stderr: s,
            exitCode: i
        };
    }
    de();
    wt();
    function Gr(e, t, n, r) {
        if (e instanceof Qe) return t += e.stdout, n += e.stderr, e.levels > 1 && r > 1 ? (e.levels--, e.stdout = t, e.stderr = n, {
            action: "rethrow",
            stdout: t,
            stderr: n,
            error: e
        }) : {
            action: "break",
            stdout: t,
            stderr: n
        };
        if (e instanceof Ke) return t += e.stdout, n += e.stderr, e.levels > 1 && r > 1 ? (e.levels--, e.stdout = t, e.stderr = n, {
            action: "rethrow",
            stdout: t,
            stderr: n,
            error: e
        }) : {
            action: "continue",
            stdout: t,
            stderr: n
        };
        if (e instanceof Ve || e instanceof lt || e instanceof ae || e instanceof ne) return e.prependOutput(t, n), {
            action: "rethrow",
            stdout: t,
            stderr: n,
            error: e
        };
        let s = Ne(e);
        return {
            action: "error",
            stdout: t,
            stderr: `${n}${s}
`,
            exitCode: 1
        };
    }
    de();
    wt();
    async function _i(e, t, n = "", r = "") {
        let s = n, i = r, o = 0;
        try {
            for (let a of t){
                let l = await e.executeStatement(a);
                s += l.stdout, i += l.stderr, o = l.exitCode;
            }
        } catch (a) {
            if (ls(a) || a instanceof lt || a instanceof ae || a instanceof ne || a instanceof Lt) throw a.prependOutput(s, i), a;
            return {
                stdout: s,
                stderr: `${i}${Ne(a)}
`,
                exitCode: 1
            };
        }
        return {
            stdout: s,
            stderr: i,
            exitCode: o
        };
    }
    async function Ny(e, t) {
        let n = "", r = "";
        for (let s of t.clauses){
            let i = await Vl(e, s.condition);
            if (n += i.stdout, r += i.stderr, i.exitCode === 0) return _i(e, s.body, n, r);
        }
        return t.elseBody ? _i(e, t.elseBody, n, r) : W(n, r, 0);
    }
    async function ky(e, t) {
        let n = await qt(e, t.redirections);
        if (n) return n;
        let r = "", s = "", i = 0, o = 0;
        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t.variable)) return M(`bash: \`${t.variable}': not a valid identifier
`);
        let a = [];
        if (t.words === null) a = (e.state.env["@"] || "").split(" ").filter(Boolean);
        else if (t.words.length === 0) a = [];
        else try {
            for (let c of t.words){
                let u = await Ft(e, c);
                a.push(...u.values);
            }
        } catch (c) {
            if (c instanceof _t) return {
                stdout: "",
                stderr: c.stderr,
                exitCode: 1
            };
            throw c;
        }
        e.state.loopDepth++;
        try {
            for (let c of a){
                o++, o > e.limits.maxLoopIterations && Xt(`for loop: too many iterations (${e.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", r, s), e.state.env[t.variable] = c;
                try {
                    for (let u of t.body){
                        let f = await e.executeStatement(u);
                        r += f.stdout, s += f.stderr, i = f.exitCode;
                    }
                } catch (u) {
                    let f = Gr(u, r, s, e.state.loopDepth);
                    if (r = f.stdout, s = f.stderr, f.action === "break") break;
                    if (f.action === "continue") continue;
                    if (f.action === "error") {
                        let p = W(r, s, f.exitCode ?? 1);
                        return $e(e, p, t.redirections);
                    }
                    throw f.error;
                }
            }
        } finally{
            e.state.loopDepth--;
        }
        let l = W(r, s, i);
        return $e(e, l, t.redirections);
    }
    async function vy(e, t) {
        let n = await qt(e, t.redirections);
        if (n) return n;
        let r = t.line;
        r !== void 0 && (e.state.currentLine = r);
        let s = "", i = "", o = 0, a = 0;
        t.init && await Q(e, t.init.expression), e.state.loopDepth++;
        try {
            for(; a++, a > e.limits.maxLoopIterations && Xt(`for loop: too many iterations (${e.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", s, i), !(t.condition && (r !== void 0 && (e.state.currentLine = r), await Q(e, t.condition.expression) === 0));){
                try {
                    for (let c of t.body){
                        let u = await e.executeStatement(c);
                        s += u.stdout, i += u.stderr, o = u.exitCode;
                    }
                } catch (c) {
                    let u = Gr(c, s, i, e.state.loopDepth);
                    if (s = u.stdout, i = u.stderr, u.action === "break") break;
                    if (u.action === "continue") {
                        t.update && await Q(e, t.update.expression);
                        continue;
                    }
                    if (u.action === "error") {
                        let f = W(s, i, u.exitCode ?? 1);
                        return $e(e, f, t.redirections);
                    }
                    throw u.error;
                }
                t.update && await Q(e, t.update.expression);
            }
        } finally{
            e.state.loopDepth--;
        }
        let l = W(s, i, o);
        return $e(e, l, t.redirections);
    }
    async function $y(e, t, n = "") {
        let r = "", s = "", i = 0, o = 0, a = n;
        for (let c of t.redirections)if ((c.operator === "<<" || c.operator === "<<-") && c.target.type === "HereDoc") {
            let u = c.target, f = await J(e, u.content);
            u.stripTabs && (f = f.split(`
`).map((p)=>p.replace(/^\t+/, "")).join(`
`)), a = f;
        } else if (c.operator === "<<<" && c.target.type === "Word") a = `${await J(e, c.target)}
`;
        else if (c.operator === "<" && c.target.type === "Word") try {
            let u = await J(e, c.target), f = e.fs.resolvePath(e.state.cwd, u);
            a = await e.fs.readFile(f);
        } catch  {
            let u = await J(e, c.target);
            return M(`bash: ${u}: No such file or directory
`);
        }
        let l = e.state.groupStdin;
        a && (e.state.groupStdin = a), e.state.loopDepth++;
        try {
            for(;;){
                o++, o > e.limits.maxLoopIterations && Xt(`while loop: too many iterations (${e.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", r, s);
                let c = 0, u = false, f = false, p = e.state.inCondition;
                e.state.inCondition = true;
                try {
                    for (let d of t.condition){
                        let m = await e.executeStatement(d);
                        r += m.stdout, s += m.stderr, c = m.exitCode;
                    }
                } catch (d) {
                    if (d instanceof Qe) {
                        if (r += d.stdout, s += d.stderr, d.levels > 1 && e.state.loopDepth > 1) throw d.levels--, d.stdout = r, d.stderr = s, e.state.inCondition = p, d;
                        u = true;
                    } else if (d instanceof Ke) {
                        if (r += d.stdout, s += d.stderr, d.levels > 1 && e.state.loopDepth > 1) throw d.levels--, d.stdout = r, d.stderr = s, e.state.inCondition = p, d;
                        f = true;
                    } else throw e.state.inCondition = p, d;
                } finally{
                    e.state.inCondition = p;
                }
                if (u) break;
                if (!f) {
                    if (c !== 0) break;
                    try {
                        for (let d of t.body){
                            let m = await e.executeStatement(d);
                            r += m.stdout, s += m.stderr, i = m.exitCode;
                        }
                    } catch (d) {
                        let m = Gr(d, r, s, e.state.loopDepth);
                        if (r = m.stdout, s = m.stderr, m.action === "break") break;
                        if (m.action === "continue") continue;
                        if (m.action === "error") return W(r, s, m.exitCode ?? 1);
                        throw m.error;
                    }
                }
            }
        } finally{
            e.state.loopDepth--, e.state.groupStdin = l;
        }
        return W(r, s, i);
    }
    async function Iy(e, t) {
        let n = "", r = "", s = 0, i = 0;
        e.state.loopDepth++;
        try {
            for(;;){
                i++, i > e.limits.maxLoopIterations && Xt(`until loop: too many iterations (${e.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", n, r);
                let o = await Vl(e, t.condition);
                if (n += o.stdout, r += o.stderr, o.exitCode === 0) break;
                try {
                    for (let a of t.body){
                        let l = await e.executeStatement(a);
                        n += l.stdout, r += l.stderr, s = l.exitCode;
                    }
                } catch (a) {
                    let l = Gr(a, n, r, e.state.loopDepth);
                    if (n = l.stdout, r = l.stderr, l.action === "break") break;
                    if (l.action === "continue") continue;
                    if (l.action === "error") return W(n, r, l.exitCode ?? 1);
                    throw l.error;
                }
            }
        } finally{
            e.state.loopDepth--;
        }
        return W(n, r, s);
    }
    async function Ry(e, t) {
        let n = await qt(e, t.redirections);
        if (n) return n;
        let r = "", s = "", i = 0, o = await J(e, t.word), a = false;
        for(let c = 0; c < t.items.length; c++){
            let u = t.items[c], f = a;
            if (!a) for (let p of u.patterns){
                let d = await J(e, p);
                Qa(p) && (d = mt(d));
                let m = e.state.shoptOptions.nocasematch, h = e.state.shoptOptions.extglob;
                if (or(o, d, m, h)) {
                    f = true;
                    break;
                }
            }
            if (f) {
                let p = await _i(e, u.body, r, s);
                if (r = p.stdout, s = p.stderr, i = p.exitCode, u.terminator === ";;") break;
                u.terminator === ";&" ? a = true : a = false;
            } else a = false;
        }
        let l = W(r, s, i);
        return $e(e, l, t.redirections);
    }
    de();
    ot();
    function ql(e, t) {
        if (e.parts.length !== 1) return false;
        let n = e.parts[0];
        return n.type !== "Literal" ? false : t.includes(n.value);
    }
    function Py(e) {
        if (!e.startsWith("__rw__:")) return null;
        let t = e.slice(7), n = t.indexOf(":");
        if (n === -1) return null;
        let r = Number.parseInt(t.slice(0, n), 10);
        if (Number.isNaN(r) || r < 0) return null;
        let s = n + 1, i = t.slice(s, s + r), o = s + r + 1, a = t.slice(o), l = a.indexOf(":");
        if (l === -1) return null;
        let c = Number.parseInt(a.slice(0, l), 10);
        if (Number.isNaN(c) || c < 0) return null;
        let u = a.slice(l + 1);
        return {
            path: i,
            position: c,
            content: u
        };
    }
    Fe();
    ot();
    var Ty = "+ ";
    async function Oy(e) {
        let t = e.state.env.PS4;
        if (t === void 0) return Ty;
        if (t === "") return "";
        try {
            let r = new se().parseWordFromString(t, false, false);
            return await J(e, r);
        } catch  {
            return e.state.expansionStderr = `${e.state.expansionStderr || ""}bash: ${t}: bad substitution
`, t || Ty;
        }
    }
    function Sk(e) {
        return e.map((t)=>Ak(t)).join(" ");
    }
    function Ak(e) {
        if (e === "") return "''";
        if (!/[\s'"\\$`!*?[\]{}|&;<>()~#\n\t]/.test(e)) return e;
        let n = /[\x00-\x1f\x7f]/.test(e), r = e.includes(`
`), s = e.includes("	"), i = e.includes("\\"), o = e.includes("'");
        if (n || r || s || i) {
            let l = "";
            for (let c of e){
                let u = c.charCodeAt(0);
                c === `
` ? l += "\\n" : c === "	" ? l += "\\t" : c === "\\" ? l += "\\\\" : c === "'" ? l += "'" : c === '"' ? l += '"' : u < 32 || u === 127 ? u < 256 ? l += `\\x${u.toString(16).padStart(2, "0")}` : l += `\\u${u.toString(16).padStart(4, "0")}` : l += c;
            }
            return `$'${l}'`;
        }
        return o ? `"${e.replace(/([\\$`"])/g, "\\$1")}"` : `'${e}'`;
    }
    async function Dy(e, t, n) {
        if (!e.state.options.xtrace) return "";
        let r = await Oy(e), s = [
            t,
            ...n
        ], i = Sk(s);
        return `${r}${i}
`;
    }
    async function Fy(e, t, n) {
        return e.state.options.xtrace ? `${await Oy(e)}${t}=${n}
` : "";
    }
    de();
    async function _y(e, t, n) {
        let r = t.timed ? performance.now() : 0, s = "", i = le, o = 0, a = [], l = t.commands.length > 1, c = e.state.lastArg;
        for(let f = 0; f < t.commands.length; f++){
            let p = t.commands[f], d = f === t.commands.length - 1;
            l && (e.state.lastArg = "");
            let h = l && (!d || !e.state.shoptOptions.lastpipe) ? {
                ...e.state.env
            } : null, g;
            try {
                g = await n(p, s);
            } catch (b) {
                if (b instanceof nt) g = {
                    stdout: b.stdout,
                    stderr: b.stderr,
                    exitCode: 1
                };
                else if (b instanceof ae && t.commands.length > 1) g = {
                    stdout: b.stdout,
                    stderr: b.stderr,
                    exitCode: b.exitCode
                };
                else if (b instanceof lt && t.commands.length > 1) g = {
                    stdout: b.stdout,
                    stderr: b.stderr,
                    exitCode: b.exitCode
                };
                else throw h && (e.state.env = h), b;
            }
            h && (e.state.env = h), a.push(g.exitCode), g.exitCode !== 0 && (o = g.exitCode), d ? i = g : t.pipeStderr?.[f] ?? false ? (s = g.stderr + g.stdout, i = {
                stdout: "",
                stderr: "",
                exitCode: g.exitCode
            }) : (s = g.stdout, i = {
                stdout: "",
                stderr: g.stderr,
                exitCode: g.exitCode
            });
        }
        if (t.commands.length > 1 || t.commands.length === 1 && t.commands[0].type === "SimpleCommand") {
            for (let f of Object.keys(e.state.env))f.startsWith("PIPESTATUS_") && delete e.state.env[f];
            for(let f = 0; f < a.length; f++)e.state.env[`PIPESTATUS_${f}`] = String(a[f]);
            e.state.env.PIPESTATUS__length = String(a.length);
        }
        if (e.state.options.pipefail && o !== 0 && (i = {
            ...i,
            exitCode: o
        }), t.negated && (i = {
            ...i,
            exitCode: i.exitCode === 0 ? 1 : 0
        }), t.timed) {
            let p = (performance.now() - r) / 1e3, d = Math.floor(p / 60), m = p % 60, h;
            t.timePosix ? h = `real ${p.toFixed(2)}
user 0.00
sys 0.00
` : h = `
real	${`${d}m${m.toFixed(3)}s`}
user	0m0.000s
sys	0m0.000s
`, i = {
                ...i,
                stderr: i.stderr + h
            };
        }
        return l && !e.state.shoptOptions.lastpipe && (e.state.lastArg = c), i;
    }
    Je();
    Fe();
    it();
    de();
    ot();
    $t();
    Tt();
    on$1();
    async function Ly(e, t) {
        let n = {}, r = "";
        for (let s of t.assignments){
            let i = s.name;
            if (s.array) {
                let u = await Ck(e, t, i, s.array, s.append, n);
                if (u.error) return {
                    continueToNext: false,
                    xtraceOutput: r,
                    tempAssignments: n,
                    error: u.error
                };
                if (r += u.xtraceOutput, u.continueToNext) continue;
            }
            let o = s.value ? await J(e, s.value) : "";
            if (i.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[\]$/)) return {
                continueToNext: false,
                xtraceOutput: r,
                tempAssignments: n,
                error: W("", `bash: ${i}: bad array subscript
`, 1)
            };
            let l = i.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
            if (l) {
                let u = await Ik(e, t, l[1], l[2], o, s.append, n);
                if (u.error) return {
                    continueToNext: false,
                    xtraceOutput: r,
                    tempAssignments: n,
                    error: u.error
                };
                if (u.continueToNext) continue;
            }
            let c = await Pk(e, t, i, o, s.append, n);
            if (c.error) return {
                continueToNext: false,
                xtraceOutput: r,
                tempAssignments: n,
                error: c.error
            };
            r += c.xtraceOutput, c.continueToNext;
        }
        return {
            continueToNext: false,
            xtraceOutput: r,
            tempAssignments: n
        };
    }
    async function Ck(e, t, n, r, s, i) {
        let o = "";
        if (/\[.+\]$/.test(n)) return {
            continueToNext: false,
            xtraceOutput: "",
            error: W("", `bash: ${n}: cannot assign list to array member
`, 1)
        };
        if (Se(e, n)) {
            let u = kn(e, n);
            if (u === void 0 || u === "") throw new ae(1, "", "");
            let f = st(e, n);
            if (f && /^[a-zA-Z_][a-zA-Z0-9_]*\[@\]$/.test(f)) return {
                continueToNext: false,
                xtraceOutput: "",
                error: W("", `bash: ${n}: cannot assign list to array member
`, 1)
            };
        }
        if (Ht(e, n)) {
            if (t.name) return o += `bash: ${n}: readonly variable
`, {
                continueToNext: true,
                xtraceOutput: o
            };
            je(e, n);
        }
        let a = e.state.associativeArrays?.has(n), l = Nk(r), c = ()=>{
            let u = `${n}_`;
            for (let f of Object.keys(e.state.env))f.startsWith(u) && !f.includes("__") && delete e.state.env[f];
            delete e.state.env[n];
        };
        if (a && l ? await kk(e, t, n, r, s, c, (u)=>{
            o += u;
        }) : l ? await vk(e, n, r, s, c) : await $k(e, n, r, s, c), t.name) {
            i[n] = e.state.env[n];
            let f = `(${r.map((p)=>Yn(p)).join(" ")})`;
            e.state.env[n] = f;
        }
        return {
            continueToNext: true,
            xtraceOutput: o
        };
    }
    function Nk(e) {
        return e.some((t)=>{
            if (t.parts.length >= 2) {
                let n = t.parts[0], r = t.parts[1];
                if (n.type !== "Glob" || !n.pattern.startsWith("[")) return false;
                if (n.pattern === "[" && (r.type === "DoubleQuoted" || r.type === "SingleQuoted")) {
                    if (t.parts.length < 3) return false;
                    let s = t.parts[2];
                    return s.type !== "Literal" ? false : s.value.startsWith("]=") || s.value.startsWith("]+=");
                }
                return r.type !== "Literal" ? false : r.value.startsWith("]") ? r.value.startsWith("]=") || r.value.startsWith("]+=") : n.pattern.endsWith("]") ? r.value.startsWith("=") || r.value.startsWith("+=") : false;
            }
            return false;
        });
    }
    async function kk(e, t, n, r, s, i, o) {
        let a = [];
        for (let l of r){
            let c = Ma(l);
            if (c) {
                let { key: u, valueParts: f, append: p } = c, d;
                f.length > 0 ? d = await J(e, {
                    parts: f
                }) : d = "", d = Te(e, d), a.push({
                    type: "keyed",
                    key: u,
                    value: d,
                    append: p
                });
            } else {
                let u = await J(e, l);
                a.push({
                    type: "invalid",
                    expandedValue: u
                });
            }
        }
        s || i();
        for (let l of a)if (l.type === "keyed") if (l.append) {
            let c = e.state.env[`${n}_${l.key}`] ?? "";
            e.state.env[`${n}_${l.key}`] = c + l.value;
        } else e.state.env[`${n}_${l.key}`] = l.value;
        else {
            let c = t.line ?? e.state.currentLine ?? 1;
            o(`bash: line ${c}: ${n}: ${l.expandedValue}: must use subscript when assigning associative array
`);
        }
    }
    async function vk(e, t, n, r, s) {
        let i = [];
        for (let a of n){
            let l = Ma(a);
            if (l) {
                let { key: c, valueParts: u, append: f } = l, p;
                u.length > 0 ? p = await J(e, {
                    parts: u
                }) : p = "", p = Te(e, p), i.push({
                    type: "keyed",
                    indexExpr: c,
                    value: p,
                    append: f
                });
            } else {
                let c = await Ft(e, a);
                i.push({
                    type: "non-keyed",
                    values: c.values
                });
            }
        }
        r || s();
        let o = 0;
        for (let a of i)if (a.type === "keyed") {
            let l;
            try {
                let c = new se(), u = he(c, a.indexExpr);
                l = await Q(e, u.expression, false);
            } catch  {
                if (/^-?\d+$/.test(a.indexExpr)) l = Number.parseInt(a.indexExpr, 10);
                else {
                    let c = e.state.env[a.indexExpr];
                    l = c ? Number.parseInt(c, 10) : 0, Number.isNaN(l) && (l = 0);
                }
            }
            if (a.append) {
                let c = e.state.env[`${t}_${l}`] ?? "";
                e.state.env[`${t}_${l}`] = c + a.value;
            } else e.state.env[`${t}_${l}`] = a.value;
            o = l + 1;
        } else for (let l of a.values)e.state.env[`${t}_${o++}`] = l;
    }
    async function $k(e, t, n, r, s) {
        let i = [];
        for (let a of n){
            let l = await Ft(e, a);
            i.push(...l.values);
        }
        let o = 0;
        if (r) {
            let a = te(e, t);
            if (a.length > 0) o = Math.max(...a.map(([c])=>typeof c == "number" ? c : 0)) + 1;
            else if (e.state.env[t] !== void 0) {
                let l = e.state.env[t];
                e.state.env[`${t}_0`] = l, delete e.state.env[t], o = 1;
            }
        } else s();
        for(let a = 0; a < i.length; a++)e.state.env[`${t}_${o + a}`] = i[a];
        r || (e.state.env[`${t}__length`] = String(i.length));
    }
    async function Ik(e, t, n, r, s, i, o) {
        let a = n;
        if (Se(e, n)) {
            let f = st(e, n);
            if (f && f !== n) {
                if (f.includes("[")) return {
                    continueToNext: false,
                    xtraceOutput: "",
                    error: W("", `bash: \`${f}': not a valid identifier
`, 1)
                };
                a = f;
            }
        }
        if (Ht(e, a)) {
            if (t.name) return {
                continueToNext: true,
                xtraceOutput: ""
            };
            je(e, a);
        }
        let l = e.state.associativeArrays?.has(a), c;
        if (l) c = await My(e, a, r);
        else {
            let f = await Rk(e, a, r);
            if (f.error) return {
                continueToNext: false,
                xtraceOutput: "",
                error: f.error
            };
            c = `${a}_${f.index}`;
        }
        let u = i ? (e.state.env[c] || "") + s : s;
        if (t.name) o[c] = e.state.env[c], e.state.env[c] = u;
        else {
            let f = ar(e, a);
            if (f !== void 0 && f === e.state.callDepth && e.state.localScopes.length > 0) {
                let p = e.state.localScopes[e.state.localScopes.length - 1];
                p.has(c) || p.set(c, e.state.env[c]);
            }
            e.state.env[c] = u;
        }
        return {
            continueToNext: true,
            xtraceOutput: ""
        };
    }
    async function My(e, t, n) {
        let r;
        if (n.startsWith("'") && n.endsWith("'")) r = n.slice(1, -1);
        else if (n.startsWith('"') && n.endsWith('"')) {
            let s = n.slice(1, -1), o = new se().parseWordFromString(s, true, false);
            r = await J(e, o);
        } else if (n.includes("$")) {
            let i = new se().parseWordFromString(n, false, false);
            r = await J(e, i);
        } else r = n;
        return `${t}_${r}`;
    }
    async function Rk(e, t, n) {
        let r = n;
        n.startsWith('"') && n.endsWith('"') && n.length >= 2 && (r = n.slice(1, -1));
        let s;
        if (/^-?\d+$/.test(r)) s = Number.parseInt(r, 10);
        else {
            try {
                let i = new se(), o = he(i, r);
                s = await Q(e, o.expression, false);
            } catch (i) {
                if (i instanceof Ee) {
                    let l = `bash: line ${e.state.currentLine}: ${n}: ${i.message}
`;
                    if (i.fatal) throw new ae(1, "", l);
                    return {
                        index: 0,
                        error: W("", l, 1)
                    };
                }
                let o = e.state.env[n];
                s = o ? Number.parseInt(o, 10) : 0;
            }
            Number.isNaN(s) && (s = 0);
        }
        if (s < 0) {
            let i = te(e, t);
            if (i.length === 0) {
                let a = e.state.currentLine;
                return {
                    index: 0,
                    error: W("", `bash: line ${a}: ${t}[${n}]: bad array subscript
`, 1)
                };
            }
            if (s = Math.max(...i.map(([a])=>typeof a == "number" ? a : 0)) + 1 + s, s < 0) {
                let a = e.state.currentLine;
                return {
                    index: 0,
                    error: W("", `bash: line ${a}: ${t}[${n}]: bad array subscript
`, 1)
                };
            }
        }
        return {
            index: s
        };
    }
    async function Pk(e, t, n, r, s, i) {
        let o = "", a = n, l = null;
        if (Se(e, n)) {
            let f = cg(e, n, r);
            if (f === void 0) return {
                continueToNext: false,
                xtraceOutput: "",
                error: W("", `bash: ${n}: circular name reference
`, 1)
            };
            if (f === null) return {
                continueToNext: true,
                xtraceOutput: ""
            };
            a = f;
            let p = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
            p && (l = {
                arrayName: p[1],
                subscriptExpr: p[2]
            }, a = p[1]);
        }
        if (Ht(e, a)) {
            if (t.name) return o += `bash: ${a}: readonly variable
`, {
                continueToNext: true,
                xtraceOutput: o
            };
            je(e, a);
        }
        let c;
        if (Hr(e, a)) try {
            let f = new se();
            if (s) {
                let d = `(${e.state.env[a] || "0"}) + (${r})`, m = he(f, d);
                c = String(await Q(e, m.expression));
            } else {
                let p = he(f, r);
                c = String(await Q(e, p.expression));
            }
        } catch  {
            c = "0";
        }
        else {
            let { isArray: f } = await Promise.resolve().then(()=>(ot(), Ya)), p = f(e, a) ? `${a}_0` : a;
            c = s ? (e.state.env[p] || "") + r : r;
        }
        c = cr(e, a, c), o += await Fy(e, a, c);
        let u = a;
        if (l) u = await Tk(e, l);
        else {
            let { isArray: f } = await Promise.resolve().then(()=>(ot(), Ya));
            f(e, a) && (u = `${a}_0`);
        }
        return t.name ? (i[u] = e.state.env[u], e.state.env[u] = c) : (e.state.env[u] = c, e.state.options.allexport && (e.state.exportedVars = e.state.exportedVars || new Set(), e.state.exportedVars.add(a)), e.state.tempEnvBindings?.some((f)=>f.has(a)) && (e.state.mutatedTempEnvVars = e.state.mutatedTempEnvVars || new Set(), e.state.mutatedTempEnvVars.add(a))), {
            continueToNext: false,
            xtraceOutput: o
        };
    }
    async function Tk(e, t) {
        let { arrayName: n, subscriptExpr: r } = t;
        if (e.state.associativeArrays?.has(n)) return My(e, n, r);
        let i;
        if (/^-?\d+$/.test(r)) i = Number.parseInt(r, 10);
        else {
            try {
                let o = new se(), a = he(o, r);
                i = await Q(e, a.expression, false);
            } catch  {
                let o = e.state.env[r];
                i = o ? Number.parseInt(o, 10) : 0;
            }
            Number.isNaN(i) && (i = 0);
        }
        if (i < 0) {
            let o = te(e, n);
            o.length > 0 && (i = Math.max(...o.map((l)=>l[0])) + 1 + i);
        }
        return `${n}_${i}`;
    }
    Fe();
    de();
    ot();
    wt();
    async function Wy(e, t, n, r) {
        let s = await qt(e, t.redirections);
        if (s) return s;
        let i = {
            ...e.state.env
        }, o = e.state.cwd, a = {
            ...e.state.options
        }, l = e.state.localScopes, c = e.state.localVarStack, u = e.state.localVarDepth, f = e.state.fullyUnsetLocals;
        if (e.state.localScopes = l.map((A)=>new Map(A)), c) {
            e.state.localVarStack = new Map();
            for (let [A, I] of c.entries())e.state.localVarStack.set(A, I.map((O)=>({
                    ...O
                })));
        }
        u && (e.state.localVarDepth = new Map(u)), f && (e.state.fullyUnsetLocals = new Map(f));
        let p = e.state.loopDepth, d = e.state.parentHasLoopContext;
        e.state.parentHasLoopContext = p > 0, e.state.loopDepth = 0;
        let m = e.state.lastArg, h = e.state.bashPid;
        e.state.bashPid = e.state.nextVirtualPid++;
        let g = e.state.groupStdin;
        n && (e.state.groupStdin = n);
        let b = "", y = "", w = 0, E = ()=>{
            e.state.env = i, e.state.cwd = o, e.state.options = a, e.state.localScopes = l, e.state.localVarStack = c, e.state.localVarDepth = u, e.state.fullyUnsetLocals = f, e.state.loopDepth = p, e.state.parentHasLoopContext = d, e.state.groupStdin = g, e.state.bashPid = h, e.state.lastArg = m;
        };
        try {
            for (let A of t.body){
                let I = await r(A);
                b += I.stdout, y += I.stderr, w = I.exitCode;
            }
        } catch (A) {
            if (E(), A instanceof ne) throw A;
            if (A instanceof Lt) {
                b += A.stdout, y += A.stderr;
                let O = W(b, y, 0);
                return $e(e, O, t.redirections);
            }
            if (A instanceof Qe || A instanceof Ke) {
                b += A.stdout, y += A.stderr;
                let O = W(b, y, 0);
                return $e(e, O, t.redirections);
            }
            if (A instanceof ae) {
                b += A.stdout, y += A.stderr;
                let O = W(b, y, A.exitCode);
                return $e(e, O, t.redirections);
            }
            if (A instanceof Ve) {
                b += A.stdout, y += A.stderr;
                let O = W(b, y, A.exitCode);
                return $e(e, O, t.redirections);
            }
            if (A instanceof lt) {
                let O = W(b + A.stdout, y + A.stderr, A.exitCode);
                return $e(e, O, t.redirections);
            }
            let I = W(b, `${y}${Ne(A)}
`, 1);
            return $e(e, I, t.redirections);
        }
        E();
        let C = W(b, y, w);
        return $e(e, C, t.redirections);
    }
    async function By(e, t, n, r) {
        let s = "", i = "", o = 0, a = await $i(e, t.redirections);
        if (a) return a;
        let l = n;
        for (let f of t.redirections)if ((f.operator === "<<" || f.operator === "<<-") && f.target.type === "HereDoc") {
            let p = f.target, d = await J(e, p.content);
            p.stripTabs && (d = d.split(`
`).map((h)=>h.replace(/^\t+/, "")).join(`
`));
            let m = f.fd ?? 0;
            m !== 0 ? (e.state.fileDescriptors || (e.state.fileDescriptors = new Map()), e.state.fileDescriptors.set(m, d)) : l = d;
        } else if (f.operator === "<<<" && f.target.type === "Word") l = `${await J(e, f.target)}
`;
        else if (f.operator === "<" && f.target.type === "Word") try {
            let p = await J(e, f.target), d = e.fs.resolvePath(e.state.cwd, p);
            l = await e.fs.readFile(d);
        } catch  {
            let p = await J(e, f.target);
            return W("", `bash: ${p}: No such file or directory
`, 1);
        }
        let c = e.state.groupStdin;
        l && (e.state.groupStdin = l);
        try {
            for (let f of t.body){
                let p = await r(f);
                s += p.stdout, i += p.stderr, o = p.exitCode;
            }
        } catch (f) {
            if (e.state.groupStdin = c, f instanceof ne) throw f;
            if (ls(f) || f instanceof lt || f instanceof ae) throw f.prependOutput(s, i), f;
            return W(s, `${i}${Ne(f)}
`, 1);
        }
        e.state.groupStdin = c;
        let u = W(s, i, o);
        return $e(e, u, t.redirections);
    }
    async function Uy(e, t, n, r, s) {
        let i;
        try {
            i = await e.fs.readFile(t);
        } catch  {
            return M(`bash: ${t}: No such file or directory
`, 127);
        }
        if (i.startsWith("#!")) {
            let g = i.indexOf(`
`);
            g !== -1 && (i = i.slice(g + 1));
        }
        let o = {
            ...e.state.env
        }, a = e.state.cwd, l = {
            ...e.state.options
        }, c = e.state.loopDepth, u = e.state.parentHasLoopContext, f = e.state.lastArg, p = e.state.bashPid, d = e.state.groupStdin, m = e.state.currentSource;
        e.state.parentHasLoopContext = c > 0, e.state.loopDepth = 0, e.state.bashPid = e.state.nextVirtualPid++, r && (e.state.groupStdin = r), e.state.currentSource = t, e.state.env[0] = t, e.state.env["#"] = String(n.length), e.state.env["@"] = n.join(" "), e.state.env["*"] = n.join(" ");
        for(let g = 0; g < n.length && g < 9; g++)e.state.env[String(g + 1)] = n[g];
        for(let g = n.length + 1; g <= 9; g++)delete e.state.env[String(g)];
        let h = ()=>{
            e.state.env = o, e.state.cwd = a, e.state.options = l, e.state.loopDepth = c, e.state.parentHasLoopContext = u, e.state.lastArg = f, e.state.bashPid = p, e.state.groupStdin = d, e.state.currentSource = m;
        };
        try {
            let b = new se().parse(i), y = await s(b);
            return h(), y;
        } catch (g) {
            if (h(), g instanceof ae || g instanceof ne) throw g;
            if (g.name === "ParseException") return M(`bash: ${t}: ${g.message}
`);
            throw g;
        }
    }
    var Zr = class {
        ctx;
        constructor(t, n){
            this.ctx = {
                state: n,
                fs: t.fs,
                commands: t.commands,
                limits: t.limits,
                execFn: t.exec,
                executeScript: this.executeScript.bind(this),
                executeStatement: this.executeStatement.bind(this),
                executeCommand: this.executeCommand.bind(this),
                fetch: t.fetch,
                sleep: t.sleep,
                trace: t.trace
            };
        }
        buildExportedEnv() {
            let t = this.ctx.state.exportedVars, n = this.ctx.state.tempExportedVars, r = new Set();
            if (t) for (let i of t)r.add(i);
            if (n) for (let i of n)r.add(i);
            if (r.size === 0) return {};
            let s = {};
            for (let i of r){
                let o = this.ctx.state.env[i];
                o !== void 0 && (s[i] = o);
            }
            return s;
        }
        async executeScript(t) {
            let n = "", r = "", s = 0;
            for (let i of t.statements)try {
                let o = await this.executeStatement(i);
                n += o.stdout, r += o.stderr, s = o.exitCode, this.ctx.state.lastExitCode = s, this.ctx.state.env["?"] = String(s);
            } catch (o) {
                if (o instanceof ae) throw o.prependOutput(n, r), o;
                if (o instanceof xt) return n += o.stdout, r += o.stderr, s = o.exitCode, this.ctx.state.lastExitCode = s, this.ctx.state.env["?"] = String(s), {
                    stdout: n,
                    stderr: r,
                    exitCode: s,
                    env: {
                        ...this.ctx.state.env
                    }
                };
                if (o instanceof ne) throw o;
                if (o instanceof lt) return n += o.stdout, r += o.stderr, s = o.exitCode, this.ctx.state.lastExitCode = s, this.ctx.state.env["?"] = String(s), {
                    stdout: n,
                    stderr: r,
                    exitCode: s,
                    env: {
                        ...this.ctx.state.env
                    }
                };
                if (o instanceof tt) return n += o.stdout, r += o.stderr, s = 1, this.ctx.state.lastExitCode = s, this.ctx.state.env["?"] = String(s), {
                    stdout: n,
                    stderr: r,
                    exitCode: s,
                    env: {
                        ...this.ctx.state.env
                    }
                };
                if (o instanceof nt) return n += o.stdout, r += o.stderr, s = 1, this.ctx.state.lastExitCode = s, this.ctx.state.env["?"] = String(s), {
                    stdout: n,
                    stderr: r,
                    exitCode: s,
                    env: {
                        ...this.ctx.state.env
                    }
                };
                if (o instanceof Ee) {
                    n += o.stdout, r += o.stderr, s = 1, this.ctx.state.lastExitCode = s, this.ctx.state.env["?"] = String(s);
                    continue;
                }
                if (o instanceof Fn) {
                    n += o.stdout, r += o.stderr, s = 1, this.ctx.state.lastExitCode = s, this.ctx.state.env["?"] = String(s);
                    continue;
                }
                if (o instanceof Qe || o instanceof Ke) {
                    if (this.ctx.state.loopDepth > 0) throw o.prependOutput(n, r), o;
                    n += o.stdout, r += o.stderr;
                    continue;
                }
                throw o instanceof Ve && o.prependOutput(n, r), o;
            }
            return {
                stdout: n,
                stderr: r,
                exitCode: s,
                env: {
                    ...this.ctx.state.env
                }
            };
        }
        async executeUserScript(t, n, r = "") {
            return Uy(this.ctx, t, n, r, (s)=>this.executeScript(s));
        }
        async executeStatement(t) {
            if (this.ctx.state.commandCount++, this.ctx.state.commandCount > this.ctx.limits.maxCommandCount && Xt(`too many commands executed (>${this.ctx.limits.maxCommandCount}), increase executionLimits.maxCommandCount`, "commands"), t.deferredError) throw new Ge(t.deferredError.message, t.line ?? 1, 1);
            if (this.ctx.state.options.noexec) return le;
            this.ctx.state.errexitSafe = false;
            let n = "", r = "";
            this.ctx.state.options.verbose && !this.ctx.state.suppressVerbose && t.sourceText && (r += `${t.sourceText}
`);
            let s = 0, i = -1, o = false;
            for(let c = 0; c < t.pipelines.length; c++){
                let u = t.pipelines[c], f = c > 0 ? t.operators[c - 1] : null;
                if (f === "&&" && s !== 0 || f === "||" && s === 0) continue;
                let p = await this.executePipeline(u);
                n += p.stdout, r += p.stderr, s = p.exitCode, i = c, o = u.negated, this.ctx.state.lastExitCode = s, this.ctx.state.env["?"] = String(s);
            }
            let a = i < t.pipelines.length - 1, l = this.ctx.state.errexitSafe;
            if (this.ctx.state.errexitSafe = a || o || l, this.ctx.state.options.errexit && s !== 0 && i === t.pipelines.length - 1 && !o && !this.ctx.state.inCondition && !l) throw new lt(s, n, r);
            return W(n, r, s);
        }
        async executePipeline(t) {
            return _y(this.ctx, t, (n, r)=>this.executeCommand(n, r));
        }
        async executeCommand(t, n) {
            switch(t.type){
                case "SimpleCommand":
                    return this.executeSimpleCommand(t, n);
                case "If":
                    return Ny(this.ctx, t);
                case "For":
                    return ky(this.ctx, t);
                case "CStyleFor":
                    return vy(this.ctx, t);
                case "While":
                    return $y(this.ctx, t, n);
                case "Until":
                    return Iy(this.ctx, t);
                case "Case":
                    return Ry(this.ctx, t);
                case "Subshell":
                    return this.executeSubshell(t, n);
                case "Group":
                    return this.executeGroup(t, n);
                case "FunctionDef":
                    return G0(this.ctx, t);
                case "ArithmeticCommand":
                    return this.executeArithmeticCommand(t);
                case "ConditionalCommand":
                    return this.executeConditionalCommand(t);
                default:
                    return le;
            }
        }
        async executeSimpleCommand(t, n) {
            try {
                return await this.executeSimpleCommandInner(t, n);
            } catch (r) {
                if (r instanceof _t) return M(r.stderr);
                throw r;
            }
        }
        async executeSimpleCommandInner(t, n) {
            if (t.line !== void 0 && (this.ctx.state.currentLine = t.line), this.ctx.state.shoptOptions.expand_aliases && t.name) {
                let E = t, C = 100;
                for(; C > 0;){
                    let A = this.expandAlias(E);
                    if (A === E) break;
                    E = A, C--;
                }
                this.aliasExpansionStack.clear(), E !== t && (t = E);
            }
            this.ctx.state.expansionStderr = "";
            let r = await Ly(this.ctx, t);
            if (r.error) return r.error;
            let s = r.tempAssignments, i = r.xtraceOutput;
            if (!t.name) {
                if (t.redirections.length > 0) {
                    let C = await qt(this.ctx, t.redirections);
                    if (C) return C;
                    let A = W("", i, 0);
                    return $e(this.ctx, A, t.redirections);
                }
                this.ctx.state.lastArg = "";
                let E = (this.ctx.state.expansionStderr || "") + i;
                return this.ctx.state.expansionStderr = "", W("", E, this.ctx.state.lastExitCode);
            }
            let o = t.name && ql(t.name, [
                "local",
                "declare",
                "typeset",
                "export",
                "readonly"
            ]), a = Object.keys(s);
            if (a.length > 0 && !o) {
                this.ctx.state.tempExportedVars = this.ctx.state.tempExportedVars || new Set();
                for (let E of a)this.ctx.state.tempExportedVars.add(E);
            }
            let l = await $i(this.ctx, t.redirections);
            if (l) {
                for (let [E, C] of Object.entries(s))C === void 0 ? delete this.ctx.state.env[E] : this.ctx.state.env[E] = C;
                return l;
            }
            let c = -1;
            for (let E of t.redirections){
                if ((E.operator === "<<" || E.operator === "<<-") && E.target.type === "HereDoc") {
                    let C = E.target, A = await J(this.ctx, C.content);
                    C.stripTabs && (A = A.split(`
`).map((O)=>O.replace(/^\t+/, "")).join(`
`));
                    let I = E.fd ?? 0;
                    I !== 0 ? (this.ctx.state.fileDescriptors || (this.ctx.state.fileDescriptors = new Map()), this.ctx.state.fileDescriptors.set(I, A)) : n = A;
                    continue;
                }
                if (E.operator === "<<<" && E.target.type === "Word") {
                    n = `${await J(this.ctx, E.target)}
`;
                    continue;
                }
                if (E.operator === "<" && E.target.type === "Word") try {
                    let C = await J(this.ctx, E.target), A = this.ctx.fs.resolvePath(this.ctx.state.cwd, C);
                    n = await this.ctx.fs.readFile(A);
                } catch  {
                    let C = await J(this.ctx, E.target);
                    for (let [A, I] of Object.entries(s))I === void 0 ? delete this.ctx.state.env[A] : this.ctx.state.env[A] = I;
                    return M(`bash: ${C}: No such file or directory
`);
                }
                if (E.operator === "<&" && E.target.type === "Word") {
                    let C = await J(this.ctx, E.target), A = Number.parseInt(C, 10);
                    if (!Number.isNaN(A) && this.ctx.state.fileDescriptors) {
                        let I = this.ctx.state.fileDescriptors.get(A);
                        if (I !== void 0) if (I.startsWith("__rw__:")) {
                            let O = Py(I);
                            O && (n = O.content.slice(O.position), c = A);
                        } else I.startsWith("__file__:") || I.startsWith("__file_append__:") || (n = I);
                    }
                }
            }
            let u = await J(this.ctx, t.name), f = [], p = [];
            if (ql(t.name, [
                "local",
                "declare",
                "typeset",
                "export",
                "readonly"
            ]) && (u === "local" || u === "declare" || u === "typeset" || u === "export" || u === "readonly")) for (let E of t.args){
                let C = await R0(this.ctx, E);
                if (C) f.push(C), p.push(true);
                else {
                    let A = await P0(this.ctx, E);
                    if (A !== null) f.push(A), p.push(true);
                    else {
                        let I = await Ft(this.ctx, E);
                        for (let O of I.values)f.push(O), p.push(I.quoted);
                    }
                }
            }
            else for (let E of t.args){
                let C = await Ft(this.ctx, E);
                for (let A of C.values)f.push(A), p.push(C.quoted);
            }
            if (!u) {
                if (t.name.parts.every((C)=>C.type === "CommandSubstitution" || C.type === "ParameterExpansion" || C.type === "ArithmeticExpansion")) {
                    if (f.length > 0) {
                        let C = f.shift();
                        return p.shift(), await this.runCommand(C, f, p, n, false, false, c);
                    }
                    return W("", "", this.ctx.state.lastExitCode);
                }
                return M(`bash: : command not found
`, 127);
            }
            if (u === "exec" && (f.length === 0 || f[0] === "--")) {
                for (let E of t.redirections){
                    if (E.target.type === "HereDoc" || E.fdVariable) continue;
                    let C = await J(this.ctx, E.target), A = E.fd ?? (E.operator === "<" || E.operator === "<>" ? 0 : 1);
                    switch(this.ctx.state.fileDescriptors || (this.ctx.state.fileDescriptors = new Map()), E.operator){
                        case ">":
                        case ">|":
                            {
                                let I = this.ctx.fs.resolvePath(this.ctx.state.cwd, C);
                                await this.ctx.fs.writeFile(I, "", "utf8"), this.ctx.state.fileDescriptors.set(A, `__file__:${I}`);
                                break;
                            }
                        case ">>":
                            {
                                let I = this.ctx.fs.resolvePath(this.ctx.state.cwd, C);
                                this.ctx.state.fileDescriptors.set(A, `__file_append__:${I}`);
                                break;
                            }
                        case "<":
                            {
                                let I = this.ctx.fs.resolvePath(this.ctx.state.cwd, C);
                                try {
                                    let O = await this.ctx.fs.readFile(I);
                                    this.ctx.state.fileDescriptors.set(A, O);
                                } catch  {
                                    return M(`bash: ${C}: No such file or directory
`);
                                }
                                break;
                            }
                        case "<>":
                            {
                                let I = this.ctx.fs.resolvePath(this.ctx.state.cwd, C);
                                try {
                                    let O = await this.ctx.fs.readFile(I);
                                    this.ctx.state.fileDescriptors.set(A, `__rw__:${I.length}:${I}:0:${O}`);
                                } catch  {
                                    await this.ctx.fs.writeFile(I, "", "utf8"), this.ctx.state.fileDescriptors.set(A, `__rw__:${I.length}:${I}:0:`);
                                }
                                break;
                            }
                        case ">&":
                            {
                                if (C === "-") this.ctx.state.fileDescriptors.delete(A);
                                else if (C.endsWith("-")) {
                                    let I = C.slice(0, -1), O = Number.parseInt(I, 10);
                                    if (!Number.isNaN(O)) {
                                        let L = this.ctx.state.fileDescriptors.get(O);
                                        L !== void 0 ? this.ctx.state.fileDescriptors.set(A, L) : this.ctx.state.fileDescriptors.set(A, `__dupout__:${O}`), this.ctx.state.fileDescriptors.delete(O);
                                    }
                                } else {
                                    let I = Number.parseInt(C, 10);
                                    Number.isNaN(I) || this.ctx.state.fileDescriptors.set(A, `__dupout__:${I}`);
                                }
                                break;
                            }
                        case "<&":
                            {
                                if (C === "-") this.ctx.state.fileDescriptors.delete(A);
                                else if (C.endsWith("-")) {
                                    let I = C.slice(0, -1), O = Number.parseInt(I, 10);
                                    if (!Number.isNaN(O)) {
                                        let L = this.ctx.state.fileDescriptors.get(O);
                                        L !== void 0 ? this.ctx.state.fileDescriptors.set(A, L) : this.ctx.state.fileDescriptors.set(A, `__dupin__:${O}`), this.ctx.state.fileDescriptors.delete(O);
                                    }
                                } else {
                                    let I = Number.parseInt(C, 10);
                                    Number.isNaN(I) || this.ctx.state.fileDescriptors.set(A, `__dupin__:${I}`);
                                }
                                break;
                            }
                    }
                }
                for (let [E, C] of Object.entries(s))C === void 0 ? delete this.ctx.state.env[E] : this.ctx.state.env[E] = C;
                if (this.ctx.state.tempExportedVars) for (let E of Object.keys(s))this.ctx.state.tempExportedVars.delete(E);
                return le;
            }
            let m = await Dy(this.ctx, u, f);
            Object.keys(s).length > 0 && (this.ctx.state.tempEnvBindings = this.ctx.state.tempEnvBindings || [], this.ctx.state.tempEnvBindings.push(new Map(Object.entries(s))));
            let h, g = null;
            try {
                h = await this.runCommand(u, f, p, n, false, false, c);
            } catch (E) {
                if (E instanceof Qe || E instanceof Ke) g = E, h = le;
                else throw E;
            }
            let b = i + m;
            if (b && (h = {
                ...h,
                stderr: b + h.stderr
            }), h = await $e(this.ctx, h, t.redirections), g) throw g;
            if (f.length > 0) {
                let E = f[f.length - 1];
                if ((u === "declare" || u === "local" || u === "typeset") && /^[a-zA-Z_][a-zA-Z0-9_]*=\(/.test(E)) {
                    let C = E.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\(/);
                    C && (E = C[1]);
                }
                this.ctx.state.lastArg = E;
            } else this.ctx.state.lastArg = u;
            let y = V0(u) && u !== "unset" && u !== "eval";
            if (!this.ctx.state.options.posix || !y) for (let [E, C] of Object.entries(s))this.ctx.state.fullyUnsetLocals?.has(E) || (C === void 0 ? delete this.ctx.state.env[E] : this.ctx.state.env[E] = C);
            if (this.ctx.state.tempExportedVars) for (let E of Object.keys(s))this.ctx.state.tempExportedVars.delete(E);
            return Object.keys(s).length > 0 && this.ctx.state.tempEnvBindings && this.ctx.state.tempEnvBindings.pop(), this.ctx.state.expansionStderr && (h = {
                ...h,
                stderr: this.ctx.state.expansionStderr + h.stderr
            }, this.ctx.state.expansionStderr = ""), h;
        }
        async runCommand(t, n, r, s, i = false, o = false, a = -1) {
            let l = {
                ctx: this.ctx,
                runCommand: (u, f, p, d, m, h, g)=>this.runCommand(u, f, p, d, m, h, g),
                buildExportedEnv: ()=>this.buildExportedEnv(),
                executeUserScript: (u, f, p)=>this.executeUserScript(u, f, p)
            }, c = await Ay(l, t, n, r, s, i, o, a);
            return c !== null ? c : Cy(l, t, n, s, o);
        }
        aliasExpansionStack = new Set();
        expandAlias(t) {
            return Oa(this.ctx.state, t, this.aliasExpansionStack);
        }
        async findCommandInPath(t) {
            return Fi(this.ctx, t);
        }
        async executeSubshell(t, n = "") {
            return Wy(this.ctx, t, n, (r)=>this.executeStatement(r));
        }
        async executeGroup(t, n = "") {
            return By(this.ctx, t, n, (r)=>this.executeStatement(r));
        }
        async executeArithmeticCommand(t) {
            t.line !== void 0 && (this.ctx.state.currentLine = t.line);
            let n = await qt(this.ctx, t.redirections);
            if (n) return n;
            try {
                let r = await Q(this.ctx, t.expression.expression), s = Le(r !== 0);
                return this.ctx.state.expansionStderr && (s = {
                    ...s,
                    stderr: this.ctx.state.expansionStderr + s.stderr
                }, this.ctx.state.expansionStderr = ""), $e(this.ctx, s, t.redirections);
            } catch (r) {
                let s = M(`bash: arithmetic expression: ${r.message}
`);
                return $e(this.ctx, s, t.redirections);
            }
        }
        async executeConditionalCommand(t) {
            t.line !== void 0 && (this.ctx.state.currentLine = t.line);
            let n = await qt(this.ctx, t.redirections);
            if (n) return n;
            try {
                let r = await ln(this.ctx, t.expression), s = Le(r);
                return this.ctx.state.expansionStderr && (s = {
                    ...s,
                    stderr: this.ctx.state.expansionStderr + s.stderr
                }, this.ctx.state.expansionStderr = ""), $e(this.ctx, s, t.redirections);
            } catch (r) {
                let s = r instanceof Ee ? 1 : 2, i = M(`bash: conditional expression: ${r.message}
`, s);
                return $e(this.ctx, i, t.redirections);
            }
        }
    };
    var Jt = {
        maxCallDepth: 100,
        maxCommandCount: 1e4,
        maxLoopIterations: 1e4,
        maxAwkIterations: 1e4,
        maxSedIterations: 1e4,
        maxJqIterations: 1e4,
        maxSqliteTimeoutMs: 5e3,
        maxPythonTimeoutMs: 3e4
    };
    function zy(e) {
        return e ? {
            maxCallDepth: e.maxCallDepth ?? Jt.maxCallDepth,
            maxCommandCount: e.maxCommandCount ?? Jt.maxCommandCount,
            maxLoopIterations: e.maxLoopIterations ?? Jt.maxLoopIterations,
            maxAwkIterations: e.maxAwkIterations ?? Jt.maxAwkIterations,
            maxSedIterations: e.maxSedIterations ?? Jt.maxSedIterations,
            maxJqIterations: e.maxJqIterations ?? Jt.maxJqIterations,
            maxSqliteTimeoutMs: e.maxSqliteTimeoutMs ?? Jt.maxSqliteTimeoutMs,
            maxPythonTimeoutMs: e.maxPythonTimeoutMs ?? Jt.maxPythonTimeoutMs
        } : {
            ...Jt
        };
    }
    function jy(e) {
        try {
            let t = new URL(e);
            return {
                origin: t.origin,
                pathname: t.pathname,
                href: t.href
            };
        } catch  {
            return null;
        }
    }
    function Ok(e) {
        let t = jy(e);
        return t ? {
            origin: t.origin,
            pathPrefix: t.pathname
        } : null;
    }
    function Dk(e, t) {
        let n = jy(e);
        if (!n) return false;
        let r = Ok(t);
        return !r || n.origin !== r.origin ? false : r.pathPrefix === "/" || r.pathPrefix === "" ? true : n.pathname.startsWith(r.pathPrefix);
    }
    function Gl(e, t) {
        return !t || t.length === 0 ? false : t.some((n)=>Dk(e, n));
    }
    var ur = class extends Error {
        constructor(t){
            super(`Network access denied: URL not in allow-list: ${t}`), this.name = "NetworkAccessDeniedError";
        }
    }, fr = class extends Error {
        constructor(t){
            super(`Too many redirects (max: ${t})`), this.name = "TooManyRedirectsError";
        }
    }, pr = class extends Error {
        constructor(t){
            super(`Redirect target not in allow-list: ${t}`), this.name = "RedirectNotAllowedError";
        }
    }, Li = class extends Error {
        constructor(t, n){
            super(`HTTP method '${t}' not allowed. Allowed methods: ${n.join(", ")}`), this.name = "MethodNotAllowedError";
        }
    };
    var Fk = 20, _k = 3e4, Lk = [
        "GET",
        "HEAD"
    ], Mk = new Set([
        "GET",
        "HEAD",
        "OPTIONS"
    ]), Wk = new Set([
        301,
        302,
        303,
        307,
        308
    ]);
    function Zl(e) {
        let t = e.maxRedirects ?? Fk, n = e.timeoutMs ?? _k, r = e.dangerouslyAllowFullInternetAccess ? [
            "GET",
            "HEAD",
            "POST",
            "PUT",
            "DELETE",
            "PATCH",
            "OPTIONS"
        ] : e.allowedMethods ?? Lk;
        function s(a) {
            if (!e.dangerouslyAllowFullInternetAccess && !Gl(a, e.allowedUrlPrefixes ?? [])) throw new ur(a);
        }
        function i(a) {
            if (e.dangerouslyAllowFullInternetAccess) return;
            let l = a.toUpperCase();
            if (!r.includes(l)) throw new Li(l, r);
        }
        async function o(a, l = {}) {
            let c = l.method?.toUpperCase() ?? "GET";
            s(a), i(c);
            let u = a, f = 0, p = l.followRedirects ?? true, d = l.timeoutMs !== void 0 ? Math.min(l.timeoutMs, n) : n;
            for(;;){
                let m = new AbortController(), h = setTimeout(()=>m.abort(), d);
                try {
                    let g = {
                        method: c,
                        headers: l.headers,
                        signal: m.signal,
                        redirect: "manual"
                    };
                    l.body && !Mk.has(c) && (g.body = l.body);
                    let b = await fetch(u, g);
                    if (Wk.has(b.status) && p) {
                        let y = b.headers.get("location");
                        if (!y) return await Hy(b, u);
                        let w = new URL(y, u).href;
                        if (!e.dangerouslyAllowFullInternetAccess && !Gl(w, e.allowedUrlPrefixes ?? [])) throw new pr(w);
                        if (f++, f > t) throw new fr(t);
                        u = w;
                        continue;
                    }
                    return await Hy(b, u);
                } finally{
                    clearTimeout(h);
                }
            }
        }
        return o;
    }
    async function Hy(e, t) {
        let n = {};
        return e.headers.forEach((r, s)=>{
            n[s.toLowerCase()] = r;
        }), {
            status: e.status,
            statusText: e.statusText,
            headers: n,
            body: await e.text(),
            url: t
        };
    }
    tn();
    Fe();
    var Ql = class {
        fs;
        commands = new Map();
        useDefaultLayout = false;
        limits;
        secureFetch;
        sleepFn;
        traceFn;
        logger;
        state;
        constructor(t = {}){
            let n = t.fs ?? new En(t.files);
            this.fs = n, this.useDefaultLayout = !t.cwd && !t.files;
            let r = t.cwd || (this.useDefaultLayout ? "/home/user" : "/"), s = {
                HOME: this.useDefaultLayout ? "/home/user" : "/",
                PATH: "/usr/bin:/bin",
                IFS: ` 	
`,
                OSTYPE: "linux-gnu",
                MACHTYPE: "x86_64-pc-linux-gnu",
                HOSTTYPE: "x86_64",
                HOSTNAME: "localhost",
                PWD: r,
                OLDPWD: r,
                OPTIND: "1",
                ...t.env
            };
            if (this.limits = zy({
                ...t.executionLimits,
                ...t.maxCallDepth !== void 0 && {
                    maxCallDepth: t.maxCallDepth
                },
                ...t.maxCommandCount !== void 0 && {
                    maxCommandCount: t.maxCommandCount
                },
                ...t.maxLoopIterations !== void 0 && {
                    maxLoopIterations: t.maxLoopIterations
                }
            }), t.network && (this.secureFetch = Zl(t.network)), this.sleepFn = t.sleep, this.traceFn = t.trace, this.logger = t.logger, this.state = {
                env: s,
                cwd: r,
                previousDir: "/home/user",
                functions: new Map(),
                localScopes: [],
                callDepth: 0,
                sourceDepth: 0,
                commandCount: 0,
                lastExitCode: 0,
                lastArg: "",
                startTime: Date.now(),
                lastBackgroundPid: 0,
                bashPid: process.pid,
                nextVirtualPid: process.pid + 1,
                currentLine: 1,
                options: {
                    errexit: false,
                    pipefail: false,
                    nounset: false,
                    xtrace: false,
                    verbose: false,
                    posix: false,
                    allexport: false,
                    noclobber: false,
                    noglob: false,
                    noexec: false,
                    vi: false,
                    emacs: false
                },
                shoptOptions: {
                    extglob: false,
                    dotglob: false,
                    nullglob: false,
                    failglob: false,
                    globstar: false,
                    globskipdots: true,
                    nocaseglob: false,
                    nocasematch: false,
                    expand_aliases: false,
                    lastpipe: false,
                    xpg_echo: false
                },
                inCondition: false,
                loopDepth: 0,
                exportedVars: new Set([
                    "HOME",
                    "PATH",
                    "PWD",
                    "OLDPWD",
                    ...Object.keys(t.env || {})
                ]),
                readonlyVars: new Set([
                    "SHELLOPTS",
                    "BASHOPTS"
                ]),
                hashTable: new Map()
            }, this.state.env.SHELLOPTS = ua(this.state.options), this.state.env.BASHOPTS = fa(this.state.shoptOptions), om(n, this.useDefaultLayout), r !== "/" && n instanceof En) try {
                n.mkdirSync(r, {
                    recursive: true
                });
            } catch  {}
            for (let i of Jh(t.commands))this.registerCommand(i);
            if (t.network) for (let i of Yh())this.registerCommand(i);
            if (t.customCommands) for (let i of t.customCommands)em(i) ? this.registerCommand(tm(i)) : this.registerCommand(i);
        }
        registerCommand(t) {
            this.commands.set(t.name, t);
            let n = this.fs;
            if (typeof n.writeFileSync == "function") {
                let r = `#!/bin/bash
# Built-in command: ${t.name}
`;
                try {
                    n.writeFileSync(`/bin/${t.name}`, r);
                } catch  {}
                try {
                    n.writeFileSync(`/usr/bin/${t.name}`, r);
                } catch  {}
            }
        }
        logResult(t) {
            return this.logger && (t.stdout && this.logger.debug("stdout", {
                output: t.stdout
            }), t.stderr && this.logger.info("stderr", {
                output: t.stderr
            }), this.logger.info("exit", {
                exitCode: t.exitCode
            })), t;
        }
        async exec(t, n) {
            if (this.state.callDepth === 0 && (this.state.commandCount = 0), this.state.commandCount++, this.state.commandCount > this.limits.maxCommandCount) return {
                stdout: "",
                stderr: `bash: maximum command count (${this.limits.maxCommandCount}) exceeded (possible infinite loop). Increase with executionLimits.maxCommandCount option.
`,
                exitCode: 1,
                env: {
                    ...this.state.env,
                    ...n?.env
                }
            };
            if (!t.trim()) return {
                stdout: "",
                stderr: "",
                exitCode: 0,
                env: {
                    ...this.state.env,
                    ...n?.env
                }
            };
            this.logger?.info("exec", {
                command: t
            });
            let r = n?.cwd ?? this.state.cwd, s, i = r;
            if (n?.cwd) if (n.env && "PWD" in n.env) s = n.env.PWD;
            else if (n?.env && !("PWD" in n.env)) try {
                s = await this.fs.realpath(r), i = s;
            } catch  {
                s = r;
            }
            else s = r;
            let o = {
                ...this.state,
                env: {
                    ...this.state.env,
                    ...n?.env,
                    ...s !== void 0 ? {
                        PWD: s
                    } : {}
                },
                cwd: i,
                functions: new Map(this.state.functions),
                localScopes: [
                    ...this.state.localScopes
                ],
                options: {
                    ...this.state.options
                },
                hashTable: this.state.hashTable
            }, a = t;
            n?.rawScript || (a = Bk(t));
            try {
                let l = Bt(a), c = {
                    fs: this.fs,
                    commands: this.commands,
                    limits: this.limits,
                    exec: this.exec.bind(this),
                    fetch: this.secureFetch,
                    sleep: this.sleepFn,
                    trace: this.traceFn
                }, f = await new Zr(c, o).executeScript(l);
                return this.logResult(f);
            } catch (l) {
                if (l instanceof ae) return this.logResult({
                    stdout: l.stdout,
                    stderr: l.stderr,
                    exitCode: l.exitCode,
                    env: {
                        ...this.state.env,
                        ...n?.env
                    }
                });
                if (l instanceof xt) return this.logResult({
                    stdout: l.stdout,
                    stderr: l.stderr,
                    exitCode: l.exitCode,
                    env: {
                        ...this.state.env,
                        ...n?.env
                    }
                });
                if (l instanceof Ee) return this.logResult({
                    stdout: l.stdout,
                    stderr: l.stderr,
                    exitCode: 1,
                    env: {
                        ...this.state.env,
                        ...n?.env
                    }
                });
                if (l instanceof ne) return this.logResult({
                    stdout: l.stdout,
                    stderr: l.stderr,
                    exitCode: ne.EXIT_CODE,
                    env: {
                        ...this.state.env,
                        ...n?.env
                    }
                });
                if (l.name === "ParseException") return this.logResult({
                    stdout: "",
                    stderr: `bash: syntax error: ${l.message}
`,
                    exitCode: 2,
                    env: {
                        ...this.state.env,
                        ...n?.env
                    }
                });
                if (l instanceof Sn) return this.logResult({
                    stdout: "",
                    stderr: `bash: ${l.message}
`,
                    exitCode: 2,
                    env: {
                        ...this.state.env,
                        ...n?.env
                    }
                });
                if (l instanceof RangeError) return this.logResult({
                    stdout: "",
                    stderr: `bash: ${l.message}
`,
                    exitCode: 1,
                    env: {
                        ...this.state.env,
                        ...n?.env
                    }
                });
                throw l;
            }
        }
        async readFile(t) {
            return this.fs.readFile(this.fs.resolvePath(this.state.cwd, t));
        }
        async writeFile(t, n) {
            return this.fs.writeFile(this.fs.resolvePath(this.state.cwd, t), n);
        }
        getCwd() {
            return this.state.cwd;
        }
        getEnv() {
            return {
                ...this.state.env
            };
        }
    };
    function Bk(e) {
        let t = e.split(`
`), n = [], r = [];
        for(let s = 0; s < t.length; s++){
            let i = t[s];
            if (r.length > 0) {
                let l = r[r.length - 1];
                if ((l.stripTabs ? i.replace(/^\t+/, "") : i) === l.delimiter) {
                    n.push(i.trimStart()), r.pop();
                    continue;
                }
                n.push(i);
                continue;
            }
            let o = i.trimStart();
            n.push(o);
            let a = /<<(-?)\s*(['"]?)([\w-]+)\2/g;
            for (let l of o.matchAll(a)){
                let c = l[1] === "-", u = l[3];
                r.push({
                    delimiter: u,
                    stripTabs: c
                });
            }
        }
        return n.join(`
`);
    }
    const _decoder = new TextDecoder();
    class VirtualFSAdapter {
        constructor(vfs){
            this.vfs = vfs;
        }
        async readFile(path, options) {
            const encoding = typeof options === "string" ? options : options?.encoding;
            if (!encoding || encoding === "utf8" || encoding === "utf-8") {
                return this.vfs.readFileSync(path, "utf8");
            }
            if (encoding === "binary" || encoding === "latin1") {
                const buffer = this.vfs.readFileSync(path);
                return uint8ToBinaryString(buffer);
            }
            return this.vfs.readFileSync(path, "utf8");
        }
        async readFileBuffer(path) {
            return this.vfs.readFileSync(path);
        }
        async writeFile(path, content, _options) {
            this.vfs.writeFileSync(path, content);
        }
        async appendFile(path, content, _options) {
            let existing = "";
            try {
                existing = this.vfs.readFileSync(path, "utf8");
            } catch  {}
            const newContent = typeof content === "string" ? content : _decoder.decode(content);
            this.vfs.writeFileSync(path, existing + newContent);
        }
        async exists(path) {
            return this.vfs.existsSync(path);
        }
        async stat(path) {
            const stats = this.vfs.statSync(path);
            const isFile = stats.isFile();
            const isDirectory = stats.isDirectory();
            let size = 0;
            if (isFile) {
                try {
                    const content = this.vfs.readFileSync(path);
                    size = content.length;
                } catch  {}
            }
            return {
                isFile,
                isDirectory,
                isSymbolicLink: false,
                mode: isDirectory ? 493 : 420,
                size,
                mtime: new Date()
            };
        }
        async mkdir(path, options) {
            this.vfs.mkdirSync(path, options);
        }
        async readdir(path) {
            return this.vfs.readdirSync(path);
        }
        async readdirWithFileTypes(path) {
            const entries = this.vfs.readdirSync(path);
            const result = [];
            for (const name of entries){
                const fullPath = path === "/" ? `/${name}` : `${path}/${name}`;
                try {
                    const stats = this.vfs.statSync(fullPath);
                    result.push({
                        name,
                        isFile: stats.isFile(),
                        isDirectory: stats.isDirectory(),
                        isSymbolicLink: false
                    });
                } catch  {}
            }
            return result;
        }
        async rm(path, options) {
            const exists = this.vfs.existsSync(path);
            if (!exists) {
                if (options?.force) {
                    return;
                }
                throw createNodeError("ENOENT", "rm", path);
            }
            const stats = this.vfs.statSync(path);
            if (stats.isFile()) {
                this.vfs.unlinkSync(path);
            } else if (stats.isDirectory()) {
                if (options?.recursive) {
                    await this.rmRecursive(path);
                } else {
                    this.vfs.rmdirSync(path);
                }
            }
        }
        async rmRecursive(path) {
            const entries = this.vfs.readdirSync(path);
            for (const entry of entries){
                const fullPath = path === "/" ? `/${entry}` : `${path}/${entry}`;
                const stats = this.vfs.statSync(fullPath);
                if (stats.isDirectory()) {
                    await this.rmRecursive(fullPath);
                } else {
                    this.vfs.unlinkSync(fullPath);
                }
            }
            this.vfs.rmdirSync(path);
        }
        async cp(src, dest, options) {
            const stats = this.vfs.statSync(src);
            if (stats.isFile()) {
                const content = this.vfs.readFileSync(src);
                this.vfs.writeFileSync(dest, content);
            } else if (stats.isDirectory()) {
                if (!options?.recursive) {
                    throw new Error(`EISDIR: illegal operation on a directory, cannot copy '${src}'`);
                }
                await this.cpRecursive(src, dest);
            }
        }
        async cpRecursive(src, dest) {
            this.vfs.mkdirSync(dest, {
                recursive: true
            });
            const entries = this.vfs.readdirSync(src);
            for (const entry of entries){
                const srcPath = src === "/" ? `/${entry}` : `${src}/${entry}`;
                const destPath = dest === "/" ? `/${entry}` : `${dest}/${entry}`;
                const stats = this.vfs.statSync(srcPath);
                if (stats.isDirectory()) {
                    await this.cpRecursive(srcPath, destPath);
                } else {
                    const content = this.vfs.readFileSync(srcPath);
                    this.vfs.writeFileSync(destPath, content);
                }
            }
        }
        async mv(src, dest) {
            this.vfs.renameSync(src, dest);
        }
        resolvePath(base, path) {
            if (path.startsWith("/")) {
                return this.normalizePath(path);
            }
            const combined = base.endsWith("/") ? `${base}${path}` : `${base}/${path}`;
            return this.normalizePath(combined);
        }
        normalizePath(path) {
            if (!path.startsWith("/")) {
                path = "/" + path;
            }
            const parts = path.split("/").filter(Boolean);
            const resolved = [];
            for (const part of parts){
                if (part === "..") {
                    resolved.pop();
                } else if (part !== ".") {
                    resolved.push(part);
                }
            }
            return "/" + resolved.join("/");
        }
        getAllPaths() {
            const paths = [];
            this.collectPaths("/", paths);
            return paths;
        }
        collectPaths(dir, paths) {
            try {
                const entries = this.vfs.readdirSync(dir);
                for (const entry of entries){
                    const fullPath = dir === "/" ? `/${entry}` : `${dir}/${entry}`;
                    paths.push(fullPath);
                    try {
                        const stats = this.vfs.statSync(fullPath);
                        if (stats.isDirectory()) {
                            this.collectPaths(fullPath, paths);
                        }
                    } catch  {}
                }
            } catch  {}
        }
        async chmod(_path, _mode) {
            if (!this.vfs.existsSync(_path)) {
                throw createNodeError("ENOENT", "chmod", _path);
            }
        }
        async symlink(_target, _linkPath) {
            throw new Error("Symbolic links are not supported in VirtualFS");
        }
        async link(_existingPath, _newPath) {
            throw new Error("Hard links are not supported in VirtualFS");
        }
        async readlink(_path) {
            throw new Error("Symbolic links are not supported in VirtualFS");
        }
        async lstat(path) {
            return this.stat(path);
        }
        async realpath(path) {
            if (!this.vfs.existsSync(path)) {
                throw createNodeError("ENOENT", "realpath", path);
            }
            return this.normalizePath(path);
        }
        async utimes(path, _atime, _mtime) {
            if (!this.vfs.existsSync(path)) {
                throw createNodeError("ENOENT", "utimes", path);
            }
        }
    }
    if (typeof globalThis.process === "undefined") {
        globalThis.process = {
            env: {
                HOME: "/home/user",
                USER: "user",
                PATH: "/usr/local/bin:/usr/bin:/bin",
                NODE_ENV: "development"
            },
            cwd: ()=>"/",
            platform: "linux",
            version: "v18.0.0",
            versions: {
                node: "18.0.0"
            },
            stdout: {
                write: ()=>{}
            },
            stderr: {
                write: ()=>{}
            }
        };
    }
    let bashInstance = null;
    let vfsAdapter = null;
    let currentVfs = null;
    function initChildProcess(vfs) {
        currentVfs = vfs;
        vfsAdapter = new VirtualFSAdapter(vfs);
        const nodeCommand = GA("node", async (args, ctx)=>{
            if (!currentVfs) {
                return {
                    stdout: "",
                    stderr: "VFS not initialized\n",
                    exitCode: 1
                };
            }
            const scriptPath = args[0];
            if (!scriptPath) {
                return {
                    stdout: "",
                    stderr: "Usage: node <script.js> [args...]\n",
                    exitCode: 1
                };
            }
            const resolvedPath = scriptPath.startsWith("/") ? scriptPath : `${ctx.cwd}/${scriptPath}`.replace(/\/+/g, "/");
            try {
                if (!currentVfs.existsSync(resolvedPath)) {
                    return {
                        stdout: "",
                        stderr: `Error: Cannot find module '${resolvedPath}'
`,
                        exitCode: 1
                    };
                }
                let stdout = "";
                let stderr = "";
                const runtime = new Runtime(currentVfs, {
                    cwd: ctx.cwd,
                    env: ctx.env,
                    onConsole: (method, consoleArgs)=>{
                        const msg = consoleArgs.map((a)=>String(a)).join(" ") + "\n";
                        if (method === "error") {
                            stderr += msg;
                        } else {
                            stdout += msg;
                        }
                    }
                });
                const processShim = globalThis.process || {};
                const originalArgv = processShim.argv;
                processShim.argv = [
                    "node",
                    resolvedPath,
                    ...args.slice(1)
                ];
                globalThis.process = processShim;
                try {
                    runtime.runFile(resolvedPath);
                    return {
                        stdout,
                        stderr,
                        exitCode: 0
                    };
                } finally{
                    processShim.argv = originalArgv;
                }
            } catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                return {
                    stdout: "",
                    stderr: `Error: ${errorMsg}
`,
                    exitCode: 1
                };
            }
        });
        const convexCommand = GA("convex", async (args, ctx)=>{
            if (!currentVfs) {
                return {
                    stdout: "",
                    stderr: "VFS not initialized\n",
                    exitCode: 1
                };
            }
            const cliBundlePath = "/node_modules/convex/dist/cli.bundle.cjs";
            if (!currentVfs.existsSync(cliBundlePath)) {
                return {
                    stdout: "",
                    stderr: "Convex CLI not found. Run: npm install convex\n",
                    exitCode: 1
                };
            }
            let stdout = "";
            let stderr = "";
            try {
                const runtime = new Runtime(currentVfs, {
                    cwd: ctx.cwd,
                    env: ctx.env,
                    onConsole: (method, consoleArgs)=>{
                        const msg = consoleArgs.map((a)=>String(a)).join(" ") + "\n";
                        if (method === "error") {
                            stderr += msg;
                        } else {
                            stdout += msg;
                        }
                    }
                });
                const processShim = globalThis.process || {};
                const originalArgv = processShim.argv;
                const originalEnv = {
                    ...processShim.env
                };
                processShim.argv = [
                    "node",
                    "convex",
                    ...args
                ];
                processShim.env = {
                    ...processShim.env,
                    ...ctx.env
                };
                globalThis.process = processShim;
                try {
                    runtime.runFile(cliBundlePath);
                    return {
                        stdout,
                        stderr,
                        exitCode: 0
                    };
                } finally{
                    processShim.argv = originalArgv;
                    processShim.env = originalEnv;
                }
            } catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                return {
                    stdout,
                    stderr: stderr + `Error: ${errorMsg}
`,
                    exitCode: 1
                };
            }
        });
        bashInstance = new Ql({
            fs: vfsAdapter,
            cwd: "/",
            env: {
                HOME: "/home/user",
                USER: "user",
                PATH: "/usr/local/bin:/usr/bin:/bin:/node_modules/.bin",
                NODE_ENV: "development"
            },
            customCommands: [
                nodeCommand,
                convexCommand
            ]
        });
    }
    function exec(command, optionsOrCallback, callback) {
        let options = {};
        let cb;
        if (typeof optionsOrCallback === "function") {
            cb = optionsOrCallback;
        } else if (optionsOrCallback) {
            options = optionsOrCallback;
            cb = callback;
        }
        const child = new ChildProcess();
        (async ()=>{
            if (!bashInstance) {
                const error = new Error("child_process not initialized");
                child.emit("error", error);
                if (cb) cb(error, "", "");
                return;
            }
            try {
                const result = await bashInstance.exec(command, {
                    cwd: options.cwd,
                    env: options.env
                });
                const stdout = result.stdout || "";
                const stderr = result.stderr || "";
                if (stdout) {
                    child.stdout?.push(BufferPolyfill.from(stdout));
                }
                child.stdout?.push(null);
                if (stderr) {
                    child.stderr?.push(BufferPolyfill.from(stderr));
                }
                child.stderr?.push(null);
                child.emit("close", result.exitCode, null);
                child.emit("exit", result.exitCode, null);
                if (cb) {
                    if (result.exitCode !== 0) {
                        const error = new Error(`Command failed: ${command}`);
                        error.code = result.exitCode;
                        cb(error, stdout, stderr);
                    } else {
                        cb(null, stdout, stderr);
                    }
                }
            } catch (error) {
                child.emit("error", error);
                if (cb) cb(error, "", "");
            }
        })();
        return child;
    }
    function execSync(command, options) {
        if (!bashInstance) {
            throw new Error("child_process not initialized");
        }
        throw new Error("execSync is not supported in browser environment. Use exec() with async/await or callbacks instead.");
    }
    function spawn(command, args, options) {
        let spawnArgs = [];
        let spawnOptions = {};
        if (Array.isArray(args)) {
            spawnArgs = args;
            spawnOptions = options || {};
        } else if (args) {
            spawnOptions = args;
        }
        const child = new ChildProcess();
        const fullCommand = spawnArgs.length > 0 ? `${command} ${spawnArgs.map((arg)=>arg.includes(" ") ? `"${arg}"` : arg).join(" ")}` : command;
        (async ()=>{
            if (!bashInstance) {
                const error = new Error("child_process not initialized");
                child.emit("error", error);
                return;
            }
            try {
                const result = await bashInstance.exec(fullCommand, {
                    cwd: spawnOptions.cwd,
                    env: spawnOptions.env
                });
                const stdout = result.stdout || "";
                const stderr = result.stderr || "";
                if (stdout) {
                    child.stdout?.push(BufferPolyfill.from(stdout));
                }
                child.stdout?.push(null);
                if (stderr) {
                    child.stderr?.push(BufferPolyfill.from(stderr));
                }
                child.stderr?.push(null);
                child.emit("close", result.exitCode, null);
                child.emit("exit", result.exitCode, null);
            } catch (error) {
                child.emit("error", error);
            }
        })();
        return child;
    }
    function spawnSync(command, args, options) {
        throw new Error("spawnSync is not supported in browser environment. Use spawn() instead.");
    }
    function execFile(file, args, options, callback) {
        let execArgs = [];
        let execOptions = {};
        let cb;
        if (Array.isArray(args)) {
            execArgs = args;
            if (typeof options === "function") {
                cb = options;
            } else if (options) {
                execOptions = options;
                cb = callback;
            }
        } else if (typeof args === "function") {
            cb = args;
        } else if (args) {
            execOptions = args;
            cb = options;
        }
        const command = execArgs.length > 0 ? `${file} ${execArgs.join(" ")}` : file;
        return exec(command, execOptions, cb);
    }
    function fork$1() {
        throw new Error("fork is not supported in browser environment");
    }
    class ChildProcess extends EventEmitter {
        pid;
        connected = false;
        killed = false;
        exitCode = null;
        signalCode = null;
        spawnargs = [];
        spawnfile = "";
        stdin;
        stdout;
        stderr;
        constructor(){
            super();
            this.pid = Math.floor(Math.random() * 1e4) + 1e3;
            this.stdin = new Writable();
            this.stdout = new Readable();
            this.stderr = new Readable();
        }
        kill(signal) {
            this.killed = true;
            this.emit("exit", null, signal || "SIGTERM");
            return true;
        }
        disconnect() {
            this.connected = false;
        }
        send(message, callback) {
            if (callback) callback(new Error("IPC not supported"));
            return false;
        }
        ref() {
            return this;
        }
        unref() {
            return this;
        }
    }
    var child_process = {
        exec,
        execSync,
        execFile,
        spawn,
        spawnSync,
        fork: fork$1,
        ChildProcess,
        initChildProcess
    };
    var childProcessShim = Object.freeze({
        __proto__: null,
        ChildProcess: ChildProcess,
        default: child_process,
        exec: exec,
        execFile: execFile,
        execSync: execSync,
        fork: fork$1,
        initChildProcess: initChildProcess,
        spawn: spawn,
        spawnSync: spawnSync
    });
    let globalVFS$2 = null;
    function setVFS$2(vfs) {
        globalVFS$2 = vfs;
    }
    class FSWatcher extends EventEmitter {
        vfs;
        watched = new Map();
        options;
        closed = false;
        ready = false;
        _eventCounts;
        constructor(options = {}){
            super();
            if (!globalVFS$2) {
                throw new Error("chokidar: VirtualFS not initialized. Call setVFS first.");
            }
            this.vfs = globalVFS$2;
            this.options = options;
        }
        shouldIgnore(path) {
            const { ignored } = this.options;
            if (!ignored) return false;
            const ignoreList = Array.isArray(ignored) ? ignored : [
                ignored
            ];
            for (const pattern of ignoreList){
                if (typeof pattern === "string") {
                    if (path === pattern || path.startsWith(pattern + "/")) return true;
                } else if (pattern instanceof RegExp) {
                    if (pattern.test(path)) return true;
                } else if (typeof pattern === "function") {
                    if (pattern(path)) return true;
                }
            }
            return false;
        }
        normalizePath(path) {
            if (this.options.cwd && !path.startsWith("/")) {
                path = this.options.cwd + "/" + path;
            }
            if (!path.startsWith("/")) {
                path = "/" + path;
            }
            return path;
        }
        add(paths) {
            if (this.closed) return this;
            const pathArray = Array.isArray(paths) ? paths : [
                paths
            ];
            const pendingEmits = [];
            console.log("[chokidar] add:", pathArray);
            for (const p of pathArray){
                const normalized = this.normalizePath(p);
                if (this.shouldIgnore(normalized)) continue;
                if (this.watched.has(normalized)) continue;
                try {
                    if (!this.vfs.existsSync(normalized)) {
                        const parentPath = normalized.substring(0, normalized.lastIndexOf("/")) || "/";
                        if (this.vfs.existsSync(parentPath)) {
                            this.watchPath(parentPath, normalized);
                        }
                        continue;
                    }
                    const stats = this.vfs.statSync(normalized);
                    if (!this.options.ignoreInitial) {
                        if (stats.isDirectory()) {
                            this.collectDirContents(normalized, pendingEmits);
                        } else {
                            pendingEmits.push(()=>this.emit("add", normalized, stats));
                        }
                    }
                    this.watchPath(normalized);
                    if (stats.isDirectory()) {
                        this.watchDirRecursive(normalized);
                    }
                } catch (err) {
                    this.emit("error", err);
                }
            }
            if (!this.ready) {
                this.ready = true;
                setTimeout(()=>{
                    for (const emitFn of pendingEmits){
                        emitFn();
                    }
                    this.emit("ready");
                }, 0);
            }
            return this;
        }
        collectDirContents(dirPath, pendingEmits) {
            try {
                const entries = this.vfs.readdirSync(dirPath);
                for (const entry of entries){
                    const fullPath = dirPath === "/" ? "/" + entry : dirPath + "/" + entry;
                    if (this.shouldIgnore(fullPath)) continue;
                    const stats = this.vfs.statSync(fullPath);
                    if (stats.isDirectory()) {
                        pendingEmits.push(()=>this.emit("addDir", fullPath, stats));
                        this.collectDirContents(fullPath, pendingEmits);
                    } else {
                        pendingEmits.push(()=>this.emit("add", fullPath, stats));
                    }
                }
            } catch  {}
        }
        watchPath(path, watchFor) {
            if (this.watched.has(path)) return;
            const watcher = this.vfs.watch(path, {
                recursive: true
            }, (eventType, filename)=>{
                if (this.closed) return;
                let fullPath;
                if (filename) {
                    fullPath = path === "/" ? "/" + filename : path + "/" + filename;
                } else {
                    fullPath = path;
                }
                const eventKey = `${eventType}:${fullPath}`;
                if (!this._eventCounts) this._eventCounts = new Map();
                const count = (this._eventCounts.get(eventKey) || 0) + 1;
                this._eventCounts.set(eventKey, count);
                if (count === 5) {
                    console.warn(`[chokidar] Repeated event: ${eventType} on ${fullPath} (${count}+ times)`);
                }
                console.log("[chokidar] event:", eventType, fullPath);
                if (watchFor && fullPath !== watchFor && !fullPath.startsWith(watchFor + "/")) {
                    return;
                }
                if (this.shouldIgnore(fullPath)) {
                    console.log("[chokidar] ignored:", fullPath);
                    return;
                }
                if (eventType === "rename") {
                    if (this.vfs.existsSync(fullPath)) {
                        try {
                            const stats = this.vfs.statSync(fullPath);
                            if (stats.isDirectory()) {
                                console.log("[chokidar] emit addDir:", fullPath);
                                this.emit("addDir", fullPath, stats);
                            } else {
                                console.log("[chokidar] emit add:", fullPath);
                                this.emit("add", fullPath, stats);
                            }
                        } catch  {}
                    } else {
                        console.log("[chokidar] emit unlink:", fullPath);
                        this.emit("unlink", fullPath);
                    }
                } else if (eventType === "change") {
                    try {
                        const stats = this.vfs.statSync(fullPath);
                        console.log("[chokidar] emit change:", fullPath);
                        this.emit("change", fullPath, stats);
                    } catch  {
                        this.emit("unlink", fullPath);
                    }
                }
            });
            this.watched.set(path, watcher);
        }
        watchDirRecursive(dirPath, depth = 0) {
            if (this.options.depth !== void 0 && depth > this.options.depth) return;
            try {
                const entries = this.vfs.readdirSync(dirPath);
                for (const entry of entries){
                    const fullPath = dirPath === "/" ? "/" + entry : dirPath + "/" + entry;
                    if (this.shouldIgnore(fullPath)) continue;
                    try {
                        const stats = this.vfs.statSync(fullPath);
                        if (stats.isDirectory()) {
                            this.watchPath(fullPath);
                            this.watchDirRecursive(fullPath, depth + 1);
                        }
                    } catch  {}
                }
            } catch  {}
        }
        unwatch(paths) {
            const pathArray = Array.isArray(paths) ? paths : [
                paths
            ];
            for (const p of pathArray){
                const normalized = this.normalizePath(p);
                const watcher = this.watched.get(normalized);
                if (watcher) {
                    watcher.close();
                    this.watched.delete(normalized);
                }
            }
            return this;
        }
        close() {
            this.closed = true;
            for (const watcher of this.watched.values()){
                watcher.close();
            }
            this.watched.clear();
            this.emit("close");
            return Promise.resolve();
        }
        getWatched() {
            const result = {};
            for (const path of this.watched.keys()){
                const dir = path.substring(0, path.lastIndexOf("/")) || "/";
                const basename = path.substring(path.lastIndexOf("/") + 1);
                if (!result[dir]) {
                    result[dir] = [];
                }
                result[dir].push(basename);
            }
            return result;
        }
    }
    function watch$2(paths, options) {
        const watcher = new FSWatcher(options);
        watcher.add(paths);
        return watcher;
    }
    var chokidar = {
        watch: watch$2,
        FSWatcher,
        setVFS: setVFS$2
    };
    var chokidarShim = Object.freeze({
        __proto__: null,
        FSWatcher: FSWatcher,
        default: chokidar,
        setVFS: setVFS$2,
        watch: watch$2
    });
    const CloseEventPolyfill = typeof CloseEvent !== "undefined" ? CloseEvent : class CloseEvent2 extends Event {
        code;
        reason;
        wasClean;
        constructor(type, init){
            super(type);
            this.code = init?.code ?? 1e3;
            this.reason = init?.reason ?? "";
            this.wasClean = init?.wasClean ?? true;
        }
    };
    const MessageEventPolyfill = typeof MessageEvent !== "undefined" ? MessageEvent : class MessageEvent2 extends Event {
        data;
        constructor(type, init){
            super(type);
            this.data = init?.data;
        }
    };
    let messageChannel = null;
    try {
        messageChannel = new BroadcastChannel("vite-ws-channel");
    } catch  {}
    const servers = new Map();
    let clientIdCounter = 0;
    class WebSocket extends EventEmitter {
        static CONNECTING = 0;
        static OPEN = 1;
        static CLOSING = 2;
        static CLOSED = 3;
        CONNECTING = WebSocket.CONNECTING;
        OPEN = WebSocket.OPEN;
        CLOSING = WebSocket.CLOSING;
        CLOSED = WebSocket.CLOSED;
        readyState = WebSocket.CONNECTING;
        url;
        protocol = "";
        extensions = "";
        bufferedAmount = 0;
        binaryType = "blob";
        _id;
        _server = null;
        _nativeWs = null;
        onopen = null;
        onclose = null;
        onerror = null;
        onmessage = null;
        constructor(url, protocols){
            super();
            this.url = url;
            this._id = `client-${++clientIdCounter}`;
            if (protocols) {
                this.protocol = Array.isArray(protocols) ? protocols[0] : protocols;
            }
            setTimeout(()=>this._connect(), 0);
        }
        _connect() {
            if (this.url.startsWith("internal://")) {
                this.readyState = WebSocket.OPEN;
                this.emit("open");
                if (this.onopen) this.onopen(new Event("open"));
                return;
            }
            if (this.url.startsWith("ws://") || this.url.startsWith("wss://")) {
                this._connectNative();
                return;
            }
            if (!messageChannel) {
                setTimeout(()=>{
                    this.readyState = WebSocket.OPEN;
                    this.emit("open");
                    if (this.onopen) this.onopen(new Event("open"));
                }, 0);
                return;
            }
            messageChannel.postMessage({
                type: "connect",
                clientId: this._id,
                url: this.url
            });
            const channel = messageChannel;
            const handler = (event)=>{
                const data = event.data;
                if (data.targetClient !== this._id) return;
                switch(data.type){
                    case "connected":
                        this.readyState = WebSocket.OPEN;
                        this.emit("open");
                        if (this.onopen) this.onopen(new Event("open"));
                        break;
                    case "message":
                        const msgEvent = new MessageEventPolyfill("message", {
                            data: data.payload
                        });
                        this.emit("message", msgEvent);
                        if (this.onmessage) this.onmessage(msgEvent);
                        break;
                    case "close":
                        this.readyState = WebSocket.CLOSED;
                        const closeEvent = new CloseEventPolyfill("close", {
                            code: data.code || 1e3,
                            reason: data.reason || "",
                            wasClean: true
                        });
                        this.emit("close", closeEvent);
                        if (this.onclose) this.onclose(closeEvent);
                        channel.removeEventListener("message", handler);
                        break;
                    case "error":
                        const errorEvent = new Event("error");
                        this.emit("error", errorEvent);
                        if (this.onerror) this.onerror(errorEvent);
                        break;
                }
            };
            channel.addEventListener("message", handler);
            setTimeout(()=>{
                if (this.readyState === WebSocket.CONNECTING) {
                    this.readyState = WebSocket.OPEN;
                    this.emit("open");
                    if (this.onopen) this.onopen(new Event("open"));
                }
            }, 100);
        }
        _connectNative() {
            const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
            const NativeWS = isBrowser && typeof globalThis.WebSocket === "function" && globalThis.WebSocket !== WebSocket ? globalThis.WebSocket : null;
            if (!NativeWS) {
                setTimeout(()=>{
                    this.readyState = WebSocket.OPEN;
                    this.emit("open");
                    if (this.onopen) this.onopen(new Event("open"));
                }, 0);
                return;
            }
            try {
                this._nativeWs = new NativeWS(this.url);
                this._nativeWs.binaryType = this.binaryType === "arraybuffer" ? "arraybuffer" : "blob";
            } catch  {
                this.readyState = WebSocket.CLOSED;
                const errorEvent = new Event("error");
                this.emit("error", errorEvent);
                if (this.onerror) this.onerror(errorEvent);
                return;
            }
            this._nativeWs.onopen = ()=>{
                this.readyState = WebSocket.OPEN;
                this.emit("open");
                if (this.onopen) this.onopen(new Event("open"));
            };
            this._nativeWs.onmessage = (event)=>{
                const msgEvent = new MessageEventPolyfill("message", {
                    data: event.data
                });
                this.emit("message", msgEvent);
                if (this.onmessage) this.onmessage(msgEvent);
            };
            this._nativeWs.onclose = (event)=>{
                this.readyState = WebSocket.CLOSED;
                this._nativeWs = null;
                const closeEvent = new CloseEventPolyfill("close", {
                    code: event.code,
                    reason: event.reason,
                    wasClean: event.wasClean
                });
                this.emit("close", closeEvent);
                if (this.onclose) this.onclose(closeEvent);
            };
            this._nativeWs.onerror = ()=>{
                const errorEvent = new Event("error");
                this.emit("error", errorEvent);
                if (this.onerror) this.onerror(errorEvent);
            };
        }
        send(data) {
            if (this.readyState !== WebSocket.OPEN) {
                throw new Error("WebSocket is not open");
            }
            if (this._nativeWs) {
                this._nativeWs.send(data);
                return;
            }
            if (this._server) {
                this._server._handleClientMessage(this, data);
                return;
            }
            if (messageChannel) {
                messageChannel.postMessage({
                    type: "message",
                    clientId: this._id,
                    url: this.url,
                    payload: data
                });
            }
        }
        close(code, reason) {
            if (this.readyState === WebSocket.CLOSED || this.readyState === WebSocket.CLOSING) {
                return;
            }
            this.readyState = WebSocket.CLOSING;
            if (this._nativeWs) {
                this._nativeWs.close(code, reason);
                return;
            }
            if (messageChannel) {
                messageChannel.postMessage({
                    type: "disconnect",
                    clientId: this._id,
                    url: this.url,
                    code,
                    reason
                });
            }
            setTimeout(()=>{
                this.readyState = WebSocket.CLOSED;
                const closeEvent = new CloseEventPolyfill("close", {
                    code: code || 1e3,
                    reason: reason || "",
                    wasClean: true
                });
                this.emit("close", closeEvent);
                if (this.onclose) this.onclose(closeEvent);
            }, 0);
        }
        ping() {}
        pong() {}
        terminate() {
            if (this._nativeWs) {
                this._nativeWs.close();
                this._nativeWs = null;
            }
            this.readyState = WebSocket.CLOSED;
            const closeEvent = new CloseEventPolyfill("close", {
                code: 1006,
                reason: "Connection terminated",
                wasClean: false
            });
            this.emit("close", closeEvent);
            if (this.onclose) this.onclose(closeEvent);
        }
        _setServer(server) {
            this._server = server;
        }
        _receiveMessage(data) {
            const msgEvent = new MessageEventPolyfill("message", {
                data
            });
            this.emit("message", msgEvent);
            if (this.onmessage) this.onmessage(msgEvent);
        }
    }
    class WebSocketServer extends EventEmitter {
        clients = new Set();
        options;
        _path;
        _channelHandler = null;
        constructor(options = {}){
            super();
            this.options = options;
            this._path = options.path || "/";
            if (!options.noServer) {
                this._setupListener();
            }
            servers.set(this._path, this);
        }
        _setupListener() {
            if (!messageChannel) return;
            const channel = messageChannel;
            this._channelHandler = (event)=>{
                const data = event.data;
                if (data.type === "connect") {
                    const ws = new WebSocket("internal://" + this._path);
                    ws._setServer(this);
                    ws._clientId = data.clientId;
                    this.clients.add(ws);
                    channel.postMessage({
                        type: "connected",
                        targetClient: data.clientId
                    });
                    this.emit("connection", ws, {
                        url: data.url
                    });
                }
                if (data.type === "message") {
                    for (const client of this.clients){
                        if (client._clientId === data.clientId) {
                            client._receiveMessage(data.payload);
                            break;
                        }
                    }
                }
                if (data.type === "disconnect") {
                    for (const client of this.clients){
                        if (client._clientId === data.clientId) {
                            client.close(data.code, data.reason);
                            this.clients.delete(client);
                            break;
                        }
                    }
                }
            };
            channel.addEventListener("message", this._channelHandler);
        }
        _handleClientMessage(client, data) {
            const msgEvent = new MessageEventPolyfill("message", {
                data
            });
            client.emit("message", msgEvent);
        }
        handleUpgrade(request, socket, head, callback) {
            const ws = new WebSocket("internal://" + this._path);
            ws._setServer(this);
            if (this.options.clientTracking !== false) {
                this.clients.add(ws);
            }
            setTimeout(()=>{
                callback(ws, request);
                this.emit("connection", ws, request);
            }, 0);
        }
        close(callback) {
            for (const client of this.clients){
                client.close(1001, "Server shutting down");
            }
            this.clients.clear();
            servers.delete(this._path);
            if (this._channelHandler && messageChannel) {
                messageChannel.removeEventListener("message", this._channelHandler);
                this._channelHandler = null;
            }
            this.emit("close");
            if (callback) {
                setTimeout(callback, 0);
            }
        }
        address() {
            return {
                port: this.options.port || 0,
                family: "IPv4",
                address: this.options.host || "0.0.0.0"
            };
        }
    }
    const Server$1 = WebSocketServer;
    const createWebSocketStream = ()=>{
        throw new Error("createWebSocketStream is not supported in browser");
    };
    var wsShim = Object.freeze({
        __proto__: null,
        Server: Server$1,
        WebSocket: WebSocket,
        WebSocketServer: WebSocketServer,
        createWebSocketStream: createWebSocketStream,
        default: WebSocket
    });
    const constants$1 = {
        kFSEventStreamEventFlagNone: 0,
        kFSEventStreamEventFlagMustScanSubDirs: 1,
        kFSEventStreamEventFlagUserDropped: 2,
        kFSEventStreamEventFlagKernelDropped: 4,
        kFSEventStreamEventFlagEventIdsWrapped: 8,
        kFSEventStreamEventFlagHistoryDone: 16,
        kFSEventStreamEventFlagRootChanged: 32,
        kFSEventStreamEventFlagMount: 64,
        kFSEventStreamEventFlagUnmount: 128,
        kFSEventStreamEventFlagItemCreated: 256,
        kFSEventStreamEventFlagItemRemoved: 512,
        kFSEventStreamEventFlagItemInodeMetaMod: 1024,
        kFSEventStreamEventFlagItemRenamed: 2048,
        kFSEventStreamEventFlagItemModified: 4096,
        kFSEventStreamEventFlagItemFinderInfoMod: 8192,
        kFSEventStreamEventFlagItemChangeOwner: 16384,
        kFSEventStreamEventFlagItemXattrMod: 32768,
        kFSEventStreamEventFlagItemIsFile: 65536,
        kFSEventStreamEventFlagItemIsDir: 131072,
        kFSEventStreamEventFlagItemIsSymlink: 262144
    };
    function watch$1(path, handler) {
        return ()=>Promise.resolve();
    }
    function getInfo(path, flags) {
        return {
            event: "unknown",
            path,
            type: "file",
            changes: {
                inode: false,
                finder: false,
                access: false,
                xattrs: false
            },
            flags
        };
    }
    var fsevents = {
        watch: watch$1,
        getInfo,
        constants: constants$1
    };
    var fseventsShim = Object.freeze({
        __proto__: null,
        constants: constants$1,
        default: fsevents,
        getInfo: getInfo,
        watch: watch$1
    });
    let globalVFS$1 = null;
    function setVFS$1(vfs) {
        globalVFS$1 = vfs;
    }
    class ReaddirpStream {
        options;
        root;
        entries = [];
        index = 0;
        collected = false;
        constructor(root, options = {}){
            this.root = root;
            this.options = options;
        }
        matchFilter(entry, filter) {
            if (!filter) return true;
            if (typeof filter === "function") {
                return filter(entry);
            }
            const patterns = Array.isArray(filter) ? filter : [
                filter
            ];
            for (const pattern of patterns){
                if (pattern.startsWith("!")) {
                    const posPattern = pattern.slice(1);
                    if (this.matchGlob(entry.basename, posPattern)) {
                        return false;
                    }
                } else if (this.matchGlob(entry.basename, pattern)) {
                    return true;
                }
            }
            return patterns.length === 0 || patterns.every((p)=>p.startsWith("!"));
        }
        matchGlob(name, pattern) {
            if (pattern === "*") return true;
            if (pattern.startsWith("*.")) {
                const ext = pattern.slice(1);
                return name.endsWith(ext);
            }
            if (pattern.endsWith("*")) {
                const prefix = pattern.slice(0, -1);
                return name.startsWith(prefix);
            }
            return name === pattern;
        }
        collect(dir, depth, relativePath = "") {
            if (!globalVFS$1) return;
            if (this.options.depth !== void 0 && depth > this.options.depth) return;
            try {
                const entries = globalVFS$1.readdirSync(dir);
                for (const name of entries){
                    const fullPath = dir === "/" ? "/" + name : dir + "/" + name;
                    const relPath = relativePath ? relativePath + "/" + name : name;
                    try {
                        const stats = globalVFS$1.statSync(fullPath);
                        const isDir = stats.isDirectory();
                        const entry = {
                            path: relPath,
                            fullPath,
                            basename: name,
                            stats: this.options.alwaysStat ? stats : void 0,
                            dirent: {
                                isFile: ()=>!isDir,
                                isDirectory: ()=>isDir,
                                name
                            }
                        };
                        const type = this.options.type || "files";
                        if (isDir) {
                            if (!this.matchFilter(entry, this.options.directoryFilter)) {
                                continue;
                            }
                            if (type === "directories" || type === "files_directories" || type === "all") {
                                this.entries.push(entry);
                            }
                            this.collect(fullPath, depth + 1, relPath);
                        } else {
                            if (type === "files" || type === "files_directories" || type === "all") {
                                if (this.matchFilter(entry, this.options.fileFilter)) {
                                    this.entries.push(entry);
                                }
                            }
                        }
                    } catch  {}
                }
            } catch  {}
        }
        async *[Symbol.asyncIterator]() {
            if (!this.collected) {
                this.collect(this.root, 0);
                this.collected = true;
            }
            for (const entry of this.entries){
                yield entry;
            }
        }
        async toArray() {
            if (!this.collected) {
                this.collect(this.root, 0);
                this.collected = true;
            }
            return [
                ...this.entries
            ];
        }
        on(event, callback) {
            if (event === "data") {
                setTimeout(async ()=>{
                    if (!this.collected) {
                        this.collect(this.root, 0);
                        this.collected = true;
                    }
                    for (const entry of this.entries){
                        callback(entry);
                    }
                    this.emit("end");
                }, 0);
            }
            return this;
        }
        listeners = new Map();
        emit(event, ...args) {
            const handlers = this.listeners.get(event);
            if (handlers) {
                for (const handler of handlers){
                    handler(...args);
                }
            }
        }
        once(event, callback) {
            const wrapper = (...args)=>{
                callback(...args);
                this.off(event, wrapper);
            };
            return this.on(event, wrapper);
        }
        off(event, callback) {
            const handlers = this.listeners.get(event);
            if (handlers) {
                const index = handlers.indexOf(callback);
                if (index !== -1) {
                    handlers.splice(index, 1);
                }
            }
            return this;
        }
    }
    function readdirp(root, options) {
        return new ReaddirpStream(root, options);
    }
    async function readdirpPromise(root, options) {
        const stream = new ReaddirpStream(root, options);
        return stream.toArray();
    }
    var readdirpShim = Object.freeze({
        __proto__: null,
        ReaddirpStream: ReaddirpStream,
        default: readdirp,
        readdirp: readdirp,
        readdirpPromise: readdirpPromise,
        setVFS: setVFS$1
    });
    function createRequire$1(filename) {
        return function require(id) {
            throw new Error(`Cannot find module '${id}' from '${filename}'`);
        };
    }
    const builtinModules$1 = [
        "assert",
        "buffer",
        "child_process",
        "cluster",
        "console",
        "constants",
        "crypto",
        "dgram",
        "dns",
        "domain",
        "events",
        "fs",
        "http",
        "https",
        "module",
        "net",
        "os",
        "path",
        "perf_hooks",
        "process",
        "punycode",
        "querystring",
        "readline",
        "repl",
        "stream",
        "string_decoder",
        "sys",
        "timers",
        "tls",
        "tty",
        "url",
        "util",
        "v8",
        "vm",
        "worker_threads",
        "zlib"
    ];
    function isBuiltin(moduleName) {
        const name = moduleName.startsWith("node:") ? moduleName.slice(5) : moduleName;
        return builtinModules$1.includes(name);
    }
    const _cache = {};
    const _extensions = {
        ".js": ()=>{},
        ".json": ()=>{},
        ".node": ()=>{}
    };
    const _pathCache = {};
    function syncBuiltinESMExports() {}
    const Module$1 = {
        createRequire: createRequire$1,
        builtinModules: builtinModules$1,
        isBuiltin,
        _cache,
        _extensions,
        _pathCache,
        syncBuiltinESMExports
    };
    var moduleShim = Object.freeze({
        __proto__: null,
        Module: Module$1,
        _cache: _cache,
        _extensions: _extensions,
        _pathCache: _pathCache,
        builtinModules: builtinModules$1,
        createRequire: createRequire$1,
        default: Module$1,
        isBuiltin: isBuiltin,
        syncBuiltinESMExports: syncBuiltinESMExports
    });
    const performance$1 = globalThis.performance || {
        now: ()=>Date.now(),
        timeOrigin: Date.now(),
        mark: ()=>{},
        measure: ()=>{},
        getEntries: ()=>[],
        getEntriesByName: ()=>[],
        getEntriesByType: ()=>[],
        clearMarks: ()=>{},
        clearMeasures: ()=>{},
        clearResourceTimings: ()=>{}
    };
    class PerformanceObserver {
        callback;
        entryTypes = [];
        constructor(callback){
            this.callback = callback;
        }
        observe(options) {
            this.entryTypes = options.entryTypes || (options.type ? [
                options.type
            ] : []);
        }
        disconnect() {
            this.entryTypes = [];
        }
        takeRecords() {
            return [];
        }
        static supportedEntryTypes = [
            "mark",
            "measure",
            "resource",
            "navigation"
        ];
    }
    class Histogram {
        min = 0;
        max = 0;
        mean = 0;
        stddev = 0;
        percentiles = new Map();
        exceeds = 0;
        reset() {
            this.min = 0;
            this.max = 0;
            this.mean = 0;
            this.stddev = 0;
            this.percentiles.clear();
            this.exceeds = 0;
        }
        percentile(percentile) {
            return this.percentiles.get(percentile) || 0;
        }
    }
    function createHistogram() {
        return new Histogram();
    }
    function monitorEventLoopDelay(options) {
        const histogram = new Histogram();
        return histogram;
    }
    var perf_hooks = {
        performance: performance$1,
        PerformanceObserver,
        createHistogram,
        monitorEventLoopDelay
    };
    var perfHooksShim = Object.freeze({
        __proto__: null,
        Histogram: Histogram,
        PerformanceObserver: PerformanceObserver,
        createHistogram: createHistogram,
        default: perf_hooks,
        monitorEventLoopDelay: monitorEventLoopDelay,
        performance: performance$1
    });
    const isMainThread = true;
    const parentPort = null;
    const workerData = null;
    const threadId = 0;
    let Worker$1 = class Worker extends EventEmitter {
        threadId = 0;
        resourceLimits = {};
        constructor(filename, options){
            super();
            console.warn("Worker threads are not fully supported in browser environment");
        }
        postMessage(value, transferList) {}
        terminate() {
            return Promise.resolve(0);
        }
        ref() {}
        unref() {}
        getHeapSnapshot() {
            return Promise.resolve({});
        }
    };
    let MessageChannel$1 = class MessageChannel {
        port1 = new MessagePort();
        port2 = new MessagePort();
    };
    class MessagePort extends EventEmitter {
        postMessage(value, transferList) {}
        start() {}
        close() {}
        ref() {}
        unref() {}
    }
    let BroadcastChannel$1 = class BroadcastChannel extends EventEmitter {
        name;
        constructor(name){
            super();
            this.name = name;
        }
        postMessage(message) {}
        close() {}
        ref() {}
        unref() {}
    };
    function moveMessagePortToContext(port, contextifiedSandbox) {
        return port;
    }
    function receiveMessageOnPort(port) {
        return void 0;
    }
    const SHARE_ENV = Symbol.for("nodejs.worker_threads.SHARE_ENV");
    function markAsUntransferable(object) {}
    function getEnvironmentData(key) {
        return void 0;
    }
    function setEnvironmentData(key, value) {}
    var worker_threads = {
        isMainThread,
        parentPort,
        workerData,
        threadId,
        Worker: Worker$1,
        MessageChannel: MessageChannel$1,
        MessagePort,
        BroadcastChannel: BroadcastChannel$1,
        moveMessagePortToContext,
        receiveMessageOnPort,
        SHARE_ENV,
        markAsUntransferable,
        getEnvironmentData,
        setEnvironmentData
    };
    var workerThreadsShim = Object.freeze({
        __proto__: null,
        BroadcastChannel: BroadcastChannel$1,
        MessageChannel: MessageChannel$1,
        MessagePort: MessagePort,
        SHARE_ENV: SHARE_ENV,
        Worker: Worker$1,
        default: worker_threads,
        getEnvironmentData: getEnvironmentData,
        isMainThread: isMainThread,
        markAsUntransferable: markAsUntransferable,
        moveMessagePortToContext: moveMessagePortToContext,
        parentPort: parentPort,
        receiveMessageOnPort: receiveMessageOnPort,
        setEnvironmentData: setEnvironmentData,
        threadId: threadId,
        workerData: workerData
    });
    const EXPORT_CONDITION_PRIORITY = [
        "convex",
        "module",
        "import",
        "require",
        "default"
    ];
    function resolveExportConditions(entry) {
        if (typeof entry === "string") {
            return entry;
        }
        if (typeof entry === "object" && entry !== null) {
            for (const condition of EXPORT_CONDITION_PRIORITY){
                const conditionValue = entry[condition];
                if (conditionValue !== void 0) {
                    const result = resolveExportConditions(conditionValue);
                    if (result) {
                        return result;
                    }
                }
            }
        }
        return void 0;
    }
    function resolveNodeModuleImport(vfs, importPath, extensions) {
        const pathParts = importPath.split("/");
        const isScoped = pathParts[0].startsWith("@");
        const moduleName = isScoped ? pathParts.slice(0, 2).join("/") : pathParts[0];
        const subPath = isScoped ? pathParts.slice(2).join("/") : pathParts.slice(1).join("/");
        const nodeModulesBase = "/project/node_modules/" + moduleName;
        if (!vfs.existsSync(nodeModulesBase)) {
            return null;
        }
        const packageJsonPath = nodeModulesBase + "/package.json";
        if (!vfs.existsSync(packageJsonPath)) {
            return null;
        }
        try {
            const packageJsonContent = vfs.readFileSync(packageJsonPath, "utf8");
            const packageJson = JSON.parse(packageJsonContent);
            let resolvedPath = null;
            if (subPath) {
                resolvedPath = resolveSubpathImport(vfs, packageJson, nodeModulesBase, subPath, extensions);
            } else {
                resolvedPath = resolveMainImport(vfs, packageJson, nodeModulesBase, extensions);
            }
            if (resolvedPath) {
                return {
                    path: resolvedPath,
                    pluginData: {
                        fromVFS: true
                    }
                };
            }
        } catch  {}
        return null;
    }
    function resolveSubpathImport(vfs, packageJson, nodeModulesBase, subPath, extensions) {
        if (packageJson.exports && typeof packageJson.exports === "object") {
            const exportKey = "./" + subPath;
            const exportsMap = packageJson.exports;
            const exportEntry = exportsMap[exportKey];
            if (exportEntry) {
                const exportPath = resolveExportConditions(exportEntry);
                if (exportPath) {
                    const resolvedPath = nodeModulesBase + "/" + exportPath.replace(/^\.\//, "");
                    const foundPath = findVFSFile(vfs, resolvedPath, [
                        "",
                        ".js",
                        ".ts",
                        ".mjs"
                    ]);
                    if (foundPath) {
                        return foundPath;
                    }
                }
            }
        }
        const directPath = nodeModulesBase + "/" + subPath;
        return findVFSFile(vfs, directPath, extensions);
    }
    function resolveMainImport(vfs, packageJson, nodeModulesBase, extensions) {
        if (packageJson.exports) {
            const mainExport = typeof packageJson.exports === "object" && !Array.isArray(packageJson.exports) ? packageJson.exports["."] || packageJson.exports : packageJson.exports;
            const exportPath = resolveExportConditions(mainExport);
            if (exportPath) {
                const resolvedPath2 = nodeModulesBase + "/" + exportPath.replace(/^\.\//, "");
                const foundPath = findVFSFile(vfs, resolvedPath2, [
                    "",
                    ".js",
                    ".ts",
                    ".mjs"
                ]);
                if (foundPath) {
                    return foundPath;
                }
            }
        }
        const mainField = packageJson.module || packageJson.main || "index.js";
        const resolvedPath = nodeModulesBase + "/" + mainField.replace(/^\.\//, "");
        return findVFSFile(vfs, resolvedPath, extensions);
    }
    let esbuildInstance = null;
    let initPromise = null;
    let wasmURL = "https://unpkg.com/esbuild-wasm@0.20.0/esbuild.wasm";
    let globalVFS = null;
    function setVFS(vfs) {
        globalVFS = vfs;
    }
    function setWasmURL(url) {
        wasmURL = url;
    }
    async function initialize(options) {
        if (esbuildInstance) {
            return;
        }
        if (typeof window !== "undefined" && window.__esbuild) {
            esbuildInstance = window.__esbuild;
            return;
        }
        if (typeof window !== "undefined" && window.__esbuildInitPromise) {
            await window.__esbuildInitPromise;
            if (window.__esbuild) {
                esbuildInstance = window.__esbuild;
                return;
            }
        }
        if (initPromise) {
            return initPromise;
        }
        initPromise = (async ()=>{
            try {
                const esbuild = await import('https://unpkg.com/esbuild-wasm@0.20.0/esm/browser.min.js').then(async (m)=>{
                    await m.__tla;
                    return m;
                });
                await esbuild.initialize({
                    wasmURL: options?.wasmURL || wasmURL
                });
                esbuildInstance = esbuild;
            } catch (error) {
                initPromise = null;
                throw new Error(`Failed to initialize esbuild-wasm: ${error}`);
            }
        })();
        return initPromise;
    }
    function isInitialized() {
        return esbuildInstance !== null;
    }
    async function transform(code, options) {
        if (!esbuildInstance) {
            await initialize();
        }
        if (!esbuildInstance) {
            throw new Error("esbuild not initialized");
        }
        return esbuildInstance.transform(code, options);
    }
    function transformSync(code, options) {
        if (!esbuildInstance) {
            throw new Error("esbuild not initialized. Call initialize() first.");
        }
        throw new Error("transformSync is not available in browser. Use transform() instead.");
    }
    async function transformToCommonJS(code, options) {
        const result = await transform(code, {
            loader: options?.loader || "js",
            format: "cjs",
            target: "es2020"
        });
        return result.code;
    }
    function remapVFSPath(path) {
        if (path === "/convex" || path.startsWith("/convex/")) {
            return "/project" + path;
        }
        return path;
    }
    function findVFSFile(vfs, originalPath, extensions) {
        for (const ext of extensions){
            const pathWithExt = originalPath + ext;
            if (vfs.existsSync(pathWithExt)) {
                return pathWithExt;
            }
            const remapped = remapVFSPath(pathWithExt);
            if (remapped !== pathWithExt && vfs.existsSync(remapped)) {
                return pathWithExt;
            }
        }
        return null;
    }
    function createVFSPlugin() {
        if (!globalVFS) {
            return null;
        }
        const vfs = globalVFS;
        return {
            name: "vfs-loader",
            setup (build2) {
                const b = build2;
                b.onResolve({
                    filter: /.*/
                }, (args)=>{
                    const { path: importPath, importer } = args;
                    if (importPath.startsWith("node_modules/")) {
                        return {
                            external: true
                        };
                    }
                    const extensions = [
                        "",
                        ".ts",
                        ".tsx",
                        ".js",
                        ".jsx",
                        ".json"
                    ];
                    if (importPath.startsWith("/")) {
                        const foundPath = findVFSFile(vfs, importPath, extensions);
                        if (foundPath) {
                            return {
                                path: foundPath,
                                pluginData: {
                                    fromVFS: true
                                }
                            };
                        }
                        return {
                            external: true
                        };
                    }
                    if (importPath.startsWith(".")) {
                        let resolved = importPath;
                        if (importer) {
                            const importerDir = importer.substring(0, importer.lastIndexOf("/"));
                            resolved = importerDir + "/" + importPath;
                        }
                        const parts = resolved.split("/").filter(Boolean);
                        const normalized = [];
                        for (const part of parts){
                            if (part === "..") {
                                normalized.pop();
                            } else if (part !== ".") {
                                normalized.push(part);
                            }
                        }
                        resolved = "/" + normalized.join("/");
                        const foundPath = findVFSFile(vfs, resolved, extensions);
                        if (foundPath) {
                            return {
                                path: foundPath,
                                pluginData: {
                                    fromVFS: true
                                }
                            };
                        }
                        for (const ext of [
                            ".ts",
                            ".tsx",
                            ".js",
                            ".jsx"
                        ]){
                            const indexPath = resolved + "/index" + ext;
                            const foundIndex = findVFSFile(vfs, indexPath, [
                                ""
                            ]);
                            if (foundIndex) {
                                return {
                                    path: foundIndex,
                                    pluginData: {
                                        fromVFS: true
                                    }
                                };
                            }
                        }
                    }
                    const resolution = resolveNodeModuleImport(vfs, importPath, extensions);
                    if (resolution) {
                        return resolution;
                    }
                    return {
                        external: true
                    };
                });
                b.onLoad({
                    filter: /^\/.*/
                }, (args)=>{
                    if (!args.pluginData?.fromVFS) {
                        return null;
                    }
                    try {
                        let contents;
                        const originalPath = args.path;
                        const remappedPath = remapVFSPath(originalPath);
                        if (vfs.existsSync(originalPath)) {
                            contents = vfs.readFileSync(originalPath, "utf8");
                        } else if (remappedPath !== originalPath && vfs.existsSync(remappedPath)) {
                            contents = vfs.readFileSync(remappedPath, "utf8");
                        } else {
                            throw new Error(`File not found: ${originalPath} (tried ${remappedPath})`);
                        }
                        const ext = originalPath.substring(originalPath.lastIndexOf("."));
                        let loader = "ts";
                        if (ext === ".tsx") loader = "tsx";
                        else if (ext === ".js") loader = "js";
                        else if (ext === ".jsx") loader = "jsx";
                        else if (ext === ".json") loader = "json";
                        return {
                            contents,
                            loader
                        };
                    } catch (err) {
                        return {
                            errors: [
                                {
                                    text: `Failed to load ${args.path}: ${err}`
                                }
                            ]
                        };
                    }
                });
            }
        };
    }
    async function build(options) {
        if (!esbuildInstance) {
            await initialize();
        }
        if (!esbuildInstance) {
            throw new Error("esbuild not initialized");
        }
        const vfsPlugin = createVFSPlugin();
        const plugins = [
            ...options.plugins || []
        ];
        if (vfsPlugin) {
            plugins.unshift(vfsPlugin);
        }
        let entryPoints = options.entryPoints;
        if (entryPoints && globalVFS) {
            const absWorkingDir = options.absWorkingDir || (typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/");
            entryPoints = entryPoints.map((ep)=>{
                if (ep.includes("vfs:")) {
                    const vfsIndex = ep.indexOf("vfs:");
                    ep = ep.substring(vfsIndex + 4);
                }
                if (ep.startsWith("/")) {
                    return ep;
                }
                if (ep.startsWith("./")) {
                    const base = absWorkingDir.endsWith("/") ? absWorkingDir.slice(0, -1) : absWorkingDir;
                    const relative = ep.slice(2);
                    const resolved = base + "/" + relative;
                    return resolved;
                }
                if (ep.startsWith("../")) {
                    const base = absWorkingDir.endsWith("/") ? absWorkingDir.slice(0, -1) : absWorkingDir;
                    const parts = base.split("/").filter(Boolean);
                    parts.pop();
                    const relative = ep.slice(3);
                    const resolved = "/" + parts.join("/") + "/" + relative;
                    return resolved;
                }
                return ep;
            });
        }
        const resolvedAbsWorkingDir = options.absWorkingDir || (typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/");
        const result = await esbuildInstance.build({
            ...options,
            entryPoints,
            plugins,
            write: false,
            absWorkingDir: resolvedAbsWorkingDir
        });
        if (result.outputFiles) {
            for (const file of result.outputFiles){
                if (file.path.includes("vfs:")) {
                    file.path = file.path.replace(/vfs:/g, "");
                }
            }
        }
        return result;
    }
    function buildSync(_options) {
        throw new Error("buildSync is not available in browser. Use build() instead.");
    }
    function version() {
        return "0.20.0";
    }
    async function context(_options) {
        throw new Error("esbuild context API is not supported in browser");
    }
    var esbuild = {
        initialize,
        isInitialized,
        transform,
        transformSync,
        transformToCommonJS,
        build,
        buildSync,
        context,
        version,
        setWasmURL,
        setVFS
    };
    var esbuildShim = Object.freeze({
        __proto__: null,
        build: build,
        buildSync: buildSync,
        context: context,
        default: esbuild,
        initialize: initialize,
        isInitialized: isInitialized,
        setVFS: setVFS,
        setWasmURL: setWasmURL,
        transform: transform,
        transformSync: transformSync,
        transformToCommonJS: transformToCommonJS,
        version: version
    });
    let rollupInstance = null;
    let loadPromise = null;
    async function loadRollup() {
        if (rollupInstance) return rollupInstance;
        if (loadPromise) return loadPromise;
        loadPromise = (async ()=>{
            try {
                const rollup2 = await import('https://esm.sh/@rollup/browser@4.9.0').then(async (m)=>{
                    await m.__tla;
                    return m;
                });
                rollupInstance = rollup2;
                console.log("[rollup] Browser version loaded");
                return rollup2;
            } catch (error) {
                console.error("[rollup] Failed to load browser version:", error);
                loadPromise = null;
                throw error;
            }
        })();
        return loadPromise;
    }
    const VERSION = "4.9.0";
    async function rollup(options) {
        const r = await loadRollup();
        return r.rollup(options);
    }
    async function watch(options) {
        const r = await loadRollup();
        return r.watch(options);
    }
    function getPackageBase() {
        return "";
    }
    var rollup_default = {
        VERSION,
        rollup,
        watch,
        loadRollup
    };
    var rollupShim = Object.freeze({
        __proto__: null,
        VERSION: VERSION,
        default: rollup_default,
        getPackageBase: getPackageBase,
        loadRollup: loadRollup,
        rollup: rollup,
        watch: watch
    });
    function getHeapStatistics() {
        return {
            total_heap_size: 0,
            total_heap_size_executable: 0,
            total_physical_size: 0,
            total_available_size: 0,
            used_heap_size: 0,
            heap_size_limit: 0,
            malloced_memory: 0,
            peak_malloced_memory: 0,
            does_zap_garbage: 0,
            number_of_native_contexts: 0,
            number_of_detached_contexts: 0
        };
    }
    function getHeapSpaceStatistics() {
        return [];
    }
    function getHeapCodeStatistics() {
        return {
            code_and_metadata_size: 0,
            bytecode_and_metadata_size: 0,
            external_script_source_size: 0
        };
    }
    function getHeapSnapshot() {
        return null;
    }
    function writeHeapSnapshot() {
        return "";
    }
    function setFlagsFromString(_flags) {}
    function takeCoverage() {}
    function stopCoverage() {}
    function serialize(value) {
        const json = JSON.stringify(value);
        return Buffer.from(json);
    }
    function deserialize(buffer) {
        return JSON.parse(buffer.toString());
    }
    class Serializer {
        writeHeader() {}
        writeValue(_value) {}
        releaseBuffer() {
            return Buffer.from("");
        }
    }
    class Deserializer {
        constructor(_buffer){}
        readHeader() {
            return true;
        }
        readValue() {
            return null;
        }
    }
    class DefaultSerializer extends Serializer {
    }
    class DefaultDeserializer extends Deserializer {
    }
    function promiseHooks() {
        return {
            onInit: ()=>{},
            onSettled: ()=>{},
            onBefore: ()=>{},
            onAfter: ()=>{},
            createHook: ()=>({
                    enable: ()=>{},
                    disable: ()=>{}
                })
        };
    }
    var v8 = {
        getHeapStatistics,
        getHeapSpaceStatistics,
        getHeapCodeStatistics,
        getHeapSnapshot,
        writeHeapSnapshot,
        setFlagsFromString,
        takeCoverage,
        stopCoverage,
        serialize,
        deserialize,
        Serializer,
        Deserializer,
        DefaultSerializer,
        DefaultDeserializer,
        promiseHooks
    };
    var v8Shim = Object.freeze({
        __proto__: null,
        DefaultDeserializer: DefaultDeserializer,
        DefaultSerializer: DefaultSerializer,
        Deserializer: Deserializer,
        Serializer: Serializer,
        default: v8,
        deserialize: deserialize,
        getHeapCodeStatistics: getHeapCodeStatistics,
        getHeapSnapshot: getHeapSnapshot,
        getHeapSpaceStatistics: getHeapSpaceStatistics,
        getHeapStatistics: getHeapStatistics,
        promiseHooks: promiseHooks,
        serialize: serialize,
        setFlagsFromString: setFlagsFromString,
        stopCoverage: stopCoverage,
        takeCoverage: takeCoverage,
        writeHeapSnapshot: writeHeapSnapshot
    });
    class Interface extends EventEmitter {
        promptText;
        constructor(_options){
            super();
            this.promptText = _options?.prompt ?? "";
        }
        prompt(_preserveCursor) {}
        setPrompt(prompt) {
            this.promptText = prompt;
        }
        getPrompt() {
            return this.promptText;
        }
        question(_query, callback) {
            setTimeout(()=>callback(""), 0);
        }
        pause() {
            return this;
        }
        resume() {
            return this;
        }
        close() {
            this.emit("close");
        }
        write(_data, _key) {}
        line = "";
        cursor = 0;
        getCursorPos() {
            return {
                rows: 0,
                cols: 0
            };
        }
    }
    function createInterface(options) {
        return new Interface(options);
    }
    function clearLine(_stream, _dir, _callback) {
        _callback?.();
        return true;
    }
    function clearScreenDown(_stream, _callback) {
        _callback?.();
        return true;
    }
    function cursorTo(_stream, _x, _y, _callback) {
        _callback?.();
        return true;
    }
    function moveCursor(_stream, _dx, _dy, _callback) {
        _callback?.();
        return true;
    }
    function emitKeypressEvents(_stream, _interface) {}
    const promises = {
        createInterface: (options)=>{
            const rl = createInterface(options);
            return {
                question: (query)=>new Promise((resolve)=>{
                        rl.question(query, resolve);
                    }),
                close: ()=>rl.close(),
                [Symbol.asyncIterator]: async function*() {}
            };
        }
    };
    var readline = {
        Interface,
        createInterface,
        clearLine,
        clearScreenDown,
        cursorTo,
        moveCursor,
        emitKeypressEvents,
        promises
    };
    var readlineShim = Object.freeze({
        __proto__: null,
        Interface: Interface,
        clearLine: clearLine,
        clearScreenDown: clearScreenDown,
        createInterface: createInterface,
        cursorTo: cursorTo,
        default: readline,
        emitKeypressEvents: emitKeypressEvents,
        moveCursor: moveCursor,
        promises: promises
    });
    class TLSSocket extends EventEmitter {
        authorized = false;
        encrypted = true;
        constructor(_socket, _options){
            super();
        }
        getPeerCertificate(_detailed) {
            return {};
        }
        getCipher() {
            return null;
        }
        getProtocol() {
            return null;
        }
        setServername(_name) {}
        renegotiate(_options, _callback) {
            return false;
        }
    }
    class Server extends EventEmitter {
        constructor(_options, _connectionListener){
            super();
        }
        listen(..._args) {
            return this;
        }
        close(_callback) {
            return this;
        }
        address() {
            return null;
        }
        getTicketKeys() {
            return Buffer.from("");
        }
        setTicketKeys(_keys) {}
        setSecureContext(_options) {}
    }
    function createServer$1(_options, _connectionListener) {
        return new Server(_options, _connectionListener);
    }
    function connect$1(_options, _callback) {
        const socket = new TLSSocket();
        if (_callback) {
            setTimeout(_callback, 0);
        }
        return socket;
    }
    const createSecureContext = (_options)=>({});
    const getCiphers = ()=>[
            "TLS_AES_256_GCM_SHA384",
            "TLS_AES_128_GCM_SHA256"
        ];
    const DEFAULT_ECDH_CURVE = "auto";
    const DEFAULT_MAX_VERSION = "TLSv1.3";
    const DEFAULT_MIN_VERSION = "TLSv1.2";
    const rootCertificates = [];
    var tls = {
        TLSSocket,
        Server,
        createServer: createServer$1,
        connect: connect$1,
        createSecureContext,
        getCiphers,
        DEFAULT_ECDH_CURVE,
        DEFAULT_MAX_VERSION,
        DEFAULT_MIN_VERSION,
        rootCertificates
    };
    var tlsShim = Object.freeze({
        __proto__: null,
        DEFAULT_ECDH_CURVE: DEFAULT_ECDH_CURVE,
        DEFAULT_MAX_VERSION: DEFAULT_MAX_VERSION,
        DEFAULT_MIN_VERSION: DEFAULT_MIN_VERSION,
        Server: Server,
        TLSSocket: TLSSocket,
        connect: connect$1,
        createSecureContext: createSecureContext,
        createServer: createServer$1,
        default: tls,
        getCiphers: getCiphers,
        rootCertificates: rootCertificates
    });
    class Http2Session extends EventEmitter {
        close(_callback) {
            if (_callback) setTimeout(_callback, 0);
        }
        destroy(_error, _code) {}
        get destroyed() {
            return false;
        }
        get encrypted() {
            return false;
        }
        get closed() {
            return false;
        }
        ping(_callback) {
            return false;
        }
        ref() {}
        unref() {}
        setTimeout(_msecs, _callback) {}
    }
    class ClientHttp2Session extends Http2Session {
    }
    class ServerHttp2Session extends Http2Session {
    }
    class Http2Stream extends EventEmitter {
        close(_code, _callback) {}
        get id() {
            return 0;
        }
        get pending() {
            return false;
        }
        get destroyed() {
            return false;
        }
        get closed() {
            return false;
        }
        priority(_options) {}
        setTimeout(_msecs, _callback) {}
        end(_data, _encoding, _callback) {}
    }
    class Http2ServerRequest extends EventEmitter {
    }
    class Http2ServerResponse extends EventEmitter {
        writeHead(_statusCode, _headers) {
            return this;
        }
        end(_data) {}
    }
    function createServer(_options, _onRequestHandler) {
        return new EventEmitter();
    }
    function createSecureServer(_options, _onRequestHandler) {
        return new EventEmitter();
    }
    function connect(_authority, _options, _listener) {
        return new ClientHttp2Session();
    }
    const constants = {
        NGHTTP2_SESSION_SERVER: 0,
        NGHTTP2_SESSION_CLIENT: 1,
        HTTP2_HEADER_STATUS: ":status",
        HTTP2_HEADER_METHOD: ":method",
        HTTP2_HEADER_AUTHORITY: ":authority",
        HTTP2_HEADER_SCHEME: ":scheme",
        HTTP2_HEADER_PATH: ":path",
        HTTP_STATUS_OK: 200,
        HTTP_STATUS_NOT_FOUND: 404
    };
    function getDefaultSettings() {
        return {};
    }
    function getPackedSettings(_settings) {
        return Buffer.from("");
    }
    function getUnpackedSettings(_buf) {
        return {};
    }
    const sensitiveHeaders = Symbol("sensitiveHeaders");
    var http2 = {
        Http2Session,
        ClientHttp2Session,
        ServerHttp2Session,
        Http2Stream,
        Http2ServerRequest,
        Http2ServerResponse,
        createServer,
        createSecureServer,
        connect,
        constants,
        getDefaultSettings,
        getPackedSettings,
        getUnpackedSettings,
        sensitiveHeaders
    };
    var http2Shim = Object.freeze({
        __proto__: null,
        ClientHttp2Session: ClientHttp2Session,
        Http2ServerRequest: Http2ServerRequest,
        Http2ServerResponse: Http2ServerResponse,
        Http2Session: Http2Session,
        Http2Stream: Http2Stream,
        ServerHttp2Session: ServerHttp2Session,
        connect: connect,
        constants: constants,
        createSecureServer: createSecureServer,
        createServer: createServer,
        default: http2,
        getDefaultSettings: getDefaultSettings,
        getPackedSettings: getPackedSettings,
        getUnpackedSettings: getUnpackedSettings,
        sensitiveHeaders: sensitiveHeaders
    });
    const isMaster = true;
    const isPrimary = true;
    const isWorker = false;
    class Worker extends EventEmitter {
        id = 0;
        process = null;
        send(_message, _callback) {
            return false;
        }
        kill(_signal) {}
        disconnect() {}
        isDead() {
            return false;
        }
        isConnected() {
            return false;
        }
    }
    const worker = null;
    const workers = {};
    function fork(_env) {
        return new Worker();
    }
    function disconnect(_callback) {
        if (_callback) setTimeout(_callback, 0);
    }
    const settings = {};
    const SCHED_NONE = 1;
    const SCHED_RR = 2;
    let schedulingPolicy = SCHED_RR;
    function setupMaster(_settings) {}
    function setupPrimary(_settings) {}
    const clusterEmitter = new EventEmitter();
    const on = clusterEmitter.on.bind(clusterEmitter);
    const once = clusterEmitter.once.bind(clusterEmitter);
    const emit = clusterEmitter.emit.bind(clusterEmitter);
    const removeListener = clusterEmitter.removeListener.bind(clusterEmitter);
    var cluster = {
        isMaster,
        isPrimary,
        isWorker,
        Worker,
        worker,
        workers,
        fork,
        disconnect,
        settings,
        SCHED_NONE,
        SCHED_RR,
        schedulingPolicy,
        setupMaster,
        setupPrimary,
        on,
        once,
        emit,
        removeListener
    };
    var clusterShim = Object.freeze({
        __proto__: null,
        SCHED_NONE: SCHED_NONE,
        SCHED_RR: SCHED_RR,
        Worker: Worker,
        default: cluster,
        disconnect: disconnect,
        emit: emit,
        fork: fork,
        isMaster: isMaster,
        isPrimary: isPrimary,
        isWorker: isWorker,
        on: on,
        once: once,
        removeListener: removeListener,
        schedulingPolicy: schedulingPolicy,
        settings: settings,
        setupMaster: setupMaster,
        setupPrimary: setupPrimary,
        worker: worker,
        workers: workers
    });
    class Socket extends EventEmitter {
        bind(_port, _address, _callback) {
            if (_callback) setTimeout(_callback, 0);
            return this;
        }
        close(_callback) {
            if (_callback) setTimeout(_callback, 0);
        }
        send(_msg, _offset, _length, _port, _address, _callback) {
            if (_callback) setTimeout(()=>_callback(null, 0), 0);
        }
        address() {
            return {
                address: "0.0.0.0",
                family: "IPv4",
                port: 0
            };
        }
        setBroadcast(_flag) {}
        setTTL(_ttl) {
            return _ttl;
        }
        setMulticastTTL(_ttl) {
            return _ttl;
        }
        setMulticastLoopback(_flag) {
            return _flag;
        }
        setMulticastInterface(_multicastInterface) {}
        addMembership(_multicastAddress, _multicastInterface) {}
        dropMembership(_multicastAddress, _multicastInterface) {}
        ref() {
            return this;
        }
        unref() {
            return this;
        }
        setRecvBufferSize(_size) {}
        setSendBufferSize(_size) {}
        getRecvBufferSize() {
            return 0;
        }
        getSendBufferSize() {
            return 0;
        }
    }
    function createSocket(_type, _callback) {
        return new Socket();
    }
    var dgram = {
        Socket,
        createSocket
    };
    var dgramShim = Object.freeze({
        __proto__: null,
        Socket: Socket,
        createSocket: createSocket,
        default: dgram
    });
    class Script {
        code;
        constructor(code2, _options2){
            this.code = code2;
        }
        runInThisContext(_options) {
            return eval(this.code);
        }
        runInNewContext(contextObject, _options2) {
            const keys = contextObject ? Object.keys(contextObject) : [];
            const values = contextObject ? Object.values(contextObject) : [];
            const fn = new Function(...keys, `return eval(${JSON.stringify(this.code)})`);
            return fn(...values);
        }
        runInContext(_context, _options2) {
            return this.runInNewContext(_context, _options2);
        }
        createCachedData() {
            return Buffer.from("");
        }
    }
    function createContext(contextObject, _options2) {
        return contextObject || {};
    }
    function isContext(_sandbox) {
        return true;
    }
    function runInThisContext(code, _options) {
        return eval(code);
    }
    function runInNewContext(code2, contextObject, _options2) {
        const script = new Script(code2);
        return script.runInNewContext(contextObject);
    }
    function runInContext(code2, context, _options2) {
        return runInNewContext(code2, context);
    }
    function compileFunction(code2, params, _options2) {
        return new Function(...params || [], code2);
    }
    class Module {
        constructor(_code, _options2){}
        link(_linker) {
            return Promise.resolve();
        }
        evaluate(_options2) {
            return Promise.resolve();
        }
        get status() {
            return "unlinked";
        }
        get identifier() {
            return "";
        }
        get context() {
            return {};
        }
        get namespace() {
            return {};
        }
    }
    class SourceTextModule extends Module {
    }
    class SyntheticModule extends Module {
        setExport(_name, _value) {}
    }
    var vm = {
        Script,
        createContext,
        isContext,
        runInThisContext,
        runInNewContext,
        runInContext,
        compileFunction,
        Module,
        SourceTextModule,
        SyntheticModule
    };
    var vmShim = Object.freeze({
        __proto__: null,
        Module: Module,
        Script: Script,
        SourceTextModule: SourceTextModule,
        SyntheticModule: SyntheticModule,
        compileFunction: compileFunction,
        createContext: createContext,
        default: vm,
        isContext: isContext,
        runInContext: runInContext,
        runInNewContext: runInNewContext,
        runInThisContext: runInThisContext
    });
    class Session extends EventEmitter {
        connect() {}
        connectToMainThread() {}
        disconnect() {}
        post(_method, _params, _callback) {
            if (_callback) setTimeout(()=>_callback(null, {}), 0);
        }
    }
    function open(_port, _host, _wait) {}
    function close$1() {}
    function url() {
        return void 0;
    }
    function waitForDebugger() {}
    const console$1 = globalThis.console;
    var inspector = {
        Session,
        open,
        close: close$1,
        url,
        waitForDebugger,
        console: console$1
    };
    var inspectorShim = Object.freeze({
        __proto__: null,
        Session: Session,
        close: close$1,
        console: console$1,
        default: inspector,
        open: open,
        url: url,
        waitForDebugger: waitForDebugger
    });
    class AsyncResource {
        constructor(_type, _options){}
        runInAsyncScope(fn, thisArg, ...args) {
            return fn.apply(thisArg, args);
        }
        emitDestroy() {
            return this;
        }
        asyncId() {
            return 0;
        }
        triggerAsyncId() {
            return 0;
        }
        static bind(fn, _type) {
            return fn;
        }
    }
    class AsyncLocalStorage {
        store;
        disable() {}
        getStore() {
            return this.store;
        }
        run(store, callback) {
            const prev = this.store;
            this.store = store;
            try {
                return callback();
            } finally{
                this.store = prev;
            }
        }
        exit(callback) {
            const prev = this.store;
            this.store = void 0;
            try {
                return callback();
            } finally{
                this.store = prev;
            }
        }
        enterWith(store) {
            this.store = store;
        }
    }
    function createHook(_callbacks) {
        return {
            enable () {
                return this;
            },
            disable () {
                return this;
            }
        };
    }
    function executionAsyncId() {
        return 0;
    }
    function executionAsyncResource() {
        return {};
    }
    function triggerAsyncId() {
        return 0;
    }
    var async_hooks = {
        AsyncResource,
        AsyncLocalStorage,
        createHook,
        executionAsyncId,
        executionAsyncResource,
        triggerAsyncId
    };
    var asyncHooksShim = Object.freeze({
        __proto__: null,
        AsyncLocalStorage: AsyncLocalStorage,
        AsyncResource: AsyncResource,
        createHook: createHook,
        default: async_hooks,
        executionAsyncId: executionAsyncId,
        executionAsyncResource: executionAsyncResource,
        triggerAsyncId: triggerAsyncId
    });
    class Domain extends EventEmitter {
        members = [];
        add(emitter) {
            this.members.push(emitter);
        }
        remove(emitter) {
            const index = this.members.indexOf(emitter);
            if (index !== -1) {
                this.members.splice(index, 1);
            }
        }
        bind(callback) {
            return callback;
        }
        intercept(callback) {
            return callback;
        }
        run(fn) {
            return fn();
        }
        dispose() {
            this.members = [];
        }
        enter() {}
        exit() {}
    }
    function create() {
        return new Domain();
    }
    let active = null;
    var domain = {
        Domain,
        create,
        active
    };
    var domainShim = Object.freeze({
        __proto__: null,
        Domain: Domain,
        active: active,
        create: create,
        default: domain
    });
    class Channel {
        name;
        _subscribers = new Set();
        constructor(name){
            this.name = name;
        }
        get hasSubscribers() {
            return this._subscribers.size > 0;
        }
        publish(message) {
            for (const subscriber of this._subscribers){
                try {
                    subscriber(message, this.name);
                } catch (err) {
                    console.error("Error in diagnostics channel subscriber:", err);
                }
            }
        }
        subscribe(onMessage) {
            this._subscribers.add(onMessage);
        }
        unsubscribe(onMessage) {
            return this._subscribers.delete(onMessage);
        }
        bindStore(store, transform) {}
        unbindStore(store) {
            return false;
        }
    }
    const channels = new Map();
    function channel(name) {
        let ch = channels.get(name);
        if (!ch) {
            ch = new Channel(name);
            channels.set(name, ch);
        }
        return ch;
    }
    function hasSubscribers(name) {
        const ch = channels.get(name);
        return ch ? ch.hasSubscribers : false;
    }
    function subscribe(name, onMessage) {
        channel(name).subscribe(onMessage);
    }
    function unsubscribe(name, onMessage) {
        const ch = channels.get(name);
        return ch ? ch.unsubscribe(onMessage) : false;
    }
    class TracingChannel {
        channels;
        constructor(nameOrChannels){
            if (typeof nameOrChannels === "string") {
                this.channels = {
                    start: channel(`tracing:${nameOrChannels}:start`),
                    end: channel(`tracing:${nameOrChannels}:end`),
                    asyncStart: channel(`tracing:${nameOrChannels}:asyncStart`),
                    asyncEnd: channel(`tracing:${nameOrChannels}:asyncEnd`),
                    error: channel(`tracing:${nameOrChannels}:error`)
                };
            } else {
                this.channels = nameOrChannels;
            }
        }
        get hasSubscribers() {
            return Object.values(this.channels).some((ch)=>ch.hasSubscribers);
        }
        subscribe(handlers) {
            if (handlers.start) this.channels.start.subscribe(handlers.start);
            if (handlers.end) this.channels.end.subscribe(handlers.end);
            if (handlers.asyncStart) this.channels.asyncStart.subscribe(handlers.asyncStart);
            if (handlers.asyncEnd) this.channels.asyncEnd.subscribe(handlers.asyncEnd);
            if (handlers.error) this.channels.error.subscribe(handlers.error);
        }
        unsubscribe(handlers) {
            if (handlers.start) this.channels.start.unsubscribe(handlers.start);
            if (handlers.end) this.channels.end.unsubscribe(handlers.end);
            if (handlers.asyncStart) this.channels.asyncStart.unsubscribe(handlers.asyncStart);
            if (handlers.asyncEnd) this.channels.asyncEnd.unsubscribe(handlers.asyncEnd);
            if (handlers.error) this.channels.error.unsubscribe(handlers.error);
        }
        traceSync(fn, context, thisArg) {
            this.channels.start.publish(context);
            try {
                const result = fn.call(thisArg);
                this.channels.end.publish(context);
                return result;
            } catch (error) {
                this.channels.error.publish({
                    error,
                    ...context
                });
                throw error;
            }
        }
        async tracePromise(fn, context, thisArg) {
            this.channels.start.publish(context);
            try {
                const result = await fn.call(thisArg);
                this.channels.asyncEnd.publish(context);
                return result;
            } catch (error) {
                this.channels.error.publish({
                    error,
                    ...context
                });
                throw error;
            }
        }
        traceCallback(fn, position, context, thisArg) {
            return fn;
        }
    }
    function tracingChannel(name) {
        return new TracingChannel(name);
    }
    var diagnostics_channel = {
        channel,
        hasSubscribers,
        subscribe,
        unsubscribe,
        tracingChannel,
        Channel,
        TracingChannel
    };
    var diagnosticsChannelShim = Object.freeze({
        __proto__: null,
        Channel: Channel,
        TracingChannel: TracingChannel,
        channel: channel,
        default: diagnostics_channel,
        hasSubscribers: hasSubscribers,
        subscribe: subscribe,
        tracingChannel: tracingChannel,
        unsubscribe: unsubscribe
    });
    const noop = ()=>{};
    const noopPromise = ()=>Promise.resolve();
    class Scope {
        setTag = noop;
        setTags = noop;
        setUser = noop;
        setContext = noop;
        setExtra = noop;
        setExtras = noop;
        setLevel = noop;
        setTransactionName = noop;
        setFingerprint = noop;
        addBreadcrumb = noop;
        clearBreadcrumbs = noop;
        addEventProcessor = noop;
        addAttachment = noop;
        clear = noop;
        update = ()=>this;
        clone = ()=>new Scope();
    }
    class Hub {
        getClient = ()=>void 0;
        getScope = ()=>new Scope();
        pushScope = ()=>new Scope();
        popScope = noop;
        withScope = (callback)=>callback(new Scope());
        captureException = ()=>"";
        captureMessage = ()=>"";
        captureEvent = ()=>"";
        addBreadcrumb = noop;
        setUser = noop;
        setTags = noop;
        setTag = noop;
        setExtra = noop;
        setExtras = noop;
        setContext = noop;
    }
    class Transaction {
        name = "";
        spanId = "";
        traceId = "";
        op = "";
        finish = noop;
        setTag = noop;
        setData = noop;
        setStatus = noop;
        startChild = ()=>new Transaction();
        toTraceparent = ()=>"";
    }
    const currentHub = new Hub();
    const init$1 = noop;
    const close = noopPromise;
    const flush = noopPromise;
    const captureException = ()=>"";
    const captureMessage = ()=>"";
    const captureEvent = ()=>"";
    const addBreadcrumb = noop;
    const setUser = noop;
    const setTag = noop;
    const setTags = noop;
    const setExtra = noop;
    const setExtras = noop;
    const setContext = noop;
    const configureScope = (callback)=>callback(new Scope());
    const withScope = (callback)=>callback(new Scope());
    const getCurrentHub = ()=>currentHub;
    const getHubFromCarrier = ()=>currentHub;
    const startTransaction = ()=>new Transaction();
    const lastEventId = ()=>void 0;
    const Integrations = {
        Http: class {
        },
        OnUncaughtException: class {
        },
        OnUnhandledRejection: class {
        },
        Console: class {
        },
        Context: class {
        },
        ContextLines: class {
        },
        Modules: class {
        },
        RequestData: class {
        },
        LinkedErrors: class {
        }
    };
    const Handlers = {
        requestHandler: ()=>(_req, _res, next)=>next(),
        errorHandler: ()=>(_err, _req, _res, next)=>next(),
        tracingHandler: ()=>(_req, _res, next)=>next()
    };
    var sentry = {
        init: init$1,
        close,
        flush,
        captureException,
        captureMessage,
        captureEvent,
        addBreadcrumb,
        setUser,
        setTag,
        setTags,
        setExtra,
        setExtras,
        setContext,
        configureScope,
        withScope,
        getCurrentHub,
        startTransaction,
        lastEventId,
        Scope,
        Hub,
        Integrations,
        Handlers
    };
    var sentryShim = Object.freeze({
        __proto__: null,
        Handlers: Handlers,
        Hub: Hub,
        Integrations: Integrations,
        Scope: Scope,
        addBreadcrumb: addBreadcrumb,
        captureEvent: captureEvent,
        captureException: captureException,
        captureMessage: captureMessage,
        close: close,
        configureScope: configureScope,
        default: sentry,
        flush: flush,
        getCurrentHub: getCurrentHub,
        getHubFromCarrier: getHubFromCarrier,
        init: init$1,
        lastEventId: lastEventId,
        setContext: setContext,
        setExtra: setExtra,
        setExtras: setExtras,
        setTag: setTag,
        setTags: setTags,
        setUser: setUser,
        startTransaction: startTransaction,
        withScope: withScope
    });
    class AssertionError extends Error {
        actual;
        expected;
        operator;
        generatedMessage;
        code = "ERR_ASSERTION";
        constructor(options){
            const message = options.message || `${JSON.stringify(options.actual)} ${options.operator || "=="} ${JSON.stringify(options.expected)}`;
            super(message);
            this.name = "AssertionError";
            this.actual = options.actual;
            this.expected = options.expected;
            this.operator = options.operator || "";
            this.generatedMessage = !options.message;
            if (Error.captureStackTrace && options.stackStartFn) {
                Error.captureStackTrace(this, options.stackStartFn);
            }
        }
    }
    function isDeepStrictEqual(actual, expected) {
        if (actual === expected) {
            return true;
        }
        if (actual === null || expected === null || actual === void 0 || expected === void 0) {
            return actual === expected;
        }
        if (typeof actual !== typeof expected) {
            return false;
        }
        if (typeof actual === "number" && Number.isNaN(actual) && Number.isNaN(expected)) {
            return true;
        }
        if (actual instanceof Date && expected instanceof Date) {
            return actual.getTime() === expected.getTime();
        }
        if (actual instanceof RegExp && expected instanceof RegExp) {
            return actual.source === expected.source && actual.flags === expected.flags;
        }
        if (Array.isArray(actual) && Array.isArray(expected)) {
            if (actual.length !== expected.length) {
                return false;
            }
            for(let i = 0; i < actual.length; i++){
                if (!isDeepStrictEqual(actual[i], expected[i])) {
                    return false;
                }
            }
            return true;
        }
        if (actual instanceof Uint8Array && expected instanceof Uint8Array) {
            if (actual.length !== expected.length) {
                return false;
            }
            for(let i = 0; i < actual.length; i++){
                if (actual[i] !== expected[i]) {
                    return false;
                }
            }
            return true;
        }
        if (actual instanceof Map && expected instanceof Map) {
            if (actual.size !== expected.size) {
                return false;
            }
            const actualEntries = Array.from(actual.entries());
            for(let i = 0; i < actualEntries.length; i++){
                const [key, value] = actualEntries[i];
                if (!expected.has(key) || !isDeepStrictEqual(value, expected.get(key))) {
                    return false;
                }
            }
            return true;
        }
        if (actual instanceof Set && expected instanceof Set) {
            if (actual.size !== expected.size) {
                return false;
            }
            const actualValues = Array.from(actual.values());
            const expectedValues = Array.from(expected.values());
            for(let i = 0; i < actualValues.length; i++){
                const value = actualValues[i];
                if (!expected.has(value)) {
                    let found = false;
                    for(let j = 0; j < expectedValues.length; j++){
                        if (isDeepStrictEqual(value, expectedValues[j])) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) return false;
                }
            }
            return true;
        }
        if (typeof actual === "object" && typeof expected === "object") {
            const actualKeys = Object.keys(actual);
            const expectedKeys = Object.keys(expected);
            if (actualKeys.length !== expectedKeys.length) {
                return false;
            }
            for (const key of actualKeys){
                if (!Object.prototype.hasOwnProperty.call(expected, key)) {
                    return false;
                }
                if (!isDeepStrictEqual(actual[key], expected[key])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    function assert(value, message) {
        if (!value) {
            if (message instanceof Error) {
                throw message;
            }
            throw new AssertionError({
                message: message || "The expression evaluated to a falsy value",
                actual: value,
                expected: true,
                operator: "==",
                stackStartFn: assert
            });
        }
    }
    assert.ok = function ok(value, message) {
        if (!value) {
            if (message instanceof Error) {
                throw message;
            }
            throw new AssertionError({
                message: message || "The expression evaluated to a falsy value",
                actual: value,
                expected: true,
                operator: "==",
                stackStartFn: ok
            });
        }
    };
    assert.strictEqual = function strictEqual(actual, expected, message) {
        if (actual !== expected) {
            if (message instanceof Error) {
                throw message;
            }
            throw new AssertionError({
                message,
                actual,
                expected,
                operator: "===",
                stackStartFn: strictEqual
            });
        }
    };
    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
        if (actual === expected) {
            if (message instanceof Error) {
                throw message;
            }
            throw new AssertionError({
                message,
                actual,
                expected,
                operator: "!==",
                stackStartFn: notStrictEqual
            });
        }
    };
    assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
        if (!isDeepStrictEqual(actual, expected)) {
            if (message instanceof Error) {
                throw message;
            }
            throw new AssertionError({
                message,
                actual,
                expected,
                operator: "deepStrictEqual",
                stackStartFn: deepStrictEqual
            });
        }
    };
    assert.notDeepStrictEqual = function notDeepStrictEqual(actual, expected, message) {
        if (isDeepStrictEqual(actual, expected)) {
            if (message instanceof Error) {
                throw message;
            }
            throw new AssertionError({
                message,
                actual,
                expected,
                operator: "notDeepStrictEqual",
                stackStartFn: notDeepStrictEqual
            });
        }
    };
    assert.throws = function throws(fn, errorOrMessage, message) {
        let threw = false;
        let thrownError;
        try {
            fn();
        } catch (err) {
            threw = true;
            thrownError = err;
        }
        if (!threw) {
            throw new AssertionError({
                message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected function to throw",
                actual: void 0,
                expected: errorOrMessage,
                operator: "throws",
                stackStartFn: throws
            });
        }
        if (errorOrMessage !== void 0 && typeof errorOrMessage !== "string") {
            if (errorOrMessage instanceof RegExp) {
                const errMessage = thrownError instanceof Error ? thrownError.message : String(thrownError);
                if (!errorOrMessage.test(errMessage)) {
                    throw new AssertionError({
                        message: message || `The error message did not match the regular expression`,
                        actual: thrownError,
                        expected: errorOrMessage,
                        operator: "throws",
                        stackStartFn: throws
                    });
                }
            } else if (typeof errorOrMessage === "function") {
                if (!(thrownError instanceof errorOrMessage)) {
                    throw new AssertionError({
                        message: message || `The error is not an instance of the expected type`,
                        actual: thrownError,
                        expected: errorOrMessage,
                        operator: "throws",
                        stackStartFn: throws
                    });
                }
            } else if (typeof errorOrMessage === "object") {
                const expected = errorOrMessage;
                const err = thrownError;
                if (expected.message !== void 0) {
                    const errMsg = err.message || String(thrownError);
                    if (expected.message instanceof RegExp) {
                        if (!expected.message.test(errMsg)) {
                            throw new AssertionError({
                                message: message || `The error message did not match`,
                                actual: errMsg,
                                expected: expected.message,
                                operator: "throws",
                                stackStartFn: throws
                            });
                        }
                    } else if (errMsg !== expected.message) {
                        throw new AssertionError({
                            message: message || `The error message did not match`,
                            actual: errMsg,
                            expected: expected.message,
                            operator: "throws",
                            stackStartFn: throws
                        });
                    }
                }
                if (expected.code !== void 0 && err.code !== expected.code) {
                    throw new AssertionError({
                        message: message || `The error code did not match`,
                        actual: err.code,
                        expected: expected.code,
                        operator: "throws",
                        stackStartFn: throws
                    });
                }
            }
        }
    };
    assert.doesNotThrow = function doesNotThrow(fn, errorOrMessage, message) {
        try {
            fn();
        } catch (err) {
            if (errorOrMessage === void 0 || typeof errorOrMessage === "string") {
                throw new AssertionError({
                    message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected function not to throw",
                    actual: err,
                    expected: void 0,
                    operator: "doesNotThrow",
                    stackStartFn: doesNotThrow
                });
            }
            if (errorOrMessage instanceof RegExp) {
                const errMessage = err instanceof Error ? err.message : String(err);
                if (errorOrMessage.test(errMessage)) {
                    throw new AssertionError({
                        message: message || "Expected function not to throw matching error",
                        actual: err,
                        expected: errorOrMessage,
                        operator: "doesNotThrow",
                        stackStartFn: doesNotThrow
                    });
                }
            } else if (typeof errorOrMessage === "function") {
                if (err instanceof errorOrMessage) {
                    throw new AssertionError({
                        message: message || "Expected function not to throw error of this type",
                        actual: err,
                        expected: errorOrMessage,
                        operator: "doesNotThrow",
                        stackStartFn: doesNotThrow
                    });
                }
            }
        }
    };
    assert.rejects = async function rejects(asyncFn, errorOrMessage, message) {
        const promise = typeof asyncFn === "function" ? asyncFn() : asyncFn;
        let rejected = false;
        let rejectionReason;
        try {
            await promise;
        } catch (err) {
            rejected = true;
            rejectionReason = err;
        }
        if (!rejected) {
            throw new AssertionError({
                message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected promise to reject",
                actual: void 0,
                expected: errorOrMessage,
                operator: "rejects",
                stackStartFn: rejects
            });
        }
        if (errorOrMessage !== void 0 && typeof errorOrMessage !== "string") {
            if (errorOrMessage instanceof RegExp) {
                const errMessage = rejectionReason instanceof Error ? rejectionReason.message : String(rejectionReason);
                if (!errorOrMessage.test(errMessage)) {
                    throw new AssertionError({
                        message: message || "The rejection message did not match the regular expression",
                        actual: rejectionReason,
                        expected: errorOrMessage,
                        operator: "rejects",
                        stackStartFn: rejects
                    });
                }
            } else if (typeof errorOrMessage === "function") {
                if (!(rejectionReason instanceof errorOrMessage)) {
                    throw new AssertionError({
                        message: message || "The rejection is not an instance of the expected type",
                        actual: rejectionReason,
                        expected: errorOrMessage,
                        operator: "rejects",
                        stackStartFn: rejects
                    });
                }
            } else if (typeof errorOrMessage === "object") {
                const expected = errorOrMessage;
                const err = rejectionReason;
                if (expected.message !== void 0) {
                    const errMsg = err.message || String(rejectionReason);
                    if (expected.message instanceof RegExp) {
                        if (!expected.message.test(errMsg)) {
                            throw new AssertionError({
                                message: message || "The rejection message did not match",
                                actual: errMsg,
                                expected: expected.message,
                                operator: "rejects",
                                stackStartFn: rejects
                            });
                        }
                    } else if (errMsg !== expected.message) {
                        throw new AssertionError({
                            message: message || "The rejection message did not match",
                            actual: errMsg,
                            expected: expected.message,
                            operator: "rejects",
                            stackStartFn: rejects
                        });
                    }
                }
                if (expected.code !== void 0 && err.code !== expected.code) {
                    throw new AssertionError({
                        message: message || "The rejection code did not match",
                        actual: err.code,
                        expected: expected.code,
                        operator: "rejects",
                        stackStartFn: rejects
                    });
                }
            }
        }
    };
    assert.doesNotReject = async function doesNotReject(asyncFn, errorOrMessage, message) {
        const promise = typeof asyncFn === "function" ? asyncFn() : asyncFn;
        try {
            await promise;
        } catch (err) {
            if (errorOrMessage === void 0 || typeof errorOrMessage === "string") {
                throw new AssertionError({
                    message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected promise not to reject",
                    actual: err,
                    expected: void 0,
                    operator: "doesNotReject",
                    stackStartFn: doesNotReject
                });
            }
            if (errorOrMessage instanceof RegExp) {
                const errMessage = err instanceof Error ? err.message : String(err);
                if (errorOrMessage.test(errMessage)) {
                    throw new AssertionError({
                        message: message || "Expected promise not to reject with matching error",
                        actual: err,
                        expected: errorOrMessage,
                        operator: "doesNotReject",
                        stackStartFn: doesNotReject
                    });
                }
            } else if (typeof errorOrMessage === "function") {
                if (err instanceof errorOrMessage) {
                    throw new AssertionError({
                        message: message || "Expected promise not to reject with error of this type",
                        actual: err,
                        expected: errorOrMessage,
                        operator: "doesNotReject",
                        stackStartFn: doesNotReject
                    });
                }
            }
        }
    };
    assert.fail = function fail(messageOrActual, expected, message, operator) {
        if (arguments.length === 0 || arguments.length === 1) {
            throw new AssertionError({
                message: typeof messageOrActual === "string" ? messageOrActual : "Failed",
                stackStartFn: fail
            });
        }
        throw new AssertionError({
            message,
            actual: messageOrActual,
            expected,
            operator: operator || "fail",
            stackStartFn: fail
        });
    };
    assert.match = function match(string, regexp, message) {
        if (!regexp.test(string)) {
            if (message instanceof Error) {
                throw message;
            }
            throw new AssertionError({
                message: message || `The input did not match the regular expression`,
                actual: string,
                expected: regexp,
                operator: "match",
                stackStartFn: match
            });
        }
    };
    assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
        if (regexp.test(string)) {
            if (message instanceof Error) {
                throw message;
            }
            throw new AssertionError({
                message: message || `The input was expected not to match the regular expression`,
                actual: string,
                expected: regexp,
                operator: "doesNotMatch",
                stackStartFn: doesNotMatch
            });
        }
    };
    assert.ifError = function ifError(value) {
        if (value !== null && value !== void 0) {
            if (value instanceof Error) {
                throw value;
            }
            throw new AssertionError({
                message: `ifError got unwanted exception: ${value}`,
                actual: value,
                expected: null,
                operator: "ifError",
                stackStartFn: ifError
            });
        }
    };
    assert.AssertionError = AssertionError;
    assert.strict = assert;
    function e(e, n, r) {
        throw new Error(r ? `No known conditions for "${n}" specifier in "${e}" package` : `Missing "${n}" specifier in "${e}" package`);
    }
    function n(n, i, o, f) {
        let s, u, l = r(n, o), c = function(e) {
            let n = new Set([
                "default",
                ...e.conditions || []
            ]);
            return e.unsafe || n.add(e.require ? "require" : "import"), e.unsafe || n.add(e.browser ? "browser" : "node"), n;
        }(f || {}), a = i[l];
        if (void 0 === a) {
            let e, n, r, t;
            for(t in i)n && t.length < n.length || ("/" === t[t.length - 1] && l.startsWith(t) ? (u = l.substring(t.length), n = t) : t.length > 1 && (r = t.indexOf("*", 1), ~r && (e = RegExp("^" + t.substring(0, r) + "(.*)" + t.substring(1 + r) + "$").exec(l), e && e[1] && (u = e[1], n = t))));
            a = i[n];
        }
        return a || e(n, l), s = t(a, c), s || e(n, l, 1), u && function(e, n) {
            let r, t = 0, i = e.length, o = /[*]/g, f = /[/]$/;
            for(; t < i; t++)e[t] = o.test(r = e[t]) ? r.replace(o, n) : f.test(r) ? r + n : r;
        }(s, u), s;
    }
    function r(e, n, r) {
        if (e === n || "." === n) return ".";
        let t = e + "/", i = t.length, o = n.slice(0, i) === t, f = o ? n.slice(i) : n;
        return "#" === f[0] ? f : o || true ? "./" === f.slice(0, 2) ? f : "./" + f : f;
    }
    function t(e, n, r) {
        if (e) {
            if ("string" == typeof e) return r && r.add(e), [
                e
            ];
            let i, o;
            if (Array.isArray(e)) {
                for(o = r || new Set, i = 0; i < e.length; i++)t(e[i], n, o);
                if (!r && o.size) return [
                    ...o
                ];
            } else for(i in e)if (n.has(i)) return t(e[i], n, r);
        }
    }
    function o(e, r, t) {
        let i, o = e.exports;
        if (o) {
            if ("string" == typeof o) o = {
                ".": o
            };
            else for(i in o){
                "." !== i[0] && (o = {
                    ".": o
                });
                break;
            }
            return n(e.name, o, r || ".", t);
        }
    }
    function f(e, r, t) {
        if (e.imports) return n(e.name, e.imports, r, t);
    }
    function s(e, n, t) {
        return "#" === (n = r(e.name, n || "."))[0] ? f(e, n, t) : o(e, n, t);
    }
    function transformDynamicImports(code2) {
        return code2.replace(/(?<![.$\w])import\s*\(/g, "__dynamicImport(");
    }
    function transformEsmToCjs(code2, filename2) {
        const hasImport = /\bimport\s+[\w{*'"]/m.test(code2);
        const hasExport = /\bexport\s+(?:default|const|let|var|function|class|{|\*)/m.test(code2);
        const hasImportMeta = /\bimport\.meta\b/.test(code2);
        if (!hasImport && !hasExport && !hasImportMeta) {
            return code2;
        }
        let transformed = code2;
        transformed = transformed.replace(/\bimport\.meta\.url\b/g, `"file://${filename2}"`);
        transformed = transformed.replace(/\bimport\.meta\.dirname\b/g, `"${dirname(filename2)}"`);
        transformed = transformed.replace(/\bimport\.meta\.filename\b/g, `"${filename2}"`);
        transformed = transformed.replace(/\bimport\.meta\b/g, `({ url: "file://${filename2}", dirname: "${dirname(filename2)}", filename: "${filename2}" })`);
        transformed = transformed.replace(/\bimport\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"]\s*;?/g, (_, imports, module2)=>{
            const cleanImports = imports.replace(/\s+as\s+/g, ": ");
            return `const {${cleanImports}} = require("${module2}");`;
        });
        transformed = transformed.replace(/\bimport\s+(\w+)\s+from\s+['"]([^'"]+)['"]\s*;?/g, (_, name, module2)=>{
            return `const ${name} = (function() { const m = require("${module2}"); return m && m.__esModule ? m.default : m; })();`;
        });
        transformed = transformed.replace(/\bimport\s+\*\s+as\s+(\w+)\s+from\s+['"]([^'"]+)['"]\s*;?/g, 'const $1 = require("$2");');
        transformed = transformed.replace(/\bimport\s+['"]([^'"]+)['"]\s*;?/g, 'require("$1");');
        transformed = transformed.replace(/\bexport\s+default\s+/g, "module.exports = module.exports.default = ");
        transformed = transformed.replace(/\bexport\s+\{([^}]+)\}\s*;?/g, (_, exports$1)=>{
            const items = exports$1.split(",").map((item)=>{
                const [local, exported] = item.trim().split(/\s+as\s+/);
                const exportName = exported || local;
                return `module.exports.${exportName.trim()} = ${local.trim()};`;
            });
            return items.join("\n");
        });
        transformed = transformed.replace(/\bexport\s+(const|let|var)\s+(\w+)\s*=/g, "$1 $2 = module.exports.$2 =");
        transformed = transformed.replace(/\bexport\s+function\s+(\w+)/g, "function $1");
        transformed = transformed.replace(/\bexport\s+class\s+(\w+)/g, "class $1");
        if (hasExport) {
            transformed = 'Object.defineProperty(exports, "__esModule", { value: true });\n' + transformed;
        }
        return transformed;
    }
    function createDynamicImport(moduleRequire2) {
        return async (specifier)=>{
            try {
                const mod = moduleRequire2(specifier);
                if (mod && typeof mod === "object" && ("default" in mod || "__esModule" in mod)) {
                    return mod;
                }
                return {
                    default: mod,
                    ...mod && typeof mod === "object" ? mod : {}
                };
            } catch (error) {
                throw error;
            }
        };
    }
    function createStringDecoderModule() {
        class StringDecoder {
            encoding;
            constructor(encoding){
                this.encoding = encoding || "utf8";
            }
            write(buffer) {
                return new TextDecoder(this.encoding).decode(buffer);
            }
            end(buffer) {
                if (buffer) return this.write(buffer);
                return "";
            }
        }
        return {
            StringDecoder
        };
    }
    function createTimersModule() {
        return {
            setTimeout: globalThis.setTimeout.bind(globalThis),
            setInterval: globalThis.setInterval.bind(globalThis),
            setImmediate: (fn2)=>setTimeout(fn2, 0),
            clearTimeout: globalThis.clearTimeout.bind(globalThis),
            clearInterval: globalThis.clearInterval.bind(globalThis),
            clearImmediate: globalThis.clearTimeout.bind(globalThis)
        };
    }
    const prettierShim = {
        format: (source, _options)=>Promise.resolve(source),
        formatWithCursor: (source, _options)=>Promise.resolve({
                formatted: source,
                cursorOffset: 0
            }),
        check: (_source, _options)=>Promise.resolve(true),
        resolveConfig: ()=>Promise.resolve(null),
        resolveConfigFile: ()=>Promise.resolve(null),
        clearConfigCache: ()=>{},
        getFileInfo: ()=>Promise.resolve({
                ignored: false,
                inferredParser: null
            }),
        getSupportInfo: ()=>Promise.resolve({
                languages: [],
                options: []
            }),
        version: "3.0.0",
        doc: {
            builders: {},
            printer: {},
            utils: {}
        }
    };
    function makeMutable(mod) {
        const mutable = {};
        for (const key of Object.keys(mod)){
            mutable[key] = mod[key];
        }
        return mutable;
    }
    const builtinModules = {
        path: pathShim,
        http: makeMutable(httpShim),
        https: makeMutable(httpsShim),
        net: netShim,
        events: events,
        stream: Stream,
        buffer: bufferModule,
        url: urlShim,
        querystring: querystringShim,
        util: utilShim,
        tty: ttyShim,
        os: osShim,
        crypto: cryptoShim,
        zlib: zlibShim,
        dns: dnsShim,
        child_process: childProcessShim,
        assert: assert,
        string_decoder: createStringDecoderModule(),
        timers: createTimersModule(),
        _http_common: {},
        _http_incoming: {},
        _http_outgoing: {},
        chokidar: chokidarShim,
        ws: wsShim,
        fsevents: fseventsShim,
        readdirp: readdirpShim,
        module: moduleShim,
        perf_hooks: perfHooksShim,
        worker_threads: workerThreadsShim,
        esbuild: esbuildShim,
        rollup: rollupShim,
        v8: v8Shim,
        readline: readlineShim,
        tls: tlsShim,
        http2: http2Shim,
        cluster: clusterShim,
        dgram: dgramShim,
        vm: vmShim,
        inspector: inspectorShim,
        "inspector/promises": inspectorShim,
        async_hooks: asyncHooksShim,
        domain: domainShim,
        diagnostics_channel: diagnosticsChannelShim,
        prettier: prettierShim,
        console,
        "util/types": types$1,
        "@sentry/node": sentryShim,
        "@sentry/core": sentryShim
    };
    function createRequire(vfs, fsShim, process, currentDir, moduleCache, options, processedCodeCache) {
        const resolutionCache = new Map();
        const packageJsonCache = new Map();
        const getParsedPackageJson = (pkgPath)=>{
            if (packageJsonCache.has(pkgPath)) {
                return packageJsonCache.get(pkgPath);
            }
            try {
                const content = vfs.readFileSync(pkgPath, "utf8");
                const parsed = JSON.parse(content);
                packageJsonCache.set(pkgPath, parsed);
                return parsed;
            } catch  {
                packageJsonCache.set(pkgPath, null);
                return null;
            }
        };
        const resolveModule = (id, fromDir)=>{
            if (id.startsWith("node:")) {
                id = id.slice(5);
            }
            if (builtinModules[id] || id === "fs" || id === "process" || id === "url" || id === "querystring" || id === "util") {
                return id;
            }
            const cacheKey = `${fromDir}|${id}`;
            const cached = resolutionCache.get(cacheKey);
            if (cached !== void 0) {
                if (cached === null) {
                    throw new Error(`Cannot find module '${id}'`);
                }
                return cached;
            }
            if (id.startsWith("./") || id.startsWith("../") || id.startsWith("/")) {
                const resolved = id.startsWith("/") ? id : resolve$2(fromDir, id);
                if (vfs.existsSync(resolved)) {
                    const stats = vfs.statSync(resolved);
                    if (stats.isFile()) {
                        resolutionCache.set(cacheKey, resolved);
                        return resolved;
                    }
                    const indexPath = join$1(resolved, "index.js");
                    if (vfs.existsSync(indexPath)) {
                        resolutionCache.set(cacheKey, indexPath);
                        return indexPath;
                    }
                }
                const extensions = [
                    ".js",
                    ".json"
                ];
                for (const ext of extensions){
                    const withExt = resolved + ext;
                    if (vfs.existsSync(withExt)) {
                        resolutionCache.set(cacheKey, withExt);
                        return withExt;
                    }
                }
                resolutionCache.set(cacheKey, null);
                throw new Error(`Cannot find module '${id}' from '${fromDir}'`);
            }
            const tryResolveFile = (basePath)=>{
                if (vfs.existsSync(basePath)) {
                    const stats = vfs.statSync(basePath);
                    if (stats.isFile()) {
                        return basePath;
                    }
                    const indexPath = join$1(basePath, "index.js");
                    if (vfs.existsSync(indexPath)) {
                        return indexPath;
                    }
                }
                const extensions = [
                    ".js",
                    ".json",
                    ".node"
                ];
                for (const ext of extensions){
                    const withExt = basePath + ext;
                    if (vfs.existsSync(withExt)) {
                        return withExt;
                    }
                }
                return null;
            };
            const tryResolveFromNodeModules = (nodeModulesDir, moduleId)=>{
                const parts = moduleId.split("/");
                const pkgName = parts[0].startsWith("@") && parts.length > 1 ? `${parts[0]}/${parts[1]}` : parts[0];
                const pkgRoot = join$1(nodeModulesDir, pkgName);
                const pkgPath = join$1(pkgRoot, "package.json");
                const pkg = getParsedPackageJson(pkgPath);
                if (pkg) {
                    if (pkg.exports) {
                        try {
                            const resolved2 = s(pkg, moduleId, {
                                require: true
                            });
                            if (resolved2 && resolved2.length > 0) {
                                const exportPath = resolved2[0];
                                const fullExportPath = join$1(pkgRoot, exportPath);
                                const resolvedFile = tryResolveFile(fullExportPath);
                                if (resolvedFile) return resolvedFile;
                            }
                        } catch  {}
                    }
                    if (pkgName === moduleId) {
                        let main;
                        if (typeof pkg.browser === "string") {
                            main = pkg.browser;
                        }
                        if (!main) {
                            main = pkg.main || "index.js";
                        }
                        const mainPath = join$1(pkgRoot, main);
                        const resolvedMain = tryResolveFile(mainPath);
                        if (resolvedMain) return resolvedMain;
                    }
                }
                const fullPath = join$1(nodeModulesDir, moduleId);
                const resolved = tryResolveFile(fullPath);
                if (resolved) return resolved;
                return null;
            };
            let searchDir = fromDir;
            while(searchDir !== "/"){
                const nodeModulesDir = join$1(searchDir, "node_modules");
                const resolved = tryResolveFromNodeModules(nodeModulesDir, id);
                if (resolved) {
                    resolutionCache.set(cacheKey, resolved);
                    return resolved;
                }
                searchDir = dirname(searchDir);
            }
            const rootResolved = tryResolveFromNodeModules("/node_modules", id);
            if (rootResolved) {
                resolutionCache.set(cacheKey, rootResolved);
                return rootResolved;
            }
            resolutionCache.set(cacheKey, null);
            throw new Error(`Cannot find module '${id}'`);
        };
        const loadModule = (resolvedPath)=>{
            if (moduleCache[resolvedPath]) {
                return moduleCache[resolvedPath];
            }
            const module = {
                id: resolvedPath,
                filename: resolvedPath,
                exports: {},
                loaded: false,
                children: [],
                paths: []
            };
            moduleCache[resolvedPath] = module;
            const cacheKeys = Object.keys(moduleCache);
            if (cacheKeys.length > 2e3) {
                delete moduleCache[cacheKeys[0]];
            }
            if (resolvedPath.endsWith(".json")) {
                const content = vfs.readFileSync(resolvedPath, "utf8");
                module.exports = JSON.parse(content);
                module.loaded = true;
                return module;
            }
            const rawCode = vfs.readFileSync(resolvedPath, "utf8");
            const dirname$1 = dirname(resolvedPath);
            const codeCacheKey = `${resolvedPath}|${simpleHash(rawCode)}`;
            let code = processedCodeCache?.get(codeCacheKey);
            if (!code) {
                code = rawCode;
                const isCjsFile = resolvedPath.endsWith(".cjs");
                const isAlreadyBundledCjs = code.startsWith('"use strict";\nvar __') || code.startsWith("'use strict';\nvar __");
                const hasEsmImport = /\bimport\s+[\w{*'"]/m.test(code);
                const hasEsmExport = /\bexport\s+(?:default|const|let|var|function|class|{|\*)/m.test(code);
                if (!isCjsFile && !isAlreadyBundledCjs) {
                    if (resolvedPath.endsWith(".mjs") || resolvedPath.includes("/esm/") || hasEsmImport || hasEsmExport) {
                        code = transformEsmToCjs(code, resolvedPath);
                    }
                }
                code = transformDynamicImports(code);
                processedCodeCache?.set(codeCacheKey, code);
            }
            const moduleRequire = createRequire(vfs, fsShim, process, dirname$1, moduleCache, options, processedCodeCache);
            moduleRequire.cache = moduleCache;
            const consoleWrapper = createConsoleWrapper(options.onConsole);
            try {
                const importMetaUrl = "file://" + resolvedPath;
                const wrappedCode = `(function($exports, $require, $module, $filename, $dirname, $process, $console, $importMeta, $dynamicImport) {
var exports = $exports;
var require = $require;
var module = $module;
var __filename = $filename;
var __dirname = $dirname;
var process = $process;
var console = $console;
var import_meta = $importMeta;
var __dynamicImport = $dynamicImport;
// Set up global.process and globalThis.process for code that accesses them directly
var global = globalThis;
globalThis.process = $process;
global.process = $process;
return (function() {
${code}
}).call(this);
})`;
                let fn;
                try {
                    fn = eval(wrappedCode);
                } catch (evalError) {
                    console.error("[runtime] Eval failed for:", resolvedPath);
                    console.error("[runtime] First 500 chars of code:", code.substring(0, 500));
                    throw evalError;
                }
                const dynamicImport = createDynamicImport(moduleRequire);
                fn(module.exports, moduleRequire, module, resolvedPath, dirname$1, process, consoleWrapper, {
                    url: importMetaUrl,
                    dirname: dirname$1,
                    filename: resolvedPath
                }, dynamicImport);
                module.loaded = true;
            } catch (error) {
                delete moduleCache[resolvedPath];
                throw error;
            }
            return module;
        };
        const require = (id)=>{
            if (id.startsWith("node:")) {
                id = id.slice(5);
            }
            if (id === "fs") {
                return fsShim;
            }
            if (id === "fs/promises") {
                return fsShim.promises;
            }
            if (id === "process") {
                return process;
            }
            if (id === "module") {
                return {
                    ...moduleShim,
                    createRequire: (filenameOrUrl)=>{
                        let fromPath = filenameOrUrl;
                        if (filenameOrUrl.startsWith("file://")) {
                            fromPath = filenameOrUrl.slice(7);
                            if (fromPath.startsWith("/") && fromPath[2] === ":") {
                                fromPath = fromPath.slice(1);
                            }
                        }
                        const fromDir = dirname(fromPath);
                        const newRequire = createRequire(vfs, fsShim, process, fromDir, moduleCache, options);
                        newRequire.cache = moduleCache;
                        return newRequire;
                    }
                };
            }
            if (builtinModules[id]) {
                return builtinModules[id];
            }
            if (id === "rollup" || id.startsWith("rollup/") || id.startsWith("@rollup/")) {
                console.log("[runtime] Intercepted rollup:", id);
                return builtinModules["rollup"];
            }
            if (id === "esbuild" || id.startsWith("esbuild/") || id.startsWith("@esbuild/")) {
                console.log("[runtime] Intercepted esbuild:", id);
                return builtinModules["esbuild"];
            }
            if (id === "prettier" || id.startsWith("prettier/")) {
                return builtinModules["prettier"];
            }
            if (id.startsWith("@sentry/")) {
                return builtinModules["@sentry/node"];
            }
            const resolved = resolveModule(id, currentDir);
            if (builtinModules[resolved]) {
                return builtinModules[resolved];
            }
            if (resolved.includes("/node_modules/rollup/") || resolved.includes("/node_modules/@rollup/")) {
                return builtinModules["rollup"];
            }
            if (resolved.includes("/node_modules/esbuild/") || resolved.includes("/node_modules/@esbuild/")) {
                return builtinModules["esbuild"];
            }
            if (resolved.includes("/node_modules/prettier/")) {
                return builtinModules["prettier"];
            }
            if (resolved.includes("/node_modules/@sentry/")) {
                return builtinModules["@sentry/node"];
            }
            return loadModule(resolved).exports;
        };
        require.resolve = (id)=>{
            if (id === "fs" || id === "process" || builtinModules[id]) {
                return id;
            }
            return resolveModule(id, currentDir);
        };
        require.cache = moduleCache;
        return require;
    }
    function createConsoleWrapper(onConsole) {
        const wrapper = {
            log: (...args)=>{
                console.log(...args);
                onConsole?.("log", args);
            },
            error: (...args)=>{
                console.error(...args);
                onConsole?.("error", args);
            },
            warn: (...args)=>{
                console.warn(...args);
                onConsole?.("warn", args);
            },
            info: (...args)=>{
                console.info(...args);
                onConsole?.("info", args);
            },
            debug: (...args)=>{
                console.debug(...args);
                onConsole?.("debug", args);
            },
            trace: (...args)=>{
                console.trace(...args);
                onConsole?.("trace", args);
            },
            dir: (obj)=>{
                console.dir(obj);
                onConsole?.("dir", [
                    obj
                ]);
            },
            time: console.time.bind(console),
            timeEnd: console.timeEnd.bind(console),
            timeLog: console.timeLog.bind(console),
            assert: console.assert.bind(console),
            clear: console.clear.bind(console),
            count: console.count.bind(console),
            countReset: console.countReset.bind(console),
            group: console.group.bind(console),
            groupCollapsed: console.groupCollapsed.bind(console),
            groupEnd: console.groupEnd.bind(console),
            table: console.table.bind(console)
        };
        return wrapper;
    }
    class Runtime {
        vfs;
        fsShim;
        process;
        moduleCache = {};
        options;
        processedCodeCache = new Map();
        constructor(vfs2, options2 = {}){
            this.vfs = vfs2;
            this.process = createProcess({
                cwd: options2.cwd || "/",
                env: options2.env
            });
            this.fsShim = createFsShim(vfs2, ()=>this.process.cwd());
            this.options = options2;
            initChildProcess(vfs2);
            setVFS$2(vfs2);
            setVFS$1(vfs2);
            setVFS(vfs2);
            this.setupStackTracePolyfill();
            this.setupTextDecoderPolyfill();
        }
        setupTextDecoderPolyfill() {
            const OriginalTextDecoder = globalThis.TextDecoder;
            class PolyfillTextDecoder {
                encoding;
                decoder = null;
                constructor(encoding = "utf-8", options2){
                    this.encoding = encoding.toLowerCase();
                    const validTextEncodings = [
                        "utf-8",
                        "utf8",
                        "utf-16le",
                        "utf-16be",
                        "utf-16",
                        "ascii",
                        "iso-8859-1",
                        "latin1",
                        "windows-1252"
                    ];
                    if (validTextEncodings.includes(this.encoding)) {
                        try {
                            this.decoder = new OriginalTextDecoder(encoding, options2);
                        } catch  {
                            this.decoder = new OriginalTextDecoder("utf-8", options2);
                        }
                    }
                }
                decode(input, options2) {
                    if (this.decoder) {
                        return this.decoder.decode(input, options2);
                    }
                    if (!input) return "";
                    const bytes = input instanceof ArrayBuffer ? new Uint8Array(input) : new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
                    if (this.encoding === "base64") {
                        return uint8ToBase64(bytes);
                    }
                    if (this.encoding === "base64url") {
                        return uint8ToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
                    }
                    if (this.encoding === "hex") {
                        return uint8ToHex(bytes);
                    }
                    return new OriginalTextDecoder("utf-8").decode(input, options2);
                }
                get fatal() {
                    return this.decoder?.fatal ?? false;
                }
                get ignoreBOM() {
                    return this.decoder?.ignoreBOM ?? false;
                }
            }
            globalThis.TextDecoder = PolyfillTextDecoder;
        }
        setupStackTracePolyfill() {
            if (typeof Error.captureStackTrace === "function") return;
            if (Error.stackTraceLimit === void 0) {
                Error.stackTraceLimit = 10;
            }
            function parseStack(stack) {
                if (!stack) return [];
                const frames = [];
                const lines = stack.split("\n");
                for (const raw of lines){
                    const line = raw.trim();
                    if (!line || line.startsWith("Error") || line.startsWith("TypeError")) continue;
                    let fn2 = "", file = "", lineNo = 0, colNo = 0;
                    const safariMatch = line.match(/^(.*)@(.*?):(\d+):(\d+)$/);
                    if (safariMatch) {
                        fn2 = safariMatch[1] || "";
                        file = safariMatch[2];
                        lineNo = parseInt(safariMatch[3], 10);
                        colNo = parseInt(safariMatch[4], 10);
                        frames.push({
                            fn: fn2,
                            file,
                            line: lineNo,
                            col: colNo
                        });
                        continue;
                    }
                    const chromeMatch = line.match(/^at\s+(?:(.+?)\s+\()?(.*?):(\d+):(\d+)\)?$/);
                    if (chromeMatch) {
                        fn2 = chromeMatch[1] || "";
                        file = chromeMatch[2];
                        lineNo = parseInt(chromeMatch[3], 10);
                        colNo = parseInt(chromeMatch[4], 10);
                        frames.push({
                            fn: fn2,
                            file,
                            line: lineNo,
                            col: colNo
                        });
                        continue;
                    }
                }
                return frames;
            }
            function createCallSite(frame) {
                return {
                    getFileName: ()=>frame.file || null,
                    getLineNumber: ()=>frame.line || null,
                    getColumnNumber: ()=>frame.col || null,
                    getFunctionName: ()=>frame.fn || null,
                    getMethodName: ()=>frame.fn || null,
                    getTypeName: ()=>null,
                    getThis: ()=>void 0,
                    getFunction: ()=>void 0,
                    getEvalOrigin: ()=>void 0,
                    isNative: ()=>false,
                    isConstructor: ()=>false,
                    isToplevel: ()=>!frame.fn,
                    isEval: ()=>false,
                    toString: ()=>frame.fn ? `${frame.fn} (${frame.file}:${frame.line}:${frame.col})` : `${frame.file}:${frame.line}:${frame.col}`
                };
            }
            function buildCallSites(stack, constructorOpt) {
                const frames = parseStack(stack);
                let startIdx = 0;
                if (constructorOpt && constructorOpt.name) {
                    for(let i = 0; i < frames.length; i++){
                        if (frames[i].fn === constructorOpt.name) {
                            startIdx = i + 1;
                            break;
                        }
                    }
                }
                return frames.slice(startIdx).map(createCallSite);
            }
            const stackSymbol = Symbol("rawStack");
            Object.defineProperty(Error.prototype, "stack", {
                get () {
                    const rawStack = this[stackSymbol];
                    if (rawStack !== void 0 && typeof Error.prepareStackTrace === "function") {
                        const callSites = buildCallSites(rawStack);
                        try {
                            return Error.prepareStackTrace(this, callSites);
                        } catch  {
                            return rawStack;
                        }
                    }
                    return rawStack;
                },
                set (value) {
                    this[stackSymbol] = value;
                },
                configurable: true,
                enumerable: false
            });
            Error.captureStackTrace = function(target, constructorOpt) {
                const savedPrepare = Error.prepareStackTrace;
                Error.prepareStackTrace = void 0;
                const err = new Error();
                const rawStack = err.stack || "";
                Error.prepareStackTrace = savedPrepare;
                if (typeof savedPrepare === "function") {
                    const callSites = buildCallSites(rawStack, constructorOpt);
                    try {
                        target.stack = savedPrepare(target, callSites);
                    } catch (e) {
                        console.warn("[almostnode] Error.prepareStackTrace threw:", e);
                        target.stack = rawStack;
                    }
                } else {
                    target.stack = rawStack;
                }
            };
        }
        execute(code, filename = "/index.js") {
            const dirname$1 = dirname(filename);
            this.vfs.writeFileSync(filename, code);
            const require = createRequire(this.vfs, this.fsShim, this.process, dirname$1, this.moduleCache, this.options, this.processedCodeCache);
            const module = {
                id: filename,
                filename,
                exports: {},
                loaded: false,
                children: [],
                paths: []
            };
            this.moduleCache[filename] = module;
            const consoleWrapper = createConsoleWrapper(this.options.onConsole);
            try {
                const importMetaUrl = "file://" + filename;
                const wrappedCode = `(function($exports, $require, $module, $filename, $dirname, $process, $console, $importMeta) {
var exports = $exports;
var require = $require;
var module = $module;
var __filename = $filename;
var __dirname = $dirname;
var process = $process;
var console = $console;
var import_meta = $importMeta;
// Set up global.process and globalThis.process for code that accesses them directly
var global = globalThis;
globalThis.process = $process;
global.process = $process;

return (function() {
${code}
}).call(this);
})`;
                const fn = eval(wrappedCode);
                fn(module.exports, require, module, filename, dirname$1, this.process, consoleWrapper, {
                    url: importMetaUrl,
                    dirname: dirname$1,
                    filename
                });
                module.loaded = true;
            } catch (error) {
                delete this.moduleCache[filename];
                throw error;
            }
            return {
                exports: module.exports,
                module
            };
        }
        executeSync = this.execute;
        async executeAsync(code2, filename2 = "/index.js") {
            return Promise.resolve(this.execute(code2, filename2));
        }
        runFile(filename2) {
            const code2 = this.vfs.readFileSync(filename2, "utf8");
            return this.execute(code2, filename2);
        }
        runFileSync = this.runFile;
        async runFileAsync(filename2) {
            return Promise.resolve(this.runFile(filename2));
        }
        clearCache() {
            this.moduleCache = {};
        }
        getVFS() {
            return this.vfs;
        }
        getProcess() {
            return this.process;
        }
        createREPL() {
            const require2 = createRequire(this.vfs, this.fsShim, this.process, "/", this.moduleCache, this.options, this.processedCodeCache);
            const consoleWrapper2 = createConsoleWrapper(this.options.onConsole);
            const process2 = this.process;
            const buffer = bufferModule.Buffer;
            const GeneratorFunction = Object.getPrototypeOf(function*() {}).constructor;
            const replGen = new GeneratorFunction("require", "console", "process", "Buffer", `var __code, __result;
while (true) {
  __code = yield;
  try {
    __result = eval(__code);
    yield { value: __result, error: null };
  } catch (e) {
    yield { value: undefined, error: e };
  }
}`)(require2, consoleWrapper2, process2, buffer);
            replGen.next();
            return {
                eval (code2) {
                    const transformed = code2.replace(/^\s*(const|let)\s+/gm, "var ");
                    const exprResult = replGen.next("(" + transformed + ")").value;
                    if (!exprResult.error) {
                        replGen.next();
                        return exprResult.value;
                    }
                    replGen.next();
                    const stmtResult = replGen.next(transformed).value;
                    if (stmtResult.error) {
                        replGen.next();
                        throw stmtResult.error;
                    }
                    replGen.next();
                    return stmtResult.value;
                }
            };
        }
    }
    let runtime = null;
    let vfs = null;
    let consoleCallback = null;
    const workerApi = {
        init (vfsSnapshot, options) {
            console.log("[Worker] Initializing with", vfsSnapshot.files.length, "files");
            vfs = VirtualFS.fromSnapshot(vfsSnapshot);
            const runtimeOptions = {
                ...options,
                onConsole: (method, args)=>{
                    if (consoleCallback) {
                        consoleCallback(method, args);
                    }
                }
            };
            runtime = new Runtime(vfs, runtimeOptions);
            console.log("[Worker] Runtime initialized");
        },
        setConsoleCallback (callback) {
            consoleCallback = callback;
        },
        syncFile (path, content) {
            if (!vfs) {
                console.warn("[Worker] VFS not initialized, cannot sync file:", path);
                return;
            }
            if (content === null) {
                try {
                    vfs.unlinkSync(path);
                    console.log("[Worker] Deleted file:", path);
                } catch (err) {}
            } else {
                vfs.writeFileSync(path, content);
                console.log("[Worker] Synced file:", path);
            }
            if (runtime) {
                runtime.clearCache();
            }
        },
        async execute (code, filename) {
            if (!runtime) {
                throw new Error("Worker runtime not initialized. Call init() first.");
            }
            console.log("[Worker] Executing code in file:", filename);
            return runtime.execute(code, filename);
        },
        async runFile (filename) {
            if (!runtime) {
                throw new Error("Worker runtime not initialized. Call init() first.");
            }
            console.log("[Worker] Running file:", filename);
            return runtime.runFile(filename);
        },
        clearCache () {
            if (runtime) {
                runtime.clearCache();
                console.log("[Worker] Cache cleared");
            }
        },
        getVFSSnapshot () {
            if (!vfs) return null;
            return vfs.toSnapshot();
        }
    };
    expose(workerApi);
    console.log("[Worker] Runtime worker loaded and ready");
    let wasm;
    const heap = new Array(32).fill(undefined);
    heap.push(undefined, null, true, false);
    function getObject(idx) {
        return heap[idx];
    }
    const cachedTextDecoder = new TextDecoder('utf-8', {
        ignoreBOM: true,
        fatal: true
    });
    cachedTextDecoder.decode();
    let cachegetUint8Memory0 = null;
    function getUint8Memory0() {
        if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
            cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        }
        return cachegetUint8Memory0;
    }
    function getStringFromWasm0(ptr, len) {
        return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
    }
    let heap_next = heap.length;
    function addHeapObject(obj) {
        if (heap_next === heap.length) heap.push(heap.length + 1);
        const idx = heap_next;
        heap_next = heap[idx];
        heap[idx] = obj;
        return idx;
    }
    let WASM_VECTOR_LEN = 0;
    const cachedTextEncoder = new TextEncoder('utf-8');
    const encodeString = (typeof cachedTextEncoder.encodeInto === 'function' ? function(arg, view) {
        return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
        const buf = cachedTextEncoder.encode(arg);
        view.set(buf);
        return {
            read: arg.length,
            written: buf.length
        };
    });
    function passStringToWasm0(arg, malloc, realloc) {
        if (realloc === undefined) {
            const buf = cachedTextEncoder.encode(arg);
            const ptr = malloc(buf.length);
            getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
            WASM_VECTOR_LEN = buf.length;
            return ptr;
        }
        let len = arg.length;
        let ptr = malloc(len);
        const mem = getUint8Memory0();
        let offset = 0;
        for(; offset < len; offset++){
            const code = arg.charCodeAt(offset);
            if (code > 0x7F) break;
            mem[ptr + offset] = code;
        }
        if (offset !== len) {
            if (offset !== 0) {
                arg = arg.slice(offset);
            }
            ptr = realloc(ptr, len, len = offset + arg.length * 3);
            const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
            const ret = encodeString(arg, view);
            offset += ret.written;
        }
        WASM_VECTOR_LEN = offset;
        return ptr;
    }
    let cachegetInt32Memory0 = null;
    function getInt32Memory0() {
        if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
            cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
        }
        return cachegetInt32Memory0;
    }
    function dropObject(idx) {
        if (idx < 36) return;
        heap[idx] = heap_next;
        heap_next = idx;
    }
    function takeObject(idx) {
        const ret = getObject(idx);
        dropObject(idx);
        return ret;
    }
    function passArray8ToWasm0(arg, malloc) {
        const ptr = malloc(arg.length * 1);
        getUint8Memory0().set(arg, ptr / 1);
        WASM_VECTOR_LEN = arg.length;
        return ptr;
    }
    let stack_pointer = 32;
    function addBorrowedObject(obj) {
        if (stack_pointer == 1) throw new Error('out of js stack');
        heap[--stack_pointer] = obj;
        return stack_pointer;
    }
    function getArrayU8FromWasm0(ptr, len) {
        return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
    }
    function compress(buf, raw_options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(buf, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.compress(retptr, ptr0, len0, addBorrowedObject(raw_options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v1;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    function decompress(buf) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(buf, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.decompress(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v1;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    function isLikeNone(x) {
        return x === undefined || x === null;
    }
    const BrotliStreamResultCode = Object.freeze({
        ResultSuccess: 1,
        "1": "ResultSuccess",
        NeedsMoreInput: 2,
        "2": "NeedsMoreInput",
        NeedsMoreOutput: 3,
        "3": "NeedsMoreOutput"
    });
    class BrotliStreamResult {
        static __wrap(ptr) {
            const obj = Object.create(BrotliStreamResult.prototype);
            obj.ptr = ptr;
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.ptr;
            this.ptr = 0;
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm.__wbg_brotlistreamresult_free(ptr);
        }
        get code() {
            const ret = wasm.__wbg_get_brotlistreamresult_code(this.ptr);
            return ret >>> 0;
        }
        set code(arg0) {
            wasm.__wbg_set_brotlistreamresult_code(this.ptr, arg0);
        }
        get buf() {
            try {
                const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
                wasm.__wbg_get_brotlistreamresult_buf(retptr, this.ptr);
                var r0 = getInt32Memory0()[retptr / 4 + 0];
                var r1 = getInt32Memory0()[retptr / 4 + 1];
                var v0 = getArrayU8FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
                return v0;
            } finally{
                wasm.__wbindgen_add_to_stack_pointer(16);
            }
        }
        set buf(arg0) {
            const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.__wbg_set_brotlistreamresult_buf(this.ptr, ptr0, len0);
        }
        get input_offset() {
            const ret = wasm.__wbg_get_brotlistreamresult_input_offset(this.ptr);
            return ret >>> 0;
        }
        set input_offset(arg0) {
            wasm.__wbg_set_brotlistreamresult_input_offset(this.ptr, arg0);
        }
    }
    class CompressStream {
        static __wrap(ptr) {
            const obj = Object.create(CompressStream.prototype);
            obj.ptr = ptr;
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.ptr;
            this.ptr = 0;
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm.__wbg_compressstream_free(ptr);
        }
        constructor(quality){
            const ret = wasm.compressstream_new(!isLikeNone(quality), isLikeNone(quality) ? 0 : quality);
            return CompressStream.__wrap(ret);
        }
        compress(input_opt, output_size) {
            try {
                const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
                var ptr0 = isLikeNone(input_opt) ? 0 : passArray8ToWasm0(input_opt, wasm.__wbindgen_malloc);
                var len0 = WASM_VECTOR_LEN;
                wasm.compressstream_compress(retptr, this.ptr, ptr0, len0, output_size);
                var r0 = getInt32Memory0()[retptr / 4 + 0];
                var r1 = getInt32Memory0()[retptr / 4 + 1];
                var r2 = getInt32Memory0()[retptr / 4 + 2];
                if (r2) {
                    throw takeObject(r1);
                }
                return BrotliStreamResult.__wrap(r0);
            } finally{
                wasm.__wbindgen_add_to_stack_pointer(16);
            }
        }
        total_out() {
            const ret = wasm.compressstream_total_out(this.ptr);
            return ret >>> 0;
        }
    }
    class DecompressStream {
        static __wrap(ptr) {
            const obj = Object.create(DecompressStream.prototype);
            obj.ptr = ptr;
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.ptr;
            this.ptr = 0;
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm.__wbg_decompressstream_free(ptr);
        }
        constructor(){
            const ret = wasm.decompressstream_new();
            return DecompressStream.__wrap(ret);
        }
        decompress(input, output_size) {
            try {
                const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
                const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);
                const len0 = WASM_VECTOR_LEN;
                wasm.decompressstream_decompress(retptr, this.ptr, ptr0, len0, output_size);
                var r0 = getInt32Memory0()[retptr / 4 + 0];
                var r1 = getInt32Memory0()[retptr / 4 + 1];
                var r2 = getInt32Memory0()[retptr / 4 + 2];
                if (r2) {
                    throw takeObject(r1);
                }
                return BrotliStreamResult.__wrap(r0);
            } finally{
                wasm.__wbindgen_add_to_stack_pointer(16);
            }
        }
        total_out() {
            const ret = wasm.decompressstream_total_out(this.ptr);
            return ret >>> 0;
        }
    }
    async function load(module, imports) {
        if (typeof Response === 'function' && module instanceof Response) {
            if (typeof WebAssembly.instantiateStreaming === 'function') {
                try {
                    return await WebAssembly.instantiateStreaming(module, imports);
                } catch (e) {
                    if (module.headers.get('Content-Type') != 'application/wasm') {
                        console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
                    } else {
                        throw e;
                    }
                }
            }
            const bytes = await module.arrayBuffer();
            return await WebAssembly.instantiate(bytes, imports);
        } else {
            const instance = await WebAssembly.instantiate(module, imports);
            if (instance instanceof WebAssembly.Instance) {
                return {
                    instance,
                    module
                };
            } else {
                return instance;
            }
        }
    }
    async function init(input) {
        if (typeof input === 'undefined') {
            input = new URL("data:application/wasm;base64,AGFzbQEAAAAByQQ4YAJ/fwBgAn9/AX9gA39/fwBgA39/fwF/YAF/AGABfwF/YAV/f39/fwBgBn9/f39/fwBgBH9/f38AYAV/f39/fwF/YAZ/f39/f38Bf2AHf39/f39/fwBgCH9/f39/f39/AGAEf39/fwF/YAx/f39/f39/f39/f38AYA5/f39/f39/f39/f39/fwBgCX9/f39/f39/fwBgC39/f39/f39/f39/AX9gCn9/f39/f39/f38AYAAAYA1/f39/f39/f39/f39/AGAIf39/f39/f38Bf2AOf39/f39/f39/f39/f38Bf2ABfwF+YAABf2AJf39/f39/f39/AX9gAX8BfWAFf39/fn8AYAp/f39/f39/f39/AX9gC39/f39/f39/f39/AGAHf39/f39/fwF/YAN/f38BfmAPf39/f39/f39/f39/f39/AGAQf39/f39/f39/f39/f39/fwBgFH9/f39/f39/f39/f39/f39/f39/AGAEf39/fgBgBX9+f39/AGABfgF/YAN+f38Bf2ACf38BfmABfQF9YBJ/f39/f39/f39/f39/f39/f38AYAl/f39/f39+fn4AYBV/f39/fn9/f39/f39/f39/f39/f38AYAV/f35/fwBgBH5/f38AYAx/f39/f39/f39/f38Bf2APf39/f39/f39/f39/f39/AX9gEH9/f39/f39/f39/f39/f38Bf2AHf39/fn9/fwF/YAN/fH8Bf2AEf3x/fwF/YAJ+fwF/YAJ/fwF9YAR/f39/AX1gAn9/AXwCsAIKA3diZxdfX3diaW5kZ2VuX2lzX3VuZGVmaW5lZAAFA3diZxRfX3diaW5kZ2VuX2lzX29iamVjdAAFA3diZxVfX3diaW5kZ2VuX3N0cmluZ19uZXcAAQN3YmcUX193YmluZGdlbl9lcnJvcl9uZXcAAQN3YmcZX193YmluZGdlbl9qc29uX3NlcmlhbGl6ZQAAA3diZxpfX3diZ19uZXdfNjkzMjE2ZTEwOTE2MjM5NgAYA3diZxxfX3diZ19zdGFja18wZGRhY2E1ZDFhYmZiNTJmAAADd2JnHF9fd2JnX2Vycm9yXzA5OTE5NjI3YWMwOTkyZjUAAAN3YmcaX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYABAN3YmcQX193YmluZGdlbl90aHJvdwAAA7IHsAcGCgIGDgwMDA0UBRwNFhYWDwcwEBAQGQodCQIJIgcLFAURBwcHAg8IBwcHBwkNBgQPDw8QDw8PDxQUFhYWEQYEBgYBCgYDARwEGhoaDAYGEQwBEQIJBiAKCwoDBRERKwYGIQsLBhIuFAANEQczAxICDAIAEQkNBgYJEhIHGQoKEgoCGQwABwcHEAIQBxkKAwMRLxAEBDIEBAIDEQYDDgAcAwMiBAECABQDIQoGAAICCwsIDggICAkGAAgGBgILDRUJAAQAAA8pADQKCgoHCQwIAwQIBwMSEh0bHQsGAQoAACobAAwBAgcEBgAUAQkQBA0BHgACBQAeDAQGCQEJAQ4CBQAKAxAmBwQCCgAKATcABAcHBQ0ECAcEBAMHAAULAAcHAAEkCRUECAYBGAYBCgAPNgIEBAECGQIAAigFDg4ODg4ODg4ODgETBAIABjEBCQAVFRUVAgEEBQkJCQcEAhsBBgQCAgMGByMLACQJCQkLDQYABgQBAQYGAgAGAggICAgICAgEAgICCAgAAAgGDQgMDAwCBQMCAgkJEgAACwYDBQgHCAICAgICAgICAgICAAAAAAAABgAHAgIIDwUICDUIBgMDAAUcIwgFLBAEAAEIBAACAgEAAAAAAAAAAAAAAAICAAsCCAgEAAAFAwYEBAEBAQEEAQEAAAYIDQEHAwAFBQgAAgEBAh4AAAAABAsLBgAEAi0GBgYAAAIMAgAACAQFAAgICAECAAAABQgICAQABggEAgICAgIEGwcGAAIABAUAAAEICQQBAAknAQAABQYGBgMTDQMDGAAAAgQHAAYADQcJAQgIAAIICAIAAgABAwEBAQEBAAEAAQIABAcEAAAAAAAAAAAAAAAAAQYGAAAACAsABQYEBQUACAAHBwcDBAEAAgQHBwcBASABAQEIAwIEAwICAgICAgICAgACBQIAAgAABwcHBwcHBAADAAACAwMEAAgMAAEEEwQCABMDAAQBGAQCAAAAAAAKAAEAAAAAAAAAAAAAAAAAAAAJBwcHBwcHBwUlHwAFAgQAJQUAAQEBAQEAAAAABAUaGgQFAAUFBQUEHwUBAAAfAQ0CCAAAAgQTAyYIBAIBAwYBAQIBAAQBAAAFBAEFKBcAAQEFAAIABCcCAwENAQUBAQMBBQUBBgEBBAADAQEBBAAFBAAAAAUAAQUFAwUBBQUABQEBAgICAQMBAQUBAQEEExMAAgUBAAUFAAEFBQUFAAMDAwMDAQEABAQEGAEBAQUFABcXFxcEAgQFAXABcXEFAwEAHAYJAX8BQYCAwAALB/AEFgZtZW1vcnkCAAhjb21wcmVzcwCKBApkZWNvbXByZXNzAKQEHV9fd2JnX2Jyb3RsaXN0cmVhbXJlc3VsdF9mcmVlAJIGIV9fd2JnX2dldF9icm90bGlzdHJlYW1yZXN1bHRfY29kZQCnBiFfX3diZ19zZXRfYnJvdGxpc3RyZWFtcmVzdWx0X2NvZGUA2wUgX193YmdfZ2V0X2Jyb3RsaXN0cmVhbXJlc3VsdF9idWYA5gQgX193Ymdfc2V0X2Jyb3RsaXN0cmVhbXJlc3VsdF9idWYAjwQpX193YmdfZ2V0X2Jyb3RsaXN0cmVhbXJlc3VsdF9pbnB1dF9vZmZzZXQAqAYpX193Ymdfc2V0X2Jyb3RsaXN0cmVhbXJlc3VsdF9pbnB1dF9vZmZzZXQAnAYZX193YmdfY29tcHJlc3NzdHJlYW1fZnJlZQCdARJjb21wcmVzc3N0cmVhbV9uZXcA6QUXY29tcHJlc3NzdHJlYW1fY29tcHJlc3MA7wIYY29tcHJlc3NzdHJlYW1fdG90YWxfb3V0AKkGG19fd2JnX2RlY29tcHJlc3NzdHJlYW1fZnJlZQC8AhRkZWNvbXByZXNzc3RyZWFtX25ldwDqBRtkZWNvbXByZXNzc3RyZWFtX2RlY29tcHJlc3MAlgMaZGVjb21wcmVzc3N0cmVhbV90b3RhbF9vdXQAqgYRX193YmluZGdlbl9tYWxsb2MAkAYSX193YmluZGdlbl9yZWFsbG9jALsGH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAjQcPX193YmluZGdlbl9mcmVlANIGCeUBAQBBAQtwuAenB64HuAezB7MHswfaBekCwAa4B5cGjge4B48HuAeQB+cGTPAGkQf9BrYC/wS4B+QGuAftBqwC9wTNBtQG0wapB7QH+QapB7kHiQfuBs0G/Qa2ArgHyQaLB8QG9AWzAu8GuAeqBcoGuAe1B7gHlweYBpoGlwa4B98GtAW4B5kGuAecB9QG8AbWBLgH2AWHAvkE4QacB8YG7wauBsgG0wa2B7UHuQbUAusD8wX3BrcHwwbOBrgH2QWEB/oE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Ih8gCEobaiEVIBhBACAFLgESIiAgCEobaiEUIBhBACAFLgEQIiEgCEobaiETIBhBACAFLgEOIiIgCEobaiESIBhBACAFLgEMIiMgCEobaiENIBhBACAFLgEKIiUgCEobaiEPIBhBACAFLgEIIiYgCEobaiEQIBhBACAFLgEGIikgCEobaiEZIBhBACAFLgEEIisgCEobaiERIBhBACAFLgECIiwgCEobaiEOIBhBACAFLgEAIi0gCEobaiEbIAcgGEEAIAUuAR4iLiAIShtqQRB0QRB1IgcgGk4EQCAHIC5qIgcgB0EQdEESdWshByAMIBxqIgwgDEEQdEESdWshDCAXIB1qIhcgF0EQdEESdWshFyAWIB5qIhYgFkEQdEESdWshFiAVIB9qIhUgFUEQdEESdWshFSAUICBqIhQgFEEQdEESdWshFCATICFqIhMgE0EQdEESdWshEyASICJqIhIgEkEQdEESdWshEiANICNqIg0gDUEQdEESdWshDSAPICVqIg8gD0EQdEESdWshDyAQICZqIhAgEEEQdEESdWshECAZIClqIhkgGUEQdEESdWshGSARICtqIhEgEUEQdEESdWshESAOICxqIg4gDkEQdEESdWshDiAbIC1qIhsgG0EQdEESdWshGyAKICRqIgogCkEQdEESdWshCgsgBiAHOwEeIAYgCjsBHCAGIAw7ARogBiAXOwEYIAYgFjsBFiAGIBU7ARQgBiAUOwESIAYgEzsBECAGIBI7AQ4gBiANOwEMIAYgDzsBCiAGIBA7AQggBiAZOwEGIAYgETsBBCAGIA47AQIgBiAbOwEAIAEgAkEFakEHcWotAAAiG0EJdCAnciIBIABBHGooAgAiEU8NByAAKAIYIicgAUEFdGoiByAJQQF0ai8BACECIARB/wFxQRBPBH8gCUF/aiIBQRBPDREgAiAHIAFBAXRqLwEAawUgAgtB//8DcUECdEGQx9IAaioCACFKIAcvAR4iBkECdEGQx9IAaioCACFLIAcvAQAgBy8BAiAHLwEEIAcvAQYgBy8BCCAHLwEKIAcvAQwgBy8BDiAHLwEQIAcvARIgBy8BFCAHLwEWIAcvARggBy8BGiAHLwEcIAVCjYC4gPCBgAg3ATggBUKJgKiAsIGABjcBMCAFQoWAmIDwgIAENwEoIAVCgYCIgLCAgAI3ASAgBSAFQSBqEO0FIAtBACAFLgEcIiQgCUobaiEOIAtBACAFLgEaIhwgCUobaiECIAtBACAFLgEYIh0gCUobaiEBIAtBACAFLgEWIh4gCUobaiEKIAtBACAFLgEUIh8gCUobaiEMIAtBACAFLgESIiAgCUobaiEXIAtBACAFLgEQIiEgCUobaiEWIAtBACAFLgEOIiIgCUobaiEVIAtBACAFLgEMIiMgCUobaiEUIAtBACAFLgEKIiUgCUobaiETIAtBACAFLgEIIiYgCUobaiESIAtBACAFLgEGIikgCUobaiENIAtBACAFLgEEIisgCUobaiEPIAtBACAFLgECIiwgCUobaiEQIAtBACAFLgEAIi0gCUobaiEZIAYgC0EAIAUuAR4iCyAJShtqQRB0QRB1IgYgKE4EQCAGIAtqIgYgBkEQdEESdWshBiAOICRqIg4gDkEQdEESdWshDiACIBxqIgIgAkEQdEESdWshAiAKIB5qIgogCkEQdEESdWshCiAMIB9qIgwgDEEQdEESdWshDCAXICBqIhcgF0EQdEESdWshFyAWICFqIhYgFkEQdEESdWshFiAVICJqIhUgFUEQdEESdWshFSAUICNqIhQgFEEQdEESdWshFCATICVqIhMgE0EQdEESdWshEyASICZqIhIgEkEQdEESdWshEiANIClqIg0gDUEQdEESdWshDSAPICtqIg8gD0EQdEESdWshDyAQICxqIhAgEEEQdEESdWshECAZIC1qIhkgGUEQdEESdWshGSABIB1qIgEgAUEQdEESdWshAQsgByAGOwEeIAcgDjsBHCAHIAI7ARogByABOwEYIAcgCjsBFiAHIAw7ARQgByAXOwESIAcgFjsBECAHIBU7AQ4gByAUOwEMIAcgEzsBCiAHIBI7AQggByANOwEGIAcgDzsBBCAHIBA7AQIgByAZOwEAICogG0EPcUEJdHJBAXIiASARTw0IICcgAUEFdGoiECAIQQF0ai8BACECIAgEfyAIQX9qIgFBEE8NESACIBAgAUEBdGovAQBrBSACC0H//wNxQQJ0QZDH0gBqKgIAIUwgEC8BHiIHQQJ0QZDH0gBqKgIAIU0gEC8BACAQLwECIBAvAQQgEC8BBiAQLwEIIBAvAQogEC8BDCAQLwEOIBAvARAgEC8BEiAQLwEUIBAvARYgEC8BGCAQLwEaIBAvARwg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AnRqIgYgBigCACALajYCACAAKAIAIgYgA08NBCAHKAK4CCEIIAcqArwIIRIgAiAGQYgIbGogB0E4akGACBClByIGIBI4AoQIIAYgCDYCgAggACAHKgLMECISOAIIIAEoAhBBAUYEQCAAQQxqIBI4AgALIABBADYCJCAAKAIoIgYgA08NECACIAZBiAhsakEAQYQIEKMHQaPg//sHNgKECCAAIAAoAixBAWoiAjYCLCACQQFNDRMgACAAKAIUIAAoAiBqNgIgDBMLIA0gA0H08sAAELwEAAsgB0EYaiABQQhqEJgHIAogBygCHCIGTw0IIAcoAhggCkECdGogCzYCACABKAIQIQggB0EQaiABEJgHIAAoAhwiBiAHKAIUIglPDQkgBygCECAGaiAIOgAAIAAgACgCADYCBCAAKgIIIRMgACASOAIIIABBDGogEzgCACABIAEoAhAiBkEBajYCECAAIAZB/wFxNgIAIAAgACgCHEEBajYCHCAAIAAoAihBAWoiBjYCKCAGIAQoAgBPDQ8gBiADSQRAIAIgBkGICGxqQQBBhAgQowdBo+D/+wc2AoQIDBALIAYgA0Gk88AAELwEAAsgCiAGTw0JIAggCkECdGogCzYCACAHQShqIAEQmAcgACgCHCIGQX5qIgggBygCLCIJTw0KIAcoAiggCGotAAAhCCAHQSBqIAEQmAcgBiAHKAIkIglPDQsgBygCICAGaiAIOgAAIAAoAgQhBiAAIAAoAgA2AgQgACAGNgIAIAYgA08NDCAHKALAECEIIAcqAsQQIRIgAiAGQYgIbGogD0GACBClByIGIBI4AoQIIAYgCDYCgAggAEEANgIkIAAqAgghEiAAIAcqAtAQOAIIIABBDGogEjgCACAAIAAoAhxBAWo2AhwgACgCKCIGIANJBEAgAiAGQYgIbGpBAEGECBCjByAAQQA2AixBo+D/+wc2AoQIIAAgACgCFDYCIAwRCyAGIANB9PPAABC8BAALIAkgBkGE9MAAELwEAAsgBiADQZT0wAAQvAQAC0EAQQBBtPTAABC8BAALQQBBAEHE9MAAELwEAAtBAEEAQdT0wAAQvAQACyAGIANJBEAgAiAGQYgIbGpBAEGECBCjB0Gj4P/7BzYChAgMCgsgBiADQeT0wAAQvAQACyAGIANB5PLAABC8BAALIAogBkGE88AAELwE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TQ0EIAJBAkYNAyABQXxqIQwgCEF+aiEKIAEoAgggASgCBCAJampBCHRBA25BpANqIQdBACEEQQAhBUEAIQYDQCAGIAhJIQsCQAJAAkACQAJAAkACQCAGIAhGIgkNACAGQcAFTw0CIAMgBmotAAANACAGBEAgBkF/aiIAQcAFTw0EIAAgA2otAAANAQsgBiACTw0EIAEgBkECdGooAgAiAEEIdCAHa0GodmpB0GxPDQELIARBA01BACAEQQNHIAVyGw0EQQEgBSAEQQF2aiIAIARuIAQgAEsbQQAgBRshACAGQX9qIQUgDCAGQQJ0aiEHA0AgBSACSQRAIAcgADYCACAHQXxqIQcgBUF/aiEFIARBf2oiBA0BDAYLCyAFIAJBsPviABC8BAALIAAgBWohBSAEQQFqIgRBA00NBCAFQQh0IARBAXZqIARuIgBB+ABqIAAgBEEERhshBwwECyAGQcAFQYD74gAQvAQACyAAQcAFQZD74gAQvAQACyAGIAJBoPviABC8BAALAkACQAJAAkAgBiAKTwRAQQAhByALDQEMBAsgBiACTw0BIAZBAWoiBCACTw0CIAZBAmoiACACSQRAIAEgAEECdGooAgAgASAGQQJ0aigCACABIARBAnRqKAIAampBCHRBA25BpANqIQcMBAsgACACQeD74gAQvAQACyAGIAJJBEAgASAGQQJ0aigCAEEIdCEHDAMLIAYgAkHw++IAELwEAAsgBiACQcD74gAQvAQACyAEIAJB0PviABC8BAALQQAhBUEBIQQgCQ0AIAYgAk8NAyABIAZBAnRqKAIAIQULIAYgCE8gBiALaiIGIAhLckUNAAsLDwsgBiACQYD84gAQvAQACyAFQcAFQcD64gAQvAQAC0ECQQJB8PriABC8BAALQQFBAUHg+uIAELwEAAsgBCACQdD64gAQvAQACyAEIAJBsPriABC8BAALIAIgAkHw+eIAELwEAAsgAiACQeD54gAQvAQAC6MLAgx/AX4jAEGQE2siBiQAIAZB+AFqEPEGIANBoARuIQcCQCADRQRAIAVBATYCEAwBCyADQYABTwRAIAZB8AFqIAdBAWoiB0EyIAdBMkkbIgcQ8gMgASACIAMgByAGKALwASIIIAYoAvQBIgkQmgIgASACIAMgByAIIAkQpAIgBkHoAWogACADENcFIAYgBikD6AE3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IBUgAkGYiMAAELwEAAsgCCAFQaiIwAAQvAQACyABIAVBuIjAABC8BAALIAMgBUHIiMAAELwEAAsgBiAFQdiIwAAQvAQACyAFIABB6IjAABC8BAALIAEgAEH4iMAAELwEAAsgASAAQYiJwAAQvAQACyACIAFBAnRqIARBDGo2AgAgC0EQaiQAC4gKAQF/IwBBMGsiAiQAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAC0AAEEBaw4RAQIDBAUGBwgJCgsMDQ4PEBEACyACIAAtAAE6AAggAkEkakECNgIAIAJBLGpBATYCACACQfC8wQA2AiAgAkEANgIYIAJBLTYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwRCyACIAApAwg3AwggAkEkakECNgIAIAJBLGpBATYCACACQdS8wQA2AiAgAkEANgIYIAJBLjYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwQCyACIAApAwg3AwggAkEkakECNgIAIAJBLGpBATYCACACQdS8wQA2AiAgAkEANgIYIAJBLzYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwPCyACIAArAwg5AwggAkEkakECNgIAIAJBLGpBATYCACACQbi8wQA2AiAgAkEANgIYIAJBMDYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwOCyACIAAoAgQ2AgggAkEkakECNgIAIAJBLGpBATYCACACQZi8wQA2AiAgAkEANgIYIAJBMTYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwNCyACIAApAgQ3AwggAkEkakEBNgIAIAJBLGpBATYCACACQYS8wQA2AiAgAkEANgIYIAJBMjYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwMCyACQSRqQQE2AgAgAkEsakEANgIAIAJB9LvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwLCyACQSRqQQE2AgAgAkEsakEANgIAIAJB4LvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwKCyACQSRqQQE2AgAgAkEsakEANgIAIAJBzLvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwJCyACQSRqQQE2AgAgAkEsakEANgIAIAJBuLvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwICyACQSRqQQE2AgAgAkEsakEANgIAIAJBoLvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwHCyACQSRqQQE2AgAgAkEsakEANgIAIAJBkLvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwGCyACQSRqQQE2AgAgAkEsakEANgIAIAJBhLvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwFCyACQSRqQQE2AgAgAkEsakEANgIAIAJB+LrBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwECyACQSRqQQE2AgAgAkEsakEANgIAIAJB5LrBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwDCyACQSRqQQE2AgAgAkEsakEANgIAIAJBzLrBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwCCyACQSRqQQE2AgAgAkEsakEANgIAIAJBtLrBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwBCyABIAAoAgQgAEEIaigCABDjBgsgAkEwaiQAC7IIAhp/BX4jAEEwayIHJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIARBCGogBU0EQCAAQRRqKAIAIQggACgCECEOIAdBCGogAEEYahCYByAHKAIMIQkgBygCCCEPIAcgCDYCECAHIAAoAgQiBjYCFCAGIAhHDQEgByAJNgIQIAcgACgCBCAAEJkHbCIGNgIUIAYgCUcNESAFIARrIhRBBE8EQCAUQQJ2IRUgADUCAEI/gyEhIAQhBQNAIAMgBXEiBiACTw0EIAZBAWoiECACTw0FIAZBAmoiESACTw0GIAZBA2oiEiACTw0HIAZBBGoiCiACTw0IIAZBBWoiCyACTw0JIAZBBmoiDCACTw0KIAEgCmoxAAAhICABIAxqMQAAISIgASALajEAACEjIAggASAGajEAACABIBBqMQAAQgiGhCABIBFqMQAAQhCGhCABIBJqMQAAQhiGhCIkQr3P1vEBfkL/////D4MgIYinIgpNDQsgDiAKQQF0aiILIAsvAQAiFkEBajsBACAAKAIIIRcgCCAgQiCGICSEIiBCCIhCvc/W8QF+Qv////8PgyAhiKciC00NDCAOIAtBAXRqIgwgDC8BACIYQQFqOwEAIAAoAgghGSAIICNCKIYgIIQiIEIQiEK9z9bxAX5C/////w+DICGIpyIMTQ0NIA4gDEEBdGoiDSANLwEAIhpBAWo7AQAgACgCCCEbIAggICAiQjCGhEIYiEK9z9bxAX5C/////w+DICGIpyINTQ0OIA4gDUEBdGoiEyATLwEAIhNBAWo7AQAgACgCCCEcIAAoAgwhHSAAKAIMIR4gACgCDCEfIBYgF3EgCiAAKAIMdGoiCiAJTw0PIA8gCkECdGogBjYCACAYIBlxIAsgHXRqIgYgCU8NECAPIAZBAnRqIBA2AgAgGiAbcSAMIB50aiIGIAlPDREgDyAGQQJ0aiARNgIAIBMgHHEgDSAfdGoiBiAJTw0SIA8gBkECdGogEjYCACAFQQRqIQUgFUF/aiIVDQALCyAUQXxxIARqIQQLIAdBMGokACAEDwsgB0EANgIgIAdBEGogB0EUaiAHQRhqQfiRwAAQ8QQACyAGIAJBmJLAABC8BAALIBAgAkGoksAAELwEAAsgESACQbiSwAAQvAQACyASIAJByJLAABC8BAALIAogAkHYksAAELwEAAsgCyACQeiSwAAQvAQACyAMIAJB+JLAABC8BAALIAogCEGIk8AAELwEAAsgCyAIQZiTwAAQvAQACyAMIAhBqJPAABC8BAALIA0gCEG4k8AAELwEAAsgCiAJQciTwAAQvAQACyAGIAlB2JPAABC8BAALIAYgCUHok8AAELwEAAsgBiAJQfiTwAAQvAQACyAHQQA2AiAgB0EQaiAHQRRqIAdBGGpBiJLAABDxBAALgAgCD38IfiMAQRBrIgokACAAQRRqKAIAIQYgACgCECEJIAAoAgAhEiAKQQhqIABBGGoQmAcCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADIARxIgUgAkkEQCAFQQFqIgggAk8NASAFQQJqIgsgAk8NAiAFQQNqIgwgAk8NAyAFQQRqIg0gAk8NBCAFQQVqIg4gAk8NBSAFQQZqIg8gAk8NBiAFQQdqIhAgAk8NByAEQQhqIANxIgcgAk8NCCAHQQFqIhEgAk8NCSAKKAIMIQIgCigCCCEDIAEgDWoxAAAhFCABIA5qMQAAIRYgASAPajEAACEXIAEgEGoxAAAhGCABIAdqMQAAIRkgASARajEAACEaIAYgASAFajEAACABIAhqMQAAQgiGhCABIAtqMQAAQhCGhCABIAxqMQAAQhiGhCIbQr3P1vEBfkL/////D4MgEkE/ca0iFYinIgFNDQogCSABQQF0aiIFIAUvAQAiC0EBajsBACAAKAIIIQwgBiAUQiCGIBuEIBZCKIaEIhRCEIhCvc/W8QF+Qv////8PgyAViKciBU0NCyAJIAVBAXRqIgcgBy8BACINQQFqOwEAIAAoAgghDiAGIBdCMIYgFIQgGEI4hoQiFEIgiEK9z9bxAX5C/////w+DIBWIpyIHTQ0MIAkgB0EBdGoiCCAILwEAIg9BAWo7AQAgACgCCCEQIAYgGUIQhiAaQhiGhCAUQjCIhEK9z9bxAX5C/////w+DIBWIpyIITQ0NIAkgCEEBdGoiBiAGLwEAIgZBAWo7AQAgACgCCCEJIAAoAgwhESAAKAIMIRIgACgCDCETIAsgDHEgASAAKAIMdGoiACACTw0OIAMgAEECdGogBDYCACANIA5xIAUgEXRqIgAgAk8NDyADIABBAnRqIARBAmo2AgAgDyAQcSAHIBJ0aiIAIAJPBEAgACACQaiLwAAQvAQACyADIABBAnRqIARBBGo2AgAgBiAJcSAIIBN0aiIAIAJJDRAgACACQbiLwAAQvAQACyAFIAJBqInAABC8BAALIAggAkG4icAAELwEAAsgCyACQciJwAAQvAQACyAMIAJB2InAABC8BAALIA0gAkHoicAAELwEAAsgDiACQfiJwAAQvAQACyAPIAJBiIrAABC8BAALIBAgAkGYisAAELwEAAsgByACQaiKwAAQvAQACyARIAJBuIrAABC8BAALIAEgBkHIisAAELwEAAsgBSAGQdiKwAAQvAQACyAHIAZB6IrAABC8BAALIAggBkH4isAAELwEAAsgACACQYiLwAAQvAQACyAAIAJBmIvAABC8BAALIAMgAEECdGogBEEGajYCACAKQRBqJAALlAkBA38jAEEwayIDJAAgA0EgaiAAEKoEAn8CQAJAAkACQAJAAkAgAy0AIA0AAkACQAJAAkACQAJAAkACQAJAIAMtACEiBEHt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DQMgDkF/aiILIAVxIg8gEU8NBiAGIBogD0ECdGooAgAiE2shDwJAIB0gBEsNACAEIBNxIhMgDWoiFiAESw0AIA0gEE8NCCAWIANPDQkgHC0AACACIBZqLQAARw0AIA8gCEsNBCATIANLDQogDkF/aiELIAIgE2ogAyATayASIBAgBxAlIgVFDQIgHyAFIA8gFxCxBiIeWg0CIAogDzYCECAKIAU2AgggCiAeNwMAIA5Bf2ohC0EBIRggBSENIB4hHwwDCyAPIAhNDQALCwsLIAUgDHEiAiARTw0GIBogAkECdGogBjYCAEEBIQsgGSAZLwEAQQFqOwEAIBgNByABRQRAQQAhCwwICyABIAAgEiAQIAcgCCAJIAoQ3QIhCwwHC0HkjsAAQSNBqIzAABC4BQALQeSOwABBI0G4jMAAELgFAAsgDyARQaSNwAAQvAQACyANIBBBtI3AABC8BAALIBYgA0HEjcAAELwEAAtB5I7AAEEjQdSNwAAQuAUACyACIBFB5I3AABC8BAALIBRBEGokACALC74JAgx/BH4jAEHAAmsiAyQAIAMgAjYCXCADIAE2AlggA0HQAGogA0HYAGoQmAcgAygCVCEEIANB4ABqIgFCADcDACABQRBqQQA2AgAgAUEIakIANwMAIANByABqEKoHIAMoAkwhASADKAJIIQUgA0H4AGoQvgYgA0GQAWoQvgYgA0GoAWoQvgYgA0FAaxCrByADKAJEIQYgAygCQCEHIANBOGoQqwcgAygCPCEIIAMoAjghCSADQTBqEKoHIAMoAjQhCiADKAIwIQsgA0EoaiICQQA6AAIgAkEAOwEAIANBwAJqIQwgA0HAAWohAiADLQAqIQ0gAy8BKCEOA0AgAiAOOwEAIAJBAmogDToAACACQQRqIgIgDEcNAAsgA0EgahCrByADKQNYIQ8gAykDICEQIANBGGoQqgcgAykDGCERIANBEGoQqgcgAykDECESIABB2A1qQgA3AwAgAEHQDWpCADcDACAAQcgNakIANwMAIABCADcDwA0gAEEAOgCKESAAQQA2AtAPIAAgAykDYDcD8A0gAEH4DWogA0HoAGopAwA3AwAgAEGADmogA0HwAGopAwA3AwAgAEIANwLUDyAAQgA3A4gOIABB3A9qQgA3AgAgAEHkD2pCADcCACAAQewPakIANwIAIABBADsB8BAgAEGUDmogATYCACAAIAU2ApAOIABB6A1qQouAgIDAADcDACAAQpCAgIDwATcD4A0gAEG8m+sANgLoECAAQQA2AvwPIABCADcC9A8gACADKQN4NwKYDiAAQaAOaiADQYABaikDADcCACAAQagOaiADQYgBaikDADcCACAAIAMpA5ABNwKwDiAAQbgOaiADQZgBaikDADcCACAAQcAOaiADQaABaikDADcCACAAQgA3A4AQIABBADYCiBAgAEGYD2pCADcDACAAQZAPakIANwMAIABCADcDiA8gAEGsD2ogCDYCACAAQagPaiAJNgIAIABBpA9qIAY2AgAgAEGgD2ogBzYCACAAQgA3AowQIABBlBBqQgA3AgAgAEGwD2pCADcDACAAQbgPakIANwMAIABBwA9qQgA3AwAgAEHFD2pCADcAACAAQdgOaiADQbgBaikDADcCACAAQdAOaiADQbABaikDADcCACAAIAMpA6gBNwLIDiAAQQA7AI8RIABBADsBhBEgAEHkDmogCjYCACAAIAs2AuAOIABBATYC7BAgAEGcEGpBAEEkEKMHGiAAIANBwAFqQYABEKUHIgBCADcB8hAgAEEQNgLAECAAQfoQakIANwEAIABBghFqQQA7AQAgAEIANwLEECAAQcwQakIANwIAIABB1BBqQQA2AgAgAEGAAWpBAEHADBCjBxogAEH/ATYC2BAgACAQNwPoDiAAQZERakEAQYECEKMHGiAAQQA7AZITIAAgBDYC3BAgACAPNwPwDiAAQQA2AIsRIABBADYBhhEgAEIANwPgECAAIBI3A4APIAAgETcD+A4gA0EIakG4CBDKBCADKAIMIQEgAygCCCECIABB7A5qKAIABEAgACgC6A4QUgsgAEEBOgCPESAAIAI2AugOIAAgATYC7A4gAEHwDWoiAEHAADYCCCAAQgA3AwAgA0HAAmokAAvXBwIFfwF+IAIpAwAhCgJAAkACQAJAAkACQAJAAkACQAJAAkAgAigCCCIGQTBPBEAgAigCDCIFQQhqIQcgBUF3Sw0BIAcgBEsNAiACIAVBBmo2AgwgAiACKAIQQXpqNgIQIAIgAyAFaiIFMQABQhiGIAUxAABCEIYgCkIwiISEIAUxAAJCIIaEIAUxAANCKIaEIAUxAARCMIaEIAUxAAVCOIaEIgo3AwAgBkEwcyEGCyAK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BAALIABBgAFB5InjABC8BAALIABBgAFB9InjABC8BAALIABBgAFBhIrjABC8BAALIABBgAFBpIrjABC8BAALIABBgAFBtIrjABC8BAALIABBgAFB5IrjABC8BAALIABBgAFBhIvjABC8BAALIABBgAFBlIvjABC8BAALIABBgAFBxIvjABC8BAALIAMgAEECdGoiACAAKAIAQQFqNgIAC/8HAgp/AX4jAEEwayIHJAAgA0GOEWohDyADQfANaiELIAMtAI0RIQYDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAGQQdxQQFrDgQGAAECAwsgAygC7A4hCCADKALoDiEJIANCAjcD6A4gAygC0BAgASgCAGoiBiAGIAkgCEEAQQAgAyAEIAUQlgEhBiADKALsDiADIAg2AuwOIAMoAugOIQggAyAJNgLoDgRAIAgQUgsgBkEBRw0JQQMhBiADQQM6AI0RIANB//8DNgLUEAwLCyACKAIEIQogAigCACEMIAMoAtAQIQ0gAygCzBAhBiAHIAMoAtQQIgg2AhwgCEH//wNHIQkgCEH//wNHIAYgAElyDQIMCQtBACEJIAdBADYCIEEBIQYgC0EBIAdBIGogBCAFEM4ERQRAQQIhBkEEIQkMBwsgBygCIEUNBkFhIQYgAy0AkRENByACKAIAIAIoAgQgACADQZIRaiADQdgQahC+A0EBIQYMBgsgDyALIAEgBCAFENgCIgZBAUYNAQwGCwNAAkACQCAJQQFxDQACQCADKALoDiADKALsDiALIAdBHGogBCAFELQBBEACQAJAIAcoAhwiCEUEQCAGIApPDQIgBiAMakEAOgAADAELIAggDU0NBCAGIApPDQMgBiAMaiAIIA1rOgAACyAGQQFqIQYMBAsgBiAKQdyl4wAQvAQACyADIAY2AswQIANB//8DNgLUEAwGCyAGIApBzKXjABC8BAALIAdBADYCIAJAIAsgCCAHQSBqIAQgBRDOBARAIAcoAiBBASAIdGoiCSAGaiAATQ0BQXghBgwJCyADIAY2AswQIAMgCDYC1BAMBQsgCiAGIAogBksbIQ4DQCAGIA5HBEAgBiAMakEAOgAAIAZBAWohBiAJQX9qIgkNAQwCCwsgDiAKQeyl4wAQvAQAC0EAIQkgBiAASQ0ACwwGCyADQQA2AswQIAEgASgCAEEBaiIG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+OIAELwEAAsgCyAFQYD54gAQvAQACyAIIAVBkPniABC8BAALIAogBUGg+eIAELwEAAsgDUEBdCENIBFBf2ogBCAFIAYgByADEJMCRQ0BCwsLgwYCA38BfiMAQUBqIgIkACABQSBqIQMCQAJAAkACQAJAAkACQAJAAkACQCABKAIgIgRBfmoOCQABAgMHBwcEBQYLIAJBOGoiASADQRBqKQIANwMAIAJBMGoiBCADQQhqKQIANwMAIAIgAykCADcDKCACQQhqQYmABBDWBSACKQMIIQUgAxDzBiEDIAAgBTcCBCAAQTBqIAM2AgAgAEEsakEANgIAIABBJGpCATcCACAAQQE2AgAgAEEMaiACKQMoNwIAIABBFGogBCkDADcCACAAQRxqIAEpAwA3AgAMCAsgAkE4aiIBIANBEGopAgA3AwAgAkEwaiIEIANBCGopAgA3AwAgAiADKQIANwMoIAJBEGpBioAEENYFIAIpAxAhBSADEPMGIQMgACAFNwIEIABBMGogAzYCACAAQSxqQQA2AgAgAEEkakIBNwIAIABBAjYCACAAQQxqIAIpAyg3AgAgAEEUaiAEKQMANwIAIABBHGogASkDADcCAAwHCyACQThqIgEgA0EQaikCADcDACACQTBqIgQgA0EIaikCADcDACACIAMpAgA3AyggAkEYakGIgAgQ1gUgAikDGCEFIAMQ8wYhAyAAIAU3AgQgAEEwaiADNgIAIABBLGpBADYCACAAQSRqQgE3AgAgAEEDNgIAIABBDGogAikDKDcCACAAQRRqIAQpAwA3AgAgAEEcaiABKQMANwIADAYLIAAgARCoAQwFCyAAQQRqIAEQkwMgAEEJNgIADAQLIABBBGogARDNAyAAQQo2AgAMAwsgBEE2Rg0BCyAAIAEQmAIMAQsgAkE4aiIBIANBEGopAgA3AwAgAkEwaiIEIANBCGopAgA3AwAgAiADKQIANwMoIAJBIGpBjIDAABDWBSACKQMgIQUgAxDzBiEDIAAgBTcCBCAAQTBqIAM2AgAgAEEsakEANgIAIABBJGpCATcCACAAQQQ2AgAgAEEMaiACKQMoNwIAIABBFGogBCkDADcCACAAQRxqIAEpAwA3AgALIAJBQGskAAuMBgEEfyMAQZABayIGJAAgAEEANgIsIABCADcCJCAAQYAENgIgIABBADYCHCAA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IgdB/wFLDQEgAyABLwEAIgcgAUFgai8BACIIazsBBCAHIAhGDQIMAwsgAS8BAA0CIANBADYCECABIANBCGpB+JPjABDwBAALIAdBgAJB2JPjABC8BAALIANBADYCECADQQRqIANBCGpB6JPjABDwBAALIAFBAmohASACQQFqIgINAAsgAEEgaiEAIAZBEGohBiIEQRBHDQALIANBIGokAA8LIAJBgAJB2JLjABC8BAALIANBADYCECADQQRqQZCR4wAgA0EIakGokuMAEPEEAAv4BQEFfyMAQYAVayIKJAAgCkEAQYACEKMHIglBgAJqQQBBgAQQowcaIAlBgAZqQQBBgAgQowcaIAlBgA5qQQBBgAEQowcaIAlBgA9qQQBBgAIQowcaIAlBgBFqQQBBgAQQowcaAkACQAJAAkAgAgRAA0AgASALRg0CIAlBgAZqIAAgC2otAABBAnRqIgogCigCAEEBajYCACACIAtBAWoiC0cNAAsLIAlBgAZqQYACIAJBCCAJQYACIAlBgAJqQYACIAYgByAIECIgBUUNAUEAIQsgAyECAkADQCAEIAtGDQEgAi0AACIKQYABTw0FIAlBgBFqIApBAnRqIgogCigCAEEBajYCACACQQRqIQIgBSALQQFqIgtHDQALIAkgCSgC0BNBAWo2AtATIAkgCSgCgBNBAWo2AoATIAkgCSgCiBFBAWo2AogRIAkgCSgChBFBAWo2AoQRIAlBgBFqIAlBgA5qIAlBgA9qIAYgByAIEIUBA0ACQAJAAkACQCAEIAxHBEAgAyAMQQJ0aigCACILQf8BcSICQYABTw0BIAlBgA5qIAJqLQAAIAlBgA9qIAJBAXRqMwEAIAYgByAIEPQCIAJBAnQiCkH05OIAaigCACALQQh2IgutIAYgByAIEPQCIAJBGE8NBCABIApB9OjiAGooAgAgC2oiCkkNAiAAIQsgCiICRQ0DA0AgCSALLQAAIg1qLQAAIAlBgAJqIA1BAXRqMwEAIAYgByAIEPQCIAtBAWohCyACQX9qIgINAAsMAwsgBCAEQZS5wAAQvAQACyACQYABQaS5wAAQvAQACyAKIAFBtLnAABCHBwALIAAgCmohACABIAprIQELIAxBAWoiDCAFRw0ACwwDCyAEIARB9LjAABC8BAALIAEgAUHkuMAAELwEAAsgCUEBNgLQEyAJ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CQJAIA4iCEUNAANAIAQgCXEiCyADSQRAIAogAiALai0AAEECdGoiCyALKAIAQQFqNgIAIAlBAWohCSAIQX9qIggNAQwCCwsgCyADQZCRwQAQvAQACyAMIA5qIA9qIQwgDUEBaiINIAdHDQALCyAKQYACQYACQQEgCkGwImpBgAIQ3QFBACEJIApBgAhqQcAFQcAFQQAgAEHABRDdASAKQYAeakGMASAAKAKQFkEAIAAoAoAWIABBhBZqKAIAEN0BQ57J/34hEANAIBAgECAAIAlqKgIAIhEgECARXRsgESARXBshECAJQQRqIgUhCSAFQYAWRw0ACyAAIBA4ApQWAkACQCAAQYwWaigCACIFBEAgACgCmBYhBkEAIQkgACgCiBYiAEEANgIAIAYEQCAAQQRqIQggBUF/aiEHQwAAAAAhEANAIAEgCWogBHEiACADTw0DIAcgCUYNBCAIIBAgEiAKQbAiaiAAIAJqLQAAQQJ0aioCAJIiEpIiETgCACASIBEgEJOTIRIgCEEEaiEIIBEhECAGIAlBAWoiCUcNAAsLIApBsCpqJAAPC0EAQQBBoJHBABC8BAALIAAgA0GwkcEAELwEAAsgBSAFQcCRwQAQvAQAC6wEAQF/IwBB0CprIgEkACABQQhqIAAQowUgAUEIahCZAgJAAn8CQAJAAkACQAJAAkACQAJAAkACQCABKAKQKQ4KCwECAwQFBgcICQALIAFBmClqKAIABEAgAUGUKWooAgAQUgsgAUGgKWooAgBFDQogAUGcKWoMCQsgAUGYKWooAgBFDQkgAUGUKWoMCAsgAUGYKWooAgBFDQggAUGUKWoMBwsgAUGYKWooAgBFDQcgAUGUKWoMBgsgAUGYKWooAgBFDQYgAUGUKWoMBQsgAUGoKWooAgAEQCABQaQpaigCABBSCyABQbApaigCAEUNBSABQawpagwECyABQZgpaigCAARAIAFBlClqKAIAEFILIAFBoClqKAIARQ0EIAFBnClqDAMLIAFBmClqKAIABEAgAUGUKWooAgAQUgsgAUGgKWooAgBFDQMgAUGcKWoMAgsgAUG0KWooAgAEQCABQbApaigCABBSCyABQbwpaigCAEUNAiABQbgpagwBCyABQZgpaigCAARAIAFBlClqKAIAEFILIAFBoClqKAIARQ0BIAFBnClqCygCABBSCyABQZgqaigCAARAIAEoApQqEFILIAFB7ChqKAIABEAgASgC6CgQUgsgAUH0KGooAgAEQCABKALwKBBSCyABQfwoaigCAARAIAEoAvgoEFILIAFBhClqKAIABEAgASgCgCkQUgsgAUGMKWooAgAEQCABKAKIKRBSCyABQdAqaiQAC5cGAQR/IwBBkAFrIgEkACABQZABaiEDIAFBEGohAgNAIAJBADsBACACQQJqQQA6AAAgAkEEaiICIANHDQALIABCADcDwA0gAEEAOgCKESAAQgA3A/ANIABCADcDiA4gAEHYDWpCADcDACAAQdANakIANwMAIABByA1qQgA3AwAgAEH4DWoiAkIANwMAIABBgA5qQQA2AgAgAEHQD2pBAEEkEKMHGiAAQQA7AfAQIABCATcDkA4gAEHoDWpCi4CAgMAANwMAIABCkICAgPABNwPgDSAAQbyb6wA2AugQIABBADYC/A8gAEIANwL0DyAAQaQOakIANwIAIABBoA5qQQI2AgAgAEIENwOYDiAAQawOakEAOwEAIABBuA5qQQI2AgAgAEIENwOwDiAAQbwOakIANwIAIABBxA5qQQA7AQAgAEIENwPIDiAAQdAOakECNgIAIABB3A5qQQA7AQAgAEHUDmpCADcCACAAQQA2AogQIABCADcDgBAgAEIANwOIDyAAQZAPakIANwMAIABBmA9qQgA3AwAgAEGoD2pBAjYCACAAQaAPakICNwMAIABCADcCjBAgAEGUEGpCADcCACAAQawPakEAQSEQowcaIABBADoAkBEgAEEAOwGEESAAQgE3A+AOIABBATYC7BAgAEGcEGpBAEEkEKMHGiAAIAFBEGpBgAEQpQciAEIANwHyECAAQRA2AsAQIABB+hBqQgA3AQAgAEGCEWpBADsBACAAQgA3AsQQIABBzBBqQgA3AgAgAEHUEGpBADYCACAAQYABakEAQcAMEKMHGiAAQf8BNgLYECAAQgI3A+gOIABBkRFqQQBBgQIQowcaIABBADsBkhMgAEEANgLcECAAQgE3A/AOIABBADYAixEgAEEANgGGESAAQgA3A+AQIABCATcDgA8gAEIBNwP4DiAAQQE6AI8RIAFBCGpBuAgQygQgASgCDCEDIAEoAgghBCAAQewOaigCAARAIAAoAugOEFILIAAgBDYC6A4gAEIANwPwDSAAIAM2AuwOIAJBwAA2AgAgAUGQAWokAAuoBQIFfwZ+IwBBgAFrIgMkACABvSEIAkAgASABYgRAQQIhBAwBCyAIQv////////8HgyIMQoCAgICAgIAIhCAIQgGGQv7///////8PgyAIQjSIp0H/D3EiBhsiCUIBgyEKQQMhBAJAAkACQEEBQQJBBCAIQoCAgICAgID4/wCDIg1QIgcbIA1CgICAgICAgPj/AFEbQQNBBCAHGyAMUBtBfmoOAwABAgMLQQQhBAwCCyAGQc13aiEFIAqnQQFzIQRCASELDAELQoCAgICAgIAgIAlCAYYgCUKAgICAgICACFEiBRshCUICQgEgBRshCyAKp0EBcyEEQct3Qcx3IAUbIAZqIQULIAMgBTsBeCADIAs3A3AgA0IBNwNoIAMgCTcDYCADIAQ6AHoCfyAEQQJGBEBByNvrACECQQAMAQsgAkUEQEG78+sAQcjb6wAgCEIAUxshAiAIQj+IpwwBC0G78+sAQbzz6wAgCEIAUxshAkEBCyEGQQEhBQJ/AkACQAJAAkAgBEF+akEDIARBAUsbQf8BcUEBaw4DAgEAAwsgA0EgaiADQeAAaiADQQ9qECQCQCADKAIgRQRAIANB0ABqIANB4ABqIANBD2oQDAwBCyADQdgAaiADQShqKAIANgIAIAMgAykDIDcDUAsgAyADKAJQIAMoAlQgAy8BWEEAIANBIGoQ8AEgAygCBCEFIAMoAgAMAwsgA0ECOwEgIANBATYCKCADQb3z6wA2AiQgA0EgagwCCyADQQM2AiggA0G+8+sANgIkIANBAjsBICADQSBqDAELIANBAzYCKCADQcHz6wA2AiQgA0ECOwEgIANBIGoLIQQgA0HcAGogBTYCACADIAQ2AlggAyAGNgJUIAMgAjYCUCAAIANB0ABqEK4BIANBgAFqJAALhgYBH38jAEGAAWsiASQAIAFB+ABqQYCABBDWBSABKAJ4IQIgASgCfCEDIAFB8ABqQYCABBDWBSABKAJwIQQgASgCdCEFIAFB6ABqQYCABBDWBSABKAJoIQYgASgCbCEHIAFB4ABqQYCABBDWBSABKAJgIQggASgCZCEJIAFB2ABqQYCABBDWBSABKAJYIQogASgCXCELIAFB0ABqQYCABBDWBSABKAJQIQwgASgCVCENIAFByABqQYCABBDWBSABKAJIIQ4gASgCTCEPIAFBQGtBgIAEENYFIAEoAkAhECABKAJEIREgAUE4akGAgAQQ1gUgASgCOCESIAEoAjwhEyABQTBqQYCABBDWBSABKAIwIRQgASgCNCEVIAFBKGpBgIAEENYFIAEoAighFiABKAIsIRcgAUEgakGAgAQQ1gUgASgCICEYIAEoAiQhGSABQRhqQYCABBDWBSABKAIYIRogASgCHCEbIAFBEGpBgIAEENYFIAEoAhAhHCABKAIUIR0gAUEIakGAgAQQ1gUgASgCCCEeIAEoAgwhHyAAQfcBakIANwAAIABCADcD8AEgACAfNgLsASAAIB42AugBIABCADcD4AEgACAdNgLcASAAIBw2AtgBIABCADcD0AEgACAbNgLMASAAIBo2AsgBIABCADcDwAEgACAZNgK8ASAAIBg2ArgBIABCADcDsAEgACAXNgKsASAAIBY2AqgBIABCADcDoAEgACAVNgKcASAAIBQ2ApgBIABCADcDkAEgACATNgKMASAAIBI2AogBIABCADcDgAEgACARNgJ8IAAgEDYCeCAAQgA3A3AgACAPNgJsIAAgDjYCaCAAQgA3A2AgACANNgJcIAAgDDYCWCAAQgA3A1AgACALNgJMIAAgCjYCSCAAQgA3A0AgACAJNgI8IAAgCDYCOCAAQgA3AzAgACAHNgIsIAAgBjYCKCAAQgA3AyAgACAFNgIcIAAgBDYCGCAAQgA3AxAgACADNgIMIAAgAjYCCCAAQgA3AwAgAUGAAWokAAuGBAACQAJ/AkACQAJAAkACQAJAAkACQAJAAkAgACgCiCkOCgsBAgMEBQYHCAkACyAAQZApaigCAARAIABBjClqKAIAEFILIABBmClqKAIARQ0KIABBlClqDAkLIABBkClqKAIARQ0JIABBjClqDAgLIABBkClqKAIARQ0IIABBjClqDAcLIABBkClqKAIARQ0HIABBjClqDAYLIABBkClqKAIARQ0GIABBjClqDAULIABBoClqKAIABEAgAEGcKWooAgAQUgsgAEGoKWooAgBFDQUgAEGkKWoMBAsgAEGQKWooAgAEQCAAQYwpaigCABBSCyAAQZgpaigCAEUNBCAAQZQpagwDCyAAQZApaigCAARAIABBjClqKAIAEFILIABBmClqKAIARQ0DIABBlClqDAILIABBrClqKAIABEAgAEGo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A3FBA0YbIAMgAUF/RxshAwsgAEH0DmooAgAhBSAAKALwDiEHAkACQAJAAkACQAJAAkAgACgC3BAiAiAEQXBqIgFNBEAgAiAFTQRAIAIhAQwCCyACIAVBvKnjABCHBwALIAIgBUsNASAAIAE2AtwQIAcgAiABa2ohBwsCQCADQf8BcUUgBEEhSHINACAEIAAoAogQIAFqQQF0IgVIDQAgBCECA0ACQCACQQF1IQMgAkHCAEgNACADIQIgAyAFTg0BCwsgACADIAQgAyAESBsiBDYC6A8LIAAgBEF/aiIDNgLsDyAGQQhqIARBwgBqIgJBARCCBSAGKQMIIQogBiACNgIYIAYgCjcDECAGIAZBEGoQlwUgBigCBCECIAYoAgAhBCAAQZQOaigCAARAIAAoApAOEFILIAAgAjYClA4gACAENgKQDgJAIAJFDQAgAyACTw0CIAMgBGpBADoAACAAKALoD0F+aiIDIAAoApQOIgRPDQMgACgCkA4iCSADakEAOgAAIAEEQCAAKALsD0EAIAAoAtwQIgNrcSIFIANqIgggBUkNBSAIIARLDQYgASADRw0HIAUgCWogByABEKUHGgsgACgC9A5FDQAgACgC8A4gAEIBNwPwDhBSCyAGQSBqJAAgAkEARw8LIAIgBUGsqeMAEIcHAAsgAyACQcyp4wAQvAQACyADIARB3KnjABC8BAALIAUgCEHsqeMAEIgHAAsgCCAEQeyp4wAQhwcACyADIAFB/KnjABDABAAL+QQBCn8jAEEwayIDJAAgA0EDOgAoIANCgICAgIAENwMgIANBADYCGCADQQA2AhAgAyABNgIMIAMgADYCCAJ/AkACQCACKAIAIgpFBEAgAkEUaigCACIARQ0BIAIoAhAhASAAQQN0IQUgAEF/akH/////AXFBAWohByACKAIIIQADQCAAQQRqKAIAIgQEQCADKAIIIAAoAgAgBCADKAIMKAIMEQMADQQLIAEoAgAgA0EIaiABQQRqKAIAEQEADQMgAUEIaiEBIABBCGohACAFQXhqIgUNAAsMAQsgAigCBCIARQ0AIABBBXQhCyAAQX9qQf///z9xQQFqIQcgAigCCCEAA0AgAEEEaigCACIBBEAgAygCCCAAKAIAIAEgAygCDCgCDBEDAA0DCyADIAUgCmoiBEEcai0AADoAKCADIARBFGopAgA3AyAgBEEQaigCACEGIAIoAhAhCEEAIQlBACEBAkACQAJAIARBDGooAgBBAWsOAgACAQsgBkEDdCAIaiIMQQRqKAIAQeAARw0BIAwoAgAoAgAhBgtBASEBCyADIAY2AhQgAyABNgIQIARBCGooAgAhAQJAAkACQCAEQQRqKAIAQQFrDgIAAgELIAFBA3QgCGoiBkEEaigCAEHgAEcNASAGKAIAKAIAIQELQQEhCQsgAyABNgIcIAMgCTYCGCAIIAQoAgBBA3RqIgEoAgAgA0EIaiABKAIEEQEADQIgAEEIaiEAIAsgBUEgaiIFRw0ACwsgByACQQxqKAIASQRAIAMoAgggAigCCCAHQQN0aiIAKAIAIAAoAgQgAygCDCgCDBEDAA0BC0EADAELQQELIANBMGokAAvsBAEDfyMAQTBrIhQkACAUIAMQ0QQgFEEQaiAEENEEIBRBIGogBRDRBAJAAkACQCACBEADQAJAAkACQAJAIAEgFUcEQCAUQRBqEPADIBQoAhQiAyARTw0BIBAgA0GIFmxqIAAgFUEEdGoiBS8BDBDxBSAFKAIAIgRFDQQDQCAUEPADIBQoAgQhAyANBEAgAyANTw0EIANBBnQCfwJAAkACQAJAIAMgDGotAABBAWsOAwEDAgALIApBP3EMAwsgCkH8AXFBAnYMAgsgC0H/AXFBkMHSAGotAAAgCkH/AXFBkMHSAGotAABBA3RqDAELIAtB/wFxQZDF0gBqLQAAIApB/wFxQZDD0gBqLQAAcgtB/wFxaiEDCyADIA9PDQQgCCAJcSILIAdJBEAgDiADQYgIbGogBiALai0AACIDEPAFIAhBAWohCCAKIQsgAyEKIARBf2oiBEUNBgwBCwsgCyAHQcCewAAQvAQACyABIAFBgJ7AABC8BAALIAMgEUGQnsAAELwEAAsgAyANQaCewAAQvAQACyADIA9BsJ7AABC8BAALIAUQlgcgCGohCAJAIAUQlgdFDQAgCEF+aiAJcSIDIAdPDQMgCEF/aiAJcSIEIAdPDQQgAyAGai0AACELIAQgBmotAAAhCiAFQQxqLwEAQf8ATQ0AIBRBIGoQ8AMgFCgCJCEDIAUQxgUgA0ECdGoiAyATTw0FIBIgA0GIEWxqIAUvAQ5B/wdxEO8FCyAVQQFqIhUgAkcNAAsLIBRBMGokAA8LIAMgB0HQnsAAELwEAAsgBCAHQeCewAAQvAQACyADIBNB8J7AABC8BAALygUBH38jAEGAAWsiASQAIAFB+ABqEKwHIAEoAnghAiABKAJ8IQMgAUHwAGoQrAcgASgCcCEEIAEoAnQhBSABQegAahCsByABKAJoIQYgASgCbCEHIAFB4ABqEKwHIAEoAmAhCCABKAJkIQkgAUHYAGoQrAcgASgCWCEKIAEoAlwhCyABQdAAahCsByABKAJQIQwgASgCVCENIAFByABqEKwHIAEoAkghDiABKAJMIQ8gAUFAaxCsByABKAJAIRAgASgCRCERIAFBOGoQrAcgASgCOCESIAEoAjwhEyABQTBqEKwHIAEoAjAhFCABKAI0IRUgAUEoahCsByABKAIoIRYgASgCLCEXIAFBIGoQrAcgASgCICEYIAEoAiQhGSABQRhqEKwHIAEoAhghGiABKAIcIRsgAUEQahCsByABKAIQIRwgASgCFCEdIAFBCGoQrAcgASgCCCEeIAEoAgwhHyAAQfcBakIANwAAIABCADcD8AEgACAfNgLsASAAIB42AugBIABCADcD4AEgACAdNgLcASAAIBw2AtgBIABCADcD0AEgACAbNgLMASAAIBo2AsgBIABCADcDwAEgACAZNgK8ASAAIBg2ArgBIABCADcDsAEgACAXNgKsASAAIBY2AqgBIABCADcDoAEgACAVNgKcASAAIBQ2ApgBIABCADcDkAEgACATNgKMASAAIBI2AogBIABCADcDgAEgACARNgJ8IAAgEDYCeCAAQgA3A3AgACAPNgJsIAAgDjYCaCAAQgA3A2AgACANNgJcIAAgDDYCWCAAQgA3A1AgACALNgJMIAAgCjYCSCAAQgA3A0AgACAJNgI8IAAgCDYCOCAAQgA3AzAgACAHNgIsIAAgBjYCKCAAQgA3AyAgACAFNgIcIAAgBDYCGCAAQgA3AxAgACADNgIMIAAgAjYCCCAAQgA3AwAgAUGAAWokAAvnBAEJfyMAQRBrIgQkAAJAAkACfwJAIAAoAghBAUYEQCAAQQxqKAIAIQcgBEEMaiABQQxqKAIAIgU2AgAgBCABKAIIIgI2AgggBCABKAIEIgM2AgQgBCABKAIAIgE2AgAgAC0AICEJIAAoAhwhCiAALQAYQQhxDQEgCiEIIAkhBiADDAILIAAoAgAgAEEEaigCACABEKMBIQIMAwsgACgCACABIAMgACgCBCgCDBEDAA0BQQEhBiAAQQE6ACBBMCEIIABBMDYCHCAEQQA2AgQgBEHI2+sANgIAQQAgByADayIDIAMgB0sbIQdBAAshASAFBEAgBUEMbCEDA0ACfwJAAkACQCACLwEAQQFrDgICAQALIAJBBGooAgAMAgsgAkEIaigCAAwBCyACQQJqLwEAIgVB6AdPBEBBBEEFIAVBkM4ASRsMAQtBASAFQQpJDQAaQQJBAyAFQeQASRsLIQUgAkEMaiECIAEgBWohASADQXRqIgMNAAsLAn8CQCAHIAFLBEAgByABayIBIQMCQAJAAkAgBkEDcSICQQFrDgMAAQACC0EAIQMgASECDAELIAFBAXYhAiABQQFqQQF2IQMLIAJBAWohAiAAQQRqKAIAIQEgACgCACEGA0AgAkF/aiICRQ0CIAYgCCABKAIQEQEARQ0ACwwDCyAAKAIAIABBBGooAgAgBBCjAQwBCyAGIAEgBBCjAQ0BQQAhAgNAQQAgAiADRg0BGiACQQFqIQIgBiAIIAEoAhARAQBFDQALIAJBf2ogA0kLIQIgACAJOgAgIAAgCjYCHAwBC0EBIQILIARBEGokACACC7UEAg5/AX4CQAJAIAJBDE0EQCACQQJJDQEgAUEBIAFBAUsbIQUgACEGQQEhBANAAkAgBCAFRwRAIARBAWohCCAAIARBA3RqKQIAIhFCMIinQRB0QRB1IQkgEachByAGIQMDQCADQQZqLgEAIAlIIAMoAgAiCiAHSyAHIApGG0UNAiADQQhqIAMpAgA3AgAgA0F4aiEDIARBf2oiBA0AC0EAIQQMAQsgBSABQaj34gAQvAQACyAEIAFJBEAgACAEQQN0aiARNwIAIAZBCGohBiAIIgQgAkcNAQwDCwsgBCABQbj34gAQvAQACyACQTlJQQF0IQkDQCAJQQJ0Qfj34gBqKAIAIgUgAkkEQCAFIAEgBSABSxshCkEAIQdBACAFQQN0Ig1rIQ4gACEIIAUhBgNAAkAgBiAKRwRAIAAgBkEDdGopAgAhESAGIgMgBUkNASARQjCIp0EQdEEQdSEPIBGnIQwgCCEDIAchBANAAkAgBCABSQRAIANBBmouAQAgD0ggAygCACILIAxLIAsgDEYbDQEgBCAFaiEDDAQLIAQgAUHY9+IAELwEAAsgAyANaiADKQIANwIAIAMgDmohAyAEIAVJIAQgBWsiECEERQ0ACyAFIBBqIQMMAQsgCiABQcj34gAQvAQACyADIAFPDQQgACADQQN0aiARNwIAIAhBCGohCCAHQQFqIQcgBkEBaiIGIAJHDQALCyAJQQFqIglBBkcNAAsLDwsgAyABQej34gAQvAQAC48FARN/IwBBQGoiAiQAIAJBOGogARCYBwJAAkACQAJAAkACQAJAIAIoAjwgASgCFCIDTwRAIAIoAjghBCACQTBqIAFBCGoQmAcgAigCNCABKAIUIgVJDQEgAigCMCEGIAEoAhAhByACQShqIAFByABqEJgHIAIoAiwgASgCcCIISQ0CIAIoAighCSACQSBqIAFBGGoQmAcgAigCJCABQSxqKAIAIgpJDQMgAigCICELIAJBGGogAUEgahCYByACKAIcIAEoAiwiDEkNBCACKAIYIQ0gAUEoaigCACEOIAJBEGogAUEwahCYByACKAIUIAFBxABqKAIAIg9JDQUgAigCECEQIAJBCGogAUE4ahCYByACKAIMIAEoAkQiEUkNBiACKAIIIRIgAUFAaygCACETIAIgAUHQAGoQmAcgAigCBCABKAJ0IgFJDQcgAigCACEUIAAgBDYCECAAIBA2AjggACALNgIkIAAgCDYCBCAAIAk2AgAgACAUNgIIIABBIGogBzYCACAAQRxqIAU2AgAgAEEYaiAGNgIAIABBFGogAzYCACAAQcgAaiATNgIAIABBxABqIBE2AgAgAEFAayASNgIAIABBPGogDzYCACAAQTRqIA42AgAgAEEwaiAMNgIAIABBLGogDTYCACAAQShqIAo2AgAgAEEMaiABNgIAIAJBQGskAA8LQb7BwABBI0HUxMAAELgFAAtBvsHAAEEjQeTEwAAQuAUAC0G+wcAAQSNB9MTAABC4BQALQb7BwABBI0GExcAAELgFAAtBvsHAAEEjQZTFwAAQuAUAC0G+wcAAQSNBpMXAABC4BQALQb7BwABBI0G0xcAAELgFAAtBvsHAAEEjQcTFwAAQuAUAC6QEAQF/AkACQAJAAkACQAJAAkACQAJAAkACQCAGKAIAQQFrDgoBAgMEBQYHCAkKAAtBxJHAAEEjQeiRwAAQuAYAC0HUvsEAQQAgBS0AWRsgACABIAIgAyAEIAUgBkEEaiAHIAggCSAKIAsgDBBBDwsgACABIAIgAyAEIAUgBkEEaiAHIAggCSAKIAsgDBBCDwtB1L7BAEEAIAUtAFkbIAAgASACIAMgBCAFIAZBBGogByAIIAkgCiALIAwQQA8LIAAgASACIAMgBCAFIAZBBGogByAIIAkgCiALIAwQQw8LQdS+wQBBACAFLQBZGyAAIAEgAiADIAQgBSAGQQRqIAcgCCAJIAogCyAMEDwPC0HUvsEAQQAgBS0AWRsgACABIAIgAyAEIAUgBkEEaiAHIAggCSAKIAsgDBA+DwtB1L7BAEEAIAUtAFkbIAAgASACIAMgBCAFIAZBBGogByAIIAkgCiALIAwQPw8LQdS+wQBBACAFLQBZGyAAIAEgAiADIAQgBSAGQQhqIAcgCCAJIAogCyAMEDoPC0HUvsEAQQAgBS0AWRsgACABIAIgAyAEIAUgBkEEaiAHIAggCSAKIAsgDBA7DwtB1L7BAEEAIAUtAFkbIQ0gBkEEaiEGIAUoAjhBCkwEQCANIAAgASACIAMgBCAFIAYgByAIIAkgCiALIAwQuQIPCyANIAAgASACIAMgBCAFIAYgByAIIAkgCiALIAwQMAvOBAICfwF+IwBBIGsiAyQAIANBEGogABCWBgJAIAACfwJAAkACQAJAAkACQAJAAkAgAy0AEARAIAMgAygCFDYCACADEJoEDAELAkAgAy0AESIEQeUATARAIARBIkYNBSAEQS1GDQYgBEHbAEcNASADQQo6ABAgA0EQaiABIAIQngMMCgsgBEHzAEwEQCAEQeYARg0IIARB7gBHDQEgABDrBiAAQYe7wABBAxD0AyIEDQsgA0EHOgAQIANBEGogASACEJ4DDAoLIARB9ABGDQggBEH7AEYNAwsgBEFQakH/AXFBCkkNAQsgA0EKNgIQIAAgA0EQahDMBAwHCyADIABBARCVByADKQMAQgNRDQMgA0EYaiADQQhqKQMANwMAIAMgAykDADcDECADQRBqIAEgAhDbBAwGCyADQQs6ABAgA0EQaiABIAIQngMMBQsgABDrBiAAQRRqQQA2AgAgAyAAIABBDGoQtwEgAygCAEECRwRAIAMpAgQhBSADQQU6ABAgAyAFNwIUIANBEGogASACEJ4DDAULIAMoAgQhBAwFCyAAEOsGIAMgAEEAEJUHIAMpAwBCA1ENACADQRhqIANBCGopAwA3AwAgAyADKQMANwMQIANBEGogASACENsEDAMLIAMoAgghBAwDCyAAEOsGIABBgLvAAEEEEPQDIgQNAiADQQA7ARAgA0EQaiABIAIQngMMAQsgABDrBiAAQYS7wABBAxD0AyIEDQEgA0GAAjsBECADQRBqIAEgAhCeAwsQqAchBAsgA0EgaiQAIAQL9gQBBX8jAEGQoQFrIhAkACAQQYjJAGogASACIAMgBCAFEKsDAkAgBy0AVUUNACAKIAtPBEAgEEGUyQBqKAIAIREgECgCkEkhEiAQKAKMSSETIBAoAohJIRQgEEGIyQBqEJUEIAAgCSALIBQgEyASIBEgCCAMIBBBiMkAaiAHQQAQDgwBC0G+wcAAQSNBoMvAABC4BQALIBBBCGpBAEGECBCjBxogEEGj4P/7BzYCjAggEEGQCGpBAEGEFhCjBxogEEGj4P/7BzYClB4gEEGYHmoQ8QYgEEGkL2pBAEGAAhCjBxogEEGkMWpBAEGABBCjBxogEEGkNWpBAEHABRCjBxogEEHkOmpBAEGACxCjBxogEEHkxQBqQQBBjAEQowcaIBBB8MYAakEAQZgCEKMHGiAQQYjJAGpBAEGI2AAQowcaIAcoAgghACAGIAQgDSAOIA8QygMgASACIAMgBSAJIAogCyAQQQhqIBBBkAhqIBBBmB5qEKMDQQ1CACANIA4gDxCtAiAQQQhqQYACQYACQYACIBBBiMkAakGBCyAQQaQvakGAAiAQQaQxakGAAiANIA4gDxBxIBBBkAhqQcAFQcAFQcAFIBBBiMkAakGBCyAQQaQ1akHABSAQQeQ6akHABSANIA4gDxBxIBBBmB5qQaAEQYwBIAAgEEGIyQBqQYELIBBB5MUAakGMASAQQfDGAGpBjAEgDSAOIA8QcSABIAIgAyAFIAkgCiALIBBBpC9qIBBBpDFqIBBBpDVqIBBB5DpqIBBB5MUAakGMASAQQfDGAGpBjAEgDSAOIA8Q0AEgBgRAIA0gDiAPEOwFCyAQQZChAWokAAu5BAEGfyMAQRBrIggkACAIQQA2AgwCQAJAAkACQAJAAkACQCACQQ8gCEEMaiAEIAUQ6wRFBEACQAJAIAIoAggiBEHAAEYEQCABRQ0CQQAhBSAALQACDQUgAC8BACEHDAELIAIpAwAgBEE/ca2IpyILQf8BcSIJIAFPDQVBwAAgBGshCiAAIAlBAnRqIgUvAQAhByAFLQACIgZBCU8EQEEAIQUgCkEJSQ0FIAZBIU8NByAHIAlqIAZBAnRB7J3jAGooAgAgC3FBCHZqIgYgAU8NCEE4IARrIAAgBkECdGotAAIiAUkNBSACIAEgBGpBCGo2AgggACAGQQJ0ai8BACEHDAELQQAhBSAKIAZJDQQgAiAEIAZqNgIICyADIAc2AgAMAgtBAEEAQbCh4wAQvAQACwJ/AkAgCCgCDCIHQf8BcSIGIAFJBEAgACAGQQJ0aiIFLwEAIQQgBS0AAiIFQQhLDQEgAigCCAwCCyAGIAFB8KDjABC8BAALIAVBeGpB/wFxIgVBIU8NBiAEIAZqIAVBAnRB7J3jAGooAgAgB0EIdnFqIgQgAU8NByAAIARBAnRqIgAtAAIhBSAALwEAIQQgAigCCEEIagshASADIARB//8DcTYCACACIAEgBUH/AXFqNgIIC0EBIQULIAhBEGokACAFDwsgCSABQZCh4wAQvAQACyAGQSFB3J/jABC8BAALIAYgAUGgoeMAELwEAAsgBUEhQdyf4wAQvAQACyAEIAFBgKHjABC8BAAL0AQCBn8BfiMAQeAHayIFJAACfyAEQf8BcUUEQEECIQdBAgwBCyAFQRhqQYCAxAAQ3wMgBSkDGCELIAVBgIDEADYC6AQgBSALNwPgBCAFQRBqIAVB4ARqEIoFIAUoAhQhCCAFKAIQIQcgBUEIakGAgIAQEN8DIAUpAwghCyAFQYCAgBA2AugEIAUgCzcD4AQgBSAFQeAEahCKBSAFKAIEIQkgBSgCAAshCiACKQAAIQsgBUHgBGoQ4AUDQCAFQaADaiAGaiICIAUpA+AENwIAIAJBCGogBUHoBGooAgA2AgAgBkEMaiIGQcABRw0ACyAFQSBqEOAFQQAhBgNAIAVB4ARqIAZqIgIgBSkDIDcCACACQQhqIAVBKGooAgA2AgAgBkEMaiIGQcABRw0ACyAFQSBqIAVBoANqQcABEKUHGiAFQeABaiAFQeAEakHAARClBxpBACEGA0AgBUHgBGogBmpBAEGAARCjBxogBkGAAWoiBkGAA0cNAAsgAEGAAjsBzAYgAEEANgLIBiAAIAEpAgA3AogGIAAgAykCADcCoAYgAEGYBmogAUEQaikCADcCACAAQZAGaiABQQhqKQIANwIAIABBqAZqIANBCGopAgA3AgAgAEGwBmogA0EQaikCADcCACAAIAVBIGpBgAMQpQciAEHEBmogCTYCACAAIAo2AsAGIABBvAZqIAg2AgAgACAHNgK4BiAAIAs3AoAGIABBgANqIAVB4ARqQYADEKUHGiAEQf8BcQRAIAcgCBCDAyAKIAkQgwMLIAVB4AdqJAAL2AQBBH8gACABEK8HIQICQAJAAkAgABCeBw0AIAAoAgAhAwJAIAAQgQdFBEAgASADaiEBIAAgAxCwByIAQdiX7AAoAgBHDQEgAigCBEEDcUEDRw0CQdCX7AAgATYCACAAIAEgAhC/Bg8LIAEgA2pBEGohAAwCCyADQYACTwRAIAAQngIMAQsgAEEMaigCACIEIABBCGooAgAiBUcEQCAFIAQ2AgwgBCAFNgIIDAELQciX7ABByJfsACgCAEF+IANBA3Z3cTYCAAsgAhD4BgRAIAAgASACEL8GDAILAkBB3JfsACgCACACRwRAIAJB2JfsACgCAEcNAUHYl+wAIAA2AgBB0JfsAEHQl+wAKAIAIAFqIgE2AgAgACABENYGDwtB3JfsACAANgIAQdSX7ABB1JfsACgCACABaiIBNgIAIAAgAUEBcjYCBCAAQdiX7AAoAgBHDQFB0JfsAEEANgIAQdiX7ABBADYCAA8LIAIQnQciAyABaiEBAkAgA0GAAk8EQCACEJ4CDAELIAJBDGooAgAiBCACQQhqKAIAIgJHBEAgAiAENgIMIAQgAjYCCAwBC0HIl+wAQciX7AAoAgBBfiADQQN2d3E2AgALIAAgARDWBiAAQdiX7AAoAgBHDQFB0JfsACABNgIACw8LIAFBgAJPBEAgACABEKUCDwsgAUF4cUHAlewAaiECAn9ByJfsACgCACIDQQEgAUEDdnQiAXEEQCACKAIIDAELQciX7AAgASADcjYCACACCyEBIAIgADYCCCABIAA2AgwgACACNgIMIAAgATYCCAvPBAEHfyMAQSBrIgUkAAJAAkACQCABKAIIIgQgASgCBCIGTw0AAkACQAJAAkACQAJAAkADQCABKAIAIARqIQhBACEHAkADQCAHIAhqLQAAIglB8KzBAGotAAANASABIAQgB2pBAWo2AgggBCAHQQFqIgdqIgMgBkkNAAsgAyEEDAkLIAQgB2ohAyAJQdwARwRAIAlBIkYNAiABIANBAWoiAjYCCCAFQQhqIAEgAhCvBCAFKAIMIQEgBSgCCCECIAVBDzYCECAFQRBqIAIgARDmBSEBIABBAjYCACAAIAE2AgQMCgsgAyAESQ0CIAMgBksNAyACIAggBxDjBSABIANBAWo2AgggAUEBIAIQTyIERQRAIAEoAggiBCABKAIEIgZJDQEMCQsLIABBAjYCACAAIAQ2AgQMCAsgAigCCARAIAMgBEkNAyADIAZLDQQgAiAIIAcQ4wUgASADQQFqNgIIIABBATYCACAAIAIpAgQ3AgQMCAsgAyAESQ0EIAMgBksNBSAAIAc2AgggAEEANgIAIAAgCDYCBCABIANBAWo2AggMBwsgBCADQaCswQAQiAcACyADIAZBoKzBABCHBwALIAQgA0HArMEAEIgHAAsgAyAGQcCswQAQhwcACyAEIANBsKzBABCIBwALIAMgBkGwrMEAEIcHAAsgBCAGRw0BIAUgASAEEK8EIAUoAgQhASAFKAIAIQIgBUEENgIQIAVBEGogAiABEOYFIQEgAEECNgIAIAAgATYCBAsgBUEgaiQADwsgBCAGQZCswQAQvAQAC4UEAQ1/IwBBEGsiByQAAkACQCACQQxNBEAgAkECSQ0BIAFBASABQQFLGyEEIAAhBkEBIQMDQAJAIAMgBEcEQCADQQFqIQkgByAAIANBA3RqKQIANwMAIAYhBQNAIAcgBRD/BkUNAiAFQQhqIAUpAgA3AgAgBUF4aiEFIANBf2oiAw0AC0EAIQMMAQsgBCABQZyzwAAQvAQACyADIAFJBEAgACADQQN0aiAHKQMANwIAIAZBCGohBiAJIgMgAkcNAQwDCwsgAyABQayzwAAQvAQACyACQTlJQQF0IQoDQCAKQQJ0Qfj34gBqKAIAIgQgAkkEQCAEIAEgBCABSxshDEEAIQtBACAEQQN0Ig1rIQ4gACEJIAQhBgNAAkAgBiAMRwRAIAcgACAGQQN0aikCADcDACAJIQUgCyEDIAYhCCAGIARJDQEDQAJAIAMgAUkEQCAHIAUQ/wYNASADIARqIQgMBAsgAyABQcyzwAAQvAQACyAFIA1qIAUpAgA3AgAgBSAOaiEFIAMgBEkgAyAEayIPIQNFDQALIAQgD2ohCAwBCyAMIAFBvLPAABC8BAALIAggAU8NBCAAIAhBA3RqIAcpAwA3AgAgCUEIaiEJIAtBAWohCyAGQQFqIgYgAkcNAAsLIApBAWoiCkEGRw0ACwsgB0EQaiQADwsgCCABQdyzwAAQvAQAC4EEAQN/AkACQAJAAkACQAJAAkACQAJAAkAgAEEGTwRAIABBggFJDQEgAEHCEEkNAiABLQA9IAIzAXogBCAFIAYQ9AJBDCAArUK+b3wgBCAFIAYQ9AJBPSEADAoLIABBKGoiAEGAAU8NAiAAQYABTw0DIAAgAWotAAAgAiAAQQF0ajMBACAEIAUgBhD0AiAAQYABTw0EDAkLIABBfmoiCGdBIGpBP3NBf2oiB0EBdCAIIAd2IglqQSpqIgBBgAFPDQQgAEGAAU8NBSAAIAFqLQAAIAIgAEEBdGozAQAgBCAFIAYQ9AIgByAIrSAJrSAHQT9xrYZ9IAQgBSAGEPQCIABBgAFJDQggAEGAAUH0huMAELwEAAsgAEG+f2oiCGdBIGpBP3MiB0EyaiIAQYABTw0FIABBgAFPDQYgACABai0AACACIABBAXRqMwEAIAQgBSAGEPQCIAcgCK1CfyAHQT9xrYZ8IAQgBSAGEPQCIABBgAFJDQcgAEGAAUGkh+MAELwEAAsgAEGAAUGkhuMAELwEAAsgAEGAAUG0huMAELwEAAsgAEGAAUHEhuMAELwEAAsgAEGAAUHUhuMAELwEAAsgAEGAAUHkhuMAELwEAAsgAEGAAUGEh+MAELwEAAsgAEGAAUGUh+MAELwEAAsgAyAAQQJ0aiIAIAAoAgBBAWo2AgALgQQBA38CQAJAAkACQAJAAkACQAJAAkACQCAAQQpPBEAgAEGGAUkNASAAQcYQSQ0CIAEtACcgAjMBTiAEIAUgBhD0AkEYIACtQrpvfCAEIAUgBhD0AkEnIQAMCgsgAEEOaiIAQYABTw0CIABBgAFPDQMgACABai0AACACIABBAXRqMwEAIAQgBSAGEPQCIABBgAFPDQQMCQsgAEF6aiIIZ0EgakE/c0F/aiIHQQF0IAggB3YiCWpBFGoiAEGAAU8NBCAAQYABTw0FIAAgAWotAAAgAiAAQQF0ajMBACAEIAUgBhD0AiAHIAitIAmtIAdBP3Gthn0gBCAFIAYQ9AIgAEGAAUkNCCAAQYABQZSN4wAQvAQACyAAQbp/aiIIZ0EgakE/cyIHQRxqIgBBgAFPDQUgAEGAAU8NBiAAIAFqLQAAIAIgAEEBdGozAQAgBCAFIAYQ9AIgByAIrUJ/IAdBP3GthnwgBCAFIAYQ9AIgAEGAAUkNByAAQYABQcSN4wAQvAQACyAAQYABQcSM4wAQvAQACyAAQYABQdSM4wAQvAQACyAAQYABQeSM4wAQvAQACyAAQYABQfSM4wAQvAQACyAAQYABQYSN4wAQvAQACyAAQYABQaSN4wAQvAQACyAAQYABQbSN4wAQvAQACyADIABBAnRqIgAgACgCAEEBajYCAAuHBAECfyMAQeAAayIEJAAgBCACNgIIAkACQAJAIAJBgAJGBEAgBEEgaiABIANBBHRB8AFxIgVBAXRqIgJBGGopAQA3AwAgBEEYaiACQRBqKQEANwMAIARBEGogAkEIaikBADcDACAEIAIpAQA3AwggA0H/AXEEQCAFQXBqIgJBgQJPDQIgBEFAayABIAJBAXRqIgJBGGopAQA3AwAgBEE4aiACQRBqKQEANwMAIARBMGogAkEIaikBADcDACAEIAIpAQA3AyhBACECA0AgBEEIaiACaiIDIAMvAQAgBEEoaiACai8BAGs7AQAgAkECaiICQSBHDQALCyAEQUBrIAFB+ANqKQEANwMAIARBOGogAUHwA2opAQA3AwAgBEEwaiABQegDaikBADcDACAEIAEpAeADNwMoQQAhAgNAIARBCGogAmoiAS8BACIDRQ0DIARBKGogAmoiAS8BACIFRQ0EIAAgACoCACADQQJ0QZDH0gBqKgIAIAVBAnRBkMfSAGoqAgCTkzgCACAAQQRqIQAgAkECaiICQSBHDQALIARB4ABqJAAPCyAEQQA2AjAgBEEIakGQkeMAIARBKGpB6JHjABDxBAALQdSO4wBBI0H4keMAELgFAAsgBEEANgJQIAEgBEHIAGpBiJLjABDwBAALIARBADYCUCABIARByABqQZiS4wAQ8AQAC4AEAQp/IwBB8AhrIhEkACARQQBBiAgQowciD0GICGpBAEHoABCjBxoCQAJAAkACQCAEBEBBASEQA0AgASANRg0CIBAhESAAIA1qLQAAIRAgDQRAIA9BAUEAIBBBAmogDCAQRhsgEUEBaiAQRhtBAnRqIgwgDCgCAEEBajYCAAsgAyANRg0DQRRBDiACIA1BAnRqKAIAIhJB8AVLG0EHQQAgEkEoSxsgEkGwAUsbIg5Bf2ohDCAOQQN0QdjRwQBqIRMgD0GICGogDkECdGohFAJAA0AgFCEOIAxBGEYNASAOQQRqIRQgDEEBaiEMIBMoAgAgE0EIaiETIBJNDQALIAxBGk8NBQsgDiAOKAIAQQFqNgIAIBEhDCANQQFqIg0gBEcNAAsLIAVBf2qtIAkgCiALEJwEAkAgBUEBSwRAIA9BggIgBUECaiIEIAQgBiAHIAhBwARqQYICIAhBCGpBggIgCSAKIAsQcSAPQYgIakEaQRpBGiAGIAcgCEHCBmpBGiAIQYwEakEaIAkgCiALEHEgA0UNBSABRQ0BIAggAigCACAALQAAQQEgCSAKIAsQpwILIA9B8AhqJAAPC0EAQQBBgNnBABC8BAALIAEgAUHA2MEAELwEAAsgAyADQdDYwQAQvAQACyAMQRpB4NjBABC8BAALQQBBAEHw2MEAELwEAAvOBAECfyMAQaDBAGsiBCQAEOEFAkACQAJAAkACQCADKAIAIgUQAEEBRwRAIAUQAUEBRg0BQdiowABBGBACIQMgAEEANgIAIAAgAzYCBAwFCyAEQaAhakGJqMAAQQIQ1wYgBEGgAWogBEGgIWoQ1gMgBCgCoAENASAEKAKkASEDDAMLIARBoCFqIAMQoQQgBCgCoCENASAEKAKkISEDDAILIAQgBCgCpAE2AqAhQZujwABBKyAEQaAhakHIo8AAQZiowAAQmAQACyAEIAQoAqQhNgKgAUGbo8AAQSsgBEGgAWpByKPAAEGoqMAAEJgEAAsgBEEANgIYIARCgICAgBA3AxAgBEEgahCGBSAEIAM2AlggBCACNgKMASAEIAE2AogBIARBoAFqQQBBgCAQowcaIARBoCFqQQBBgCAQowcaIARBgAFqIARBiAFqIARBEGogBEGgAWogBEGgIWogBEEgahCFBSAELQCAAUEERgRAIARBqCFqIARBGGooAgA2AgAgBCAEKQMQNwOgISAEQQhqIARBoCFqEJ8GIAAgBCkDCDcCAAwBCyAEIAQpA4ABNwOQASAEQQM2ApwBIAQgBEGQAWo2ApgBIARBATYCtCEgBEEBNgKsISAEQdCowAA2AqghIARBADYCoCEgBCAEQZgBajYCsCEgBEGgAWogBEGgIWoQwgEgBCgCpAEgBCgCqAEQAiEDIABBADYCACAAIAM2AgQgBEGgAWoQzQYgBEGQAWoQ0gUgBEEQahDNBgsgAgRAIAEQUgsgBEGgwQBqJAALjAQBCX8jAEGQAWsiBCQAIARBKGogACgCuAYgAEG8BmoiCCgCACACELYFIABBwANqIAQoAigiBSAEKAIsIgYgA0HwAXFBBHYiBxC7ASAEQTBqIAUgBhC7AiAEQSBqIAAoArgGIAgoAgAgAiAHEJUFIABBgANqIAQoAiAiBSAEKAIkIgYgA0EPcSIDELsBIARB0ABqIAUgBhC7AiAEQRhqIAAoAsAGIABBxAZqIgkoAgAgASACEJ0FIAQoAhwhBSAEKAIYIQYgBEGIAWoiCiAEQcgAaikBADcDACAEQYABaiILIARBQGspAQA3AwAgBEH4AGoiDCAEQThqKQEANwMAIAQgBCkBMDcDcCAAQcAFaiAGIAUgBEHwAGogBxClASAAQcAEaiAGIAUgBxC7ASAGIAUgBxCTASAEQRBqIAAoAsAGIAkoAgAgASACIAcQ5QQgBCgCFCEBIAQoAhAhBSAKIARB6ABqKQEANwMAIAsgBEHgAGopAQA3AwAgDCAEQdgAaikBADcDACAEIAQpAVA3A3AgAEGABWogBSABIARB8ABqIAMQpQEgAEGABGogBSABIAMQuwEgBSABIAMQkwEgBEEIaiAAKAK4BiAIKAIAIAIQtgUgBCgCCCAEKAIMIAcQkwEgBCAAKAK4BiAIKAIAIAIgBxCVBSAEKAIAIAQoAgQgAxCTASAEQZABaiQAC4QEAgR/AX4jAEEgayIEJABBAUIAIAEgAiADEK0CQQJCAyABIAIgAxCtAkEBQgAgASACIAMQrQJBAkIBIAEgAiADEK0CIAA1AkQhCCAEQRhqQQA7AQAgBEIANwMQQQEhBQJAA0AgBCAFakEPaiIGIAinIgdB/wBxOgAAIAhC/wBYBEAgBEEIaiAEQRhqLwEAOwEAIAQgBCkDEDcDAAwCCyAGIAdBgAFyOgAAIAhCB4ghCCAFQQFqIgVBC0cNAAsgBEEIaiAEQRhqLwEAOwEAIAQgBCkDEDcDAEEKIQULIARBGGogBEEIai8BADsBACAEIAQpAwA3AxBBCCAFrUIDfCABIAIgAxCtAiABIAEoAgBBB2oiBkF4cTYCAAJAAkAgBkEDdiIGIANJBEAgAiAGakEAOgAAAkAgAC0AWARAIAAtAFlFDQELIARB4a8COwAAIAAtAFoNAiAEQYABOgACDAMLIARBgQE6AAIgBEHhrwI7AAAMAgsgBiADQcDbwQAQvAQACyAEQYIBOgACC0EAIQADQEEIIAAgBGoxAAAgASACIAMQrQIgAEEBaiIAQQNHDQALQQhCASABIAIgAxCtAiAFQQtJBEBBACEAA0BBCCAEQRBqIABqMQAAIAEgAiADEK0CIAUgAEEBaiIARw0ACyAEQSBqJAAPCyAFQQpBoN3BABCHBwAL+AMBCH8gBARAA0ACQAJAAkACQAJAAkACQAJAAkACQAJAIAIgCmogA3EiBSABTQRAIAEgBUYNAUEBIQYgACAFaiIHLAAAIghBAU4NBiAEIAprIglBAkkNCiABIAVrIQUCQCAIQWBxQUBHDQAgBUECSQ0DIAhBHnFFDQBBAiEGIActAAFBQHFBgAFGDQcLIAlBA0kNCiAIQXBxQWBHDQUgBUECSQ0DIActAAEiDEHAAXFBgAFHDQUgBUEDSQ0EIActAAJBwAFxQYABRw0FQQMhBiAMQSBxQQZ0IAhBD3FBDHRyRQ0FDAYLIAUgAUHc0+IAEIYHAAtBAEEAQezS4gAQvAQAC0EBQQFB/NLiABC8BAALQQFBAUGM0+IAELwEAAtBAkECQZzT4gAQvAQACyAIQfgBcUHwAUcgCUEESXINBCAFQQJJDQEgBy0AASIJQcABcUGAAUcNBCAFQQNJDQIgBy0AAkHAAXFBgAFHDQQgBUEESQ0DIActAANBwAFxQYABRw0EQQQhBiAIQQdxQRJ0IAlBP3FBDHRyQYCAfGpB//8/Sw0ECyAGIAtqIQsMBAtBAUEBQazT4gAQvAQAC0ECQQJBvNPiABC8BAALQQNBA0HM0+IAELwEAAtBASEGCyAGIApqIgogBEkNAAsLIASzQwAAQD+UIAuzXQvfAwEGfyMAQUBqIgYkACAGQRhqQgA3AwAgBkEQakIANwMAIAZBCGpCADcDACAGQgA3AwAgBkE4akIANwMAIAZBMGpCADcDACAGQShqQgA3AwAgBkIANwMgAkACQAJAAkACQCACBEADQCABIAVGDQIgACAFai0AACIHQRBPDQYgBiAHQQF0aiIHIAcvAQBBAWo7AQAgAiAFQQFqIgVHDQALC0EAIQUgBkEAOwEAA0AgBSAGakEiaiAIIAUgBmovAQBqQQF0Igg7AQAgBUECaiIFQR5HDQALIAIEQEEAIQcDQCABIAdGDQMgACAHai0AACIJBEAgCUEPSw0FIAZBIGogCUEBdGoiBSAFLwEAIgVBAWo7AQAgBUEPcUECdEHQ/uIAaigCACEIIAlBBU8EQEEEIQoDQCAFQQJ2QTxxQdD+4gBqKAIAIAhBBHRyIQggBUEEdkH/H3EhBSAKQQRqIgogCUkNAAsLIAcgBE8NBiADIAdBAXRqIAhBACAJa0EDcXY7AQALIAdBAWoiByACRw0ACwsgBkFAayQADwsgASABQZD/4gAQvAQACyABIAFBsP/iABC8BAALIAlBEEHA/+IAELwEAAsgByAEQdD/4gAQvAQACyAHQRBBoP/iABC8BAAL7gMBBn8jAEEwayIFJAACQAJAAkACQAJAIAFBDGooAgAiAwRAIAEoAgghByADQX9qQf////8BcSIDQQFqIgZBB3EhBAJ/IANBB0kEQEEAIQMgBwwBCyAHQTxqIQIgBkH4////A3EhBkEAIQMDQCACKAIAIAJBeGooAgAgAkFwaigCACACQWhqKAIAIAJBYGooAgAgAkFYaigCACACQVBqKAIAIAJBSGooAgAgA2pqampqampqIQMgAkFAayECIAZBeGoiBg0ACyACQURqCyECIAQEQCACQQRqIQIDQCACKAIAIANqIQMgAkEIaiECIARBf2oiBA0ACwsgAUEUaigCAA0BIAMhBAwDC0EAIQMgAUEUaigCAA0BQQEhAgwECyADQQ9LDQAgBygCBEUNAgsgAyADaiIEIANJDQELIARFDQACQCAEQX9KBEAgBEEBEOkGIgJFDQEgBCEDDAMLEOUFAAsgBEEBEKEHAAtBASECQQAhAwsgAEEANgIIIAAgAjYCBCAAIAM2AgAgBSAANgIMIAVBIGogAUEQaikCADcDACAFQRhqIAFBCGopAgA3AwAgBSABKQIANwMQIAVBDGpB/NnrACAFQRBqEKsBBEBB3NrrAEEzIAVBKGpBkNvrAEG42+sAEJgEAAsgBUEwaiQAC+gDAQ1/IwBBMGsiBCQAIABCADcDACAAQQhqIQggA0H/AXEhDANAIAEgCUEDdCIFaiIDKAIAIAMoAgQhAyACIAVqIgUoAgQhByAEIAUoAgAiBTYCLCAEIAUgB2o2AiggAyAEQShqIgUoAgAgBSgCBGsiBSADIAVJGyEKQXhqIQ0gBCgCLCEOQQAhAwJAA0AgC0EBcyEPA0AgAyAKIAMgCksbIQYgDSADQQR0aiEFA0AgAyAGRg0DIAMgDmogBUEQaiEFIANBAWohAy0AACAMRw0ACyAEQSBqIAgQmAcgBCgCJCEGIAQoAiAhByAPRQRAIARBGGogBRCYByAEKAIYIQUgBiAEKAIcIhAgBiAQSRsiBkUNAQNAIAcgBygCACAFKAIAajYCACAHQQRqIQcgBUEEaiEFIAZBf2oiBg0ACwwBCwsgBEEQaiAFEJgHIAQoAhQiBSAGRgRAIAcgBCgCECAGQQJ0EKUHGkEBIQsMAQsLIAYgBUGshsEAEMAEAAsgCUEBaiIJQQJHDQALAkBBAUEAIAtBAXMbRQRAIARBCGogCBCYByAAIAQoAgggBCgCDBCXAjkDAAwBCyAAQgA3AwAgBCAIEJgHIAQoAgQiAEUNACAEKAIAQQAgAEECdBCjBxoLIARBMGokAAv5AwEHfyMAQYACayIFJAAgBUEAQYACEKMHIQgCQAJAAkACQAJAAkAgAgRAIAFFDQQgACgCACEGIAJBAk8EQCAAQQRqIQUgAkF/aiEHIAFBf2ogAkF+ak0hCQNAIAkNAyAFKAIAIgogBiAKIAZLGyEGIAVBBGohBSAHQX9qIgcNAAsLQQAhBQNAIAVBgAJPDQYgBSAIaiAFOgAAIAUgBkkEQCAFIAUgBklqIgUgBk0NAQsLIAJBASACQQFLGyEJIAZBAWohAiAIQQFqIQpBACEGA0ACQAJAIAEgBkcEQCAGQQJ0IQcgAgRAIAAgB2ooAgAhC0EAIQUCQANAIAVBgAJGDQkgBSAIai0AACALQf8BcUYNASACIAVBAWoiBUcNAAsgAiEFCyAGIARJDQIMCwsgBiAETw0KIAMgB2pBADYCACAILQAAIQcMAgsgASABQZDawQAQvAQACyADIAdqIAU2AgAgBUH/AUsNBSAFIAhqLQAAIQcgBUUNACAKIAggBRCmBxoLIAggBzoAACAGQQFqIgYgCUcNAAsLIAhBgAJqJAAPCyABIAFB8NnBABC8BAALQYACQYACQcDZwQAQvAQACyAFQYACQdDZwQAQvAQAC0EAQQBB4NnBABC8BAALIAVBgAJBgNrBABC8BAALIAYgBEGg2sEAELwEAAvuAwECfyMAQfAAayIFJAAgBUEgaiAEEIAFIAUgAzYCLCAFQQA2AjAgBSAENgI0IAVBADYCOAJAAn8CQAJAAkACQCAFQSxqIAVBMGogAiADIAVBNGogBUE4aiAFKAIkIAUoAiggAUGYE2ogARAVIgZBAWsOAwMAAQILIAVBIGogBSgCOBDYBiAFQeAAaiAFQShqKAIANgIAIAUgBSkDIDcDWCAFQRBqIAVB2ABqEJ8GIAUoAhAhBCAFKAIUDAMLIAVB4ABqIAVBKGooAgA2AgAgBSAFKQMgNwNYIAVBGGogBUHYAGoQnwYgBSgCGCEEIAUoAhwMAgsgBSABKALsEDYCPCAFQQo2AlQgBSAFQTxqNgJQIAVBATYCbCAFQQE2AmQgBUHwt8AANgJgIAVBADYCWCAFIAVB0ABqNgJoIAVBQGsgBUHYAGoQwgEgBSgCRCAFKAJIEAMhASAAQQA2AgwgACABNgIAIAVBQGsQzQYgBUEgahDNBgwCCyAFQSBqIAUoAjgQ2AYgBUHgAGogBUEoaigCADYCACAFIAUpAyA3A1ggBUEIaiAFQdgAahCfBiAFKAIIIQQgBSgCDAshASAAIAY2AgwgACAFKAIwNgIIIAAgBDYCACAAIAE2AgQLIAMEQCACEFILIAVB8ABqJAALgAQBA38jAEHQAGsiAyQAIANBQGsgACABQQlqENcFIAMgAygCRCIANgJMIAMgAygCQCIENgJIIANBOGogAhCYBwJAIAMoAjxFDQAgAigCGCEAIANBMGogA0HIAGoQmAcCQCAAQQlqIgAgAygCNCIETQRAIAMoAjAgA0EoaiACEJgHIAAgAygCLCIFSw0BIAAgAygCKCAAQezmwAAQwgYgA0EgahCqByACKAIEIQAgAygCICEEIAIgAygCJDYCBCACKAIAIAIgBDYCACAAENIGIAMoAkwhACADKAJIIQQMAgsgACAEQczmwAAQhwcACyAAIAVB3ObAABCHBwALIAIoAgQgAiAANgIEIAIoAgAhACACIAQ2AgAEQCAAEFILIAJBAjYCICACIAE2AhggA0EYaiACEJgHAkACQCACKAIgQX5qIgAgAygCHCIBSQRAIAMoAhggAGpBADoAACADQRBqIAIQmAcgAigCIEF/aiIAIAMoAhQiAU8NASADKAIQIABqQQA6AABBACEBA0AgA0EIaiACEJgHIAEgAigCICACKAIYaiIAaiIEIAMoAgwiBU8NAyADKAIIIABqIAFqQQA6AAAgAUEBaiIBQQdHDQALIANB0ABqJAAPCyAAIAFB/ObAABC8BAALIAAgAUGM58AAELwEAAsgBCAFQZznwAAQvAQAC+8DAgV/AX4jAEHwDmsiByQAIABBf2qtIAQgBSAGEJwEAkACQCAAQQFLBEAgB0EEakEAQbwIEKMHGiAHQcAIakEAQZACEKMHGiAHQdAKakEAQaAEEKMHGkEBQgEgBCAFIAYQrQJBBCABQX5qrSAEIAUgBhCtAiABQX9qIghBjwJLDQEgByAIQQJ0aiAANgIAIAdBATYCACAAIAhqIgogAUsEQCABQfB9aiEJIABBf2ohCyAHIAFBAnRqIQEDQCAJRQ0EIAFBATYCACAJQQFqIQkgAUEEaiEBIAtBf2oiCw0ACwsgB0GQAiAKIAogAiADIAdBwAhqQZACIAdB0ApqQZACIAQgBSAGEHEgAEEBIABBAUsbIQAgB0HQCmogCEEBdGohAkF/IAh0QX9zrSEMIAdBwAhqIAhqIQNBACEJA0BBACEBAkAgCUUNACAIIAlqIgFBkAJJDQAgCCAJakGQAkGw2cEAELwEAAsgB0HACGogAWotAAAgB0HQCmogAUEBdGozAQAgBCAFIAYQrQIgAy0AACACMwEAIAQgBSAGEK0CIAggDCAEIAUgBhCtAiAAIAlBAWoiCUcNAAtBAUIBIAQgBSAGEK0CCyAHQfAOaiQADwsgCEGQAkGQ2cEAELwEAAtBkAJBkAJBoNnBABC8BAAL7AMCCH8BfiMAQSBrIgQkACAEIAEoArQQIgY2AgwgBCABKAK4ECIJNgIQIAQgASgCvBAiBTYCFCAEIAEoAqAQIgc2AhggBCABKAKcECIINgIcIAFB8A1qIQoCfwJAAkAgAUH4DWooAgBBwABGBEAgCiACIAMQ3gRFDQELIAVFIAYgAE9yDQEgASABQYAOaigCAEEETwR/IAFBgAFqIQkgAUGgDWohByABQYACaiEIA0AgCiACIAMQ7QMgASABKAL4DSIFIAEgASkD8A0iDCAFQT9xrYinQR9xQQJ0aiIFLQACaiIGNgL4DQJAIAUvAQAiBUEQTwRAIAEgBkECQQMgBUEQRhsiC2o2AvgNIAUgC0ECdEHsneMAaigCACAMIAZBP3GtiKdxIAAgBEEMaiAEQRBqIARBFGogBEEYaiAEQRxqIAggASgCwBAgByAJEIgCDAELIAUgBEEMaiAEQRBqIARBFGogBEEYaiAIIAEoAsAQIAcgCRDUAwsgBCgCFCIFRSAEKAIMIgYgAE9yDQMgASgCgA5BBE8NAAsgBCgCHCEIIAQoAhghByAEKAIQBSAJCzYCuBAgASAGNgK0ECABIAc2AqAQIAEgBTYCvBAgASAINgKcEAtBAgwBCyABIAU2ArwQQQELIARBIGokAAvQAwEDfyMAQYAIayIJJAAgCUEAQYAIEKMHIQkCQAJAAkACQAJAIAJBgIACTwRAA0AgCCABTw0EIAkgACAIai0AAEECdGoiCiAKKAIAQQFqNgIAIAhBHWoiCCACSQ0ACyACQRxqQR1uIQJBACEIA0AgCCAJaiIAIAAoAgAiAEELIABBC0kbQQF0QQFyIgEgAGo2AgAgASACaiECIAhBBGoiCEGACEcNAAsMAQsgAgRAA0AgASAIRg0DIAkgACAIai0AAEECdGoiCiAKKAIAQQFqNgIAIAIgCEEBaiIIRw0ACwtBACEIA0AgCCAJaiIAIAAoAgAiAEELIABBC0kbQQF0IgEgAGo2AgAgASACaiECIAhBBGoiCEGACEcNAAsLIAlBgAIgAkEIIANBgAIgBEGAAiAFIAYgBxAiQQAhACAJIQFBACEIA0AgASgCACIEBEAgCEGAAk8NBSAEIAMgCGotAABsIABqIQALIAFBBGohASAIQQFqIghBgAJHDQALIAJFDQIgCUGACGokACAAQf0AbCACbg8LIAEgAUGAscAAELwEAAsgCCABQZCxwAAQvAQAC0HwqcAAQRlB4KnAABC4BQALIAhBgAJBoLHAABC8BAALxgMBCX8jAEEQayIKJAAgAEF/aiIABEADQCAHQQFqIQcgAEEBSyAAQQF2IQANAAsLIAIoArQQIghBAWoiCSACKAL8DyIGTwRAIAlB0AVNBEAgAkGAAmohCwJAAkACQAJAIAYgCUcEQCAIQQF0IAZBAXQiAGtBAmohBSACQfANaiEMIAAgC2ohAANAIApBADYCDCAMIAcgCkEMaiADIAQQzgRFDQIgCigCDCINIAFPBEBBfCEADAULIAAgDTsBACAGQQFqIQYgAEECaiEAIAVBfmoiBQ0ACwsgCEHRBU8NA0EBIQAgCEUNAiALIAhBAXRqIQMgCEEBdCEEQQAhAiALIQUMAQtBAiEAIAJBAjoAjBEgAiAGNgL8DwwBCwNAAkAgAiAJRwRAIAVBAmohASALIAJBAWoiAkEBdGohByAEIQADQCAARQ0CIABBfmohACAHLwEAIAdBAmohByAFLwEARw0AC0F7IQAMAwsgCEECaiAJQYCi4wAQiAcACyAEQX5qIQRBASEAIAEiBSADRw0ACwsgCkEQaiQAIAAPCyAIQdAFQfCh4wAQhwcACyAJQdAFQeCh4wAQhwcACyAGIAlB4KHjABCIBwAL7AMBDH8jAEFAaiICJAACQAJAAkACQAJAIAEtAABBAWsOBgADBAIEBAELIAAgACgCyAYgAUEKai0AAGo2AsgGDAMLIAAgACgCyAYgAUEIaigCAGo2AsgGDAILIAAgAS8AATsBzAYMAQsgAkIANwMwIABBiAZqIQVBByEEA0AgACgCyAYiBiADSwRAIAJBMGogBGogBSAEIAZqQXhqQbyZwAAQ1AUtAAA6AAALIANBAWohAyAEQX9qIgRBf0cNAAsgAkEoaiABQQRqIgYQmAcgAigCLCIBBEAgAigCKCEEIABBrAZqIQcgAEGgBmohCEEAIQMDQCACQTBqIANBBmpBB3FyLQAAIQkgAkEwaiADQQdqIgpBB3FyLQAAIQsgAkEgaiAIEJgHIAIoAiQhDCACKAIgIQ0gAkEYaiAHEJgHQQAhBSACQRBqIAsgCSANIAwgAigCHAR/IAIoAhgtAAAFIAULIAAtAMwGEJYEIAIoAhAhBSACIAIpAzA3AzggACACQThqIAogAC0AzQZrQQdxci0AACAFIAQtAAAQvgEgAkEwaiADaiAELQAAOgAAIANBAWpBB3EhAyAEQQFqIQQgAUF/aiIBDQALCyACQQhqIAYQmAcgACAAKALIBiACKAIMajYCyAYLIAJBQGskAAvhAgACQAJ/AkACQAJAAkACQAJAAkACQAJAAkAgACgCAA4KCwECAwQFBgcICQALIABBCGooAgAEQCAAKAIEEFILIABBEGooAgBFDQogAEEMagwJCyAAQQhqKAIARQ0JIABBBGoMCAsgAEEIaigCAEUNCCAAQQRqDAcLIABBCGooAgBFDQcgAEEEagwGCyAAQQhqKAIARQ0GIABBBGoMBQsgAEEYaigCAARAIABBFGooAgAQUgsgAEEgaigCAEUNBSAAQRxqDAQLIABBCGooAgAEQCAAKAIEEFILIABBEGooAgBFDQQgAEEMagwDCyAAQQhqKAIABEAgACgCBBBSCyAAQRBqKAIARQ0DIABBDGoMAgsgAEEkaigCAARAIABBIGooAgAQUgsgAEEsaigCAEUNAiAAQShqDAELIABBCGooAgAEQCAAKAIEEFILIABBEGooAgBFDQEgAEEMagsoAgAQUgsL5wMBDH8jAEFAaiICJAACQAJAAkACQAJAIAEtAABBAWsOBgADBAIEBAELIAAgACgCmAEgAUEKai0AAGo2ApgBDAMLIAAgACgCmAEgAUEIaigCAGo2ApgBDAILIAAgAS8AATsBnAEMAQsgAkIANwMwIABBOGohBUEHIQQDQCAAKAKYASIGIANLBEAgAkEwaiAEaiAFIAQgBmpBeGpB3J/AABDUBS0AADoAAAsgA0EBaiEDIARBf2oiBEF/Rw0ACyACQShqIAFBBGoiBhCYByACKAIsIgEEQCACKAIoIQQgAEHcAGohCSAAQdAAaiEKQQAhAwNAIAJBMGogA0EGakEHcXItAAAhByADQX9qQQdxIgsgAkEwanItAAAhCCACQSBqIAoQmAcgAigCJCEMIAIoAiAhDSACQRhqIAkQmAdBACEFIAJBEGogCCAHIA0gDCACKAIcBH8gAigCGC0AAAUgBQsgAC0AnAEQlgQgBC0AACEFIAItABQhByACKAIQIQggAiACKQMwNwM4IAAgAkE4aiALIAggBRAKIAJBMGogA2ogBC0AADoAACADQQFqQQdxIQMgBEEBaiEEIAFBf2oiAQ0ACwsgAkEIaiAGEJgHIAAgACgCmAEgAigCDGo2ApgBCyACQUBrJAAL3QMBCn8jAEFAaiICJAACQAJAAkACQAJAIAEtAABBAWsOBgADBAIEBAELIAAgACgCaCABQQpqLQAAajYCaAwDCyAAIAAoAmggAUEIaigCAGo2AmgMAgsgACABLQABIAFBAmotAAAQ0wIMAQsgAkIANwMwIABByABqIQVBByEEA0AgACgCaCIGIANLBEAgAkEwaiAEaiAFIAQgBmpBeGpB/ILBABDUBS0AADoAAAsgA0EBaiEDIARBf2oiBEF/Rw0ACyACQShqIAFBBGoiBhCYByACKAIsIgEEQCACKAIoIQRBACEDA0AgAkEwaiADQQZqQQdxci0AACEHIANBf2pBB3EiCCACQTBqci0AACEJIAJBIGogACgCdBCYByACKAIkIQogAigCICELIAJBGGogACgCdEEMahCYB0EAIQUg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AogWIgAgAUECdGoqAgAgACoCAJMiDV8EQCAIQQhqQgA3AwAgCEIANwMAIAggATYCECAIIAw4AhggCCAMIA2TOAIUIAEgAyAGIAcgCBCDAiAFIAgQlAILIAhBIGokAA8LIAEgB0HkjMEAELwEAAsgACAHQcyPwQAQvAQACyABIABBwJDBABC8BAALsgMCAX8DfiMAQSBrIgEkACAAQcAnahCGBSABQRhqEKoHIAEpAxghAiABQRBqEKwHIAEpAxAhAyABQQhqEKoHIAEpAwghBCABEKoHIAAgASkDADcCjCogAEIANwPAKCAAQQA2AogpIABBlCpqQgA3AgAgAEEANgLoKSAAQZwqakIANwIAIABBpCpqQgA3AgAgAEGsKmpBADYCACAAQQA2AvQpIABCADcC7CkgAEIENwPgKCAAQgA3A8goIABB0ChqQgA3AwAgAEGIJ2pCj4CAgIACNwMAIABChICAgLABNwOAJyAAQZAnakEAQTAQowcaIABBADYCtCogAEEANgL4KSAAQagoakKPgICAgAI3AwAgAEKEgICAsAE3A6AoIABBuCpqQQA6AAAgACACNwPoKCAAQQBBgCAQowciAEEANgL8KSAAQgQ3A/AoIABBgCBqQQBBgAcQowcaIABBAjYC4CkgACAENwOAKSAAIAM3A/goIABCADcD2CggAEIANwOwKCAAQbgoakIANwMAIABBADYCsCogAEIANwOAKiAAQQA2ALkqIABBADYCiCogAUEgaiQAC/ECAQR/QRAhBwJAAkACQAJAAkACQAJAAkAgACADSQRAIAIgAEEUbGoiACgCAEECRw0FIAAoAgQiAEUNBSAEIQgDQCAGIQUgACADTw0CIAVBBEYNAyAIIAIgAEEUbGoiBigCDDYCACAAIAYoAghB////D3EgBigCEEH///8/cWprIgAgA08NBCACIABBFGxqIgAoAgBBAkcgBUECS3INBSAFQQFqIQYgCEEEaiEIIAAoAgQiAA0ACwwECyAAIANB5JbjABC8BAALIAAgA0H0luMAELwEAAtBBEEEQYSX4wAQvAQACyAAIANBlJfjABC8BAALIAVBAksNASAFQQFqIQULIAVBBCAFQQRLGyECIAQgBUECdGohAANAIAdFDQMgAiAFRg0CIAAgASgCADYCACAAQQRqIQAgAUEEaiEBIAdBf2ohByAFQQFqIgVBBEcNAAsLDwsgAkEEQbSX4wAQvAQAC0GIleMAQSNBpJfjABC4BQALiAMCBX8CfiMAQUBqIgUkAEEBIQcCQCAALQAEDQAgAC0ABSEIIAAoAgAiBigCGCIJQQRxRQRAIAYoAgBB/fbrAEH/9usAIAgbQQJBAyAIGyAGKAIEKAIMEQMADQEgBigCACABIAIgBigCBCgCDBEDAA0BIAYoAgBByPbrAEECIAYoAgQoAgwRAwANASADIAYgBCgCDBEBACEHDAELIAhFBEAgBigCAEH49usAQQMgBigCBCgCDBEDAA0BIAYoAhghCQsgBUEBOgAXIAVB3PbrADYCHCAFIAYpAgA3AwggBSAFQRdqNgIQIAYpAgghCiAGKQIQIQsgBSAGLQAgOgA4IAUgBigCHDYCNCAFIAk2AjAgBSALNwMoIAUgCjcDICAFIAVBCGo2AhggBUEIaiABIAIQ2gENACAFQQhqQcj26wBBAhDaAQ0AIAMgBUEYaiAEKAIMEQEADQAgBSgCGEH79usAQQIgBSgCHCgCDBEDACEHCyAAQQE6AAUgACAHOgAEIAVBQGskACAAC4oDAQN/IwBBQGoiAiQAQQEhAwJAIAEoAgAiBEH09OsAQQwgASgCBCIBKAIMEQMADQACQCAAKAIIIgMEQCACIAM2AgwgAkHhADYCFCACIAJBDGo2AhBBASEDIAJBATYCPCACQQI2AjQgAkGE9esANgIwIAJBADYCKCACIAJBEGo2AjggBCABIAJBKGoQqwFFDQEMAgsgACgCACIDIAAoAgRBDGooAgARFwBCyLXgz8qG29OJf1INACACIAM2AgwgAkHiADYCFCACIAJBDGo2AhBBASEDIAJBATYCPCACQQI2AjQgAkGE9esANgIwIAJBADYCKCACIAJBEGo2AjggBCABIAJBKGoQqwENAQsgACgCDCEAIAJBJGpBJzYCACACQRxqQSc2AgAgAiAAQQxqNgIgIAIgAEEIajYCGCACQeMANgIUIAIgADYCECACQQM2AjwgAkEDNgI0IAJB3PTrADYCMCACQQA2AiggAiACQRBqNgI4IAQgASACQShqEKsBIQMLIAJBQGskACADC/ICAQV/IwBBMGsiBSQAIAUgAToADwJAAn8CQAJAAkACQCACLQCKEUFrag4CAgEAC0H8peMAQShBpKbjABC4BQALIAENASAFQQA2AhggBUEPakG0puMAIAVBEGpBuKbjABDyBAALIAENAiACQfgOaiEGIAJB5BBqIQcgAkH8DmoMAQsgAkHgDmohBiACQZgQaiEHIAJB5A5qCyEIIAYoAgAhCSAGQQE2AgAgCCgCACEGIAhBADYCACAFIAcoAgA2AiwgBSAGNgIUIAUgCTYCECAAIAVBLGogBUEQaiACIAMgBBBjIAUoAiwhAAJAIAFFBEAgAiAANgLkECACQfwOaigCACACKAL4DiEBIAIgBSkDEDcD+A5FDQEgARBSDAELIAIgADYCmBAgAkHkDmooAgAgAigC4A4hASACIAUpAxA3A+AORQ0AIAEQUgsgBUEwaiQADwsgBUEANgIYIAVBD2pByKbjACAFQRBqQcym4wAQ8gQAC9UCAQJ/IwBBEGsiAiQAIAAoAgAhAAJAAn8CQCABQYABTwRAIAJBADYCDCABQYAQTw0BIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECDAILIAAoAggiAyAAKAIARgRAIAAgAxCkAyAAKAIIIQMLIAAgA0EBajYCCCAAKAIEIANqIAE6AAAMAgsgAUGAgARPBEAgAiABQT9xQYABcjoADyACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA0gAiABQRJ2QQdxQfABcjoADEEEDAELIAIgAUE/cUGAAXI6AA4gAiABQQx2QeABcjoADCACIAFBBnZBP3FBgAFyOgANQQMLIQEgACgCACAAKAIIIgNrIAFJBEAgACADIAEQnwMgACgCCCEDCyAAKAIEIANqIAJBDGogARClBxogACABIANqNgIICyACQRBqJABBAAvJAgECfwJ/IAYoAgBBACAAQRBGIg0bIgYgBygCAEYEQEEAIAQoAgAiAEUNARogAEF+akECQQMgDRt0IQwgAAwBCyAHIAY2AgBBAAshACAEIAEgDGpBA2oiATYCAAJAIAMoAgAiBCABIABrIgBqIgEgAk0EQCAGDQEgAyABNgIADwsgBUH//z82AgAgAyACNgIADwsCQAJAIAZBIEkEQCALIAZBAnRqIgcoAgAhAiAAIQwDQCACIAlqIgFB0AVPDQIgAyAEIgJBAWoiBDYCACAIIAFBAXRqIAI7AQAgDEF/aiIMDQALIAcgBEF/ajYCACAFIAUoAgAgAEEPIAZrdGs2AgAgBkEQTw0CIAogBkEBdGoiASABLwEAIABqOwEADwsgBkEgQcCi4wAQvAQACyABQdAFQdCi4wAQvAQACyAGQRBB4KLjABC8BAAL1AIBAn8jAEHAwABrIgMkABDhBSADQQA2AhggA0KAgICAEDcDECADIAI2AiwgAyABNgIoIANBQGtBAEGAIBCjBxogA0HAIGpBAEGAIBCjBxogA0EgaiADQShqIANBEGogA0FAayADQcAgahDYBAJAAkAgAy0AIEEERgRAIANByCBqIANBGGooAgA2AgAgAyADKQMQNwPAICADQQhqIANBwCBqEJ8GIAAgAykDCDcCACACDQEMAgsgAyADKQMgNwMwIANBAzYCPCADIANBMGo2AjggA0EBNgLUICADQQE2AswgIANBjKnAADYCyCAgA0EANgLAICADIANBOGo2AtAgIANBQGsgA0HAIGoQwgEgAygCRCADKAJIEAIhBCAAQQA2AgAgACAENgIEIANBQGsQzQYgA0EwahDSBSADQRBqEM0GIAJFDQELIAEQUgsgA0HAwABqJAAL0wICBX8BfiMAQSBrIgEkACAAKAKEKiEFIAFBEGogAEHoKGoQmAcgAUEIaiAAQeApaiABKAIQIAEoAhQgAEGwKGoQuQQgASgCDCECIAEoAgghAyABIAAtALYqNgIcIAIEQCADIAAtALQqOgAAAkACQAJAAkAgAkEBRwRAIAMgAEG1KmotAAA6AAEgAEEAOgC2KiAAQQA7AbQqQQFCACABQRxqIAMgAhD0AkECQgMgAUEcaiADIAIQ9AJBAUIAIAFBHGogAyACEPQCIAUOAgEDAgtBAUEBQajuwAAQvAQAC0ECQgAgAUEcaiADIAIQ9AIMAgsgBUF/aiIAZ0EgakE/c0EIakEDdiEEIACtIQYLQQIgBK0gAUEcaiADIAIQ9AIgBEEDdCAGIAFBHGogAyACEPQCCyABKAIcIAFBIGokAEEHakEDdg8LQQBBAEGY7sAAELwEAAvMAgECfyMAQRBrIgIkAAJAAn8CQCABQYABTwRAIAJBADYCDCABQYAQTw0BIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECDAILIAAoAggiAyAAKAIARgRAIAAgAxClAyAAKAIIIQMLIAAgA0EBajYCCCAAKAIEIANqIAE6AAAMAgsgAUGAgARPBEAgAiABQT9xQYABcjoADyACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA0gAiABQRJ2QQdxQfABcjoADEEEDAELIAIgAUE/cUGAAXI6AA4gAiABQQx2QeABcjoADCACIAFBBnZBP3FBgAFyOgANQQMLIQEgACgCACAAKAIIIgNrIAFJBEAgACADIAEQoAMgACgCCCEDCyAAKAIEIANqIAJBDGogARClBxogACABIANqNgIICyACQRBqJAAL5QICBn8BfiMAQSBrIgckAAJAAkACQAJAAkAgACgCsCpBAUYEQCAALQC2Kg0BCyAAKAKAKiIIRQ0BIAEoAgAiCUUNASAEKAIAIgogCCAJIAggCUkbIgZqIgggCkkNAiAIIANLDQMgB0EYaiAAQegoahCYByAHQRBqIABB4ClqIgMgBygCGCAHKAIcIABBsChqELkEIAYgBygCFCILSw0EIAIgCmogBiAHKAIQIAZBqO/AABDCBiABIAkgBms2AgAgBCAINgIAIAdBCGogAyAGEJEGIAcoAgghASAAQeQpaiAHKAIMNgIAIAAgATYC4CkgACAAKAKAKiAGazYCgCogACAAKQPYKCAGrXwiDDcD2ChBASEGIAUoAgBBAUcNASAFIAw+AgQMAQsgABCRAkEBIQYLIAdBIGokACAGDwsgCiAIQYjvwAAQiAcACyAIIANBiO/AABCHBwALIAYgC0GY78AAEIcHAAuxAgEHfwJAIAJBD00EQCAAIQMMAQsgAEEAIABrQQNxIgZqIQQgBgRAIAAhAyABIQUDQCADIAUtAAA6AAAgBUEBaiEFIANBAWoiAyAESQ0ACwsgBCACIAZrIghBfHEiB2ohAwJAIAEgBmoiBkEDcSICBEAgB0EBSA0BIAZBfHEiBUEEaiEBQQAgAkEDdCIJa0EYcSECIAUoAgAhBQNAIAQgBSAJdiABKAIAIgUgAnRyNgIAIAFBBGohASAEQQRqIgQgA0kNAAsMAQsgB0EBSA0AIAYhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIANJDQALCyAIQQNxIQIgBiAHaiEBCyACBEAgAiADaiECA0AgAyABLQAAOgAAIAFBAWohASADQQFqIgMgAkkNAAsLIAAL3QIBA38jAEEQayILJAACQAJAAkACQAJAIAAgACgCjAciCQR/IAkFIAAgACgCiAdBAWoiCTYCiAcgCSAAQQxqKAIAIgpPDQEgCSAAKAIEIgpPDQIgACgCACAJai0AACEKIAAgACgCCCAJQQJ0aigCACIJNgKMByAAIAogCHQ2ApAHIABBLGogCSAKQQAgBSAGIAcQpwIgACgCjAcLQX9qNgKMByAAKAKQByACaiICIARPDQIgAyACQQJ0aigCACAAKAIgIAtBCGogAEEQahCYB2wgAWoiASALKAIMIgJPDQMgASAAQRxqKAIAIgJJDQQgASACQdDKwAAQvAQACyAJIApBkMrAABC8BAALIAkgCkGgysAAELwEAAsgAiAEQbDKwAAQvAQACyABIAJBwMrAABC8BAALIAsoAgggAWotAAAgACgCGCABQQF0ajMBACAFIAYgBxCtAiALQRBqJAALwQICBX8BfiMAQTBrIgUkAEEnIQMCQCAAQpDOAFQEQCAAIQgMAQsDQCAFQQlqIANqIgRBfGogACAAQpDOAIAiCEKQzgB+faciBkH//wNxQeQAbiIHQQF0Qbr36wBqLwAAOwAAIARBfmogBiAHQeQAbGtB//8DcUEBdEG69+sAai8AADsAACADQXxqIQMgAEL/wdcvViAIIQANAAsLIAinIgRB4wBLBEAgA0F+aiIDIAVBCWpqIAinIgQgBEH//wNxQeQAbiIEQeQAbGtB//8DcUEBdEG69+sAai8AADsAAAsCQCAEQQpPBEAgA0F+aiIDIAVBCWpqIARBAXRBuvfrAGovAAA7AAAMAQsgA0F/aiIDIAVBCWpqIARBMGo6AAALIAIgAUHI2+sAQQAgBUEJaiADakEnIANrEIoBIAVBMGokAAu3AgIGfwF+AkAgA0UNACACKAIIIghBv39qQXdLDQAgA0F/aiEJIAIpAwAhDAJAA0AgASAHRwRAIAIgCEEIaiIKNgIIIAAgB2ogDCAIQT9xrYg8AAAgB0EBaiEGIAhBR2pBd0sNAiAHIAlHIAYhByAKIQgNAQwCCwsgASABQfS66wAQvAQACyADIAZrIQMLIAIoAgwhCgJAAkAgAwRAIAogBSAKIAVJGyEHIAYgASAGIAFJGyEIIAMhCyAKIQkDQCAFIAdGDQMgASAIRg0CIAAgBmogBCAJai0AADoAACAJQQFqIQkgB0EBaiEHIAhBAWohCCAGQQFqIQYgC0F/aiILDQALCyACIAMgCmo2AgwgAiACKAIQIANrNgIQDwsgBiABQZS76wAQvAQACyAJIAVBhLvrABC8BAAL3gIBB38jAEEQayICJAAgAC0AtiohAyAAQQA6ALYqIAAvAbQqIABBADsBtCpBBiADdCIHciEEAkACQAJAAkACQCAAQeApaiIBKAIAQQFNBEAgAkEIaiAAQegoahCYByACIAEgAigCCCACKAIMIABBsChqELkEIAIoAgQiBSAAKAKAKiIBSQ0CIAEgBUcEQCACKAIAIAFqIgYgBDoAACADQQJNDQYgBSABayIBQQFLDQJBAUEBQejuwAAQvAQAC0EAQQBB2O7AABC8BAALIAAgBDoAsCggAEIBNwPgKSADQQJLDQIMBAsgBiAEQQh2OgABIANBCk0NAyABQQNPDQJBAkECQfjuwAAQvAQACyABIAVByO7AABCGBwALIABBsShqIARBCHY6AAAgA0EKTQ0BIABBsChqIQYLIAYgB0EQdjoAAgsgACAAKAKAKiADQQ1qQQN2ajYCgCogAkEQaiQAC7ACAQR/AkACQAJAAkACQAJAIAFBA2pBfHEiAyABRg0AIAMgAWsiAyACIAMgAkkbIgRFDQBBACEDQQEhBQNAIAEgA2otAABBCkYNBiAEIANBAWoiA0cNAAsgBCACQXhqIgNLDQIMAQsgAkF4aiEDQQAhBAsDQAJAIAEgBGoiBSgCAEGKlKjQAHMiBkF/cyAGQf/9+3dqcUGAgYKEeHENACAFQQRqKAIAQYqUqNAAcyIFQX9zIAVB//37d2pxQYCBgoR4cQ0AIARBCGoiBCADTQ0BCwsgBCACSw0BC0EAIQUgAiAERg0BA0AgASAEai0AAEEKRgRAIAQhA0EBIQUMBAsgBEEBaiIEIAJHDQALDAELIAQgAkHk+usAEIYHAAsgAiEDCyAAIAM2AgQgACAFNgIAC68CAQR/IwBBQGoiCSQAIAlBBGpBAEE8EKMHGiAJQX82AgACfwJAIAAgAkkEQANAAkAgASAAQQN0aiIILwEEIgBBEHRBEHUiB0F/SgRAIAYgBU4NBCAGQQFqIQcgBkEOTQRAIAkgB0ECdGogCC4BBjYCAAwCCyAHQRBB+PbiABC8BAALAkAgCC4BBiIAIARJBEAgACADaiAGOgAAIAZBAEgNBSAJIAZBAnRqIQggBiEHAkADQCAGQQ9LDQMgCCgCACIAQX9HDQEgCEF8aiEIIAdBAEogB0F/aiEHDQALQQEMBwsgCEF/NgIADAILIAAgBEGI9+IAELwEAAsgBkEQQZj34gAQvAQACyAHIQYgACACSQ0ACwsgACACQej24gAQvAQACyAHQQBICyAJQUBrJAALuwICCX8EfiAAIAAoAuABIgJBAWoiAzYC4AEgACACQX9zQQdxIgRBHGxqIgIgASkCADcCACACQQhqIAFBCGopAgA3AgAgAkEQaiABQRBqKQIANwIAIAJBGGogAUEYaigCADYCACADQQggA0EISRsiAUECTwRAIAFBf2ohAwNAIAAgBEEHcUEcbGoiASoCFCAAIARBAWoiBEEHcUEcbGoiAioCFF4EQCABKQIAIQwgAkEIaiIGKQIAIQ0gAkEQaiIHKQIAIQsgAkEYaiIIKAIAIQUgASACKQIANwIAIAFBGGoiCSgCACEKIAkgBTYCACABQRBqIgUpAgAhDiAFIAs3AgAgAUEIaiIBKQIAIQsgASANNwIAIAggCjYCACAHIA43AgAgBiALNwIAIAIgDDcCAAsgA0F/aiIDDQALCwvAAgMDfwF+AXwjAEGQEWsiBiQAIAZBADsBAiAGQQhqQQBBhBEQowcaIAZBo+D/+wc2AowRAn8CQCABIAJPBEAgAkUNASAEKAIAIgEgAygCAEYgBCgCBCIHIAMoAgRGcSEIIAJBBHQhAiABrSEJIAQoAgwhAQNAAkAgAEEEaigCAEH///8PcUUNACAAQQxqLwEAQf8ATQ0AAkACQCAIRQRAIAAgAxDUBCIEIAFLDQIgBCAHIAkgBkECaiAGQQRqENMDIAYvAQIhBAwBCyAGIABBDmovAQAiBDsBAgsgBkEIaiAEQf8HcRDvBSAKIARBgPgDcUEKdrigIQoMAQtBAAwECyAAQRBqIQAgAkFwaiICDQALDAELQYiV4wBBI0HAm+MAELgFAAsgBSAKIAZBCGoQVbugOQMAQQELIAZBkBFqJAALxAIBA38jAEGAAWsiBCQAAkACQAJAAkAgASgCGCICQRBxRQRAIAJBIHENASAANQIAQQEgARCPAiEADAQLIAAoAgAhAEEAIQIDQCACIARqQf8AakEwQdcAIABBD3EiA0EKSRsgA2o6AAAgAkF/aiECIABBD0sgAEEEdiEADQALIAJBgAFqIgBBgQFPDQEgAUEBQbj36wBBAiACIARqQYABakEAIAJrEIoBIQAMAwsgACgCACEAQQAhAgNAIAIgBGpB/wBqQTBBNyAAQQ9xIgNBCkkbIANqOgAAIAJBf2ohAiAAQQ9LIABBBHYhAA0ACyACQYABaiIAQYEBTw0BIAFBAUG49+sAQQIgAiAEakGAAWpBACACaxCKASEADAILIABBgAFBqPfrABCGBwALIABBgAFBqPfrABCGBwALIARBgAFqJAAgAAu6AgQDfwF+AX0EfCMAQSBrIgIkACACIAE2AgQgAUGAgARGBEADQCAAIARBAnRqIQEDQCAEQQFqIgRBgYAERgRAAn1CfwJ+IAdEAAAAAAAAAABmIgAgB0QAAAAAAADwQ2NxBEAgB7EMAQtCAAtCACAAGyAHRP///////+9DZBsiBUKAAloEQCAFtRDEAgwBCyAFp0ECdEGQx+IAaioCAAshBiACQSBqJAAgCCAJRAAAAAAAADBAoqAgByAGu6KgDwsgASgCACEDIAFBBGohASADRQ0ACyAJRAAAAAAAAPA/oCEJIAcgA7giCqAhByAIIAoCfSADQYACTwRAIAOzEMQCDAELIANBAnRBkMfiAGoqAgALu6KhIQgMAAsACyACQQA2AhAgAkEEakHAv9IAIAJBCGpBpMDSABDxBAALuQICBH8DfiMAQTBrIgIkACACQRhqQgEgAUEoaiIDNQIAhiIHIAFBJGoiBDUCACIGhqcQ1gUgAikDGCEIIAJBEGpCASAGhqciBRDfAyACKQMQIQYgAiAFNgIoIAIgBjcDICACQQhqIAJBIGoQigUgAikDCCEGIABB1ABqIAFBIGoQ8wY2AgAgAEHQAGpBADYCACAAQcgAakIBNwMAIABBKGogCDcDACAAQSBqIAY3AwAgAEEYaiAHp0F/ajYCACAAQUBrIAFBMGopAgA3AgAgAEE4aiADKQIANwIAIABBMGogASkCIDcCACAAQRxqIAMoAgA2AgAgAEEUakEBIAQoAgAiA3Q2AgAgAEEQakHAACADazYCACAAQn8gAUEsaigCAEE4bEE4ca2INwMIIABBCDYCACACQTBqJAALoQIBBX8jAEEgayIBJAAgAUEYahCqByAAKALoKCAAIAEoAhg2AugoIABB7ChqIgMoAgAgAyABKAIcNgIAENIGIABB5ChqKAIAIAAoAuAoIQMgAEIENwPgKARAIAMQUgsgAUEQahCqByAAKAKMKiABKAIUIQMgACABKAIQNgKMKiAAQZAqaiIEKAIAIAQgAzYCABDSBiAAQYgpahA5IABB9ChqKAIAIAAoAvAoIQMgAEIENwPwKARAIAMQUgsgAUEIahCsByAAKAL4KCAAIAEoAgg2AvgoIABB/ChqIgMoAgAgAyABKAIMNgIAENIGIAEQqgcgACgCgCkgACABKAIANgKAKSAAQYQpaiIAKAIAIAAgASgCBDYCABDSBiABQSBqJAALtQIBB38jAEEQayIIJAAgCEEHNgIMAkACQAJAIAMEQCACIANuIQogAyAFSw0BIAQgA0GIEWxqIQcgBCEGA0AgBkEAQYQREKMHIgZBhBFqQaPg//sHNgIAIAZBiBFqIgYgB0cNAAsgAkFXaiELQQAhBwJAA0AgCSADbiEGIAcEQCAIQQxqEMwGIAMgAksNBSAKcCAGaiEGCyAFIAdGDQEgBiALIAZBKGogAkkbIgYgAUsNBSAEIAAgBkEBdGogASAGa0EoELUEIAIgCWohCSAEQYgRaiEEIAMgB0EBaiIHRw0ACyAIQRBqJAAPCyAFIAVBzN3AABC8BAALQdDRwABBGUG40cAAELgFAAsgAyAFQYCdwAAQhwcAC0Hw0cAAQTlBuNHAABC4BQALIAYgAUHc3cAAEIYHAAu1AgEHfyMAQRBrIggkACAIQQc2AgwCQAJAAkAgAwRAIAIgA24hCiADIAVLDQEgBCADQYgWbGohByAEIQYDQCAGQQBBhBYQowciBkGEFmpBo+D/+wc2AgAgBkGIFmoiBiAHRw0ACyACQVdqIQtBACEHAkADQCAJIANuIQYgBwRAIAhBDGoQzAYgAyACSw0FIApwIAZqIQYLIAUgB0YNASAGIAsgBkEoaiACSRsiBiABSw0FIAQgACAGQQF0aiABIAZrQSgQtgQgAiAJaiEJIARBiBZqIQQgAyAHQQFqIgdHDQALIAhBEGokAA8LIAUgBUHM3cAAELwEAAtB0NHAAEEZQbjRwAAQuAUACyADIAVBgJ3AABCHBwALQfDRwABBOUG40cAAELgFAAsgBiABQdzdwAAQhgcAC7QCAQJ/IwBBIGsiASQAIAFBEGogABDTBQJ/AkACQCABLQAQDQACQAJAAkACQCABLQASQQAgAS0AERsiAkH/AXFBMEYEQCABQQhqIAAQlgYgAS0ACA0BIAEtAAlBUGpB/wFxQQpJDQIMBAsgAkFPakH/AXFBCEsNAiABQRBqIAAQlgYgAS0AEA0EA0AgAS0AEUFQakH/AXFBCk8NBCAAEOsGIAFBEGogABCWBiABLQAQRQ0ACwwECyABKAIMDAULIAFBDDYCECAAIAFBEGoQzAQMBAsgAUEMNgIQIAAgAUEQahCTBQwDCyABQRBqIAAQlgYgAS0AEA0AIAEtABEiAkEuRg0BIAJBxQBHBEBBACACQeUARw0DGgsgABDOAwwCCyABKAIUDAELIAAQ0gMLIAFBIGokAAucAgIDfwN9IwBBgAhrIgUkACAFQQBBgAgQowchBQJAAn0CQCACRQ0AA0AgBCABTw0DIAUgACAEai0AAEECdGoiBiAGKAIAQQFqNgIAIARBK2oiBCACSQ0ACyACQSpqIgBBK24hBCAAQYDWAEkNACAEsyIHEMQCDAELIASzIQcgBEECdEGQx+IAaioCAAshCCAHIAhDAAAAP5KUQwAASEOSIQdBACEEA0AgAy0AALMhCSAEIAVqKAIAIgCzIQggA0EBaiEDIAcCfSAAQYACTwRAIAgQxAIMAQsgAEECdEGQx+IAaioCAAsgCZIgCJSTIQcgBEEEaiIEQYAIRw0ACyAFQYAIaiQAIAdDAAAAAGAPCyAEIAFBhI7jABC8BAALvAIBBX8gACgCGCEDAkACQCAAIAAoAgxGBEAgAEEUQRAgAEEUaiIBKAIAIgQbaigCACICDQFBACEBDAILIAAoAggiAiAAKAIMIgE2AgwgASACNgIIDAELIAEgAEEQaiAEGyEEA0AgBCEFIAIiAUEUaiICIAFBEGogAigCACICGyEEIAFBFEEQIAIbaigCACICDQALIAVBADYCAAsCQCADRQ0AAkAgACAAKAIcQQJ0QbCU7ABqIgIoAgBHBEAgA0EQQRQgAygCECAARhtqIAE2AgAgAUUNAgwBCyACIAE2AgAgAQ0AQcyX7ABBzJfsACgCAEF+IAAoAhx3cTYCAA8LIAEgAzYCGCAAKAIQIgIEQCABIAI2AhAgAiABNgIYCyAAQRRqKAIAIgBFDQAgAUEUaiAANgIAIAAgATYCGAsLvwICA38BfSMAQRBrIgQkACAEIAFBAiACQQFzIAMbQQd0aiIGQcADaioCADgCBCAEIAZBgANqKgIAOAIAIARCADcCCEEBIQEDQEEAIQJBASEDA0AgBiACQQZ0aiABQQJ0akGAA2oqAgAiByAEIAJBAnQiAmoiBSoCAF0EQCAFIAc4AgAgBEEIaiACaiABNgIAC0EBIQIgA0EBcUEAIQMNAAsgAUEBaiIBQRBHDQALAkAgBCgCCCIBQRBJBEAgBCgCDCICQRBPDQEgACAEKQMANwIIIAAgAkEBdCICQdCcwABqLwEAOwEGIAAgAkGgnMAAai8BADsBBCAAIAFBAXQiAUHQnMAAai8BADsBAiAAIAFBoJzAAGovAQA7AQAgBEEQaiQADwsgAUEQQcCcwAAQvAQACyACQRBB8JzAABC8BAALtQIBB38jAEEQayIIJAAgCEEHNgIMAkACQAJAIAMEQCACIANuIQogAyAFSw0BIAQgA0GICGxqIQcgBCEGA0AgBkEAQYQIEKMHIgZBhAhqQaPg//sHNgIAIAZBiAhqIgYgB0cNAAsgAkG5f2ohC0EAIQcCQANAIAkgA24hBiAHBEAgCEEMahDMBiADIAJLDQUgCnAgBmohBgsgBSAHRg0BIAYgCyAGQcYAaiACSRsiBiABSw0FIAQgACAGaiABIAZrQcYAEJkFIAIgCWohCSAEQYgIaiEEIAMgB0EBaiIHRw0ACyAIQRBqJAAPCyAFIAVBzN3AABC8BAALQdDRwABBGUG40cAAELgFAAsgAyAFQYCdwAAQhwcAC0Hw0cAAQTlBuNHAABC4BQALIAYgAUHc3cAAEIYHAAuSAgEEfyMAQRBrIgMkACAAEKgEIABBGGoQqAQgAEEwahCoBCADQQhqEKwHIABBzABqIgEoAgAhAiADKAIIIQQgASADKAIMNgIAIAAoAkggACAENgJIIAIQ0gYgAEEANgJwIAMQrAcgAEHUAGoiASgCACECIAMoAgAhBCABIAMoAgQ2AgAgACgCUCAAIAQ2AlAgAhDSBiAAQQA2AnQgAEHcAGooAgAgACgCWCECIABCBDcCWARAIAIQUgsgAEEANgJ4IABB5ABqKAIAIAAoAmAhAiAAQgQ3AmAEQCACEFILIABBADYCfCAAQewAaigCACAAKAJoIQIgAEIENwJoBEAgAhBSCyAAQQA2AoABIANBEGokAAvRAgEDfyAALQC7KkUEQCAAQcAnaiIBEM8EIABBgChqIgIgARDJBDYCACABEOQEIABBfzYChCogAEGUKmpBASABKAI8IgMgASgCQCIBIAMgAUobQQFqdCIBNgIAIABBnCpqQQEgAigCAHQiAjYCACAAQZgqaiABQX9qNgIAIABBoCpqIAEgAmo2AgAgAEH8J2ooAgAiAUESIAFBEkobIAEgAEH4J2oiASgCAEECSRsgAEGWKGotAAAgAEG0KmogAEG2KmoQugQgASgCAEUEQCAAQYAmaiAAQYAkaiAAQYAgaiAAQfwpahCiBQsgAEGYKGotAAAEQCAAQYAnaiECQQAhAQNAIAEgAmpB8P///wc2AgAgAUEEaiIBQcAARw0ACyAAQaAoaiECQQAhAQNAIAEgAmpB8P///wc2AgAgAUEEaiIBQRBHDQALCyAAQQE6ALsqCwvRAgIEfwJ+IwBBQGoiAyQAIAACfyAALQAIBEAgACgCACEFQQEMAQsgACgCACEFIABBBGooAgAiBCgCGCIGQQRxRQRAQQEgBCgCAEH99usAQYf36wAgBRtBAkEBIAUbIAQoAgQoAgwRAwANARogASAEIAIoAgwRAQAMAQsgBUUEQCAEKAIAQYX36wBBAiAEKAIEKAIMEQMABEBBACEFQQEMAgsgBCgCGCEGCyADQQE6ABcgA0Hc9usANgIcIAMgBCkCADcDCCADIANBF2o2AhAgBCkCCCEHIAQpAhAhCCADIAQtACA6ADggAyAEKAIcNgI0IAMgBjYCMCADIAg3AyggAyAHNwMgIAMgA0EIajYCGEEBIAEgA0EYaiACKAIMEQEADQAaIAMoAhhB+/brAEECIAMoAhwoAgwRAwALOgAIIAAgBUEBajYCACADQUBrJAAgAAufAgEHfyMAQZARayIGJAAgBkEHNgIEIAMEQAJAIAMgAkEBdEEobmpB4wBqIgcgByADcCIIRwRAIAcgCGsiB0EBIAdBAUsbIQtBACEHA0AgBkEIahDxBiAGQQhqQQBBhBEQowcaIAZBo+D/+wc2AowRIAZBBGogACABIAIgBkEIahDZBCAHIANwIgggBU8NAiAHQQFqIQcgBCAIQYgRbGoiCiAGKAKIESAKKAKAEWo2AoARQQAhCEEAIQkDQCAKIAlBAnRqIgwgBkEIaiAIaigCACAMKAIAajYCACAJQQFqIQkgCEEEaiIIQYARRw0ACyAHIAtHDQALCyAGQZARaiQADwsgCCAFQbzdwAAQvAQAC0HQ0cAAQRlBuNHAABC4BQALpwIBBX8gAEIANwIQIAACf0EAIAFBgAJJDQAaQR8gAUH///8HSw0AGiABQQYgAUEIdmciAmt2QQFxIAJBAXRrQT5qCyICNgIcIAJBAnRBsJTsAGohAyAAIQQCQAJAAkACQEHMl+wAKAIAIgVBASACdCIGcQRAIAMoAgAhAyACENUGIQIgAxCdByABRw0BIAMhAgwCC0HMl+wAIAUgBnI2AgAgAyAANgIADAMLIAEgAnQhBQNAIAMgBUEddkEEcWpBEGoiBigCACICRQ0CIAVBAXQhBSACIgMQnQcgAUcNAAsLIAIoAggiASAENgIMIAIgBDYCCCAEIAI2AgwgBCABNgIIIABBADYCGA8LIAYgADYCAAsgACADNgIYIAQgBDYCCCAEIAQ2AgwLqAIBBn8jAEEQayIDJAACfwJAIAAoAggiASAAKAIEIgRJBEAgACgCACEFA0ACQAJAAkACQCABIAVqLQAAIgJBDEwEQCACQXdqQQJJDQQMAQsgAkEfTARAIAJBDUcNAQwECyACQSBGDQMgAkHdAEYNASACQSxGDQILIANBEzYCAAwFCyAAIAFBAWo2AghBAAwFCyAAIAFBAWoiATYCCAJAIAEgBE8NAANAIAEgBWotAAAiAkF3aiIGQRdLQQEgBnRBk4CABHFFckUEQCAAIAFBAWoiATYCCCABIARHDQEMAgsLIAJB3QBHDQAgA0ESNgIADAQLIANBEzYCAAwDCyAAIAFBAWoiATYCCCABIARHDQALCyADQQI2AgALIAAgAxDMBAsgA0EQaiQAC6cCAQR/IAAoAgQhByAAIAAoAgAiCDYCBCAAIAJB/wFxIgI2AgAgA0UEQCAAQQFBACACQQJqIAIgB0YbIAhBAWogAkYbIgJqQcAEai0AACAAIAJBAXRqQQhqMwEAIAQgBSAGEK0CC0EUQQ4gAUHwBUsbQQdBACABQShLGyABQbABSxsiAkHCBmohAyACQQN0QdDRwQBqIQogAkEBdCAAakGMBGohBwJAA0AgByEIIAohCSADIgJB2wZGDQEgAkEBaiEDIAhBAmohByAJQQhqIgooAgAgAU0NAAsgA0G9eWoiA0EaSQ0AIANBGkGw2MEAELwEAAsgCUEEaigCACAJKAIAIQMgACACai0AACAIMwEAIAQgBSAGEK0CIAEgA2utIAQgBSAGEK0CC6gCAQl/IwBBIGsiAiQAIAACfyABKAIIIgVBBGogASgCBCIETQRAQQAgBCAFayIDIAMgBEsbIQcgASgCACAFaiEIQQAhAwJAA0AgAyAHRg0BIAEgAyAFaiIJQQFqNgIIIAMgCGotAABBgK/BAGotAAAiCkH/AUYEQCACQQhqIAEgCUEBahCvBCACKAIMIQEgAigCCCEEIAJBCzYCECAAIAJBEGogBCABEOYFNgIEQQEMBAsgBkEEdCAKaiEGIANBAWoiA0EERw0ACyAAIAY7AQJBAAwCCyADIAVqIARB4KzBABC8BAALIAEgBDYCCCACIAEgBBCvBCACKAIEIQEgAigCACEDIAJBBDYCECAAIAJBEGogAyABEOYFNgIEQQELOwEAIAJBIGokAAuYAgEHfyMAQZAIayIHJAAgB0EHNgIEIAMEQAJAIAMgAkEBdEHGAG5qQeMAaiIGIAYgA3AiCEcEQCAGIAhrIgZBASAGQQFLGyELQQAhBgNAIAdBCGpBAEGECBCjBxogB0Gj4P/7BzYCjAggB0EEaiAAIAEgAiAHQQhqEOcEIAYgA3AiCCAFTw0CIAZBAWohBiAEIAhBiAhsaiIKIAcoAogIIAooAoAIajYCgAhBACEIQQAhCQNAIAogCUECdGoiDCAHQQhqIAhqKAIAIAwoAgBqNgIAIAlBAWohCSAIQQRqIghBgAhHDQALIAYgC0cNAAsLIAdBkAhqJAAPCyAIIAVBvN3AABC8BAALQdDRwABBGUG40cAAELgFAAuXAgEHfyMAQZAWayIHJAAgB0EHNgIEIAMEQAJAIAMgAkEBdEEobmpB4wBqIgYgBiADcCIIRwRAIAYgCGsiBkEBIAZBAUsbIQtBACEGA0AgB0EIakEAQYQWEKMHGiAHQaPg//sHNgKMFiAHQQRqIAAgASACIAdBCGoQ2gQgBiADcCIIIAVPDQIgBkEBaiEGIAQgCEGIFmxqIgogBygCiBYgCigCgBZqNgKAFkEAIQhBACEJA0AgCiAJQQJ0aiIMIAdBCGogCGooAgAgDCgCAGo2AgAgCUEBaiEJIAhBBGoiCEGAFkcNAAsgBiALRw0ACwsgB0GQFmokAA8LIAggBUG83cAAELwEAAtB0NHAAEEZQbjRwAAQuAUAC60CAQV/IwBBwAVrIgIkACACQQBBwAUQowchBgJAIAEoAngiBQRAIAFB3ABqKAIAIQQgASgCWCECA0AgAyAERg0CQYACIAJBgAIgBhAxIAJBiAhqIQIgBSADQQFqIgNHDQALCwJAIAEoAnwiBQRAIAFB5ABqKAIAIQQgASgCYCECQQAhAwNAIAMgBEYNAkHABSACQcAFIAYQMSACQYgWaiECIAUgA0EBaiIDRw0ACwsCQCABKAKAASIFBEAgAUHsAGooAgAhBCABKAJoIQJBACEDA0AgAyAERg0CIAAgAkGgBCAGEDEgAkGIEWohAiAFIANBAWoiA0cNAAsLIAZBwAVqJAAPCyAEIARBlPXAABC8BAALIAQgBEGE9cAAELwEAAsgBCAEQfT0wAAQvAQAC50CAQJ/IwBBEGsiAiQAAkAgACgCACIAIAJBDGoCfwJAIAFBgAFPBEAgAkEANgIMIAFBgBBPDQEgAiABQT9xQYABcjoADSACIAFBBnZBwAFyOgAMQQIMAgsgACgCCCIDIAAoAgBGBH8gACADEMQFIAAoAggFIAMLIAAoAgRqIAE6AAAgACAAKAIIQQFqNgIIDAILIAFBgIAETwRAIAIgAUE/cUGAAXI6AA8gAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANIAIgAUESdkEHcUHwAXI6AAxBBAwBCyACIAFBP3FBgAFyOgAOIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDCxDjBQsgAkEQaiQAQQALmwICBH8BfiMAQSBrIgUkACAFIAEgAK2IIgk3AwACQAJAAkAgCVAEQCAAQf8BcUE4Sw0BIAIoAgAiB0EDdiIGIARPDQIgBkEHaiIIIARJDQMgCCAEQdzUwQAQvAQACyAFQQA2AhAgBSAFQQhqEO8EAAtBnNTBAEEeQbzUwQAQuAUACyAGIARBzNTBABC8BAALIAIgByAAQf8BcWo2AgAgAyAIaiABIAdBB3GthiIBQjiIPAAAIAMgBmoiAEEGaiABQjCIPAAAIABBBWogAUIoiDwAACAAQQRqIAFCIIg8AAAgAEEDaiABQhiIPAAAIABBAmogAUIQiDwAACAAQQFqIAFCCIg8AAAgACAALQAAIAGncjoAACAFQSBqJAALugIBBX8jAEEQayIFJAAgBUEANgIIAkACQAJAAkACQCABQQNLBEAgBUEIakEEIABBBEHI2eIAEMIGIAUtAAshBiAFLQAKIQcgBS0ACSEIIAUtAAghCSAFQQA2AgwgA0EDTQ0BIAVBDGpBBCACQQRByNniABDCBgJ/QQAgBSgCDCAIQQh0IAlyIAdBEHRyIAZBGHRyRw0AGkEBIARBBEYNABogAUEFSQ0DIANBBE0NBEEAIAAtAAQgAi0ABEcNABogAUEGSQ0FIANBBU0NBiAALQAFIAItAAVGCyAFQRBqJAAPC0G42OIAQSNBuNniABC4BQALQbjY4gBBI0G42eIAELgFAAtBBEEEQbTd4gAQvAQAC0EEQQRBxN3iABC8BAALQQVBBUHU3eIAELwEAAtBBUEFQeTd4gAQvAQAC74CAQZ/IwBBEGsiCyQAIAVB8A1qIQ0gBS0AkxMhCANAAkACQAJAIAhB/wFxRQRAIAUoApQOIgkgBSgC2A8iCEkNASAFKAKQDiAIaiAJIAhrIA0gBSgC6A8iCSAIayAFKAKADkHAACAFKAL4DWtBA3ZqIgogBSgCiBAiDCAKIAxIGyIKIAggCmogCUobIgkgBiAHEJACIAUgCSAFKALYD2oiCjYC2A8gBSAFKAKIECIMIAlrNgKIEEEBIQggCkEBIAUoAuAQdE4NAkEBQQIgCSAMRhshCAwDCyALIAAgASACIAMgBEEAIAUQ7QEgCygCACIIQQFHDQJBACEIIAUoAugPQQEgBSgC4BB0Rw0BIAUgBSgC3A82AuQPDAELIAggCUGcqeMAEIYHAAsgBSAIOgCTEwwBCwsgC0EQaiQAIAgL3QEBA38jAEEQayICJAAgAkEIaiAAQYgCahCYByACKAIMBEAQ3AQLIABB7AlqKAIABEAgACgC6AkQUgsDQCAAIAFqIgNBjAJqKAIABEAgA0GIAmooAgAQUgsgAUEQaiIBQYABRw0ACyAAQYwKaigCAARAIAAoAogKEFILQQAhAQNAIAAgAWoiA0EMaigCAARAIANBCGooAgAQUgsgAUEQaiIBQfABRw0ACyAAQbwJaigCAARAIABBuAlqKAIAEFILIABBxAlqKAIABEAgAEHACWooAgAQUgsgAkEQaiQAC5kCAQx/IwBBEGsiBSQAIAMgAygCECIJQQZ0IgQ2AnAgBUEIaiAEENYFIANBzABqIgQoAgAhBiAFKAIIIQcgBCAFKAIMNgIAIAMoAkggAyAHNgJIIAYQ0gYgCQRAIANByABqIQtBACEEA0AgACAIbCEMIAhBAWohCCAEIQYgASEHQQAhAwJAAkADQCACIANGDQEgBygCACENIAUgCxCYByADIApqIg4gBSgCBCIPSQRAIAUoAgAgBmogDCANajYCACAGQQRqIQYgB0EEaiEHIANBAWoiA0HAAEYNAwwBCwsgDiAPQaTywAAQvAQACyACIAJBlPLAABC8BAALIARBgAJqIQQgCkFAayEKIAggCUcNAAsLIAVBEGokAAv+AQELfwJAIAJFBEBBASEIQQEhCQwBC0EBIQlBASEIA0ACQAJAAkAgBiABSQRAQQEhBSAGQQFqIAJPDQMgACAGaiINLQAAIQ4gASAGayEPIAIgBmshCwNAIAUgD0YNAiAOIgwgBSANai0AAEcNAyALIAVBAWoiBUcNAAsgCyEFDAILIAYgAUGQ/OIAELwEAAsgASABQaD84gAQvAQACyAMRUEAIAVBAksbRQRAIAxFIAVBA01yDQEgCEEBaiEIIAUgB2ohBwwBCyAJQQFqIQkgBSAKaiEKCyAFIAZqIgYgAkkNAAsLIAQgCiAJQQF0SzYCACADIAcgCEEBdEs2AgALlQIBAX8jAEEQayICJAAgACgCACEAAn8CQCABKAIIQQFHBEAgASgCEEEBRw0BCyACQQA2AgwgASACQQxqAn8gAEGAAU8EQCAAQYAQTwRAIABBgIAETwRAIAIgAEE/cUGAAXI6AA8gAiAAQRJ2QfABcjoADCACIABBBnZBP3FBgAFyOgAOIAIgAEEMdkE/cUGAAXI6AA1BBAwDCyACIABBP3FBgAFyOgAOIAIgAEEMdkHgAXI6AAwgAiAAQQZ2QT9xQYABcjoADUEDDAILIAIgAEE/cUGAAXI6AA0gAiAAQQZ2QcABcjoADEECDAELIAIgADoADEEBCxBkDAELIAEoAgAgACABKAIEKAIQEQEACyACQRBqJAALYAEMf0G4lewAKAIAIgIEQEGwlewAIQYDQCACIgEoAgghAiABKAIEIQMgASgCACEEIAFBDGooAgAaIAEhBiAFQQFqIQUgAg0ACwtB8JfsACAFQf8fIAVB/x9LGzYCACAIC7kCAQN/IwBBEGsiByQAAkACQAJAAkAgACAAKAKMByIFBH8gBQUgACAAKAKIB0EBaiIFNgKIByAFIABBDGooAgAiBk8NASAFIAAoAgQiBk8NAiAAKAIAIAVqLQAAIQYgACAAKAIIIAVBAnRqKAIAIgU2AowHIAAgBiAAKAIgbDYCkAcgAEEsaiAFIAZBACACIAMgBBCnAiAAKAKMBwtBf2o2AowHIAAoApAHIQUgB0EIaiAAQRBqEJgHIAEgBWoiASAHKAIMIgVPDQIgASAAQRxqKAIAIgVJDQMgASAFQYDKwAAQvAQACyAFIAZB0MnAABC8BAALIAUgBkHgycAAELwEAAsgASAFQfDJwAAQvAQACyAHKAIIIAFqLQAAIAAoAhggAUEBdGozAQAgAiADIAQQrQIgB0EQaiQAC5gCAQJ/IwBBEGsiAiQAAkAgACACQQxqAn8CQCABQYABTwRAIAJBADYCDCABQYAQTw0BIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECDAILIAAoAggiAyAAKAIARgR/IAAgAxDEBSAAKAIIBSADCyAAKAIEaiABOgAAIAAgACgCCEEBajYCCAwCCyABQYCABE8EQCACIAFBP3FBgAFyOgAPIAIgAUEGdkE/cUGAAXI6AA4gAiABQQx2QT9xQYABcjoADSACIAFBEnZBB3FB8AFyOgAMQQQMAQsgAiABQT9xQYABcjoADiACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwsQ4wULIAJBEGokAEEAC6YCAQN/AkACQAJAIAUEQCADIQcDQCAEIAZGDQIgB0GAAjsBACAHQQJqIQcgBSAGQQFqIgZHDQALC0EAIQUgAg0BDAILIAQgBEH0meMAELwEAAtBACEGA0ACQAJAAkAgASAGRwRAIAAgBmotAAAiByAETw0BIAZBAWohBiADIAdBAXRqIgcvAQBBgAJGDQIMAwsgASABQYSa4wAQvAQACyAHIARBlJrjABC8BAALIAcgBTsBACAFQQFqIQULIAIgBkcNAAtBACEGAkADQCABIAZHBEAgACAGaiIILQAAIgcgBE8NAiAIIAMgB0EBdGotAAA6AAAgBkEBaiIGIAJHDQEMAwsLIAEgAUGkmuMAELwEAAsgByAEQbSa4wAQvAQACyAFQf//A3ELzwICBH8CfiMAQUBqIgIkAEEBIQQCQCAALQAEDQAgAC0ABSEEAkACQAJAIAAoAgAiAygCGCIFQQRxRQRAIAQNAQwDCyAEDQFBASEEIAMoAgBBiffrAEEBIAMoAgQoAgwRAwANAyADKAIYIQUMAQtBASEEIAMoAgBB/fbrAEECIAMoAgQoAgwRAwBFDQEMAgtBASEEIAJBAToAFyACQdz26wA2AhwgAiADKQIANwMIIAIgAkEXajYCECADKQIIIQYgAykCECEHIAIgAy0AIDoAOCACIAMoAhw2AjQgAiAFNgIwIAIgBzcDKCACIAY3AyAgAiACQQhqNgIYIAEgAkEYakGM0uIAKAIAEQEADQEgAigCGEH79usAQQIgAigCHCgCDBEDACEEDAELIAEgA0GM0uIAKAIAEQEAIQQLIABBAToABSAAIAQ6AAQgAkFAayQAC/8BAQd/IwBBIGsiDiQAIAYoAjwhFAJAAkAgAUEBaiISRQRAIA5BCGoQ2QZBBCEQDAELIA4gEhDaAyAOKAIEIQ8gDigCACEQIA5BCGoQ2QYgECERA0AgDyATRg0CIBEgDikDCDcCACARQRBqIA5BGGooAgA2AgAgEUEIaiAOQRBqKQMANwIAIBFBFGohESASIBNBAWoiE0cNAAsLIAwgDCgCACAAIAEgAiADIAQgBSAGQQEgFHRBcGoiACAIIAcgECAPEHBqNgIAIAEgAiAAIBAgDyAIIAkgBiAKIAsgDRDjASAPBEAgEBBSCyAOQSBqJAAPCyAPIA9BvI/BABC8BAALkQICAn8CfSMAQRBrIgUkACABQQAgAkEBcRsEQCABQX9qIQFDAAAAACAAKAIAIgRB//8DcUECdEGQx9IAaioCACAEs5STIQYgAEEEaiEACyABIAJBfnEiAU8EQCAFQQhqIgIgADYCBCACIAAgAUECdGo2AgAgBSgCDCIBIAUoAggiAkcEQANAIAEoAgAiACAEaiEEIAYgAEH//wNxQQJ0QZDH0gBqKgIAIACzlJMhBiABQQRqIgEgAkcNAAsLIAQEQCAEsyEHIAYCfSAEQYACTwRAIAcQxAIMAQsgBEECdEGQx+IAaioCAAsgB5SSIQYLIAMgBDYCACAFQRBqJAAgBg8LQbLdwQBBI0Gc38EAELgFAAujAgEBfyMAQSBrIgMkACADIAI2AgQgAkGAAkYEQCAAIAFBEGoiAS8BADsBACAAIAFB4ANqLwEAOwEeIAAgAUHAA2ovAQA7ARwgACABQaADai8BADsBGiAAIAFBgANqLwEAOwEYIAAgAUHgAmovAQA7ARYgACABQcACai8BADsBFCAAIAFBoAJqLwEAOwESIAAgAUGAAmovAQA7ARAgACABQeABai8BADsBDiAAIAFBwAFqLwEAOwEMIAAgAUGgAWovAQA7AQogACABQYABai8BADsBCCAAIAFB4ABqLwEAOwEGIAAgAUFAay8BADsBBCAAIAFBIGovAQA7AQIgA0EgaiQADwsgA0EANgIQIANBBGpBkJHjACADQQhqQYiU4wAQ8QQAC+MBAQF/IwBBoBNrIgEkACABIAAQgwUgARD9AiABQZQOaigCAARAIAEoApAOEFILIAFBmA5qEOgFIAFBsA5qEOgFIAFByA5qEOgFIAFBpA9qKAIABEAgAUGgD2ooAgAQUgsgAUGsD2ooAgAEQCABQagPaigCABBSCyABQeQOaigCAARAIAEoAuAOEFILIAFB7A5qKAIABEAgASgC6A4QUgsgAUH0DmooAgAEQCABKALwDhBSCyABQfwOaigCAARAIAEoAvgOEFILIAFBhA9qKAIABEAgASgCgA8QUgsgAUGgE2okAAupAgEDfyMAQeAAayIBJAAgAUEANgIgIAFCgICAgBA3AxggAUE4aiABQRhqQcCTwQAQtAYgACABQThqEIUCRQRAIAFBGGpB/JTBAEEKEOMFIAFBEGoQBSIAEAYgASgCECECIAEgASgCFCIDNgJAIAEgAjYCPCABIAM2AjggAUEIaiABQThqEJ4GIAEgASgCDCICNgIwIAEgASgCCCIDNgIsIAEgAjYCKCABQRhqIAMgAhDjBSABQRhqQYaVwQBBAhDjBSABQUBrIAFBIGooAgA2AgAgASABKQMYNwM4IAEgAUE4ahCeBiABKAIAIAEoAgQQByABQShqEM0GIABBJE8EQCAAEAgLIAFB4ABqJAAPC0HYk8EAQTcgAUEoakGQlMEAQeyUwQAQmAQAC4UDAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAgBBAWsOFQECAwQFBgcICQoLDA0ODxAREhMUFQALIAEgACgCBCAAQQhqKAIAEOMGDwsgAEEEaiABEO4BDwsgAUHMt8EAQRgQ4wYPCyABQbG3wQBBGxDjBg8LIAFBl7fBAEEaEOMGDwsgAUH+tsEAQRkQ4wYPCyABQfK2wQBBDBDjBg8LIAFB37bBAEETEOMGDwsgAUHMtsEAQRMQ4wYPCyABQb62wQBBDhDjBg8LIAFBsLbBAEEOEOMGDwsgAUGitsEAQQ4Q4wYPCyABQZS2wQBBDhDjBg8LIAFBgbbBAEETEOMGDwsgAUHntcEAQRoQ4wYPCyABQam1wQBBPhDjBg8LIAFBlbXBAEEUEOMGDwsgAUHxtMEAQSQQ4wYPCyABQeO0wQBBDhDjBg8LIAFB0LTBAEETEOMGDwsgAUG0tMEAQRwQ4wYPCyABQZy0wQBBGBDjBguLAgIEfwF+AkACQCACRQRAIABBADoAAQwBCwJAAkACQCABLQAAQVVqDgMBAgACCyACQQFGDQMMAQsgAkF/aiICRQ0CIAFBAWohAQsCQAJAAkAgAkEJTwRAA0AgAS0AAEFQaiIEQQlLDQYgA61CCn4iB0IgiKcNBCAHpyIFIAQgBiAEQQpJG2oiAyAFSQ0DIAFBAWohASAEIQYgAkF/aiICDQALDAELA0AgAS0AAEFQaiIEQQlLDQUgAUEBaiEBIAQgA0EKbGohAyACQX9qIgINAAsLIAAgAzYCBCAAQQA6AAAPCyAAQQI6AAEMAQsgAEECOgABCyAAQQE6AAAPCyAAQQE6AAEgAEEBOgAAC4sCAgJ/AX4CQCABQR9xIglBGE0EQAJAIAkgBEsNACAAKAIEIAlBAnRqKAIAIAFBBXYiBCAJbGoiAUGhvwdPDQIgAiADIAAoAgggAWpBoL8HIAFrIAkQ0gQiAUUgAUEKaiAJTXINACAEIAVqQoDktNGtwdSNByAJIAFrrSILQgZ+iEI/gyALQgKGfKcgACgCACAJai0AAHRqQQFqIgAgBksNACABIAdBAnZsrSAAZ0EgakE/c0EebK19QoAPfCILIAgpAwBUDQAgCCAANgIQIAggATYCCCAIIAs3AwAgCCABIAlzNgIMQQEhCgsgCg8LIAlBGUGY1+IAELwEAAsgAUGgvwdBqNfiABCGBwALxAIBA38jAEGAAWshAwJAIAEvAQ4iBUH/B3EiBEEQTwRAAn8gAigCBCIDQRBqIARNBEAgAyAEIANrQXBqIgRBfyACKAIAIgJ0QX9zcWogASgCCCAEIAJ2QQFxQQJyIAVBCnZ0akF8aiACdGpBAWoMAQsgBEFxagshAUEAIQIMAQsgA0KCgICAMDcDeCADQoKAgIBQNwNwIANCgoCAgCA3A2ggA0KCgICAYDcDYCADQoKAgIAQNwNYIANCgoCAgHA3A1AgA0KBgICAMDcDSCADQoGAgIBQNwNAIANCgYCAgCA3AzggA0KBgICAYDcDMCADQoGAgIAQNwMoIANCgYCAgHA3AyAgA0IENwMYIANCAzcDECADQgI3AwggA0IBNwMAIAMgBEEDdGoiASgCACECIAEoAgQhAQsgACABNgIEIAAgAjYCAAuYAgEFfyMAQSBrIgMkAAJAIAAoApQKIgIgAEHsCWooAgAiBEcNACAAKALoCSEFIAMgACgCnAogAkEBdBCbBCADKAIEIgQgAk8EQCADKAIAIAUgAkEUbBClByECIAAoAuwJIAAgBDYC7AkgACgC6AkhBiAAIAI2AugJRQ0BIAYQUgwBC0G+wcAAQSNBnMHAABC4BQALAkACQCAEIAAoApQKIgJGBEAgAEEBOgCjCgwBCyADQQhqIAEQ+wIgAiAETw0BIAAoAugJIAJBFGxqIgEgAykDCDcCACABQQhqIANBEGopAwA3AgAgAUEQaiADQRhqKAIANgIAIAAgAkEBajYClAoLIANBIGokAA8LIAIgBEGswcAAELwEAAuWAgEEfwJAIAEoAgQiAyACSwRAIAAgAjYCBCAAIAEoAggiBDYCCCAAIAEoAgAiBTYCACAAQSRqIAEpAgw3AgAgAEEsaiABQRRqKAIANgIAIAMgAmshASACIARqIQMgAiAFaiEEQQAhAkH0m+MAIQUMAQsgACABKQIANwIAIABBCGogAUEIaigCADYCACAAQSxqIAFBFGooAgAiBiACIANrIgJqNgIAIABBKGogAUEQaigCACIDIAIgAyACIANJGyICazYCACAAQSRqIAEoAgwiBSACajYCAEEAIQFB9JvjACEEQQAhAwsgACAENgIYIAAgBjYCFCAAIAI2AhAgACAFNgIMIABBIGogAzYCACAAQRxqIAE2AgALogICAn8CfQJAAkACfyAAvCIBQYCAgAROBEAgAUH////7B0sNAkMAAAAAIQBBgX8gAUGAgID8A0cNARoMAgsgAUH/////B3FFBEBDAACAvyAAIACUlQ8LIAFBAEgNAiAAQwAAAEyUvCEBQeh+CyECIAFBjfarAmoiAUH///8DcUHzidT5A2q+QwAAgL+SIgAgACAAQwAAAD+UlCIDk7xBgGBxviIEQwCwuD+UIAAgBJMgA5MgACAAQwAAAECSlSIAIAMgACAAlCIAIAAgAJQiAEPu6ZE+lEOqqio/kpQgACAAQyaeeD6UQxPOzD6SlJKSlJIiAEMAsLg/lCAAIASSQ9SaOLmUkpIgAUEXdiACarKSIQALIAAPCyAAIACTQwAAAACVC5cCAQR/IwBBIGsiAiQAAkACQCAAKAIIIgEgACgCBCIDSQRAA0ACQCAAKAIAIAFqLQAAIgRB8KzBAGotAABFBEAgACABQQFqIgE2AggMAQsgBEHcAEcEQCAEQSJHBEAgAkEIaiAAIAEQrwQgAigCDCEAIAIoAgghASACQQ82AhAgAkEQaiABIAAQ5gUhAQwFCyAAIAFBAWo2AghBACEBDAQLIAAgAUEBajYCCCAAEMUDIgENAyAAKAIEIQMgACgCCCEBCyABIANJDQALCyABIANHDQEgAiAAIAEQrwQgAigCBCEAIAIoAgAhASACQQQ2AhAgAkEQaiABIAAQ5gUhAQsgAkEgaiQAIAEPCyABIANB0KzBABC8BAALiQIBBX8jAEEgayIMJAACQCACBEADQCAMQQA2AgggDEEANgIMIAwgBjYCFCAMIAU2AhAgDCAENgIcIAwgAzYCGCANIAJBgIAIIAJBgIAISRsiDiACIAAgASAHIAhBCEEEIAxBEGogDEEIaiAMQRhqIAxBDGoQEyANIAFLDQICQCAAIA1qIg8gASANayIQIA4gDCgCCBCXA0UEQCAPIBAgDiAJIAogCxDqBAwBCyAOQQAgCSAKIAsQlAVBDUIAIAkgCiALEPQCIAUgBiAMKAIIIAMgBCAMKAIMIAkgCiALEJQBCyANIA5qIQ0gAiAOayICDQALCyAMQSBqJAAPCyANIAFBxLnAABCGBwALiQIBBX8jAEEgayIMJAACQCACBEADQCAMQQA2AgggDEEANgIMIAwgBjYCFCAMIAU2AhAgDCAENgIcIAwgAzYCGCANIAJBgIAIIAJBgIAISRsiDiACIAAgASAHIAhBCUEEIAxBEGogDEEIaiAMQRhqIAxBDGoQEyANIAFLDQICQCAAIA1qIg8gASANayIQIA4gDCgCCBCXA0UEQCAPIBAgDiAJIAogCxDqBAwBCyAOQQAgCSAKIAsQlAVBDUIAIAkgCiALEPQCIAUgBiAMKAIIIAMgBCAMKAIMIAkgCiALEJQBCyANIA5qIQ0gAiAOayICDQALCyAMQSBqJAAPCyANIAFBxLnAABCGBwALiQIBBX8jAEEgayIMJAACQCACBEADQCAMQQA2AgggDEEANgIMIAwgBjYCFCAMIAU2AhAgDCAENgIcIAwgAzYCGCANIAJBgIAIIAJBgIAISRsiDiACIAAgASAHIAhBCkEEIAxBEGogDEEIaiAMQRhqIAxBDGoQEyANIAFLDQICQCAAIA1qIg8gASANayIQIA4gDCgCCBCXA0UEQCAPIBAgDiAJIAogCxDqBAwBCyAOQQAgCSAKIAsQlAVBDUIAIAkgCiALEPQCIAUgBiAMKAIIIAMgBCAMKAIMIAkgCiALEJQBCyANIA5qIQ0gAiAOayICDQALCyAMQSBqJAAPCyANIAFBxLnAABCGBwALiQIBBX8jAEEgayIMJAACQCACBEADQCAMQQA2AgggDEEANgIMIAwgBjYCFCAMIAU2AhAgDCAENgIcIAwgAzYCGCANIAJBgIAIIAJBgIAISRsiDiACIAAgASAHIAhBC0EEIAxBEGogDEEIaiAMQRhqIAxBDGoQEyANIAFLDQICQCAAIA1qIg8gASANayIQIA4gDCgCCBCXA0UEQCAPIBAgDiAJIAogCxDqBAwBCyAOQQAgCSAKIAsQlAVBDUIAIAkgCiALEPQCIAUgBiAMKAIIIAMgBCAMKAIMIAkgCiALEJQBCyANIA5qIQ0gAiAOayICDQALCyAMQSBqJAAPCyANIAFBxLnAABCGBwALiQIBBX8jAEEgayIMJAACQCACBEADQCAMQQA2AgggDEEANgIMIAwgBjYCFCAMIAU2AhAgDCAENgIcIAwgAzYCGCANIAJBgIAIIAJBgIAISRsiDiACIAAgASAHIAhBDEEEIAxBEGogDEEIaiAMQRhqIAxBDGoQEyANIAFLDQICQCAAIA1qIg8gASANayIQIA4gDCgCCBCXA0UEQCAPIBAgDiAJIAogCxDqBAwBCyAOQQAgCSAKIAsQlAVBDUIAIAkgCiALEPQCIAUgBiAMKAIIIAMgBCAMKAIMIAkgCiALEJQBCyANIA5qIQ0gAiAOayICDQALCyAMQSBqJAAPCyANIAFBxLnAABCGBwALiQIBBX8jAEEgayIMJAACQCACBEADQCAMQQA2AgggDEEANgIMIAwgBjYCFCAMIAU2AhAgDCAENgIcIAwgAzYCGCANIAJBgIAIIAJBgIAISRsiDiACIAAgASAHIAhBDUEEIAxBEGogDEEIaiAMQRhqIAxBDGoQEyANIAFLDQICQCAAIA1qIg8gASANayIQIA4gDCgCCBCXA0UEQCAPIBAgDiAJIAogCxDqBAwBCyAOQQAgCSAKIAsQlAVBDUIAIAkgCiALEPQCIAUgBiAMKAIIIAMgBCAMKAIMIAkgCiALEJQBCyANIA5qIQ0gAiAOayICDQALCyAMQSBqJAAPCyANIAFBxLnAABCGBwALiQIBBX8jAEEgayIMJAACQCACBEADQCAMQQA2AgggDEEANgIMIAwgBjYCFCAMIAU2AhAgDCAENgIcIAwgAzYCGCANIAJBgIAIIAJBgIAISRsiDiACIAAgASAHIAhBDkEEIAxBEGogDEEIaiAMQRhqIAxBDGoQEyANIAFLDQICQCAAIA1qIg8gASANayIQIA4gDCgCCBCXA0UEQCAPIBAgDiAJIAogCxDqBAwBCyAOQQAgCSAKIAsQlAVBDUIAIAkgCiALEPQCIAUgBiAMKAIIIAMgBCAMKAIMIAkgCiALEJQBCyANIA5qIQ0gAiAOayICDQALCyAMQSBqJAAPCyANIAFBxLnAABCGBwALiQIBBX8jAEEgayIMJAACQCACBEADQCAMQQA2AgggDEEANgIMIAwgBjYCFCAMIAU2AhAgDCAENgIcIAwgAzYCGCANIAJBgIAIIAJBgIAISRsiDiACIAAgASAHIAhBD0EGIAxBEGogDEEIaiAMQRhqIAxBDGoQEyANIAFLDQICQCAAIA1qIg8gASANayIQIA4gDCgCCBCXA0UEQCAPIBAgDiAJIAogCxDqBAwBCyAOQQAgCSAKIAsQlAVBDUIAIAkgCiALEPQCIAUgBiAMKAIIIAMgBCAMKAIMIAkgCiALEJQBCyANIA5qIQ0gAiAOayICDQALCyAMQSBqJAAPCyANIAFBxLnAABCGBwALiQIBBX8jAEEgayIMJAACQCACBEADQCAMQQA2AgggDEEANgIMIAwgBjYCFCAMIAU2AhAgDCAENgIcIAwgAzYCGCANIAJBgIAIIAJBgIAISRsiDiACIAAgASAHIAhBEEEGIAxBEGogDEEIaiAMQRhqIAxBDGoQEyANIAFLDQICQCAAIA1qIg8gASANayIQIA4gDCgCCBCXA0UEQCAPIBAgDiAJIAogCxDqBAwBCyAOQQAgCSAKIAsQlAVBDUIAIAkgCiALEPQCIAUgBiAMKAIIIAMgBCAMKAIMIAkgCiALEJQBCyANIA5qIQ0gAiAOayICDQALCyAMQSBqJAAPCyANIAFBxLnAABCGBwALiQIBBX8jAEEgayIMJAACQCACBEADQCAMQQA2AgggDEEANgIMIAwgBjYCFCAMIAU2AhAgDCAENgIcIAwgAzYCGCANIAJBgIAIIAJBgIAISRsiDiACIAAgASAHIAhBEUEGIAxBEGogDEEIaiAMQRhqIAxBDGoQEyANIAFLDQICQCAAIA1qIg8gASANayIQIA4gDCgCCBCXA0UEQCAPIBAgDiAJIAogCxDqBAwBCyAOQQAgCSAKIAsQlAVBDUIAIAkgCiALEPQCIAUgBiAMKAIIIAMgBCAMKAIMIAkgCiALEJQBCyANIA5qIQ0gAiAOayICDQALCyAMQSBqJAAPCyANIAFBxLnAABCGBwAL5gEBC38CfyAAQRBqKAIAIgYgACgCBCIHaiABQRBqKAIAIgQgASgCBCICakYEQCABKAIMIgUgBGohCCABKAIAIgMgAmohCSAAKAIMIgIgBmohCiAAKAIAIgEgB2ohCwNAAn8gAUUgASALRnJFBEAgAiEEIAFBAWoMAQtBASACRSACIApGcg0DGiACQQFqIQQgAiEBQQALIANFIAMgCUZyBH9BASAFRSAFIAhGcg0DGiAFIgNBAWohBUEABSADQQFqCyEHIAMtAAAhDCABLQAAIQYhASAEIQIgByEDIAYgDEYNAAsLQQALC9ECAQR/IwBBIGsiACQAAkACQEGolOwAKAIAQf////8HcQRAEK0HRQ0BC0GYlOwAKAIAQZiU7ABBfzYCAA0BAkACQEGolOwAKAIAQf////8HcUUEQEGklOwAKAIAIQFBpJTsAEHkoMAANgIAQaCU7AAoAgAhAkGglOwAQQE2AgAMAQsQrQdBpJTsACgCACEBQaSU7ABB5KDAADYCAEGglOwAKAIAIQJBoJTsAEEBNgIARQ0BC0GolOwAKAIAQf////8HcUUNABCtBw0AQZyU7ABBAToAAAtBmJTsAEEANgIAAkAgAkUNACACIAEoAgARBAAgAUEEaigCAEUNACABQQhqKAIAGiACEFILIABBIGokAA8LIABBFGpBATYCACAAQRxqQQA2AgAgAEG4zOsANgIQIABBzMLrADYCGCAAQQA2AgggAEEIakHczOsAEI8GAAsAC8gBACAAEP0CIABBlA5qKAIABEAgACgCkA4QUgsgAEGYDmoQ6AUgAEGwDmoQ6AUgAEHIDmoQ6AUgAEGkD2ooAgAEQCAAQaAPaigCABBSCyAAQawPaigCAARAIABBqA9qKAIAEFILIABB5A5qKAIABEAgACgC4A4QUgsgAEHsDmooAgAEQCAAKALoDhBSCyAAQfQOaigCAARAIAAoAvAOEFILIABB/A5qKAIABEAgACgC+A4QUgsgAEGED2ooAgAEQCAAKAKADxBSCwuFAgIEfwF+IwBBIGsiAyQAIAAgAjoAeSAAIAE6AHggACAAKAJsQQFqIgE2AmwCQCABQQN0QQdyIABB5ABqKAIAIgFJDQAgACgCYCEGIANBCGogAUEBdCICEOQDIAMpAwghByADIAI2AhggAyAHNwMQIAMgA0EQahCPBQJAIAMoAgQiBSABTwRAIAMoAgAhBCABRQ0BQQAhAgNAIAIgBGogAiAGaioCADgCACACQQRqIQIgAUF/aiIBDQALIAAoAmQgACAFNgJkIAAoAmAhAiAAIAQ2AmBFDQIgAhBSDAILQZCDwQBBI0HsgsEAELgFAAsgACAFNgJkIAAgBDYCYAsgA0EgaiQAC4wCAgN/AX4jAEEwayICJAAgASgCBEUEQCABKAIMIQMgAkEQaiIEQQA2AgAgAkKAgICAEDcDCCACIAJBCGo2AhQgAkEoaiADQRBqKQIANwMAIAJBIGogA0EIaikCADcDACACIAMpAgA3AxggAkEUakG0wusAIAJBGGoQqwEaIAFBCGogBCgCADYCACABIAIpAwg3AgALIAEpAgAhBSABQoCAgIAQNwIAIAJBIGoiAyABQQhqIgEoAgA2AgAgAUEANgIAIAIgBTcDGEEMQQQQ6QYiAUUEQEEMQQQQoQcACyABIAIpAxg3AgAgAUEIaiADKAIANgIAIABBjM3rADYCBCAAIAE2AgAgAkEwaiQAC/wBAgJ/An4jAEEQayIFJAACQAJAAkAgAyAEcSIDIAJNBEAgADUCACEHIAEgA2ogAiADaxDTBCEIIABBFGooAgAiAiAIIAeIpyIBTQ0BIAAoAhAgAUEBdGovAQAgACgCCCAAKAIMIQYgBUEIaiAAQRhqEJgHcSABIAZ0aiICIAUoAgwiA08NAiAFKAIIIAJBAnRqIAQ2AgAgACgCFCICIAFLDQMgASACQaSOwAAQvAQAC0HkjsAAQSNB9I3AABC4BQALIAEgAkGEjsAAELwEAAsgAiADQZSOwAAQvAQACyAAKAIQIAFBAXRqIgAgAC8BAEEBajsBACAFQRBqJAAL+AECAn8DfSMAQZAIayIHJABBASEIAkACQCAEQQh2QQJqIAZNDQAgBLMiCkOkcH0/lCAFs11FDQAgB0EMakEAQYAIEKMHGiAEQQxqIgRBDU8EQCAEQQ1uIQggA6chBANAIAIgBHEiBSABTw0DIAdBDGogACAFai0AAEECdGoiBSAFKAIAQQFqNgIAIARBDWohBCAIQX9qIggNAAsLIAdBADYCjAggB0EMakGAAkGAAiAHQYwIahC6AiEJIAcoAowIsyILIAkgCSALXRsgCkOkcP1AlEMAAFBBlV5BAXMhCAsgB0GQCGokACAIDwsgBSABQeju4gAQvAQAC+YBAQF/IwBBEGsiAiQAIAAoAgAgAkEANgIMIAJBDGoCfyABQYABTwRAIAFBgBBPBEAgAUGAgARPBEAgAiABQT9xQYABcjoADyACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA0gAiABQRJ2QQdxQfABcjoADEEEDAMLIAIgAUE/cUGAAXI6AA4gAiABQQx2QeABcjoADCACIAFBBnZBP3FBgAFyOgANQQMMAgsgAiABQT9xQYABcjoADSACIAFBBnZBwAFyOgAMQQIMAQsgAiABOgAMQQELENoBIAJBEGokAAuAAgECfyMAQRBrIgUkACAFQQA2AgwgAC0AACEGAn8CQANAAkACQAJAAkACQAJAIAZBAWsOAgIBAAsgAUEBIAVBDGogAyAEEM4EDQIMBgsgASACKAIAIgEgBUEMaiADIAQQzgQEQCAAQQA6AAAgAiAFKAIMQQEgAXRqNgIAQQEMBwsgAEECOgAAQQIMBgsgAUEDIAVBDGogAyAEEM4ERQRAIABBAToAAAwFCyAFKAIMIgZFDQIgAiAGNgIAQQIhBgwBC0EBIQYgBSgCDA0AIAJBADYCAEEBDAQLIAAgBjoAAAwBCwsgAEEAOgAAIAJBATYCAEEBDAELQQILIAVBEGokAAuVAgECfyMAQSBrIgIkAAJAAkACQAJ/IAEoAgAoAgAiASgCAEGslOwARwRAIAEtAAwhAyABQQE6AAwgAiADQQFxIgM6AAcgAw0CIAFBATYCBCABQayU7AA2AgBBAAwBCyABKAIEQQFqIgNFDQIgASADNgIEIANBf2oLIQMgASgCCA0CIABBwAA2AgQgAEEENgIAIAFBADYCCCABIAM2AgQgA0UEQCABQQA2AgAgAUEMakEAOgAACyACQSBqJAAPCyACQQA2AhwgAkHMwusANgIYIAJBATYCFCACQeTS6wA2AhAgAkEANgIIIAJBB2ogAkEIahD0BAALELoGAAtBzMLrAEEQIAJBCGpB3MLrAEHAyusAEJgEAAvbAQEKfwJAIAFBMGooAgAiDCABQSxqKAIAIghBB3ZPBEAgASgCNCEPQQEhDUEAQYCAAiACIAMQswUiCUEBdCILayIKIApBgIACSxshECAIQQFqIQogCUECdEHw38IAaiEJA0AgECARRg0CIAEgCjYCLAJAIAkvAQAiCEUNACAAIAggAiADIAQgBSAGIA8gBxDAAkUNAEEBIQ4gASAMQQFqIgw2AjALIAlBAmohCUEBIREgCkEBaiEKIAtBAWohCyANQQAhDQ0ACwsgDg8LIAtBgIACQbSRwAAQvAQAC68BAQd/AkAgAUEoaigCACILIAFBJGooAgAiCEEHdk8EQCABKAIsIQxBAEGAgAIgAiADELMFIglBAXQiDWsiCiAKQYCAAksbIAhBAWohCCAJQQJ0QfDfwgBqIQ5BACEJRQ0BIAEgCDYCJAJAIA4vAQAiCEUNACAAIAggAiADIAQgBSAGIAwgBxDAAkUNAEEBIQkgASALQQFqNgIoCwsgCQ8LIA1BgIACQbSRwAAQvAQAC9sBAQp/AkAgAUFAaygCACIMIAFBPGooAgAiCEEHdk8EQCABKAJEIQ9BASENQQBBgIACIAIgAxCzBSIJQQF0IgtrIgogCkGAgAJLGyEQIAhBAWohCiAJQQJ0QfDfwgBqIQkDQCAQIBFGDQIgASAKNgI8AkAgCS8BACIIRQ0AIAAgCCACIAMgBCAFIAYgDyAHEMACRQ0AQQEhDiABIAxBAWoiDDYCQAsgCUECaiEJQQEhESAKQQFqIQogC0EBaiELIA1BACENDQALCyAODwsgC0GAgAJBtJHAABC8BAAL3QEBCn8CQCABQcgAaigCACIMIAFBxABqKAIAIghBB3ZPBEAgASgCTCEPQQEhDUEAQYCAAiACIAMQswUiCUEBdCILayIKIApBgIACSxshECAIQQFqIQogCUECdEHw38IAaiEJA0AgECARRg0CIAEgCjYCRAJAIAkvAQAiCEUNACAAIAggAiADIAQgBSAGIA8gBxDAAkUNAEEBIQ4gASAMQQFqIgw2AkgLIAlBAmohCUEBIREgCkEBaiEKIAtBAWohCyANQQAhDQ0ACwsgDg8LIAtBgIACQbSRwAAQvAQAC/oBAgZ/AX4jAEEwayIDJABBBCEEQQQhBSACQQJqIgYEQCADQRhqIAYQ5AMgAykDGCEJIAMgBjYCKCADIAk3AyAgA0EQaiADQSBqEI8FIAMoAhQhByADKAIQIQULIAEoAggiAQRAIANBCGogASACaiIEEOQDIAMpAwghCSADIAQ2AiggAyAJNwMgIAMgA0EgahCPBSADKAIEIQggAygCACEECyAAQQBBgBYQowciAEGEFmogCDYCACAAIAQ2AoAWIAAgAjYCmBYgAEEANgKUFiAAQYwWaiAHNgIAIAAgBTYCiBYgACABQaAEIAFBoARJGzYCkBYgA0EwaiQAC+MBAQF/IwBBEGsiAiQAIAJBADYCDCAAIAJBDGoCfyABQYABTwRAIAFBgBBPBEAgAUGAgARPBEAgAiABQT9xQYABcjoADyACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA0gAiABQRJ2QQdxQfABcjoADEEEDAMLIAIgAUE/cUGAAXI6AA4gAiABQQx2QeABcjoADCACIAFBBnZBP3FBgAFyOgANQQMMAgsgAiABQT9xQYABcjoADSACIAFBBnZBwAFyOgAMQQIMAQsgAiABOgAMQQELENoBIAJBEGokAAv7AQECfyAAQQA2AogQIABCATcDiA8gAEHID2pBgICACDYCACAAQcAPakKAgICIgICAgAE3AwAgAEG4D2pBATYCACAAQbAPakKBgICAEDcDACAAQZgPakIBNwMAIABBkA9qQgE3AwAgAEH8DmooAgAgACgC+A4hAiAAQgE3A/gOBEAgAhBSCyAAQYQPaigCACAAKAKADyECIABCATcDgA8EQCACEFILIABB5A5qKAIAIAAoAuAOIQIgAEIBNwPgDgRAIAIQUgsgAEIANwL0DyAAQQA7AYQRIABBvJvrADYC6BAgAEGYDmoQqAUgAEGwDmoQqAUgAEHIDmoQqAUL4wEAAkAgAEEgSQ0AAkACf0EBIABB/wBJDQAaIABBgIAESQ0BAkAgAEGAgAhPBEAgAEHQuHNqQdC6K0kgAEG12XNqQQVJcg0EIABB4ot0akHiC0kgAEGfqHRqQZ8YSXINBCAAQX5xQZ7wCkYgAEHe4nRqQQ5Jcg0EIABBYHFB4M0KRw0BDAQLIABB1oXsAEEsQa6G7ABBxAFB8ofsAEHCAxD7AQ8LQQAgAEHGkXVqQQZJDQAaIABBgIC8f2pB8IN0SQsPCyAAQbiA7ABBKEGIgewAQZ8CQaeD7ABBrwIQ+wEPC0EAC+8BAgR/An4CQAJAAkAgAEE4aigCACIHRQRAAkAgAUUgACgCBEEGdiACSXJFBEAgAkUNASAEIQVBACEBA0AgASAESw0FIAA1AgAhCSABIANqIAUQ0wQhCiAAKAIUIgggCiAJiKciBk0NBiAAKAIQIAZBAXRqQQA7AQAgBUF/aiEFIAIgAUEBaiIBRw0ACwwBCyAAKAIQIAAoAgQiASAAQRRqKAIAIgNLDQIgAUUNAEEAIAFBAXQQowcaCyAAQQE2AjgLIAdFDwsgASADQdSOwAAQhwcACyABIARBtI7AABCGBwALIAYgCEHEjsAAELwEAAvvAQEGfyMAQRBrIgUkAAJAAkAgAEEgaigCACIIRQRAAkAgAUUgAkGAgAJLckUEQCACRQ0BQQAhASAEIQcDQCABIARLDQQgASADaiAHEN0DIQYgBSAAEJgHIAZBBGoiCSAFKAIEIgpLDQUgBSgCACAGQQJ0aiIGQgA3AgAgBkEIakIANwIAIAdBf2ohByACIAFBAWoiAUcNAAsMAQsgBUEIaiAAEJgHIAUoAgwiAUUNACAFKAIIQQAgAUECdBCjBxoLIABBATYCIAsgBUEQaiQAIAhFDwsgASAEQcyFwAAQhgcACyAJIApB3IXAABCHBwAL7gEBBn8jAEEQayIFJAACQAJAIABBIGooAgAiCEUEQAJAIAFFIAJBgCBLckUEQCACRQ0BQQAhASAEIQcDQCABIARLDQQgASADaiAHEI4EIQYgBSAAEJgHIAZBBGoiCSAFKAIEIgpLDQUgBSgCACAGQQJ0aiIGQgA3AgAgBkEIakIANwIAIAdBf2ohByACIAFBAWoiAUcNAAsMAQsgBUEIaiAAEJgHIAUoAgwiAUUNACAFKAIIQQAgAUECdBCjBxoLIABBATYCIAsgBUEQaiQAIAhFDwsgASAEQcyFwAAQhgcACyAJIApB3IXAABCHBwALhQIAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIAQQFrDgoBAgMEBQYHCAkKAAtB7IXAAEEMQYiGwAAQuAYACyAAQQRqIAEgAiADIAQgBRDQBQ8LIABBBGogASACIAMgBCAFEM8FDwsgAEEEaiABIAIgAyAEIAUQzgUPCyAAQQRqIAEgAiADIAQgBRDNBQ8LIABBBGogASACIAMgBCAFEK0FDwsgAEEEaiABIAIgAyAEIAUQrgUPCyAAQQRqIAEgAiADIAQgBRCvBQ8LIABBCGogASACIAMgBCAFENEFDwsgAEEEaiABIAIgAyAEIAUQzAUPCyAAQQRqIAEgAiADIAQgBRCFBAufAQECfyAAQewAaigCAARAIAAoAmgQUgsgAEH0AGooAgAEQCAAKAJwEFILIABB/ABqKAIABEAgACgCeBBSCyAAQYQBaigCAARAIAAoAoABEFILA0AgACABaiICQQRqKAIABEAgAigCABBSCyABQQhqIgFBIEcNAAsgAEGMAWooAgAEQCAAKAKIARBSCyAAQZQBaigCAARAIAAoApABEFILC+ABAQR/IwBBIGsiBSQAIAAoAgAgACgCCCIDayABSQRAIAAgAyABELwFIAAoAgghAwsgACgCBCADQRRsaiEEIAFBAk8EQCABQX9qIQYDQCAFQQhqIAIQ8QMgBEEQaiAFQRhqKAIANgIAIARBCGogBUEQaikDADcCACAEIAUpAwg3AgAgBEEUaiEEIAZBf2oiBg0ACyABIANqQX9qIQMLIAAgAQR/IAQgAikCADcCACAEQRBqIAJBEGooAgA2AgAgBEEIaiACQQhqKQIANwIAIANBAWoFIAMLNgIIIAVBIGokAAvpAQICfwJ8IwBBEGsiBiQAIAO6IQcgAAJ/AkACQCAEIARBH3UiBXMgBWsiBUG1Ak8EQANAIAdEAAAAAAAAAABhDQMgBEF/Sg0CIAdEoMjrhfPM4X+jIQcgBEG0AmoiBCAEQR91IgVzIAVrIgVBtQJPDQALCyAFQQN0QfiVwQBqKwMAIQggBEF/TARAIAcgCKMhBwwCCyAHIAiiIgdEAAAAAAAA8H9iQQAgB0QAAAAAAADw/2IbDQELIAZBDTYCACAAIAEgBhCTBTYCBEEBDAELIAAgByAHmiACGzkDCEEACzYCACAGQRBqJAAL7QEBAX8jAEHwAGsiAiQAIAJBADYCQCACQoCAgIAQNwM4IAAoAgAhACACQcgAaiACQThqQYCxwQAQtAYgAEEIaiACQcgAahC+AkUEQCACQTRqQSc2AgAgAkEsakEnNgIAIAJBFGpBBDYCACACQRxqQQM2AgAgAkEoNgIkIAJBiLjBADYCECACQQA2AgggAiAANgIoIAIgAEEEajYCMCACIAJBOGo2AiAgAiACQSBqNgIYIAEgAkEIahD9BCACKAI4BEAgAigCPBBSCyACQfAAaiQADwtBmLHBAEE3IAJBIGpB0LHBAEGsssEAEJgEAAvtAQECfyMAQRBrIgUkAAJAAkACQCADIARxIgMgAk0EQCAAIAEgA2ogAiADaxDfBCIBIABBHGooAgAiAk8NASAAKAIYIAFBAXRqLwEAIAAoAhAgACgCFCEGIAVBCGogAEEgahCYB3EgASAGdGoiAiAFKAIMIgNPDQIgBSgCCCACQQJ0aiAENgIAIAEgACgCHCICSQ0DIAEgAkGkjsAAELwEAAtB5I7AAEEjQfSNwAAQuAUACyABIAJBhI7AABC8BAALIAIgA0GUjsAAELwEAAsgACgCGCABQQF0aiIAIAAvAQBBAWo7AQAgBUEQaiQAC4ICAgF/An4jAEFAaiIBJAAgAUE4ahCqByABKQM4IQIgAUEwahCsByAAIAEpAzA3AgggACACNwIAIABCADcCECABQShqEKoHIAEpAyghAiABQSBqEKwHIABBIGogASkDIDcCACAAIAI3AhggAEEoakIANwIAIAFBGGoQqgcgASkDGCECIAFBEGoQrAcgAEE4aiABKQMQNwIAIAAgAjcCMCAAQUBrQgA3AgAgAUEIahCsByABKQMIIQIgARCsByABKQMAIQMgAEEANgJwIAAgAjcCSCAAIAM3AlAgAEIANwJ0IABCBDcCWCAAQgQ3AmAgAEIANwJ8IABCBDcCaCABQUBrJAAL5gEBA38gACgCACAAKAIIIgRrIAFJBEAgACAEIAEQwAUgACgCCCEECyAAKAIEIARBBXRqIQMgAUECTwRAIAFBf2ohBQNAIAMgAikCADcCACADQRhqIAJBGGopAgA3AgAgA0EQaiACQRBqKQIANwIAIANBCGogAkEIaikCADcCACADQSBqIQMgBUF/aiIFDQALIAEgBGpBf2ohBAsgACABBH8gAyACKQIANwIAIANBGGogAkEYaikCADcCACADQRBqIAJBEGopAgA3AgAgA0EIaiACQQhqKQIANwIAIARBAWoFIAQLNgIIC+YBAQN/IAAoAgAgACgCCCIEayABSQRAIAAgBCABEMMFIAAoAgghBAsgACgCBCAEQQV0aiEDIAFBAk8EQCABQX9qIQUDQCADIAIpAQA3AQAgA0EYaiACQRhqKQEANwEAIANBEGogAkEQaikBADcBACADQQhqIAJBCGopAQA3AQAgA0EgaiEDIAVBf2oiBQ0ACyABIARqQX9qIQQLIAAgAQR/IAMgAikBADcBACADQRhqIAJBGGopAQA3AQAgA0EQaiACQRBqKQEANwEAIANBCGogAkEIaikBADcBACAEQQFqBSAECzYCCAvjAQIEfwF+IAAtAAAhBiAAQQA6AAAgAiACKAIIIgRBAWoiAzYCCCACKQMAIgcgBEE/ca2Ip0EBcUUEQCABQRA2AgBBAQ8LIAIgBEEEaiIFNgIIAkACQAJAAkACQCAHIANBP3GtiKdBB3EiA0UEQCACIARBB2oiAzYCCCAHIAVBP3GtiKdBB3EiBQ4CAgEDCyABIANBEWo2AgAMAwtBcyEBIAZFDQMgAiAEQQhqNgIIIAcgA0E/ca2Ip0EBcQ0DIABBAToAAAwCCyABQRE2AgAMAQsgASAFQQhyNgIAC0EBIQELIAEL4gECAX8BfiMAQTBrIgUkAAJAIAEEQCABKAIADQEgAUF/NgIAIAVBEGogAUEIaiACBH8gBSADNgIoIAUgAjYCJCAFIAM2AiAgBUEIaiAFQSBqEJ8GIAUoAgwhAiAFKAIIBUEACyACIAQQgAEgAUEANgIAIAUoAhAhAQJ/IAUoAhwiAgRAIAUpAhQhBiAFIAI2AiwgBSAGNwIkIAUgATYCICAFQSBqEIwGIQFBACEDQQAMAQtBASEDIAELIQIgACADNgIIIAAgAjYCBCAAIAE2AgAgBUEwaiQADwsQkgcACxCTBwAL8wECAX8BfiMAQSBrIgYkAAJAAkACQAJAQYCACEGAgAIgAxsgBBCyBiIEIARBqtUqcSADckV0IgNBgQhPBEAgAigCACEBIAMgAigCBCIESw0BDAILIAUgAzYCAEGACCEEIANFDQMMAgsgBARAIAEQUgsgBkEIaiADEOQDIAYpAwghByAGIAM2AhggBiAHNwMQIAYgBkEQahCPBSAGKAIAIQEgAiAGKAIEIgQ2AgQgAiABNgIACyAFIAM2AgAgAyAETQ0AIAMgBEG85sAAEIcHAAsgAUEAIANBAnQQowcaCyAAIAQ2AgQgACABNgIAIAZBIGokAAv1AQICfwJ+IwBBEGsiBCQAAkACQAJAAkACQCABKAIIIgUgASgCBEkEQCABKAIAIAVqLQAAIgVBLkYNAiAFQcUARiAFQeUARnINAQtCASEGIAIEQCADIQcMBAtCACEGQgAgA30iB0IAUwRAQgIhBgwECyADur1CgICAgICAgICAf4UhBwwDCyAEIAEgAiADQQAQ6wEgBCgCAEUNASAAIAQoAgQ2AgggAEIDNwMADAMLIAQgASACIANBABDiASAEKAIARQ0AIAAgBCgCBDYCCCAAQgM3AwAMAgsgBCkDCCEHCyAAIAc3AwggACAGNwMACyAEQRBqJAALcwAgAwJ/IABBwrABTwRAIAEtAD8gAjMBfiAEIAUgBhD0AkEYIACtQr7PfnwgBCAFIAYQ9AJBPwwBCyABLQA+IAIzAXwgBCAFIAYQ9AJBDiAArUK+T3wgBCAFIAYQ9AJBPgtBAnRqIgAgACgCAEEBajYCAAv/AQMBfwF+AXwjAEEgayICJAACQAJAAkACQCABKAIAQQFrDgIBAgALIAErAwghBCACQQM6AAggAiAEOQMQIAJBCGogAkEYakHUm8AAEJ4DIQEgAEEBNgIAIAAgATYCBAwCCyAAAn8gASkDCCIDQoCAgIAIWgRAIAJBAToACCACIAM3AxAgACACQQhqIAJBGGoQrgQ2AgRBAQwBCyAAIAM+AgRBAAs2AgAMAQsgAAJ/IAEpAwgiA0KAgICACHxCgICAgBBaBEAgAkECOgAIIAIgAzcDECAAIAJBCGogAkEYahCuBDYCBEEBDAELIAAgAz4CBEEACzYCAAsgAkEgaiQAC+kBAQR/IwBBEGsiBSQAAkAgAigCACIHQQN2IgYgBE0EQCAEIAZHBEAgAyAGaiIDLQAAIQggBSABIAdBB3GthiIBQjiIPAAPIAUgAUIwiDwADiAFIAFCKIg8AA0gBSABQiCIPAAMIAUgAUIYiDwACyAFIAFCEIg8AAogBSABQgiIPAAJIAUgCCABp3I6AAggBCAGa0EHTQ0CIANBCCAFQQhqQQhBiNriABDCBiACIAAgB2o2AgAgBUEQaiQADwtBAEEAQZTk4gAQvAQACyAGIARBhOTiABCGBwALQbjY4gBBI0H42eIAELgFAAviAQEGfyMAQRBrIgUkAAJAAkAgAEEgaigCACIIRQRAAkAgAUUgAkGAEEtyRQRAIAJFDQFBACEBIAQhBgNAIAEgBEsNBCABIANqIAYQjQQhByAFIAAQmAcgB0ECaiIJIAUoAgQiCksNBSAFKAIAIAdBAnRqQgA3AgAgBkF/aiEGIAIgAUEBaiIBRw0ACwwBCyAFQQhqIAAQmAcgBSgCDCIBRQ0AIAUoAghBACABQQJ0EKMHGgsgAEEBNgIgCyAFQRBqJAAgCEUPCyABIARBzIXAABCGBwALIAkgCkHchcAAEIcHAAvmAQEFfwJAAkACQCAAQUBrKAIAIghFBEACQCABRSAAKAIMIgFBBnYgAklyRQRAIAJFDQEgAEEcaigCACEGIAAoAhghCSAEIQVBACEBA0AgASAESw0FIAAgASADaiAFEN8EIgcgBk8NBiAJIAdBAXRqQQA7AQAgBUF/aiEFIAIgAUEBaiIBRw0ACwwBCyABIABBHGooAgAiAksNAiABRQ0AIAAoAhhBACABQQF0EKMHGgsgAEEBNgJACyAIRQ8LIAEgAkHUjsAAEIcHAAsgASAEQbSOwAAQhgcACyAHIAZBxI7AABC8BAAL4AEBBX8jAEEQayIFJAACQAJAIABBIGooAgAiCEUEQAJAIAFFIAJBgBBLckUEQCACRQ0BIAQhBkEAIQEDQCABIARLDQQgASADaiAGEI0EIQcgBSAAEJgHIAcgBSgCBCIJTw0FIAUoAgAgB0ECdGpBADYCACAGQX9qIQYgAiABQQFqIgFHDQALDAELIAVBCGogABCYByAFKAIMIgFFDQAgBSgCCEEAIAFBAnQQowcaCyAAQQE2AiALIAVBEGokACAIRQ8LIAEgBEHMhcAAEIYHAAsgB0EBaiAJQdyFwAAQhwcAC90BAQF/IwBB4ABrIgckAAJAIAAoAgAEQCAEIAAgBEUgBkEAR3EgBSACIAMQ9gFFcg0BIAAQswRCADcCHAwBCyABEPEBIAdBCGogARCOASAAEMwBIAAgB0EIakHYABClByEAIAdBGGoiAiABQTBqKQIANwMAIAdBEGoiAyABQShqKQIANwMAIAcgASkCIDcDCCAAELMEIgFBEGogAikDADcCACABQQhqIAMpAwA3AgAgASAHKQMINwIAIAAoAgAEQCAAELMEQQA2AhgLIAAQswRBATYCGAsgB0HgAGokAAvxAQEGfyMAQRBrIgQkACAEQQA2AggCQAJAAkAgAUEDSwRAIARBCGpBBCAAQQRB8IDjABDCBiAELQALIQYgBC0ACiEHIAQtAAkhCCAELQAIIQkgBEEANgIMIANBA00NASAEQQxqQQQgAkEEQfCA4wAQwgYgBCgCDCAIQQh0IAlyIAdBEHRyIAZBGHRyRgRAIAFBBUkNAyADQQRNDQQgAC0ABCACLQAERiEFCyAEQRBqJAAgBQ8LQeD/4gBBI0HggOMAELgFAAtB4P/iAEEjQeCA4wAQuAUAC0EEQQRBhIbjABC8BAALQQRBBEGUhuMAELwEAAvvAQEBfyMAQRBrIgUkAAJAAkACQCADIARxIgMgAk0EQCAFQQA2AgwgAiADa0EDTQ0BIAVBDGpBBCABIANqQQRB9I/AABDCBiAFKAIMQb3P1vEBbEERdiIBIAAoAgQiAk8NAiAAKAIAIAFBAXRqIgItAAAgBSAAQQhqEJgHIAFBCHRyIgAgBSgCBCIBSQ0DIAAgAUGMg8AAELwEAAtB5I7AAEEjQeyCwAAQuAUAC0HkjsAAQSNB5I/AABC4BQALIAEgAkH8gsAAELwEAAsgBSgCACAAQQJ0aiAENgIAIAIgAi8BAEEBajsBACAFQRBqJAAL8AECAX8BfiMAQSBrIgIkACAAAn8CQAJAAkACQAJAAkACQCABLQAAQQFrDgYBAgMEBQYACyAAIAEpAgQ3AgRBAAwGCyAAIAEpAgQ3AgRBAQwFCyACQQhqIAFBBGoQ8gYgAikDCCEDIABBDGogAUEQai0AADoAACAAIAM3AgRBAgwECyAAIAEtAAE6AAFBAwwDCyAAIAEvAAE7AAFBBAwCCyAAIAEtAAE6AAFBBQwBCyACQRhqIAFBBGoQ8gYgAikDGCEDIAJBEGogAUEQahDyBiAAQQxqIAIpAxA3AgAgACADNwIEQQYLOgAAIAJBIGokAAvTAQEIfyMAQRBrIgUkACABIAJBB3FqLQAAIQYgASACQX9qQQdxai0AACEHIAEgAkEGakEHcWotAAAhCCABIAJBBWpBB3FqLQAAIQkgASACQQRqQQdxai0AACEKIAEgAkEDakEHcWotAAAhCyABIAJBAmpBB3FqLQAAIQwgBSABIAJBAWpBB3FqLQAAOgAPIAUgDDoADiAFIAs6AA0gBSAKOgAMIAUgCToACyAFIAg6AAogBSAHOgAJIAUgBjoACCAAIAVBCGogAyAEENwBIAVBEGokAAuxAQEDfyAAEPcDIABBlA5qKAIAIAAoApAOIQIgAEIBNwOQDgRAIAIQUgsgAEGkD2ooAgAgAEGgD2oiAigCACEDIAJCAjcDAARAIAMQUgsgAEGsD2ooAgAgAEGoD2oiAigCACEDIAJCAjcDAARAIAMQUgsgAEHsDmooAgAgACgC6A4hAiAAQgI3A+gOBEAgAhBSCyAAQfQOaigCACAAKALwDiECIABCATcD8A4EQCACEFILC9gBAgR/AX4jAEGAAWsiAyQAIAApAwAhBkGAASEAIANBgAFqIQQCQAJAA0AgAEUEQEEAIQAMAwsgBEF/akEwQdcAIAanIgJBD3EiBUEKSRsgBWo6AAAgBkIQWgRAIARBfmoiBEEwQdcAIAJB/wFxIgJBoAFJGyACQQR2ajoAACAAQX5qIQAgBkKAAlQgBkIIiCEGRQ0BDAILCyAAQX9qIQALIABBgQFJDQAgAEGAAUGo9+sAEIYHAAsgAUEBQbj36wBBAiAAIANqQYABIABrEIoBIANBgAFqJAAL1gECBH8BfiMAQYABayIDJAAgACkDACEGQYABIQAgA0GAAWohBAJAAkADQCAARQRAQQAhAAwDCyAEQX9qQTBBNyAGpyICQQ9xIgVBCkkbIAVqOgAAIAZCEFoEQCAEQX5qIgRBMEE3IAJB/wFxIgJBoAFJGyACQQR2ajoAACAAQX5qIQAgBkKAAlQgBkIIiCEGRQ0BDAILCyAAQX9qIQALIABBgQFJDQAgAEGAAUGo9+sAEIYHAAsgAUEBQbj36wBBAiAAIANqQYABIABrEIoBIANBgAFqJAAL3gEBAX8jAEEQayIFJAACQAJAAkAgAyAEcSIDIAJNBEAgASADaiACIANrELAFIgEgACgCBCICTw0BIAAoAgAgAUEBdGovAQAgBUEIaiAAQQhqEJgHQT9xIAFBBnRyIgIgBSgCDCIDTw0CIAUoAgggAkECdGogBDYCACABIAAoAgQiAkkNAyABIAJBpI7AABC8BAALQeSOwABBI0H0jcAAELgFAAsgASACQYSOwAAQvAQACyACIANBlI7AABC8BAALIAAoAgAgAUEBdGoiACAALwEAQQFqOwEAIAVBEGokAAveAQEBfyMAQRBrIgUkAAJAAkACQCADIARxIgMgAk0EQCABIANqIAIgA2sQsQUiASAAKAIEIgJPDQEgACgCACABQQF0ai8BACAFQQhqIABBCGoQmAdBD3EgAUEEdHIiAiAFKAIMIgNPDQIgBSgCCCACQQJ0aiAENgIAIAEgACgCBCICSQ0DIAEgAkGkjsAAELwEAAtB5I7AAEEjQfSNwAAQuAUACyABIAJBhI7AABC8BAALIAIgA0GUjsAAELwEAAsgACgCACABQQF0aiIAIAAvAQBBAWo7AQAgBUEQaiQAC8wBACAAAn8gAUGAAU8EQCABQYAQTwRAIAFBgIAETwRAIAIgAUE/cUGAAXI6AAMgAiABQQZ2QT9xQYABcjoAAiACIAFBDHZBP3FBgAFyOgABIAIgAUESdkEHcUHwAXI6AABBBAwDCyACIAFBP3FBgAFyOgACIAIgAUEMdkHgAXI6AAAgAiABQQZ2QT9xQYABcjoAAUEDDAILIAIgAUE/cUGAAXI6AAEgAiABQQZ2QcABcjoAAEECDAELIAIgAToAAEEBCzYCBCAAIAI2AgAL1wEBBX8jAEEgayIDJAAgAyABQf8BcSIENgIEIARFBEADQAJAAkAgBSABTQRAIAEgBWtBD00NASACQQFqIQQgAkECdEEEaiEGQQAhAgNAIAAgAmogBjsBACACQQJqIgJBIEcNAAsgBUEQaiEFIARBEEcNAkEAIQQgASAFRw0CIANBIGokAA8LQdSO4wBBI0HwkOMAELgFAAtB1I7jAEEjQYCR4wAQuAUACyAAQSBqIQAgBCECDAALAAsgA0EANgIQIANBBGpB3JDjACADQQhqQeCQ4wAQ8QQAC+8BAQF/AkACQAJAAkACQAJAAkACQCACIANNBEAgASADSQ0CIAEgA2siASAESQ0DIAIgBGoiASAESQ0EIAEgA00NASABIANBzNfjABCHBwALIAEgAkkNBCADIARqIgUgBEkNBSAFIAJLDQYgASACayIBIARJDQcLIAAgAmogACADaiAEEKUHGg8LQcid4wBBI0Gs1+MAELgFAAsgBCABQbzX4wAQhwcACyACIAFBzNfjABCIBwALQcid4wBBI0H81uMAELgFAAsgAyAFQYzX4wAQiAcACyAFIAJBjNfjABCHBwALIAQgAUGc1+MAEIcHAAvmAQEFfyMAQSBrIgMkAAJAIAEoAgAiByACTwRAQYGAgIB4IQQgB0UNASABKAIEIQZBASEFAkAgAgRAAkAgAkF/TARAIAJBARDpBiIFDQFBACEEDAULQQEhBCAGIAdBASACEN4GIgUNAgwECyAFIAYgAhClBxoLIAYQUgsgASACNgIAIAEgBTYCBEGBgICAeCEEDAELIANBFGpBATYCACADQRxqQQA2AgAgA0GYl8AANgIQIANB9JbAADYCGCADQQA2AgggA0EIakHsl8AAEI8GAAsgACAENgIEIAAgAjYCACADQSBqJAALzwEBBH8jAEEgayIEJAAgAAJ/QQAgAiADaiIDIAJJDQAaIAEoAgAiAkEBdCIFIAMgBSADSxsiA0EEIANBBEsbIgVBFGwhAyAFQefMmTNJQQJ0IQYCQCACBEAgASgCBCEHIARBBDYCGCAEIAJBFGw2AhQgBCAHNgIQDAELIARBADYCGAsgBCADIAYgBEEQahDRAyAEKAIEIQMgBCgCAARAIARBCGooAgAMAQsgASAFNgIAIAEgAzYCBEGBgICAeAs2AgQgACADNgIAIARBIGokAAvQAQEEfyMAQSBrIgQkACAAAn9BACACIANqIgMgAkkNABogASgCACICQQF0IgUgAyAFIANLGyIDQQEgA0EBSxsiBUGIFmwhAyAFQfm0LklBAnQhBgJAIAIEQCABKAIEIQcgBEEENgIYIAQgAkGIFmw2AhQgBCAHNgIQDAELIARBADYCGAsgBCADIAYgBEEQahDRAyAEKAIEIQMgBCgCAARAIARBCGooAgAMAQsgASAFNgIAIAEgAzYCBEGBgICAeAs2AgQgACADNgIAIARBIGokAAvRAQEEfyMAQSBrIgQkACAAAn9BACACIANqIgMgAkkNABogASgCACICQQF0IgUgAyAFIANLGyIDQQEgA0EBSxsiBUGICGwhAyAFQYCB/wBJQQJ0IQYCQCACBEAgASgCBCEHIARBBDYCGCAEIAJBiAhsNgIUIAQgBzYCEAwBCyAEQQA2AhgLIAQgAyAGIARBEGoQ0QMgBCgCBCEDIAQoAgAEQCAEQQhqKAIADAELIAEgBTYCACABIAM2AgRBgYCAgHgLNgIEIAAgAzYCACAEQSBqJAAL0AEBBH8jAEEgayIEJAAgAAJ/QQAgAiADaiIDIAJJDQAaIAEoAgAiAkEBdCIFIAMgBSADSxsiA0EBIANBAUsbIgVBiBFsIQMgBUHxgTxJQQJ0IQYCQCACBEAgASgCBCEHIARBBDYCGCAEIAJBiBFsNgIUIAQgBzYCEAwBCyAEQQA2AhgLIAQgAyAGIARBEGoQ0QMgBCgCBCEDIAQoAgAEQCAEQQhqKAIADAELIAEgBTYCACABIAM2AgRBgYCAgHgLNgIEIAAgAzYCACAEQSBqJAALzwEBBH8jAEEgayIEJAAgAAJ/QQAgAiADaiIDIAJJDQAaIAEoAgAiAkEBdCIFIAMgBSADSxsiA0EEIANBBEsbIgVBBXQhAyAFQYCAgCBJQQJ0IQYCQCACBEAgASgCBCEHIARBBDYCGCAEIAJBBXQ2AhQgBCAHNgIQDAELIARBADYCGAsgBCADIAYgBEEQahDRAyAEKAIEIQMgBCgCAARAIARBCGooAgAMAQsgASAFNgIAIAEgAzYCBEGBgICAeAs2AgQgACADNgIAIARBIGokAAvQAQEEfyMAQSBrIgQkACAAAn9BACACIANqIgMgAkkNABogASgCACICQQF0IgUgAyAFIANLGyIDQQQgA0EESxsiBUEDdCEDIAVBgICAgAFJQQJ0IQYCQCACBEAgASgCBCEHIARBBDYCGCAEIAJBA3Q2AhQgBCAHNgIQDAELIARBADYCGAsgBCADIAYgBEEQahDRAyAEKAIEIQMgBCgCAARAIARBCGooAgAMAQsgASAFNgIAIAEgAzYCBEGBgICAeAs2AgQgACADNgIAIARBIGokAAvPAQEEfyMAQSBrIgQkACAAAn9BACACIANqIgMgAkkNABogASgCACICQQF0IgUgAyAFIANLGyIDQQQgA0EESxsiBUEFdCEDIAVBgICAIElBAXQhBgJAIAIEQCABKAIEIQcgBEECNgIYIAQgAkEFdDYCFCAEIAc2AhAMAQsgBEEANgIYCyAEIAMgBiAEQRBqENEDIAQoAgQhAyAEKAIABEAgBEEIaigCAAwBCyABIAU2AgAgASADNgIEQYGAgIB4CzYCBCAAIAM2AgAgBEEgaiQAC+wBAQJ/IwBBIGsiASQAAkACQAJAAkACQAJAQeGT7AAtAABBAWsOAwIEAQALQeGT7ABBAjoAACABQeGT7AA2AgggACgCACIALQAAIABBADoAAEEBcUUNAhDRAiABQQM6AAwgAUEIaiIAKAIAIAAtAAQ6AAALIAFBIGokAA8LIAFBFGpBATYCACABQRxqQQA2AgAgAUHoocAANgIQDAILQfChwABBK0HoosAAELgFAAsgAUEUakEBNgIAIAFBHGpBADYCACABQbShwAA2AhALIAFB8J/AADYCGCABQQA2AgggAUEIakHUoMAAEI8GAAvmAQEFfyMAQSBrIgMkAAJAIAEoAgAiByACTwRAQYGAgIB4IQQgB0UNASABKAIEIQZBASEFAkAgAgRAAkAgAkF/TARAIAJBARDpBiIFDQFBACEEDAULQQEhBCAGIAdBASACEN4GIgUNAgwECyAFIAYgAhClBxoLIAYQUgsgASACNgIAIAEgBTYCBEGBgICAeCEEDAELIANBFGpBATYCACADQRxqQQA2AgAgA0GYqsEANgIQIANB9KnBADYCGCADQQA2AgggA0EIakHsqsEAEI8GAAsgACAENgIEIAAgAjYCACADQSBqJAAL3AEBA38jAEEQayIEJAAgACACNgIEIAAgATYCAAJ/IAAtAFZFBEBBASABQRpqdCACakF/IAFBAmp0aiEFQRgMAQsgBEKMgICAwAM3AgggBEKAgICAwAA3AgACQCABQQNNBEAgBCABQQJ0aigCACIDIAJLBEAgAiADa0H8//8/aiEFDAILQfz//z8hBSADQQEgAXRqIAJLDQEgAiADa0H8////BWohBQwBCyABQQRBoJvjABC8BAALQT4LIQMgACAFNgIMIAAgAiADIAFBAWp0akEQajYCCCAEQRBqJAAL5gEBBX8jAEEgayIDJAACQCABKAIAIgcgAk8EQEGBgICAeCEEIAdFDQEgASgCBCEGQQEhBQJAIAIEQAJAIAJBf0wEQCACQQEQ6QYiBQ0BQQAhBAwFC0EBIQQgBiAHQQEgAhDeBiIFDQIMBAsgBSAGIAIQpQcaCyAGEFILIAEgAjYCACABIAU2AgRBgYCAgHghBAwBCyADQRRqQQE2AgAgA0EcakEANgIAIANB4KvrADYCECADQbyr6wA2AhggA0EANgIIIANBCGpBtKzrABCPBgALIAAgBDYCBCAAIAI2AgAgA0Eg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IAU2AgRBgYCAgHghBgsgACAGNgIEIAAgBDYCACADQSBqJAALwQEBAX8jAEEwayICJAAgASgCBARAIAJBDGogAUEIaigAADYAACACIAEpAAA3AAQgAkEYaiACQQhqKQAANwAAIAJBAjoAECACIAIpAAE3ABEgAkEAOgAgIAAgAkEQahDLAQsgAUEMaiIBKAIEBEAgAkEMaiABQQhqKAAANgAAIAIgASkAADcABCACQRhqIAJBCGopAAA3AAAgAkECOgAQIAIgAikAATcAESACQQA6ACAgACACQRBqEMsBCyACQTBqJAALwQEBAX8jAEEwayICJAAgASgCBARAIAJBDGogAUEIaigAADYAACACIAEpAAA3AAQgAkEYaiACQQhqKQAANwAAIAJBAjoAECACIAIpAAE3ABEgAkEBOgAgIAAgAkEQahDLAQsgAUEMaiIBKAIEBEAgAkEMaiABQQhqKAAANgAAIAIgASkAADcABCACQRhqIAJBCGopAAA3AAAgAkECOgAQIAIgAikAATcAESACQQE6ACAgACACQRBqEMsBCyACQTBqJAALwQEBAX8jAEEwayICJAAgASgCBARAIAJBDGogAUEIaigAADYAACACIAEpAAA3AAQgAkEYaiACQQhqKQAANwAAIAJBAjoAECACIAIpAAE3ABEgAkEAOgAgIAAgAkEQahDNAQsgAUEMaiIBKAIEBEAgAkEMaiABQQhqKAAANgAAIAIgASkAADcABCACQRhqIAJBCGopAAA3AAAgAkECOgAQIAIgAikAATcAESACQQA6ACAgACACQRBqEM0BCyACQTBqJAALwQEBAX8jAEEwayICJAAgASgCBARAIAJBDGogAUEIaigAADYAACACIAEpAAA3AAQgAkEYaiACQQhqKQAANwAAIAJBAjoAECACIAIpAAE3ABEgAkEBOgAgIAAgAkEQahDNAQsgAUEMaiIBKAIEBEAgAkEMaiABQQhqKAAANgAAIAIgASkAADcABCACQRhqIAJBCGopAAA3AAAgAkECOgAQIAIgAikAATcAESACQQE6ACAgACACQRBqEM0BCyACQTBqJAALwQEBAX8jAEEwayICJAAgASgCBARAIAJBDGogAUEIaigAADYAACACIAEpAAA3AAQgAkEYaiACQQhqKQAANwAAIAJBAjoAECACIAIpAAE3ABEgAkEA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NgKACCAEQYgIaiEEIAVBf2oiBQ0ACyABIANqQX9qIQMLIAAgAQR/IAQgAkGICBClBxogA0EBagUgAws2AggLqgEBA38jAEEwayICJAAgASgCBEUEQCABKAIMIQMgAkEQaiIEQQA2AgAgAkKAgICAEDcDCCACIAJBCGo2AhQgAkEoaiADQRBqKQIANwMAIAJBIGogA0EIaikCADcDACACIAMpAgA3AxggAkEUakG0wusAIAJBGGoQqwEaIAFBCGogBCgCADYCACABIAIpAwg3AgALIABBjM3rADYCBCAAIAE2AgAgAkEwaiQAC58BAQF/AkAgA0EDdiIHIAZJBEAgBCADNgIAIAUgB2oiByAHLQAAQX8gA0EHcXRBf3NxOgAAIAJBASAEIAUgBhCUBSAFIAYgBCgCAEEHaiIDQQN2IAAgASACEMMEIAQgA0F4cSACQQN0aiIANgIAIABBA3YiACAGSQ0BIAAgBkH0h+MAELwEAAsgByAGQeSH4wAQvAQACyAAIAVqQQA6AAALpgECAn8BfgJAAkAgACgCCCIDQSBPBEAgACADQSBzNgIIIAAoAgwiBEEEaiEDIARBe0sNASADIAJLDQIgACkDACEFIAAgAzYCDCAAIAAoAhBBfGo2AhAgACABIARqIgAxAAFCKIYgADEAAEIghiAFQiCIhIQgADEAAkIwhoQgADEAA0I4hoQ3AwALDwsgBCADQfi56wAQiAcACyADIAJB+LnrABCHBwALqQEBAX8jAEEgayIEJAAgASADRgRAIAEEQANAIAAgAkGAFhClByIAQYQWaiACQYQWaioCADgCACAAQYAWaiACQYAWaigCADYCACAAQYgWaiEAIAJBiBZqIQIgAUF/aiIBDQALCyAEQSBqJAAPCyAEQRRqQQE2AgAgBEEcakEANgIAIARBmJzAADYCECAEQdSbwAA2AhggBEEANgIIIARBCGpBzNfAABCPBgALqQEBAX8jAEEgayIEJAAgASADRgRAIAEEQANAIAAgAkGACBClByIAQYQIaiACQYQIaioCADgCACAAQYAIaiACQYAIaigCADYCACAAQYgIaiEAIAJBiAhqIQIgAUF/aiIBDQALCyAEQSBqJAAPCyAEQRRqQQE2AgAgBEEcakEANgIAIARBmJzAADYCECAEQdSbwAA2AhggBEEANgIIIARBCGpBzNfAABCPBgALqAEBBH8jAEEQayICJAACQAJAIAAgACgCCCIBBH8gAQUgACAAKAIAQQFqIgE2AgAgAkEIaiAAKAIMIgMQmAcgASACKAIMIgRPDQIgACACKAIIIAFqLQAANgIEIAIgA0EIahCYByABIAIoAgQiA08NASACKAIAIAFBAnRqKAIAC0F/ajYCCCACQRBqJAAPCyABIANB0J3AABC8BAALIAEgBEHAncAAELwEAAuwAQAgAAJ/AkACQAJAAkACQAJAAkAgAS0AAEEBaw4GAQIDBAUGAAsgACABKQIENwIEQQAMBgsgACABKQIENwIEQQEMBQsgACABKQIENwIEIABBDGogAUEMai0AADoAAEECDAQLIAAgAS0AAToAAUEDDAMLIAAgAS8AATsAAUEEDAILIAAgAS0AAToAAUEFDAELIAAgASkCBDcCBCAAQQxqIAFBDGopAgA3AgBBBgs6AAALoAEBAn8jAEHAM2siAiQAIAJBsBFqEPEGIAJBKGogAkGwEWoQywYgAkEQaiABEN4DIAJBIGoiA0EANgIAIAIgAikDEDcDGCACQbgiaiACQShqQYgREKUHGiACQRhqIAEgAkG4ImoQ2wMgAkHAImogAygCADYCACACIAIpAxg3A7giIAJBCGogAkG4ImoQjQUgACACKQMINwMAIAJBwDNqJAALmgEBBn8jAEEQayICJAACfwJAAkAgACgCCCIBIAAoAgQiA0kEQCAAKAIAIQQDQCABIARqLQAAIgVBd2oiBkEXS0EBIAZ0QZOAgARxRXINAiAAIAFBAWoiATYCCCABIANHDQALCyACQQM2AgAMAQsgBUE6RgRAIAAgAUEBajYCCEEADAILIAJBBjYCAAsgACACEMwECyACQRBqJAALkwEBB38jAEEQayIEJAAgACgCCCIDIAAoAgQiBSADIAVLGyEGIAAoAgAhBwJ/AkADQEEAIAJFDQIaIAMgBkYEQCAEQQU2AgAMAgsgACADQQFqIgU2AgggAkF/aiECIAMgB2ohCCABLQAAIAUhAyABQQFqIQEgCC0AAEYNAAsgBEEJNgIACyAAIAQQkwULIARBEGokAAujAQICfwF+IAQoAgQhBQJAAkAgBCgCACIGIAMoAgBGBEAgAygCBCAFRg0BCyABIAJJDQEgAkUNACACQQR0IQQgBq0hBwNAAkAgAEEEaigCAEH///8PcUUNACAAQQxqLwEAQf8ATQ0AIAAgAxDUBCAFIAcgAEEOaiAAQQhqENMDCyAAQRBqIQAgBEFwaiIEDQALCw8LQYiV4wBBI0Gwm+MAELgFAAukAQEEfyAAKALwDyEBIAAoAqgQIgJFBEAgAEEBNgKEECAAIAFBf2oiATYC8A8gACAAIAFBA3FBAnRqQeANaigCADYCqBAPC0GAyv5SIAJBAXQiBHZBA3EhAyAAQZv+v9V6IAR1IAFqQQNxQQJ0akHgDWooAgAhASACQQFxRQRAIABB/////wcgASADayIAIABBAUgbNgKoEA8LIAAgASADajYCqBALfwECfyAAQfwOaigCACAAKAL4DiECIABCATcD+A4EQCACEFILIABBhA9qKAIAIAAoAoAPIQIgAEIBNwOADwRAIAIQUgsgAEHkDmooAgAgACgC4A4hAiAAQgE3A+AOBEAgAhBSCyAAQZgOahCoBSAAQbAOahCoBSAAQcgOahCoBQuTAQEDfyMAQYABayIDJAAgAC8BACECQQAhAANAIAAgA2pB/wBqQTBB1wAgAkEPcSIEQQpJGyAEajoAACAAQX9qIQAgAiIEQQR2IQIgBEEPSw0ACyAAQYABaiICQYEBTwRAIAJBgAFBqPfrABCGBwALIAFBAUG49+sAQQIgACADakGAAWpBACAAaxCKASADQYABaiQAC5IBAQN/IwBBgAFrIgMkACAALQAAIQJBACEAA0AgACADakH/AGpBMEE3IAJBD3EiBEEKSRsgBGo6AAAgAEF/aiEAIAIiBEEEdiECIARBD0sNAAsgAEGAAWoiAkGBAU8EQCACQYABQaj36wAQhgcACyABQQFBuPfrAEECIAAgA2pBgAFqQQAgAGsQigEgA0GAAWokAAuTAQEDfyMAQYABayIDJAAgAC0AACECQQAhAANAIAAgA2pB/wBqQTBB1wAgAkEPcSIEQQpJGyAEajoAACAAQX9qIQAgAiIEQQR2IQIgBEEPSw0ACyAAQYABaiICQYEBTwRAIAJBgAFBqPfrABCGBwALIAFBAUG49+sAQQIgACADakGAAWpBACAAaxCKASADQYABaiQAC5IBAQN/IwBBgAFrIgMkACAALwEAIQJBACEAA0AgACADakH/AGpBMEE3IAJBD3EiBEEKSRsgBGo6AAAgAEF/aiEAIAIiBEEEdiECIARBD0sNAAsgAEGAAWoiAkGBAU8EQCACQYABQaj36wAQhgcACyABQQFBuPfrAEECIAAgA2pBgAFqQQAgAGsQigEgA0GAAWokAAu1AQEDfyMAQRBrIgEkACAAKAIAIgJBFGooAgAhAwJAAn8CQAJAIAJBDGooAgAOAgABAwsgAw0CQQAhAkHMwusADAELIAMNASACKAIIIgMoAgQhAiADKAIACyEDIAEgAjYCBCABIAM2AgAgAUHAzesAIAAoAgQiASgCCCAAKAIIIAEtABAQpwMACyABQQA2AgQgASACNgIMIAFBrM3rACAAKAIEIgEoAgggACgCCCABLQAQEKcDAAuNAQEDfyMAQYABayIDJAAgACgCACEAA0AgAiADakH/AGpBMEHXACAAQQ9xIgRBCkkbIARqOgAAIAJBf2ohAiAAQQ9LIABBBHYhAA0ACyACQYABaiIAQYEBTwRAIABBgAFBqPfrABCGBwALIAFBAUG49+sAQQIgAiADakGAAWpBACACaxCKASADQYABaiQAC4wBAQN/IwBBgAFrIgMkACAAKAIAIQADQCACIANqQf8AakEwQTcgAEEPcSIEQQpJGyAEajoAACACQX9qIQIgAEEPSyAAQQR2IQANAAsgAkGAAWoiAEGBAU8EQCAAQYABQaj36wAQhgcACyABQQFBuPfrAEECIAIgA2pBgAFqQQAgAmsQigEgA0GAAWokAAuSAQEDfyMAQUBqIgIkACACQQhqIAEQ5gMgAkEYaiIDQQA2AgAgAiACKQMINwMQIAJBOGpCADcDACACQTBqQgA3AwAgAkEoaiIEQgA3AwAgAkIANwMgIAJBEGogASACQSBqEOwCIAQgAygCADYCACACIAIpAxA3AyAgAiACQSBqEJIFIAAgAikDADcDACACQUBrJAALkgEBA38jAEFAaiICJAAgAkEIaiABEOgDIAJBGGoiA0EANgIAIAIgAikDCDcDECACQThqQgA3AwAgAkEwakIANwMAIAJBKGoiBEIANwMAIAJCADcDICACQRBqIAEgAkEgahDtAiAEIAMoAgA2AgAgAiACKQMQNwMgIAIgAkEgahCJBSAAIAIpAwA3AwAgAkFAayQAC6IBAQJ/IwBBEGsiBSQAIAACfwJAIANFQQAgBBtFBEAgASgCCCIDIAEoAgQiBE8NASABKAIAIQYDQCADIAZq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9+maHn5CMIinC5MBAgF/BX4jAEEQayICJAAgAkIANwMIIAFBB00EQEHkjsAAQSNBhJDAABC4BQALIAJBCGpBCCAAQQhBlJDAABDCBiACMQAIIQMgAjEACSACMQAKIQUgAjEACyEGIAIxAAwhByACQRBqJABCIIYgA0IYhoQgBUIohoQgBkIwhoQgB0I4hoRCvc/W8dH36ZoefkIviKcLigEBAX8jAEEgayIDJAACQCAABEAgAyACNgIYIAMgATYCFCADIAI2AhAgA0EIaiADQRBqEJ8GIAAoAgANASADKAIMIQEgAygCCCECIABBfzYCACAAQQhqKAIABEAgACgCBBBSCyAAIAI2AgQgAEEANgIAIAAgATYCCCADQSBqJAAPCxCSBwALEJMHAAuPAQECfyMAQRBrIgckAAJAIANFDQAgB0EANgIMIARBGU0EQCABIARBAnQiAUGmpOMAai0AACAHQQxqIAUgBhDOBEUEQCAAQQE6AEQgACAENgI0DAILIABBADoARCACIAcoAgwgAUGkpOMAai8BAGo2AgBBASEIDAELIARBGkGMpeMAELwEAAsgB0EQaiQAIAgLjQEBAX8jAEEgayICJAAgASgCBARAIAJBEGpBADoAACACQQxqIAFBCGooAgA2AgAgAkECOgAAIAIgASkCADcCBCAAIAIQwgILIAFBDGoiASgCBARAIAJBEGpBADoAACACQQxqIAFBCGooAgA2AgAgAkECOgAAIAIgASkCADcCBCAAIAIQwgILIAJBIGokAAuNAQEBfyMAQSBrIgIkACABKAIEBEAgAkEQakEBOgAAIAJBDGogAUEIaigCADYCACACQQI6AAAgAiABKQIANwIEIAAgAhDCAgsgAUEMaiIBKAIEBEAgAkEQakEBOgAAIAJBDGogAUEIaigCADYCACACQQI6AAAgAiABKQIANwIEIAAgAhDCAgsgAkEgaiQAC40BAQJ/IwBBsAhrIgIkACACQRBqIAEQ4gMgAkEgaiIDQQA2AgAgAiACKQMQNwMYIAJBKGpBAEGECBCjBxogAkGj4P/7BzYCrAggAkEYaiABIAJBKGoQ6gMgAkEwaiADKAIANgIAIAIgAikDGDcDKCACQQhqIAJBKGoQiwUgACACKQMINwMAIAJBsAhqJAALjQEBAn8jAEGwFmsiAiQAIAJBEGogARDgAyAC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rAcgACgCBCECIAEoAgAhAyAAIAEoAgQ2AgQgACgCACAAIAM2AgAgAhDSBiABQRBqJAALdgEGfwJAIAEoAggiAiABKAIEIgRPDQAgASgCACEFQQEhAwNAIAIgBWotAAAiBkF3aiIHQRdLQQEgB3RBk4CABHFFcg0BIAEgAkEBaiICNgIIIAIgBEcNAAtBACEDCyAAIAM6AAEgAEEAOgAAIABBAmogBjoAAAuGAQECf0H06eIAIQUCQAJAAkACQAJAIAEoAgBBAWsOAgECAAsgASgCBCIBIANLDQIgAyABayEGIAEgAmohBQwBCyABKAIEIgFBEU8NAkEQIAFrIQYgASAEaiEFCyAAIAY2AgQgACAFNgIADwsgASADQdzq4gAQhgcACyABQRBBzOriABCGBwALdQEBfwJAAkACQCABRQRAQQEhASAAQXBqDgIDAQILIABBCHRBgP4AcUERciEEQQ4hAQwCC0EHIQFBASEEDAELIABBEUwEQCAAQQR0QYF/aiEEQQchAQwBCyAAQQF0QV9qIQRBBCEBCyADIAE6AAAgAiAEOwEAC48BAQN/AkACQAJAIAAtAJARBEAgAEGUDmooAgAiASAAKALoDyICSQ0BIAIgACgC2A8iA0kNAiABIAJrIANJDQMgACgCkA4iASABIAJqIAMQpQcaIABBADoAkBELDwtByJ3jAEEjQeyo4wAQuAUAC0HIneMAQSNB/KjjABC4BQALQcid4wBBI0GMqeMAELgFAAt3AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EUakECNgIAIANBHGpBAjYCACADQSxqQSc2AgAgA0HI9OsANgIQIANBADYCCCADQSc2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEI8GAAt3AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EUakECNgIAIANBHGpBAjYCACADQSxqQSc2AgAgA0Go++sANgIQIANBADYCCCADQSc2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEI8GAAt3AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EUakECNgIAIANBHGpBAjYCACADQSxqQSc2AgAgA0HI++sANgIQIANBADYCCCADQSc2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEI8GAAt3AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EUakECNgIAIANBHGpBAjYCACADQSxqQSc2AgAgA0H8++sANgIQIANBADYCCCADQSc2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEI8GAAt3AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EUakEDNgIAIANBHGpBAjYCACADQSxqQSc2AgAgA0HM/OsANgIQIANBADYCCCADQSc2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEI8GAAtjAQV/IwBBEGsiASQAIAFBCGoQqgcgACgCECABKAIMIQMgACABKAIINgIQIABBFGoiBCgCACAEIAM2AgAQ0gYgAEEcaigCACAAKAIYIQMgAEICNwIYBEAgAxBSCyABQRBqJAALdwEEfwJAAkAgASgCCCIFIAEoAgQiBk8NACABKAIAIQcDQCAFIAdqLQAAIghBUGpB/wFxQQpJBEAgASAFQQFqIgU2AgggBSAGRw0BDAILCyAIQSByQeUARg0BCyAAIAEgAiADIAQQ6AIPCyAAIAEgAiADIAQQ6wELeQEBfwJAAkACQCACIAVqIgYgBU8EQCAGIAFLDQEgBSIBIAVJDQIgASAESw0DIAAgAmogBSADIAVBxOTiABDCBg8LIAIgBkGk5OIAEIgHAAsgBiABQaTk4gAQhwcAC0EAIAFBtOTiABCIBwALIAEgBEG05OIAEIcHAAt2AQF/IwBBEGsiBSQAAkAgAyAEcSIDIAJNBEAgASADaiACIANrEI0EIQEgBUEIaiAAEJgHIAEgBSgCDCIASQ0BIAEgAEG8hcAAELwEAAtB5I7AAEEjQayFwAAQuAUACyAFKAIIIAFBAnRqIAQ2AgAgBUEQaiQAC3MBA38jAEEgayICJAAgAkEQakGAgAgQ1gUgAiACKQMQNwMYIAJBCGogAkEYahCYByACKAIMIgMEQCACKAIIIQQgA0ECdCEDA0AgBCABNgIAIARBBGohBCADQXxqIgMNAAsLIAAgAikDGDcDACACQSBqJAALZQEDfyABKAIAIgMoAgAhBAJAQYAgIAMoAgQiBUGAICAFSRsiAUEBRwRAIAIgASAEIAEQvQYMAQsgAiAELQAAOgAACyAAIAE2AgQgAEEEOgAAIAMgBSABazYCBCADIAEgBGo2AgALdAECfyMAQSBrIgIkACAAAn8gASgCCCIDIAEoAgRPBEAgAkEIaiABIAMQrwQgAigCDCEBIAIoAgghAyACQQQ2AhAgACACQRBqIAMgARDmBTYCBEEBDAELIAAgASgCACADai0AADoAAUEACzoAACACQSBqJAALWAEEfyAAQeQAaigCACAAKAJgIQIgAEIENwJgBEAgAhBSC0EAIQEDQCAAIAFqIgIoAgAhAyACQQRqKAIAIAJCAjcCAARAIAMQUgsgAUEIaiIBQcAARw0ACwtkAQJ/AkACfyAAKAI4IgFBAk8EQEEOIAFBBEgNARogACgCQCICDQIgACgCPCIAQRIgAEESSBtBECAAQRBKG0EQIAFBCEsbDwsgACgCPAsPCyACQRAgAkEQShsiAEEYIABBGEgbC2kBAn8jAEEwayICJAAgAkEIaiABEKYEIAJBGGoiA0EANgIAIAIgAikDCDcDECACQRBqIAEQhwQgAkEoaiADKAIANgIAIAIgAikDEDcDICACIAJBIGoQlgUgACACKQMANwMAIAJBMGokAAtrAQJ/IwBBMGsiAiQAIAJBCGogAUEAEIIFIAJBGGoiA0EANgIAIAIgAikDCDcDECACQRBqIAEQsQQgAkEoaiADKAIANgIAIAIgAikDEDcDICACIAJBIGoQjAUgACACKQMANwMAIAJBMGokAAtpAQJ/IwBBIGsiAiQAIAJBCGogACAAKAIEIgMgACgCCEEBaiIAIAMgAEkbEK8EIAIoAgwhACACKAIIIQMgAkEYaiABQQhqKAIANgIAIAIgASkCADcDECACQRBqIAMgABDmBSACQSBqJAALdwEBfyMAQRBrIgQkACAEQgA3AwAgBEEANgIIIARBADYCDEEBQgAgASACIAMQrQIgACAEIARBCGogBEEMahDHA0ECIAQ1AgwgASACIAMQrQIgBCgCCCAEKQMAIAEgAiADEK0CQQFCASABIAIgAxCtAiAEQRBqJAALcgECfwJAA0ACQEHAACAAKAIIIgVrIgYgAU8EQCABQSFPDQMgACABIAVqNgIIIAIgAUECdEH4t+sAaigCACAAKQMAIAVBP3GtiKdxNgIADAELIAAgAyAEEN4EDQELCyAGIAFPDwsgAUEh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IgIkACACQQhqQQ5BABCCBSACKAIIIQMgAigCDCABQQ4QpQchBEEMQQQQ6QYiAUUEQEEMQQQQoQcACyABQQ42AgggASAENgIEIAEgAzYCACAAQcipwQA2AgQgACABNgIAIAJBEGokAAtmAgF/AX4jAEEQayIEJAAgBEIANwMIIAFBB00EQEG42OIAQSNB2NniABC4BQALIARBCGpBCCAAQQhB6NniABDCBiAEKQMIIARBEGokACADQThsQThxrYZCvc/W8QF+IAJBP3GtiKcLYgEBfyACQQEgAyAEIAUQlAUgBCAFIAMoAgBBB2oiBkEDdiAAIAEgAhDDBCADIAZBeHEgAkEDdGoiADYCACAAQQN2IgAgBUkEQCAAIARqQQA6AAAPCyAAIAVB1OniABC8BAALaAECfwJAA0ACQEHAACAAKAIIIgVrIgYgAU8EQCABQSFPDQMgAiABQQJ0Qfi36wBqKAIAIAApAwAgBUE/ca2Ip3E2AgAMAQsgACADIAQQ3gQNAQsLIAYgAU8PCyABQSFB6LnrABC8BAALWQECfyMAQSBrIgIkACABKAIEIQMgASgCACACQRhqIAAoAgAiAEEQaikCADcDACACQRBqIABBCGopAgA3AwAgAiAAKQIANwMIIAMgAkEIahCrASACQSBqJAALYwEBfyMAQSBrIgQkACAEIAE2AgQgBCAANgIAIARBGGogAkEQaikCADcDACAEQRBqIAJBCGopAgA3AwAgBCACKQIANwMIQQAgBEGcssAAIARBBGpBnLLAACAEQQhqIAMQ5AEAC2MBAX8jAEEgayIEJAAgBCABNgIEIAQgADYCACAEQRhqIAJBEGopAgA3AwAgBEEQaiACQQhqKQIANwMAIAQgAikCADcDCEEAIARBrLLAACAEQQRqQayywAAgBEEIaiADEOQBAAtpAQF/IwBBIGsiAiQAIAJBoNPBADYCBCACIAA2AgAgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwhBACACQZDewQAgAkEEakGQ3sEAIAJBCGpBjNTBABDkAQALZgEBfyMAQSBrIgMkACADQcSR4wA2AgQgAyAANgIAIANBGGogAUEQaikCADcDACADQRBqIAFBCGopAgA3AwAgAyABKQIANwMIQQEgA0Gg3sEAIANBBGpBoN7BACADQQhqIAIQ5AEAC2MBAX8jAEEgayIEJAAgBCABNgIEIAQgADYCACAEQRhqIAJBEGopAgA3AwAgBEEQaiACQQhqKQIANwMAIAQgAikCADcDCEEAIARBsN7BACAEQQRqQbDewQAgBEEIaiADEOQBAAtjAQF/IwBBIGsiBCQAIAQgATYCBCAEIAA2AgAgBEEYaiACQRBqKQIANwMAIARBEGogAkEIaikCADcDACAEIAIpAgA3AwhBACAEQfzb4wAgBEEEakH82+MAIARBCGogAxDkAQALZgEBfyMAQSBrIgMkACADIAE2AgQgAyAANgIAIANBGGogAkEQaikCADcDACADQRBqIAJBCGopAgA3AwAgAyACKQIANwMIQQAgA0GM3OMAIANBBGpBjNzjACADQQhqQeza4wAQ5AEAC2kBAX8jAEEgayICJAAgAkHswusANgIEIAIgADYCACACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCEEAIAJB8MLrACACQQRqQfDC6wAgAkEIakGk0+sAEOQBAAtmAQF/IwBBIGsiAyQAIAMgATYCBCADIAA2AgAgA0EYaiACQRBqKQIANwMAIANBEGogAkEIaikCADcDACADIAIpAgA3AwhBACADQaz16wAgA0EEakGs9esAIANBCGpBmNzrABDkAQALXwECfyMAQRBrIgIkACACQQhqIABBCGoQmAcgAigCCCACKAIMIQAgAiABQQhqEJgHIAIoAgQiASAARwRAIAAgAUGchsEAEMAEAAsgAigCACAAQQJ0EKUHGiACQRBqJAALWgEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakGgqcEAIAJBCGoQqwEgAkEgaiQAC28AAkACQAJAAkAgAkH/AXFBAWsOAwEDAgALIABBP3EPCyAAQfwBcUECdg8LIAFB/wFxQZDB0gBqLQAAIABB/wFxQZDB0gBqLQAAQQN0ag8LIAFB/wFxQZDF0gBqLQAAIABB/wFxQZDD0gBqLQAAcgtaAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQbTC6wAgAkEIahCrASACQSBqJAALWgEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakH82esAIAJBCGoQqwEgAkEgaiQAC1QBAn8jAEEgayICJAAgASgCBCEDIAEoAgAgAkEYaiAAQRBqKQIANwMAIAJBEGogAEEIaikCADcDACACIAApAgA3AwggAyACQQhqEKsBIAJBIGokAAtaAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQYT56wAgAkEIahCrASACQSBqJAALVAECfyMAQSBrIgIkACAAKAIEIQMgACgCACACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCADIAJBCGoQqwEgAkEgaiQAC2cBA38jAEEgayICJAAgASgCACEDIAJBCGogASgCBCIBQQAQggUgAiACKAIMIgQ2AhQgAiACKAIINgIQIAQgAyABEKUHGiACIAE2AhggAiACQRBqEJ8GIAAgAikDADcDACACQSBqJAALVwEBfyMAQSBrIgIkACACIAA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakGgqcEAIAJBCGoQqwEgAkEgaiQACy4BAX8jAEEQayICJAAgAiABQQEQggUgACACKQMANwIAIAAgATYCCCACQRBqJAALVwEBfyMAQSBrIgIkACACIAA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakGE+esAIAJBCGoQqwEgAkEgaiQAC1wBAX8CQCABRQRAQQEhAgwBCyABQQBOBEAgAUF/c0EfdiEDAn8gAkUEQCABIAMQ6QYMAQsgASADEOoGCyICDQEgASADEKEHAAsQ5QUACyAAIAI2AgQgACABNgIAC1UBAX8jAEGwE2siAiQAAkAgAQRAIAEoAgANASABQQA2AgAgAkEIaiABQagTEKUHGiAAIAJBEGpBoBMQpQcaIAEQUiACQbATaiQADwsQkgcACxCTBwALQwECfyAAEMgEA0AgACABaiICQQRqKAIABEAgAigCABBSCyABQQhqIgFBwABHDQALIABB5ABqKAIABEAgACgCYBBSCwtPAQF/IwBBIGsiBiQAIAYgATYCACAGIAI2AgQgBkEIakGRicEAEJ0GIAYgBikDCDcDECAAIAYgBkEEaiADIAQgBSAGQRBqEG0gBkEgaiQAC3wAIABCADcCECAAQsCAgIDA////AzcCCCAAQgA3AgAgAEEAOgBUIABBCzYCOCAAQgA3AkQgAEIWNwI8IABCgICAgBA3AFUgAEIANwJMIABChoCAgPABNwIgIABBGGpCADcCACAAQTBqQhA3AgAgAEEoakKIgICA0AA3AgALYAICfwF+IwBBEGsiAiQAIAJBCGogAUEIaigCACIDNgIAIAIgASkCACIENwMAIASnIANLBEAgAiADEPwFIAIoAgghAwsgAigCBCEBIAAgAzYCBCAAIAE2AgAgAkEQaiQAC2ACAn8BfiMAQRBrIgIkACACQQhqIAFBCGooAgAiAzYCACACIAEpAgAiBDcDACAEpyADSwRAIAIgAxD6BSACKAIIIQMLIAIoAgQhASAAIAM2AgQgACABNgIAIAJBEGokAAtgAgJ/AX4jAEEQayICJAAgAkEIaiABQQhqKAIAIgM2AgAgAiABKQIAIgQ3AwAgBKcgA0sEQCACIAMQ/gUgAigCCCEDCyACKAIEIQEgACADNgIEIAAgATYCACACQRBqJAALYAICfwF+IwBBEGsiAiQAIAJBCGogAUEIaigCACIDNgIAIAIgASkCACIENwMAIASnIANLBEAgAiADEPYFIAIoAgghAwsgAigCBCEBIAAgAzYCBCAAIAE2AgAgAkEQaiQAC2ACAn8BfiMAQRBrIgIkACACQQhqIAFBCGooAgAiAzYCACACIAEpAgAiBDcDACAEpyADSwRAIAIgAxD4BSACKAIIIQMLIAIoAgQhASAAIAM2AgQgACABNgIAIAJBEGokAAtgAgJ/AX4jAEEQayICJAAgAkEIaiABQQhqKAIAIgM2AgAgAiABKQIAIgQ3AwAgBKcgA0sEQCACIAMQyAUgAigCCCEDCyACKAIEIQEgACADNgIEIAAgATYCACACQRBqJAALYAICfwF+IwBBEGsiAiQAIAJBCGogAUEIaigCACIDNgIAIAIgASkCACIENwMAIASnIANLBEAgAiADEP8FIAIoAgghAwsgAigCBCEB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KAIMIgBBgYCAgHhHBEAgAigCCCAAEKEHAAsgAkEQaiQACzwBAX8jAEEQayICJAAgAkEIaiAAIAEQswMgAigCDCIAQYGAgIB4RwRAIAIoAgggABChBwALIAJBEGokAAs8AQF/IwBBEGsiAiQAIAJBCGogACABELQDIAIoAgwiAEGBgICAeEcEQCACKAIIIAAQoQcACyACQRBqJAALPAEBfyMAQRBrIgIkACACQQhqIAAgARC1AyACKAIMIgBBgYCAgHhHBEAgAigCCCAAEKEHAAsgAkEQaiQACzwBAX8jAEEQayICJAAgAkEIaiAAIAEQtgMgAigCDCIAQYGAgIB4RwRAIAIoAgggABChBwALIAJBEGokAAs8AQF/IwBBEGsiAiQAIAJBCGogACABELcDIAIoAgwiAEGBgICAeEcEQCACKAIIIAAQoQcACyACQRBqJAALPAEBfyMAQRBrIgIkACACQQhqIAAgARDBAyACKAIMIgBBgYCAgHhHBEAgAigCCCAAEKEHAAsgAkEQaiQACzwBAX8jAEEQayICJAAgAkEIaiAAIAEQwgMgAigCDCIAQYGAgIB4RwRAIAIoAgggABChBwALIAJBEGokAAs/AQF/QQxBBBDpBiICRQRAQQxBBBChBwALIAJBJToACCACQcipwQA2AgQgAiABNgIAIAAgAq1CIIZCA4Q3AgALOQEBfyABQRB2QAAhAiAAQQA2AgggAEEAIAFBgIB8cSACQX9GIgEbNgIEIABBACACQRB0IAEbNgIACzkAAkACfyACQYCAxABHBEBBASAAIAIgASgCEBEBAA0BGgsgAw0BQQALDwsgACADIAQgASgCDBEDAAs1ACAAIAEgAiADIAQgBRDTASIEIAVJBEADQCAAIAEgAiADIAQQnQQgBSAEQQFqIgRHDQALCws1ACAAIAEgAiADIAQgBRDnASIEIAVJBEADQCAAIAEgAiADIAQQxAQgBSAEQQFqIgRHDQALCws1ACAAIAEgAiADIAQgBRDUASIEIAVJBEADQCAAIAEgAiADIAQQngQgBSAEQQFqIgRHDQALCws1ACAAIAEgAiADIAQgBRDVASIEIAVJBEADQCAAIAEgAiADIAQQnwQgBSAEQQFqIgRHDQALCws1ACAAIAEgAiADIAQgBRCHASIEIAVJBEADQCAAIAEgAiADIAQQgAMgBSAEQQFqIgRHDQALCws1ACAAIAEgAiADIAQgBRCIASIEIAVJBEADQCAAIAEgAiADIAQQgQMgBSAEQQFqIgRHDQALCws0ACAAIAEgAiADIAQgBRBNIgQgBUkEQANAIAAgASACIAMgBBDVAiAFIARBAWoiBEcNAAsLCzwBAX9BFEEEEOkGIgFFBEBBFEEEEKEHAAsgAUEANgIAIAEgACkCADcCBCABQQxqIABBCGopAgA3AgAgAQsnAQJ/IABCAloEQANAIAFBAWohASAAQgRUIABCAYghAEUNAAsLIAELMQAgAUEPTQRAIAFBAnRByNbiAGo1AgAgAq0gAK1+fEICiA8LIAFBEEGI1+IAELwEAAs/AQF/IwBBIGsiAiQAIAJBAToAGCACIAE2AhQgAiAANgIQIAJBlPXrADYCDCACQcjb6wA2AgggAkEIahCsBQALMwACQCAAQfz///8HSw0AIABFBEBBBA8LIAAgAEH9////B0lBAnQQ6QYiAEUNACAADwsAC0ABAn8CQAJAAkAgASgCACIEQQFrDgIBAgALIAEoAgQgAmohAwwBCyABKAIEIAJqIQMLIAAgAzYCBCAAIAQ2AgALKgEBfyMAQRBrIgEkACABIAAQmQQgASgCBARAIAEoAgAQUgsgAUEQaiQACzkAIABBgAE6ABggAEKAgICAEDcCDCAAIAEpAgA3AgAgAEEUakEANgIAIABBCGogAUEIaigCADYCAAs1AQF/IACnIQEgAUEBdEEBdUGAgICAfHEgAUH/////A3FyQYCAgIB4cyABIABC/////wtWGwsxACAAKAIcIAAoAhggACgCFCAAKAIQIAAoAgwgACgCCCAAKAIEIAAoAgBqampqampqCy8BAn8gASgCCCIDIAEoAgRJBEAgASgCACADai0AACECCyAAQQA6AAAgACACOgABCzIAIAAoAgAhACABEPsGRQRAIAEQ/AZFBEAgACABEIkHDwsgACABEP4DDwsgACABEP0DCzIAIAAoAgAhACABEPsGRQRAIAEQ/AZFBEAgACABEIsHDwsgACABEP8CDwsgACABEP4CCzcAIAAoAgAhACABEPsGRQRAIAEQ/AZFBEAgADEAAEEBIAEQjwIPCyAAIAEQ+QMPCyAAIAEQ+gMLNwAgACgCACEAIAEQ+wZFBEAgARD8BkUEQCAAMwEAQQEgARCPAg8LIAAgARD7Aw8LIAAgARD4AwsnAAJAIAAgARDmASIBRQ0AIAEQsgcQgQcNACABQQAgABCjBxoLIAELKwACQCAABEAgACgCAA0BIABBADYCACAAQQxqIAE2AgAPCxCSBwALEJMHAAsoAQF/IwBBEGsiAiQAIAJBCGogARDoBCAAIAIoAggQggYgAkEQaiQACzIBAX8gACABKAIAIAEoAggiAksEfyABIAIQygUgASgCCAUgAgs2AgQgACABKAIENgIACzIBAX8gACABKAIAIAEoAggiAksEfyABIAIQywUgASgCCAUgAgs2AgQgACABKAIENgIACy0BAX8jAEEQayIBJAAgAUEIaiAAQQhqKAIANgIAIAEgACkCADcDACABEKsGAAsoAQF/QQEgACgCPCIBIAAoAkAiACABIABKG0EBaiIAQRggAEEYSBt0CyoBAX8gABCIBCIBQRBJBEAgACABQQJ0aioCAA8LIAFBEEH4lOMAELwEAAssACAARQRAQwAAAMAPCyAAQYACTwRAIACzEMQCDwsgAEECdEGQx+IAaioCAAstAQF/IwBBEGsiASQAIAFBCGogAEEIaigCADYCACABIAApAgA3AwAgARD8AwALMgEBf0EBIQEgAC0ABAR/IAEFIAAoAgAiACgCAEGL9+sAQQEgAEEEaigCACgCDBEDAAsLMwAgACABKAIAQdTJ6wBBBCABKAIEKAIMEQMAOgAIIAAgATYCBCAAQQA6AAkgAEEANgIACyUAAkAgAARAIAAoAgBBf0YNASAAQRBqKAIADwsQkgcACxCTBwALJQACQCAABEAgACgCAEF/Rg0BIABBDGooAgAPCxCSBwALEJMHAAsmAAJAIAAEQCAAKAIAQX9GDQEgAEHIKmooAgAPCxCSBwALEJMHAAsmAAJAIAAEQCAAKAIAQX9GDQEgAEGgE2ooAgAPCxCSBwALEJMHAAsuAQF/IwBBEGsiASQAIAEgACkCADcDCCABQQhqQYS9wQBBACAAKAIIQQEQpwMACx8AIAKtIACtfiABZ0EgakE/c0H4AGytfUKAPHxCAogLJQAgACgCBCIAQRh2QYABcSAAQRl2ckEYdEEYdSAAQf///w9xagssAAJAIAEQ+wZFBEAgARD8Bg0BIAAgARDABg8LIAAgARD9Aw8LIAAgARD+AwslAQF/IwBBEGsiAiQAIAIgATYCDCAAIAJBDGoQ2QIgAkEQaiQACycAIAAgACgCBEEBcSABckECcjYCBCAAIAFqIgAgACgCBEEBcjYCBAsdACACQQJ2IABsrSABZ0EgakE/c0EebK19QoAPfAsmAQJ/QYACIQMDQCADIgIgAEkEQCACQQF0IQMgAiABSQ0BCwsgAgskACAAIAFBiA9qIAFB8A1qQQAgAiADEGEiAARAIAEQ1QMLIAALMQAgAEEDOgAgIABCgICAgIAENwIYIABBADYCECAAQQA2AgggACACNgIEIAAgATYCAAstACABKAIAIAIgAyABKAIEKAIMEQMAIQIgAEEAOgAFIAAgAjoABCAAIAE2AgALMgEBfyABKAIAQYr36wBBASABKAIEKAIMEQMAIQIgAEEAOgAFIAAgAjoABCAAIAE2AgALKgEBfyABKAIAIgEQ8wMiAkUEQCAAIAEQ/AEPCyAAQQE2AgAgACACNgIECygBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIAA2AgAgAxCgBgALIAEBfwJAIABBBGooAgAiAUUNACAAKAIARQ0AIAEQUgsLJwEBfyMAQRBrIgAkACAAQSY2AgwgAEHQyusANgIIIABBCGoQuQUACyMAAkAgAUH8////B00EQCAAIAFBBCACEN4GIgANAQsACyAACyAAIAAgAUEDdEE4ca2IQoCAgOj7tI0PfiACQT9xrYinCyIAIAEgA0YEQCAAIAIgARClBxoPCyABIANB/LHAABDABAALJAAgAEECNgIIIABCBDcCACAAQQxqQgA3AgAgAEEUakEAOwEACyMAIAIgAigCBEF+cTYCBCAAIAFBAXI2AgQgACABaiABNgIACx8AIAAoAgAiAK1CACAArH0gAEF/SiIAGyAAIAEQjwILHAAgAUEITwRAIAFBCCACELwEAAsgACABQQJ0agseACABIANHBEAgASADIAQQwAQACyAAIAIgARClBxoLKAAgASAAKAIALQAAQQJ0IgBB2NjrAGooAgAgAEG01+sAaigCABDjBgsgAQJ+IAApAwAiAiACQj+HIgOFIAN9IAJCf1UgARCPAgshAAJAIAENACAAKAIAQQFHDQAgAkECNgIAIABBADYCAAsLJQAgASAALQAAQQJ0IgBB2NjrAGooAgAgAEG01+sAaigCABDjBgseACAAIAFBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQLFAAgACgCAARAIABBBGooAgAQUgsLIgAgAC0AAEUEQCABQZz66wBBBRBkDwsgAUGY+usAQQQQZAsdACABKAIARQRAAAsgAEGYvcEANgIEIAAgATYCAAskACAAIAFBgBEQpQciACABKgKEETgChBEgACABKAKAETYCgBELHAAgACAAKAIAQaeDAWwiAEEBIAAbIgA2AgAgAAsRACAAKAIABEAgACgCBBBSCwscACAAKAIAIgAoAgAgASAAQQRqKAIAKAIMEQEACxkBAX8gACgCECIBBH8gAQUgAEEUaigCAAsLHQBDAAAAAEMAAAAAIAAgAEMAAAAAXRsgACAAXBsLEwBCkJQHIABBDnGtiEIOg0InfAsLACABBEAgABBSCwsWACAAQQRqKAIAIABBCGooAgAgARB3CxcAIABBBGooAgAgAEEIaigCACABEKIHCxIAQQBBGSAAQQF2ayAAQR9GGwsWACAAIAFBAXI2AgQgACABaiABNgIACxcAIABBADYCCCAAIAI2AgQgACABNgIACxQAIAAoAgggAU8EQCAAIAE2AggLCyAAIABBADYCECAAQgE3AgggAEKAgICA4LPy//4ANwIACxAAIAFBAnatIACtfkKPD3wLGQAgACACOwEGIABB//8DOwEEIAAgATYCAAsRACAAQTJsIAFNIAJB1AdLcQsQACAAIAFqQX9qQQAgAWtxCwwAIAAgASACIAMQcwsWACAAKAIAIgAoAgAgACgCBCABEKcFCw8AIABBAXQiAEEAIABrcgsZACABKAIAQYj06wBBDiABKAIEKAIMEQMACxUAIAEgACgCACIAKAIAIAAoAgQQZAsWACAAKAIAIAEgAiAAKAIEKAIMEQMACxkAIAEoAgBB3ozsAEEFIAEoAgQoAgwRAwALEAAgAEEQaigCACAAKAIEagsRAEHAAEGABCAAKAI4QQlIGwsUACAAKAIAIAEgACgCBCgCDBEBAAsPACAAIAEgAiADIAQQSAALCQAgACABEOYBCwkAIAAgARCbBgsPACAAIAAoAghBAWo2AggLEAAgAEEBOgAEIAAgATYCAAsQACAAKAIAIAEgAhDjBUEACxAAIAAoAgQgACgCCCABEHcLEAAgACgCACAAKAIEIAEQdwsRACAAKAIAIAAoAgQgARCiBwsWACAAQQBBhBEQowdBo+D/+wc2AoQRCw8AIAAgASkCBEIgiTcDAAsPACAAKAIUIgBBnAQgABsLEwAgAEEANgIEIABB9JvjADYCAAsQACAAQQA6AAEgACABOgAACxAAIABBADYCBCAAIAE2AgALEwAgAEGczesANgIEIAAgATYCAAsNACAALQAEQQJxQQF2Cw8AIAAgAUEEaikCADcDAAsQACABIAAoAgAgACgCBBBkCw0AIAAtABhBEHFBBHYLDQAgAC0AGEEgcUEFdgsNACAAIAEgAhDjBUEACwoAQQEgAHRBcGoLDQAgACgCACABKAIASQsKAEEAIABrIABxCwsAIAAtAARBA3FFCwwAIAAgAUEDcjYCBAsNACAAKAIAIAAoAgRqCw4AIAAoAgAgARCLAkEACw4AIAAoAgAaA0AMAAsACwwAIAAgASACEL0EAAsMACAAIAEgAhC+BAALDAAgACABIAIQvwQACw4AIAA1AgBBASABEI8CCw4AIAAoAgAgASACENoBCw4AIAApAwBBASABEI8CCw8AIAAoAgApAwAgARDSAQsLACAAIwBqJAAjAAsMACAAKAIAIAEQ3wULDgAgAUH7p8AAQQ4Q4wYLDQAgAUG8wcAAQQIQZAsHACAAEM0GCw0AQYiVwQBBGxCUBwALDgBBo5XBAEHPABCUBwALCQAgACABEAkACwsAIAAgASACEO8BCw0AIAAoAgRB////D3ELDQAgAUGw3cEAQQIQZAsMACAAIAEpAgA3AwALCgBBASAAKAIMdAsKAEEBIAAoAhR0CwwAIAAgASkBADcBAAsMACAAKAIAIAEQyQYLCgAgACgCBEF4cQsKACAAKAIEQQFxCwoAIAAoAgxBAXELCgAgACgCDEEBdgsaACAAIAFBlJTsACgCACIAQcYAIAAbEQAAAAsKACACIAAgARBkCwsAIAAgASACEMwDCwsAIAAgASACELoFCwsAIAAgASACEI0CCwsAIAAgASACEJgBCw4AIAFBgL3BAEEDEOMGCwkAIAEgABCpBQsJACAAQQA2AgALCQAgAEIBNwMACwkAIABCAjcDAAsJACAAQgQ3AwALCwBB9JfsACgCAEULCQAgACABEPoBCwcAIAAgAWoLBwAgACABawsHACAAQQhqCwcAIABBeGoLBwAgARC9AgsMAELTz56i/5e3gk8LDQBCyLXgz8qG29OJfwsMAEK5h9OJk5/l8gALDQBCqd3+1cDm39HMAAsDAAELAwABCwu20inyJgBBgYDAAAvYRwECAwAAAAAAAAEBAQEBAS9ob21lL3RpbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9icm90bGktNS4wLjAvc3JjL2VuYy9iYWNrd2FyZF9yZWZlcmVuY2VzL21vZC5ycwAAABAAEABpAAAA2QIAABIAAAAAAAAA/wH+Av0D/wH+Av0DEAAQAGkAAADkAgAAFAAAABAAEABpAAAA5QIAABgAAAAQABAAaQAAAOsCAAAvAAAAEAAQAGkAAADrAgAAQQAAABAAEABpAAAA+gIAACsAAAAQABAAaQAAAP4CAAASAAAAEAAQAGkAAAAAAwAAEgAAABAAEABpAAAABAMAACUAAAAQABAAaQAAAAsDAAAlAAAAEAAQAGkAAAAVAwAAKQAAABAAEABpAAAAGwMAAB4AAAAQABAAaQAAAC4DAAAtAAAAEAAQAGkAAAA3AwAAJgAAABAAEABpAAAASAMAACUAAAAQABAAaQAAAEoDAAAhAAAAEAAQAGkAAABMAwAACQAAABAAEABpAAAAXgEAACgAAAAQABAAaQAAAF8BAAAlAAAAEAAQAGkAAABiAQAAJgAAABAAEABpAAAAaAEAACAAAAAQABAAaQAAAGoBAAAWAAAAEAAQAGkAAAB0AQAAJAAAABAAEABpAAAAdgEAABkAAAAQABAAaQAAAJQBAAAnAAAAEAAQAGkAAACUAQAAEQAAABAAEABpAAAAmQEAACQAAAAQABAAaQAAAKABAAAWAAAAEAAQAGkAAACsAQAAKAAAABAAEABpAAAAgAEAABcAAAAQABAAaQAAAIEBAAANAAAAEAAQAGkAAACEAQAAIAAAABAAEABpAAAAiwEAAC8AAAAQABAAaQAAAL8BAAAJAAAAEAAQAGkAAAAqAQAAJQAAABAAEABpAAAALQEAAAkAAAAQABAAaQAAAD4BAAArAAAAEAAQAGkAAABAAQAAHQAAAFVOSU5USUFMSVpFRBAAEABpAAAAkggAAAkAAAAQABAAaQAAAK0IAAAJAAAAEAAQAGkAAACYCAAACQAAABAAEABpAAAACwYAACAAAAAQABAAaQAAAAwGAAAaAAAAEAAQAGkAAAANBgAAGgAAABAAEABpAAAADgYAABoAAAAQABAAaQAAAA8GAAAgAAAAEAAQAGkAAAAQBgAAGgAAABAAEABpAAAAEQYAABoAAAAQABAAaQAAABIGAAAaAAAAEAAQAGkAAAAUBgAAIAAAABAAEABpAAAAFQYAABoAAAAQABAAaQAAABYGAAAaAAAAEAAQAGkAAAAXBgAAGgAAABAAEABpAAAAGQYAACAAAAAQABAAaQAAABoGAAAaAAAAEAAQAGkAAAAbBgAAGgAAABAAEABpAAAAHAYAABoAAAAQABAAaQAAACoGAAAmAAAAEAAQAGkAAAAtBgAAJgAAABAAEABpAAAAMAYAACYAAAAQABAAaQAAADMGAAAmAAAAEAAQAGkAAAA6BgAACQAAABAAEABpAAAAOwYAAAkAAAAQABAAaQAAADwGAAAJAAAAEAAQAGkAAAA9BgAACQAAABAAEABpAAAA1AUAAB8AAAAQABAAaQAAANUFAAAaAAAAEAAQAGkAAADWBQAAGgAAABAAEABpAAAA1wUAABoAAAAQABAAaQAAANgFAAAaAAAAEAAQAGkAAADZBQAAGgAAABAAEABpAAAA2gUAABoAAAAQABAAaQAAANsFAAAaAAAAEAAQAGkAAADdBQAAHwAAABAAEABpAAAA3QUAADYAAAAQABAAaQAAAOsFAAAmAAAAEAAQAGkAAADuBQAAJgAAABAAEABpAAAA8QUAACYAAAAQABAAaQAAAPQFAAAmAAAAEAAQAGkAAAD7BQAACQAAABAAEABpAAAA/AUAAAkAAAAQABAAaQAAAP0FAAAJAAAAEAAQAGkAAAD+BQAACQAAABAAEABpAAAAfgYAAB0AAAAQABAAaQAAAIIGAAArAAAAEAAQAGkAAACNBgAAHAAAABAAEABpAAAAjQYAADIAAAAQABAAaQAAAJEGAAAqAAAAEAAQAGkAAACtBgAAJAAAABAAEABpAAAAsgYAABIAAAAQABAAaQAAALQGAAASAAAAYXNzZXJ0aW9uIGZhaWxlZDogYnVja2V0LmxlbigpID4gc2VsZi5zcGVjaWFsaXphdGlvbi5ibG9ja19tYXNrKCkgYXMgdXNpemUAABAAEABpAAAAtgYAAA0AAAAQABAAaQAAAMAGAAAZAAAAEAAQAGkAAADFBgAAHAAAABAAEABpAAAAxQYAADIAAAAQABAAaQAAAM8GAAAqAAAAEAAQAGkAAADeBgAADQAAABAAEABpAAAAQAYAACUAAAAQABAAaQAAAEMGAAAOAAAAEAAQAGkAAABGBgAACQAAABAAEABpAAAASAYAAB0AAAAQABAAaQAAAK0FAAArAAAAEAAQAGkAAACuBQAAEQAAABAAEABpAAAAsgUAABEAAABhc3NlcnRpb24gZmFpbGVkOiBtaWQgPD0gc2VsZi5sZW4oKS9ob21lL3RpbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9icm90bGktNS4wLjAvc3JjL2VuYy9zdGF0aWNfZGljdC5yc4cHEABdAAAAIwAAAB8AAACHBxAAXQAAACMAAAALAAAAhwcQAF0AAAAuAAAAHwAAAIcHEABdAAAALgAAAAsAAAAQABAAaQAAAPIAAAAjAAAAEAAQAGkAAADyAAAAMQAAABAAEABpAAAA/AAAABEAAAAQABAAaQAAAP0AAAARAAAAEAAQAGkAAAD+AAAAEQAAABAAEABpAAAA/wAAABEAAAAQABAAaQAAAKQJAAAlAAAAEAAQAGkAAACkCQAAFQAAABAAEABpAAAArgkAADwAAAAQABAAaQAAAJQHAAAfAAAAd29ya2luZyB3aXRoIHVuaW5pdGlhbGl6ZWQgaGFzaCBtYXAAEAAQAGkAAAD0CQAAJQAAABAAEABpAAAAbQQAAA0AAAAQABAAaQAAAG4EAAANAAAAEAAQAGkAAAB4BAAAJgAAABAAEABpAAAAeQQAACIAAAAQABAAaQAAAHoEAAAiAAAAEAAQAGkAAAB7BAAAIgAAABAAEABpAAAAfAQAACIAAAAQABAAaQAAAH0EAAAiAAAAEAAQAGkAAAB+BAAAIgAAABAAEABpAAAAiwQAAC4AAAAQABAAaQAAAI4EAAAuAAAAEAAQAGkAAACRBAAALgAAABAAEABpAAAAlAQAAC4AAAAQABAAaQAAAJ8EAAARAAAAEAAQAGkAAACgBAAAEQAAABAAEABpAAAAoQQAABEAAAAQABAAaQAAAKIEAAARAAAAEAAQAGkAAAC5BAAADQAAABAAEABpAAAAugQAAA0AAAAQABAAaQAAAMMEAAAaAAAAEAAQAGkAAADFBAAAGgAAABAAEABpAAAAwgQAADUAAAAQABAAaQAAAOEEAAAyAAAAEAAQAGkAAADkBAAAMgAAABAAEABpAAAA5wQAADIAAAAQABAAaQAAAOoEAAAyAAAAEAAQAGkAAAD1BAAAFQAAABAAEABpAAAA9gQAABUAAAAQABAAaQAAAPcEAAAVAAAAEAAQAGkAAAD4BAAAFQAAAC9ob21lL3RpbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9icm90bGktNS4wLjAvc3JjL2VuYy9jb21tYW5kLnJzAAAA2AoQAFkAAAApAAAAOwAAANgKEABZAAAAKgAAADsAAADYChAAWQAAADMAAAAfAAAA2AoQAFkAAAA1AAAAHwAAAFRyaWVkIHRvIHNocmluayB0byBhIGxhcmdlciBjYXBhY2l0eXQLEAAkAAAAL3J1c3RjLzllYjNhZmU5ZWJlOWM3ZDJiODRiNzEwMDJkNDRmNGEwZWRhYzk1ZTAvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc6ALEABMAAAAqgEAAAkAAAAvaG9tZS90aW0vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYnJvdGxpLTUuMC4wL3NyYy9lbmMvaGlzdG9ncmFtLnJzL2hvbWUvdGltLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jyb3RsaS01LjAuMC9zcmMvZW5jL2NvbnRleHRfbWFwX2VudHJvcHkucnNXDBAAZQAAABkCAAAJAAAAL2hvbWUvdGltLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jyb3RsaS1kZWNvbXByZXNzb3ItNC4wLjAvc3JjL2xpYi5yc1VuZXhwZWN0ZWQgRU9GYXNzZXJ0aW9uIGZhaWxlZDogaW5wdXRfYnVmZmVyLmxlbigpICE9IDAAAADMDBAAXgAAANsAAAADAAAAYXNzZXJ0aW9uIGZhaWxlZDogb3V0cHV0X2J1ZmZlci5sZW4oKSAhPSAwAADMDBAAXgAAANwAAAADAAAAAAAAAMwMEABeAAAAFgEAABgAAADMDBAAXgAAABwBAAANAAAAAQAAAAAAAAAB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AwAAGgAAAKwVEABjAAAACAQAABYAAACsFRAAYwAAADgAAAAnAAAArBUQAGMAAABPAAAAKwAAAKwVEABjAAAAdgAAAD0AAAAvcnVzdGMvOWViM2FmZTllYmU5YzdkMmI4NGI3MTAwMmQ0NGY0YTBlZGFjOTVlMC9saWJyYXJ5L3N0ZC9zcmMvaW8vaW1wbHMucnMAsBgQAEsAAAD0AAAAGAAAALAYEABLAAAA8gAAAA0AAAALAAAABAAAAAQAAAAMAAAACwAAAAQAAAAEAAAADQAAAC9ob21lL3RpbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9icm90bGktNS4wLjAvc3JjL2VuYy9lbnRyb3B5X2VuY29kZS5yczwZEABgAAAAUAAAACgAAAA8GRAAYAAAAF8AAAANAAAAPBkQAGAAAABoAAAAMAAAADwZEABgAAAAaQAAAEYAAAA8GRAAYAAAAG8AAAAVAAAAL2hvbWUvdGltLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jyb3RsaS01LjAuMC9zcmMvZW5jL2ludGVyZmFjZS5ycwDsGRAAWwAAADsBAAAZAAAA7BkQAFsAAAA8AQAAGgAAAOwZEABbAAAAPQEAABcAAADsGRAAWwAAAD4BAAAYAAAA7BkQAFsAAAApAQAAGQAAAOwZEABbAAAAKgEAABoAAADsGRAAWwAAACsBAAAXAAAA7BkQAFsAAAAsAQAAGAAAAOwZEABbAAAAqQAAAAkAAABpbnZhbGlkIGVudW0gdmFsdWUgcGFzc2VkVW5leHBlY3RlZCBCcm90bGkgc3RyZWFtaW5nIGNvbXByZXNzOiBib3RoIGF2YWlsYWJsZV9pbiAmIGF2YWlsYWJsZV9vdXQgYXJlIG5vdCAwIGFmdGVyIGEgc3VjY2Vzc2Z1bCBwcm9jZXNzaW5nQnJvdGxpIHN0cmVhbWluZyBjb21wcmVzcyBmYWlsZWQ6IFdoZW4gcHJvY2Vzc2luZ0Jyb3RsaSBzdHJlYW1pbmcgY29tcHJlc3MgZmFpbGVkOiBXaGVuIGZpbmlzaGluZ0Jyb3RsaSBzdHJlYW1pbmcgZGVjb21wcmVzcyBmYWlsZWQ6IEVycm9yIGNv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95k5/RwDfpx1AIg85Dd+A5MAqkvdbX7iW0BKT6qiftpy0BzjVNd+kI8E5BsqDX+62YJuUTpCfymQI8rlyHZ/M3SsPB97rH+gyOuF88zhfxsAAAAEAAAABAAAABwAAAAdAAAAHgAAAB8AAAAMAAAABAAAACAAAAAfAAAADAAAAAQAAAAhAAAAIAAAALhUEAAiAAAAIwAAACQAAAAlAAAAJgAAAFRyaWVkIHRvIHNocmluayB0byBhIGxhcmdlciBjYXBhY2l0efRUEAAkAAAAL3J1c3RjLzllYjNhZmU5ZWJlOWM3ZDJiODRiNzEwMDJkNDRmNGEwZWRhYzk1ZTAvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5ycyBVEABMAAAAqgEAAAkAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL2hvbWUvdGltLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3NlcmRlX2pzb24tMS4wLjc5L3NyYy9yZWFkLnJzAACnVRAAVwAAAKEBAAAUAAAAp1UQAFcAAADGAQAAEwAAAKdVEABXAAAA1QEAADAAAACnVRAAVwAAAMsBAAApAAAAp1UQAFcAAADPAQAANAAAAKdVEABXAAAAJgIAABMAAACnVRAAVwAAAD4CAAAlAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAEAQcytwQALAQEAQfCuwQAL/g6nVRAAVwAAAKYDAAAvAAAA////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg///////////////////////////////////woLDA0OD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////ykAAAAMAAAABAAAACoAAAArAAAAGAAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkALAAAAAAAAAABAAAAGgAAAC9ydXN0Yy85ZWIzYWZlOWViZTljN2QyYjg0YjcxMDAyZDQ0ZjRhMGVkYWM5NWUwL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwDgWBAASwAAAOkJAAAOAAAAL3J1c3RjLzllYjNhZmU5ZWJlOWM3ZDJiODRiNzEwMDJkNDRmNGEwZWRhYzk1ZTAvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwA8WRAATwAAAP4FAAAUAAAAPFkQAE8AAAD+BQAAIQAAADxZEABPAAAACgYAABQAAAA8WRAATwAAAAoGAAAhAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5pc19jaGFyX2JvdW5kYXJ5KG5ld19sZW4p4FgQAEsAAAD/BAAADQAAADxZEABPAAAAiwQAABcAAAByZWN1cnNpb24gbGltaXQgZXhjZWVkZWR1bmV4cGVjdGVkIGVuZCBvZiBoZXggZXNjYXBldHJhaWxpbmcgY2hhcmFjdGVyc3RyYWlsaW5nIGNvbW1hbG9uZSBsZWFkaW5nIHN1cnJvZ2F0ZSBpbiBoZXggZXNjYXBla2V5IG11c3QgYmUgYSBzdHJpbmdjb250cm9sIGNoYXJhY3RlciAoXHUwMDAwLVx1MDAxRikgZm91bmQgd2hpbGUgcGFyc2luZyBhIHN0cmluZ2ludmFsaWQgdW5pY29kZSBjb2RlIHBvaW50bnVtYmVyIG91dCBvZiByYW5nZWludmFsaWQgbnVtYmVyaW52YWxpZCBlc2NhcGVleHBlY3RlZCB2YWx1ZWV4cGVjdGVkIGlkZW50ZXhwZWN0ZWQgYCxgIG9yIGB9YGV4cGVjdGVkIGAsYCBvciBgXWBleHBlY3RlZCBgOmBFT0Ygd2hpbGUgcGFyc2luZyBhIHZhbHVlRU9GIHdoaWxlIHBhcnNpbmcgYSBzdHJpbmdFT0Ygd2hpbGUgcGFyc2luZyBhbiBvYmplY3RFT0Ygd2hpbGUgcGFyc2luZyBhIGxpc3QgYXQgbGluZSBFcnJvcigsIGxpbmU6ICwgY29sdW1uOiApAADtWxAABgAAAPNbEAAIAAAA+1sQAAoAAAAFXBAA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HQCn8wEAp/MFAKfzCQCn8w0Ap/MRAKfzFQCn8xkAp/MdAKf7AQCn+wUAp/sJAKf7DQCn+xEAp/sVAKf7GQCn+x0At8MBALfDBQC3wwkAt8MNALfDEQC3wxUAt8MZALfDHQC3ywEAt8sFALfLCQC3yw0At8sRALfLFQC3yxkAt8sdALfTAQC30wUAt9MJALfTDQC30xEAt9MVALfTGQC30x0At9sBALfbBQC32wkAt9sNALfbEQC32xUAt9sZALfbHQC34wEAt+MFALfjCQC34w0At+MRALfjFQC34xkAt+MdALfrAQC36wUAt+sJALfrDQC36xEAt+sVALfrGQC36x0At/MBALfzBQC38wkAt/MNALfzEQC38xUAt/MZALfzHQC3+wEAt/sFALf7CQC3+w0At/sRALf7FQC3+xkAt/sdAMfDAQDHwwUAx8MJAMfDDQDHwxEAx8MVAMfDGQDHwx0Ax8sBAMfLBQDHywkAx8sNAMfLEQDHyxUAx8sZAMfLHQDH0wEAx9MFAMfTCQDH0w0Ax9MRAMfTFQDH0xkAx9MdAMfbAQDH2wUAx9sJAMfbDQDH2xEAx9sVAMfbGQDH2x0Ax+MBAMfjBQDH4wkAx+MNAMfjEQDH4xUAx+MZAMfjHQDH6wEAx+sFAMfrCQDH6w0Ax+sRAMfrFQDH6xkAx+sdAMfzAQDH8wUAx/MJAMfzDQDH8xEAx/MVAMfzGQDH8x0Ax/sBAMf7BQDH+wkAx/sNAMf7EQDH+xUAx/sZAMf7HQDXwwEA18MFANfDCQDXww0A18MRANfDFQDXwxkA18MdANfLAQDXywUA18sJANfLDQDXyxEA18sVANfLGQDXyx0A19MBANfTBQDX0wkA19MNANfTEQDX0xUA19MZANfTHQDX2wEA19sFANfbCQDX2w0A19sRANfbFQDX2xkA19sdANfjAQDX4wUA1+MJANfjDQDX4xEA1+MVANfjGQDX4x0A1+sBANfrBQDX6wkA1+sNANfrEQDX6xUA1+sZANfrHQDX8wEA1/MFANfzCQDX8w0A1/MRANfzFQDX8xkA1/MdANf7AQDX+wUA1/sJANf7DQDX+xEA1/sVANf7GQDX+x0A58MBAOfDBQDnwwkA58MNAOfDEQDnwxUA58MZAOfDHQDnywEA58sFAOfLCQDnyw0A58sRAOfLFQDnyxkA58sdAOfTAQDn0wUA59MJAOfTDQDn0xEA59MVAOfTGQDn0x0A59sBAOfbBQDn2wkA59sNAOfbEQDn2xUA59sZAOfbHQDn4wEA5+MFAOfjCQDn4w0A5+MRAOfjFQDn4xkA5+MdAOfrAQDn6wUA5+sJAOfrDQDn6xEA5+sVAOfrGQDn6x0A5/MBAOfzBQDn8wkA5/MNAOfzEQDn8xUA5/MZAOfzHQDn+wEA5/sFAOf7CQDn+w0A5/sRAOf7FQDn+xkA5/sdAPfDAQD3wwUA98MJAPfDDQD3wxEA98MVAPfDGQD3wx0A98sBAPfLBQD3ywkA98sNAPfLEQD3yxUA98sZAPfLHQD30wEA99MFAPfTCQD30w0A99MRAPfTFQD30xkA99MdAPfbAQD32wUA99sJAPfbDQD32xEA99sVAPfbGQD32x0A9+MBAPfjBQD34wkA9+MNAPfjEQD34xUA9+MZAPfjHQD36wEA9+sFAPfrCQD36w0A9+sRAPfrFQD36xkA9+sdAPfzAQD38wUA9/MJAPfzDQD38xEA9/MVAPfzGQD38x0A9/sBAPf7BQD3+wkA9/sNAPf7EQD3+xUA9/sZAPf7HQCHw+EAh8PhAofD4QSHw+EGh8PhCIfD4QqHw+EMh8PhDofD5QCHw+UCh8PlBIfD5QaHw+UIh8PlCofD5QyHw+UOh8PpAIfD6QKHw+kEh8PpBofD6QiHw+kKh8PpDIfD6Q6Hw+0Ah8PtAofD7QSHw+0Gh8PtCIfD7QqHw+0Mh8PtDofD8QCHw/ECh8PxBIfD8QaHw/EIh8PxCofD8QyHw/EOh8P1AIfD9QKHw/UEh8P1BofD9QiHw/UKh8P1DIfD9Q6Hw/kAh8P5AofD+QSHw/kGh8P5CIfD+QqHw/kMh8P5DofD/QCHw/0Ch8P9BIfD/QaHw/0Ih8P9CofD/QyHw/0Oh8vhAIfL4QKHy+EEh8vhBofL4QiHy+EKh8vhDIfL4Q6Hy+UAh8vlAofL5QSHy+UGh8vlCIfL5QqHy+UMh8vlDofL6QCHy+kCh8vpBIfL6QaHy+kIh8vpCofL6QyHy+kOh8vtAIfL7QKHy+0Eh8vtBofL7QiHy+0Kh8vtDIfL7Q6Hy/EAh8vxAofL8QSHy/EGh8vxCIfL8QqHy/EMh8vxDofL9QCHy/UCh8v1BIfL9QaHy/UIh8v1CofL9QyHy/UOh8v5AIfL+QKHy/kEh8v5BofL+QgAAAAABAAAAAgAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAsAAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAAAQEBAQEBAQEBAQEBAQFBQAEBAYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYAAAAAAAAIAAAABAAAAAwAAAACAAAACgAAAAYAAAAOAAAAAQAAAAkAAAAFAAAADQAAAAMAAAAPAAAAHwAAAAAAAAALAAAABwAAAAsAAAAbAAAAKwAAADsAAADLAgAAywYAAMsKAADLDgAA2wIAANsGAADbCgAA2w4AAOsCAADrBgAA6woAAOsOAAD7AgAA+wYAAPsKAAD7DgAAy7IAAMuyAQDLsgIAy7IDAMu2AADLtgEAy7YCAMu2AwDLugAAy7oBAMu6AgDLugMAy74AAMu+AQDLvgIAy74DANuyAADbsgEA27ICANuyAwDbtgAA27YBANu2AgDbtgMA27oAANu6AQDbugIA27oDANu+AADbvgEA274CANu+AwDrsgAA67IBAOuyAgDrsgMA67YAAOu2AQDrtgIA67YDAOu6AADrugEA67oCAOu6AwDrvgAA674BAOu+AgDrvgMA+7IAAPuyAQD7sgIA+7IDAPu2AAD7tgEA+7YCAPu2AwD7ugAA+7oBAPu6AgD7ugMA+74AAPu+AQD7vgIA+74DAMuyLADLsmwAy7KsAMuy7ADLsi0Ay7JtAMuyrQDLsu0Ay7IuAMuybgDLsq4Ay7LuAMuyLwDLsm8Ay7KvAMuy7wDLtiwAy7ZsAMu2rADLtuwAy7YtAMu2bQDLtq0Ay7btAMu2LgDLtm4Ay7auAMu27gDLti8Ay7ZvAMu2rwDLtu8Ay7osAMu6bADLuqwAy7rsAMu6LQDLum0Ay7qtAMu67QDLui4Ay7puAMu6rgDLuu4Ay7ovAMu6bwDLuq8Ay7rvAMu+LADLvmwAy76sAMu+7ADLvi0Ay75tAMu+rQDLvu0Ay74uAMu+bgDLvq4Ay77uAMu+LwDLvm8Ay76vAMu+7wDbsiwA27JsANuyrADbsuwA27ItANuybQDbsq0A27LtANuyLgDbsm4A27KuANuy7gDbsi8A27JvANuyrwDbsu8A27YsANu2bADbtqwA27bsANu2LQDbtm0A27atANu27QDbti4A27ZuANu2rgDbtu4A27YvANu2bwDbtq8A27bvANu6LADbumwA27qsANu67ADbui0A27ptANu6rQDbuu0A27ouANu6bgDbuq4A27ruANu6LwDbum8A27qvANu67wDbviwA275sANu+rADbvuwA274tANu+bQDbvq0A277tANu+LgDbvm4A276uANu+7gDbvi8A275vANu+rwDbvu8A67IsAOuybADrsqwA67LsAOuyLQDrsm0A67KtAOuy7QDrsi4A67JuAOuyrgDrsu4A67IvAOuybwDrsq8A67LvAOu2LADrtmwA67asAOu27ADrti0A67ZtAOu2rQDrtu0A67YuAOu2bgDrtq4A67buAOu2LwDrtm8A67avAOu27wDruiwA67psAOu6rADruuwA67otAOu6bQDruq0A67rtAOu6LgDrum4A67quAOu67gDrui8A67pvAOu6rwDruu8A674sAOu+bADrvqwA677sAOu+LQDrvm0A676tAOu+7QDrvi4A675uAOu+rgDrvu4A674vAOu+bwDrvq8A677vAPuyLAD7smwA+7KsAPuy7AD7si0A+7JtAPuyrQD7su0A+7IuAPuybgD7sq4A+7LuAPuyLwD7sm8A+7KvAPuy7wD7tiwA+7ZsAPu2rAD7tuwA+7YtAPu2bQD7tq0A+7btAPu2LgD7tm4A+7auAPu27gD7ti8A+7ZvAPu2rwD7tu8A+7osAPu6bAD7uqwA+7rsAPu6LQD7um0A+7qtAPu67QD7ui4A+7puAPu6rgD7uu4A+7ovAPu6bwD7uq8A+7rvAPu+LAD7vmwA+76sAPu+7AD7vi0A+75tAPu+rQD7vu0A+74uAPu+bgD7vq4A+77uAPu+LwD7vm8A+76vAPu+7wDLsiwLy7IsG8uyLCvLsiw7y7JsC8uybBvLsmwry7JsO8uyrAvLsqwby7KsK8uyrDvLsuwLy7LsG8uy7CvLsuw7y7ItC8uyLRvLsi0ry7ItO8uybQvLsm0by7JtK8uybTvLsq0Ly7KtG8uyrSvLsq07y7LtC8uy7RvLsu0ry7LtO8uyLgvLsi4by7IuK8uyLjvLsm4Ly7JuG8uybivLsm47y7KuC8uyrhvLsq4ry7KuO8uy7gvLsu4by7LuK8uy7jvLsi8Ly7IvG8uyLyvLsi87y7JvC8uybxvLsm8ry7JvO8uyrwvLsq8by7KvK8uyrzvLsu8Ly7LvG8uy7yvLsu87y7YsC8u2LBvLtiwry7YsO8u2bAvLtmwby7ZsK8u2bDvLtqwLy7asG8u2rCvLtqw7y7bsC8u27BvLtuwry7bsO8u2LQvLti0by7YtK8u2LTvLtm0Ly7ZtG8u2bSvLtm07y7atC8u2rRvLtq0ry7atO8u27QvLtu0by7btK8u27TvLti4Ly7YuG8u2LivLti47y7ZuC8u2bhvLtm4ry7ZuO8u2rgvLtq4by7auK8u2rjvLtu4Ly7buG8u27ivLtu47y7YvC8u2LxvLti8ry7YvO8u2bwvLtm8by7ZvK8u2bzvLtq8Ly7avG8u2ryvLtq87y7bvC8u27xvLtu8ry7bvO8u6LAvLuiwby7osK8u6LDvLumwLy7psG8u6bCvLumw7y7qsC8u6rBvLuqwry7qsO8u67AvLuuwby7rsK8u67DvLui0Ly7otG8u6LSvLui07y7ptC8u6bRvLum0ry7ptO8u6rQvLuq0by7qtK8u6rTvLuu0Ly7rtG8u67SvLuu07y7ouC8u6LhvLui4ry7ouO8u6bgvLum4by7puK8u6bjvLuq4Ly7quG8u6rivLuq47y7ruC8u67hvLuu4ry7ruO8u6LwvLui8by7ovK8u6LzvLum8Ly7pvG8u6byvLum87y7qvC8u6rxvLuq8ry7qvO8u67wvLuu8by7rvK8u67zvLviwLy74sG8u+LCvLviw7y75sC8u+bBvLvmwry75sO8u+rAvLvqwby76sK8u+rDvLvuwLy77sG8u+7CvLvuw7y74tC8u+LRvLvi0ry74tO8u+bQvLvm0by75tK8u+bTvLvq0Ly76tG8u+rSvLvq07y77tC8u+7RvLvu0ry77tO8u+LgvLvi4by74uK8u+LjvLvm4Ly75uG8u+bivLvm47y76uC8u+rhvLvq4ry76uO8u+7gvLvu4by77uK8u+7jvLvi8Ly74vG8u+LyvLvi87y75vC8u+bxvLvm8ry75vO8u+rwvLvq8by76vK8u+rzvLvu8Ly77vG8u+7yvLvu8727IsC9uyLBvbsiwr27IsO9uybAvbsmwb27JsK9uybDvbsqwL27KsG9uyrCvbsqw727LsC9uy7Bvbsuwr27LsO9uyLQvbsi0b27ItK9uyLTvbsm0L27JtG9uybSvbsm0727KtC9uyrRvbsq0r27KtO9uy7Qvbsu0b27LtK9uy7Tvbsi4L27IuG9uyLivbsi4727JuC9uybhvbsm4r27JuO9uyrgvbsq4b27KuK9uyrjvbsu4L27LuG9uy7ivbsu4727IvC9uyLxvbsi8r27IvO9uybwvbsm8b27JvK9uybzvbsq8L27KvG9uyryvbsq8727LvC9uy7xvbsu8r27LvO9u2LAvbtiwb27YsK9u2LDvbtmwL27ZsG9u2bCvbtmw727asC9u2rBvbtqwr27asO9u27Avbtuwb27bsK9u27Dvbti0L27YtG9u2LSvbti0727ZtC9u2bRvbtm0r27ZtO9u2rQvbtq0b27atK9u2rTvbtu0L27btG9u27Svbtu0727YuC9u2Lhvbti4r27YuO9u2bgvbtm4b27ZuK9u2bjvbtq4L27auG9u2rivbtq47BgAAAAYAAAAGAAAABgAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAIAAQADAACAAoABgAOAAEACQAFAA0AAwALAAcADwAAgAiABIAMgAKACoAGgA6AAYAJgAWADYADgAuAB4APgABACEAEQAxAAkAKQAZADkABQAlABUANQANAC0AHQA9AAMAIwATADMACwArABsAOwAHACcAFwA3AA8ALwAfAD8AAAAAAYAAgAFAAEABwADAASAAIAGgAKABYABgAeAA4AEQABABkACQAVAAUAHQANABMAAwAbAAsAFwAHAB8ADwAQgACAGIAIgBSABIAcgAyAEoACgBqACoAWgAaAHoAOgBGAAYAZgAmAFYAFgB2ADYATgAOAG4ALgBeAB4AfgA+AEEAAQBhACEAUQARAHEAMQBJAAkAaQApAFkAGQB5ADkARQAFAGUAJQBVABUAdQA1AE0ADQBtAC0AXQAdAH0APQBDAAMAYwAjAFMAEwBzADMASwALAGsAKwBbABsAewA7AEcABwBnACcAVwAXAHcANwBPAA8AbwAvAF8AHwB/AD8AQIAAgGCAIIBQgBCAcIAwgEiACIBogCiAWIAYgHiAOIBEgASAZIAkgFSAFIB0gDSATIAMgGyALIBcgByAfIA8gEKAAoBigCKAUoASgHKAMoBKgAqAaoAqgFqAGoB6gDqARoAGgGaAJoBWgBaAdoA2gE6ADoBugC6AXoAegH6APoBBgAGAYYAhgFGAEYBxgDGASYAJgGmAKYBZgBmAeYA5gEWABYBlgCWAVYAVgHWANYBNgA2AbYAtgF2AHYB9gD2AQ4ADgGOAI4BTgBOAc4AzgEuAC4BrgCuAW4AbgHuAO4BHgAeAZ4AngFeAF4B3gDeAT4APgG+AL4BfgB+Af4A/gEBAAEBgQCBAUEAQQHBAMEBIQAhAaEAoQFhAGEB4QDhAREAEQGRAJEBUQBRAdEA0QExADEBsQCxAXEAcQHxAPEBCQAJAYkAiQFJAEkByQDJASkAKQGpAKkBaQBpAekA6QEZABkBmQCZAVkAWQHZANkBOQA5AbkAuQF5AHkB+QD5AQUABQGFAIUBRQBFAcUAxQElACUBpQClAWUAZQHlAOUBFQAVAZUAlQFVAFUB1QDVATUANQG1ALUBdQB1AfUA9QENAA0BjQCNAU0ATQHNAM0BLQAtAa0ArQFtAG0B7QDtAR0AHQGdAJ0BXQBdAd0A3QE9AD0BvQC9AX0AfQH9AP0BAwADAYMAgwFDAEMBwwDDASMAIwGjAKMBYwBjAeMA4wETABMBkwCTAVMAUwHTANMBMwAzAbMAswFzAHMB8wDzAQsACwGLAIsBSwBLAcsAywErACsBqwCrAWsAawHrAOsBGwAbAZsAmwFbAFsB2wDbATsAOwG7ALsBewB7AfsA+wEHAAcEBwIHBgcBBwUHAwcHhwCHBIcChwaHAYcFhwOHB0cARwRHAkcGRwFHBUcDRwfHAMcExwLHBscBxwXHA8cHJwAnBCcCJwYnAScFJwMnB6cApwSnAqcGpwGnBacDpwdnAGcEZwJnBmcBZwVnA2cH5wDnBOcC5wbnAecF5wPnBxcAFwQXAhcGFwEXBRcDFweXAJcElwKXBpcBlwWXA5cHVwBXBFcCVwZXAVcFVwNXB9cA1wTXAtcG1wHXBdcD1wc3ADcENwI3BjcBNwU3AzcHtwC3BLcCtwa3AbcFtwO3B3cAdwR3AncGdwF3BXcDdwf3APcE9wL3BvcB9wX3A/cHDwAPBA8CDwYPAQ8FDwMPB48AjwSPAo8GjwGPBY8DjwdPAE8ETwJPBk8BTwVPA08HzwDPBM8CzwbPAc8FzwPPBy8ALwQvAi8GLwEvBS8DLwevAK8ErwKvBq8BrwWvA68HbwBvBG8CbwZvAW8FbwNvB+8A7wTvAu8G7wHvBe8D7wcfAB8EHwIfBh8BHwUfAx8HnwCfBJ8CnwafAZ8FnwOfB18AXwRfAl8GXwFfBV8DXwffAN8E3wLfBt8B3wXfA98HPwA/BD8CPwY/AT8FPwM/B78AvwS/Ar8GvwG/Bb8Dvwd/AH8EfwJ/Bn8BfwV/A38H/wD/BP8C/wb/Af8F/wP/B0h9AEGC4MIACwJkVQBBkuDCAAsCJp4AQZ7gwgALAuayAEGs4MIACwIMBQBBtuDCAAsKZBMWAaVcAAAETgBB2ODCAAsMTgjmPgAAAAAAAGU4AEHy4MIACwpnaM0IAAAAAGRDAEGO4cIACwImDgBBmOHCAAsCyFkAQabhwgALBgdBAADHhQBBtuHCAAsCZr0AQdThwgALAs8JAEGY4sIACxBMTAAAAADEXQAAAAAAAGQmAEHG4sIACwKFeABBiuPCAAsC5nwAQZzjwgALEKpQZAkAACVRjQZHIwAABBkAQdLjwgALAqfKAEHw48IACxZpGiYcAAAAAOhVx1kAAAAAyQ0AAEgHAEGS5MIACxomKwAAAACpJQAAAAAAAGsZAAAAAEaQSFSn8wBBvuTCAAsCZiAAQc7kwgALDGefAAAAAAAA5pnIHwBB6OTCAAsCqyIAQZLlwgALFgUfAAAAAAlkAAAAAAAAqAOEDo0MRz0AQbLlwgALBifNAADlQwBBwOXCAAsQKAWlFgAAJVIAAAAASBknAwBB5OXCAAsc6TQAAAAAAAAoDgAAAAAAAOpzZHgAAAV6AADEGQBBkubCAAsCRvoAQarmwgALBgZXAABGkgBBuObCAAsMSBynAQAAJGDJVOREAEHQ5sIACxQpBwAAAAAAAEgBhRcAAAAAAAAGTgBB9ubCAAsEp/JSEABBgufCAAsaRC+pIQAAAAAEQgAARo8AAAAAAAAmigAABsoAQbrnwgALBgZSAACG8gBByufCAAsCphUAQeLnwgALBiU5yCpHZQBB8OfCAAsCiU0AQYDowgALIOh45gvqN8YyAAAAAAAApDsAAIaeCHam8gAAAAAAAKROAEGq6MIACwrlLgAAAAAAAIbMAEG86MIACwjKYAAALABHgQBBzujCAAsCBGcAQdrowgALCsUOAAAAAAhGByUAQfTowgALBCl+xW8AQZLpwgALBEa4yy0AQajpwgALCugJZ9cAAAAAChkAQcLpwgALDObbii4AABECAADodQBB8unCAAsORSAAAAAAiHDm5WlYxQMAQabqwgALDof6AAAAAEsBZA4AAEUGAEHI6sIACwwKQSUAAABGXEgMRTwAQejqwgALA6tXRQBB/OrCAAsCqEUAQZDrwgALAmkrAEGa68IACwKFRwBBruvCAAsKBmgAAAAAqGMnZQBBzuvCAAsYBUIAAAAAAACmawAAAADKJAAAAAAAALQNAEH268IACwZmlEkkRSEAQYTswgALDioGRAaIXQAAAABEOu0xAEGg7MIACwZJLwAA6UAAQb7swgALBmRT6CvGcABB6OzCAAsIjBYAAAAApGwAQf7swgALAoQgAEGU7cIACxJsQYUEAAAAAGpJxD8qZacDjSAAQbbtwgALCkZHAACmRgAABrcAQcztwgALDlMBAAAAAGRi7DGGLwkZAEHi7cIACwiEQAAAhGnrbgBB+O3CAAsMjAUAAAAAAAAoJufOAEGg7sIACwRLYkQBAEG27sIACwLm/QBBwu7CAAsChVUAQc7uwgALEga5AAAAAAAAZgMAAAAAAABmMQBBhu/CAAsEpGXoPwBBqO/CAAsMEQcAAAAAAADJGQY+AEG+78IACwakcQAAZG8AQdbvwgALCuRVAAAAAAAAxqcAQfTvwgALBA0UJgUAQY7wwgALBMbWSGEAQabwwgALAkbJAEGy8MIACwJlDgBBvPDCAAsQTifEJAAAAAAAAOR6TBYlGABB3vDCAAsCxxUAQfTwwgALBAhqhuAAQYTxwgALCKwbAADpVYbPAEGU8cIACwjNIAAAAABlFgBBpvHCAAsKRAgAAKZgAAAHLABB0PHCAAsMbQQAAAkTAAAAAKaVAEH08cIACxAMRgAAAACFRgAAAAAAAKZjAEGi8sIACwaGRQAAZmYAQbjywgALB+hZB0SoT6QAQdbywgALDqcMAAAntAAAAAAAAKRvAEH28sIACwLFHQBBlvPCAAsOBqIAAAAAKHkm2EgnhAcAQa7zwgALBgaPAABnjwBByPPCAAsEqjan5wBB6vPCAAsGhWcAAAcWAEH888IACwRJNuUEAEGK9MIACwrnEwAAAAAAAMVwAEG29MIACwLGIQBBwPTCAAsEKWSERQBB0vTCAAsIBDRsAqUYKy4AQez0wgALFIgDRwQAAKVeAAAAAEhwJ8IAACVaAEGI9cIACwKIfgBBkvXCAAsIx4kAAERw6hYAQaj1wgALAgkRAEHw9cIACwztHqUiAAAAAAAAZDYAQYb2wgALAuajAEGU9sIACxJuGqU2AAAAAAAAhwMAAAAAyl0AQc72wgALCob7AADEVwAABWUAQeD2wgALBGhcxRQAQfD2wgALBulZRRWJPgBBhvfCAAsihrvpKAAAAABEOAAAAAAAAMekAAAAAAAARsgAAAAAailEXgBBsvfCAAsSBqsAAAAAqkUAAAAAAADoY0VqAEHU98IACwKKcQBB4PfCAAsGcgLEB2w5AEH+98IACwJG4QBBkvjCAAsCpq4AQZz4wgALBAgPxx0AQbb4wgALAoalAEHI+MIACwpISyQZAAAAAIgUAEHu+MIACwLlTABBivnCAAsCZ5sAQZT5wgALAgh5AEGi+cIACw5GbgAAAAAAAGRxKimFDABBxvnCAAsOBBZIAycBAAAAACghBiAAQeb5wgALAmRQAEGM+sIACwTqD0ZMAEGY+sIACwSoeSb6AEGo+sIACwJMQQBBwPrCAAsCKkUAQc76wgALBsbFAABHxQBB6vrCAAsKZmMAAAAAAAAHNgBBgPvCAAsEiArHDwBBjPvCAAsMyGIAACwvBggAACa/AEGg+8IACwhJQifoa0MHigBBwPvCAAsKK3oAAAAAAABJBABB4PvCAAsKCANHAwAAAADKcgBBmPzCAAsE6BZmLwBBqvzCAAsCBWMAQb78wgALAgfwAEHS/MIACxBmYAAAAAAAAGf3AACkcM4fAEGo/cIACwKOEQBBtP3CAAsQCDekBAAAhD8AAAAAAAAlQABB+P3CAAsIFAEAAAAApEIAQbz+wgALGAxeBXMAAAeDAAAlEwAAAADqMAAAAAAH9ABB6P7CAAsCzg8AQfL+wgALCgZQAABkPKkIB8oAQYb/wgALAsdbAEGU/8IACwoKPAAA6T0AAAk7AEGu/8IACwREbakcAEG6/8IACwKGdgBBzP/CAAsIK36EXQAAZkUAQeD/wgALBigYAACoUQBB+v/CAAsKBHsAAAAAAACFFQBBlIDDAAsKbQoGxAAAAAALMABBrIDDAAsEiRQHbgBBxoDDAAsK5i0yDwAAAACEZwBB3oDDAAsCpsAAQe6AwwALAuUqAEGAgcMACwQpRicHAEGSgcMACwLGcwBBnIHDAAsGaWcAAEgYAEHKgcMACwLHAgBB4IHDAAsEC3AnnABB7oHDAAsKxskAAAAAAACHawBBiILDAAsEi3jEDABByoLDAAsGZHAAACRHAEHYgsMACwRoY6b/AEHogsMACwQJDYYGAEH2gsMACwKESwBBgIPDAAsCaGEAQaCDwwALAhMEAEGqg8MACwbGPQAAplQAQb6DwwALAoc/AEHSg8MACyLGfgAApncAAAAAyk7GJgAAAAAAAEdHAAAAACg4AAAICCdDAEGChMMACwKEHgBBoITDAAsGyldGzjQGAEHQhMMACwJJKgBB2oTDAAsC5p8AQeqEwwALCAVwAAAAAFIWAEGMhcMACwQJZeZWAEGYhcMACwRoQ6eLAEGshcMAC0QsIAAAbH0AAAAAAAArAAY4AACFQAAAAAAMeAAArA+FAAAAh57LA4ZdAAAAAItqAAAAAAAAzAAAAAAABGqMHSetyGtm4gBB+IXDAAsESFdlZABBiobDAAsOREwLfAAAAADGbQAA5+YAQaaGwwALBuUvAACGrwBBtIbDAAsGSHsAAGorAEHQhsMACwgJSodHAABnsABB/IbDAAsCCwgAQZ6HwwALAsdLAEG6h8MACwKm5ABB1IfDAAsEi1eHXQBB5IfDAAsQqi0AAAAA5Q8AAAAAbArGGABBgIjDAAsECmzmBgBBjIjDAAsEyFoG2wBBqojDAAsGR4UAAIVfAEG4iMMACyhrVQAAykSmJgAAAABIbYaXAAAAAAAAhqoAAEd7qi9mWgAAAAAAAKfEAEHqiMMACwImgABBkonDAAsC58IAQZyJwwALBKo9pxAAQaiJwwALBIoS5g4AQbiJwwALFChDxQGrQwAAaE/EDwAAAAAAAOQ9AEHUicMACwapa8R8KH4AQeiJwwALBOssBi4AQfSJwwALBAomJ8UAQYKKwwALAmaKAEGOisMACwomdAAAAAAAAMeOAEGgisMACwwpJOYVAAAFNgAAZxsAQbaKwwALCCdiAAAAAGtKAEHYisMACwIMCgBB5orDAAsCZXQAQY6LwwALAmalAEGYi8MACyRNJAAA6EXm2u0PAAAAAAAAy3TnkQAAZ3gAAIYgAAAAAAAApkcAQeyLwwALBIlIJtMAQYKMwwALDoaRAAAAAMl6RvAAAOYHAEGajMMACwIlYwBBtozDAAsEZQjJYgBBzozDAAsE5DBpNwBBgo3DAAsC5CEAQZqNwwALAoaOAEGkjcMACwiJKoclAAAncABBwI3DAAsCSm8AQcqNwwALBkVmKyilBgBB4o3DAAsmhDoAAGceAADGbAAAAAAAAKbcNA8AAAAAAACKFsdAAADFZm40RE8AQZqOwwALAkZwAEGkjsMACwTIOIYEAEHQjsMACwLJZABB6o7DAAsGxqUAAAQNAEGCj8MACwKHIABBnI/DAAsOyUOnBQAAAADrIIa9TwUAQbSPwwALBoo6AACofQBB3I/DAAsEDiTnCgBB8I/DAAsGyT6He60QAEGCkMMACwqnEQAAAAAIbUbmAEGckMMACwSpIGRNAEGokMMACwSoF8UeAEHSkMMACwLFVABB7JDDAAsIqCNlBAAApEAAQYiRwwALEIxDxhpoUwAATAkAAAAApw8AQaKRwwALBCVfahAAQcCRwwALAqgpAEHqkcMACwRHp84LAEGGksMACxUlOAAAxVDoDMcKKlCH/QAAAAAAACYAQbKSwwALCqZs8gqmIq4O5wQAQcySwwALBEt1JiUAQdiSwwALBMhFBzoAQfCSwwALAmxbAEGOk8MACwIGyQBBnpPDAAseprIAAAAAq1tHfgAAAABKKgfPAAAAAAAAxoFoekb7AEHKk8MACxKmfQAAAAAzDwAAAAAAAGkbhQIAQeiTwwALFgttB7QAAAAAAABnVQAAxoUAAAAAS0EAQYaUwwALBOQ2qFMAQZqUwwALAqabAEGmlMMACwpGmAAAAABoRCQdAEHClMMACwJEPABB0pTDAAsCxG4AQfqUwwALAmVjAEGelcMACwJnLgBBupXDAAsWx00AACdOAAAAAAAAZyqvAwAAAABFKgBB2JXDAAsCShAAQeyVwwALAmwmAEGClsMACwKH/wBBlJbDAAsEiSZGYABBopbDAAsCR54AQbaWwwALAgQyAEHYlsMACwRLVmdcAEHqlsMACwrGewAAAAAAAOfkAEGOl8MACwKkTABBqpfDAAsSZV8AAMRtAAAAAAAAJHoAAIQMAEHOl8MACwLmOQBB2JfDAAse603GJwAAAAAIJeU5LhEAAAAAxDgAAAAAAADnvlEHAEGEmMMACwRNAgUGAEGSmMMACwolWwAAAAAAAEU3AEGkmMMACwgQBSY4AACkagBBuJjDAAsCbBwAQcaYwwALAma6AEHcmMMACxIsFOUGAABFOAAAxpLKBwAA7BkAQf6YwwALAqdsAEGImcMACwQICqQaAEGgmcMACyxILIdmAAAAAGhdAAAAAAAASHcAAAAAJoYAAIdFAAAAAAAAhVYAAOYXAACEZABB/JnDAAsK6GdGFAAAAAB2BABBlprDAAsCZ5oAQaKawwALAkaaAEG4msMACwINDABByJrDAAsYshIAAAAAAADJcIQZAAAAAChoAADpI8ctAEHsmsMACwQIfIb8AEGGm8MACwKFLABBppvDAAsYBmIAAAAA6UbHTgAAAAAAAGZDAAAAAG4DAEHSm8MACwJmXgBB7JvDAAsCy2UAQYicwwALEGh7AAAAAOcfKl9EGAAAxocAQaScwwALCAh/AAAAAIeuAEHSnMMACwZFRukhJnIAQeicwwALCAsoJhOsBWc7AEH+nMMACwYmWQAA5SgAQZCdwwALCIlLBkVrAOYsAEGgncMACwSpagUKAEGyncMACwYG/MgA5W4AQcCdwwALBuh5AAAqeABB0J3DAAsEiXJm7ABB/J3DAAsUiQylDMowh1gAAAAAAABlSeh6B0AAQaaewwALCqZQAAAAAAAAZmoAQbqewwALDkQ+iBEnGwAAAAAAAAa1AEHansMACwIlcQBB+J7DAAsIaFAnDQAABmMAQZifwwALAhYHAEGun8MACwLlQgBBzp/DAAsCh9oAQdqfwwALAkVeAEH0n8MACxRxCwAAAACmwwAAZgsMY2R1cwBGLgBBkKDDAAsC8AsAQZqgwwALBudE7wBnTQBBwqDDAAsCxo8AQd6gwwALAudTAEHqoMMACzIEbwoupBIAAAAAKA3HjQAA53oAAAAASTnkAwAAZlAAAAAAAAAEJwAAhVwAAAAAAABHzQBBqqHDAAsChB0AQbqhwwALBGcHiggAQcihwwALBGtsZ2MAQdShwwALBEx5JvcAQeahwwALBoaPAADkYABBnKLDAAsCSHkAQbCiwwALBCpT5AgAQbyiwwALAmtnAEHSosMACwLkOwBB5KLDAAsEaAznSwBB9qLDAAsaBvUAAAAAAAAkYwAAAADrbCQFAAAAACwexwsAQZijwwALCCkaAAAAACa7AEGyo8MACwpFDAAAAAAAAOQ5AEHEo8MACwJuJABB2qPDAAsCBXsAQeajwwALAqYZAEH0o8MACwipGUQFAAAmZABBhqTDAAsIZE8AAAAAq0IAQaqkwwALDmQuAABGoAAAAAAAACVnAEHKpMMACwqnLOltZjoAAKcnAEHipMMACwKGcwBB7KTDAAsEKGpm4ABB+KTDAAsG6m/m4GsFAEGSpcMACwKH4wBBoqXDAAsCpUEAQc6lwwALDMYNAAClPQAAxBUoNABB5KXDAAsE6UinWwBB9KXDAAsELTzlGgBBgKbDAAsCqDsAQZKmwwALAoUmAEGkpsMACwwoJcUPAAAAACst58EAQbymwwALBOhs5uEAQcqmwwALBmejAACkVQBB3qbDAAsKpWMAAEZrAAClRgBBgKfDAAsGSjaEH0lnAEGSp8MACwLkYgBBnKfDAAsIqj/lHEoWJ0sAQbSnwwALBHAF58YAQcKnwwALAmfSAEHMp8MACwKrBQBB4qfDAAsCB4wAQYiowwALEIlFxT0AAMQxAAAAAAAAx4AAQaSowwALAg0VAEG6qMMACwaneQAARFAAQdKowwALAubJAEGEqcMACw5NL0dKAACniAAA5FQQDgBBmqnDAAsKhrqIQ8erSVnHuQBBrKnDAAsEKGfmvABByqnDAAsSBncAAAAACFzlEQAAhFcAAIbAAEGCqsMACxSnwgAAAAAAAIVry3sHAAAAAADrZABBoKrDAAsIaRBlQAAAxFAAQbCqwwALCKkOB1uIPyYPAEHEqsMACwKqLABB0qrDAAsCpR0AQeaqwwALAgffAEH+qsMACwokWYorBsAAAEdcAEGWq8MACwJFNgBBpKvDAAsGyi2n6uoEAEG2q8MACwKESABB1KvDAAsCKW0AQd6rwwALDmcVAAAmTshEZw3sKuR1AEH6q8MACwMFYA4AQYqswwALCuRjAAAAAAAAxG8AQbaswwALAifRAEHOrMMACwKGgwBB7qzDAAsaBiIAACQ3AAAAAHQAJAEAAAAAAADHkwAARqgAQZitwwALF0hVAAAAAIZ9DwMAAAAABnkAAAAAAABEAEHsrcMACwwsFwAAAAAAAElIRzsAQZSuwwALBC4ORUIAQcKuwwALAoVFAEHQrsMACxIIAqakAAAAADIMAAAAAAAA6lcAQfKuwwALFoZvAAAAAAAAZsQAAAAASTVGFwAApokAQZivwwALBCl1JEkAQbyvwwALBItQZyQAQcivwwALDKldAABJFAAAAACkLwBB9q/DAAsCRl8AQaiwwwALBIlOpQIAQbywwwALAutyAEHQsMMACwIqTwBB2rDDAAsChykAQe6wwwALAie6AEGiscMACxAEaMgxAACoUAAAAAAAALABAEHGscMACwaGAgAABGQAQeaxwwALAib5AEHwscMACwooYAAAAAAAACtTAEGOssMACwJG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AACSKJQoligAQfiDyAALGJcoAAAAAJgomigAAAAAnCgAAJ0oAACjKABBoITIAAsSpCgAAKUoqigAAAAAqygAAKwoAEHAhMgACwa1KLYotygAQdiEyAALDrkoAAAAALsoAAAAAL4oAEHwhMgACwjAKAAAwSjCKABBgIXIAAsSxCjFKAAAxigAAMcoAADMKM4oAEGchcgACwLQKABBqIXIAAsC0SgAQbiFyAALGtMoAADVKAAAAAAAANYo2SgAAAAA2ygAAOUoAEHchcgACwToKPEoAEHqhcgACwjyKPMoAAD8KABBhobIAAsgAykAAAAAAAAGKQAAAAAOKQAAGSkcKQAAAAAdKR4pICkAQbaGyAALAiIpAEHAhsgACwYlKQAAJikAQdqGyAALFicpKCkAAAAAMCkAADkpPCkAAD0pPykAQfqGyAALFkIpQylEKQAARSkAAAAAAABGKQAARykAQZiHyAALDE8pAAAAAFApAABSKQBBuIfIAAsSWSlaKVspXSkAAF4pAAAAAGIpAEHUh8gACypmKQAAAABpKQAAAAAAAGopAABrKQAAbCkAAG0pAAAAAG8pAACCKQAAgykAQYiIyAALOIUphimHKQAAAAAAAJYpAAAAAAAAlykAAJopAACbKQAAAAAAAJwpnSmfKQAAoikAAAAAoykAAKspAEHIiMgACwKtKQBB3IjIAAsKrikAAAAAAACvKQBB7ojIAAsQsCmxKQAAsikAAAAAAAC0KQBBionIAAsQtikAALopAAAAAMQpAADJKQBBoonIAAsKyikAAAAAAADMKQBBtonIAAsGzykAANApAEHKicgACxDRKQAA2yneKeApAAAAAOIpAEHqicgACwLjKQBB9InIAAsC5ikAQYCKyAALBucp6in3KQBBkorIAAsI+CkAAAAA+SkAQaaKyAALAvwpAEGwisgACxL+KQAAAAAAKgEqAAAAAAAABCoAQc6KyAALFAYqAAAAAAAAByoAABEqAAAAABQqAEHuisgACxAVKgAAAAAAABkqAAAAABsqAEGOi8gACxQcKiAqAAAAAAAAJSoAAAAAAAAnKgBBtIvIAAsmKyoAAAAALCoAADgqAAA5KgAAAAAAADoqAAAAAAAAPCoAAAAAPioAQeyLyAALAj8qAEH2i8gACwRAKkEqAEGCjMgACwZDKgAARCoAQZCMyAALDEUq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xpTKAAsop2gAAKhoqWgAAAAAAACqaAAArWiuaAAAAAAAALBoAAAAALNoAAC0aABBgJXKAAsOtWgAAAAAuGgAAAAAuWgAQZyVygALBrxoAADJaABBsJXKAAsMymgAAAAAy2jNaNJoAEHElcoACwzTaAAAAADhaAAA42gAQeKVygALEORoAADlaOloAADqaAAA62gAQYCWygALCvxoAAD+aAJpA2kAQZKWygALBAppDmkAQZ6WygALBA9pEGkAQayWygALAhRpAEG8lsoACzgfaSFpImkjaSRpJ2kAAAAAAAApaSppAAAAAC1pAAAAAAAAMGkAAAAAMWkyaQAAAAAAADNpAAA0aQBB/pbKAAsCNWkAQYyXygALFjlpAAAAAD9pAAAAAEBpAAAAAAAAQmkAQbCXygALDExpAABOaQAAAABTaQBBypfKAAsKVWkAAFlpWmlcaQBB3pfKAAsOXWkAAF5pAABiaQAAZGkAQfiXygALDGZpAABqaWtpAABuaQBBjJjKAAsQe2l+aQAAAAB/aYJphGmFaQBBrJjKAAsKhmmHaYppAACLaQBBwJjKAAsKkWkAAAAAAACSaQBB0pjKAAsilWmWaZdpmmkAAAAAnGmdaQAAAAAAAJ5pomkAAAAAAACkaQBBkJnKAAsCpWkAQaCZygALAqZpAEGwmcoACxanaalpAACqaQAAAAAAAKtprGkAAK9pAEHsmcoACw6wabJps2kAALVpAAC4aQBBhJrKAAsIvWkAAAAAvmkAQZqaygALAsBpAEGsmsoACwLEaQBBuJrKAAsOxmkAAMdpAAAAAAAAyWkAQdKaygALCMppAADLac5pAEHimsoACwLPaQBB7prKAAsc0GnSaQAA1mkAAAAA12kAANtp3mkAAAAAAADfaQBBkpvKAAsK4WkAAAAAAADiaQBBqJvKAAsC42kAQbKbygALBORp7WkAQb6bygALFO5pAAAAAPRpAAD2aQAAAAD6aftpAEHem8oACwILagBB6JvKAAsEDGoNagBB9JvKAAsUDmoPagAAEGoAABdqAAAAAAAAHGoAQZacygALGCdqAAA1agAAAAA3agAAOWoAADtqAAA+agBBuJzKAAsCQGoAQcKcygALAkJqAEHMnMoACxJDagAAAABEagAAAABGagAAR2oAQeacygALKElqAAAAAAAATWoAAAAAUGpTalRqVmpXagAAWGoAAFlqWmoAAAAAYWoAQZadygALCmNqAABlagAAZmoAQbydygALGGdqAABqamtqAAByagAAAAAAAHNqAAB1agBB/p3KAAsOdmp3anpqAAAAAAAAe2oAQZieygALCINqAACMao5qAEGynsoACwagaqFqpWoAQcSeygALAqZqAEHSnsoACwSwarFqAEHgnsoACxS2agAAuGoAAMFqAADCasNqAADEagBB/J7KAAsKzGoAAAAAAADUagBBkp/KAAsG1moAANdqAEGgn8oACyTbagAAAADeat9q4WoAAAAAAADlagAA52oAAPBq8moAAAAA82oAQdCfygALCARrAAAFawxrAEHin8oACwIQawBB7J/KAAsSPWsAAAAAAABAawAAAAAAAEJrAEGMoMoACypDawAAAAAAAERrAAAAAEVrAABJa0trAAAAAE1rAABOawAAT2sAAFVrWmsAQcKgygALAlxrAEHQoMoACwJdawBB3KDKAAsIZWsAAGZrbmsAQfygygALFndrjGsAAAAAAACNa5lrAAAAAAAAmmsAQaahygALDptrAAAAAJ1rnmsAAJ9rAEHCocoACx6jawAAAACzawAAtWu2a7druWsAALprAAAAALtrwWsAQeqhygALCsJrAAAAAMRrxWsAQfyhygALCMxrAAAAANBrAEGaosoACwLYawBBsqLKAAs02msAAAAAAADiawAAAADkawAAAAAAAO9rAAAAAPBr8msAAPRr9msAAAAAAAD7awAA/GsBbABBgKPKAAsIA2wMbAAADWwAQZajygALRg5sAAAAABBsAAARbAAAAAAAABVsAAAXbAAAAAAAABlsGmwAAAAAAAAibAAAAAAAAD9sAABAbEFsR2xIbAAAAABQbAAAUWwAQe6jygALIlNsAAAAAFRsAABVbAAAWmwAAAAAAABebAAAAAAAAF9sYGwAQZykygALTmFsYmwAAAAAAABjbGRsZ2xobAAAAAAAAHhsemwAAAAAAAB+bH9sAACAbIFsAAAAAIVsAACIbAAAimwAAAAAj2wAAJBskWycbAAApGylbABB+qTKAAsKpmwAALFsAACzbABBjKXKAAsctGzVbNZsAAAAAAAA2GwAAAAAAADZbOxsAADxbABBsqXKAAsO8mwAAPNsAAAAAAAA9GwAQcqlygALLvls+mwAAAAA+2wAAAAA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eAAAAAAueAAAMXgyeDN4Nng5eAAAAAA7eDx4PXgAQZrRygALCkZ4AAAAAAAASHgAQazRygALAlp4AEG80coACxRceGN4AAAAAGd4aHgAAGl4AABreABB3NHKAAsebHgAAAAAbngAAAAAAAByeAAAc3gAAHV4dngAAH14AEGE0soACw5+eH94AAAAAIF4AACDeABBnNLKAAsqhHiKeAAAAACLeAAAkXgAAAAAkngAAAAAlHgAAAAAlXgAAAAAAACheKN4AEHQ0soACwapeAAAq3gAQd7SygALHK54AACveAAAsXgAALJ4AAAAAAAAuHi6eAAAvXgAQYbTygALDr54AAAAAAAAw3jVeN54AEGc08oACwjfeAAAAADheABBsNPKAAs84ngAAAAA43gAAAAA63jseAAAAADweAAAAADxePJ49ngAAAAA+Xj+eAAAAAAAAAB5AAAAAAF5AAACeQZ5AEH608oACyoSeRN5FnkAABh5AAAAABl5AAAAABt5HXkAAAAAHnkjeQAAAAAmeQAAKHkAQazUygALDip5AAAAACx5L3kweTF5AEHW1MoACwYzeTR5NXkAQejUygALAjh5AEGA1coACzQ8eT15PnkAAAAAAABBeUN5RXkAAEd5AAAAAAAASHkAAEl5AAAAAAAATXlOeU95AAAAAFd5AEG+1coACxJaeQAAXHlfeQAAAAAAAGB5YXkAQdjVygALFmN5AAAAAGR5AAAAAAAAZXlneQAAaHkAQYLWygALFG95AACmeQAAqHkAAAAAqXmqeat5AEGy1soACwiteQAAr3mweQBByNbKAAsQunnDecZ5x3kAAAAAAADIeQBB5tbKAAsay3kAAAAAAADSeQAAAAAAANh523kAAAAA3HkAQZDXygALAt55AEGc18oACwrfeQAAAAAAAOV5AEGu18oACwTree95AEG618oACwb/eQAAAHoAQdTXygALCgF6BHoVegAAFnoAQerXygALCBd6AAAAABl6AEGE2MoACw4aeht6AAAAABx6AAAdegBBnNjKAAsSHnofegAAAAAgegAAInoAACN6AEG42MoACywxegAAMnoAADR6AAAAADV6N3o4egAAAAA6egAAAAAAADx6P3oAAEN6AABEegBB7tjKAAsCRnoAQfjYygALAkd6AEGG2coACwJIegBBktnKAAsMSXpMek16U3oAAFV6AEGo2coACwZbegAAXHoAQbjZygALCl16X3oAAAAAY3oAQczZygALAmV6AEHY2coACwhoegAAAABpegBB7NnKAAsCanoAQYbaygALAmt6AEGW2soACwJuegBBoNrKAAsCcXoAQbLaygALAnN6AEHA2soACxR0egAAAAB2end6AAB4egAAAAB6egBB3NrKAAsIe3oAAAAAfHoAQfjaygALDIN6AACMegAAAACNegBBltvKAAsekHoAAJx6AACdegAAoHoAAKl6AACteq96sHoAALF6AEHA28oACw61erd6AAAAAAAAuHq6egBB2tvKAAsQvnq/egAAAADAegAAwXrIegBB/NvKAAsCyXoAQY7cygALAsp6AEGc3MoACwLLegBBptzKAAsCznoAQczcygALENJ6AADUegAA2HoAAAAA23oAQeTcygALKNx6AADleul6AAAAAOp6AAAAAOt6AAAAAOx6AAAAAAAA7XrxegAA9HoAQZTdygALBAF7AnsAQabdygALBgR7BXsGewBBtN3KAAsGDXsQexF7AEHM3coACwIVewBB1t3KAAsOFnsAAAAAF3sAAAAAGXsAQfbdygALEBp7AAAiezB7M3s0ewAANXsAQZLeygALJjp7QXtHewAAAAAAAEh7SXtKewAAAABMe097AABRewAAAAAAAFJ7AEHA3soACwJTewBBzt7KAAsaVHtWe1x7XXsAAAAAXntge2F7YntrewAAbHsAQfDeygALKG17AABvewAAcHtxewAAAABze3R7AAAAAHh7ensAAAAAAAB7ewAAf3sAQaDfygALAoB7AEGu38oACwKBewBBut/KAAsCgnsAQcjfygALAoV7AEHc38oACwSGe4l7AEHo38oACxKLewAAmXsAAAAAmnsAAAAAm3sAQYzgygALBpx7AACeewBBmuDKAAsYoHsAAAAAAACkewAAAAAAAKl7AAAAALx7AEHA4MoAC9DiB8l7y3vMewAAznsAAAAAAADQewAA1nsAANd7AAAAAAAACADqA4gA9wMEAKsCBApFAYoKfQAHCzwCCQtQAgsLqAILC0oDCwucAwwLZAEMCyYCDQs9AQ0LcgENC9UBDQvXAQ4LjQESC0UAkguRAIYA8QSICxYChgCXBQsAigCMACgABACbAAcAmQYECs4ChwrABAQA9QAFAJcABQDlAgYAewQH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Cg8ABQrLAQcKMQQICvEAiApOAYoAhwGHAKAHhQsNAggLgQILC4QBjAtEAo4AfgCGAIAChADjAQcAUAYJAEUABgpEAQYKCAIHClIBBwrBBggK5ACLCu4CBQvtAYYLEAKHAN4CBAuuAIcLjwOKAOABCQDvAZIAaACHCsECCQDYAQQKSQAGCmQCBwqfAwcKMgUHCh4HCArZAAkK/QIJCv4CCgqYAQsKMwALChkDDAoKAQ8KngAUClkAlgogAAcLJAKJCzoABAsgAAUL1wAGCw0BBwv2BgcLZAcKCxAACws2AwsLugONC+EBhABqAwkA5QAFCoUBiAp8AgcL1QaIC90BhgC0AwULNAGHC0AEBADsAosA8QOIChUABgArAocA5QEFC34ACAspAQkLbgEJC70BDAs1AAwLdgGNC+wBBwsPBosLaQGIAMEAiADYAQgAjQINAF0AkwAOAIQA2AOEC68ABQCsAAYAsweEC60ClQsIAIULHQMNAFMABQq9AAcKugEHCrsBCAoZAQwKrgCNCgUBhgAgBoULNQKLAIABhQAEAQcA9gIHAHADBwBPBQkApAAJAKcACgCcAAoATAIMAGUADgAwAA8ARgAGCgIABwruBAcKyQYIChYACAoOAQgKZAIJCjgBCQq0AQoKNwEKCm8CCwpIAAsKSgELCscBDApBAQwK+AEMChICDAofAg0KEQANCpwADQpOAREKPACUCkAABAv8AAcLLAQKC7IBCwvkAAsLqgENC+cAEgtqAJQLVwAHCmIBCgqaAYsKLwMGAG8BBwqeAgcKLwUICpsBCAqzAQkKjQIJCuQCCgqBAQsK3gALCkQBCwo9A4wKYwIHAJYEBgqmAIcKdgGSAHkAhAA8AwUL5wCKC/0BBwtZAgkLFQEJC6ICCguyAAoLAQEKC6IBCwsTAgsLIAILC0kCDAtxAAwL2wENC2MAjgusAYYABQaHC/MGBQBXAYYKjgGHCjIAhwuTBgQAuAEHADkACACnAAgAdwEJAFIACQAxAgkA6AIKAGwCiQvoAoYAngMGCgUCBwqHBAoKbQKLCsAAiQA7AwgAwgCIAPQCCgrfAIsKhQIHCkAAiAr1AAQLjwEFC3cABQvuAQcL7wKJCywChAAoA4cAFgAHCuMGjAo2AQUAfwIHAOEECwCAA4YLSAKGAE4GhwBcA4cLYQQFCoEABgo9AIcKswME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Cr0GBwpNAAcKqgEHCiUFBwpLBQgKfgAICjMCCQoLAgkK7gIKCjYBCgpEAwsKKgALCj4BCwrbAgwKRAAMClwADAr7AQwKtAINClEADQruAA0KdgEOCrQBEgqKABMKTgATCm8AFAo3ABQKTQCUClwAjQqiAQcAJweECqoDBgAIA4YAkwOKCl8BBQtcAQYLCgIGCoQGBwrbBQgKdQAJCjoBigquAIcKwwKEAGUChQqTAYQLiAEFC7EBCQt5AosLdQKFAPsChABuA4QA0QOEAGQABgDPAQQKLAAFCjcBBwp/AgcK+gIHCiMHCQoIAAkKzgGUClMAhgvqAAQKWgEHCnMACQq0AAkKyAGKCmsBBQBqAQUAuwEGAD4BBwD7A4sAbwIFAM8BCAAoAQcLjAAHC54HCAuoAgsLMQOTC1gABwvGBIoLggGOAIkAhADGAQcAegcGCwUABwobBAkKIQILC/kADAs5ARALQgCRCxoAhwD3BZEAOgCUCzsABQAwAAUAlAEGAC0CBwDKAQgAVQIKAMcBCgBeAgsAMQALACQCDADcAQ0AEgCNAMIBBQvDA4YL7QaFANkCigtKAgUAugGHAMAHhgDBAZAAKAAEAFUDBwu0AAgL/QGICxgDBgq5AAcKawcJCmsDiwqhAoYLDAIMAOMABApHAQUK3gEHCjQFiArxAgYA0wUFCvwDhQr+AwQKZwCFCpEBhAujAwQK8wGHCo0FBQA3AAcAeAGMAKEAhQDCAQYAlgSGABoGCgA+AA0AkAGHCy0HjADPAIcAZQMECwUDBQtqAokL9AKECmAABADVAAcA3wAIAFAAhwrIAwQLWgAFC1EBBQshAgcL8gIJC7oACgtIAAoLDgMLCwECCwtBAgsLYgILC3kDCwvBAwwLYgEMC2oBDAvNAQwLUwINC08Ajwt5AAcAfQEHACYDBwA0AwgAYgEIALUBCAATAwkAkQIKADoACgBTAQoA7QILAJIDDACiAA0ASwAOAGoADgDGAA4AQAEOAJ0BkgArAIgA6wKIALoDhgAxBIcALAIHC5cACQtJAYsL/gAFALQChgBzBQYKMwKJCuAAhgC/AIQAJAMJC7sACgskABELLACSC0AABwulAAcLlwOICwUCBAv6AQULJwEHC5AGDwsOAJALBQAEAMICBgCiAAcAqAeIAD8DhwtgBQcL2wMJC7ACCgsKAgsLFAOM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C8EBDgs1AA8LDQAQC0AAkQspAAYAdAMGAPsDhgB+BAYL5wYMC8IAkQtrAIgK9wGFC0gDBwCfAoYK0gGEAHgDBACVAIoAcAEEAJoABwBuBIgAaQCHANcDCQuCAgsL7ACOC8EABAAfAAYArQEHAMIDCQDKAYsAswIGAIMChgBOBIQAOAEEC0QABQt6AgYLggEHCxoDCAsRAQkLMwIKC2kACgurAAsLXgCLC2IBhQDkAocAagYEC18ABwugAQgL0wCLCz4DhADsAIoK8QAHC9sCDQsUAI8LCwAFAEQDBQBZAwYAkAaHADsACgBEAAsA7gGYCwYABABRAIsAYwOHABsDhQuxAgQA6QMFABoBBgCMBwYAuQcGAMMHBgDIBwgAigIIAJcDCACYAwgAmwMIAJ4DCACfAwgAowMIAKsDCACzAwgAvAMIAOUDCQCLAwoAtgMKALkDCgC6AwoAvAMKAL4DCgC/AwoAxAMKAMoDCgDMAwoAzQMKAM8DCgDQAwoA1AMKANUDCgDYAwoA3AMKAN4DCgDjAwoA5wMKAOoDCgDrAwoA7QMKAO4DCgDwAwoA8QMKAPQDCgD2AwoA9wMKAPsDCgD8AwoA/gMMAL8DDADBAwwAwgMMAMMDDADEAwwAxQMMAMcDDADIAwwAyQMMAMoDDADLAwwAzAMMAM0DDADOAwwAzwMMANADDADRAwwA0wMMANUDDADWAwwA1wMMANgDDADZAwwA2gMMANsDDADdAwwA3gMMAOADDADhAwwA4wMMAOYDDADnAwwA6AMMAOkDDADqAwwA7AMMAO0DDADuAwwA7wMMAPADDADxAwwA8gMMAPMDDAD0AwwA9gMMAPcDDAD4AwwA+QMMAPoDDAD7AwwA/gMMAP8DDgDbAQ4A3QEOAN4BDgDfAQ4A4AEOAOIBDgDjAQ4A5AEOAOUBDgDmAQ4A5wEOAOgBDgDpAQ4A6gEOAOsBDgDsAQ4A7QEOAO4BDgDvAQ4A8AEOAPEBDgDyAQ4A8wEOAPQBDgD1AQ4A9gEOAPcBDgD4AQ4A+gEOAPsBDgD8AQ4A/QEOAP4BDgD/ARAAcQAQAHIAEABzABAAdQAQAHYAEAB3ABAAeQAQAHoAEAB7ABAAfAAQAH0AEAB+ABAAfwASAPIAEgDzABIA9AASAPUAEgD4ABIA+QASAPoAEgD7ABIA/AASAP0AEgD+ABIA/wAUAH0AFAB+AJQAfwAHC7UGBwvpBooLIgIHC2cEBwskBgoLKQEKC6YBCwv8AgsLKgMMCwgBDQtmAA0LLAENC+QBDguTAA4L5QARC0cAEgt2AJMLeAAGAHwEhgAyBoQABwOHCroDhQtgA4ULoAOKC70AhwqmBwYKJQIICiIACAobAQkKpQCKCtsBBQqMAgUKvQKHCsEBhwu3AgQKjwIHClIDEQpLAJIKiQCMC6oChQsLAggAygOICp4CiAsrAgcLTAAICywACQt0AwoLRAILC48BCwt+Aw8LegASC5AAkws9AAYKnwAGCmwBBwoEAgcKnwWJCgYCBABHAAUAeAEHAHcAigCZAo0KlwALADsDDgAiAI8AlACFCwYCBADfAYcL+waHCzwHhwrhAwcAXwKIAGMAhgCoB4QAGQMEACkABQBKAAcAWwYLAGcDjABrAgcAXgALAEkBCwDFAwwA8QAOAGIBDwAWAJQAPwAHCvUBCQpvAAoKjQALCkwBDQorAA0KrQEOCoIADgqfAZEKZgAJANEAiQAsAYYA2QWKC/8ABAumAwULigCIC2IChQBiAAYAJAUKCyQDigtAAwgLYAAJCyQACgtfAgsLpwELC7oBDAs1AQ4LxwAPC1oAkQtuAIQAzwEFCpUAiArpAIUKpwMEC4wCCAtAAQkLDQAJC44BCQvXAgoLSwAKC7gACgvmAAoLNAIKCzkCCwvNAwwLRgAMC70ADQs5AA0LAQEWCwYAlgsQAI4AIwEMCkYCkgqDAIgKIQOFANgDkQt0AAQLtAKFC0EBBAC2AAYAzQCHANwABAAqAAkAzQAJABIDigCTAgYAIQMLC4IAjAthAoQAewIFC1kBhwv4A4sAFQKEAHMBBAAQAYcARAMGAAIFhwtMBAUAOQOGAGgGhwstBYULoQIECx8BhQv6A4cAZQEGANMBiQBvAwcAPQGHADkCBgCcA4YANAYFCyIABQqWAQoL1AIMC7wBDQtiARILIAAXCxgAFwsfAJgLBQAGAAMHBgArBwYALAcGAEAHCABMAwgAUQMIAFYDCABmAwgAdwMKAFQDigCuAwYKRQCHCnUAiQAzAQQAsAMGAAcHBgAhBwoAUAMKAGsDCgB/AwoAgwMKAIYDjAAFAwsAKwANAEgAjQCOAIcKJgeGC34BBAqwAYcKOAOEC0kBBwAcB4sLfACFCjoDhQANAoQLigMH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CugCjQu6AQoKawCMCrQBhwv3AYYAigSECp8DBwAeAAgAVgAIADsBCAC8AgkAQAIJAFoDCgCeAQsANgELAHgDCwCIAwwAaQENAPgADQBzAQ4AjgAMCp4CkgpeAIYA0QIEC3EABQujAAUL3wIHC/EDBwp9BAkLCQAJCpwACQsDAwwLWgANC4oADQuaAY8LgACKAEcDhQoKA4kAaQKFCvYBCArEAAoKGwGLCpYBBgCsAQcADAIIAKkACADqAAkA4AGKAIYChQpXA4YAcAYHALUEigB9AgcAPAYEC6cDhQs3AwULDQEHC7IBBwt7AwgLUwEJC74CCwtSAgsLzgKRC2QABwtuAwkL5QGNCwgBBAAKAQgABAAJACcACgCmAAsAlgMMAHsCFAAKABYAGwAWACsAFgA0AIYLsQYHCngFCQq+AYoKLQCHC4QDhABeA4YAEgaHCwkEEwAQAJMLEACHC7gEBwCdAIgAFwEGAFwCiACHAQ0KxwEPCmMADwqBAJAKRACHCqwABwCxAwsAyQKLAOgCBADNAwoAbQMKAKkDCgCqA4wAxwKLAP4DhAo4Ao4LjwAEADcCCQBbA4QK3AIHADYHiAB0AogK3QKFAPoCBAqsAYcK/QYKABADDQC/AAcK3weMCpkChQAqAQcAeQIHAIkDBwCNAwcAAgYJAP8CjAB8AooKJgOEABsDiwAtAYcAsgcFC3EChwtRBocLEwEHCyUACAupAQgLtQIJC9ACCgt8AQoLfgILCxEBCwszAQsL2QEMCz0AjwsrAIcLxgCGANQEBwBxAQwAhAIMAIUCkABaABMADwCVABsABgBHAAcATQMIAKAACQA+AQYKVwaGCpEGhgCnBYYA5wSKAN8CCABMAIQLqAAGCtQGCArLAgkKIgMKCi4ACgozAw0KNAEOCl8BDgprAZIKQwCHC1sABgDaAQQKPwCFClsBhQrtAooASQOFCm4BBgBEA4QL4QCHAFYGhwpZAIwA3wKGAEEGiguRAAYAbgWJACQDjgCKAQYLDwAHC0YACgvwAJMLXQAGAGAAhwCSBQQAiwKFACEBBwu8AwcK0QMHC4UEBwviBQcLRgYHC08GBwtTBgcLyAYHC+8GCAtOAgkLRAEJC+ACCQsGAwkLCAMJCxADCgs3AgoLxAILCwYCCwtlAgsLtwILC8wCCwvjAgsLAgMLCwMDCwtQAwsLWQMLC6MDCwuzAwwLRgEMC4MBDAvkAQwLEAIMCygCDAtlAg0LvQANCwABDQtUAQ0LsAENC7QBDQu4AQ0LxgEOC64ADgvcAA4LHAEOC4YBkQt5AAcAsAIIACMACQD/AQoA/wKTAHYAhgCbAgQAAQIFCjgDhQqtAwcKuAEICuYAiwpqAIYA8geHC3cFjwtCAIcL+QUEC5EABguwAAcLiwEJCzICkAscAIQL9QGEAMAChgD0BQcANgSGC9ABBgv9AQoLUgAUC1sAlwsNAAQA0AKFADIBhQCvAQcArAQECpIDBQogA4UKVAOHC6UECgA2AI0KcwAHCjQCjgqoAAUA0AEGAOwABwC4AgcAkgMHAFQEBwCoBQkADwAJADQCCgAOAAwANQINAMEBDgA1AA8ADQAQAEAAEQApAAQKlgOFCmwDBgCKBYYK5AYEClwAhQoSAYYAiwMEC3IACAr1AQkL7AENC84BjgvXAAQLTQAFC2kBBguLAAYLkQEGC5QBBwudAQcLywIHC7QGCwsXAQwLswAMCwIBDQv0AI4LZgEGAOcGDADCAJEAawCGC7UGBQrnAo4LSQEECjEABwoYAYcKYQYFAEgDBwslBAgLUgALC/oADAukAY0LuACHC9QChgCEA4gKLwCGAJwFkAsAAAYAowIHAPADBwAYBgkAggILAOwADgDBAAUKEAEFCowDBQquAwgKxQAJCi8ACwoaAosK5gIEAEQABQB0AgUAegIGAIIBBwAaAwgAEQEJADMCCgBpAAoAqwALAF4AiwBiAYcKdweJCnsDBABfAAYAEQUGAEQGBwCgAYsAPgMGCwEChwscBAcA2wINABQAjwALAIkLgwMKAFIDjAC5AgQAlgIHC4kFDAt+ARELMACYCwwAhQDgAoQAXQMECpcBhAowAo0K6gEGCyECBws1AgcLhQYKC3IACwuCAowLagIGAGcDhgDoAwUAYAMKAIgCCwCfAg8ALgCFCwUAhQCgAwsAWgANAAcABArbAQsKIwANCkcADQqxAI4KpgGIAEwBhwvAAIYAHwSIC/sCCwDaA4wAqgIHAEwACAAsAAkAdAMKAEQCCwCPAQsAfgOPAHoAhwvVBIcKfAILACwBBgreAAcKVAYICpkBiQq1AgQLVwAFC/oACgtZAg0LKgENC2EBjQt4AQUABgIKAFQBCwCvAJUAEACMAAMDBgBUBIkAPwOEAEQDhwA8BwQAvQMGAAwHCABKAwgASwMIAFMDCABXA4wA/wKHCy4DBAs5AAcLqwQHC54FBwsMBgcLKwcHC3AHCQv1AgoLXAKLCwcChQpyA4oA9gAEAKYDBQDKAAgAYgIHC2kHDAsiAQ0LUAANC7UBkQtKAAgAYAAJACQACgBfAgoAJAMKAEADCwCnAQsAugEMADUBDgDHAA8AWgCRAG4AhAqqAQcAjgIIAPAABgo6AAcK6QIHCrEHCAqjAgkK3wEJCtsCCgpKAQoKUQIKCjEDCwogAAsKhQALCt0AkQpEAAkADQAJAI4BCQDXAgoASwAKALgACgDmAAoANAIKADkCCwDNAwwARgAMAL0ADQA5AI0AAQEEC9EAhwuGAwcAhwGJChoChgCTAQYLLwEHC08BBwudBQcLhAYICykCCAuMAggLkAIJCy4CCwvnApULEgCECy8CCwBLAI4ACwEGAC8DjQsCAI0AbgGJAHcChQv5AwUAWQGHAPgDhQvFAoYL0QaFCjYCBwC4AwYKMAAJCosACgqPAQsK1QEMCnoCjQrfAIUAoQIJAFIDBwsIAIgLzgAGAJYClQAjAAQAHwGFAPoDBgpyAAcKyAQHChQGiAoDAAgKQAKJCgsBBAB0AwUAIgAKANQCDAC8AQ0AYgESACAAFwAYABcAHwCYAAUAhQqlA4QLCAOKAJcAiACrAYYAfgGEAEkBCQBOAwoAOwOKCyEACQAXAQoAlwEOAFQAFgASAIcLEQWIC5YBhACKA4gAbgGGAEsDhgCjBYcAXAWKAOADBAB7AAUAXQIHAOUFiAAkAIQAiQIIC68ACguoAIoLPQKFAP8ChgD6A4cLGQUMCh4ADQqUAA4KVwAOCrYAEAoqAJQKRgCGC18CBAARAQUAkgKFAOMDBgBIAIsLrgAKAOMBDABwAQcKOAAHCsUHCApRAQgK4gIJClgCDQq/AY4KXAAFCxADigqaAocAQQWLC3IDhgANBYUATQKGAMQHBQB1AAYAAgIGAB0CBwCMBAcAnAUIANwACACIAgoAsAKLADACiAB7AQUArgIHCmIDhwqLBIQKSAEJCw4ACQu5AQoLMgGLCwkABAplAIcKkwQFCkEDiAroAgULoQAHC0cDhwt3AwcAxAAKAP0CCwBbAQsAKAILABYDDAAHAQ0A9gANAA4BDQCLAQ4AsAAOAL4ADgCOAQ4AnAEP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C90CCQvCAAoLXAALC8YADAtUAAwLVwANC4AAkAtKAAUAVQEHAGkECwCeAQQKMwAGCgQABwpPAgcKUQMHCrcDBwpNBgcK4AYHCsQHCQqyAQoK8gILChkAiwolAIUKhgOHCqADhwATA4QAtAGGCg4BBwAzBocAqwYGAHkBBwABBAkAZQKRAGgABwvWAwcLUQUKCyAAjws4AIsAYACEAMMBhAqgAY4KdAEFCpgABQrFAAcLMgEHClQBBwpjAwoKJAIKCkUCCwoGAAwKAwAMChMADgpuAI4KIQGGAKgChgthAgcA4wEHCr4ACAocAAgKjQAICrwBCAorAwkK1AELCk4BDAoYAAwKggGMCkACCgCUA4UK9QIFCtEChwoRBoULsgCGAKkDhAqCA4UA4wKTAFIAhwCXApIAgAAFChUBjQr3AIYAPwSECrMBBgt9AQcLhQIHC7YCiAsiAgcA9wGHAF0HBgCtBwgAnQOKALsDBABxAAUAowAFAN8CBwDxAwkACQAJAAMDDABaAA0AigANAJoBjwCAAAQARAGKAGgABwDMAQUKCQGGCtQAhQtpAAcLBQEHC1MEBwtbBAcLSgUHCzQGBwupBgcLbgcJC9EBCgv4AAoLXQEKC4cCCwsPAgsLlAILC50CDAsRAo0LMQEFC7YBCQu2AgwLcwKNC9IAmAsLAAQApwOFADcDhAq+AgUADQEHALIBBwB7AwgAUwEJAL4CCwBSAgsAzgIRAGQABQooA4cK/QcHAPYDCQDlAY0ACAGGALEGBwASBwsAYgMMAGcADQDvAYwL6QAEAKcBCgC1A4oA9QOHAIQDCAsZAIoLOgMFCqYACArjAowK/wGGAOIHBwv2BIsLZAIECncABQqqAAUKvwEHCqwGBwphBwkKZQEJCs8CDArmAYwKVAIMAD4CjAs+AoQLNAEGAMQDBgC2BIYAFgUECsIBhwqGBIcLlgCIC4kCDgDVAJQAJgAJCy0ACQs3AY0LKgCGCwkCBwpfBQcKugWKCksBhAryAgULUwEHC6IFDgsDAA8LKQCTC0IAiAt6AYYA/gMFClIDiAofA44AjwCHAO0HhgtcBggACwKWACIABQBxAocAUQYHABMBBwruAAcK8QcICngACAq8AAgKkwIJClYCCgrSAQwKVgEMCkwCDQr3AQ4K9gCPClwABwAlAAgAqQEIALUCCQDQAgoAfAEKAH4CCwARAQsA2QEMAD0AjwArAIcLPQOHAJcHhAD9AgUL5gGHC0UFBwtjBggLEQAKC9kAigsnAQQKyQAHCtAGCApaAgsK9wALCjoDkQpBAIoLLgILACcCjgCfAAgKpACSCj4AiwuwAIQAqACIAPIDhgDKB4cAWwCKABQChwrbBIcAXAeECosDBQpkAAoKSQEMCqABlQodAIYLvwGECrAABQp8AgUK5gMHCgkABwrkBQgKGgAJCj0BCQpmAQoK0gAKCiQBCgoVAgsKKwIMCg4CDApfAg0KBwENCssBjgoPAQQLYQKHC/QCBgAPAAcARgAKAPAAkwBdAAQLogOFC7MDhgDLBIYA/gWFC6sDhQvCAwULiwIIC6oACQs9AAkLPwAKCxcACgslAAoLQgMLCwQACwu7AAsLGQELC/cBCwulAgwLYAAMC4IADAv0AA4LBQAOCygADguiAA4LygCSC4UABAuWAQULQwIMC+wBlgsPAIsAiAEGCmICCgp/AI0KGwAHAI8CBwA0B4gKdwAEAJEABgCwAAcAiwGJADIChAD1AYwLkQCIAPsDhgD9AYsACwEGCxEABwsQAAcL6QMHC74HCQt2AwoL6QEKCyADCwsOAwwLQAENC9MBDguRAA4LgwGPC3cAkQsRAAYASwSFC8oBBwu/BwgLAAAIC6sACQt4AAkL3AIKC9kBCwuQAgsL5gMSCwAAEgsCAJMLFQAMC6sBkgsmAAoAtAOKAMgDBwp+AIgKVACIChYDBAByAAkA7AENAM4BjgDXAAYKQAAMCnkBjQo1AQQATQAFAGkBBgCLAAYAkQEGAJQBBwCdAQcAywIHALQGCwAXAQwAswAMAAIBDQD0AI4AZgGGALUGBwAEAwcAJQQHAG8GCABSAAsA+gALAF8CDAA3AQwApAENALgADQBvAQcKUAQLCg0BCwobAgsKcwILCsICCwrPAwwK+AAMCrIBDApYAgwKbgINCikBDQrlAQ4KRQAOCpkBjwpsAIcA1AIECwACBAsHAoULVgGGAG0EkQsdAAsK0QONCvsBBgBJAwYAEgQGAKoECgDhA4wA/QMGCx8ABwvrAQcLEgIIC1ACCQoiAAsLNQALCuQBCwsLAwwLpwAMC5sBDgsOAA4LiAAPC0gAEAsRAJALSAAEAP0DBgD1B4ULiwMHAHUBCABPAQgAVAIJAOgBBgqkBgcKJQEHCn4BBwoCBAcKPwQHCusHCAr8AAgK1wIICtkCCQoeAAkKxwAJCucACQr7AAkKTgEJCmkBCQrIAgoKNwAKCjwACgroAAoKTAEKCoABCgqMAQoK+AEKCh4CCgqMAgsKFAALCjAACwrPAAsKIwELCioBCwpWAQsKbQELCooBCwpsAgsKwQILCvkDDAp7AAwKVAEMCpYBDAqDAg0KPQANCg0BDQo3AQ0KPwENCuYBDgrqAA8KPgAPClUAEApHABIKdwCUCmkAlgAlAAQL0AAFC2oABgsTAggLmAEJC7wAigs8AoQANAIGAAEChwAcBIQAOQMJAIMDjAu5AYYACgOFC3sBBwCJBQwAfgERADAAmAAMAIQL8QAHAFwEBgp7AQcKDgEICrAACAq3AAkKsAEJCpUCDAr3AAwKaQKSCn0ABQoYA4UKhAMGACECBwA1AgcAhQYKAHIACwCCAowAagKFAAUAigsHAIQLAwGHAMAAhgC9AogA+wKHCrsHBAqFA4UKCAMKAPMCkwAdAIUA9wIEC60ABQs4AQULAAKHCwUFBwtDBgcLmwYJC9ABCwvDAAwLFwEMC8ABDgsLAJMLZgAHAHIBBwDvAwcAmQSHAB0GhwDVBAQAVwAFAPoAjQAqAQQLxAEFC0cCBQsxAwYLsQEHC1ECBwvQAgcLYgUIC6EACQscAQoLOQGLC3YDBAsjAocLgQWIC9ICBAolAAUKTgGHCuUEhAr8AQwAawCSAB8ACAukAYsLwQCHAC4DhwuZAYwA3wMEADkABwCrBAcAngUHAAwGBwArBwcAcAcJAPUCCgBcAosABwKEABwCigs0AYQKFQKIAGACkAtBAAQA9gOGAO0HBADRAAcAhgMFC+oDiAvpAoYA7gcGAC8BBwBPAQcAnQUHAIQGCAApAggAjAIIAJACCQAuAgsA5wKVABIABQs/AgYLYgGHC70CBAvvAAYL3QEHC0cGCwtEAIsLaQKEAC8CCAAPAhIAPACTABgAhQqYA4oA/wGFAPkDhQCjAooKhwELAJwAhwqgB4oLcQGEC28BhQDFAgYAugKGAHcDjgp+AIYA0QaECuMBDQsrAY4LSwCFAMoCBwAIAIgAzgCKCuABBAu2AgkK7wGSCmgABwvgBAsLbQKLC74CjAuvAoQACAOLCvEDhwD4BIYAIwQICo0CDQpdAJMKDgCHC9UAiACWAYUKrACE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AL4DCQDLAwkA0AMMABwDDAAfAwwAKAMMAEMDDABEAwwAkgMMALIDDwDYAA8A6AASALcAEgC7ABIAwgASANQAEgDoAJUAMQCECuIBBgA7A4YAmgWHCloBhgD7BwYA8gAHAOMABwAtBggAaAAJAHEACQDcAAkAqwEKAIgACgDvAAsAQwILAP8DDQAEAA0AzAANADwBlABWAIYLlQYHAJQACAAcAY0APwCOAAoAhwtIAoYA4QQHAF0DhwpOAQUKGwMGCs0GiQtGAIQAJwMHC4cACAsHAAgLPgAJC/MACguSAgoLuQILC8gBiwv0AgkLiwGKC08AiQtsAJMAXgCIAO4Bhwt3AocKbgIHAOYFhwrWBgQKywCHCpAHBwuWAQcLywEIC14CiwvWAgcAGgUIAPkBCQDiAQoAfgALAOEADABbAQwAwQENABMADgDaAI4AswEFAAwBCgD8AgwAeAANACcAkQB/AI4LRAALCqYCjAozAQwLDAEMC4ACjgt3AIcK/AeFC2QCBAt0AQcL4gEIC54ACQtaAgkLZwIKC/UACgumAgoL6AILC/gAiwsmAwcKNwEJCjQBjAr/AAQAgAGHAP4DBQtWA4cLxweHCvIEBAqQAQUKCwGHCugAhwCnBgkAnwALAJUCjABbAgQAxAMOALYBDgC8AQ4AyAEWADwAFgA/AAkLagAJC6MACQsoAQoLpwAKC6wACgsJA4sLEACIAEcChAADAggAeAIIALkCiQBWAwULwwCHC5UGBgBjBIYAVQWGC0gBBwvNBwgL2gKLC+4DBACIAIUAJwKGAPYGBwAHBQkALAAKACgCCgCCAgsARwMMABIBDAATAQwAdAENAFsAjgB9AAUL7wILCx0DjAvLAIUA3AIHAKcCCAA5AQQKZACHCzUDCgBpAY4APAGGAFMCBgCTAAcAdgMJAPECigAMAQUKagEFCrsBBgo+AQcK+wOLCm8CBQrPAYgKKAEECsYBBQu2AwUL4gOGC18BigCJAAUKMAAFCpQBBgotAgcKygEIClUCCgrHAQoKXgILCjEACwokAgwK3AENChIAjQrCAYUAngGHAOIGBQulAYcLLwAFCroBhwrAB4YAVwKGANUGhgBbBgQA6AGEC14BiQvvAoQAUwCMAKQChQvHAwcAZwYFCjcAjAqhAAQL2QEHC28CCAsoAwkLZwMJC30DCwsmAAsLrwEM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Cs4ACgvmAQoKVAILCw0ACwt9AQsL4AILC/4CCwtNAw0LcgANCtoADQskAQ4LLwCOCpkADAC1AocL9wIFADoBBgDdAAcAowEKAIoCCwCMAQwAnAANAHEBDgBNAZEALwAGC5QGBgvDBgcLZAEHC4wHCAs2AAgL3QAJC+EACQtkAQoLTQAKC74BCgvbAgwLlAGNC+sBhAt3AQQKBgKHCnAEBACRAwQLmwELC4MCjAtzAAQLUACFCywACAqxAokKXwOKAHADBAoSAAcKkQAHCrwBBwr+BAgKMQAICpABCQpHAAkK+gAKCssBDAqgAJAKGACIANsBBQD4AwULKwGHCzsEBwBaAggAswAKAA0DjAB+AAYASQGKAG8AhwBIBwQL2wAHC+EGiQtWAAYAYAcGAGQHBgBtBwYAcAcJALkDCQDZAwkA3wMJAOkDDAAyAwwATgMMAE8DDABdAwwAXgMMAGkDDABrAwwAbQMMAG8DDABxAwwAdAMMAIcDDACTAwwAngMMAKsDDwC2AA8A2wAPAP8AEgC/ABIA0QASANMAlQApAAULSAGHC5YDiQAMAwwAUgCPACQAhQryAwUANQOGAJcGhQsCAoQAvAOGAJwECgBwAAUKVwAHCjkBBwpPBAoKRgILCoUBCwotAwwKgQENCh4BDgp8AJIKbAAFAEcABwB/BQkAwAIKAAUBCgBrAgsAIwILAGsCjwCdAAQAEwIFAMcBBQstAQYLOwIOCzEAkgtmAIQKCwEGAIEBBwDYBwkAUQGKAAUChQvWAoULbAEEC0wABwsOBgkLMgEJC64BCQuXAgoLqwILC6sBCwvxAgwLTgEMC7oBDgsCAQ4LbgGPC4MABgBJBwYAVwcGAFkHBgBmBwYAdAcJAJMDCQCeAwkArAMJAK8DCQDGAwkA1AMJAN0DCQDtAwkA8gMMAC0DDAAxAwwASAMMAEsDDABXAwwAYAMMAGcDDABoAwwAgwMMAIkDDACcAw8AqwAPALUADwDgAA8A6wAPAPsAkgC4AIkLNAAFABAABgBWAAYAWwIHACQBBwAxAggAAQEIAH4BCQDRAgkACgMLAEUCjADSAQQA5gEFAOsBhwphBAQASAAGAAkBhwAUBYcLnwQKCvkAiwrRAIQKMQKJCwcCBAuQAgQK+AKHCwsDCQqaAIwK5QGHCwEHhwuQAIgK/wCFAG0CBApwAYcKgQKHC10FBwsqAgcLXQKNCwoAiQDqAAUALwMGAJgGhgDbBgULRgMFC0kDhgtxBgcAwwcHAPgHiADnAoUL9AMGAMUAiADNAAYAOgGGCzoBkAs1AAYL+wAHC20BBwtNBQcL2QUIC5oAjQsZAYULVAEGAMQBBwA4AYoA2wCKAE0CBABNAQkAsAAMAGEBjQC7AAkKXACTClsAhgBWBAsALwCLC+8BBgoNAggKJgMJCmwDjAocAQgLBQEJC5AACQvSAQoLcgEMC9YBDQuQAI4LXAGJC4EDCABfAwgAYAMIAGQDCAB0AwoAYgMKAGQDCgBpAwoAjwMKAJADCgCwAwwA1wIGC/gACQsiAgoLFwILC6kCjQuHAAYALAGHAOsFhgDVBIsKvgOFClICjAv6AIYAlQaGCzcCBwCHAAgABwAIAD4ACQDzAAoAkgIKALkCCwDIAYsA9AIJAIsBigBPAAYKaQaICjQDBAouAYcK5gaGC64AhwohBYcAdwKGCooGhguLAYoAQwMHAJYBBwDLAQgAXgKLANYChgtpAoYA0wMGCoUBBwqVAAkKjgCKCl4ABQtuA4ULzAMGCggABwpZBwgKWwCIC/8BhQBkAoQLXwEEAHQBBwDiAQgAngAJAFoCCQBnAgoA9QAKAKYCCgDoAgsA+ACLACYDBQBWA4cAxweECx4BhwtYAQcLtgEHC3MCBwvsBQgLKAAJCzgACQsmAQoLHgAKCwMBCwvJA5ILlACHANQFBQsDAQcLngEHC1YDjgtrAIcK0gYGAEEDhgDmA4cKGAAGAO4ChwDLBgQK9wGHCn0GBQqCAAcKIgUJCmICCgrOAgsKWQILCjMDCwqyA4wKGAIKCpUACwoYAY4KUAGEC+IChwqaBwUAwwCHAJUGBwDNBwgA2gKLAO4DlwsRAIULYgMOAM8BDgDWAZYAPQAFAO8CCAAKAQsAQgIECogBhwo9BgUKsQEJCnkCiwp1AocANQMGAMsChgAtBYULdAAGAGQDhAvJAYYAvwMGCuoAigvHAAcAHQQHCp4HCAqoAgsKMQOTClgABwrGBIoKggEFALYDBQDiAwYAXwGGAGQEhgA5BAcAOwYGCgUACwr5AAwKOQEQCkIAkQoaAJQAOwAFCw8CBgu9AIcLWwMFCsMDBgrtBgsLaAALCyoCDws8AI8LfQCHAC8AiQCsAoYLdACGAEYGhgAJAwcA/AMICv0BiAoYA4cARgSEAF4BhQvnAQQLVgAFC5sCBQvxAgYLPAEGC8cBhwuyAwcAFAcNAAMBDQBkAQ4A8gCTAHIAhAqjA4UAxwMEANkBBwBvAggAKAMJAGcDCQB9AwsAJgALAK8BDABwAAwA2QAMAPMADAAyAgwAlwIMAKsCDQCNAA0AxQANAOMADQCWAQ0A5wEOAJwADgDLAA4A4AAOAAABEgA6AJYAAACKAB4BBwqvA4sKZgKHCi0HlgstAIQAHgMEAN4ABwAeAYgAdQIEC08ABwvtBgoLwgELC00CDQtMAQ0L7QEOC7cADgtOAQ4LagEOC3ABDgt4AQ4LewETC1oAEwtnABMLfwCUC1oABQBRAQsAAQILAHkDCwDBAwwAzQENAE8ADwB5AAQKWgAFCiECBwryAgkKugAKCkgACgoOAwsKQQILCmICDApiAQwKagGMClMCjQAyAYgAkgAHAG4GCQpJAQsK/gCNC3wABADRAYcAfwaEAA0ChQuXAgoAKwESAEoACQq7AAsK+AORCiwABwClAAcAlwMECvoBiAoFAgUKJwGHCpAGhQtOA4YAKAQFC3oBBwt6BQcLhgUIC9EBCQseAQoLuQAKCzICCgt7AgsLHwALC4kBDAvIAQ0LOAESC0EAEgtgAJMLWQCEAFQCBwrbAwkKsAIKCgoCCwoUA4wKNgIGAFIABwCKAAcABQIHAM0GCwDuAAQLiAKGCu8GBwDRBAcKvAIHCqwDCAoCAgkKdAAJChcCCgp2AAsKawALCpQACwqaAwwK/gAMCqUBjgruAAQAwgMGACAHCAB+AwwAxAIMANUCDgDDARQAXgAWADsAlgA+AAULsQMGC3gGBgv7BgcLpwAICzgDCQuHAQoLdwGLC7kABQDvAQcAQgMJAN0CiwB6AQQK5wKHC/kEBgC0BAcLbQYIC2ABiQv5AIsKJAGFAC8ChAuYAAkA8wEKAFUBDwCQABMAMQAHCgMFCQrjAAsKRQELCpgBDgq0AJIKLwAGABUABgDJBgcApAWIAOAAhQvuAwcApgUJAGEAEQAPAAUKUQAHCpIABwo+BQgKNQAICjECCAq2AggK8gIJCnMACQp+AwoKzgEKCi0DCwrmAAsKkQILCrsCCwrsAgwKdwAMCsgADAobAY4KEQEFCpgBiQrrAocLrwGHC0ADBgDZAoYAuQMEANcCCAA1AgULXwEHCwgBiAs1AoYAnAcFAAcCBQsoAAcLVgIHC2YGCAtOAAkLpgAJC4ACCQutAgkLBQMLC9cADQtBAA4LrAAOCz0BkQsGAAgLPAAJC1cBiwsBA4kLxwGGAKkEjAAWAwcLnwcIC/0CCAsEA4wLnwIHC2wACAvbAAgLhAEJC38CCQsHAwsLEwGMC9ABhAvUAQcKHgAIClYACAo7AQgKvAIJCkACCQpaAwsKNgELCngDCwqIAwwKaQGNCvgABQsPAAYLOAAHC94GCAv0AQkL2gILC0sBDQuWAI4LGgEEAJIBBwACAAgAQwGIAN8BigpHAwsARAKOAMkABQA7AIcAoAKJCmkCkgAiAIYLXgcEAMEDiACAAwYABQUFC80ABgu2AYkLxwKGCqwBBwoMAggKqQAICuoACQrgAYoKhgKUAC4AjQDfAYULFgIGAOMHhgpwBgQAVQAHACUCBwq1BIoKfQIEAJcCBQBeAAcL6wAHC8MFDwtEAJILeAAGC7sBCQvtAAkLOwIJC7cCCguLAAsLywIMC6EBjQulAYQADwMEAKoCCABBAAkKJwAKCqYACwqWAwwKewIUCgoAFgobABYKKwCWCjQABgALAIcAuwCEAAoCBAA0AIcAlQIEAH8BhQAIAocLIgILAFcBjgB/AAQLQgIHCp0ABwtwAgcLlAMIChcBCgsAAQsLVwCLC78ChgpcAgQAGQEFACYABwDCAAcAnAIHAGUHiQCNAQcKsQMLCskCiwroAosK/gMJAHsCiwAvAgULmwMHC+oBDAspAg0LZAAOC3YAjwtLAIQAzwOECjcCiQpbAwcKNgcHCzYHCAp0AogLdAKUAHQAigvuAg4AMwAOCzMADwsHAJQLFACEAFoDhgAzBAQLnAOFCvoCiAAXAoUAwAEKChADjQq/AIUKKgEHAGIChwDdBQcKeQIHCokDBwqNAwcKAgYJCv8CjAp8AgQLCQEHCycDhwu2AwULXQAMCwsBkAsaAIgAvwCLCi0BhwqyB4cACwEEAD8BBQC7AooAoQIGAFABBwBcAAcAtgAIAMUBCAAoAgkAzAAJAB0BCgBjAAsAOAILALYDDABeABAAFAAQAEYAEwA3AAwKhAKQCloABgAnAgcAHAUHCk0DBwviAwgKoACJCj4BEwsBABMLGgCWCwkABwB+BQkA2gCNAN4ABQAAAYoARQAFC+kABQtAAQYLjAAHC0oBiAsnAQYAvAeIALgDBABBA4kLpgKFC9IDBAuJAwYLpQaJC0sDigrfAogKTAARACcAlAAkABIAUQCSC1EADgBgAREANQASAJIAEgCYABMACwCWADYAhwB6AooKSQOEAGoCBABTAQcAAwERAEkABAsTAYwLeAGEC/0BBwsRAYsLeQEEAPcCDQCpAIkKJAMGCmAAhwqSBQQKiwKFCiEBBwAzBAgKIwAJCv8BCgr/ApMKdgAGAIkCBgCeAogA4gEFAFABBgBVAQYA3gEGAOMGiACCAQULIgMHC+UHCAslAw4LXgAPC0EAEAsEABALTQAQC1AAkQsFAAYACwQFC6cABQuDAwYLmgGJCwkDhgupBgUAnAOFAMkDhArAAocASQCHCwoAhwo2BAULCwAGC3UABgvlAQcLbQQJC0YCCQtSAgsLFQALCzIDDAsXAo0LVgCHALMHBAsIAQcLKwQIC8wACAuBAYsLuQMGALIFhwBABQUAjAGGAPUBBArQAoUKMgEEAKEDBQAfAwgALgAIAOQChQqvAQcLhgIHC8IGCwu+AY0LsgAHABQBBQrQAQYK7AAHCrgCBwqSAwcKVAQHCqgFCQoPAAkKNAIKCg4ADAo1Ag0KwQEOCjUADwoNABAKQACRCikABAB8A4UAAgMGCucGDArCAJEKawCHAJ4ABQpIA4oLYAKGAJgFigv6AAgLGgMJC5ABCgsqAY4L5ACXABkABwtrBIcLvAWHANEHCQqCAgsK7ACOCsEABApEAAUKegIGCoIBBwoaAwgKEQEJCjMCCgppAAoKqwALCl4AiwpiAYgL1AKEAN4BCwsAAg0LzQATCx4AFgskAJcLEwAHALUFjABbAAYLvgAHCwADhwuSBAQAWgIIANMABApfAAcKoAGLCj4DBwrbAg0KFACPCgsABgAsBIcAUAcEAA0ABQA3AgcA2gUJAHwACwAJAgwAlQGHC/8DhwDuA4QA3wKKACwDBACqAIcAQwEGC4kACQtLAAkL/QAKC8IAigu8AQUAMAEHAHsFBQpgAwoKiAILCp8CjwouAIcLnASFCqADBACUAIUA5gILCtoDjAqqAoUACwKHC88GBwDaAhIAkAATAD0ACAosAAkKdAMKCkQCCwqPAQsKfgOPCnoABQv4AgcLHgIIC4cAiAvwAYgA1QOFAG8ACgCEAAsAvwALAGYBiwDMAQcLPwEHC2MBBwv7AgoLhQGRCysAhgB6A4YAjAWICy0ChQoGAoUAvAGHAPsGhwo8BwgAewAPAAYAkAAHAAYA+QcKCyYAiwsQA4gApAMFAKkDhwBkAAYA4wMECzoABQseAQYLPwEHC5IBBwvmBAcLbwcIC2QBjAuYAQQLhQEJC7UACQv/AAoLCAAKCx0ACgswAwsLNwELCzECDAtDAI0LtQCKAP8ABQCKAAQKpgOICmICBADFAwoAXwOKAIIDCgokA4oKQAMMAHcCCApgAAkKJAAKCl8CCwqnAQsKugEMCjUBDgrHAA8KWgCRCm4AhgByBQQAjAIIAEABFgAGABYAEAAJCg0ACQqOAQkK1wIKCksACgq4AAoK5gAKCjQCCgo5AgsKzQMMCkYADAq9AA0KOQCNCgEBBgCBA4YANQUEALQChQBBAYULdQGHAJoDBQBrAoUAugKJCncCBQpZAYcK+AMJAL0DCQD6AwwAPAMMAEwDDACBAwwAhQMMAK8DDwC0ABIAxQASAMgAEgDVABIA1gCSAOIABQCVA4YAewaHAEwEhgCVBIYAigcFAPsABQC8AwgADAEJANYAkgCOAIUKoQKJClIDBAofAYUK+gOEC6ACBQBaAQUAxwIIAIYBCwvwAosLdQMFCiIACgrUAgwKvAENCmIBEgogABcKGAAXCh8AmAoFAAQLxgKGC14ChgDoAoYKfgGFC5EABApJAQcLdAOMC3wABAvTAQULlQGGCyACCQpOA4oKOwOFAHACCQt0AQ8LAgATCwoAkwsSAAQLgwGHCwgFBQAPAwcAzgeHAP8HhAqKA4gKbgGHCyYCBAp7AAQKiQIFCl0CBwrlBYgKJACGAGUEhABSAoUK/wKHC8sEiAvTAQQLQAKHC+8EBAAMAQcA/gWHC/4FBAoRAQUKkgIFC5cDBQrjA4YLiQaFADMChgpIAIcKQQUEC1IABQtNAQULiAMGC88ABwtFAQcLvgYIC2UACgsKA4sL3AAFACUABgAnAAYAwwEHANoABwCbAgcAjgQHAJcGCACWAhAAAgCFCk0ChgA0BYULhwOGAPwBBQp1AAYKAgIGCh0CBwqMBAcKnAUICtwACAqIAgoKsAILCjACjAuTAAYLKwKHC+UBhQquAgcAxQEHAHsCBwAcAwgASwEJAEoBCQBhAwoAdwAKAOsACwBvAAsAgQALAPAADAAfAAwAQgAMAN4ADAANAQwAVwIMAKwCDACxAgwAswKOAFkBhwAqBwQLwQIHC2cCigv7AIgLWQGJAA8CBgBiAAcAvgKHAN8DCwBAAg4ASgAHCsQACgr9AgsKWwELCigCCwoWAwwKBwENCvYADQoOAQ0KiwEOCrAADgq+AA4KjgEOCpwBDwogAA8KPwAQClgAkwppAIYLWgANAFQAjQB6AAYAJQAHACsBBwCCBggAwwAIADwBCQCyAAkAFAEJAFMBCQAYAgoAZgAKAGoBCgARAwsANwALAJUACwAFAw0AoAENAKMBDgAmAA4AKQCOANIABQp9AYcKAAcHCy0DDAvxAY0LOAAHCmgCigqdAYUAhQIGC30Ahwv9BIQAIgEGAEYABwAMBQoA+gKLACABBgp4AAcKpAQHCq4GCAoeAQkKmwILClACiwraAocL+AYHACMFhwsjBYYAoweHCnoEBwCDAAcApgEIANIAjAA9AgQKYAGHCq8CiwAdA48AJgAOALMADwCXAJYACwAHAOgBBArAAAUKMQAGCsgABgolAYYKoAaEAKgDhwu/AgYLoAAHC1IECQsCAwoLagILC3AAjAudAQUAxQGGALkBhwBTAoQKigKECpMABgDfAwYAngQMCw8BkQttAIUKpgOMC90AhACNAgcA+QGHAAsChgCHA4cL3wEHCzABCQuGAgkLXgMKCwYBCwu4AgwL0AAPC08AkwtsAJIAUACHC9UDjgCwAYQAOgGJC5gABwBYBQgA6AAIAGkBCgCqAooA5gKHCzIGCQAWAgQLsgELC5cCDAvSAA0LpgANCzYBDgt1AZMLKwAHC0MEhwvlBgYLJgKHC4wCiQAbAI4ADAAECn0CBQspAgcL/gKKCzgDBwvhAggLKgGIC8QBBwDgAosACAGGAHkGhQskAYoLhwAGAEwDhgBdBIcAfwAJCmMDigpFAwYAoASGALgEhgAOBYgAbAEGAIcFBwA2BQsAfQAGCqoABwuJAQgKiwEICucBCgtbAgsLzgCNCpMAiQvsAgQLkAOJC+gABAoXAogKagKJABgDBwu1B4gLzAKHC2IABQCNAwkAUQOKACUDBAB2AoQAuwIFC90CDgtnAJYKFwAMC54AEgsIABMLPgAUCwYAFgsEABcLAgCXCwkAhADIA4QKCgOECi4ABQorAwYKjwYGCrIGhwrwBwYApgUHCrIFCQqXAYsKDwAHAM4ABwCNAQcAbQIHAIACCAB8AAgAawIJADEBCQCDAgoACAEKAHQCCwAoAAwAXQENAIYADQAnAQ4AmwAPAHgAEgBpAAYKIgAHCkEECArEAggK0QIJCmsBlApiAAQABgEFAIEChwBWAYkLSAAEAGMABgD6AAYAWgEIAH8AigBRAIQAkwMFAEsACQAFAgoA1gEMAJsAjQDgAIQKzgELC1gCCwueAo0L9QCOAFMABQpJAAYKFwCGClIBBgAHBIsLmwMHC6QABwsjBgkLawCMC+EAhgC+BYUAugMGADABCACiAQoAWQELAFUBiwCjAgkAmgGLAKkBBAsbAAUL5AEFC/4BBguyAQcL6AMHC0oECAsCAIgLyACGAN4CjAsBAQcK1QIICvIBiwoMAYYAHgeHAAYHhwoFA4QLzAEEC6QDhQt7A4YADgCECkcCBwq2BQgLcQKLCpMCBQBxAAYA8wAGAKwGBwBJBwsAoQAQACUAEQBjAIUK3ACGC0wABQvNAYcLhQeMAEUACAtcAIkL3QCLCiMDhAogAgQAEgGGAJoDhAAdAgUAcwIGCrUBBgo0AgsKtQCNCrcAhwqoBAcApgCEC/sChQv9AIYAUQMJC0kACgtuAA4LuQCRC3cABQvUAAwLIwCNC34BhQDNAokAMAGIAFgChQCOAgYAEQEKALwADQB5AZIATQAEChYDBQoRAYYKigGEAB8ChwCaAQsAYgALAAwCjQBXAIQArQOHC5cEBAD6AAcATAYLALoADACFAAYKfwAHCucFCAplAgwK7wEMCkoCDAqUAgwKnAIOCoEBDwp2ABEKFACSCmIABgD5BoULMAOGADsFBwDBAwcAPQQHAL8GCADOAQYK5gCHC78GCQB8AocKogeEAAwDBQtlAwULyAMGC1oGCAveAogLEAMECx4CBgu0BgYLvwYHCzoEBwsJBggLOAAIC3YACAucAQgLNAIJC3gDCQuMAwoLMgAKC6cBCwutAgsLuQILC6UDDAsrAQ0LfgANC4gADQuqAI0LvgCGC+IABAvoAAkLygAKC9oBjAuxAYkL9AEFABECiApEAIQKjgIECpwABwrmAwcKFQQHCkQHCQowAAkKtAILCqMBiwpaAgcA/AQIANoBCQCMAgYLbAAHC+sDBwudBIgLVwEHC/AEBwuOBgsLsQMMC1UBDAvXAYwLOQKGC7AGBQC0AwwA1AETAGAAlAAYAAQLhQAHC8cCBwsSBQcLMQaHC4kHBgDxAowAkQKLAK0DBgtjAAcLEAeRCzkABgs+AgcLrAEHC+IECgudAgsL5QELC0gDDAssAY4L+gAEABQCBQDCAocAlgIFAEUDBgBzBosA2QMHAEUHCQrFAAoKLAEMCtkBDQpaAI0KlQGJC/wABgtDAYcLHAYEAEoBBABfAwcApQMHANwHCAAkAQcLzQEICwcDiguzAYQKXgIEC48CBwtSAxELSwCSC4kAhwD/AgcKugeICqQChACBAocLFwaGANEEiQDyABEAcgAECmkBhQo7AYkAcwOECs0BigASAYYA2AeGAAIHBAC/AocAzwAMAB0BhArYAYQAOwIFAGkDBQDAAwgANwMJAHEDiAtBAgcAaQIKAPIBCwD1AQwAEACMAJYAigrrAoQArwGFCpsACwAbAQsANwIHCqMACAo/AQkKkgEKChgACgqpAgsKyAAMCv0ADAqaAY4K2wAEC50BBQulAggLsAGMCxgBCQCRAQUK2wEHCvQGCwopAQsKLgIOCkIBkwpMAAYADQMJAIYACgACAAoAGwAKAE0BCwDSAo8AAQAFACEABgDWAYsAqAGHANYHDAAPA4cKpAeIABIBhwBaB4QAGgOHADgHBQqwA4YK6QYGAC8ABwBaAAcAmAIHAD4DBwBkBQcA6QcIAMABiAA8A4QKkACGAK8EBAuLAYsL+gKHC+AFCQChAYkA7QEJC64ACgukAAsLuAELC0kDjwtiAIYLqgGLC+oDhgAnAYYAMAMGCvcAiQorAoUA+wMEAGwCBQvcAQoKGAGKCh0DiwDQAQULTAAGC8oBBgvxAQcL/AIHC2QDCQuSAgoLUgILC60ACws2AgwLFAAMC1IBjQvIAIYA0AAECw4CBwsFBIcLHgSEC3wCBgvpAAcLlAIHC2QEEQsfABMLFgCXCw4ACgC6AYUKrAEKAKIDjAAKAwYARAAHAMABBwBdBgcA6QYHABUHCAC6AQgABAIJAMYCCgAaAQoA0gIHCrUGigoiAoYAaAQLAEwDDABoAIwAcQIEC7ABhws4A4oKvQCFABMDhQpjAAQLFwEHCy0BiQtqAQgA6wEECo0BiAorAgQLsgCFC48BhgDHApAACQAEAJMBBQC5AQcAwgEKAEgDCwBlAAwAwQCNAK4BhwveBAwKjgEUCicAFQoLAJYKKQAECuUBBwphAYcK8wUGCm4BBwpoBQcKQQaHC3gHBwCMAQoAoACHC4wBiQoaAYYLnAYECp0ABQrXAQYLygAKC8ABCwvQAAwLaAERC3UAEQt2ABILGwCUC0MAhQCnAokARgGICnQABwtoAwoLBAKLC6cAhAvgAAULIgIHCyMACAsLAAgLDAAJCzsBCQsVAgoLIgMLC6YADAsNAo4L8wAHAGgEhwuABwUL8QAIC/IACQvDAQoLmwILC1YCjAutAQYA4QIFCqAABwprAQcKTQIKCqoAjQo3AIcABAeOC/4ABAA+AgcAXgEHAAAECABSAQkApQKKACgDhgBIBIkLBAIHAJUBCgDrAQQKbAAEC24BiwryAQsLUQGOCy8BhgvIBgcAOQSMC2wBBwrtA4wKYQIHAIwGBAp/A4UKBAOHAPUHBgC3BAsLlAOOC6MBDguMAJQLKQAGC0sBiAtvAgkAsAMJAMkDCQD+AwwAkQMMAKgDDwCxAA8AwQAECp4DhQrXAwUAYgGHC/oBCABWAgkAmAKKALkBBAuAAoULAQKJACkBhAoaAgYKJgEHCvMEiApwAgcA7AYHC2AHCAshAQsLLQAMCxYBjAsZAocKLQWKAO8CjQAlAIYAJAeECvUChAuKAQYAAQGHAPIFBABGAgkAvwCHC4sHBws+AgcLtwaJC5EAhAuSAgoAFgOEC3EBCQsNAwoLkAALC4EBDQuhAA0L5AANCwwBlAtrAAgA1QEKAC8AiAt2AQYAMgEHAHQEBwA8BQgAhQCKAMEBiwDzAwcKUweLCnwABAtYAQYL8gGLC0MBiQArAYQARQOFC4oDBQBJAQgABAGKAAoAhgAoBQQAkQKSAJ4AhwCnBJgABwAGAJMHCADOA4oA5AOHAIEGCwt+AIsLHwGPAAgADguVAA4LjwGPCzkABQBCAAcAaAeIACABBwCvAAoA7gEFCpYACApbAgkKUQIJCnoCCgqtAAsKzgELCgMCDQrYAA0KIAGOCpABhgBrBogLFQAEABUABQBbAAUAiAIFAO4CBQANAwYANgAGAHAABgCSAQYAxAYHADsBBwDtAgcAkwUHAGwHCQBOAAkA/AEKAGMCCgArAwsA/gELANgCDQAkAA4AJwAQAFMAEQB8AJQAHgAEAJwCiAA6AgoAQgEKAM8CiwCXAYcLZQWIC8EADApsAI0KIwGEC2gCiAu0AggAfQAIAHEBCAAMAgoA5gELAA0ACwB9AQsA4AILAP4CCwBNAw0AcgANACQBjgAvAIYA3wQGAJQGBgDDBgcAZAEIADYACADdAAkA4QAJAGQBCgBNAAoAvgEKANsCDACUAY0A6wGHCvEGBAsxAQQK7QGQCjcABAC3AwYAEQcGADkHCABOAwgAYgMIAIMDCgCAAwwAtgKOANQBBQvWAAcLWwIIC2MCCQuuAgoLWAALC8sBCwvwAQwLzwEMC04CDQsAAI4L1gCEAJsBBABQAIUALACMC0oAjwAfAAcAnQIGCjgCBwoMBwgKagEICpoBCAo+AwkKAgILCokCjgqdAAcAoQKGC6cGhApxAoYAFwUFACsBhwA7BIoAwAIGABMBBwCYAQYKngAHCoEABwq1AAgKFAEICnkBCgoLAgsKMAMMCscBDQovAY4KhwAEANsABwBvAQcAsQYHAOEGCQBWAAkAGQIKAKUADADbAIwAMQIIANgABAoBAAQL4QIGCz0BBwp3BAcKtwUJCs8ACQqGAQkK0wEKC2IACwsmAQsKRAMMCzwADAu1AQ0LQAANC3wBjguuAQYL3gYICwgCCQtZAQkLkwGOC14BBQsvAAoL8gCKC0MCBQuLAAcLkASKCxsChwAnBQQKJwEECtMCBQp/AwcKBwQICscACApUAQkKmQAJCtcACgoVAAoKOwAKClAACgrgAAoKRgMLCuUACwqMAgwKwAANCpIAjgpbAIwArAGJCjMAhQACAgUKNQGMCtMABgDyAwUKfQAICk0AigoPAAQANwAFAC0BBgA7Ao4AMQCSAGYAiAtyAQQLawAHC2UCCAtmAQgLtwEIC/gBCQv1AQoLfwGLC90BhAvlAIUAbAGFCrcBBAuHA4cLGAcLAHsBjApMAAQATAAEAMsDBwAOBgkAMgEJAK4BCQCXAgoAqwIKAJkDCwCrAQsA8QIMAE4BDAC6AQ4AAgEOAG4BjwCDAIkANAAECy8ABgt1AQcLxAEHCx8CBwuyBgcLQAcJCwYACwsBAYsLhwEECggABwqABAcKgQQHCrMGCQp2AQoK3gGLCogCBAsRA4ULcAGHCksEhwtcAwUL1AOGC9oGhgDqBAYAIgQGAE8FBwsYAgcLMwWIC48ABACQAocACwOIClcABQsTAAYLFQKSC34ABwCQAIoKtgEFC4sBBQu3A4YL8AaHAF0FBwAqAgcAXQKNAAoABApFAAUKegAJCpACigrQAQUKUQOGCmEGBQBGAwUASQOGAHEGhQD0A4sK8wEHCtwBBwo4BooKVwAGAPsABwBtAQcATQUHANkFCACaAI0AGQGEC7kBhAu3AgcL8QEJC4MBkwtRAIUAVAEOChsBjgsbAYYAKgOHC2YHiwDvAQULHAEGCzEABgteAQcLAQAHC3kBBwudBggLEgAIC6YCCQuhAAkLSQIJC58CCQtHAwsLkAONC6sBBQpbAwcKiAQICmsACQojAQkKtwEKCpcCCwphAowKxQAIAAUBCQCQAAkA0gEKAHIBDADWAQ0AkACOAFwBiQCBAwYA+AAJACICCgAXAgsAqQKNAIcABABmAYcA2AWGADcCiAC9AQQKdQAGCnQBBwpxB44KQwEECtICiwrXAQYAuQKGAOQDBwvXBwkLZQAJC8IBCgtCAAoLSgMLCxgCjAtLAoQAQQKGADgFCQoFAAwK2AAMCiYBDAoqAQwKkAEMCgYCDQrlAI8KiwAGAK4AigCVA4YK7gYFCgwABwp3AQkKWAAJCrYBCws+AIsKDgGGC+YGBgsAAAcLVAAHCjADBwrZBAkKGwEJCggCCgrVAAoKMwEKCs8BCgqfAgoK6gILCpEBCwoaAwsLfwMMCgUCEQsLABIKawCTCnMABQBuA4UAzAMGC4EGBwsAAQcLbAWKC/MBBAoCAYgKfwIECxYABQsKAAYKFgAHC1ADBwqHAwcKqwcIC2EAigpBAgUKqQKICg4DhQvhAYQAXwEECpgCBQokA4sK9QMGC4YABwu1AQcLvwMJCyUADgsdAQ4LcwGQCzwABwvmAQgLmwALC10AjAukAIQAHgEHALYBBwBzAgcA7AUIACgACQA4AAkAJgEKAB4ACwDJAwsA4wOSAJQABQtPAocLUQGGAJ4HhQogAIoL9AEFC3wBBQuKAogLNgEEC2wBBwuEBAcLowSJC5kBBADiAoYL4gEECw0DBgvnAQcLngMICwcBiwv0AYcLogEGAP8HCgDJAwQKIQEHCnUCBwqiBgcKrwaMCtcABgrCAYgKbQCGADIDiArBAoUAYgMEC14AhwvxBIQLoQGGALsFhwrWBAQAzAMGADsHhgBBB4YAYwGFAHQAhADJAYcLgwUEC5gBBAvlAocL9AGGChoAjguJAAUADwIGAL0ABwBbA4gACwELAGgACwAqAg8APACP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CmYBhgq1BgcKJQQIClIACwr6AAwKpAGNCrgAhQDLAocK1AIJAJcDCQCaAwkAnwMJAKUDCQDCAwkA6AMJAOoDCQD9AwwAegMMAIsDDACiAw8AzwAPAOQADwDuAJUAPQAIABoDCQCQAQoAKgGOAOQABQuuAQULpAMGC4MABwuhAQkLCgILCzoBjQuGAYQAYwMIANQChAv7AYkLBQEEC1cBhQv/AQYAvgAHAAADhwCSBAYKAQKHChwEBwvHAYoLTwKGACoEiQqDAw4AQwCTADwABAC0AxIArgCSALAAhwD/AwcKiQUMCn4BEQowAJgKDACGCz8ChAD8AgYKIQIHCjUCBwqFBgoKcgALCoICjApqAgYAiQAJAEsACQD9AAoAwgCKALwBBAD0AoUKBQAIAPADhwrAAIQASgMLAIMCDABzAIgK+wKLAEMAhQr3AgQANQMFAPgCBwAeAggAhwAIAPABhwtEAgcKcgEHCu8DBwqZBIcKHQaHCtUEjADgAgcAPwEHAGMBBwD7AgoAhQGRACsACAtNAYoLtgAEClcABQr6AI0KKgGKABIDhgD8BwgLSgGMC90Bhws6BYQLfQCGAAYEhgA7BIQL0QKHCi4DBwsIAwgLkQCTCzgAhgDKBAQKOQAHCqsEBwqeBQcKDAYHCisHBwpwBwkK9QIKClwCiwoHAgcLGAMIC5MACgs1A4sL/QOJCx0DBAA6AAUAHgEGAD8BBwCSAQcA5gQHAG8HCABkAYwAmAEEAIUBBAAvAwkAtQAJAP8ACgAIAAoAHQAKADADCwA3AQsAMQIMAEMAjQC1AAcLwAWHCxIGBwsvBAcLBQYHC+cGBwsOBwcLzwcJC/gACguQAQsLogALC7IACwvyAAwLXQIPCxoAkAssAAULqAAFC6IDCAtKAAkLbwIMC/QBDAtDAg0LKQCPC10ABgvcAAcLTQSNC2kABQDaAQcA+wEECtEABwv7AYcKhgOEAKsBBgCdAQcKTwEHCp0FBwqEBggKKQIICowCCAqQAgkKLgILCucClQoSAIQA2gIGCxMABwuFBYsLrAGFAHUBhAovAgcLYAAIC5EBiQuAAwcAHwMHALQHBQr5A4oK/wGHAAEHBwupBwcLrQcIC74CiAvuAggLlgAIC+ECjAtuAYQAQgGFCsUCCAsgAwkLlAAJC2gDCQt6AwsLNQELC+kDDQsLAY0LQwGGCtEGBwAiAYgKzgAHAHMGkQBZAIsAAgCEAKACBgBEBwgAiQMKAEwDCgBOAwoAWgMMALsCDADqAowABAOHC6gBhQsjAoUA4QIFC+oBBgtnAgYLbAKHC6sCBgDqAoYATAaECggDCQuBAZULEQCFAJEAhwr4BAcAdAOMAHwABACDAYcACAUFC4UAiAqWAYgLuwAGAKcCCAsIAIoLAACHACYChwseA4gLrQIHCz4EkQsuAAgKrwAKCqgAigo9AocAGQUEAEAChwDvBAYArgKGABsGhgBfAgUAlwOGAIkGlAAlAAgLBgMKC54CjAszAIUKEAOLCnIDBABSAAUATQEFAIgDBgDPAAcARQEHAL4GCABlAAoACgOLANwAhwtzAYQAvgOFAIcDBAt/AAULXgEGC2QBCAuqAQkLPAIKC/cAiws4AYwAkwAGCzsABwt1AwkLWwKNC40BCgBvAQkKDgAJCrkBiwoJAAsKxgMMCh8BDQpWAQ0KkgEPCm4AjwqjAIYAsgKEAMECCQCLAgsAywMNABEBBwqUBQcKaAYHCksHCQqpAAkKtgAJCm8BCQreAQkK+gEJCicCCQotAgkKiAIJCrkCCQrBAgkK1QIJChMDCQoaAwoKxgAKCtYACgoLAQoKEwEKCsgBCgonAgoKMQIKCmUCCgpzAgoKnAIKCqMCCgqzAgoKtwIKCsMCCgrLAgsKtwALCskACwoGAQsKYAELCrcBCwrtAQsKPAILCk8CCwpgAgsKYwILCoYCCwqiAgsKxwILCu8CCwr5AgsKCAMLChEDCwpSAwsKVQMLCl4DCwphAwsKZAMLCmsDCwqCAwsKhgMLCocDCwqOAwsKpAMLCq4DCwq9AwsKxwMLCswDDAqUAAwKwwAMCtwADArtAAwKPgEMClMBDAqJAQwKvQEMCsIBDAraAQwK+QEMCv0BDAoVAgwKTwIMClICDApVAgwKbQIMCnkCDAqCAg0KOwANCjwADQqRAA0K7wANCvoADQpJAQ0KWAENCm0BDQp0AQ0KgwENCpMBDQqeAQ0KyAENCtYBDQreAQ0K4wENCukBDgo3AA4KOQAOClEADgpaAA4KlAAOCu8ADgoKAQ4KQQEOCkYBDgpHAQ4KSgEOClsBDgpjAQ4KkQEOCpQBDgqbAQ4KngEOCqABDgqkAQ8KPQAPCkoADwpXAA8KWAAPCl4ADwpgAA8KdAAP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Cv4DBwCPBwgARAEMACoABAuzAgcLjwcIC0QBCQsjAAoLqAILC2wBDAsqAA0LZQGSCxAAhwDeBwcA1wcJAGUACQDCAQoAQgAKAEoDCwAYAgwASwIGCyAABwuBAQcL9QIHC3wHCAslAAgLXgAIC8cCCQsdAgoLogAKCxsDCwvdAwsL8gMMCw4Ajgs0AYsASgKHCqcGBwA1BAsAHAAJCp8AjApbAgYAxQSICkcCBguYAAYLXQEGC5IGBwvkBAgLcAAJC7MBCQucAgoLIgEKCz8BCgsvAwsLtAALC0UDDAvwAA0LmAANC9sAjgueAIsAPgCECgMCCAp4AggKuQKJClYDhgDmBoQLRQIGC34ABws9AggLjQGOCywAlgAcAAsAngIWABkABAqIAIUKJwIGAIEGBwAAAQcAbAWKAPMBBAAWAAUACgAHACgGiABhAIYK9gYFAOEBBwoHBQkKLAAKCigCCgqCAgsKRwMMChIBDAoTAQwKdAENClsAjgp9AIULngMHC9AEiQsTAgYAhgAHALUBBwAgBwkAJQAOAB0BjgBzAQcA5gEIAJsACwBdAIwApAAGAG8FhgCiBYULngKFAE8CBgqTAAcKdgMHC6UHCQrxAooKDAEFAHwBBQCKAgcAlQSIADYBBABsAQcAhAQHAKMEiQCZAYcLVQaGAOIBhQv6AQQADQMGAOcBBwCeAwgABwGLAPQBigqJAIcL8gCLC2AAhQqeAYcK4gaGACQDBQtCAwcLsgQICw4ACQvhAYkLcAOGClcCBABeAIcA8QQEAJ8BhAChAQUAXAEGAAoCBgrVBgcL9gWKC9EBhgpbBoQA9AOECugBBAtlAQYLrAAHC48AiQudAQQKUwAEC04CkgtMAIwKpAIHCx8BCAtjAQkLJQGJC+cChgoWAQYACwcSAKUAGAAVAAULqQAHC00BiAstAAwKYQCMC2EABACYAQQA5QKHAPQBhAvGAAcKhAEHCoQCiwoNAwQLGAAFC4wABQu5AAcL3AULCzUCiwtGAwYAKQUJAAEBBwrlAAgKOwAJCr4ACgp6AYwKvwAEC04BhQtRAocLXQeGAHIEBAD5AAYASQCHALEAhQBAAo4A5wCJACABhAqUAgcKCwSKCuEChwDPBQYA3QMJALEBBwqyAgkKSwKMCgkCBwDwBAcAjgYLALEDDABVAQwA1wGMADkChAvFAoULgQMF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CyUAFAtJAJYLJgCFCsoBhwDBBwcKvwcICgAACAqrAAkKeAAJCtwCCgrZAQsKkAILCuYDEgoAABIKAgCTChUABQtFAQcLywUICwUACAvjAAkLaQAKC0kCjAtmAogAegCEAOoAhwusBAYA0AMGAEoEhgChBQcA/QCIACUCBgttAg0L+AGQCxMAhAoHAgUArgEFAKQDBgCDAAcAoQEJAAoCCwA6AY0AhgEOAJUADgCPAY8AOQAFCosDBgofAAYL2gAHCusBBwoSAggKUAILCjUACwoLAwwKpwAMCpsBDgoOAA4KiAAPCkgAEAoRAJAKSACMC0oBBwvGAQcLDgOICwADhAD7AQoLpAKMC84BBgB2AgkAKwMECtAABQpqAAYKEwIICpgBCQq8AIoKPAIEAFcBBQD/AYYKnQaGC6QAhADAAQcAxwGKAE8ChwBlBQwKuQGWCzIACQrBAQoKwACKCuQCBgA/AoQK8QCGAJcEhgCNAoYA4QaGAK4EhAoDAQYLVwEHC8MACQviAAoLxQAKCz8CCwv2AYsLgwMHAGcEBwAkBgoAKQEKAKYBCwD8AgsAKgMMAAgBDQBmAA0ALAENAOQBDgCTAA4A5QARAEcAEgB2AJMAeACHC5oChACmAgQKrQAFCjgBBQoAAocKBQUHCkMGBwqbBgkK0AELCsMADAoXAQwKwAEOCgsAkwpmABAAYwCSAKQABwtlBAkLjwALCz0ADguVAZYLFQCJCwQBBArEAQUKRwIFCjEDBgqxAQcKUQIHCtACBwpiBQgKoQAJChwBCgo5AYsKdgOECiMCiArSAg4AIwCOAL8AjQAtAIoAeQCEAH0AhgBWBoULvwMICqQBiwrBAIQA0QKHCpkBiACRAAcAGAMIAJMACgA1AwsAygMLAP0DiAutAIYLCgGEAMsCBwDPB4oKNAGFABMCBQCoAAUAogMIAEoACQBvAgwA9AGMAEMCkABBAIoL9gAGANwABwBNBA0AaQCOCzoBBQrqA4gK6QKGAMADFAAAAJQLAAAEAO0DBArvAAYK3QEHCkcGCwpEAIsKaQIGABMABwCFBYsArAGVCg0ABwBgAAgAkQEIAL8CCQCAA4gLLAGGADsGkQB0AIgA/QMHAKkHBwCtBwcA7gcIAJYACAC+AggA4QIIAO4CjABuAQsLSwCOCwsBhApvAQgAIAMJAJQACQBoAwkAegML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AEQBBAsAAAULKQAHC7MFBwu9BQcLUgYHC0MHCQslAosLiQMECmIABwpVBQkKpgEJCp4CCgoHAwsK0gANChoADQrJAY0K3AEGALcGBgDHBgcA4AcHAOQHCABFA4kAVAOFC7gChwBUA4QAuAOGCsIGhAsDA4oAOAKJAMABiwCSAAgAQwCKAKMBhQuZA4kKkwCGACIHCgCRAg4AKQGOAGkBBgCaAgYA/wKGAAYGiwDZAgYLtAAHC3EECAvvAosLJQMEC7cABwsPAQsLOAMLC7gDDQsWAQ0LUwENC+IBDguoAZQLYwAEAJ0CBQvdAQULVAIGC/kBBwvFBAsLiwMMC9EAjQvWAIcLvwQFAJIBBgoeAAsKOACLCjEBBws0Ao4LqACLAJgABwCQA4cKTgYECpYABQovAYYKRwEHAEABCAAzAAkAZAMKAEEDDADhAQwAOgKUAGoAhAC9AQcLEgELCwcBCwvfAQsL+wGMCxUBCgArAgsANAETAF8ABgttBggKwAAKCk4AjQpnAYcKEgMGC1wABgu8AAcL9QQHC/QFBwtUBwoL5ACLC/wDBAvLAYULxgMLAIIBBgpmBgcKTwAHCvABCQqKAAoKUAEMCpwBDAq4AY4KMQGFAO8ABwBTAAcAxgcIAIIAiwDQAooLxQIEAI8ABQAmAoUA8AIFAHsABgASAgcAXAGHAIsFhwDoBwYLEgAHC7MABwvRAgcLpAMICyQCCAv1AgkLNgAJC0EACQsUAgkLTAMKC3EACgt1AAoL7AAKCzsBCguuAQoLHgMLC5kACwtfAQsLdwEMC04ADAuXAAwLiAEOC/gAjwsXAAcKzAAHCp8BCAoqAAoKVQCLCjQChgC+A4ULxQOEANIAhwuVBYoL4AGGC7YAiwtZAQoLQQAKC+gBigvxAQQKAwAFCvcABQqEAgcK6AIHCrcEBwrJBAcKdQeSCpMAhACuAQUKHQEJCkMADQrZAY8KUgCQCxAABwuKBAkLTAIKCwQBlwoIAIUA1QCKAAcAhwAhA4YL+gaHCzQBBgCoA4YACQWFAGwAhAB1A4UA2wCLAEsCBADBAAUAlAMGABEEBwBsAQoAjgEKANYCCwA9AQsAcgIMAI4ADAAgAQwApgINADkBDwBxAJIAcgCHAI0EBgDxAAkAVgEKANkCCwAcAQsAvQELAIsCCwBfAw0AjgGSAGMABwCLA4gAQAMJAC8BBAodAAYKFAIHClwGBwpwBgkKXgEKCrEBCwphAAsKLQILCukCDAohAQwKTwEMClwBDApeAg0KdAANCukADQrSAQ4KtQAOCtEADgroAA4K7AAOCiwBEAopAJQKYQAHC6cBBwqcBogLTAIGAKMDhgCuBQUK9QEHCqgGCQopAgsKCAIMCi0CjQr5AIgLHwEEADICCQD+AIsAbwOEABIDDgsgABILVQAUCwIAmAsQAIcADgUHC9MChwtvBAYA2AAHAIUDBwA/BQgA7QGGC5MBBwvPAggLKQOIC0IDBQvSAAYL1QAHCzwACgtsAYsLhwAHAFUBCwDbAAULXwIIC0YBiAvqAQQLvQIFC9gBBQt/AgcL4QQJC/YCiwuAA4cLfAGHC5sHiwCCAIcAxgYKAHMACwCkAQwAmgANAJQBDgBaAY8ANgCGCoEABAuCAQcLKQAIC5UBCQvxAQsLbgALC2gBDwslAJALVACNCxoBBQsuAAcLrAUHC8gFCAt6AowL2AEECwwCiAsqAwoL7gCNCyEAhQBcAgUA8wOIAL0CCABYAwgAWgMIAG8DDAC+Ao4AvwEEADYABQCaAgcADwQHAGoECQDDAIoALgEEChkABQo8AAYK+AEHCmYCBwqDBIwKAAAHCuAECwptAosKvgKFC+UDiQpBAYYAhQaGAP8GBAp7AYcKdQWKC3QBBQsOAwULPQOGC8oGhwDMBAQKdgAGChIBBgppAQcKSwCNCrkBhABvAgkLFwEKC5cBDgtUAJYLEgCJCkkDhwAeA4wKtQIFCjoBBgrdAAcKowEKCooCCwqMAQwKnAANCnEBDgpNAZEKLwCHC1wFBwB6AAkAAwEKAFQACwDWAQwAHQKNAHsBhgBFAwgA9QMEC04ABQtgAAULtgAHC7wGBwshBwoLigEKC9cBCwsUAg4LVAGRC1gAhgBBAocLrAeECpEDhgDMAQgAewMKAIUDCgCXAwoApAMMAMsCDADYAgwACQMOAMkBkABnAAUAUgAFAIMABwDbBggAHwAJAKgACQD8AosAZQOICtsBBgBdAgUK+AMJC1kCCQtrAgoL+QEKC9wCCwtjAYwLiwAHCloCCAqzAAoKDQOMCn4AhgDeBAYKSQGKCm8ABgvXAAcLBAQHC8EFBwu5BgkLqAGKCwsDBQAWAYkARAAGAKQDBgA8BJAAVgAEAKMABQDJAAUAMwEFADYBBgBPAQcAHAEHAHwGiAClAIgADQOGAMMCBgAhAIcA3AQFCjUDBgtDAAYKlwYHCwIBBwteBgkLYgEJC6MCCgs+Aw4LUACRC1AABguNAAcL4QAJCzsACQtfAgoLOAELC68CDAsrAg0LdQENC+4BlAs6AIYAWQQJAIQBBQpHAAcKfwUJCsACCgoFAQoKawILCiMCCwprAo8KnQAHAKEHiADQAooAywAHCtgHCQpRAYoKBQIGAEYBBwClAokAqQGLC1EABwAkBQcAhAUHAC8HCQBNAgsA8QALAKQCCwArAwsAewMMAIwADABaAQwA3wENAIwADQB9AQ4AvAASAB4AlABsAAUAoAEGClYABgpbAgcKJAEHCjECCAoBAQgKfgEJCtECCQoKAwsKRQKMCtIBBArmAYUK6wGGABQFhApIAAcATwMGCgkBBwuuAYsLLgAFC1oCBgtqAAcL+gYHCx0HBwviBwkLogGJC/sCBQBmAQcAFwIHAKAECgCWAg0A1AANADABDQBNAZEAYgAFC0EABgugAQcLuAYHC4QHCAulAgoLbQALCw4ACwtGAAsLOQILC98CDwuZAJQLUAAGAB8HCABHAwgAVAMIAIcDCgCsAwwAwwKMAAcDhwvNBAYA8gWMAI4CiAtTAosAowCNADoBhADSAwQAWQIGAPMHiQrqAAUKLwMGCpgGhgrbBoUAsgOIALIBBgrFAIgKzQAHAJsBBwBOAggAdwIJAEMBCgBjAQsA6wEMAI8ADACSAQ0ASQAOAJgBDwBrAJIARwAHALsFCABIAQoAIAILALsDDAANAA0AQAGRAFMAjgCaAQsA/wENAIoBDgAqAQ4APgGSAGcABgrEAQcKOAGKCtsAigpNAgQKTQEJCrAADAphAY0KuwCHC0kBhAvVAQUAQwOGAOMBhgvPBgULoQMGC1QBCAt4AYgLJwOGCpUGhAClAgUL2gAHC0oGigtTAAULOwKHCzIHhAvHAYkARgCHAH0FBwqHAAgKBwAICj4ACQrzAAoKkgIKCrkCCwrIAYsK9AIJCosBigpPAIkAbAAGC6EABwt0AYkLVQKEC10BhAAJA4QASwGHCncChQDrAgYLsAEGC2ACiwtCAYoKQwMFC9QBBwsRBwoLRQELC1gDDAtZAY8LaACFC98ABwqWAQcKywEICl4CiwrWAoQLNgKOAEQABAs7AIcLcgUG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ALgBDQAoAAYKMAEICqIBCwpVAYsKowIOACgBCQqaAYsKqQEKC3kBDAtrAQ0LRAANC14ADgtsAI4LMgEHAHkFhwDEBQQAKAEGANsBBwCRAQcAggUHADoGBwCKBggAPwAIAJQCiQBKAAQAiwAEAIQBjAC8AIQAHQOEC/4CBQtnAAcLmQMIC0QCCAtRAggLdgKKCxwABAuPAwULYwOFC/UDhgoOAIYAJAaGCqwGFQAnAAUKcQAGCvMABwpJBwsKoQAQCiUAkQpjAAcLGwaNC7YABQuHAAYLBwIHC7oGCgsPAQsLBQGRCzYAhAoSAYYAOgYECywBBQu0AYcL5AEEAOsCBgAiAQcAiQIHAMcFhwAvBoULFwKTC1IAhQDoAIkAdwOHCqYAiAAJAgQADgAHANgBBwAJBwoA7AKNAMoBhgDlAoYA4AMQAG8AiQowAQQAqQEFC4MBBwstAgwLIwKOC1YAhwvTBgUKjgKHC9EFBwAVAwQLBgAFC8QCiAtLAAYKEQEKCrwADQp5AZIKTQAGADkGBAsvAQcLawIKCyMCCguvAgsLegCMC1kChgDoBocKmgGKCwQDCwDpAIsKDAIFAK8DhgDzBoYK+QaICxEChAC7AwUA9QAGAEACBwBGAogA4QCECgwDjgDxAIYAlwcEC2oABws2AQcL+QYKC7ICiwvNAoYABAUFC3oDhQvcAwYLcgKOC68BCgvCApELIACJC0wBhAu6AocAxQIFCrQDigsRAIgAKgKGABwGiwqtA4QAuwGGAI0DhgtUAI4AGAEEChQCBQrCAocKlgKEANkCBQpFAwYKcwaLCtkDhwpFBwQAXAGYCwMABQvaAwYLggAHCy4GCAvKAQoLZQAKCz4Bigs3A4YA9gIEACoBiQBQAwQKSgEHCqUDBwrcB4gKJAEHC2wGiQuBAAYAjgUJAD0Dhwr/AgUApAAHAHkAjgC9AAcALAMHAO0EBwBQBQkAeAKMAGABhwv8BosALAKHC+UDkQpyAAQArAAJAGMCCgC0AQwAoQINAP8AiQpzAwsAEgKKChIBhQBMA4YA2AMNAOgAEgAjAAQKvwKHCs8AhAo7AgkABwEKAJMAigDsAQcL3AaJC2IABQppAwUKwAMICjcDiQpxA4UAGQKEAFsDBwsWBIsLoACJAEoDiwobAQUKIQAGCtYBiwqoAQYLLQAHC7EBCAuBAAkLFQAK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AJsDhAv2AooL1wCICu8BBwo2AAgKOAEKCr8ACgpmAowKNwIHC18BiwuAAAcAawMGCtQBBwrGBQgKEgKOCiIBhwD8BhEAMQCFC5YDDAuOARQLJwAVCwsAlgspAAoAlQIGCuQBhwo2A4cAmQeGABoDiQqEA4cKNwUGCrwGhwrmB4QLVAGGAG8EBAAQA4UA6QIFAFQAhgCjAIUAmgEEANADBQvZAwcL/QEHCxECkQtgAIQK2gGGAL8Chwt/BwUAQgEIALoACQAGAQoAuwCOANAAhwrgBYUA4wAJADACDQDQAIUKMQGEC/cABwBzBQgA5gEJAOwACQBuAwoA2gALAF8AEwARAJMAHwAHAPsHCACgAo0AwAEEC7gABQuGAQYLUQEHCxcABwvuAQcLagIHC7AFCAsbAAgLVwIKC5kAiwvGAocA0gGHCtQEBgCnAAcAugAHAJACCgCDAgQK4AEGCi4BBgpqBgcKRQMHCgsGBwp5BggKrQEJCuQADQohAQ0KVwGTCmUAhgCUBYYAoAUFAJwBBwoWAQoK4wILCsQCjQpcAYYAXgSIADIClAsuAAkAPAGLAAABhgDrBocApgSJAIQACgvjAAsL8QELC8UCjAufAY8AQgAGC2gBBwuABogL3gGQChwABAA9AYcA/wQFAD8AhQD9AYgLuwKRCiQAhgDDBQsLVwGOC38AhAvjAoQAIAGHC90GCABZAAgAbAIJAGACCwB0AgwAQgGPAHwAhgDJBAcApQQEC0MABQumAQYKawEHCw0EBwsJBQcLEwYHCqMHCArVAgkL5QKRC2wAhgC8BQYAsQKGAKsFigB4AJcAAQCJCiUDjgBJAQUKLQOHCv4HhwDiAIoLYAAHAD8HBQrIAgsKEQANCkEBkApDAAkAzQEGCkABBwoNAwcKgQcJCjcACgq6AAoKEQEKCpgCCgohAwsK5AMLCuUDDQqdAI4KqgAIC8sACAoPAQsLNwMLC04DDAviAQ0LhQANCxUBDQsuAQ0L0AEOC80AjgvdAIcAQgUEC8EBhQvOAoYAVQAOACsBBwpnAAcKXwMLCrgAkQo+AAQLYwEGCzcBCQsAAYoLlAGJCpMCigv2AoULOwMFC0AAjAtFAoYAkwQEC7oBBwsXBAcLSAWHC2sGhADUAwUL0QMGCyABBwsQAocLKQQFABcBBgDrAAcA1AEIAL4BCQB9AgoAzQIL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AK8ABApOAYUKUQKNC1cAiAv+AgoAHwEMAIoACgsfAYwLigAEAGkAhADkAowKdACGAFkDhwsxBwYAegWJADMDhAtIAoQKxQKFCoEDBQDgAA0ArgCSADQAhwowBwQKYAKFCvEBiws8AAQA9gKHAHEGBAviAAQLRgGHC+oGBQuqAQgLHgAJCwIACwslApMLegCHCvcHBgocAogKiAAEAD0CCACPAgQKgQOFChIDBwBfAYsAgACFCucDBAorAYcK7AOFAJYDhAtZAQQLgQEHCwkBhwtLAoUKyAGICrQABgCvAoYAAQYEC1sBBQunAQUL5AOHCzEFhArzAgcL6wQJC30ACwtBAIwLHQEFC4gABguIAIgLhAKGAPUFBADxA4cAcwSLClIBhABUAYcKuAUIAE8DCgBdAwoAbAMKAHkDCgCaAwoAoQMKAKUDDAAQA4wAFwOLALAACQuGAAoLAgAKCxsACgtNAQsL0gKPCwEABAuxAYULzwIFANkDBwD9AQcAEQKRAGAAhABnAgQKegMFCiUDBQozAwUKwQMGCowBBgpfBgYKjgYHCq8HBwr5BwkKdgILCggACwr7AwwKsAANCuEADgokAZUKGACHAH8HhgBrBJALFQCQCzMAhwoXBwQA9wAHCuEFCgq+AAoKegILChgDDApmAYwKvwEFCgAABgoYAgcKXAINCr0BkQp+AAQAuAAFAIYBBgBRAQcAFwAHAO4BBwBqAgcAsAUIABsACABXAgoAmQCLAMYCBgroAAYKnAEHCjIECAoJAAgKnQAIChIDCQrEAAkKYAEJCskBCgpRAQsK6AALCm0DDArgAYwKIgINACYAhwq+AwQKfgGICkMCBArUAIcKtgQECysCCAsYAooLIAELC4sAiwurAAkLcgGKC1oAhAD3A4YAQAQFCo8ChwvRA4YAMQYRCkMAkwpKAAoA4wALAPEBCwDFAowAnwEGAGgBBwCABogA3gEHAF8ABgrnAIgKpwGMC0EABAsBAYcL7weHC+gGhQosAYsL0wCIALsCBgrtAAcKYwIICmQACQqgAQsKTwEMCq0AkgplAA4AGgCSAJYABgBFAocAXwSHCrgEhADjAgYLUwAGC8UGhwttBYkAZQMEAEMABQCmAQcADQQHAAkFBwATBgkA5QKRAGwAhQrHAAwKqwGSCiYAiADQAY4AKgAKAGAACAv1AYkLuAKG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C84BBwvKA4cLSQQEChwABQq4AQcK+AALCkEDjApYAYYKdgYGAHgCBgCMAgYA+AQGAGgFhgAYBoYLqAYGAHEFhQpVAwYK+QAHCtIEiwo9AgULVgAHC+cCCQtVAAoLGQEKC7ABCwvqAQwL+wANC3YADgt6AZILjwAFCwwChQvoAoYA6gUKAMkAjgA/AQcAzQIKAP4BBwqIAQgKFAAICqwACAqyAgkKfwEJCk0DCwolAQsKQAMLCpgDCwrYA40K3QCGAGUFBQpaA4UK4AMIABACiQBcAQoLawCMC7QBBAAUAIUAaAKGAOMEhAufAwoLewAMC54CDQtzAQ4LjgCSC14AhgCLBAcLfQSJC5wAhgAzAYULCgMHAEMEhwDlBgUL9gEGCgwBiQo+AAgLxAAKCxsBiwuWAQQAGgAFAK0BBgD1AAcAwAIHAGMFhwDCBYULVwOEAHEDBABtAocLPAYHC3gFCQu+AYoLLQAGAOACigpqAIUAHgKGAFwBhQBkA4gAsQGHANcFigADAwYKZQKICt8AigDXAI0AfACIC4cBhwusAIQKngKMADcACQooAIsKiAAHAD4AkwBwAIQAWAOECzgCDAAOAYsKAwEIADwCiQC6AgQL3AIJCjYBiQqqAo4KKAGGAKsDiAvdAocLmwUHCnkFhwrEBQYAYAEECigBBwqRAQcKggUHCjoGBwqKBggKPwAICpQCiQpKAAQLrAGFC5wCBAqLAAQKhAGMCrwABwvfB4wLmQKEAIcCkgAKAIoA3ACOANABhABtAIYA0gYGAAMCBArrAgYLVwYGC5EGBwqJAgcKxwWHCi8GhQroAIcANgKJCncDBAAoAAoAQwALAHUACwAAA4sApwOEACEDBwDgAwgALQEJANICDAA/AA0AHQAOAKEAjwASAIsAmwMGC9QGCAvLAgkLIgMKCy4ACgszAw0LNAEOC18BDgtrAZILQwCJC+kCBwB5BAQKDgAHCgkHCgrsAo0KygEECz8ABQtbAYYL2gGHADgCBAqpAQcLQQIHC5gFCQvbAQkL+QEJCw4CCQthAgkLsQIJC9YCCQvfAgkL4gIKCywCCguiAgoLrAILC1kACwvKAAsLEAELC3wBCwufAQsL+QELCxkCCwsmAgsLMgILC4ACCwubAgsLsAILC08DCwufAwsLogMLC6wDDAuQAAwLRQEMC0kBDAuFAQwLkwEM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E2FBhhNhQd4TYUE2FGFBjhRhQeYUYUE+FWFBlhVhQe8VYUFHFmFBnxZhQfcWYUFPF2FBpxdhQf8XYUFXGGFBrxhhQQcZYUFfGWFBtxlhQQ8aYUFnGmFBvxphQRcbYUFvG2FBxxthQR8cYUF3HGFBzxxhQScdYUF/HWFB1x1hQS8eYUGHHmFB3x5hQTcfYUGPH2FB5x9hQT8gYUGXIGFB7yBhQUchYUGfIWFB9yFhQU8iYUGmImFB/iJhQVYjYUGuI2FBBiRhQV4kYUG2JGFBDiVhQWUlYUG9JWFBFSZhQW0mYUHFJmFBHSdhQXUnYUHMJ2FBJChhQXwoYUHUKGFBLClhQYMpYUHbKWFBMyphQYsqYUHjKmFBOithQZIrYUHqK2FBQixhQZksYUHxLGFBSS1hQaEtYUH4LWFBUC5hQaguYUEAL2FBVy9hQa8vYUEHMGFBXjBhQbYwYUEOMWFBZTFhQb0xYUEVMmFBbDJhQcQyYUEcM2FBczNhQcszYUEjNGFBejRhQdI0YUEqNWFBgTVhQdk1YUEwNmFBiDZhQeA2YUE3N2FBjzdhQeY3YUE+OGFBljhhQe04YUFFOWFBnDlhQfQ5YUFLOmFBozphQfs6YUFSO2FBqjthQQE8YUFZPGFBsDxhQQg9YUFfPWFBtz1hQQ4+YUFmPmFBvT5hQRU/YUFsP2FBxD9hQRtAYUFzQGFBykBhQSFBYUF5QWFB0EFhQShCYUF/QmFB10JhQS5DYUGFQ2FB3UNhQTREYUGMRGFB40RhQTpFYUGSRWFB6UVhQUFGYUGYRmFB70ZhQUdHYUGeR2FB9UdhQU1IYUGkSGFB+0hhQVNJYUGqSWFBAUphQVlKYUGwSmFBB0thQV9LYUG2S2FBDUxhQWRMYUG8TGFBE01hQWpNYUHCTWFBGU5hQXBOYUHHTmFBH09hQXZPYUHNT2FBJFBhQXxQYUHTUGFBKlFhQYFRYUHYUWFBMFJhQYdSYUHeUmFBNVNhQYxTYUHjU2FBO1RhQZJUYUHpVGFBQFVhQZdVYUHuVWFBRlZhQZ1WYUH0VmFBS1dhQaJXYUH5V2FBUFhhQadYYUH+WGFBVllhQa1ZYUEEWmFBW1phQbJaYUEJW2FBYFthQbdbYUEOXGFBZVxhQbxcYUETXWFBal1hQcFdYUEYXmFBb15hQcZeYUEdX2FBdF9hQctfYUEiYGFBeWBhQdBgYUEnYWFBfmFhQdVhYUEsYmFBg2JhQdpiYUExY2FBiGNhQd9jYUE2ZGFBjWRhQeRkYUE7ZWFBkmVhQellYUE/ZmFBlmZhQe1mYUFEZ2FBm2dhQfJnYUFJaGFBoGhhQfZoYUFNaWFBpGlhQftpYUFSamFBqWphQQBrYUFWa2FBrWthQQRsYUFbbGFBsmxhQQhtYUFfbWFBtm1hQQ1uYUFkbmFBum5hQRFvYUFob2FBv29hQRVwYUFscGFBw3BhQRpxYUFwcWFBx3FhQR5yYUF1cmFBy3JhQSJzYUF5c2FBz3NhQSZ0YUF9dGFB1HRhQSp1YUGBdWFB2HVhQS52YUGFdmFB3HZhQTJ3YUGJd2FB4HdhQTZ4YUGNeGFB43hhQTp5YUGReWFB53lhQT56YUGVemFB63phQUJ7YUGYe2FB73thQUV8YUGcfGFB83xhQUl9YUGgfWFB9n1hQU1+YUGjfmFB+n5hQVB/YUGnf2FB/n9hQVSAYUGrgGFBAYFhQViBYUGugWFBBYJhQVuCYUGygmFBCINhQV+DYUG1g2FBC4RhQWKEYUG4hGFBD4VhQWWFYUG8hWFBEoZhQWmGYUG/hmFBFYdhQWyHYUHCh2FBGYhhQW+IYUHFiGFBHIlhQXKJYUHJiWFBH4phQXWKYUHMimFBIothQXiLYUHPi2FBJYxhQXyMYUHSjGFBKI1hQX+NYUHVjWFBK45hQYGOYUHYjmFBLo9hQYSPYUHbj2FBMZBhQYeQYUHekGFBNJFhQYqRYUHgkWFBN5JhQY2SYUHjkmFBOZNhQZCTYUHmk2FBPJRhQZKUYUHplGFBP5VhQZWVYUHrlWFBQZZhQZiWYUHulmFBRJdhQZqXYUHwl2FBRphhQZ2YYUHzmGFBSZlhQZ+ZYUH1mWFBS5phQaKaYUH4mmFBTpthQaSbYUH6m2FBUJxhQaacYUH8nGFBUp1hQamdYUH/nWFBVZ5hQaueYUEBn2FBV59hQa2fYUEDoGFBWaBhQa+gYUEFoWFBW6FhQbGhYUEHomFBXaJhQbOiYUEJo2FBX6NhQbWjYUELpGFBYaRhQbekYUENpWFBY6VhQbmlYUEPpmFBZaZhQbumYUERp2FBZ6dhQb2nYUETqGFBaahhQb+oYUEVqWFBa6lhQcGpYUEWqmFBbKphQcKqYUEYq2FBbqthQcSrYUEarGFBcKxhQcasYUEbrWFBca1hQcetYUEdrmFBc65hQcmuYUEfr2FBdK9hQcqvYUEgsGFBdrBhQcywYUEisWFBd7FhQc2xYUEjsmFBebJhQc6yYUEks2FBerNhQdCzYUEmtGFBe7RhQdG0YUEntWFBfbVhQdK1YUEotmFBfrZhQdS2YUEpt2FBf7dhQdW3YUEquGFBgLhhQda4YUEruWFBgblhQde5YUEtumFBgrphQdi6YUEuu2FBg7thQdm7YUEuvGFBhLxhQdq8YUEvvWFBhb1hQdu9YUEwvmFBhr5hQdy+YUExv2FBh79hQdy/YUEywGFBh8BhQd3AYUEzwWFBiMFhQd7BYUEzwmFBicJhQd7CYUE0w2FBisNhQd/DYUE1xGFBisRhQeDEYUE1xWFBi8VhQeDFYUE2xmFBi8ZhQeHGYUE2x2FBjMdhQeHHYUE3yGFBjMhhQeLIYUE3yWFBjMlhQeLJYUE3ymFBjcphQeLKYUE4y2FBjcthQePLYUE4zGFBjcxhQePMYUE4zWFBjs1hQePNYUE4zmFBjs5hQePOYUE4z2FBjs9hQePPYUE50GFBjtBhQePQYUE50WFBjtFhQePRYUE50mFBjtJhQePSYUE502FBjtNhQePTYUE51GFBjtRhQePUYUE41WFBjtVhQePVYUE41mFBjdZhQePWYUE412FBjddhQePXYUE42GFBjdhhQeLYYUE32WFBjdlhQeLZYUE32mFBjNphQeLaYUE322FBjNthQeHbYUE23GFBi9xhQeHcYUE23WFBi91hQeDdYUE13mFBit5hQeDeYUE132FBit9hQd/fYUE04GFBieBhQd7gYUE04WFBieFhQd7hYUEz4mFBiOJhQd3iYUEy42FBh+NhQdzjYUEx5GFBhuRhQdvkYUEx5WFBhuVhQdvlYUEw5mFBheZhQdrmYUEv52FBhOdhQdnnYUEu6GFBg+hhQdjoYUEt6WFBgulhQdfpYUEs6mFBgephQdbqYUEr62FBgOthQdXrYUEq7GFBf+xhQdPsYUEo7WFBfe1hQdLtYUEn7mFBfO5hQdHuYUEm72FBe+9hQdDvYUEl8GFBevBhQc7wYUEj8WFBePFhQc3xYUEi8mFBd/JhQczyYUEh82FBdfNhQcrzYUEf9GFBdPRhQcn0YUEe9WFBcvVhQcf1YUEc9mFBcfZhQcb2YUEa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GWNBQhpjQZIaY0HjGmNBNBtjQYUbY0HVG2NBJhxjQXccY0HHHGNBGB1jQWkdY0G5HWNBCh5jQVseY0GrHmNB/B5jQU0fY0GdH2NB7h9jQT8gY0GPIGNB4CBjQTEhY0GBIWNB0iFjQSIiY0FzImNBxCJjQRQjY0FlI2NBtSNjQQYkY0FXJGNBpyRjQfgkY0FIJWNBmSVjQeklY0E6JmNBiyZjQdsmY0EsJ2NBfCdjQc0nY0EdKGNBbihjQb4oY0EPKWNBXyljQbApY0EAKmNBUSpjQaEqY0HyKmNBQitjQZMrY0HjK2NBNCxjQYQsY0HVLGNBJS1jQXYtY0HGLWNBFy5jQWcuY0G3LmNBCC9jQVgvY0GpL2NB+S9jQUowY0GaMGNB6jBjQTsxY0GLMWNB3DFjQSwyY0F8MmNBzTJjQR0zY0FuM2NBvjNjQQ40Y0FfNGNBrzRjQf80Y0FQNWNBoDVjQfA1Y0FBNmNBkTZjQeE2Y0EyN2NBgjdjQdI3Y0EjOGNBczhjQcM4Y0EUOWNBZDljQbQ5Y0EFOmNBVTpjQaU6Y0H1OmNBRjtjQZY7Y0HmO2NBNjxjQYc8Y0HXPGNBJz1jQXc9Y0HIPWNBGD5jQWg+Y0G4PmNBCT9jQVk/Y0GpP2NB+T9jQUlAY0GaQGNB6kBjQTpBY0GKQWNB2kFjQStCY0F7QmNBy0JjQRtDY0FrQ2NBu0NjQQxEY0FcRGNBrERjQfxEY0FMRWNBnEVjQexFY0E9RmNBjUZjQd1GY0EtR2NBfUdjQc1HY0EdSGNBbUhjQb1IY0ENSWNBXkljQa5JY0H+SWNBTkpjQZ5KY0HuSmNBPktjQY5LY0HeS2NBLkxjQX5MY0HOTGNBHk1jQW5NY0G+TWNBDk5jQV5OY0GuTmNB/k5jQU5PY0GeT2NB7k9jQT5QY0GOUGNB3lBjQS5RY0F+UWNBzlFjQR5SY0FuUmNBvlJjQQ5TY0FeU2NBrlNjQf5TY0FOVGNBnlRjQe5UY0E9VWNBjVVjQd1VY0EtVmNBfVZjQc1WY0EdV2NBbVdjQb1XY0ENWGNBXFhjQaxYY0H8WGNBTFljQZxZY0HsWWNBPFpjQYtaY0HbWmNBK1tjQXtbY0HLW2NBG1xjQWpcY0G6XGNBCl1jQVpdY0GqXWNB+l1jQUleY0GZXmNB6V5jQTlfY0GIX2NB2F9jQShgY0F4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m2pBbptqQaibakHim2pBHZxqQVecakGRnGpBzJxqQQadakFAnWpBe51qQbWdakHvnWpBKZ5qQWSeakGenmpB2J5qQROfakFNn2pBh59qQcGfakH8n2pBNqBqQXCgakGqoGpB5aBqQR+hakFZoWpBk6FqQc6hakEIompBQqJqQXyiakG3ompB8aJqQSujakFlo2pBoKNqQdqjakEUpGpBTqRqQYmkakHDpGpB/aRqQTelakFxpWpBrKVqQealakEgpmpBWqZqQZWmakHPpmpBCadqQUOnakF9p2pBuKdqQfKnakEsqGpBZqhqQaCoakHaqGpBFalqQU+pakGJqWpBw6lqQf2pakE4qmpBcqpqQayqakHmqmpBIKtqQVqrakGVq2pBz6tqQQmsakFDrGpBfaxqQbesakHxrGpBLK1qQWatakGgrWpB2q1qQRSuakFOrmpBiK5qQcOuakH9rmpBN69qQXGvakGrr2pB5a9qQR+wakFZsGpBk7BqQc6wakEIsWpBQrFqQXyxakG2sWpB8LFqQSqyakFksmpBnrJqQdiyakETs2pBTbNqQYezakHBs2pB+7NqQTW0akFvtGpBqbRqQeO0akEdtWpBV7VqQZG1akHLtWpBBbZqQT+2akF5tmpBtLZqQe62akEot2pBYrdqQZy3akHWt2pBELhqQUq4akGEuGpBvrhqQfi4akEyuWpBbLlqQaa5akHguWpBGrpqQVS6akGOumpByLpqQQK7akE8u2pBdrtqQbC7akHqu2pBJLxqQV68akGYvGpB0rxqQQy9akFGvWpBgL1qQbq9akH0vWpBLr5qQWi+akGivmpB3L5qQRa/akFQv2pBir9qQcS/akH+v2pBOMBqQXLAakGrwGpB5cBqQR/BakFZwWpBk8FqQc3BakEHwmpBQcJqQXvCakG1wmpB78JqQSnDakFjw2pBncNqQdfDakEQxGpBSsRqQYTEakG+xGpB+MRqQTLFakFsxWpBpsVqQeDFakEaxmpBVMZqQY3GakHHxmpBAcdqQTvHakF1x2pBr8dqQenHakEjyGpBXMhqQZbIakHQyGpBCslqQUTJakF+yWpBuMlqQfLJakErympBZcpqQZ/KakHZympBE8tqQU3LakGHy2pBwMtqQfrLakE0zGpBbsxqQajMakHizGpBG81qQVXNakGPzWpByc1qQQPOakE8zmpBds5qQbDOakHqzmpBJM9qQV7PakGXz2pB0c9qQQvQakFF0GpBf9BqQbjQakHy0GpBLNFqQWbRakGf0WpB2dFqQRPSakFN0mpBh9JqQcDSakH60mpBNNNqQW7TakGn02pB4dNqQRvUakFV1GpBjtRqQcjUakEC1WpBPNVqQXXVakGv1WpB6dVqQSPWakFc1mpBltZqQdDWakEK12pBQ9dqQX3XakG312pB8ddqQSrYakFk2GpBnthqQdfYakER2WpBS9lqQYXZakG+2WpB+NlqQTLaakFr2mpBpdpqQd/aakEY22pBUttqQYzbakHG22pB/9tqQTncakFz3GpBrNxqQebcakEg3WpBWd1qQZPdakHN3WpBBt5qQUDeakF63mpBs95qQe3eakEn32pBYN9qQZrfakHT32pBDeBqQUfgakGA4GpBuuBqQfTgakEt4WpBZ+FqQaHhakHa4WpBFOJqQU3iakGH4mpBweJqQfriakE042pBbuNqQafjakHh42pBGuRqQVTkakGO5GpBx+RqQQHlakE65WpBdOVqQa3lakHn5WpBIeZqQVrmakGU5mpBzeZqQQfnakFB52pBeudqQbTnakHt52pBJ+hqQWDoakGa6GpB1OhqQQ3pakFH6WpBgOlqQbrpakHz6WpBLepqQWbqakGg6mpB2epqQRPrakFN62pBhutqQcDrakH562pBM+xqQWzsakGm7GpB3+xqQRntakFS7WpBjO1qQcXtakH/7WpBOO5qQXLuakGr7mpB5e5qQR7vakFY72pBke9qQcvvakEE8GpBPvBqQXfwakGx8GpB6vBqQSTxakFd8WpBl/FqQdDxakEK8mpBQ/JqQXzyakG28mpB7/JqQSnzakFi82pBnPNqQdXzakEP9GpBSPRqQYL0akG79GpB9PRqQS71akFn9WpBofVqQdr1akEU9mpBTfZqQYb2akHA9mpB+fZqQTP3akFs92pBpvdqQd/3akEY+GpBUvhqQYv4akHF+GpB/vhqQTf5akFx+WpBqvlqQeT5akEd+mpBVvpqQZD6akHJ+mpBAvtqQTz7akF1+2pBr/tqQej7akEh/GpBW/xqQZT8akHN/GpBB/1qQUD9akF6/WpBs/1qQez9akEm/mpBX/5qQZj+akHS/mpBC/9qQUT/akF+/2pBt/9qQfD/akEqAGtBYwBrQZwAa0HW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IG5B3yBuQREhbkFDIW5BdSFuQachbkHZIW5BCyJuQT0ibkFvIm5BoSJuQdMibkEGI25BOCNuQWojbkGcI25BziNuQQAkbkEyJG5BZCRuQZYkbkHIJG5B+iRuQSwlbkFeJW5BkCVuQcIlbkH0JW5BJiZuQVgmbkGKJm5BvCZuQe4mbkEgJ25BUiduQYQnbkG2J25B6CduQRoobkFMKG5BfihuQbAobkHiKG5BFCluQUYpbkF4KW5BqiluQdwpbkEOKm5BQCpuQXIqbkGkKm5B1ipuQQgrbkE6K25BbCtuQZ4rbkHQK25BAixuQTQsbkFmLG5BmCxuQcosbkH8LG5BLi1uQWAtbkGSLW5BxC1uQfYtbkEoLm5BWS5uQYsubkG9Lm5B7y5uQSEvbkFTL25BhS9uQbcvbkHpL25BGzBuQU0wbkF/MG5BsTBuQeMwbkEVMW5BRzFuQXgxbkGqMW5B3DFuQQ4ybkFAMm5BcjJuQaQybkHWMm5BCDNuQTozbkFsM25BnjNuQc8zbkEBNG5BMzRuQWU0bkGXNG5ByTRuQfs0bkEtNW5BXzVuQZE1bkHCNW5B9DVuQSY2bkFYNm5BijZuQbw2bkHuNm5BIDduQVE3bkGDN25BtTduQec3bkEZOG5BSzhuQX04bkGvOG5B4DhuQRI5bkFEOW5BdjluQag5bkHaOW5BDDpuQT06bkFvOm5BoTpuQdM6bkEFO25BNztuQWk7bkGaO25BzDtuQf47bkEwPG5BYjxuQZQ8bkHFPG5B9zxuQSk9bkFbPW5BjT1uQb49bkHwPW5BIj5uQVQ+bkGGPm5BuD5uQek+bkEbP25BTT9uQX8/bkGxP25B4j9uQRRAbkFGQG5BeEBuQapAbkHbQG5BDUFuQT9BbkFxQW5Bo0FuQdRBbkEGQm5BOEJuQWpCbkGcQm5BzUJuQf9CbkExQ25BY0NuQZRDbkHGQ25B+ENuQSpEbkFbRG5BjURuQb9EbkHxRG5BI0VuQVRFbkGGRW5BuEVuQepFbkEbRm5BTUZuQX9GbkGxRm5B4kZuQRRHbkFGR25BeEduQalHbkHbR25BDUhuQT5IbkFwSG5BokhuQdRIbkEFSW5BN0luQWlJbkGbSW5BzEluQf5JbkEwSm5BYUpuQZNKbkHFSm5B90puQShLbkFaS25BjEtuQb1LbkHvS25BIUxuQVJMbkGE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Im9BKSNvQVkjb0GJI29BuSNvQegjb0EYJG9BSCRvQXgkb0GoJG9B2CRvQQglb0E4JW9BaCVvQZglb0HIJW9B9yVvQScmb0FXJm9BhyZvQbcmb0HnJm9BFydvQUcnb0F3J29BpydvQdYnb0EGKG9BNihvQWYob0GWKG9BxihvQfYob0EmKW9BVSlvQYUpb0G1KW9B5SlvQRUqb0FFKm9BdSpvQaUqb0HUKm9BBCtvQTQrb0FkK29BlCtvQcQrb0H0K29BIyxvQVMsb0GDLG9BsyxvQeMsb0ETLW9BQi1vQXItb0GiLW9B0i1vQQIub0EyLm9BYi5vQZEub0HBLm9B8S5vQSEvb0FRL29BgC9vQbAvb0HgL29BEDBvQUAwb0FwMG9BnzBvQc8wb0H/MG9BLzFvQV8xb0GOMW9BvjFvQe4xb0EeMm9BTjJvQX0yb0GtMm9B3TJvQQ0zb0E9M29BbDNvQZwzb0HMM29B/DNvQSw0b0FbNG9BizRvQbs0b0HrNG9BGzVvQUo1b0F6NW9BqjVvQdo1b0EJNm9BOTZvQWk2b0GZNm9ByDZvQfg2b0EoN29BWDdvQYg3b0G3N29B5zdvQRc4b0FHOG9BdjhvQaY4b0HWOG9BBjlvQTU5b0FlOW9BlTlvQcU5b0H0OW9BJDpvQVQ6b0GDOm9BszpvQeM6b0ETO29BQjtvQXI7b0GiO29B0jtvQQE8b0ExPG9BYTxvQZA8b0HAPG9B8DxvQSA9b0FPPW9Bfz1vQa89b0HePW9BDj5vQT4+b0FuPm9BnT5vQc0+b0H9Pm9BLD9vQVw/b0GMP29Buz9vQes/b0EbQG9BS0BvQXpAb0GqQG9B2kBvQQlBb0E5QW9BaUFvQZhBb0HIQW9B+EFvQSdCb0FXQm9Bh0JvQbZCb0HmQm9BFkNvQUVDb0F1Q29BpUNvQdRDb0EERG9BNERvQWNEb0GTRG9Bw0RvQfJEb0EiRW9BUkVvQYFFb0GxRW9B4UVvQRBGb0FARm9Bb0ZvQZ9Gb0HPRm9B/kZvQS5Hb0FeR29BjUdvQb1Hb0HtR29BHEhvQUxIb0F7SG9Bq0hvQdtIb0EKSW9BOklvQWpJb0GZSW9ByUlvQfhJb0EoSm9BWEpvQYdKb0G3Sm9B5kpvQRZLb0FGS29BdUtvQaVLb0HUS29BBExvQTRMb0FjTG9Bk0xvQcJMb0Hy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B3FBJwhxQVMIcUF/CHFBqwhxQdcIcUEECXFBMAlxQVwJcUGICXFBtAlxQeAJcUEMCnFBOQpxQWUKcUGRCnFBvQpxQekKcUEVC3FBQQtxQW0LcUGaC3FBxgtxQfILcUEeDHFBSgxxQXYMcUGiDHFBzgxxQfoMcUEnDXFBUw1xQX8NcUGrDXFB1w1xQQMOcUEvDnFBWw5xQYcOcUG0DnFB4A5xQQwPcUE4D3FBZA9xQZAPcUG8D3FB6A9xQRQQcUFAEHFBbBBxQZkQcUHFEHFB8RBxQR0RcUFJEXFBdRFxQaERcUHNEXFB+RFxQSUScUFREnFBfRJxQakScUHWEnFBAhNxQS4TcUFaE3FBhhNxQbITcUHeE3FBChRxQTYUcUFiFHFBjhRxQboUcUHmFHFBEhVxQT4VcUFqFXFBlhVxQcMVcUHvFXFBGxZxQUcWcUFzFnFBnxZxQcsWcUH3FnFBIxdxQU8XcUF7F3FBpxdxQdMXcUH/F3FBKxhxQVcYcUGDGHFBrxhxQdsYcUEHGXFBMxlxQV8ZcUGLGXFBtxlxQeMZcUEPGnFBOxpxQWcacUGTGnFBvxpxQesacUEXG3FBQxtxQW8bcUGbG3FBxxtxQfMbcUEfHHFBSxxxQXcccUGjHHFBzxxxQfsccUEnHXFBUx1xQX8dcUGrHXFB1x1xQQMecUEvHnFBWx5xQYcecUGzHnFB3x5xQQsfcUE3H3FBYx9xQY8fcUG7H3FB5x9xQRMgcUE/IHFBayBxQZcgcUHDIHFB7yBxQRshcUFHIXFBcyFxQZ8hcUHLIXFB9yFxQSMicUFPInFBeiJxQaYicUHSInFB/iJxQSojcUFWI3FBgiNxQa4jcUHaI3FBBiRxQTIkcUFeJHFBiiRxQbYkcUHiJHFBDiVxQTolcUFlJXFBkSVxQb0lcUHpJXFBFSZxQUEmcUFtJnFBmSZxQcUmcUHxJnFBHSdxQUkncUF1J3FBoCdxQcwncUH4J3FBJChxQVAocUF8KHFBqChxQdQocUEAKXFBLClxQVgpcUGDKXFBrylxQdspcUEHKnFBMypxQV8qcUGLKnFBtypxQeMqcUEOK3FBOitxQWYrcUGSK3FBvitxQeorcUEWLHFBQixxQW4scUGZLHFBxSxxQfEscUEdLXFBSS1xQXUtcUGhLXFBzC1xQfgtcUEkLnFBUC5xQXwucUGoLnFB1C5xQQAvcUErL3FBVy9xQYMvcUGvL3FB2y9xQQcwcUEzMHFBXjBxQYowcUG2MHFB4jBxQQ4xcUE6MXFBZTFxQZExcUG9MXFB6TFxQRUycUFBMnFBbDJxQZgycUHEMnFB8DJxQRwzcUFIM3FBczNxQZ8zcUHLM3FB9zNxQSM0cUFPNHFBejRxQaY0cUHSNHFB/jRxQSo1cUFVNXFBgTVxQa01cUHZNXFBBTZxQTA2cUFcNnFBiDZxQbQ2cUHgNnFBCzdxQTc3cUFjN3FBjzdxQbs3cUHmN3FBEjhxQT44cUFqOHFBljhxQcE4cUHtOHFBGTlxQUU5cUFxOXFBnDlxQcg5cUH0OXFBIDpxQUs6cUF3OnFBozpxQc86cUH7OnFBJjtxQVI7cUF+O3FBqjtxQdU7cUEBPHFBLTxxQVk8cUGEPHFBsDxxQdw8cUEIPXFBMz1xQV89cUGLPXFBtz1xQeI9cUEOPnFBOj5xQWY+cUGRPnFBvT5xQek+cUEVP3FBQD9xQWw/cUGYP3FBxD9xQe8/cUEbQHFBR0BxQXNAcUGeQHFBykBxQfZAcUEhQXFBTUFxQXlBcUGlQXFB0EFxQfxBcUEoQnFBU0JxQX9CcUGrQnFB10JxQQJDcUEuQ3FBWkNxQYVDcUGxQ3FB3UNxQQlEcUE0RHFBYERxQYxEcUG3RHFB40RxQQ9FcUE6RXFBZkVxQZJFcUG+RXFB6UVxQRVGcUFBRnFBbEZxQZhGcUHERnFB70ZxQRtHcUFHR3FBckdxQZ5HcUHKR3FB9UdxQSFIcUFNSHFBeEhxQaRIcUHQSHFB+0hxQSdJcUFTSXFBfklxQapJcUHWSXFBAUpxQS1KcUFZSnFBhEpxQbBKcUHcSnFBB0txQTNLcUFfS3FBiktxQbZLcUHiS3FBDUxxQTlMcUFkTHFBkExxQbxMcUHnTHFBE01xQT9NcUFqTXFBlk1xQcJNcUHtTXFBGU5xQUROcUFwTnFBnE5xQcdOcUHzTnFBH09xQUpPcUF2T3FBoU9xQc1PcUH5T3FBJFBxQVBQcUF8UHFBp1BxQdNQcUH+UHFBKlFxQVZRcUGBUXFBrVFxQdhRcUEEUnFBMFJxQVtScUGHUnFBslJxQd5ScUEKU3FBNVNxQWFTcUGMU3FBuFNxQeNTcUEPVHFBO1RxQWZUcUGSVHFBvVRxQelUcUEVVXFBQFVxQWxVcUGXVXFBw1VxQe5VcUEaVnFBRlZxQXFWcUGdVnFByFZxQfRWcUEfV3FBS1dxQXdXcUGiV3FBzldxQflXcUElWHFBUFhxQXxYcUGnWHFB01hxQf5YcUEqWXFBVllxQYFZcUGtWXFB2FlxQQRacUEvWnFBW1pxQYZacUGyWnFB3VpxQQlbcUE1W3FBYFtxQYxbcUG3W3FB41txQQ5ccUE6XHFBZVxxQZFccUG8XHFB6FxxQRNdcUE/XXFBal1xQZZdcUHBXXFB7V1xQRhecUFEXnFBb15xQZtecUHGXnFB8l5xQR1fcUFJX3FBdF9xQaBfcUHLX3FB919xQSJgcUFOYHFBeWBxQaVgcUHQYHFB/GBxQSdhcUFTYXFBfmFxQaphcUHVYXFBAWJxQSxicUFYYnFBg2JxQa9icUHaYnFBBmNxQTFjcUFdY3FBiGNxQbRjcUHfY3FBCmRxQTZkcUFhZHFBjWRxQbhkcUHkZHFBD2VxQTtlcUFmZXFBkmVxQb1lcUHpZXFBFGZxQT9mcUFrZnFBlmZxQcJmcUHtZnFBGWdxQURncUFwZ3FBm2dxQcZncUHyZ3FBHWhxQUlocUF0aHFBoGhxQctocUH2aHFBImlxQU1pcUF5aXFBpGlxQdBpcUH7aXFBJmpxQVJqcUF9anFBqWpxQdRqcUEAa3FBK2txQVZrcUGCa3FBrWtxQdlrcUEEbHFBL2xxQVtscUGGbHFBsmxxQd1scUEIbXFBNG1xQV9tcUGLbXFBtm1xQeFtcUENbnFBOG5xQWRucUGPbnFBum5xQeZucUERb3FBPW9xQWhvcUGTb3FBv29xQepvcUEVcHFBQXBxQWxwcUGYcHFBw3BxQe5wcUEacXFBRXFxQXBxcUGccXFBx3FxQfNxcUEecnFBSXJxQXVycUGgcnFBy3JxQfdycUEic3FBTXNxQXlzcUGkc3FBz3NxQftzcUEmdHFBUnRxQX10cUGodHFB1HRxQf90cUEqdXFBVnVxQYF1cUGsdXFB2HVxQQN2cUEudnFBWnZxQYV2cUGwdnFB3HZxQQd3cUEyd3FBXndxQYl3cUG0d3FB4HdxQQt4cUE2eHFBYnhxQY14cUG4eHFB43hxQQ95cUE6eXFBZXlxQZF5cUG8eXFB53lxQRN6cUE+enFBaXpxQZV6cUHAenFB63pxQRZ7cUFCe3FBbXtxQZh7cUHEe3FB73txQRp8cUFFfHFBcXxxQZx8cUHHfHFB83xxQR59cUFJfXFBdH1xQaB9cUHLfXFB9n1xQSJ+cUFNfnFBeH5xQaN+cUHPfnFB+n5xQSV/cUFQf3FBfH9xQad/cUHSf3FB/n9xQSmAcUFUgHFBf4BxQauAcUHWgHFBAYFxQSyBcUFYgXFBg4FxQa6BcUHZgXFBBYJxQTCCcUFbgnFBhoJxQbKCcUHdgnFBCINxQTODcUFfg3FBioNxQbWDcUHgg3FBC4RxQTeEcUFihHFBjYRxQbiEcUHkhHFBD4VxQTqFcUFlhXFBkYVxQbyFcUHnhXFBEoZxQT2GcUFphnFBlIZxQb+GcUHqhnFBFYdxQUGHcUFsh3FBl4dxQcKHcUHth3FBGYhxQUSIcUFviHFBmohxQcWIcUHxiHFBHIlxQUeJcUFyiXFBnYlxQcmJcUH0iXFBH4pxQUqKcUF1inFBoYpxQcyKcUH3inFBIotxQU2LcUF4i3FBpItxQc+LcUH6i3FBJYxxQVCMcUF8jHFBp4xxQdKMcUH9jHFBKI1xQVONcUF/jXFBqo1xQdWNcUEAjnFBK45xQVaOcUGBjnFBrY5xQdiOcUEDj3FBLo9xQVmPcUGEj3FBsI9xQduPcUEGkHFBMZBxQVyQcUGHkHFBspBxQd6QcUEJkXFBNJFxQV+RcUGKkXFBtZFxQeCRcUELknFBN5JxQWKScUGNknFBuJJxQeOScUEOk3FBOZNxQWSTcUGQk3FBu5NxQeaTcUERlHFBPJRxQWeUcUGSlHFBvZRxQemUcUEUlXFBP5VxQWqVcUGVlXFBwJVxQeuVcUEWlnFBQZZxQWyWcUGYlnFBw5ZxQe6WcUEZl3FBRJdxQW+XcUGal3FBxZdxQfCXcUEbmHFBRphxQXKYcUGdmHFByJhxQfOYcUEemXFBSZlxQXSZcUGfmXFByplxQfWZcUEgmnFBS5pxQXaacUGimnFBzZpxQfiacUEjm3FBTptxQXmbcUGkm3FBz5txQfqbcUElnHFBUJxxQXuccUGmnHFB0ZxxQfyccUEnnXFBUp1xQX2dcUGpnXFB1J1xQf+dcUEqnnFBVZ5xQYCecUGrnnFB1p5xQQGfcUEsn3FBV59xQYKfcUGtn3FB2J9xQQOgcUEuoHFBWaBxQYSgcUGvoHFB2qBxQQWhcUEwoXFBW6FxQYahcUGxoXFB3KFxQQeicUEyonFBXaJxQYiicUGzonFB3qJxQQmjcUE0o3FBX6NxQYqjcUG1o3FB4KNxQQukcUE2pHFBYaRxQYykcUG3pHFB4qRxQQ2lcUE4pXFBY6VxQY6lcUG5pXFB5KVxQQ+mcUE6pnFBZaZxQZCmcUG7pnFB5qZxQRGncUE8p3FBZ6dxQZKncUG9p3FB6KdxQROocUE+qHFBaahxQZSocUG/qHFB6qhxQRWpcUFAqXFBa6lxQZapcUHBqXFB7KlxQRaqcUFBqnFBbKpxQZeqcUHCqnFB7apxQRircUFDq3FBbqtxQZmrcUHEq3FB76txQRqscUFFrHFBcKxxQZuscUHGrHFB8axxQRutcUFGrXFBca1xQZytcUHHrXFB8q1xQR2ucUFIrnFBc65xQZ6ucUHJrnFB9K5xQR+vcUFKr3FBdK9xQZ+vcUHKr3FB9a9xQSCwcUFLsHFBdrBxQaGwcUHMsHFB97BxQSKxcUFMsXFBd7FxQaKxcUHNsXFB+LFxQSOycUFOsnFBebJxQaSycUHOsnFB+bJxQSSzcUFPs3FBerNxQaWzcUHQs3FB+7NxQSa0cUFQtHFBe7RxQaa0cUHRtHFB/LRxQSe1cUFStXFBfbVxQae1cUHStXFB/bVxQSi2cUFTtnFBfrZxQam2cUHUtnFB/rZxQSm3cUFUt3FBf7dxQaq3cUHVt3FBALhxQSq4cUFVuHFBgLhxQau4cUHWuHFBAblxQSu5cUFWuXFBgblxQay5cUHXuXFBArpxQS26cUFXunFBgrpxQa26cUHYunFBA7txQS67cUFYu3FBg7txQa67cUHZu3FBBLxxQS68cUFZvHFBhLxxQa+8cUHavHFBBb1xQS+9cUFavXFBhb1xQbC9cUHbvXFBBb5xQTC+cUFbvnFBhr5xQbG+cUHcvnFBBr9xQTG/cUFcv3FBh79xQbK/cUHcv3FBB8BxQTLAcUFdwHFBh8BxQbLAcUHdwHFBCMFxQTPBcUFdwXFBiMFxQbPBcUHewXFBCcJxQTPCcUFewnFBicJxQbTCcUHewnFBCcNxQTTDcUFfw3FBisNxQbTDcUHfw3FBCsRxQTXEcUFfxHFBisRxQbXEcUHgxHFBCsVxQTXFcUFgxXFBi8VxQbXFcUHgxXFBC8ZxQTbGcUFgxnFBi8ZxQbbGcUHhxnFBC8dxQTbHcUFhx3FBjMdxQbbHcUHhx3FBDMhxQTfIcUFhyHFBjMhxQbfIcUHiyHFBDMlxQTfJcUFiyXFBjMlxQbfJcUHiyXFBDcpxQTfKcUFiynFBjcpxQbjKcUHiynFBDctxQTjLcUFiy3FBjctxQbjLcUHjy3FBDcxxQTjMcUFjzHFBjcxxQbjMcUHjzHFBDc1xQTjNcUFjzXFBjs1xQbjNcUHjzXFBDs5xQTjOcUFjznFBjs5xQbjOcUHjznFBDs9xQTjPcUFjz3FBjs9xQbnPcUHjz3FBDtBxQTnQcUFj0HFBjtBxQbnQcUHj0HFBDtFxQTnRcUFj0XFBjtFxQbnRcUHj0XFBDtJxQTnScUFj0nFBjtJxQbnScUHj0nFBDtNxQTnTcUFj03FBjtNxQbnTcUHj03FBDtRxQTnUcUFj1HFBjtRxQbjUcUHj1HFBDtVxQTjVcUFj1XFBjtVxQbjVcUHj1XFBDtZxQTjWcUFj1nFBjdZxQbjWcUHj1nFBDddxQTjXcUFj13FBjddxQbjXcUHj13FBDdhxQTjYcUFi2HFBjdhxQbjYcUHi2HFBDdlxQTfZcUFi2XFBjdlxQbfZcUHi2XFBDdpxQTfacUFi2nFBjNpxQbfacUHi2nFBDNtxQTfbcUFh23FBjNtxQbfbcUHh23FBDNxxQTbccUFh3HFBi9xxQbbccUHh3HFBC91xQTbdcUFg3XFBi91xQbbdcUHg3XFBC95xQTXecUFg3nFBit5xQbXecUHg3nFBCt9xQTXfcUFf33FBit9xQbTfcUHf33FBCuBxQTTgcUFf4HFBieBxQbTgcUHe4HFBCeFxQTThcUFe4XFBieFxQbPhcUHe4XFBCOJxQTPicUFd4nFBiOJxQbLicUHd4nFBCONxQTLjcUFd43FBh+NxQbLjcUHc43FBB+RxQTHkcUFc5HFBhuRxQbHkcUHb5HFBBuVxQTHlcUFb5XFBhuVxQbDlcUHb5XFBBeZxQTDmcUFa5nFBheZxQa/mcUHa5nFBBOdxQS/ncUFZ53FBhOdxQa7ncUHZ53FBA+hxQS7ocUFY6HFBg+hxQa3ocUHY6HFBAulxQS3pcUFX6XFBgulxQazpcUHX6XFBAepxQSzqcUFW6nFBgepxQavqcUHW6nFBAOtxQSvrcUFV63FBgOtxQarrcUHV63FB/+txQSrscUFU7HFBf+xxQanscUHT7HFB/uxxQSjtcUFT7XFBfe1xQajtcUHS7XFB/e1xQSfucUFS7nFBfO5xQafucUHR7nFB/O5xQSbvcUFQ73FBe+9xQaXvcUHQ73FB+u9xQSXwcUFP8HFBevBxQaTwcUHO8HFB+fBxQSPxcUFO8XFBePFxQaPxcUHN8XFB+PFxQSLycUFM8nFBd/JxQaHycUHM8nFB9vJxQSHzcUFL83FBdfNxQaDzcUHK83FB9fNxQR/0cUFK9HFBdPRxQZ70cUHJ9HFB8/RxQR71cUFI9XFBcvVxQZ31cUHH9XFB8vVxQRz2cUFG9nFBcfZxQZv2cUHG9nFB8PZxQRr3cUFF93FBb/dxQZr3cUHE93FB7vdxQRn4cUFD+HFBbvhxQZj4cUHC+HFB7fhxQRf5cUFC+XFBbPlxQZb5cUHB+XFB6/lxQRX6cUFA+nFBavpxQZX6cUG/+nFB6fpxQRT7cUE++3FBaPtxQZP7cUG9+3FB6PtxQRL8cUE8/HFBZ/xxQZH8cUG7/HFB5vxxQRD9cUE6/XFBZf1xQY/9cUG5/XFB5P1xQQ7+cUE5/nFBY/5xQY3+cUG4/nFB4v5xQQz/cUE3/3FBYf9xQYv/cUG2/3FB4P9xQQoAckE1AHJBXwByQYkAckG0AHJB3gByQQgBckEzAXJBXQFyQYcBckGyAXJB3AFyQQYCckExAnJBWwJyQYUCckGvAnJB2gJyQQQDckEuA3JBWQNyQYMDckGtA3JB2ANyQQIEckEsBHJBVwRyQYEEckGrBHJB1QRyQQAFckEqBXJBVAVyQX8FckGpBXJB0wVyQf4FckEoBnJBUgZyQXwGckGnBnJB0QZyQfsGckEmB3JBUAdyQXoHckGkB3JBzwdyQfkHckEjCHJBTghyQXgIckGiCHJBzAhyQfcIckEhCXJBSwlyQXUJckGgCXJByglyQfQJckEeCnJBSQpyQXMKckGdCnJByApyQfIKckEcC3JBRgtyQXELckGbC3JBxQtyQe8LckEaDHJBRAxyQW4MckGYDHJBwwxyQe0MckEXDXJBQQ1yQWsNckGWDXJBwA1yQeoNckEUDnJBPw5yQWkOckGTDnJBvQ5yQegOckESD3JBPA9yQWYPckGQD3JBuw9yQeUPckEPEHJBORByQWQQckGOEHJBuBByQeIQckEMEXJBNxFyQWERckGLEXJBtRFyQd8RckEKEnJBNBJyQV4SckGIEnJBsxJyQd0SckEHE3JBMRNyQVsTckGFE3JBsBNyQdoTckEEFHJBLhRyQVgUckGDFHJBrRRyQdcUckEBFXJBKxVyQVYVckGAFXJBqhVyQdQVckH+FXJBKBZyQVMWckF9FnJBpxZyQdEWckH7FnJBJRdyQVAXckF6F3JBpBdyQc4XckH4F3JBIhhyQU0YckF3GHJBoRhyQcsYckH1GHJBHxlyQUoZckF0GXJBnhlyQcgZckHyGXJBHBpyQUcackFxGnJBmxpyQcUackHvGnJBGRtyQUMbckFtG3JBmBtyQcIbckHsG3JBFhxyQUAcckFqHHJBlBxyQb8cckHpHHJBEx1yQT0dckFnHXJBkR1yQbsdckHlHXJBEB5yQToeckFkHnJBjh5yQbgeckHiHnJBDB9yQTYfckFgH3JBix9yQbUfckHfH3JBCSByQTMgckFdIHJBhyByQbEgckHbIHJBBiFyQTAhckFaIXJBhCFyQa4hckHYIXJBAiJyQSwickFWInJBgCJyQaoickHVInJB/yJyQSkjckFTI3JBfSNyQacjckHRI3JB+yNyQSUkckFPJHJBeSRyQaMkckHNJHJB+CRyQSIlckFMJXJBdiVyQaAlckHKJXJB9CVyQR4mckFIJnJBciZyQZwmckHGJnJB8CZyQRonckFEJ3JBbidyQZknckHDJ3JB7SdyQRcockFBKHJBayhyQZUockG/KHJB6ShyQRMpckE9KXJBZylyQZEpckG7KXJB5SlyQQ8qckE5KnJBYypyQY0qckG3KnJB4SpyQQsrckE1K3JBXytyQYkrckGzK3JB3ityQQgsckEyLHJBXCxyQYYsckGwLHJB2ixyQQQtckEuLXJBWC1yQYItckGsLXJB1i1yQQAuckEqLnJBVC5yQX4uckGoLnJB0i5yQfwuckEmL3JBUC9yQXovckGkL3JBzi9yQfgvckEiMHJBTDByQXYwckGgMHJByjByQfQwckEeMXJBSDFyQXIxckGcMXJBxjFyQe8xckEZMnJBQzJyQW0yckGXMnJBwTJyQesyckEVM3JBPzNyQWkzckGTM3JBvTNyQeczckERNHJBOzRyQWU0ckGPNHJBuTRyQeM0ckENNXJBNzVyQWE1ckGLNXJBtTVyQd81ckEJNnJBMzZyQVw2ckGGNnJBsDZyQdo2ckEEN3JBLjdyQVg3ckGCN3JBrDdyQdY3ckEAOHJBKjhyQVQ4ckF+OHJBqDhyQdI4ckH7OHJBJTlyQU85ckF5OXJBozlyQc05ckH3OXJBITpyQUs6ckF1OnJBnzpyQck6ckHzOnJBHDtyQUY7ckFwO3JBmjtyQcQ7ckHuO3JBGDxyQUI8ckFsPHJBljxyQcA8ckHpPHJBEz1yQT09ckFnPXJBkT1yQbs9ckHlPXJBDz5yQTk+ckFiPnJBjD5yQbY+ckHgPnJBCj9yQTQ/ckFeP3JBiD9yQbI/ckHbP3JBBUByQS9AckFZQHJBg0ByQa1AckHXQHJBAUFyQSpBckFUQXJBfkFyQahBckHSQXJB/EFyQSZCckFQQnJBeUJyQaNCckHNQnJB90JyQSFDckFLQ3JBdUNyQZ5DckHIQ3JB8kNyQRxEckFGRHJBcERyQZlEckHDRHJB7URyQRdFckFBRXJBa0VyQZVFckG+RXJB6EVyQRJGckE8RnJBZkZyQZBGckG5RnJB40ZyQQ1HckE3R3JBYUdyQYtHckG0R3JB3kdyQQhIckEySHJBXEhyQYVIckGvSHJB2UhyQQNJckEtSXJBV0lyQYBJckGqSXJB1ElyQf5JckEoSnJBUUpyQXtKckGlSnJBz0pyQflKckEiS3JBTEtyQXZLckGgS3JByktyQfNLckEdTHJBR0xyQXFMckGbTHJBxExyQe5MckEYTXJBQk1yQWtNckGVTXJBv01yQelNckETTnJBPE5yQWZOckGQTnJBuk5yQeNOckENT3JBN09yQWFPckGLT3JBtE9yQd5PckEIUHJBMlByQVtQckGFUHJBr1ByQdlQckECUXJBLFFyQVZRckGAUXJBqVFyQdNRckH9UXJBJ1JyQVBSckF6UnJBpFJyQc5SckH3UnJBIVNyQUtTckF1U3JBnlNyQchTckHyU3JBHFRyQUVUckFvVHJBmVRyQcNUckHsVHJBFlVyQUBVckFpVXJBk1VyQb1VckHnVXJBEFZyQTpWckFkVnJBjlZyQbdWckHhVnJBC1dyQTRXckFeV3JBiFdyQbJXckHbV3JBBVhyQS9YckFYWHJBglhyQaxYckHWWHJB/1hyQSlZckFTWXJBfFlyQaZZckHQWXJB+VlyQSNackFNWnJBdlpyQaBackHKWnJB9FpyQR1bckFHW3JBcVtyQZpbckHEW3JB7ltyQRdcckFBXHJBa1xyQZRcckG+XHJB6FxyQRFdckE7XXJBZV1yQY5dckG4XXJB4l1yQQteckE1XnJBX15yQYheckGyXnJB3F5yQQVfckEvX3JBWV9yQYJfckGsX3JB1l9yQf9fckEpYHJBU2ByQXxgckGmYHJB0GByQflgckEjYXJBTWFyQXZhckGgYXJByWFyQfNhckEdYnJBRmJyQXBickGaYnJBw2JyQe1ickEXY3JBQGNyQWpjckGTY3JBvWNyQedjckEQZHJBOmRyQWRkckGNZHJBt2RyQeBkckEKZXJBNGVyQV1lckGHZXJBsGVyQdplckEEZnJBLWZyQVdmckGBZnJBqmZyQdRmckH9ZnJBJ2dyQVFnckF6Z3JBpGdyQc1nckH3Z3JBIWhyQUpockF0aHJBnWhyQcdockHwaHJBGmlyQURpckFtaXJBl2lyQcBpckHqaXJBFGpyQT1qckFnanJBkGpyQbpqckHjanJBDWtyQTdrckFga3JBimtyQbNrckHda3JBBmxyQTBsckFabHJBg2xyQa1sckHWbHJBAG1yQSltckFTbXJBfW1yQaZtckHQbXJB+W1yQSNuckFMbnJBdm5yQZ9uckHJbnJB825yQRxvckFGb3JBb29yQZlvckHCb3JB7G9yQRVwckE/cHJBaHByQZJwckG7cHJB5XByQQ9xckE4cXJBYnFyQYtxckG1cXJB3nFyQQhyckExcnJBW3JyQYRyckGucnJB13JyQQFzckEqc3JBVHNyQX1zckGnc3JB0HNyQfpzckEjdHJBTXRyQXZ0ckGgdHJByXRyQfN0ckEcdXJBRnVyQW91ckGZdXJBwnVyQex1ckEVdnJBP3ZyQWh2ckGSdnJBu3ZyQeV2ckEOd3JBOHdyQWF3ckGLd3JBtHdyQd53ckEHeHJBMXhyQVp4ckGEeHJBrXhyQdd4ckEAeXJBKnlyQVN5ckF9eXJBpnlyQdB5ckH5eXJBI3pyQUx6ckF1enJBn3pyQch6ckHyenJBG3tyQUV7ckFue3JBmHtyQcF7ckHre3JBFHxyQT58ckFnfHJBkHxyQbp8ckHjfHJBDX1yQTZ9ckFgfXJBiX1yQbN9ckHcfXJBBX5yQS9+ckFYfnJBgn5yQat+ckHVfnJB/n5yQSh/ckFRf3JBen9yQaR/ckHNf3JB939yQSCAckFKgHJBc4ByQZyAckHGgHJB74ByQRmBckFCgXJBa4FyQZWBckG+gXJB6IFyQRGCckE7gnJBZIJyQY2CckG3gnJB4IJyQQqDckEzg3JBXINyQYaDckGvg3JB2YNyQQKEckErhHJBVYRyQX6EckGohHJB0YRyQfqEckEkhXJBTYVyQXeFckGghXJByYVyQfOFckEchnJBRoZyQW+GckGYhnJBwoZyQeuGckEUh3JBPodyQWeHckGRh3JBuodyQeOHckENiHJBNohyQV+IckGJiHJBsohyQduIckEFiXJBLolyQViJckGBiXJBqolyQdSJckH9iXJBJopyQVCKckF5inJBoopyQcyKckH1inJBH4tyQUiLckFxi3JBm4tyQcSLckHti3JBF4xyQUCMckFpjHJBk4xyQbyMckHljHJBD41yQTiNckFhjXJBi41yQbSNckHdjXJBB45yQTCOckFZjnJBg45yQayOckHVjnJB/45yQSiPckFRj3JBe49yQaSPckHNj3JB9o9yQSCQckFJkHJBcpByQZyQckHFkHJB7pByQRiRckFBkXJBapFyQZSRckG9kXJB5pFyQQ+SckE5knJBYpJyQYuSckG1knJB3pJyQQeTckExk3JBWpNyQYOTckGsk3JB1pNyQf+TckEolHJBUpRyQXuUckGklHJBzZRyQfeUckEglXJBSZVyQXOVckGclXJBxZVyQe6VckEYlnJBQZZyQWqWckGTlnJBvZZyQeaWckEPl3JBOZdyQWKXckGLl3JBtJdyQd6XckEHmHJBMJhyQVmYckGDmHJBrJhyQdWYckH+mHJBKJlyQVGZckF6mXJBo5lyQc2ZckH2mXJBH5pyQUiackFymnJBm5pyQcSackHtmnJBF5tyQUCbckFpm3JBkptyQbybckHlm3JBDpxyQTecckFgnHJBipxyQbOcckHcnHJBBZ1yQS+dckFYnXJBgZ1yQaqdckHTnXJB/Z1yQSaeckFPnnJBeJ5yQaKeckHLnnJB9J5yQR2fckFGn3JBcJ9yQZmfckHCn3JB659yQRSgckE+oHJBZ6ByQZCgckG5oHJB4qByQQyhckE1oXJBXqFyQYehckGwoXJB2qFyQQOickEsonJBVaJyQX6ickGoonJB0aJyQfqickEjo3JBTKNyQXWjckGfo3JByKNyQfGjckEapHJBQ6RyQW2kckGWpHJBv6RyQeikckERpXJBOqVyQWSlckGNpXJBtqVyQd+lckEIpnJBMaZyQVqmckGEpnJBraZyQdamckH/pnJBKKdyQVGnckF7p3JBpKdyQc2nckH2p3JBH6hyQUiockFxqHJBm6hyQcSockHtqHJBFqlyQT+pckFoqXJBkalyQbupckHkqXJBDapyQTaqckFfqnJBiKpyQbGqckHbqnJBBKtyQS2rckFWq3JBf6tyQairckHRq3JB+qtyQSSsckFNrHJBdqxyQZ+sckHIrHJB8axyQRqtckFDrXJBbK1yQZatckG/rXJB6K1yQRGuckE6rnJBY65yQYyuckG1rnJB3q5yQQevckExr3JBWq9yQYOvckGsr3JB1a9yQf6vckEnsHJBULByQXmwckGisHJBzLByQfWwckEesXJBR7FyQXCxckGZsXJBwrFyQeuxckEUsnJBPbJyQWayckGPsnJBuLJyQeKyckELs3JBNLNyQV2zckGGs3JBr7NyQdizckEBtHJBKrRyQVO0ckF8tHJBpbRyQc60ckH3tHJBILVyQUm1ckFztXJBnLVyQcW1ckHutXJBF7ZyQUC2ckFptnJBkrZyQbu2ckHktnJBDbdyQTa3ckFft3JBiLdyQbG3ckHat3JBA7hyQSy4ckFVuHJBfrhyQae4ckHQuHJB+bhyQSO5ckFMuXJBdblyQZ65ckHHuXJB8LlyQRm6ckFCunJBa7pyQZS6ckG9unJB5rpyQQ+7ckE4u3JBYbtyQYq7ckGzu3JB3LtyQQW8ckEuvHJBV7xyQYC8ckGpvHJB0rxyQfu8ckEkvXJBTb1yQXa9ckGfvXJByL1yQfG9ckEavnJBQ75yQWy+ckGVvnJBvr5yQee+ckEQv3JBOb9yQWK/ckGLv3JBtL9yQd2/ckEGwHJBL8ByQVjAckGBwHJBqsByQdPAckH8wHJBJcFyQU7BckF3wXJBn8FyQcjBckHxwXJBGsJyQUPCckFswnJBlcJyQb7CckHnwnJBEMNyQTnDckFiw3JBi8NyQbTDckHdw3JBBsRyQS/EckFYxHJBgcRyQarEckHTxHJB/MRyQSXFckFNxXJBdsVyQZ/FckHIxXJB8cVyQRrGckFDxnJBbMZyQZXGckG+xnJB58ZyQRDHckE5x3JBYsdyQYvHckG0x3JB3MdyQQXIckEuyHJBV8hyQYDIckGpyHJB0shyQfvIckEkyXJBTclyQXbJckGfyXJByMlyQfDJckEZynJBQspyQWvKckGUynJBvcpyQebKckEPy3JBOMtyQWHLckGJy3JBsstyQdvLckEEzHJBLcxyQVbMckF/zHJBqMxyQdHMckH6zHJBIs1yQUvNckF0zXJBnc1yQcbNckHvzXJBGM5yQUHOckFqznJBks5yQbvOckHkznJBDc9yQTbPckFfz3JBiM9yQbHPckHZz3JBAtByQSvQckFU0HJBfdByQabQckHP0HJB99ByQSDRckFJ0XJBctFyQZvRckHE0XJB7dFyQRbSckE+0nJBZ9JyQZDSckG50nJB4tJyQQvTckEz03JBXNNyQYXTckGu03JB19NyQQDUckEp1HJBUdRyQXrUckGj1HJBzNRyQfXUckEe1XJBRtVyQW/VckGY1XJBwdVyQerVckET1nJBO9ZyQWTWckGN1nJBttZyQd/WckEI13JBMNdyQVnXckGC13JBq9dyQdTXckH813JBJdhyQU7YckF32HJBoNhyQcjYckHx2HJBGtlyQUPZckFs2XJBldlyQb3ZckHm2XJBD9pyQTjackFh2nJBidpyQbLackHb2nJBBNtyQS3bckFV23JBfttyQafbckHQ23JB+NtyQSHcckFK3HJBc9xyQZzcckHE3HJB7dxyQRbdckE/3XJBaN1yQZDdckG53XJB4t1yQQveckEz3nJBXN5yQYXeckGu3nJB1t5yQf/eckEo33JBUd9yQXrfckGi33JBy99yQfTfckEd4HJBReByQW7gckGX4HJBwOByQejgckER4XJBOuFyQWPhckGL4XJBtOFyQd3hckEG4nJBLuJyQVfickGA4nJBqeJyQdHickH64nJBI+NyQUzjckF043JBneNyQcbjckHu43JBF+RyQUDkckFp5HJBkeRyQbrkckHj5HJBDOVyQTTlckFd5XJBhuVyQa7lckHX5XJBAOZyQSnmckFR5nJBeuZyQaPmckHL5nJB9OZyQR3nckFG53JBbudyQZfnckHA53JB6OdyQRHockE66HJBY+hyQYvockG06HJB3ehyQQXpckEu6XJBV+lyQX/pckGo6XJB0elyQfrpckEi6nJBS+pyQXTqckGc6nJBxepyQe7qckEW63JBP+tyQWjrckGQ63JBuetyQeLrckEK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M3NBRTNzQW4zc0GWM3NBvjNzQeYzc0EONHNBNjRzQV80c0GHNHNBrzRzQdc0c0H/NHNBKDVzQVA1c0F4NXNBoDVzQcg1c0HwNXNBGTZzQUE2c0FpNnNBkTZzQbk2c0HhNnNBCjdzQTI3c0FaN3NBgjdzQao3c0HSN3NB+zdzQSM4c0FLOHNBczhzQZs4c0HDOHNB7DhzQRQ5c0E8OXNBZDlzQYw5c0G0OXNB3DlzQQU6c0EtOnNBVTpzQX06c0GlOnNBzTpzQfU6c0EeO3NBRjtzQW47c0GWO3NBvjtzQeY7c0EOPHNBNjxzQV88c0GHPHNBrzxzQdc8c0H/PHNBJz1zQU89c0F3PXNBoD1zQcg9c0HwPXNBGD5zQUA+c0FoPnNBkD5zQbg+c0HgPnNBCT9zQTE/c0FZP3NBgT9zQak/c0HRP3NB+T9zQSFAc0FJQHNBckBzQZpAc0HCQHNB6kBzQRJBc0E6QXNBYkFzQYpBc0GyQXNB2kFzQQJCc0ErQnNBU0JzQXtCc0GjQnNBy0JzQfNCc0EbQ3NBQ0NzQWtDc0GTQ3NBu0NzQeNDc0EMRHNBNERzQVxEc0GERHNBrERzQdREc0H8RHNBJEVzQUxFc0F0RXNBnEVzQcRFc0HsRXNBFEZzQT1Gc0FlRnNBjUZzQbVGc0HdRnNBBUdzQS1Hc0FVR3NBfUdzQaVHc0HNR3NB9UdzQR1Ic0FFSHNBbUhzQZVIc0G9SHNB5UhzQQ1Jc0E1SXNBXklzQYZJc0GuSXNB1klzQf5Jc0EmSnNBTkpzQXZKc0GeSnNBxkpzQe5Kc0EWS3NBPktzQWZLc0GOS3NBtktzQd5Lc0EGTHNBLkxzQVZMc0F+THNBpkxzQc5Mc0H2THNBHk1zQUZNc0FuTXNBlk1zQb5Nc0HmTXNBDk5zQTZOc0FeTnNBhk5zQa5Oc0HWTnNB/k5zQSZPc0FOT3NBdk9zQZ5Pc0HGT3NB7k9zQRZQc0E+UHNBZlBzQY5Qc0G2UHNB3lBzQQZRc0EuUXNBVlFzQX5Rc0GmUXNBzlFzQfZRc0EeUnNBRlJzQW5Sc0GWUnNBvlJzQeZSc0EOU3NBNlNzQV5Tc0GGU3NBrlNzQdZTc0H+U3NBJlRzQU5Uc0F2VHNBnlRzQcZUc0HuVHNBFlVzQT1Vc0FlVXNBjVVzQbVVc0HdVXNBBVZzQS1Wc0FVVnNBfVZzQaVWc0HNVnNB9VZzQR1Xc0FFV3NBbVdzQZVXc0G9V3NB5VdzQQ1Yc0E1WHNBXFhzQYRYc0GsWHNB1FhzQfxYc0EkWXNBTFlzQXRZc0GcWXNBxFlzQexZc0EUWnNBPFpzQWRac0GLWnNBs1pzQdtac0EDW3NBK1tzQVNbc0F7W3NBo1tzQctbc0HzW3NBG1xzQUNcc0FqXHNBklxzQbpcc0HiXHNBCl1zQTJdc0FaXXNBgl1zQapdc0HSXXNB+l1zQSFec0FJXnNBcV5zQZlec0HBXnNB6V5zQRFfc0E5X3NBYV9zQYhfc0GwX3NB2F9zQQBgc0EoYHNBUGBzQXhgc0GgYHNByGBzQe9gc0EXYXNBP2FzQWdhc0GPYXNBt2FzQd9hc0EHYnNBLmJzQVZic0F+YnNBpmJzQc5ic0H2YnNBHmNzQUZjc0FtY3NBlWNzQb1jc0HlY3NBDWRzQTVkc0FdZHNBhGRzQaxkc0HUZHNB/GRzQSRlc0FMZXNBdGVzQZtlc0HDZXNB62VzQRNmc0E7ZnNBY2ZzQYpmc0GyZnNB2mZzQQJnc0EqZ3NBUmdzQXlnc0GhZ3NByWdzQfFnc0EZaHNBQWhzQWhoc0GQaHNBuGhzQeBoc0EIaXNBMGlzQVdpc0F/aXNBp2lzQc9pc0H3aXNBH2pzQUZqc0FuanNBlmpzQb5qc0HmanNBDWtzQTVrc0Fda3NBhWtzQa1rc0HUa3NB/GtzQSRsc0FMbHNBdGxzQZxsc0HDbHNB62xzQRNtc0E7bXNBY21zQYptc0GybXNB2m1zQQJuc0EpbnNBUW5zQXluc0GhbnNByW5zQfBuc0EYb3NBQG9zQWhvc0GQb3NBt29zQd9vc0EHcHNBL3BzQVZwc0F+cHNBpnBzQc5wc0H2cHNBHXFzQUVxc0FtcXNBlXFzQbxxc0HkcXNBDHJzQTRyc0FbcnNBg3JzQatyc0HTcnNB+nJzQSJzc0FKc3NBcnNzQZpzc0HBc3NB6XNzQRF0c0E5dHNBYHRzQYh0c0GwdHNB2HRzQf90c0EndXNBT3VzQXZ1c0GedXNBxnVzQe51c0EVdnNBPXZzQWV2c0GNdnNBtHZzQdx2c0EEd3NBLHdzQVN3c0F7d3NBo3dzQct3c0Hyd3NBGnhzQUJ4c0FpeHNBkXhzQbl4c0HheHNBCHlzQTB5c0FY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LnVBsS51QdYudUH7LnVBIC91QUQvdUFpL3VBji91QbMvdUHYL3VB/S91QSIwdUFHMHVBazB1QZAwdUG1MHVB2jB1Qf8wdUEkMXVBSTF1QW4xdUGSMXVBtzF1QdwxdUEBMnVBJjJ1QUsydUFwMnVBlDJ1QbkydUHeMnVBAzN1QSgzdUFNM3VBcjN1QZYzdUG7M3VB4DN1QQU0dUEqNHVBTzR1QXM0dUGYNHVBvTR1QeI0dUEHNXVBLDV1QVE1dUF1NXVBmjV1Qb81dUHkNXVBCTZ1QS42dUFSNnVBdzZ1QZw2dUHBNnVB5jZ1QQs3dUEvN3VBVDd1QXk3dUGeN3VBwzd1Qeg3dUEMOHVBMTh1QVY4dUF7OHVBoDh1QcQ4dUHpOHVBDjl1QTM5dUFYOXVBfTl1QaE5dUHGOXVB6zl1QRA6dUE1OnVBWTp1QX46dUGjOnVByDp1Qe06dUERO3VBNjt1QVs7dUGAO3VBpTt1Qco7dUHuO3VBEzx1QTg8dUFdPHVBgTx1QaY8dUHLPHVB8Dx1QRU9dUE5PXVBXj11QYM9dUGoPXVBzT11QfE9dUEWPnVBOz51QWA+dUGFPnVBqT51Qc4+dUHzPnVBGD91QTw/dUFhP3VBhj91Qas/dUHQP3VB9D91QRlAdUE+QHVBY0B1QYdAdUGsQHVB0UB1QfZAdUEbQXVBP0F1QWRBdUGJQXVBrkF1QdJBdUH3QXVBHEJ1QUFCdUFlQnVBikJ1Qa9CdUHUQnVB+EJ1QR1DdUFCQ3VBZ0N1QYtDdUGwQ3VB1UN1QfpDdUEeRHVBQ0R1QWhEdUGNRHVBsUR1QdZEdUH7RHVBIEV1QURFdUFpRXVBjkV1QbNFdUHXRXVB/EV1QSFGdUFGRnVBakZ1QY9GdUG0RnVB2UZ1Qf1GdUEiR3VBR0d1QWtHdUGQR3VBtUd1QdpHdUH+R3VBI0h1QUhIdUFtSHVBkUh1QbZIdUHbSHVB/0h1QSRJdUFJSXVBbkl1QZJJdUG3SXVB3El1QQBKdUElSnVBSkp1QW9KdUGTSnVBuEp1Qd1KdUEBS3VBJkt1QUtLdUFvS3VBlEt1QblLdUHeS3VBAkx1QSdMdUFMTHVBcEx1QZVMdUG6THVB3kx1QQNNdUEoTXVBTU11QXFNdUGWTXVBu011Qd9NdUEETnVBKU51QU1OdUFyTnVBl051QbtOdUHgTnVBBU91QSlPdUFOT3VBc091QZhPdUG8T3VB4U91QQZQdUEqUHVBT1B1QXRQdUGYUHVBvVB1QeJQdUEGUXVBK1F1QVBRdUF0UXVBmVF1Qb5RdUHiUXVBB1J1QSxSdUFQUnVBdVJ1QZpSdUG+UnVB41J1QQhTdUEsU3VBUVN1QXZTdUGaU3VBv1N1QeNTdUEIVHVBLVR1QVFUdUF2VHVBm1R1Qb9UdUHkVHVBCVV1QS1VdUFSVXVBd1V1QZtVdUHAVXVB5FV1QQlWdUEuVnVBUlZ1QXdWdUGcVnVBwFZ1QeVWdUEKV3VBLld1QVNXdUF3V3VBnFd1QcFXdUHlV3VBClh1QS9YdUFTWHVBeFh1QZxYdUHBWHVB5lh1QQpZdUEvWXVBVFl1QXhZdUGdWXVBwVl1QeZZdUELWnVBL1p1QVRadUF4WnVBnVp1QcJadUHmWnVBC1t1QTBbdUFUW3VBeVt1QZ1bdUHCW3VB51t1QQtcdUEwXHVBVFx1QXlcdUGeXHVBwlx1QedcdUELXXVBMF11QVVddUF5XXVBnl11QcJddUHnXXVBC151QTBedUFVXnVBeV51QZ5edUHCXnVB5151QQxfdUEwX3VBVV91QXlfdUGeX3VBwl91QedfdUEMYHVBMGB1QVVgdUF5YHVBnmB1QcJgdUHnYHVBDGF1QTBhdUFVYXVBeWF1QZ5hdUHCYXVB52F1QQxidUEwYnVBVWJ1QXlidUGeYnVBwmJ1QedidUELY3VBMGN1QVVjdUF5Y3VBnmN1QcJjdUHnY3VBC2R1QTBkdUFUZHVBeWR1QZ5kdUHCZHVB52R1QQtldUEwZXVBVGV1QXlldUGdZXVBwmV1QeZldUELZnVBMGZ1QVRmdUF5ZnVBnWZ1QcJmdUHmZnVBC2d1QS9ndUFUZ3VBeGd1QZ1ndUHBZ3VB5md1QQpodUEvaHVBVGh1QXhodUGdaHVBwWh1QeZodUEKaXVBL2l1QVNpdUF4aXVBnGl1QcFpdUHlaXVBCmp1QS5qdUFTanVBd2p1QZxqdUHAanVB5Wp1QQlrdUEua3VBUmt1QXdrdUGba3VBwGt1QeRrdUEJbHVBLWx1QVJsdUF2bHVBm2x1Qb9sdUHkbHVBCG11QS1tdUFRbXVBdm11QZptdUG/bXVB4211QQhudUEsbnVBUW51QXVudUGabnVBvm51QeNudUEHb3VBLG91QVBvdUF1b3VBmW91Qb5vdUHib3VBB3B1QStwdUFQcHVBdHB1QZhwdUG9cHVB4XB1QQZxdUEqcXVBT3F1QXNxdUGYcXVBvHF1QeFxdUEFcnVBKnJ1QU5ydUFzcnVBl3J1QbtydUHgcnVBBHN1QSlzdUFNc3VBcnN1QZZzdUG7c3VB33N1QQR0dUEodHVBTHR1QXF0dUGVdHVBunR1Qd50dUEDdXVBJ3V1QUx1dUFwdXVBlHV1Qbl1dUHddXVBAnZ1QSZ2dUFLdnVBb3Z1QZR2dUG4dnVB3HZ1QQF3dUEld3VBSnd1QW53dUGTd3VBt3d1Qdt3dUEAeHVBJHh1QUl4dUFteHVBknh1QbZ4dUHaeHVB/3h1QSN5dUFIeXVBbHl1QZF5dUG1eXVB2Xl1Qf55dUEienVBR3p1QWt6dUGPenVBtHp1Qdh6dUH9enVBIXt1QUZ7dUFqe3VBjnt1QbN7dUHXe3VB/Ht1QSB8dUFEfHVBaXx1QY18dUGyfHVB1nx1Qfp8dUEffXVBQ311QWh9dUGMfXVBsH11QdV9dUH5fXVBHX51QUJ+dUFmfnVBi351Qa9+dUHTfnVB+H51QRx/dUFBf3VBZX91QYl/dUGuf3VB0n91QfZ/dUEbgHVBP4B1QWSAdUGIgHVBrIB1QdGAdUH1gHVBGYF1QT6BdUFigXVBh4F1QauBdUHPgXVB9IF1QRiCdUE8gnVBYYJ1QYWCdUGqgnVBzoJ1QfKCdUEXg3VBO4N1QV+DdUGEg3VBqIN1QcyDdUHxg3VBFYR1QTmEdUFehHVBgoR1QaeEdUHLhHVB74R1QRSFdUE4hXVBXIV1QYGFdUGlhXVByYV1Qe6FdUEShnVBNoZ1QVuGdUF/hnVBo4Z1QciGdUHshnVBEId1QTWHdUFZh3VBfYd1QaKHdUHGh3VB6od1QQ+IdUEziHVBV4h1QXyIdUGgiHVBxIh1QemIdUENiXVBMYl1QVaJdUF6iXVBnol1QcOJdUHniXVBC4p1QS+KdUFUinVBeIp1QZyKdUHBinVB5Yp1QQmLdUEui3VBUot1QXaLdUGbi3VBv4t1QeOLdUEIjHVBLIx1QVCMdUF0jHVBmYx1Qb2MdUHhjHVBBo11QSqNdUFOjXVBc411QZeNdUG7jXVB3411QQSOdUEojnVBTI51QXGOdUGVjnVBuY51Qd2OdUECj3VBJo91QUqPdUFvj3VBk491QbePdUHbj3VBAJB1QSSQdUFIkHVBbZB1QZGQdUG1kHVB2ZB1Qf6QdUEikXVBRpF1QWqRdUGPkXVBs5F1QdeRdUH8kXVBIJJ1QUSSdUFoknVBjZJ1QbGSdUHVknVB+ZJ1QR6TdUFCk3VBZpN1QYqTdUGvk3VB05N1QfeTdUEblHVBQJR1QWSUdUGIlHVBrJR1QdGUdUH1lHVBGZV1QT2VdUFilXVBhpV1QaqVdUHOlXVB85V1QReWdUE7lnVBX5Z1QYSWdUGolnVBzJZ1QfCWdUEVl3VBOZd1QV2XdUGBl3VBppd1QcqXdUHul3VBEph1QTaYdUFbmHVBf5h1QaOYdUHHmHVB7Jh1QRCZdUE0mXVBWJl1QX2ZdUGhmXVBxZl1QemZdUENmnVBMpp1QVaadUF6mnVBnpp1QcKadUHnmnVBC5t1QS+bdUFTm3VBeJt1QZybdUHAm3VB5Jt1QQicdUEtnHVBUZx1QXWcdUGZnHVBvZx1QeKcdUEGnXVBKp11QU6ddUFynXVBl511QbuddUHfnXVBA551QSeedUFMnnVBcJ51QZSedUG4nnVB3J51QQGfdUEln3VBSZ91QW2fdUGRn3VBtZ91QdqfdUH+n3VBIqB1QUagdUFqoHVBj6B1QbOgdUHXoHVB+6B1QR+hdUFDoXVBaKF1QYyhdUGwoXVB1KF1QfihdUEconVBQaJ1QWWidUGJonVBraJ1QdGidUH1onVBGqN1QT6jdUFio3VBhqN1QaqjdUHOo3VB86N1QRekdUE7pHVBX6R1QYOkdUGnpHVBzKR1QfCkdUEUpXVBOKV1QVyldUGApXVBpKV1QcmldUHtpXVBEaZ1QTWmdUFZpnVBfaZ1QaGmdUHGpnVB6qZ1QQ6ndUEyp3VBVqd1QXqndUGep3VBw6d1QeendUELqHVBL6h1QVOodUF3qHVBm6h1Qb+odUHkqHVBCKl1QSypdUFQqXVBdKl1QZipdUG8qXVB4Kl1QQWqdUEpqnVBTap1QXGqdUGVqnVBuap1Qd2qdUEBq3VBJqt1QUqrdUFuq3VBkqt1QbardUHaq3VB/qt1QSKsdUFGrHVBa6x1QY+sdUGzrHVB16x1QfusdUEfrXVBQ611QWetdUGLrXVBr611QdStdUH4rXVBHK51QUCudUFkrnVBiK51QayudUHQrnVB9K51QRivdUE8r3VBYa91QYWvdUGpr3VBza91QfGvdUEVsHVBObB1QV2wdUGBsHVBpbB1QcmwdUHtsHVBErF1QTaxdUFasXVBfrF1QaKxdUHGsXVB6rF1QQ6ydUEysnVBVrJ1QXqydUGesnVBwrJ1QeaydUELs3VBL7N1QVOzdUF3s3VBm7N1Qb+zdUHjs3VBB7R1QSu0dUFPtHVBc7R1QZe0dUG7tHVB37R1QQO1dUEntXVBS7V1QXC1dUGUtXVBuLV1Qdy1dUEAtnVBJLZ1QUi2dUFstnVBkLZ1QbS2dUHYtnVB/LZ1QSC3dUFEt3VBaLd1QYy3dUGwt3VB1Ld1Qfi3dUEcuHVBQLh1QWS4dUGIuHVBrLh1QdG4dUH1uHVBGbl1QT25dUFhuXVBhbl1Qam5dUHNuXVB8bl1QRW6dUE5unVBXbp1QYG6dUGlunVBybp1Qe26dUERu3VBNbt1QVm7dUF9u3VBobt1QcW7dUHpu3VBDbx1QTG8dUFVvHVBebx1QZ28dUHBvHVB5bx1QQm9dUEtvXVBUb11QXW9dUGZvXVBvb11QeG9dUEFvnVBKb51QU2+dUFxvnVBlb51Qbm+dUHdvnVBAb91QSW/dUFJv3VBbb91QZG/dUG1v3VB2b91Qf2/dUEhwHVBRcB1QWnAdUGNwHVBscB1QdXAdUH5wHVBHcF1QUHBdUFlwXVBicF1Qa3BdUHRwXVB9cF1QRnCdUE9wnVBYcJ1QYXCdUGpwnVBzcJ1QfDCdUEUw3VBOMN1QVzDdUGAw3VBpMN1QcjDdUHsw3VBEMR1QTTEdUFYxHVBfMR1QaDEdUHExHVB6MR1QQzFdUEwxXVBVMV1QXjFdUGcxXVBwMV1QeTFdUEIxnVBLMZ1QU/GdUFzxnVBl8Z1QbvGdUHfxnVBA8d1QSfHdUFLx3VBb8d1QZPHdUG3x3VB28d1Qf/HdUEjyHVBR8h1QWvIdUGPyHVBssh1QdbIdUH6yHVBHsl1QULJdUFmyXVBisl1Qa7JdUHSyXVB9sl1QRrKdUE+ynVBYsp1QYbKdUGpynVBzcp1QfHKdUEVy3VBOct1QV3LdUGBy3VBpct1QcnLdUHty3VBEcx1QTXMdUFYzHVBfMx1QaDMdUHEzHVB6Mx1QQzNdUEwzXVBVM11QXjNdUGczXVBwM11QePNdUEHznVBK851QU/OdUFzznVBl851QbvOdUHfznVBA891QSfPdUFKz3VBbs91QZLPdUG2z3VB2s91Qf7PdUEi0HVBRtB1QWrQdUGN0HVBsdB1QdXQdUH50HVBHdF1QUHRdUFl0XVBidF1Qa3RdUHQ0XVB9NF1QRjSdUE80nVBYNJ1QYTSdUGo0nVBzNJ1Qe/SdUET03VBN9N1QVvTdUF/03VBo9N1QcfTdUHq03VBDtR1QTLUdUFW1HVBetR1QZ7UdUHC1HVB5dR1QQnVdUEt1XVBUdV1QXXVdUGZ1XVBvdV1QeDVdUEE1nVBKNZ1QUzWdUFw1nVBlNZ1QbjWdUHb1nVB/9Z1QSPXdUFH13VBa9d1QY/XdUGz13VB1td1QfrXdUEe2HVBQth1QWbYdUGK2HVBrdh1QdHYdUH12HVBGdl1QT3ZdUFh2XVBhNl1QajZdUHM2XVB8Nl1QRTadUE42nVBW9p1QX/adUGj2nVBx9p1QevadUEP23VBMtt1QVbbdUF623VBntt1QcLbdUHl23VBCdx1QS3cdUFR3HVBddx1QZjcdUG83HVB4Nx1QQTddUEo3XVBTN11QW/ddUGT3XVBt911QdvddUH/3XVBIt51QUbedUFq3nVBjt51QbLedUHV3nVB+d51QR3fdUFB33VBZd91QYjfdUGs33VB0N91QfTfdUEY4HVBO+B1QV/gdUGD4HVBp+B1QcvgdUHu4HVBEuF1QTbhdUFa4XVBfeF1QaHhdUHF4XVB6eF1QQ3idUEw4nVBVOJ1QXjidUGc4nVBv+J1QePidUEH43VBK+N1QU/jdUFy43VBluN1QbrjdUHe43VBAeR1QSXkdUFJ5HVBbeR1QZDkdUG05HVB2OR1QfzkdUEg5XVBQ+V1QWfldUGL5XVBr+V1QdLldUH25XVBGuZ1QT7mdUFh5nVBheZ1QanmdUHN5nVB8OZ1QRTndUE453VBXOd1QX/ndUGj53VBx+d1QevndUEO6HVBMuh1QVbodUF66HVBneh1QcHodUHl6HVBCOl1QSzpdUFQ6XVBdOl1QZfpdUG76XVB3+l1QQPqdUEm6nVBSup1QW7qdUGS6nVBtep1QdnqdUH96nVBIOt1QUTrdUFo63VBjOt1Qa/rdUHT63VB9+t1QRvsdUE+7HVBYux1QYbsdUGp7HVBzex1QfHsdUEV7XVBOO11QVztdUGA7XVBo+11QcftdUHr7XVBD+51QTLudUFW7nVBeu51QZ3udUHB7nVB5e51QQjvdUEs73VBUO91QXTvdUGX73VBu+91Qd/vdUEC8HVBJvB1QUrwdUFt8HVBkfB1QbXwdUHY8HVB/PB1QSDxdUFE8XVBZ/F1QYvxdUGv8XVB0vF1QfbxdUEa8nVBPfJ1QWHydUGF8nVBqPJ1QczydUHw8nVBE/N1QTfzdUFb83VBfvN1QaLzdUHG83VB6fN1QQ30dUEx9HVBVPR1QXj0dUGc9HVBv/R1QeP0dUEH9XVBKvV1QU71dUFy9XVBlfV1Qbn1dUHd9XVBAPZ1QST2dUFI9nVBa/Z1QY/2dUGz9nVB1vZ1Qfr2dUEe93VBQfd1QWX3dUGJ93VBrPd1QdD3dUH093VBF/h1QTv4dUFf+HVBgvh1Qab4dUHJ+HVB7fh1QRH5dUE0+XVBWPl1QXz5dUGf+XVBw/l1Qef5dUEK+nVBLvp1QVH6dUF1+nVBmfp1Qbz6dUHg+nVBBPt1QSf7dUFL+3VBb/t1QZL7dUG2+3VB2ft1Qf37dUEh/HVBRPx1QWj8dUGM/HVBr/x1QdP8dUH2/HVBGv11QT79dUFh/XVBhf11Qaj9dUHM/XVB8P11QRP+dUE3/nVBW/51QX7+dUGi/nVBxf51Qen+dUEN/3VBMP91QVT/dUF3/3VBm/91Qb//dUHi/3VBBgB2QSkAdkFNAHZBcQB2QZQAdkG4AHZB2wB2Qf8AdkEjAXZBRgF2QWoBdkGNAXZBsQF2QdQBdkH4AXZBHAJ2QT8CdkFjAnZBhgJ2QaoCdkHOAnZB8QJ2QRUDdkE4A3ZBXAN2QX8DdkGjA3ZBxwN2QeoDdkEOBHZBMQR2QVUEdkF4BHZBnAR2QcAEdkHjBHZBBwV2QSoFdkFOBXZBcQV2QZUFdkG5BXZB3AV2QQAGdkEjBnZBRwZ2QWoGdkGOBnZBsgZ2QdUGdkH5BnZBHAd2QUAHdkFjB3ZBhwd2QaoHdkHOB3ZB8gd2QRUIdkE5CHZBXAh2QYAIdkGjCHZBxwh2QeoIdkEOCXZBMQl2QVUJdkF5CXZBnAl2QcAJdkHjCXZBBwp2QSoKdkFOCnZBcQp2QZUKdkG4CnZB3Ap2Qf8KdkEjC3ZBRwt2QWoLdkGOC3ZBsQt2QdULdkH4C3ZBHAx2QT8MdkFjDHZBhgx2QaoMdkHNDHZB8Qx2QRQNdkE4DXZBWw12QX8NdkGiDXZBxg12QekNdkENDnZBMA52QVQOdkF4DnZBmw52Qb8OdkHiDnZBBg92QSkPdkFND3ZBcA92QZQPdkG3D3ZB2w92Qf4PdkEiEHZBRRB2QWkQdkGMEHZBsBB2QdMQdkH3EHZBGhF2QT4RdkFhEXZBhRF2QagRdkHMEXZB7xF2QRMSdkE2EnZBWhJ2QX0SdkGgEnZBxBJ2QecSdkELE3ZBLhN2QVITdkF1E3ZBmRN2QbwTdkHgE3ZBAxR2QScUdkFKFHZBbhR2QZEUdkG1FHZB2BR2QfwUdkEfFXZBQxV2QWYVdkGKFXZBrRV2QdAVdkH0FXZBFxZ2QTsWdkFeFnZBghZ2QaUWdkHJFnZB7BZ2QRAXdkEzF3ZBVxd2QXoXdkGdF3ZBwRd2QeQXdkEIGHZBKxh2QU8YdkFyGHZBlhh2QbkYdkHdGHZBABl2QSMZdkFHGXZBahl2QY4ZdkGxGXZB1Rl2QfgZdkEcGnZBPxp2QWIadkGGGnZBqRp2Qc0adkHwGnZBFBt2QTcbdkFbG3ZBfht2QaEbdkHFG3ZB6Bt2QQwcdkEvHHZBUxx2QXYcdkGZHHZBvRx2QeAcdkEEHXZBJx12QUsddkFuHXZBkR12QbUddkHYHXZB/B12QR8edkFCHnZBZh52QYkedkGtHnZB0B52QfQedkEXH3ZBOh92QV4fdkGBH3ZBpR92QcgfdkHrH3ZBDyB2QTIgdkFWIHZBeSB2QZwgdkHAIHZB4yB2QQchdkEqIXZBTSF2QXEhdkGUIXZBuCF2QdshdkH+IXZBIiJ2QUUidkFpInZBjCJ2Qa8idkHTInZB9iJ2QRojdkE9I3ZBYCN2QYQjdkGnI3ZByiN2Qe4jdkERJHZBNSR2QVgkdkF7JHZBnyR2QcIkdkHmJHZBCSV2QSwldkFQJXZBcyV2QZYldkG6JXZB3SV2QQEmdkEkJnZBRyZ2QWsmdkGOJnZBsSZ2QdUmdkH4JnZBGyd2QT8ndkFiJ3ZBhid2QakndkHMJ3ZB8Cd2QRModkE2KHZBWih2QX0odkGgKHZBxCh2QecodkEKKXZBLil2QVEpdkF1KXZBmCl2QbspdkHfKXZBAip2QSUqdkFJKnZBbCp2QY8qdkGzKnZB1ip2QfkqdkEdK3ZBQCt2QWMrdkGHK3ZBqit2Qc0rdkHxK3ZBFCx2QTcsdkFbLHZBfix2QaEsdkHFLHZB6Cx2QQstdkEvLXZBUi12QXUtdkGZLXZBvC12Qd8tdkEDLnZBJi52QUkudkFtLnZBkC52QbMudkHXLnZB+i52QR0vdkFBL3ZBZC92QYcvdkGqL3ZBzi92QfEvdkEUMHZBODB2QVswdkF+MHZBojB2QcUwdkHoMHZBDDF2QS8xdkFSMXZBdTF2QZkxdkG8MXZB3zF2QQMydkEmMnZBSTJ2QW0ydkGQMnZBszJ2QdYydkH6MnZBHTN2QUAzdkFkM3ZBhzN2QaozdkHNM3ZB8TN2QRQ0dkE3NHZBWzR2QX40dkGhNHZBxDR2Qeg0dkELNXZBLjV2QVI1dkF1NXZBmDV2Qbs1dkHfNXZBAjZ2QSU2dkFJNnZBbDZ2QY82dkGyNnZB1jZ2Qfk2dkEcN3ZBPzd2QWM3dkGGN3ZBqTd2Qc03dkHwN3ZBEzh2QTY4dkFaOHZBfTh2QaA4dkHDOHZB5zh2QQo5dkEtOXZBUDl2QXQ5dkGXOXZBujl2Qd05dkEBOnZBJDp2QUc6dkFqOnZBjjp2QbE6dkHUOnZB9zp2QRs7dkE+O3ZBYTt2QYQ7dkGoO3ZByzt2Qe47dkERPHZBNTx2QVg8dkF7PHZBnjx2QcE8dkHlPHZBCD12QSs9dkFOPXZBcj12QZU9dkG4PXZB2z12Qf89dkEiPnZBRT52QWg+dkGLPnZBrz52QdI+dkH1PnZBGD92QTw/dkFfP3ZBgj92QaU/dkHIP3ZB7D92QQ9AdkEyQHZBVUB2QXlAdkGcQHZBv0B2QeJAdkEFQXZBKUF2QUxBdkFvQXZBkkF2QbVBdkHZQXZB/EF2QR9CdkFCQnZBZUJ2QYlCdkGsQnZBz0J2QfJCdkEVQ3ZBOUN2QVxDdkF/Q3ZBokN2QcVDdkHpQ3ZBDER2QS9EdkFSRHZBdUR2QZlEdkG8RHZB30R2QQJFdkElRXZBSEV2QWxFdkGPRXZBskV2QdVFdkH4RXZBHEZ2QT9GdkFiRnZBhUZ2QahGdkHLRnZB70Z2QRJHdkE1R3ZBWEd2QXtHdkGeR3ZBwkd2QeVHdkEISHZBK0h2QU5IdkFySHZBlUh2QbhIdkHbSHZB/kh2QSFJdkFESXZBaEl2QYtJdkGuSXZB0Ul2QfRJdkEXSnZBO0p2QV5KdkGBSnZBpEp2QcdKdkHqSnZBDUt2QTFLdkFU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W3dBJVt3QUZbd0FoW3dBiVt3Qatbd0HNW3dB7lt3QRBcd0ExXHdBU1x3QXRcd0GWXHdBt1x3Qdlcd0H7XHdBHF13QT5dd0FfXXdBgV13QaJdd0HEXXdB5V13QQded0EpXndBSl53QWxed0GNXndBr153QdBed0HyXndBE193QTVfd0FWX3dBeF93QZpfd0G7X3dB3V93Qf5fd0EgYHdBQWB3QWNgd0GEYHdBpmB3Qcdgd0HpYHdBCmF3QSxhd0FOYXdBb2F3QZFhd0GyYXdB1GF3QfVhd0EXYndBOGJ3QVpid0F7YndBnWJ3Qb5id0HgYndBAWN3QSNjd0FEY3dBZmN3QYhjd0GpY3dBy2N3Qexjd0EOZHdBL2R3QVFkd0FyZHdBlGR3QbVkd0HXZHdB+GR3QRpld0E7ZXdBXWV3QX5ld0GgZXdBwWV3QeNld0EEZndBJmZ3QUdmd0FpZndBimZ3Qaxmd0HNZndB72Z3QRBnd0EyZ3dBU2d3QXVnd0GWZ3dBuGd3Qdlnd0H7Z3dBHGh3QT5od0FfaHdBgWh3QaJod0HEaHdB5Wh3QQdpd0EoaXdBSml3QWtpd0GNaXdBrml3QdBpd0HxaXdBE2p3QTRqd0FWandBd2p3QZlqd0G6andB22p3Qf1qd0Eea3dBQGt3QWFrd0GDa3dBpGt3QcZrd0Hna3dBCWx3QSpsd0FMbHdBbWx3QY9sd0GwbHdB0mx3QfNsd0EVbXdBNm13QVdtd0F5bXdBmm13Qbxtd0HdbXdB/213QSBud0FCbndBY253QYVud0GmbndByG53Qelud0EKb3dBLG93QU1vd0Fvb3dBkG93QbJvd0HTb3dB9W93QRZwd0E4cHdBWXB3QXpwd0GccHdBvXB3Qd9wd0EAcXdBInF3QUNxd0FlcXdBhnF3Qadxd0HJcXdB6nF3QQxyd0EtcndBT3J3QXByd0GRcndBs3J3QdRyd0H2cndBF3N3QTlzd0Fac3dBe3N3QZ1zd0G+c3dB4HN3QQF0d0EjdHdBRHR3QWV0d0GHdHdBqHR3Qcp0d0HrdHdBDXV3QS51d0FPdXdBcXV3QZJ1d0G0dXdB1XV3Qfd1d0EYdndBOXZ3QVt2d0F8dndBnnZ3Qb92d0HgdndBAnd3QSN3d0FFd3dBZnd3QYd3d0Gpd3dBynd3Qex3d0ENeHdBLnh3QVB4d0FxeHdBk3h3QbR4d0HVeHdB93h3QRh5d0E6eXdBW3l3QXx5d0GeeXdBv3l3QeF5d0ECendBI3p3QUV6d0FmendBiHp3Qal6d0HKendB7Hp3QQ17d0Eve3dBUHt3QXF7d0GTe3dBtHt3QdV7d0H3e3dBGHx3QTp8d0FbfHdBfHx3QZ58d0G/fHdB4Xx3QQJ9d0EjfXdBRX13QWZ9d0GHfXdBqX13Qcp9d0HsfXdBDX53QS5+d0FQfndBcX53QZJ+d0G0fndB1X53QfZ+d0EYf3dBOX93QVt/d0F8f3dBnX93Qb9/d0Hgf3dBAYB3QSOAd0FEgHdBZYB3QYeAd0GogHdByoB3QeuAd0EMgXdBLoF3QU+Bd0FwgXdBkoF3QbOBd0HUgXdB9oF3QReCd0E4gndBWoJ3QXuCd0GcgndBvoJ3Qd+Cd0EAg3dBIoN3QUODd0Fkg3dBhoN3QaeDd0HIg3dB6oN3QQuEd0EshHdBToR3QW+Ed0GQhHdBsoR3QdOEd0H0hHdBFoV3QTeFd0FYhXdBeoV3QZuFd0G8hXdB3oV3Qf+Fd0EghndBQoZ3QWOGd0GEhndBpoZ3QceGd0HohndBCod3QSuHd0FMh3dBbod3QY+Hd0Gwh3dB0od3QfOHd0EUiHdBNoh3QVeId0F4iHdBmYh3QbuId0HciHdB/Yh3QR+Jd0FAiXdBYYl3QYOJd0GkiXdBxYl3QeeJd0EIindBKYp3QUqKd0FsindBjYp3Qa6Kd0HQindB8Yp3QRKLd0E0i3dBVYt3QXaLd0GXi3dBuYt3QdqLd0H7i3dBHYx3QT6Md0FfjHdBgIx3QaKMd0HDjHdB5Ix3QQaNd0EnjXdBSI13QWmNd0GLjXdBrI13Qc2Nd0HvjXdBEI53QTGOd0FSjndBdI53QZWOd0G2jndB2I53QfmOd0Eaj3dBO493QV2Pd0F+j3dBn493QcCPd0Hij3dBA5B3QSSQd0FGkHdBZ5B3QYiQd0GpkHdBy5B3QeyQd0ENkXdBLpF3QVCRd0FxkXdBkpF3QbORd0HVkXdB9pF3QReSd0E4kndBWpJ3QXuSd0GckndBvZJ3Qd+Sd0EAk3dBIZN3QUKTd0Fkk3dBhZN3QaaTd0HHk3dB6ZN3QQqUd0ErlHdBTJR3QW6Ud0GPlHdBsJR3QdGUd0HzlHdBFJV3QTWVd0FWlXdBeJV3QZmVd0G6lXdB25V3Qf2Vd0EelndBP5Z3QWCWd0GClndBo5Z3QcSWd0HllndBBpd3QSiXd0FJl3dBapd3QYuXd0Gtl3dBzpd3Qe+Xd0EQmHdBMZh3QVOYd0F0mHdBlZh3QbaYd0HYmHdB+Zh3QRqZd0E7mXdBXJl3QX6Zd0GfmXdBwJl3QeGZd0EDmndBJJp3QUWad0FmmndBh5p3Qamad0HKmndB65p3QQybd0Etm3dBT5t3QXCbd0GRm3dBspt3QdObd0H1m3dBFpx3QTecd0FYnHdBeZx3QZucd0G8nHdB3Zx3Qf6cd0EfnXdBQZ13QWKdd0GDnXdBpJ13QcWdd0HnnXdBCJ53QSmed0FKnndBa553QY2ed0GunndBz553QfCed0ERn3dBMp93QVSfd0F1n3dBlp93Qbefd0HYn3dB+p93QRugd0E8oHdBXaB3QX6gd0GfoHdBwaB3QeKgd0EDoXdBJKF3QUWhd0FmoXdBiKF3Qamhd0HKoXdB66F3QQyid0EuondBT6J3QXCid0GRondBsqJ3QdOid0H0ondBFqN3QTejd0FYo3dBeaN3QZqjd0G7o3dB3aN3Qf6jd0EfpHdBQKR3QWGkd0GCpHdBpKR3QcWkd0HmpHdBB6V3QSild0FJpXdBaqV3QYyld0GtpXdBzqV3Qe+ld0EQpndBMaZ3QVKmd0F0pndBlaZ3Qbamd0HXpndB+KZ3QRmnd0E6p3dBXKd3QX2nd0Gep3dBv6d3QeCnd0EBqHdBIqh3QUSod0FlqHdBhqh3Qaeod0HIqHdB6ah3QQqpd0ErqXdBTal3QW6pd0GPqXdBsKl3QdGpd0HyqXdBE6p3QTSqd0FWqndBd6p3QZiqd0G5qndB2qp3Qfuqd0Ecq3dBPat3QV+rd0GAq3dBoat3QcKrd0Hjq3dBBKx3QSWsd0FGrHdBZ6x3QYmsd0GqrHdBy6x3Qeysd0ENrXdBLq13QU+td0FwrXdBka13QbKtd0HUrXdB9a13QRaud0E3rndBWK53QXmud0GarndBu653Qdyud0H9rndBH693QUCvd0Fhr3dBgq93QaOvd0HEr3dB5a93QQawd0EnsHdBSLB3QWmwd0GLsHdBrLB3Qc2wd0HusHdBD7F3QTCxd0FRsXdBcrF3QZOxd0G0sXdB1bF3Qfaxd0EYsndBObJ3QVqyd0F7sndBnLJ3Qb2yd0He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lnhBFJd4QTSXeEFUl3hBdJd4QZSXeEGzl3hB05d4QfOXeEETmHhBM5h4QVOYeEFymHhBkph4QbKYeEHSmHhB8ph4QRGZeEExmXhBUZl4QXGZeEGRmXhBsJl4QdCZeEHwmXhBEJp4QTCaeEFPmnhBb5p4QY+aeEGvmnhBz5p4Qe6aeEEOm3hBLpt4QU6beEFum3hBjZt4Qa2beEHNm3hB7Zt4QQ2ceEEsnHhBTJx4QWyceEGMnHhBrJx4QcuceEHrnHhBC514QSudeEFLnXhBap14QYqdeEGqnXhByp14QemdeEEJnnhBKZ54QUmeeEFpnnhBiJ54QaieeEHInnhB6J54QQefeEEnn3hBR594QWefeEGHn3hBpp94QcafeEHmn3hBBqB4QSWgeEFFoHhBZaB4QYWgeEGloHhBxKB4QeSgeEEEoXhBJKF4QUOheEFjoXhBg6F4QaOheEHCoXhB4qF4QQKieEEionhBQaJ4QWGieEGBonhBoaJ4QcGieEHgonhBAKN4QSCjeEFAo3hBX6N4QX+jeEGfo3hBv6N4Qd6jeEH+o3hBHqR4QT6keEFdpHhBfaR4QZ2keEG9pHhB3KR4QfykeEEcpXhBPKV4QVuleEF7pXhBm6V4QbqleEHapXhB+qV4QRqmeEE5pnhBWaZ4QXmmeEGZpnhBuKZ4QdimeEH4pnhBGKd4QTeneEFXp3hBd6d4QZeneEG2p3hB1qd4QfaneEEVqHhBNah4QVWoeEF1qHhBlKh4QbSoeEHUqHhB9Kh4QROpeEEzqXhBU6l4QXKpeEGSqXhBsql4QdKpeEHxqXhBEap4QTGqeEFQqnhBcKp4QZCqeEGwqnhBz6p4Qe+qeEEPq3hBLqt4QU6reEFuq3hBjqt4Qa2reEHNq3hB7at4QQyseEEsrHhBTKx4QWyseEGLrHhBq6x4QcuseEHqrHhBCq14QSqteEFJrXhBaa14QYmteEGprXhByK14QeiteEEIrnhBJ654QUeueEFnrnhBhq54QaaueEHGrnhB5q54QQWveEElr3hBRa94QWSveEGEr3hBpK94QcOveEHjr3hBA7B4QSKweEFCsHhBYrB4QYKweEGhsHhBwbB4QeGweEEAsXhBILF4QUCxeEFfsXhBf7F4QZ+xeEG+sXhB3rF4Qf6xeEEdsnhBPbJ4QV2yeEF8snhBnLJ4QbyyeEHb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V3lBrVd5QcxXeUHrV3lBClh5QShYeUFHWHlBZlh5QYVYeUGkWHlBwlh5QeFYeUEAWXlBH1l5QT5ZeUFcWXlBe1l5QZpZeUG5WXlB2Fl5QfZZeUEVWnlBNFp5QVNaeUFxWnlBkFp5Qa9aeUHOWnlB7Vp5QQtbeUEqW3lBSVt5QWhbeUGHW3lBpVt5QcRbeUHjW3lBAlx5QSBceUE/XHlBXlx5QX1ceUGcXHlBulx5QdlceUH4XHlBF115QTVdeUFUXXlBc115QZJdeUGwXXlBz115Qe5deUENXnlBLF55QUpeeUFpXnlBiF55QadeeUHFXnlB5F55QQNfeUEiX3lBQF95QV9feUF+X3lBnV95QbtfeUHaX3lB+V95QRhgeUE2YHlBVWB5QXRgeUGTYHlBsWB5QdBgeUHvYHlBDmF5QSxheUFLYXlBamF5QYlheUGnYXlBxmF5QeVheUEEYnlBImJ5QUFieUFgYnlBf2J5QZ1ieUG8YnlB22J5QfpieUEYY3lBN2N5QVZjeUF1Y3lBk2N5QbJjeUHRY3lB8GN5QQ5keUEtZHlBTGR5QWtkeUGJZHlBqGR5QcdkeUHlZHlBBGV5QSNleUFCZXlBYGV5QX9leUGeZXlBvWV5QdtleUH6ZXlBGWZ5QTdmeUFWZnlBdWZ5QZRmeUGyZnlB0WZ5QfBmeUEPZ3lBLWd5QUxneUFrZ3lBiWd5QahneUHHZ3lB5md5QQRoeUEjaHlBQmh5QWBoeUF/aHlBnmh5Qb1oeUHbaHlB+mh5QRlpeUE3aXlBVml5QXVpeUGUaXlBsml5QdFpeUHwaXlBDmp5QS1qeUFManlBamp5QYlqeUGoanlBx2p5QeVqeUEEa3lBI2t5QUFreUFga3lBf2t5QZ1reUG8a3lB22t5QfpreUEYbHlBN2x5QVZseUF0bHlBk2x5QbJseUHQbHlB72x5QQ5teUEsbXlBS215QWpteUGIbXlBp215QcZteUHlbXlBA255QSJueUFBbnlBX255QX5ueUGdbnlBu255QdpueUH5bnlBF295QTZveUFVb3lBc295QZJveUGxb3lBz295Qe5veUENcHlBK3B5QUpweUFpcHlBh3B5QaZweUHFcHlB43B5QQJxeUEhcXlBP3F5QV5xeUF9cXlBm3F5QbpxeUHZcXlB93F5QRZyeUE1cnlBU3J5QXJyeUGR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3XlBgN15QZ/deUG93XlB2915QfndeUEX3nlBNd55QVPeeUFx3nlBj955Qa7eeUHM3nlB6t55QQjfeUEm33lBRN95QWLfeUGA33lBnt95QbzfeUHb33lB+d95QRfgeUE14HlBU+B5QXHgeUGP4HlBreB5QcvgeUHp4HlBB+F5QSbheUFE4XlBYuF5QYDheUGe4XlBvOF5QdrheUH44XlBFuJ5QTTieUFS4nlBceJ5QY/ieUGt4nlBy+J5QenieUEH43lBJeN5QUPjeUFh43lBf+N5QZ3jeUG743lB2uN5QfjjeUEW5HlBNOR5QVLkeUFw5HlBjuR5QazkeUHK5HlB6OR5QQbleUEk5XlBQuV5QWDleUF/5XlBneV5QbvleUHZ5XlB9+V5QRXmeUEz5nlBUeZ5QW/meUGN5nlBq+Z5QcnmeUHn5nlBBed5QSPneUFC53lBYOd5QX7neUGc53lBuud5QdjneUH253lBFOh5QTLoeUFQ6HlBbuh5QYzoeUGq6HlByOh5QeboeUEE6XlBIul5QUDpeUFf6XlBfel5QZvpeUG56XlB1+l5QfXpeUET6nlBMep5QU/qeUFt6nlBi+p5QanqeUHH6nlB5ep5QQPreUEh63lBP+t5QV3reUF763lBmet5QbfreUHV63lB8+t5QRLseUEw7HlBTux5QWzseUGK7HlBqOx5QcbseUHk7HlBAu15QSDteUE+7XlBXO15QXrteUGY7XlBtu15QdTteUHy7XlBEO55QS7ueUFM7nlBau55QYjueUGm7nlBxO55QeLueUEA73lBHu95QTzveUFa73lBeO95QZbveUG073lB0u95QfDveUEO8HlBLPB5QUrweUFo8HlBhvB5QaTweUHC8HlB4fB5Qf/weUEd8XlBO/F5QVnxeUF38XlBlfF5QbPxeUHR8XlB7/F5QQ3yeUEr8nlBSfJ5QWfyeUGF8nlBo/J5QcHyeUHf8nlB/fJ5QRvzeUE583lBV/N5QXXzeUGT83lBsfN5Qc/zeUHt83lBC/R5QSn0eUFH9HlBZfR5QYP0eUGh9HlBv/R5Qd30eUH79HlBGfV5QTf1eUFV9XlBc/V5QZD1eUGu9XlBzPV5Qer1eUEI9nlBJvZ5QUT2eUFi9nlBgPZ5QZ72eUG89nlB2vZ5Qfj2eUEW93lBNPd5QVL3eUFw93lBjvd5Qaz3eUHK93lB6Pd5QQb4eUEk+HlBQvh5QWD4eUF++HlBnPh5Qbr4eUHY+HlB9vh5QRT5eUEy+XlBUPl5QW75eUGM+XlBqvl5Qcj5eUHm+XlBBPp5QSL6eUFA+nlBXvp5QXv6eUGZ+nlBt/p5QdX6eUHz+nlBEft5QS/7eUFN+3lBa/t5QYn7eUGn+3lBxft5QeP7eUEB/HlBH/x5QT38eUFb/HlBefx5QZf8eUG1/HlB0/x5QfH8eUEP/XlBLP15QUr9eUFo/XlBhv15QaT9eUHC/XlB4P15Qf79eUEc/nlBOv55QVj+eUF2/nlBlP55QbL+eUHQ/nlB7v55QQz/eUEq/3lBR/95QWX/eUGD/3lBof95Qb//eUHd/3lB+/95QRkAekE3AHpBVQB6QXMAekGRAHpBrwB6Qc0AekHrAHpBCAF6QSYBekFEAXpBYgF6QYABekGeAXpBvAF6QdoBekH4AXpBFgJ6QTQCekFSAnpBcAJ6QY4CekGrAnpByQJ6QecCekEFA3pBIwN6QUEDekFfA3pBfQN6QZsDekG5A3pB1wN6QfUDekESBHpBMAR6QU4EekFsBHpBigR6QagEekHGBHpB5AR6QQIFekEgBXpBPgV6QVsFekF5BXpBlwV6QbUFekHTBXpB8QV6QQ8GekEtBnpBSwZ6QWkGekGHBnpBpAZ6QcIGekHgBnpB/gZ6QRwHekE6B3pBWAd6QXYHekGUB3pBsgd6Qc8HekHtB3pBCwh6QSkIekFHCHpBZQh6QYMIekGhCHpBvwh6QdwIekH6CHpBGAl6QTYJekFUCXpBcgl6QZAJekGuCXpBzAl6QekJekEHCnpBJQp6QUMKekFhCnpBfwp6QZ0KekG7CnpB2Ap6QfYKekEUC3pBMgt6QVALekFuC3pBjAt6QaoLekHIC3pB5Qt6QQMMekEhDHpBPwx6QV0MekF7DHpBmQx6QbcMekHUDHpB8gx6QRANekEuDXpBTA16QWoNekGIDXpBpQ16QcMNekHhDXpB/w16QR0OekE7DnpBWQ56QXYOekGUDnpBsg56QdAOekHuDnpBDA96QSoPekFID3pBZQ96QYMPekGhD3pBvw96Qd0PekH7D3pBGRB6QTYQekFUEHpBchB6QZAQekGuEHpBzBB6QekQekEHEXpBJRF6QUMRekFhEXpBfxF6QZ0RekG6EXpB2BF6QfYRekEUEnpBMhJ6QVASekFtEnpBixJ6QakSekHHEnpB5RJ6QQMTekEhE3pBPhN6QVwTekF6E3pBmBN6QbYTekHUE3pB8RN6QQ8UekEtFHpBSxR6QWkUekGHFHpBpBR6QcIUekHgFHpB/hR6QRwVekE6FXpBVxV6QXUVekGTFXpBsRV6Qc8VekHsFXpBChZ6QSgWekFGFnpBZBZ6QYIWekGfFnpBvRZ6QdsWekH5FnpBFxd6QTQXekFSF3pBcBd6QY4XekGsF3pByhd6QecXekEFGHpBIxh6QUEYekFfGHpBfBh6QZoYekG4GHpB1hh6QfQYekERGXpBLxl6QU0ZekFrGXpBiRl6QacZekHEGXpB4hl6QQAaekEeGnpBPBp6QVkaekF3GnpBlRp6QbMaekHRGnpB7hp6QQwbekEqG3pBSBt6QWYbekGDG3pBoRt6Qb8bekHdG3pB+xt6QRgcekE2HHpBVBx6QXIcekGPHHpBrRx6QcscekHpHHpBBx16QSQdekFCHXpBYB16QX4dekGcHXpBuR16QdcdekH1HXpBEx56QTAeekFOHnpBbB56QYoeekGoHnpBxR56QeMeekEBH3pBHx96QT0fekFaH3pBeB96QZYfekG0H3pB0R96Qe8fekENIHpBKyB6QUggekFmIHpBhCB6QaIgekHAIHpB3SB6QfsgekEZIXpBNyF6QVQhekFyIXpBkCF6Qa4hekHLIXpB6SF6QQciekElInpBQyJ6QWAiekF+InpBnCJ6QboiekHXInpB9SJ6QRMjekExI3pBTiN6QWwjekGKI3pBqCN6QcUjekHjI3pBASR6QR8kekE8JHpBWiR6QXgkekGWJHpBsyR6QdEkekHvJHpBDSV6QSolekFIJXpBZiV6QYQlekGhJXpBvyV6Qd0lekH7JXpBGCZ6QTYmekFUJnpBciZ6QY8mekGtJnpByyZ6QekmekEGJ3pBJCd6QUInekFfJ3pBfSd6QZsnekG5J3pB1id6QfQnekESKHpBMCh6QU0oekFrKHpBiSh6QacoekHEKHpB4ih6QQApekEdKXpBOyl6QVkpekF3KXpBlCl6QbIpekHQKXpB7il6QQsqekEpKnpBRyp6QWQqekGCKnpBoCp6Qb4qekHbKnpB+Sp6QRcrekE0K3pBUit6QXArekGOK3pBqyt6QckrekHnK3pBBCx6QSIsekFALHpBXix6QXssekGZLHpBtyx6QdQsekHyLHpBEC16QS4tekFLLXpBaS16QYctekGkLXpBwi16QeAtekH+LXpBGy56QTkuekFXLnpBdC56QZIuekGwLnpBzS56QesuekEJL3pBJy96QUQvekFiL3pBgC96QZ0vekG7L3pB2S96QfYvekEUMHpBMjB6QU8wekFtMHpBizB6QakwekHGMHpB5DB6QQIxekEfMXpBPTF6QVsxekF4MXpBljF6QbQxekHRMXpB7zF6QQ0yekEqMnpBSDJ6QWYyekGDMnpBoTJ6Qb8yekHdMnpB+jJ6QRgzekE2M3pBUzN6QXEzekGPM3pBrDN6QcozekHoM3pBBTR6QSM0ekFBNHpBXjR6QXw0ekGaNHpBtzR6QdU0ekHzNHpBEDV6QS41ekFMNXpBaTV6QYc1ekGlNXpBwjV6QeA1ekH+NXpBGzZ6QTk2ekFXNnpBdDZ6QZI2ekGwNnpBzTZ6Qes2ekEJN3pBJjd6QUQ3ekFiN3pBfzd6QZ03ekG7N3pB2Dd6QfY3ekETOHpBMTh6QU84ekFsOHpBijh6Qag4ekHFOHpB4zh6QQE5ekEeOXpBPDl6QVo5ekF3OXpBlTl6QbM5ekHQOXpB7jl6QQs6ekEpOnpBRzp6QWQ6ekGCOnpBoDp6Qb06ekHbOnpB+Tp6QRY7ekE0O3pBUjt6QW87ekGNO3pBqjt6Qcg7ekHmO3pBAzx6QSE8ekE/PHpBXDx6QXo8ekGXPHpBtTx6QdM8ekHwPHpBDj16QSw9ekFJPXpBZz16QYQ9ekGiPXpBwD16Qd09ekH7PXpBGT56QTY+ekFUPnpBcT56QY8+ekGtPnpByj56Qeg+ekEGP3pBIz96QUE/ekFeP3pBfD96QZo/ekG3P3pB1T96QfI/ekEQQHpBLkB6QUtAekFpQHpBh0B6QaRAekHCQHpB30B6Qf1AekEbQXpBOEF6QVZBekFzQXpBkUF6Qa9BekHMQXpB6kF6QQdCekElQnpBQ0J6QWBCekF+QnpBm0J6QblCekHXQnpB9EJ6QRJDekEvQ3pBTUN6QWtDekGIQ3pBpkN6QcNDekHhQ3pB/0N6QRxEekE6RHpBV0R6QXVEekGTRHpBsER6Qc5EekHrRHpBCUV6QSZFekFERXpBYkV6QX9FekGdRXpBukV6QdhFekH2RXpBE0Z6QTFGekFO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k3pB6JN6QQWUekEilHpBQJR6QV2UekF6lHpBl5R6QbSUekHSlHpB75R6QQyVekEplXpBRpV6QWSVekGBlXpBnpV6QbuVekHYlXpB9pV6QROWekEwlnpBTZZ6QWqWekGHlnpBpZZ6QcKWekHflnpB/JZ6QRmXekE3l3pBVJd6QXGXekGOl3pBq5d6QciXekHml3pBA5h6QSCYekE9mHpBWph6QXeYekGVmHpBsph6Qc+YekHsmHpBCZl6QSaZekFEmXpBYZl6QX6ZekGbmXpBuJl6QdWZekHzmXpBEJp6QS2aekFKmnpBZ5p6QYSaekGimnpBv5p6QdyaekH5mnpBFpt6QTObekFRm3pBbpt6QYubekGom3pBxZt6QeKbekEAnHpBHZx6QTqcekFXnHpBdJx6QZGcekGunHpBzJx6QemcekEGnXpBI516QUCdekFdnXpBe516QZidekG1nXpB0p16Qe+dekEMnnpBKZ56QUeeekFknnpBgZ56QZ6eekG7nnpB2J56QfWeekETn3pBMJ96QU2fekFqn3pBh596QaSfekHBn3pB3p96QfyfekEZoHpBNqB6QVOgekFwoHpBjaB6QaqgekHIoHpB5aB6QQKhekEfoXpBPKF6QVmhekF2oXpBk6F6QbGhekHOoXpB66F6QQiiekElonpBQqJ6QV+iekF8onpBmqJ6QbeiekHUonpB8aJ6QQ6jekEro3pBSKN6QWWjekGDo3pBoKN6Qb2jekHao3pB96N6QRSkekExpHpBTqR6QWukekGJpHpBpqR6QcOkekHgpHpB/aR6QRqlekE3pXpBVKV6QXGlekGPpXpBrKV6QcmlekHmpXpBA6Z6QSCmekE9pnpBWqZ6QXemekGVpnpBsqZ6Qc+mekHspnpBCad6QSanekFDp3pBYKd6QX2nekGap3pBuKd6QdWnekHyp3pBD6h6QSyoekFJqHpBZqh6QYOoekGgqHpBvah6QdqoekH4qHpBFal6QTKpekFPqXpBbKl6QYmpekGmqXpBw6l6QeCpekH9qXpBGqp6QTiqekFVqnpBcqp6QY+qekGsqnpByap6QeaqekEDq3pBIKt6QT2rekFaq3pBd6t6QZWrekGyq3pBz6t6QeyrekEJrHpBJqx6QUOsekFgrHpBfax6QZqsekG3rHpB1Kx6QfGsekEPrXpBLK16QUmtekFmrXpBg616QaCtekG9rXpB2q16QfetekEUrnpBMa56QU6uekFrrnpBiK56QaWuekHDrnpB4K56Qf2uekEar3pBN696QVSvekFxr3pBjq96QauvekHIr3pB5a96QQKwekEfsHpBPLB6QVmwekF2sHpBk7B6QbGwekHOsHpB67B6QQixekElsXpBQrF6QV+xekF8sXpBmbF6QbaxekHTsXpB8LF6QQ2yekEqsnpBR7J6QWSyekGBsnpBnrJ6QbuyekHYsnpB9bJ6QROzekEws3pBTbN6QWqzekGHs3pBpLN6QcGzekHes3pB+7N6QRi0ekE1tHpBUrR6QW+0ekGMtHpBqbR6Qca0ekHjtHpBALV6QR21ekE6tXpBV7V6QXS1ekGRtXpBrrV6Qcu1ekHotXpBBbZ6QSK2ekE/tnpBXLZ6QXm2ekGXtnpBtLZ6QdG2ekHutnpBC7d6QSi3ekFFt3pBYrd6QX+3ekGct3pBubd6Qda3ekHzt3pBELh6QS24ekFKuHpBZ7h6QYS4ekGhuHpBvrh6Qdu4ekH4uHpBFbl6QTK5ekFPuXpBbLl6QYm5ekGmuXpBw7l6QeC5ekH9uXpBGrp6QTe6ekFUunpBcbp6QY66ekGrunpByLp6QeW6ekECu3pBH7t6QTy7ekFZu3pBdrt6QZO7ekGwu3pBzbt6Qeq7ekEHvHpBJLx6QUG8ekFevHpBe7x6QZi8ekG1vHpB0rx6Qe+8ekEMvXpBKb16QUa9ekFjvXpBgL16QZ29ekG6vXpB1716QfS9ekERvnpBLr56QUu+ekFovnpBhb56QaK+ekG/vnpB3L56Qfm+ekEWv3pBM796QVC/ekFtv3pBir96Qae/ekHEv3pB4b96Qf6/ekEbwHpBOMB6QVXAekFywHpBj8B6QavAekHIwHpB5cB6QQLBekEfwXpBPMF6QVnBekF2wXpBk8F6QbDBekHNwXpB6sF6QQfCekEkwnpBQcJ6QV7CekF7wnpBmMJ6QbXCekHSwnpB78J6QQzDekEpw3pBRsN6QWPDekGAw3pBncN6QbrDekHXw3pB9MN6QRDEekEtxHpBSsR6QWfEekGExHpBocR6Qb7EekHbxHpB+MR6QRXFekEyxXpBT8V6QWzFekGJxXpBpsV6QcPFekHgxXpB/cV6QRrGekE3xnpBVMZ6QXDGekGNxnpBqsZ6QcfGekHkxnpBAcd6QR7HekE7x3pBWMd6QXXHekGSx3pBr8d6QczHekHpx3pBBsh6QSPIekFAyHpBXMh6QXnIekGWyHpBs8h6QdDIekHtyHpBCsl6QSfJekFEyXpBYcl6QX7JekGbyXpBuMl6QdXJekHyyXpBDsp6QSvKekFIynpBZcp6QYLKekGfynpBvMp6QdnKekH2ynpBE8t6QTDLekFNy3pBast6QYfLekGjy3pBwMt6Qd3LekH6y3pBF8x6QTTMekFRzHpBbsx6QYvMekGozHpBxcx6QeLMekH+zHpBG816QTjNekFVzXpBcs16QY/NekGszXpByc16QebNekEDznpBIM56QTzOekFZznpBds56QZPOekGwznpBzc56QerOekEHz3pBJM96QUHPekFez3pBes96QZfPekG0z3pB0c96Qe7PekEL0HpBKNB6QUXQekFi0HpBf9B6QZvQekG40HpB1dB6QfLQekEP0XpBLNF6QUnRekFm0XpBg9F6QZ/RekG80XpB2dF6QfbRekET0npBMNJ6QU3SekFq0npBh9J6QaPSekHA0npB3dJ6QfrSekEX03pBNNN6QVHTekFu03pBi9N6QafTekHE03pB4dN6Qf7TekEb1HpBONR6QVXUekFy1HpBjtR6QavUekHI1HpB5dR6QQLVekEf1XpBPNV6QVnVekF11XpBktV6Qa/VekHM1XpB6dV6QQbWekEj1npBQNZ6QVzWekF51npBltZ6QbPWekHQ1npB7dZ6QQrXekEn13pBQ9d6QWDXekF913pBmtd6QbfXekHU13pB8dd6QQ3YekEq2HpBR9h6QWTYekGB2HpBnth6QbvYekHX2HpB9Nh6QRHZekEu2XpBS9l6QWjZekGF2XpBodl6Qb7ZekHb2XpB+Nl6QRXaekEy2npBT9p6QWvaekGI2npBpdp6QcLaekHf2npB/Np6QRjbekE123pBUtt6QW/bekGM23pBqdt6QcbbekHi23pB/9t6QRzcekE53HpBVtx6QXPcekGP3HpBrNx6QcncekHm3HpBA916QSDdekE83XpBWd16QXbdekGT3XpBsN16Qc3dekHp3XpBBt56QSPeekFA3npBXd56QXreekGW3npBs956QdDeekHt3npBCt96QSffekFD33pBYN96QX3fekGa33pBt996QdPfekHw33pBDeB6QSrgekFH4HpBZOB6QYDgekGd4HpBuuB6QdfgekH04HpBEOF6QS3hekFK4XpBZ+F6QYThekGh4XpBveF6QdrhekH34XpBFOJ6QTHiekFN4npBauJ6QYfiekGk4npBweJ6Qd3iekH64npBF+N6QTTjekFR43pBbuN6QYrjekGn43pBxON6QeHjekH+43pBGuR6QTfkekFU5HpBceR6QY7kekGq5HpBx+R6QeTkekEB5XpBHuV6QTrlekFX5XpBdOV6QZHlekGt5XpByuV6QeflekEE5npBIeZ6QT3mekFa5npBd+Z6QZTmekGx5npBzeZ6QermekEH53pBJOd6QUHnekFd53pBeud6QZfnekG053pB0Od6Qe3nekEK6HpBJ+h6QUToekFg6HpBfeh6QZroekG36HpB1Oh6QfDoekEN6XpBKul6QUfpekFj6XpBgOl6QZ3pekG66XpB1ul6QfPpekEQ6npBLep6QUrqekFm6npBg+p6QaDqekG96npB2ep6QfbqekET63pBMOt6QU3rekFp63pBhut6QaPrekHA63pB3Ot6QfnrekEW7HpBM+x6QU/sekFs7HpBiex6QabsekHC7HpB3+x6QfzsekEZ7XpBNe16QVLtekFv7XpBjO16QajtekHF7XpB4u16Qf/tekEb7npBOO56QVXuekFy7npBj+56QavuekHI7npB5e56QQLvekEe73pBO+96QVjvekF073pBke96Qa7vekHL73pB5+96QQTwekEh8HpBPvB6QVrwekF38HpBlPB6QbHwekHN8HpB6vB6QQfxekEk8XpBQPF6QV3xekF68XpBl/F6QbPxekHQ8XpB7fF6QQryekEm8npBQ/J6QWDyekF88npBmfJ6QbbyekHT8npB7/J6QQzzekEp83pBRvN6QWLzekF/83pBnPN6QbjzekHV83pB8vN6QQ/0ekEr9HpBSPR6QWX0ekGC9HpBnvR6Qbv0ekHY9HpB9PR6QRH1ekEu9XpBS/V6QWf1ekGE9XpBofV6Qb31ekHa9XpB9/V6QRT2ekEw9npBTfZ6QWr2ekGG9npBo/Z6QcD2ekHd9npB+fZ6QRb3ekEz93pBT/d6QWz3ekGJ93pBpvd6QcL3ekHf93pB/Pd6QRj4ekE1+HpBUvh6QW74ekGL+HpBqPh6QcX4ekHh+HpB/vh6QRv5ekE3+XpBVPl6QXH5ekGN+XpBqvl6Qcf5ekHk+XpBAPp6QR36ekE6+npBVvp6QXP6ekGQ+npBrPp6Qcn6ekHm+npBAvt6QR/7ekE8+3pBWft6QXX7ekGS+3pBr/t6Qcv7ekHo+3pBBfx6QSH8ekE+/HpBW/x6QXf8ekGU/HpBsfx6Qc38ekHq/HpBB/16QSP9ekFA/XpBXf16QXr9ekGW/XpBs/16QdD9ekHs/XpBCf56QSb+ekFC/npBX/56QXz+ekGY/npBtf56QdL+ekHu/npBC/96QSj/ekFE/3pBYf96QX7/ekGa/3pBt/96QdT/ekHw/3pBDQB7QSoAe0FGAHtBYwB7QYAAe0GcAHtBuQB7QdYAe0HyAHtBDwF7QSwBe0FIAXtBZQF7QYIBe0GeAXtBuwF7QdgBe0H0AXtBEQJ7QS4Ce0FKAntBZwJ7QYMCe0GgAntBvQJ7QdkCe0H2AntBEwN7QS8De0FMA3tBaQN7QYUDe0GiA3tBvwN7QdsDe0H4A3tBFQR7QTEEe0FOBHtBawR7QYcEe0GkBHtBwAR7Qd0Ee0H6BHtBFgV7QTMFe0FQBXtBbAV7QYkFe0GmBXtBwgV7Qd8Fe0H8BXtBGAZ7QTUGe0FRBntBbgZ7QYsGe0GnBntBxAZ7QeEGe0H9BntBGgd7QTYHe0FTB3tBcAd7QYwHe0GpB3tBxgd7QeIHe0H/B3tBHAh7QTgIe0FVCHtBcQh7QY4Ie0GrCHtBxwh7QeQIe0EBCXtBHQl7QToJe0FWCXtBcwl7QZAJe0GsCXtByQl7QeUJe0ECCntBHwp7QTsKe0FYCntBdQp7QZEKe0GuCntBygp7QecKe0EEC3tBIAt7QT0Le0FZC3tBdgt7QZMLe0GvC3tBzAt7QegLe0EFDHtBIgx7QT4Me0FbDHtBeAx7QZQMe0GxDHtBzQx7QeoMe0EHDXtBIw17QUANe0FcDXtBeQ17QZYNe0GyDXtBzw17QesNe0EIDntBJQ57QUEOe0FeDntBeg57QZcOe0G0DntB0A57Qe0Oe0EJD3tBJg97QUMPe0FfD3tBfA97QZgPe0G1D3tB0Q97Qe4Pe0ELEHtBJxB7QUQQe0FgEHtBfRB7QZoQe0G2EHtB0xB7Qe8Qe0EMEXtBKBF7QUURe0FiEXtBfhF7QZsRe0G3EXtB1BF7QfERe0ENEntBKhJ7QUYSe0FjEntBfxJ7QZwSe0G5EntB1RJ7QfISe0EOE3tBKxN7QUcTe0FkE3tBgRN7QZ0Te0G6E3tB1hN7QfMTe0EPFHtBLBR7QUkUe0FlFHtBghR7QZ4Ue0G7FHtB1xR7QfQUe0ERFXtBLRV7QUoVe0FmFXtBgxV7QZ8Ve0G8FXtB2BV7QfUVe0ESFntBLhZ7QUsWe0FnFntBhBZ7QaAWe0G9FntB2hZ7QfYWe0ETF3tBLxd7QUwXe0FoF3tBhRd7QaEXe0G+F3tB2hd7QfcXe0EUGHtBMBh7QU0Ye0FpGHtBhhh7QaIYe0G/GHtB2xh7QfgYe0EVGXtBMRl7QU4Ze0FqGXtBhxl7QaMZe0HAGXtB3Bl7QfkZe0EVGntBMhp7QU4ae0FrGntBiBp7QaQae0HBGntB3Rp7Qfoae0EWG3tBMxt7QU8be0FsG3tBiBt7QaUbe0HBG3tB3ht7Qfobe0EXHHtBNBx7QVAce0FtHHtBiRx7QaYce0HCHHtB3xx7Qfsce0EYHXtBNB17QVEde0FtHXtBih17QaYde0HDHXtB3x17Qfwde0EYHntBNR57QVIee0FuHntBix57Qacee0HEHntB4B57Qf0ee0EZH3tBNh97QVIfe0FvH3tBix97Qagfe0HEH3tB4R97Qf0fe0EaIHtBNiB7QVMge0FvIHtBjCB7Qagge0HFIHtB4SB7Qf4ge0EaIXtBNyF7QVMhe0FwIXtBjCF7Qakhe0HFIXtB4iF7Qf4he0EbIntBNyJ7QVQie0FwIntBjSJ7Qakie0HGIntB4iJ7Qf8ie0EbI3tBOCN7QVQje0FxI3tBjSN7Qaoje0HGI3tB4yN7Qf8je0EcJHtBOCR7QVUke0FxJHtBjiR7Qaoke0HHJHtB4yR7QQAle0EcJXtBOSV7QVUle0FyJXtBjiV7Qasle0HHJXtB5CV7QQAme0EdJntBOSZ7QVYme0FyJntBjiZ7Qasme0HHJntB5CZ7QQAne0EdJ3tBOSd7QVYne0FyJ3tBjyd7Qasne0HIJ3tB5Cd7QQEoe0EdKHtBOih7QVYoe0FzKHtBjyh7Qasoe0HIKHtB5Ch7QQEpe0EdKXtBOil7QVYpe0FzKXtBjyl7Qawpe0HIKXtB5Sl7QQEqe0EeKntBOip7QVYqe0FzKntBjyp7Qawqe0HIKntB5Sp7QQEre0EeK3tBOit7QVcre0FzK3tBjyt7Qawre0HIK3tB5St7QQEse0EeLHtBOix7QVcse0FzLHtBkCx7Qawse0HILHtB5Sx7QQEte0EeLXtBOi17QVcte0FzLXtBkC17Qawte0HJLXtB5S17QQEue0EeLntBOi57QVcue0FzLntBkC57Qawue0HILntB5S57QQEve0EeL3tBOi97QVcve0FzL3tBkC97Qawve0HIL3tB5S97QQEwe0EeMHtBOjB7QVcwe0FzMHtBjzB7Qawwe0HIMHtB5TB7QQExe0EeMXtBOjF7QVYxe0FzMXtBjzF7Qawxe0HIMXtB5TF7QQEye0EdMntBOjJ7QVYye0FzMntBjzJ7Qawye0HIMntB5DJ7QQEze0EdM3tBOjN7QVYze0FyM3tBjzN7Qasze0HIM3tB5DN7QQE0e0EdNHtBOTR7QVY0e0FyNHtBjzR7Qas0e0HHNHtB5DR7QQA1e0EdNXtBOTV7QVY1e0FyNXtBjjV7Qas1e0HHNXtB5DV7QQA2e0EcNntBOTZ7QVU2e0FyNntBjjZ7Qao2e0HHNntB4zZ7QQA3e0EcN3tBODd7QVU3e0FxN3tBjjd7Qao3e0HGN3tB4zd7Qf83e0EcOHtBODh7QVQ4e0FxOHtBjTh7Qao4e0HGOHtB4jh7Qf84e0EbOXtBNzl7QVQ5e0FwOXtBjTl7Qak5e0HFOXtB4jl7Qf45e0EbOntBNzp7QVM6e0FwOntBjDp7Qag6e0HFOntB4Tp7Qf46e0EaO3tBNjt7QVM7e0FvO3tBjDt7Qag7e0HEO3tB4Tt7Qf07e0EZPHtBNjx7QVI8e0FvPHtBizx7Qac8e0HEPHtB4Dx7Qfw8e0EZPXtBNT17QVI9e0FuPXtBij17Qac9e0HDPXtB3z17Qfw9e0EYPntBND57QVE+e0FtPntBij57QaY+e0HCPntB3z57Qfs+e0EXP3tBND97QVA/e0FsP3tBiT97QaU/e0HCP3tB3j97Qfo/e0EXQHtBM0B7QU9Ae0FsQHtBiEB7QaRAe0HBQHtB3UB7QflAe0EWQXtBMkF7QU9Be0FrQXtBh0F7QaRBe0HAQXtB3EF7QflBe0EVQntBMUJ7QU5Ce0FqQntBhkJ7QaNCe0G/QntB20J7QfhCe0EUQ3tBMEN7QU1De0FpQ3tBhUN7QaJDe0G+Q3tB2kN7QfdDe0ETRHtBL0R7QUxEe0FoRHtBhER7QaFEe0G9RHtB2UR7QfZEe0ESRXtBLkV7QUtFe0FnRXtBg0V7QaBFe0G8RXtB2EV7QfVFe0ERRntBLUZ7QUpGe0FmRntBgkZ7QZ9Ge0G7RntB10Z7QfRGe0EQR3tBLEd7QUlHe0FlR3tBgUd7QZ5He0G6R3tB1kd7QfNHe0EPSHtBK0h7QUhIe0FkSHtBgEh7QZ1Ie0G5SHtB1Uh7QfFIe0EOSXtBKkl7QUZJe0FjSXtBf0l7QZtJe0G4SXtB1El7QfBJe0ENSntBKUp7QUVKe0FhSntBfkp7QZpKe0G2SntB00p7Qe9Ke0ELS3tBKEt7QURLe0FgS3tBfUt7QZlLe0G1S3tB0Ut7Qe5Le0EKTHtBJkx7QUNMe0FfTHtBe0x7QZhMe0G0THtB0Ex7QexMe0EJTXtBJU17QUFNe0FeTXtBek17QZZNe0GyTXtBz017QetNe0EHTntBJE57QUBOe0FcTntBeU57QZVOe0GxTntBzU57QepOe0EGT3tBIk97QT9Pe0FbT3tBd097QZNPe0GwT3tBzE97QehPe0EEUHtBIVB7QT1Qe0FZUHtBdlB7QZJQe0GuUHtBylB7QedQe0EDUXtBH1F7QTxRe0FYUXtBdFF7QZBRe0GtUXtByVF7QeVRe0EBUntBHlJ7QTpSe0FWUntBc1J7QY9Se0GrUntBx1J7QeRSe0EAU3tBHFN7QThTe0FVU3tBcVN7QY1Te0GpU3tBxlN7QeJTe0H+U3tBGlR7QTdUe0FTVHtBb1R7QYxUe0GoVHtBxFR7QeBUe0H9VHtBGVV7QTVVe0FRVXtBblV7QYpVe0GmVXtBwlV7Qd9Ve0H7VXtBF1Z7QTNWe0FQVntBbFZ7QYhWe0GkVntBwVZ7Qd1We0H5VntBFVd7QTJXe0FOV3tBald7QYZXe0GjV3tBv1d7QdtXe0H3V3tBFFh7QTBYe0FMWHtBaFh7QYVYe0GhWHtBvVh7QdlYe0H1WHtBEll7QS5Ze0FKWXtBZll7QYNZe0GfWXtBu1l7QddZe0H0WXtBEFp7QSxae0FIWntBZVp7QYFae0GdWntBuVp7QdVae0HyWntBDlt7QSpbe0FGW3tBY1t7QX9be0GbW3tBt1t7QdNbe0HwW3tBDFx7QShce0FEXHtBYVx7QX1ce0GZXHtBtVx7QdFce0HuXHtBCl17QSZde0FCXXtBX117QXtde0GXXXtBs117Qc9de0HsXXtBCF57QSRee0FAXntBXF57QXlee0GVXntBsV57Qc1ee0HqXntBBl97QSJfe0E+X3tBWl97QXdfe0GTX3tBr197Qctfe0HnX3tBBGB7QSBge0E8YHtBWGB7QXRge0GRYHtBrWB7Qclge0HlYHtBAWF7QR5he0E6YXtBVmF7QXJhe0GOYXtBq2F7Qcdhe0HjYXtB/2F7QRtie0E4YntBVGJ7QXBie0GMYntBqGJ7QcVie0HhYntB/WJ7QRlje0E1Y3tBUWN7QW5je0GKY3tBpmN7QcJje0HeY3tB+2N7QRdke0EzZHtBT2R7QWtke0GIZHtBpGR7QcBke0HcZHtB+GR7QRRle0ExZXtBTWV7QWlle0GFZXtBoWV7Qb1le0HaZXtB9mV7QRJme0EuZntBSmZ7QWdme0GDZntBn2Z7Qbtme0HXZntB82Z7QRBne0EsZ3tBSGd7QWRne0GAZ3tBnGd7Qblne0HVZ3tB8Wd7QQ1oe0EpaHtBRWh7QWJoe0F+aHtBmmh7QbZoe0HSaHtB7mh7QQtpe0EnaXtBQ2l7QV9pe0F7aXtBl2l7QbRpe0HQaXtB7Gl7QQhqe0EkantBQGp7QVxqe0F5antBlWp7QbFqe0HNantB6Wp7QQVre0Eia3tBPmt7QVpre0F2a3tBkmt7Qa5re0HKa3tB52t7QQNse0EfbHtBO2x7QVdse0FzbHtBj2x7Qaxse0HIbHtB5Gx7QQBte0EcbXtBOG17QVRte0FxbXtBjW17Qalte0HFbXtB4W17Qf1te0EZbntBNm57QVJue0FubntBim57QaZue0HCbntB3m57Qfpue0EXb3tBM297QU9ve0Frb3tBh297QaNve0G/b3tB3G97Qfhve0EUcHtBMHB7QUxwe0FocHtBhHB7QaBwe0G9cHtB2XB7QfVwe0ERcXtBLXF7QUlxe0FlcXtBgXF7QZ5xe0G6cXtB1nF7QfJxe0EOcntBKnJ7QUZye0FicntBfnJ7QZtye0G3cntB03J7Qe9ye0ELc3tBJ3N7QUNze0Ffc3tBe3N7QZhze0G0c3tB0HN7Qexze0EIdHtBJHR7QUB0e0FcdHtBeHR7QZV0e0GxdHtBzXR7Qel0e0EFdXtBIXV7QT11e0FZdXtBdXV7QZF1e0GudXtBynV7QeZ1e0ECdntBHnZ7QTp2e0FWdntBcnZ7QY52e0GqdntBx3Z7QeN2e0H/dntBG3d7QTd3e0FTd3tBb3d7QYt3e0Gnd3tBw3d7QeB3e0H8d3tBGHh7QTR4e0FQeHtBbHh7QYh4e0GkeHtBwHh7Qdx4e0H4eHtBFHl7QTF5e0FNeXtBaXl7QYV5e0GheXtBvXl7Qdl5e0H1eXtBEXp7QS16e0FJentBZXp7QYJ6e0GeentBunp7QdZ6e0HyentBDnt7QSp7e0FGe3tBYnt7QX57e0Gae3tBtnt7QdJ7e0Hue3tBC3x7QSd8e0FDfHtBX3x7QXt8e0GXfHtBs3x7Qc98e0HrfHtBB317QSN9e0E/fXtBW317QXd9e0GTfXtBsH17Qcx9e0HofXtBBH57QSB+e0E8fntBWH57QXR+e0GQfntBrH57Qch+e0HkfntBAH97QRx/e0E4f3tBVH97QXB/e0GNf3tBqX97QcV/e0Hhf3tB/X97QRmAe0E1gHtBUYB7QW2Ae0GJgHtBpYB7QcGAe0HdgHtB+YB7QRWBe0ExgXtBTYF7QWmBe0GFgXtBoYF7Qb6Be0HagXtB9oF7QRKCe0EugntBSoJ7QWaCe0GCgntBnoJ7QbqCe0HWgntB8oJ7QQ6De0Eqg3tBRoN7QWKDe0F+g3tBmoN7QbaDe0HSg3tB7oN7QQqEe0EmhHtBQoR7QV6Ee0F6hHtBloR7QbOEe0HPhHtB64R7QQeFe0EjhXtBP4V7QVuFe0F3hXtBk4V7Qa+Fe0HLhXtB54V7QQOGe0EfhntBO4Z7QVeGe0FzhntBj4Z7QauGe0HHhntB44Z7Qf+Ge0Ebh3tBN4d7QVOHe0Fvh3tBi4d7QaeHe0HDh3tB34d7QfuHe0EXiHtBM4h7QU+Ie0FriHtBh4h7QaOIe0G/iHtB24h7QfeIe0ETiXtBL4l7QUuJe0FniXtBg4l7QZ+Je0G7iXtB14l7QfOJe0EPintBK4p7QUeKe0FjintBf4p7QZuKe0G3intB04p7Qe+Ke0ELi3tBJ4t7QUOLe0Ffi3tBe4t7QZeLe0Gzi3tBz4t7QeuLe0EHjHtBI4x7QT+Me0FbjHtBd4x7QZOMe0GvjHtBy4x7QeeMe0EDjXtBH417QTuNe0FXjXtBc417QY+Ne0GrjXtBx417QeONe0H/jXtBG457QTeOe0FTjntBb457QYuOe0GnjntBw457Qd+Oe0H7jntBF497QTOPe0FPj3tBa497QYePe0Gjj3tBv497QduPe0H3j3tBE5B7QS+Qe0FLkHtBZ5B7QYOQe0GfkHtBu5B7QdeQe0HzkHtBD5F7QSqRe0FGkXtBYpF7QX6Re0GakXtBtpF7QdKRe0HukXtBCpJ7QSaSe0FCkntBXpJ7QXqSe0GWkntBspJ7Qc6Se0HqkntBBpN7QSKTe0E+k3tBWpN7QXaTe0GSk3tBrpN7QcqTe0Hmk3tBApR7QR2Ue0E5lHtBVZR7QXGUe0GNlHtBqZR7QcWUe0HhlHtB/ZR7QRmVe0E1lXtBUZV7QW2Ve0GJlXtBpZV7QcGVe0HdlXtB+ZV7QRWWe0ExlntBTZZ7QWiWe0GElntBoJZ7QbyWe0HYlntB9JZ7QRCXe0Esl3tBSJd7QWSXe0GAl3tBnJd7QbiXe0HUl3tB8Jd7QQyYe0EomHtBQ5h7QV+Ye0F7mHtBl5h7QbOYe0HPmHtB65h7QQeZe0EjmXtBP5l7QVuZe0F3mXtBk5l7Qa+Ze0HLmXtB5pl7QQKae0EemntBOpp7QVaae0FymntBjpp7Qaqae0HGmntB4pp7Qf6ae0Eam3tBNpt7QVGbe0Ftm3tBiZt7QaWbe0HBm3tB3Zt7Qfmbe0EVnHtBMZx7QU2ce0FpnHtBhZx7QaGce0G8nHtB2Jx7QfSce0EQnXtBLJ17QUide0FknXtBgJ17QZyde0G4nXtB1J17Qe+de0ELnntBJ557QUOee0FfnntBe557QZeee0GznntBz557Qeuee0EHn3tBIp97QT6fe0Fan3tBdp97QZKfe0Gun3tByp97Qeafe0ECoHtBHqB7QTmge0FVoHtBcaB7QY2ge0GpoHtBxaB7QeGge0H9oHtBGaF7QTWhe0FQoXtBbKF7QYihe0GkoXtBwKF7Qdyhe0H4oXtBFKJ7QTCie0FLontBZ6J7QYOie0GfontBu6J7Qdeie0HzontBD6N7QSuje0FGo3tBYqN7QX6je0Gao3tBtqN7QdKje0Huo3tBCqR7QSake0FBpHtBXaR7QXmke0GVpHtBsaR7Qc2ke0HppHtBBaV7QSCle0E8pXtBWKV7QXSle0GQpXtBrKV7Qcile0HkpXtB/6V7QRume0E3pntBU6Z7QW+me0GLpntBp6Z7QcOme0HepntB+qZ7QRane0Eyp3tBTqd7QWqne0GGp3tBoad7Qb2ne0HZp3tB9ad7QRGoe0EtqHtBSah7QWSoe0GAqHtBnKh7Qbioe0HUqHtB8Kh7QQype0EnqXtBQ6l7QV+pe0F7qXtBl6l7QbOpe0HPqXtB6ql7QQaqe0EiqntBPqp7QVqqe0F2qntBkqp7Qa2qe0HJqntB5ap7QQGre0Edq3tBOat7QVWre0Fwq3tBjKt7Qaire0HEq3tB4Kt7Qfyre0EXrHtBM6x7QU+se0FrrHtBh6x7QaOse0G+rHtB2qx7Qfase0ESrXtBLq17QUqte0FmrXtBga17QZ2te0G5rXtB1a17QfGte0ENrntBKK57QUSue0FgrntBfK57QZiue0G0rntBz657Qeuue0EHr3tBI697QT+ve0Far3tBdq97QZKve0Gur3tByq97Qeave0EBsHtBHbB7QTmwe0FVsHtBcbB7QY2we0GosHtBxLB7QeCwe0H8sHtBGLF7QTOxe0FPsXtBa7F7QYexe0GjsXtBv7F7Qdqxe0H2sXtBErJ7QS6ye0FKsntBZbJ7QYGye0GdsntBubJ7QdWye0HxsntBDLN7QSize0FEs3tBYLN7QXyze0GXs3tBs7N7Qc+ze0Hrs3tBB7R7QSK0e0E+tHtBWrR7QXa0e0GStHtBrbR7Qcm0e0HltHtBAbV7QR21e0E4tXtBVLV7QXC1e0GMtXtBqLV7QcO1e0HftXtB+7V7QRe2e0EztntBTrZ7QWq2e0GGtntBorZ7Qb62e0HZtntB9bZ7QRG3e0Ett3tBSbd7QWS3e0GAt3tBnLd7Qbi3e0HUt3tB77d7QQu4e0EnuHtBQ7h7QV64e0F6uHtBlrh7QbK4e0HOuHtB6bh7QQW5e0EhuXtBPbl7QVi5e0F0uXtBkLl7Qay5e0HIuXtB47l7Qf+5e0EbuntBN7p7QVK6e0FuuntBirp7Qaa6e0HCuntB3bp7Qfm6e0EVu3tBMbt7QUy7e0Fou3tBhLt7QaC7e0G8u3tB17t7QfO7e0EPvHtBK7x7QUa8e0FivHtBfrx7QZq8e0G1vHtB0bx7Qe28e0EJvXtBJb17QUC9e0FcvXtBeL17QZS9e0GvvXtBy717Qee9e0EDvntBHr57QTq+e0FWvntBcr57QY2+e0GpvntBxb57QeG+e0H8vntBGL97QTS/e0FQv3tBa797QYe/e0Gjv3tBv797Qdq/e0H2v3tBEsB7QS7Ae0FJwHtBZcB7QYHAe0GdwHtBuMB7QdTAe0HwwHtBDMF7QSfBe0FDwXtBX8F7QXvBe0GWwXtBssF7Qc7Be0HqwXtBBcJ7QSHCe0E9wntBWcJ7QXTCe0GQwntBrMJ7QcfCe0HjwntB/8J7QRvDe0E2w3tBUsN7QW7De0GKw3tBpcN7QcHDe0Hdw3tB+cN7QRTEe0EwxHtBTMR7QWfEe0GDxHtBn8R7QbvEe0HWxHtB8sR7QQ7Fe0EqxXtBRcV7QWHFe0F9xXtBmMV7QbTFe0HQxXtB7MV7QQfGe0EjxntBP8Z7QVvGe0F2xntBksZ7Qa7Ge0HJxntB5cZ7QQHHe0Edx3tBOMd7QVTHe0Fwx3tBi8d7QafHe0HDx3tB38d7QfrHe0EWyHtBMsh7QU3Ie0FpyHtBhch7QaHIe0G8yHtB2Mh7QfTIe0EPyXtBK8l7QUfJe0FiyXtBfsl7QZrJe0G2yXtB0cl7Qe3Je0EJyntBJMp7QUDKe0FcyntBeMp7QZPKe0GvyntBy8p7QebKe0ECy3tBHst7QTnLe0FVy3tBcct7QYzLe0Goy3tBxMt7QeDLe0H7y3tBF8x7QTPMe0FOzHtBasx7QYbMe0GhzHtBvcx7QdnMe0H0zHtBEM17QSzNe0FIzXtBY817QX/Ne0GbzXtBts17QdLNe0HuzXtBCc57QSXOe0FBzntBXM57QXjOe0GUzntBr857QcvOe0HnzntBAs97QR7Pe0E6z3tBVs97QXHPe0GNz3tBqc97QcTPe0Hgz3tB/M97QRfQe0Ez0HtBT9B7QWrQe0GG0HtBotB7Qb3Qe0HZ0HtB9dB7QRDRe0Es0XtBSNF7QWPRe0F/0XtBm9F7QbbRe0HS0XtB7tF7QQnSe0El0ntBQdJ7QVzSe0F40ntBlNJ7Qa/Se0HL0ntB59J7QQLTe0Ee03tBOtN7QVXTe0Fx03tBjdN7QajTe0HE03tB4NN7QfvTe0EX1HtBMtR7QU7Ue0Fq1HtBhdR7QaHUe0G91HtB2NR7QfTUe0EQ1XtBK9V7QUfVe0Fj1XtBftV7QZrVe0G21XtB0dV7Qe3Ve0EJ1ntBJNZ7QUDWe0Fb1ntBd9Z7QZPWe0Gu1ntBytZ7QebWe0EB13tBHdd7QTnXe0FU13tBcNd7QYzXe0Gn13tBw9d7Qd7Xe0H613tBFth7QTHYe0FN2HtBadh7QYTYe0Gg2HtBvNh7QdfYe0Hz2HtBDtl7QSrZe0FG2XtBYdl7QX3Ze0GZ2XtBtNl7QdDZe0Hr2XtBB9p7QSPae0E+2ntBWtp7QXbae0GR2ntBrdp7Qcjae0Hk2ntBANt7QRvbe0E323tBU9t7QW7be0GK23tBpdt7QcHbe0Hd23tB+Nt7QRTce0Ew3HtBS9x7QWfce0GC3HtBntx7Qbrce0HV3HtB8dx7QQzde0Eo3XtBRN17QV/de0F73XtBl917QbLde0HO3XtB6d17QQXee0Eh3ntBPN57QVjee0Fz3ntBj957Qavee0HG3ntB4t57Qf3ee0EZ33tBNd97QVDfe0Fs33tBh997QaPfe0G/33tB2t97Qfbfe0ER4HtBLeB7QUnge0Fk4HtBgOB7QZvge0G34HtB0+B7Qe7ge0EK4XtBJeF7QUHhe0Fd4XtBeOF7QZThe0Gv4XtBy+F7Qefhe0EC4ntBHuJ7QTnie0FV4ntBceJ7QYzie0Go4ntBw+J7Qd/ie0H64ntBFuN7QTLje0FN43tBaeN7QYTje0Gg43tBvON7Qdfje0Hz43tBDuR7QSrke0FF5HtBYeR7QX3ke0GY5HtBtOR7Qc/ke0Hr5HtBB+V7QSLle0E+5XtBWeV7QXXle0GQ5XtBrOV7Qcjle0Hj5XtB/+V7QRrme0E25ntBUeZ7QW3me0GJ5ntBpOZ7QcDme0Hb5ntB9+Z7QRLne0Eu53tBSed7QWXne0GB53tBnOd7Qbjne0HT53tB7+d7QQroe0Em6HtBQuh7QV3oe0F56HtBlOh7QbDoe0HL6HtB5+h7QQLpe0Ee6XtBOul7QVXpe0Fx6XtBjOl7Qajpe0HD6XtB3+l7Qfrpe0EW6ntBMup7QU3qe0Fp6ntBhOp7QaDqe0G76ntB1+p7QfLqe0EO63tBKut7QUXre0Fh63tBfOt7QZjre0Gz63tBz+t7Qerre0EG7HtBIex7QT3se0FZ7HtBdOx7QZDse0Gr7HtBx+x7QeLse0H+7HtBGe17QTXte0FQ7XtBbO17QYfte0Gj7XtBv+17Qdrte0H27XtBEe57QS3ue0FI7ntBZO57QX/ue0Gb7ntBtu57QdLue0Ht7ntBCe97QSTve0FA73tBXO97QXfve0GT73tBru97Qcrve0Hl73tBAfB7QRzwe0E48HtBU/B7QW/we0GK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UHxBn1B8QbpQfEHVUHxB8FB8QQtRfEEmUXxBQVF8QV1RfEF4UXxBk1F8Qa5RfEHJUXxB5FF8Qf9RfEEaUnxBNVJ8QVBSfEFrUnxBhlJ8QaFSfEG8UnxB2FJ8QfNSfEEOU3xBKVN8QURTfEFfU3xBelN8QZVTfEGwU3xBy1N8QeZTfEEBVHxBHFR8QTdUfEFSVHxBblR8QYlUfEGkVHxBv1R8QdpUfEH1VHxBEFV8QStVfEFGVXxBYVV8QXxVfEGXVXxBslV8Qc1VfEHoVXxBA1Z8QR5WfEE6VnxBVVZ8QXBWfEGLVnxBplZ8QcFWfEHcVnxB91Z8QRJXfEEtV3xBSFd8QWNXfEF+V3xBmVd8QbRXfEHPV3xB6ld8QQVYfEEgWHxBO1h8QVZYfEFyWHxBjVh8QahYfEHDWHxB3lh8QflYfEEUWXxBL1l8QUpZfEFlWXxBgFl8QZtZfEG2WXxB0Vl8QexZfEEHWnxBIlp8QT1afEFYWnxBc1p8QY5afEGpWnxBxFp8Qd9afEH6WnxBFVt8QTBbfEFLW3xBZ1t8QYJbfEGdW3xBuFt8QdNbfEHuW3xBCVx8QSRcfEE/XHxBWlx8QXVcfEGQXHxBq1x8QcZcfEHhXHxB/Fx8QRddfEEyXXxBTV18QWhdfEGDXXxBnl18QbldfEHUXXxB7118QQpefEElXnxBQF58QVtefEF2XnxBkV58QaxefEHHXnxB4l58Qf1efEEYX3xBM198QU5ffEFpX3xBhF98QZ9ffEG6X3xB1V98QfBffEELYHxBJmB8QUFgfEFcYHxBd2B8QZJgfEGtYHxByGB8QeNgfEH+YHxBGWF8QTRhfEFPYXxBamF8QYVhfEGgYXxBu2F8QdZhfEHxYXxBDGJ8QSdifEFCYnxBXWJ8QXhifEGTYnxBrmJ8QclifEHkYnxB/2J8QRpjfEE1Y3xBUGN8QWtjfEGGY3xBoWN8QbxjfEHXY3xB8mN8QQ1kfEEoZHxBQ2R8QV5kfEF5ZHxBlGR8Qa9kfEHKZHxB5WR8QQBlfEEbZXxBNmV8QVFlfEFsZXxBh2V8QaJlfEG9ZXxB2GV8QfNlfEEOZnxBKWZ8QURmfEFfZnxBemZ8QZVmfEGwZnxBy2Z8QeZmfEEBZ3xBHGd8QTdnfEFSZ3xBbWd8QYhnfEGjZ3xBvmd8QdlnfEH0Z3xBD2h8QSpofEFF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l3xBmJd8QbKXfEHNl3xB6Jd8QQOYfEEdmHxBOJh8QVOYfEFumHxBiJh8QaOYfEG+mHxB2Zh8QfOYfEEOmXxBKZl8QUSZfEFemXxBeZl8QZSZfEGvmXxByZl8QeSZfEH/mXxBGpp8QTSafEFPmnxBapp8QYWafEGfmnxBupp8QdWafEHvmnxBCpt8QSWbfEFAm3xBWpt8QXWbfEGQm3xBq5t8QcWbfEHgm3xB+5t8QRacfEEwnHxBS5x8QWacfEGBnHxBm5x8QbacfEHRnHxB65x8QQadfEEhnXxBPJ18QVadfEFxnXxBjJ18QaedfEHBnXxB3J18QfedfEERnnxBLJ58QUeefEFinnxBfJ58QZeefEGynnxBzZ58QeeefEECn3xBHZ98QTeffEFSn3xBbZ98QYiffEGin3xBvZ98QdiffEHyn3xBDaB8QSigfEFDoHxBXaB8QXigfEGToHxBraB8QcigfEHjoHxB/qB8QRihfEEzoXxBTqF8QWihfEGDoXxBnqF8QbmhfEHToXxB7qF8QQmifEEjonxBPqJ8QVmifEF0onxBjqJ8QamifEHEonxB3qJ8QfmifEEUo3xBL6N8QUmjfEFko3xBf6N8QZmjfEG0o3xBz6N8QemjfEEEpHxBH6R8QTqkfEFUpHxBb6R8QYqkfEGkpHxBv6R8QdqkfEH0pHxBD6V8QSqlfEFEpXxBX6V8QXqlfEGVpXxBr6V8QcqlfEHlpXxB/6V8QRqmfEE1pnxBT6Z8QWqmfEGFpnxBn6Z8QbqmfEHVpnxB8KZ8QQqnfEElp3xBQKd8QVqnfEF1p3xBkKd8QaqnfEHFp3xB4Kd8QfqnfEEVqHxBMKh8QUqofEFlqHxBgKh8QZqofEG1qHxB0Kh8QeqofEEFqXxBIKl8QTqpfEFVqXxBcKl8QYupfEGlqXxBwKl8QdupfEH1qXxBEKp8QSuqfEFFqnxBYKp8QXuqfEGVqnxBsKp8QcuqfEHlqnxBAKt8QRurfEE1q3xBUKt8QWurfEGFq3xBoKt8QburfEHVq3xB8Kt8QQusfEElrHxBQKx8QVusfEF1rHxBkKx8QausfEHFrHxB4Kx8QfqsfEEVrXxBMK18QUqtfEFlrXxBgK18QZqtfEG1rXxB0K18QeqtfEEFrnxBIK58QTqufEFVrnxBcK58QYqufEGlrnxBwK58QdqufEH1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3XxBuN18QdPdfEHt3XxBCN58QSLefEE93nxBV958QXLefEGM3nxBpt58QcHefEHb3nxB9t58QRDffEEr33xBRd98QV/ffEF633xBlN98Qa/ffEHJ33xB5N98Qf7ffEEY4HxBM+B8QU3gfEFo4HxBguB8QZ3gfEG34HxB0eB8QezgfEEG4XxBIeF8QTvhfEFW4XxBcOF8QYrhfEGl4XxBv+F8QdrhfEH04XxBD+J8QSnifEFD4nxBXuJ8QXjifEGT4nxBreJ8QcfifEHi4nxB/OJ8QRfjfEEx43xBTON8QWbjfEGA43xBm+N8QbXjfEHQ43xB6uN8QQTkfEEf5HxBOeR8QVTkfEFu5HxBieR8QaPkfEG95HxB2OR8QfLkfEEN5XxBJ+V8QUHlfEFc5XxBduV8QZHlfEGr5XxBxeV8QeDlfEH65XxBFeZ8QS/mfEFJ5nxBZOZ8QX7mfEGZ5nxBs+Z8Qc3mfEHo5nxBAud8QR3nfEE353xBUed8QWznfEGG53xBoed8QbvnfEHV53xB8Od8QQrofEEl6HxBP+h8QVnofEF06HxBjuh8QanofEHD6HxB3eh8QfjofEES6XxBLOl8QUfpfEFh6XxBfOl8QZbpfEGw6XxBy+l8QeXpfEEA6nxBGup8QTTqfEFP6nxBaep8QYPqfEGe6nxBuOp8QdPqfEHt6nxBB+t8QSLrfEE863xBV+t8QXHrfEGL63xBput8QcDrfEHa63xB9et8QQ/sfEEq7HxBROx8QV7sfEF57HxBk+x8Qa3sfEHI7HxB4ux8Qf3sfEEX7XxBMe18QUztfEFm7XxBgO18QZvtfEG17XxBz+18QertfEEE7nxBH+58QTnufEFT7nxBbu58QYjufEGi7nxBve58QdfufEHx7nxBDO98QSbvfEFB73xBW+98QXXvfEGQ73xBqu98QcTvfEHf73xB+e98QRPwfEEu8HxBSPB8QWPwfEF98HxBl/B8QbLwfEHM8HxB5vB8QQHxfEEb8XxBNfF8QVDxfEFq8XxBhPF8QZ/xfEG58XxB0/F8Qe7xfEEI8nxBI/J8QT3yfEFX8nxBcvJ8QYzyfEGm8nxBwfJ8QdvyfEH18nxBEPN8QSrzfEFE83xBX/N8QXnzfEGT83xBrvN8QcjzfEHi83xB/fN8QRf0fEEx9HxBTPR8QWb0fEGA9HxBm/R8QbX0fEHP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UH1ByVB9QeJQfUH8UH1BFlF9QTBRfUFKUX1BZFF9QX5RfUGYUX1BslF9QcxRfUHmUX1BAFJ9QRpSfUE0Un1BTVJ9QWdSfUGBUn1Bm1J9QbVSfUHPUn1B6VJ9QQNTfUEdU31BN1N9QVFTfUFrU31BhFN9QZ5TfUG4U31B0lN9QexTfUEGVH1BIFR9QTpUfUFUVH1BblR9QYhUfUGiVH1Bu1R9QdVUfUHvVH1BCVV9QSNVfUE9VX1BV1V9QXFVfUGLVX1BpVV9Qb9VfUHYVX1B8lV9QQxWfUEmVn1BQFZ9QVpWfUF0Vn1BjlZ9QahWfUHCVn1B3FZ9QfVWfUEPV31BKVd9QUNXfUFdV31Bd1d9QZFXfUGrV31BxVd9Qd9XfUH4V31BElh9QSxYfUFGWH1BYFh9QXpYfUGUWH1Brlh9QchYfUHiWH1B+1h9QRVZfUEvWX1BSVl9QWNZfUF9WX1Bl1l9QbFZfUHLWX1B5Fl9Qf5ZfUEYWn1BMlp9QUxafUFmWn1BgFp9QZpafUG0Wn1BzVp9QedafUEBW31BG1t9QTVbfUFPW31BaVt9QYNbfUGcW31Btlt9QdBbfUHqW31BBFx9QR5cfUE4XH1BUlx9QWxcfUGFXH1Bn1x9QblcfUHTXH1B7Vx9QQddfUEhXX1BO119QVRdfUFuXX1BiF19QaJdfUG8XX1B1l19QfBdfUEKXn1BI159QT1efUFXXn1BcV59QYtefUGlXn1Bv159QdlefUHyXn1BDF99QSZffUFAX31BWl99QXRffUGOX31Bp199QcFffUHbX31B9V99QQ9gfUEpYH1BQ2B9QVxgfUF2YH1BkGB9QapgfUHEYH1B3mB9QfhgfUERYX1BK2F9QUVhfUFfYX1BeWF9QZNhfUGtYX1BxmF9QeBhfUH6YX1BFGJ9QS5ifUFIYn1BYmJ9QXtifUGVYn1Br2J9QclifUHjYn1B/WJ9QRdjfUEwY31BSmN9QWRjfUF+Y31BmGN9QbJjfUHMY31B5WN9Qf9jfUEZZH1BM2R9QU1kfUFnZH1BgGR9QZpkfUG0ZH1BzmR9QehkfUECZX1BG2V9QTVlfUFPZX1BaWV9QYNlfUGdZX1Bt2V9QdBlfUHqZX1BBGZ9QR5mfUE4Zn1BUmZ9QWtmfUGFZn1Bn2Z9QblmfUHTZn1B7WZ9QQZnfUEgZ31BOmd9QVRnfUFu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lH1Bw5R9QdyUfUH2lH1BEJV9QSmVfUFDlX1BXZV9QXaVfUGQlX1BqZV9QcOVfUHdlX1B9pV9QRCWfUEqln1BQ5Z9QV2WfUF2ln1BkJZ9QaqWfUHDln1B3ZZ9QfeWfUEQl31BKpd9QUOXfUFdl31Bd5d9QZCXfUGql31BxJd9Qd2XfUH3l31BEJh9QSqYfUFEmH1BXZh9QXeYfUGQmH1Bqph9QcSYfUHdmH1B95h9QRGZfUEqmX1BRJl9QV2ZfUF3mX1BkZl9QaqZfUHEmX1B3Zl9QfeZfUERmn1BKpp9QUSafUFemn1Bd5p9QZGafUGqmn1BxJp9Qd6afUH3mn1BEZt9QSqbfUFEm31BXpt9QXebfUGRm31Bqpt9QcSbfUHem31B95t9QRGcfUEqnH1BRJx9QV6cfUF3nH1BkZx9QaqcfUHEnH1B3px9QfecfUERnX1BKp19QUSdfUFenX1Bd519QZGdfUGqnX1BxJ19Qd6dfUH3nX1BEZ59QSqefUFEnn1BXp59QXeefUGRnn1Bqp59QcSefUHdnn1B9559QRGffUEqn31BRJ99QV2ffUF3n31BkZ99QaqffUHEn31B3Z99QfeffUERoH1BKqB9QUSgfUFdoH1Bd6B9QZCgfUGqoH1BxKB9Qd2gfUH3oH1BEKF9QSqhfUFEoX1BXaF9QXehfUGQoX1BqqF9QcOhfUHdoX1B96F9QRCifUEqon1BQ6J9QV2ifUF2on1BkKJ9QaqifUHDon1B3aJ9QfaifUEQo31BKaN9QUOjfUFdo31BdqN9QZCjfUGpo31Bw6N9QdyjfUH2o31BEKR9QSmkfUFDpH1BXKR9QXakfUGPpH1BqaR9QcOkfUHcpH1B9qR9QQ+lfUEppX1BQqV9QVylfUF1pX1Bj6V9QamlfUHCpX1B3KV9QfWlfUEPpn1BKKZ9QUKmfUFbpn1BdaZ9QY+mfUGopn1BwqZ9QdumfUH1pn1BDqd9QSinfUFBp31BW6d9QXWnfUGOp31BqKd9QcGnfUHbp31B9Kd9QQ6ofUEnqH1BQah9QVuofUF0qH1Bjqh9QaeofUHBqH1B2qh9QfSofUENqX1BJ6l9QUCpfUFaqX1BdKl9QY2pfUGnqX1BwKl9QdqpfUHzqX1BDap9QSaqfUFAqn1BWap9QXOqfUGMqn1Bpqp9QcCqfUHZqn1B86p9QQyrfUEm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131B99d9QRDYfUEq2H1BQ9h9QVzYfUF22H1Bj9h9QajYfUHC2H1B29h9QfTYfUEO2X1BJ9l9QUDZfUFa2X1Bc9l9QYzZfUGm2X1Bv9l9QdjZfUHy2X1BC9p9QSTafUE+2n1BV9p9QXDafUGK2n1Bo9p9QbzafUHW2n1B79p9QQjbfUEi231BO9t9QVTbfUFu231Bh9t9QaDbfUG6231B09t9QezbfUEG3H1BH9x9QTjcfUFS3H1Ba9x9QYTcfUGe3H1Bt9x9QdDcfUHq3H1BA919QRzdfUE23X1BT919QWjdfUGC3X1Bm919QbTdfUHO3X1B5919QQDefUEZ3n1BM959QUzefUFl3n1Bf959QZjefUGx3n1By959QeTefUH93n1BF999QTDffUFJ331BY999QXzffUGV331Br999QcjffUHh331B+t99QRTgfUEt4H1BRuB9QWDgfUF54H1BkuB9QazgfUHF4H1B3uB9QfjgfUER4X1BKuF9QUPhfUFd4X1BduF9QY/hfUGp4X1BwuF9QdvhfUH14X1BDuJ9QSfifUFA4n1BWuJ9QXPifUGM4n1BpuJ9Qb/ifUHY4n1B8uJ9QQvjfUEk431BPeN9QVfjfUFw431BieN9QaPjfUG8431B1eN9Qe7jfUEI5H1BIeR9QTrkfUFU5H1BbeR9QYbkfUGf5H1BueR9QdLkfUHr5H1BBeV9QR7lfUE35X1BUeV9QWrlfUGD5X1BnOV9QbblfUHP5X1B6OV9QQLmfUEb5n1BNOZ9QU3mfUFn5n1BgOZ9QZnmfUGy5n1BzOZ9QeXmfUH+5n1BGOd9QTHnfUFK531BY+d9QX3nfUGW531Br+d9QcnnfUHi531B++d9QRTofUEu6H1BR+h9QWDofUF56H1Bk+h9QazofUHF6H1B3+h9QfjofUER6X1BKul9QUTpfUFd6X1Bdul9QY/pfUGp6X1Bwul9QdvpfUH16X1BDup9QSfqfUFA6n1BWup9QXPqfUGM6n1Bpep9Qb/qfUHY6n1B8ep9QQrrfUEk631BPet9QVbrfUFv631Biet9QaLrfUG7631B1Ot9Qe7rfUEH7H1BIOx9QTrsfUFT7H1BbOx9QYXsfUGf7H1BuOx9QdHsfUHq7H1BBO19QR3tfUE27X1BT+19QWntfUGC7X1Bm+19QbTtfUHO7X1B5+19QQDufUEZ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Gn5Bahp+QYMafkGcGn5BtRp+Qc4afkHnGn5BABt+QRkbfkEyG35BSxt+QWQbfkF9G35Blxt+QbAbfkHJG35B4ht+QfsbfkEUHH5BLRx+QUYcfkFfHH5BeBx+QZEcfkGqHH5Bwxx+QdwcfkH1HH5BDh1+QScdfkFAHX5BWR1+QXIdfkGMHX5BpR1+Qb4dfkHXHX5B8B1+QQkefkEiHn5BOx5+QVQefkFtHn5Bhh5+QZ8efkG4Hn5B0R5+QeoefkEDH35BHB9+QTUffkFOH35BZx9+QYAffkGZH35Bsh9+QcwffkHlH35B/h9+QRcgfkEwIH5BSSB+QWIgfkF7IH5BlCB+Qa0gfkHGIH5B3yB+QfggfkERIX5BKiF+QUMhfkFcIX5BdSF+QY4hfkGnIX5BwCF+QdkhfkHyIX5BCyJ+QSQifkE9In5BViJ+QW8ifkGIIn5BoSJ+QboifkHTIn5B7CJ+QQYjfkEfI35BOCN+QVEjfkFqI35BgyN+QZwjfkG1I35BziN+QecjfkEAJH5BGSR+QTIkfkFLJH5BZCR+QX0kfkGWJH5BryR+QcgkfkHhJH5B+iR+QRMlfkEsJX5BRSV+QV4lfkF3JX5BkCV+QaklfkHCJX5B2yV+QfQlfkENJn5BJiZ+QT8mfkFYJn5BcSZ+QYomfkGjJn5BvCZ+QdUmfkHuJn5BByd+QSAnfkE5J35BUid+QWsnfkGEJ35BnSd+QbYnfkHPJ35B6Cd+QQEofkEaKH5BMyh+QUwofkFlKH5Bfih+QZcofkGwKH5BySh+QeIofkH7KH5BFCl+QS0pfkFGKX5BXyl+QXgpfkGRKX5Bqil+QcMpfkHcKX5B9Sl+QQ4qfkEnKn5BQCp+QVkqfkFyKn5Biyp+QaQqfkG9Kn5B1ip+Qe8qfkEIK35BISt+QTorfkFTK35BbCt+QYUrfkGeK35Btyt+QdArfkHpK35BAix+QRssfkE0LH5BTSx+QWYsfkF/LH5BmCx+QbEsfkHKLH5B4yx+QfwsfkEVLX5BLi1+QUctfkFgLX5BeS1+QZItfkGrLX5BxC1+Qd0tfkH2LX5BDy5+QSgufkFALn5BWS5+QXIufkGLLn5BpC5+Qb0ufkHWLn5B7y5+QQgvfkEhL35BOi9+QVMvfkFsL35BhS9+QZ4vfkG3L35B0C9+QekvfkECMH5BGzB+QTQwfkFNMH5BZjB+QX8wfkGYMH5BsTB+QcowfkHjMH5B/DB+QRUxfkEuMX5BRzF+QWAxfkF4MX5BkTF+QaoxfkHDMX5B3DF+QfUxfkEOMn5BJzJ+QUAyfkFZMn5BcjJ+QYsyfkGkMn5BvTJ+QdYyfkHvMn5BCDN+QSEzfkE6M35BUzN+QWwzfkGFM35BnjN+QbczfkHPM35B6DN+QQE0fkEaNH5BMzR+QUw0fkFlNH5BfjR+QZc0fkGwNH5ByTR+QeI0fkH7NH5BFDV+QS01fkFGNX5BXzV+QXg1fkGRNX5BqTV+QcI1fkHbNX5B9DV+QQ02fkEmNn5BPzZ+QVg2fkFxNn5BijZ+QaM2fkG8Nn5B1TZ+Qe42fkEHN35BIDd+QTk3fkFRN35Bajd+QYM3fkGcN35BtTd+Qc43fkHnN35BADh+QRk4fkEyOH5BSzh+QWQ4fkF9OH5Bljh+Qa84fkHIOH5B4Dh+Qfk4fkESOX5BKzl+QUQ5fkFdOX5Bdjl+QY85fkGoOX5BwTl+Qdo5fkHzOX5BDDp+QSU6fkE9On5BVjp+QW86fkGIOn5BoTp+Qbo6fkHTOn5B7Dp+QQU7fkEeO35BNzt+QVA7fkFpO35BgTt+QZo7fkGzO35BzDt+QeU7fkH+O35BFzx+QTA8fkFJPH5BYjx+QXs8fkGUPH5BrDx+QcU8fkHePH5B9zx+QRA9fkEpPX5BQj1+QVs9fkF0PX5BjT1+QaY9fkG+PX5B1z1+QfA9fkEJPn5BIj5+QTs+fkFUPn5BbT5+QYY+fkGfPn5BuD5+QdA+fkHpPn5BAj9+QRs/fkE0P35BTT9+QWY/fkF/P35BmD9+QbE/fkHKP35B4j9+Qfs/fkEUQH5BLUB+QUZAfkFfQH5BeEB+QZFAfkGqQH5Bw0B+QdtAfkH0QH5BDUF+QSZBfkE/QX5BWEF+QXFBfkGKQX5Bo0F+QbtBfkHUQX5B7UF+QQZCfkEfQn5BOEJ+QVFCfkFqQn5Bg0J+QZxCfkG0Qn5BzUJ+QeZCfkH/Qn5BGEN+QTFDfkFKQ35BY0N+QXtDfkGUQ35BrUN+QcZDfkHfQ35B+EN+QRFEfkEqRH5BQ0R+QVtEfkF0RH5BjUR+QaZEfkG/RH5B2ER+QfFEfkEKRX5BI0V+QTtFfkFURX5BbUV+QYZFfkGfRX5BuEV+QdFFfkHqRX5BAkZ+QRtGfkE0Rn5BTUZ+QWZGfkF/Rn5BmEZ+QbFGfkHJRn5B4kZ+QftGfkEUR35BLUd+QUZHfkFfR35BeEd+QZBHfkGpR35Bwkd+QdtHfkH0R35BDUh+QSZIfkE+SH5BV0h+QXBIfkGJSH5Bokh+QbtIfkHUSH5B7Uh+QQVJfkEeSX5BN0l+QVBJfkFpSX5Bgkl+QZtJfkGzSX5BzEl+QeVJfkH+SX5BF0p+QTBKfkFJSn5BYUp+QXpKfkGTSn5BrEp+QcVKfkHeSn5B90p+QQ9LfkEoS35BQUt+QVpLfkFzS35BjEt+QaVLfkG9S35B1kt+Qe9LfkEITH5BIUx+QTpMfkFSTH5Ba0x+QYRMfkGdTH5Btkx+Qc9MfkHoTH5BAE1+QRlNfkEyTX5BS01+QWRNfkF9TX5BlU1+Qa5NfkHHTX5B4E1+QflNfkESTn5BK05+QUNOfkFcTn5BdU5+QY5OfkGnTn5BwE5+QdhOfkHxTn5BCk9+QSNPfkE8T35BVU9+QW1PfkGGT35Bn09+QbhPfkHRT35B6k9+QQJQfkEbUH5BNFB+QU1QfkFmUH5Bf1B+QZdQfkGwUH5ByVB+QeJQfkH7UH5BFFF+QSxRfkFFUX5BXlF+QXdRfkGQUX5BqVF+QcFRfkHaUX5B81F+QQxSfkElUn5BPlJ+QVZSfkFvUn5BiFJ+QaFSfkG6Un5B0lJ+QetSfkEEU35BHVN+QTZTfkFPU35BZ1N+QYBTfkGZU35BslN+QctTfkHjU35B/FN+QRVUfkEuVH5BR1R+QWBUfkF4VH5BkVR+QapUfkHDVH5B3FR+QfRUfkENVX5BJlV+QT9VfkFYVX5BcVV+QYlVfkGiVX5Bu1V+QdRVfkHtVX5BBVZ+QR5WfkE3Vn5BUFZ+QWlWfkGBVn5BmlZ+QbNWfkHMVn5B5VZ+Qf1WfkEWV35BL1d+QUhXfkFhV35BeVd+QZJXfkGrV35BxFd+Qd1XfkH1V35BDlh+QSdYfkFAWH5BWVh+QXFYfkGKWH5Bo1h+QbxYfkHVWH5B7Vh+QQZZfkEfWX5BOFl+QVFZfkFpWX5Bgll+QZtZfkG0WX5BzVl+QeVZfkH+WX5BF1p+QTBafkFJWn5BYVp+QXpafkGTWn5BrFp+QcRafkHdWn5B9lp+QQ9bfkEoW35BQFt+QVlbfkFyW35Bi1t+QaRbfkG8W35B1Vt+Qe5bfkEHXH5BH1x+QThcfkFRXH5Balx+QYNcfkGbXH5BtFx+Qc1cfkHmXH5B/1x+QRddfkEwXX5BSV1+QWJdfkF6XX5Bk11+QaxdfkHFXX5B3l1+QfZdfkEPXn5BKF5+QUFefkFZXn5Bcl5+QYtefkGkXn5BvF5+QdVefkHuXn5BB19+QSBffkE4X35BUV9+QWpffkGDX35Bm19+QbRffkHNX35B5l9+Qf5ffkEXYH5BMGB+QUlgfkFiYH5BemB+QZNgfkGsYH5BxWB+Qd1gfkH2YH5BD2F+QShhfkFAYX5BWWF+QXJhfkGLYX5Bo2F+QbxhfkHVYX5B7mF+QQdifkEfYn5BOGJ+QVFifkFqYn5BgmJ+QZtifkG0Yn5BzWJ+QeVifkH+Yn5BF2N+QTBjfkFIY35BYWN+QXpjfkGTY35Bq2N+QcRjfkHdY35B9mN+QQ5kfkEnZH5BQGR+QVlkfkFxZH5BimR+QaNkfkG8ZH5B1GR+Qe1kfkEGZX5BH2V+QTdlfkFQZX5BaWV+QYJlfkGaZX5Bs2V+QcxlfkHlZX5B/WV+QRZmfkEvZn5BR2Z+QWBmfkF5Zn5BkmZ+QapmfkHDZn5B3GZ+QfVmfkENZ35BJmd+QT9nfkFYZ35BcGd+QYlnfkGiZ35Bu2d+QdNnfkHsZ35BBWh+QR1ofkE2aH5BT2h+QWhofkGAaH5BmWh+QbJofkHLaH5B42h+QfxofkEVaX5BLml+QUZpfkFfaX5BeGl+QZBpfkGpaX5Bwml+QdtpfkHzaX5BDGp+QSVqfkE9an5BVmp+QW9qfkGIan5BoGp+QblqfkHSan5B62p+QQNrfkEca35BNWt+QU1rfkFma35Bf2t+QZhrfkGwa35ByWt+QeJrfkH6a35BE2x+QSxsfkFFbH5BXWx+QXZsfkGPbH5Bp2x+QcBsfkHZbH5B8mx+QQptfkEjbX5BPG1+QVRtfkFtbX5Bhm1+QZ9tfkG3bX5B0G1+QeltfkEBbn5BGm5+QTNufkFMbn5BZG5+QX1ufkGWbn5Brm5+QcdufkHgbn5B+G5+QRFvfkEqb35BQ29+QVtvfkF0b35BjW9+QaVvfkG+b35B129+Qe9vfkEIcH5BIXB+QTpwfkFScH5Ba3B+QYRwfkGccH5BtXB+Qc5wfkHmcH5B/3B+QRhxfkExcX5BSXF+QWJxfkF7cX5Bk3F+QaxxfkHF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nX5BHJ1+QTWdfkFNnX5BZp1+QX6dfkGXnX5Br51+QcidfkHgnX5B+Z1+QRGefkEqnn5BQp5+QVuefkFznn5BjJ5+QaSefkG9nn5B1Z5+Qe6efkEGn35BH59+QTeffkFQn35BaJ9+QYGffkGZn35Bsp9+QcqffkHjn35B+59+QRSgfkEsoH5BRaB+QV2gfkF2oH5BjqB+QaegfkG/oH5B2KB+QfCgfkEJoX5BIaF+QTqhfkFSoX5Ba6F+QYOhfkGcoX5BtKF+Qc2hfkHloX5B/qF+QRaifkEvon5BR6J+QWCifkF4on5BkaJ+QamifkHCon5B2qJ+QfOifkELo35BJKN+QTyjfkFVo35BbaN+QYajfkGeo35Bt6N+Qc+jfkHoo35BAKR+QRikfkExpH5BSaR+QWKkfkF6pH5Bk6R+QaukfkHEpH5B3KR+QfWkfkENpX5BJqV+QT6lfkFXpX5Bb6V+QYilfkGgpX5BuaV+QdGlfkHqpX5BAqZ+QRumfkEzpn5BS6Z+QWSmfkF8pn5BlaZ+Qa2mfkHGpn5B3qZ+QfemfkEPp35BKKd+QUCnfkFZp35Bcad+QYqnfkGip35Bu6d+QdOnfkHrp35BBKh+QRyofkE1qH5BTah+QWaofkF+qH5Bl6h+Qa+ofkHIqH5B4Kh+QfmofkERqX5BKql+QUKpfkFaqX5Bc6l+QYupfkGkqX5BvKl+QdWpfkHtqX5BBqp+QR6qfkE3qn5BT6p+QWeqfkGAqn5BmKp+QbGqfkHJqn5B4qp+QfqqfkETq35BK6t+QUSrfkFcq35BdKt+QY2rfkGlq35Bvqt+QdarfkHvq35BB6x+QSCsfkE4rH5BUax+QWmsfkGBrH5Bmqx+QbKsfkHLrH5B46x+QfysfkEUrX5BLa1+QUWtfkFdrX5Bdq1+QY6tfkGnrX5Bv61+QditfkHwrX5BCa5+QSGufkE5rn5BUq5+QWqufkGDrn5Bm65+QbSufkHMrn5B5a5+Qf2ufkEVr35BLq9+QUavfkFfr35Bd69+QZCvfkGor35BwK9+QdmvfkHxr35BCrB+QSKwfkE7sH5BU7B+QWuwfkGEsH5BnLB+QbWwfkHNsH5B5rB+Qf6wfkEWsX5BL7F+QUexfkFgsX5BeLF+QZGxfkGpsX5BwbF+QdqxfkHysX5BC7J+QSOyfkE8sn5BVLJ+QWyyfkGF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3X5BZN1+QXzdfkGU3X5Brd1+QcXdfkHd3X5B9d1+QQ7efkEm3n5BPt5+QVbefkFv3n5Bh95+QZ/efkG33n5B0N5+QejefkEA335BGN9+QTDffkFJ335BYd9+QXnffkGR335Bqt9+QcLffkHa335B8t9+QQvgfkEj4H5BO+B+QVPgfkFs4H5BhOB+QZzgfkG04H5BzOB+QeXgfkH94H5BFeF+QS3hfkFG4X5BXuF+QXbhfkGO4X5Bp+F+Qb/hfkHX4X5B7+F+QQfifkEg4n5BOOJ+QVDifkFo4n5BgeJ+QZnifkGx4n5ByeJ+QeLifkH64n5BEuN+QSrjfkFC435BW+N+QXPjfkGL435Bo+N+QbzjfkHU435B7ON+QQTkfkEc5H5BNeR+QU3kfkFl5H5BfeR+QZXkfkGu5H5BxuR+Qd7kfkH25H5BD+V+QSflfkE/5X5BV+V+QW/lfkGI5X5BoOV+QbjlfkHQ5X5B6OV+QQHmfkEZ5n5BMeZ+QUnmfkFi5n5BeuZ+QZLmfkGq5n5BwuZ+QdvmfkHz5n5BC+d+QSPnfkE7535BVOd+QWznfkGE535BnOd+QbTnfkHN535B5ed+Qf3nfkEV6H5BLeh+QUbofkFe6H5Bduh+QY7ofkGm6H5Bv+h+QdfofkHv6H5BB+l+QR/pfkE46X5BUOl+QWjpfkGA6X5BmOl+QbHpfkHJ6X5B4el+QfnpfkER6n5BKup+QULqfkFa6n5Bcup+QYrqfkGj6n5Bu+p+QdPqfkHr6n5BA+t+QRzrfkE0635BTOt+QWTrfkF8635BlOt+Qa3rfkHF635B3et+QfXrfkEN7H5BJux+QT7sfkFW7H5Bbux+QYbsfkGf7H5Bt+x+Qc/sfkHn7H5B/+x+QRftfkEw7X5BSO1+QWDtfkF47X5BkO1+QantfkHB7X5B2e1+QfHtfkEJ7n5BIe5+QTrufkFS7n5Bau5+QYLufkGa7n5Bs+5+QcvufkHj7n5B++5+QRPvfkEr735BRO9+QVzvfkF0735BjO9+QaTvfkG8735B1e9+Qe3vfkEF8H5BHfB+QTXwfkFN8H5BZvB+QX7wfkGW8H5BrvB+QcbwfkHe8H5B9/B+QQ/xfkEn8X5BP/F+QVfxfkFv8X5BiPF+QaDxfkG48X5B0PF+QejxfkEA8n5BGfJ+QTHyfkFJ8n5BYfJ+QXnyfkGR8n5BqvJ+QcLyfkHa8n5B8vJ+QQrzfkEi835BO/N+QVPzfkFr835Bg/N+QZvzfkGz835By/N+QeTzfkH8835BFPR+QSz0fkFE9H5BXPR+QXX0fkGN9H5BpfR+Qb30fkHV9H5B7fR+QQX1fkEe9X5BNvV+QU71fkFm9X5BfvV+QZb1fkGu9X5Bx/V+Qd/1fkH39X5BD/Z+QSf2fkE/9n5BV/Z+QXD2fkGI9n5BoPZ+Qbj2fkHQ9n5B6PZ+QQD3fkEZ935BMfd+QUn3fkFh935Befd+QZH3fkGp935Bwvd+Qdr3fkHy935BCvh+QSL4fkE6+H5BUvh+QWv4fkGD+H5Bm/h+QbP4fkHL+H5B4/h+Qfv4fkEU+X5BLPl+QUT5fkFc+X5BdPl+QYz5fkGk+X5BvPl+QdX5fkHt+X5BBfp+QR36fkE1+n5BTfp+QWX6fkF9+n5Blvp+Qa76fkHG+n5B3vp+Qfb6fkEO+35BJvt+QT77fkFX+35Bb/t+QYf7fkGf+35Bt/t+Qc/7fkHn+35B//t+QRj8fkEw/H5BSPx+QWD8fkF4/H5BkPx+Qaj8fkHA/H5B2fx+QfH8fkEJ/X5BIf1+QTn9fkFR/X5Baf1+QYH9fkGZ/X5Bsv1+Qcr9fkHi/X5B+v1+QRL+fkEq/n5BQv5+QVr+fkFy/n5Bi/5+QaP+fkG7/n5B0/5+Qev+fkED/35BG/9+QTP/fkFL/35BZP9+QXz/fkGU/35BrP9+QcT/fkHc/35B9P9+QQwAf0EkAH9BPQB/QVUAf0FtAH9BhQB/QZ0Af0G1AH9BzQB/QeUAf0H9AH9BFQF/QS4Bf0FGAX9BXgF/QXYBf0GOAX9BpgF/Qb4Bf0HWAX9B7gF/QQYCf0EfAn9BNwJ/QU8Cf0FnAn9BfwJ/QZcCf0GvAn9BxwJ/Qd8Cf0H3An9BDwN/QSgDf0FAA39BWAN/QXADf0GIA39BoAN/QbgDf0HQA39B6AN/QQAEf0EYBH9BMQR/QUkEf0FhBH9BeQR/QZEEf0GpBH9BwQR/QdkEf0HxBH9BCQV/QSEFf0E6BX9BUgV/QWoFf0GCBX9BmgV/QbIFf0HKBX9B4gV/QfoFf0ESBn9BKgZ/QUIGf0FaBn9BcwZ/QYsGf0GjBn9BuwZ/QdMGf0HrBn9BAwd/QRsHf0EzB39BSwd/QWMHf0F7B39Bkwd/QawHf0HEB39B3Ad/QfQHf0EMCH9BJAh/QTwIf0FUCH9BbAh/QYQIf0GcCH9BtAh/QcwIf0HkCH9B/Qh/QRUJf0EtCX9BRQl/QV0Jf0F1CX9BjQl/QaUJf0G9CX9B1Ql/Qe0Jf0EFCn9BHQp/QTUKf0FNCn9BZgp/QX4Kf0GWCn9Brgp/QcYKf0HeCn9B9gp/QQ4Lf0EmC39BPgt/QVYLf0FuC39Bhgt/QZ4Lf0G2C39Bzgt/QeYLf0H/C39BFwx/QS8Mf0FHDH9BXwx/QXcMf0GPDH9Bpwx/Qb8Mf0HXDH9B7wx/QQcNf0EfDX9BNw1/QU8Nf0FnDX9Bfw1/QZcNf0GwDX9ByA1/QeANf0H4DX9BEA5/QSgOf0FADn9BWA5/QXAOf0GIDn9BoA5/QbgOf0HQDn9B6A5/QQAPf0EYD39BMA9/QUgPf0FgD39BeA9/QZAPf0GoD39BwA9/QdkPf0HxD39BCRB/QSEQf0E5EH9BURB/QWkQf0GBEH9BmRB/QbEQf0HJEH9B4RB/QfkQf0EREX9BKRF/QUERf0FZEX9BcRF/QYkRf0GhEX9BuRF/QdERf0HpEX9BARJ/QRkSf0ExEn9BSRJ/QWESf0F6En9BkhJ/QaoSf0HCEn9B2hJ/QfISf0EKE39BIhN/QToTf0FSE39BahN/QYITf0GaE39BshN/QcoTf0HiE39B+hN/QRIUf0EqFH9BQhR/QVoUf0FyFH9BihR/QaIUf0G6FH9B0hR/QeoUf0ECFX9BGhV/QTIVf0FKFX9BYhV/QXoVf0GSFX9BqhV/QcIVf0HaFX9B8hV/QQoWf0EiFn9BOhZ/QVIWf0FqFn9BghZ/QZoWf0GyFn9ByhZ/QeMWf0H7Fn9BExd/QSsXf0FDF39BWxd/QXMXf0GLF39Boxd/QbsXf0HTF39B6xd/QQMYf0EbGH9BMxh/QUsYf0FjGH9Bexh/QZMYf0GrGH9Bwxh/QdsYf0HzGH9BCxl/QSMZf0E7GX9BUxl/QWsZf0GDGX9Bmxl/QbMZf0HLGX9B4xl/QfsZf0ETGn9BKxp/QUMaf0FbGn9Bcxp/QYsaf0GjGn9Buxp/QdMaf0HrGn9BAxt/QRsbf0EzG39BSxt/QWMbf0F7G39Bkxt/Qasbf0HDG39B2xt/QfMbf0ELHH9BIxx/QTscf0FTHH9Baxx/QYMcf0GbHH9Bsxx/Qcscf0HiHH9B+hx/QRIdf0EqHX9BQh1/QVodf0FyHX9Bih1/QaIdf0G6HX9B0h1/Qeodf0ECHn9BGh5/QTIef0FKHn9BYh5/QXoef0GSHn9Bqh5/QcIef0HaHn9B8h5/QQoff0EiH39BOh9/QVIff0FqH39Bgh9/QZoff0GyH39Byh9/QeIff0H6H39BEiB/QSogf0FCIH9BWiB/QXIgf0GKIH9BoiB/Qbogf0HSIH9B6iB/QQIhf0EaIX9BMiF/QUkhf0FhIX9BeSF/QZEhf0GpIX9BwSF/Qdkhf0HxIX9BCSJ/QSEif0E5In9BUSJ/QWkif0GBIn9BmSJ/QbEif0HJIn9B4SJ/Qfkif0ERI39BKSN/QUEjf0FZI39BcSN/QYkjf0GhI39BuSN/QdEjf0HoI39BACR/QRgkf0EwJH9BSCR/QWAkf0F4JH9BkCR/Qagkf0HAJH9B2CR/QfAkf0EIJX9BICV/QTglf0FQJX9BaCV/QYAlf0GYJX9BsCV/Qcglf0HgJX9B9yV/QQ8mf0EnJn9BPyZ/QVcmf0FvJn9BhyZ/QZ8mf0G3Jn9BzyZ/Qecmf0H/Jn9BFyd/QS8nf0FHJ39BXyd/QXcnf0GPJ39Bpyd/Qb4nf0HWJ39B7id/QQYof0EeKH9BNih/QU4of0FmKH9Bfih/QZYof0GuKH9Bxih/Qd4of0H2KH9BDil/QSYpf0E+KX9BVSl/QW0pf0GFKX9BnSl/QbUpf0HNKX9B5Sl/Qf0pf0EVKn9BLSp/QUUqf0FdKn9BdSp/QY0qf0GlKn9BvCp/QdQqf0HsKn9BBCt/QRwrf0E0K39BTCt/QWQrf0F8K39BlCt/Qawrf0HEK39B3Ct/QfQrf0ELLH9BIyx/QTssf0FTLH9Bayx/QYMsf0GbLH9Bsyx/Qcssf0HjLH9B+yx/QRMtf0ErLX9BQi1/QVotf0FyLX9Bii1/QaItf0G6LX9B0i1/Qeotf0ECLn9BGi5/QTIuf0FKLn9BYi5/QXkuf0GRLn9BqS5/QcEuf0HZLn9B8S5/QQkvf0EhL39BOS9/QVEvf0FpL39BgC9/QZgvf0GwL39ByC9/QeAvf0H4L39BEDB/QSgwf0FAMH9BWDB/QXAwf0GIMH9BnzB/Qbcwf0HPMH9B5zB/Qf8wf0EXMX9BLzF/QUcxf0FfMX9BdzF/QY4xf0GmMX9BvjF/QdYxf0HuMX9BBjJ/QR4yf0E2Mn9BTjJ/QWYyf0F9Mn9BlTJ/Qa0yf0HFMn9B3TJ/QfUyf0ENM39BJTN/QT0zf0FVM39BbDN/QYQzf0GcM39BtDN/Qcwzf0HkM39B/DN/QRQ0f0EsNH9BRDR/QVs0f0FzNH9BizR/QaM0f0G7NH9B0zR/Qes0f0EDNX9BGzV/QTI1f0FKNX9BYjV/QXo1f0GSNX9BqjV/QcI1f0HaNX9B8jV/QQk2f0EhNn9BOTZ/QVE2f0FpNn9BgTZ/QZk2f0GxNn9ByDZ/QeA2f0H4Nn9BEDd/QSg3f0FAN39BWDd/QXA3f0GIN39Bnzd/Qbc3f0HPN39B5zd/Qf83f0EXOH9BLzh/QUc4f0FeOH9Bdjh/QY44f0GmOH9Bvjh/QdY4f0HuOH9BBjl/QR05f0E1OX9BTTl/QWU5f0F9OX9BlTl/Qa05f0HFOX9B3Dl/QfQ5f0EMOn9BJDp/QTw6f0FUOn9BbDp/QYM6f0GbOn9Bszp/Qcs6f0HjOn9B+zp/QRM7f0ErO39BQjt/QVo7f0FyO39Bijt/QaI7f0G6O39B0jt/Qek7f0EBPH9BGTx/QTE8f0FJPH9BYTx/QXk8f0GQPH9BqDx/QcA8f0HYPH9B8Dx/QQg9f0EgPX9BOD1/QU89f0FnPX9Bfz1/QZc9f0GvPX9Bxz1/Qd49f0H2PX9BDj5/QSY+f0E+Pn9BVj5/QW4+f0GFPn9BnT5/QbU+f0HNPn9B5T5/Qf0+f0EVP39BLD9/QUQ/f0FcP39BdD9/QYw/f0GkP39Buz9/QdM/f0HrP39BA0B/QRtAf0EzQH9BS0B/QWJAf0F6QH9BkkB/QapAf0HCQH9B2kB/QfFAf0EJQX9BIUF/QTlBf0FRQX9BaUF/QYFBf0GYQX9BsEF/QchBf0HgQX9B+EF/QRBCf0EnQn9BP0J/QVdCf0FvQn9Bh0J/QZ9Cf0G2Qn9BzkJ/QeZCf0H+Qn9BFkN/QS5Df0FFQ39BXUN/QXVDf0GNQ39BpUN/Qb1Df0HUQ39B7EN/QQREf0EcRH9BNER/QUxEf0FjRH9Be0R/QZNEf0GrRH9Bw0R/QdpEf0HyRH9BCkV/QSJFf0E6RX9BUkV/QWlFf0GBRX9BmUV/QbFFf0HJRX9B4UV/QfhFf0EQRn9BKEZ/QUBGf0FYRn9Bb0Z/QYdGf0GfRn9Bt0Z/Qc9Gf0HnRn9B/kZ/QRZHf0EuR39BRkd/QV5Hf0F1R39BjUd/QaVHf0G9R39B1Ud/Qe1Hf0EESH9BHEh/QTRIf0FMSH9BZEh/QXtIf0GTSH9Bq0h/QcNIf0HbSH9B8kh/QQpJf0EiSX9BOkl/QVJJf0FqSX9BgUl/QZlJf0GxSX9ByUl/QeFJf0H4SX9BEEp/QShKf0FASn9BWEp/QW9Kf0GHSn9Bn0p/QbdKf0HPSn9B5kp/Qf5Kf0EWS39BLkt/QUZLf0FdS39BdUt/QY1Lf0GlS39BvUt/QdRLf0HsS39BBEx/QRxMf0E0TH9BS0x/QWNMf0F7TH9Bk0x/QatMf0HCTH9B2kx/QfJMf0EKTX9BIk1/QTlNf0FRTX9BaU1/QYFNf0GYTX9BsE1/QchNf0HgTX9B+E1/QQ9Of0EnTn9BP05/QVdOf0FvTn9Bhk5/QZ5Of0G2Tn9Bzk5/QeVOf0H9Tn9BFU9/QS1Pf0FFT39BXE9/QXRPf0GMT39BpE9/QbxPf0HTT39B609/QQNQf0EbUH9BMlB/QUpQf0FiUH9BelB/QZJQf0GpUH9BwVB/QdlQf0HxUH9BCFF/QSBRf0E4UX9BUFF/QWhRf0F/UX9Bl1F/Qa9Rf0HHUX9B3lF/QfZRf0EOUn9BJlJ/QT5Sf0FVUn9BbVJ/QYVSf0GdUn9BtFJ/QcxSf0HkUn9B/FJ/QRNTf0ErU39BQ1N/QVtTf0FzU39BilN/QaJTf0G6U39B0lN/QelTf0EBVH9BGVR/QTFUf0FIVH9BYFR/QXhUf0GQVH9Bp1R/Qb9Uf0HXVH9B71R/QQdVf0EeVX9BNlV/QU5Vf0FmVX9BfVV/QZVVf0GtVX9BxVV/QdxVf0H0VX9BDFZ/QSRWf0E7Vn9BU1Z/QWtWf0GDVn9BmlZ/QbJWf0HKVn9B4lZ/QflWf0ERV39BKVd/QUFXf0FYV39BcFd/QYhXf0GgV39Bt1d/Qc9Xf0HnV39B/1d/QRZYf0EuWH9BRlh/QV5Yf0F1WH9BjVh/QaVYf0G9WH9B1Fh/QexYf0EEWX9BHFl/QTNZf0FLWX9BY1l/QXtZf0GSWX9Bqll/QcJZf0HaWX9B8Vl/QQlaf0EhWn9BOVp/QVBaf0FoWn9BgFp/QZdaf0GvWn9Bx1p/Qd9af0H2Wn9BDlt/QSZbf0E+W39BVVt/QW1bf0GFW39BnVt/QbRbf0HMW39B5Ft/Qfxbf0ETXH9BK1x/QUNcf0FaXH9Bclx/QYpcf0GiXH9BuVx/QdFcf0HpXH9BAV1/QRhdf0EwXX9BSF1/QV9df0F3XX9Bj11/Qaddf0G+XX9B1l1/Qe5df0EGXn9BHV5/QTVef0FNXn9BZF5/QXxef0GUXn9BrF5/QcNef0HbXn9B815/QQtff0EiX39BOl9/QVJff0FpX39BgV9/QZlff0GxX39ByF9/QeBff0H4X39BD2B/QSdgf0E/YH9BV2B/QW5gf0GGYH9BnmB/QbVgf0HNYH9B5WB/Qf1gf0EUYX9BLGF/QURhf0FbYX9Bc2F/QYthf0GjYX9BumF/QdJhf0HqYX9BAWJ/QRlif0ExYn9BSGJ/QWBif0F4Yn9BkGJ/Qadif0G/Yn9B12J/Qe5if0EGY39BHmN/QTZjf0FNY39BZWN/QX1jf0GUY39BrGN/QcRjf0HbY39B82N/QQtkf0EjZH9BOmR/QVJkf0FqZH9BgWR/QZlkf0GxZH9ByGR/QeBkf0H4ZH9BEGV/QSdlf0E/ZX9BV2V/QW5lf0GGZX9BnmV/QbVlf0HNZX9B5WV/Qfxlf0EUZn9BLGZ/QURmf0FbZn9Bc2Z/QYtmf0GiZn9BumZ/QdJmf0HpZn9BAWd/QRlnf0EwZ39BSGd/QWBnf0F4Z39Bj2d/Qadnf0G/Z39B1md/Qe5nf0EGaH9BHWh/QTVof0FNaH9BZGh/QXxof0GUaH9Bq2h/QcNof0HbaH9B8mh/QQppf0EiaX9BOml/QVFpf0FpaX9BgWl/QZhpf0GwaX9ByGl/Qd9pf0H3aX9BD2p/QSZqf0E+an9BVmp/QW1qf0GFan9BnWp/QbRqf0HMan9B5Gp/Qftqf0ETa39BK2t/QUJrf0Faa39Bcmt/QYlrf0Gha39BuWt/QdBrf0Hoa39BAGx/QRdsf0EvbH9BR2x/QV5sf0F2bH9Bjmx/QaVsf0G9bH9B1Wx/Qexsf0EEbX9BHG1/QTNtf0FLbX9BY21/QXptf0GSbX9Bqm1/QcFtf0HZbX9B8W1/QQhuf0Egbn9BOG5/QU9uf0Fnbn9Bf25/QZZuf0Gubn9Bxm5/Qd1uf0H1bn9BDW9/QSRvf0E8b39BVG9/QWtvf0GDb39Bm29/QbJvf0HKb39B4W9/Qflvf0ERcH9BKHB/QUBwf0FYcH9Bb3B/QYdwf0Gf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mn9BI5p/QTuaf0FSmn9Bapp/QYGaf0GZmn9BsJp/Qciaf0Hfmn9B95p/QQ6bf0Emm39BPZt/QVWbf0Fsm39BhJt/QZubf0Gzm39Bypt/QeKbf0H5m39BEZx/QSicf0E/nH9BV5x/QW6cf0GGnH9BnZx/QbWcf0HMnH9B5Jx/Qfucf0ETnX9BKp1/QUKdf0FZnX9BcZ1/QYidf0GgnX9Bt51/Qc+df0HmnX9B/Z1/QRWef0Esnn9BRJ5/QVuef0Fznn9Bip5/QaKef0G5nn9B0Z5/Qeief0EAn39BF59/QS+ff0FGn39BXZ9/QXWff0GMn39BpJ9/Qbuff0HTn39B6p9/QQKgf0EZoH9BMaB/QUigf0FgoH9Bd6B/QY6gf0GmoH9BvaB/QdWgf0HsoH9BBKF/QRuhf0EzoX9BSqF/QWKhf0F5oX9BkKF/Qaihf0G/oX9B16F/Qe6hf0EGon9BHaJ/QTWif0FMon9BZKJ/QXuif0GSon9BqqJ/QcGif0HZon9B8KJ/QQijf0Efo39BN6N/QU6jf0Fmo39BfaN/QZSjf0Gso39Bw6N/Qdujf0Hyo39BCqR/QSGkf0E5pH9BUKR/QWekf0F/pH9BlqR/Qa6kf0HFpH9B3aR/QfSkf0EMpX9BI6V/QTqlf0FSpX9BaaV/QYGlf0GYpX9BsKV/Qcelf0HepX9B9qV/QQ2mf0Elpn9BPKZ/QVSmf0Frpn9Bg6Z/QZqmf0Gxpn9ByaZ/QeCmf0H4pn9BD6d/QSenf0E+p39BVad/QW2nf0GEp39BnKd/QbOnf0HLp39B4qd/Qfmnf0ERqH9BKKh/QUCof0FXqH9Bb6h/QYaof0GdqH9Btah/Qcyof0HkqH9B+6h/QROpf0EqqX9BQal/QVmpf0FwqX9BiKl/QZ+pf0G3qX9Bzql/QeWpf0H9qX9BFKp/QSyqf0FDqn9BWqp/QXKqf0GJqn9Boap/Qbiqf0HQqn9B56p/Qf6qf0EWq39BLat/QUWrf0Fcq39BdKt/QYurf0Giq39Buqt/QdGrf0Hpq39BAKx/QResf0EvrH9BRqx/QV6sf0F1rH9BjKx/QaSsf0G7rH9B06x/Qeqsf0ECrX9BGa1/QTCtf0FIrX9BX61/QXetf0GOrX9Bpa1/Qb2tf0HUrX9B7K1/QQOuf0Earn9BMq5/QUmuf0Fhrn9BeK5/QY+uf0Gn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139Bvdd/QdTXf0Hr139BA9h/QRrYf0Ex2H9BSNh/QWDYf0F32H9Bjth/QaXYf0G92H9B1Nh/QevYf0EC2X9BGtl/QTHZf0FI2X9BX9l/QXbZf0GO2X9Bpdl/QbzZf0HT2X9B69l/QQLaf0EZ2n9BMNp/QUjaf0Ff2n9Bdtp/QY3af0Gl2n9BvNp/QdPaf0Hq2n9BAdt/QRnbf0Ew239BR9t/QV7bf0F2239Bjdt/QaTbf0G7239B0tt/Qerbf0EB3H9BGNx/QS/cf0FH3H9BXtx/QXXcf0GM3H9Bo9x/Qbvcf0HS3H9B6dx/QQDdf0EY3X9BL91/QUbdf0Fd3X9BdN1/QYzdf0Gj3X9But1/QdHdf0Hp3X9BAN5/QRfef0Eu3n9BRd5/QV3ef0F03n9Bi95/QaLef0G53n9B0d5/Qejef0H/3n9BFt9/QS7ff0FF339BXN9/QXPff0GK339Bot9/Qbnff0HQ339B599/Qf7ff0EW4H9BLeB/QUTgf0Fb4H9BcuB/QYrgf0Gh4H9BuOB/Qc/gf0Hm4H9B/uB/QRXhf0Es4X9BQ+F/QVvhf0Fy4X9BieF/QaDhf0G34X9Bz+F/Qebhf0H94X9BFOJ/QSvif0FD4n9BWuJ/QXHif0GI4n9Bn+J/Qbfif0HO4n9B5eJ/Qfzif0ET439BK+N/QULjf0FZ439BcON/QYfjf0Ge439BtuN/Qc3jf0Hk439B++N/QRLkf0Eq5H9BQeR/QVjkf0Fv5H9BhuR/QZ7kf0G15H9BzOR/QePkf0H65H9BEuV/QSnlf0FA5X9BV+V/QW7lf0GF5X9BneV/QbTlf0HL5X9B4uV/Qfnlf0ER5n9BKOZ/QT/mf0FW5n9BbeZ/QYXmf0Gc5n9Bs+Z/Qcrmf0Hh5n9B+OZ/QRDnf0En539BPud/QVXnf0Fs539BhOd/QZvnf0Gy539Byed/QeDnf0H3539BD+h/QSbof0E96H9BVOh/QWvof0GC6H9Bmuh/QbHof0HI6H9B3+h/Qfbof0EN6X9BJel/QTzpf0FT6X9Baul/QYHpf0GZ6X9BsOl/Qcfpf0He6X9B9el/QQzqf0Ek6n9BO+p/QVLqf0Fp6n9BgOp/QZfqf0Gv6n9Bxup/Qd3qf0H06n9BC+t/QSLrf0E6639BUet/QWjrf0F/639Blut/Qa3rf0HF639B3Ot/QfPrf0EK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0BgAYQAAAB4GAAAcAAAADNAYAGEAAAB1BgAAGAAAAAzQGABhAAAArwYAAA8AAAAM0BgAYQAAALEGAAAFAAAADNAYAGEAAADQBgAASQAAAAzQGABhAAAA0gYAABcAAAAM0BgAYQAAANIGAABMAAAADNAYAGEAAADuBgAAJQAAAAzQGABhAAAALAcAABAAAAAM0BgAYQAAADAHAAAHAAAADNAYAGEAAABFBwAABQAAAAzQGABhAAAARgcAAAUAAAAM0BgAYQAAAEkHAAAHAAAADNAYAGEAAABJBwAAXAAAAAzQGABhAAAAXQcAABwAAAAM0BgAYQAAAPEHAAAbAAAADNAYAGEAAAD2BwAAGQAAAAAAAgAAAAAAAAADAAAAAAEAAAQAAAAAAgAABQAAAAADAAAGAAAAAAMAAAcAAAAAAwAACAAAAAADAAAJAAAAAAMBAAIAAAAAAAEAAwAAAAABAQAEAAAAAAIBAAUAAAAAAwEABgAAAAADAQAHAAAAAAMBAAgAAAAAAwEACQAAAAADAgACAAAAAAACAAMAAAAAAQIABAAAAAACAgAFAAAAAAMCAAYAAAAAAwIABwAAAAADAgAIAAAAAAMCAAkAAAAAAwMAAgAAAAAAAwADAAAAAAEDAAQAAAAAAgMABQAAAAADAwAGAAAAAAMDAAcAAAAAAwMACAAAAAADAwAJAAAAAAMEAAIAAAAAAAQAAwAAAAABBAAEAAAAAAIEAAUAAAAAAwQABgAAAAADBAAHAAAAAAMEAAgAAAAAAwQACQAAAAADBQACAAAAAAAFAAMAAAAAAQUABAAAAAACBQAFAAAAAAMFAAYAAAAAAwUABwAAAAADBQAIAAAAAAMFAAkAAAAAAwYAAgABAAAABgADAAEAAAEGAAQAAQAAAgYABQABAAADBgAGAAEAAAMGAAcAAQAAAwYACAABAAADBgAJAAEAAAMIAAIAAQAAAAgAAwABAAABCAAEAAEAAAIIAAUAAQAAAwgABgABAAADCAAHAAEAAAMIAAgAAQAAAwgACQABAAADAAAKAAABAAMAAAwAAAEAAwAADgAAAgADAAASAAACAAMAABYAAAMAAwAAHgAAAwADAAAmAAAEAAMAADYAAAQAAwEACgAAAQADAQAMAAABAAMBAA4AAAIAAwEAEgAAAgADAQAWAAADAAMBAB4AAAMAAwEAJgAABAADAQA2AAAEAAMCAAoAAAEAAwIADAAAAQADAgAOAAACAAMCABIAAAIAAwIAFgAAAwADAgAeAAADAAMCACYAAAQAAwIANgAABAADAwAKAAABAAMDAAwAAAEAAwMADgAAAgADAwASAAACAAMDABYAAAMAAwMAHgAAAwADAwAmAAAEAAMDADYAAAQAAwQACgAAAQADBAAMAAABAAMEAA4AAAIAAwQAEgAAAgADBAAWAAADAAMEAB4AAAMAAwQAJgAABAADBAA2AAAEAAMFAAoAAAEAAwUADAAAAQADBQAOAAACAAMFABIAAAIAAwUAFgAAAwADBQAeAAADAAMFACYAAAQAAwUANgAABAADBgAKAAEBAAMGAAwAAQEAAwYADgABAgADBgASAAECAAMGABYAAQMAAwYAHgABAwADBgAmAAEEAAMGADYAAQQAAwgACgABAQADCAAMAAEBAAMIAA4AAQIAAwgAEgABAgADCAAWAAEDAAMIAB4AAQMAAwgAJgABBAADCAA2AAEEAAMAAAIAAAD/AAAAAwAAAP8BAAAEAAAA/wIAAAUAAAD/AwAABgAAAP8DAAAHAAAA/wMAAAgAAAD/AwAACQAAAP8DAQACAAAA/wABAAMAAAD/AQEABAAAAP8CAQAFAAAA/wMBAAYAAAD/AwEABwAAAP8DAQAIAAAA/wMBAAkAAAD/AwIAAgAAAP8AAgADAAAA/wECAAQAAAD/AgIABQAAAP8DAgAGAAAA/wMCAAcAAAD/AwIACAAAAP8DAgAJAAAA/wMDAAIAAAD/AAMAAwAAAP8BAwAEAAAA/wIDAAUAAAD/AwMABgAAAP8DAwAHAAAA/wMDAAgAAAD/AwMACQAAAP8DBAACAAAA/wAEAAMAAAD/AQQABAAAAP8CBAAFAAAA/wMEAAYAAAD/AwQABwAAAP8DBAAIAAAA/wMEAAkAAAD/AwUAAgAAAP8ABQADAAAA/wEFAAQAAAD/AgUABQAAAP8DBQAGAAAA/wMFAAcAAAD/AwUACAAAAP8DBQAJAAAA/wMGAAIAAQD/AAYAAwABAP8BBgAEAAEA/wIGAAUAAQD/AwYABgABAP8DBgAHAAEA/wMGAAgAAQD/AwYACQABAP8DCAACAAEA/wAIAAMAAQD/AQgABAABAP8CCAAFAAEA/wMIAAYAAQD/AwgABwABAP8DCAAIAAEA/wMI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ABoAAAAM0BgAYQAAACgJAAAaAAAADNAYAGEAAABGCQAAGQAAAAzQGABhAAAAVQkAAA8AAAAM0BgAYQAAAEkKAAARAAAADNAYAGEAAAB6CgAABwAAAAzQGABhAAAAewoAABsAAAAM0BgAYQAAAKUKAAAgAAAADNAYAGEAAACmCgAAEQAAAAzQGABhAAAAqQoAABwAAAAM0BgAYQAAAKkKAAARAAAADNAYAGEAAAC/CgAAQwAAAAzQGABhAAAAvwoAABEAAAAM0BgAYQAAAKMLAAAuAAAADNAYAGEAAACvCwAACwAAAAzQGABhAAAAdwsAAB8AAAAM0BgAYQAAAGILAAAmAAAADNAYAGEAAABpCwAACwAAAAzQGABhAAAAawsAAA4AAABCAAAABAAAAAQAAABDAAAAQgAAAAQAAAAEAAAAQQAAAHRpbWVkb3dubGlmZWxlZnRiYWNrY29kZWRhdGFzaG93b25seXNpdGVjaXR5b3Blbmp1c3RsaWtlZnJlZXdvcmt0ZXh0eWVhcm92ZXJib2R5bG92ZWZvcm1ib29rcGxheWxpdmVsaW5laGVscGhvbWVzaWRlbW9yZXdvcmRsb25ndGhlbXZpZXdmaW5kcGFnZWRheXNmdWxsaGVhZHRlcm1lYWNoYXJlYWZyb210cnVlbWFya2FibGV1cG9uaGlnaGRhdGVsYW5kbmV3c2V2ZW5uZXh0Y2FzZWJvdGhwb3N0dXNlZG1hZGVoYW5kaGVyZXdoYXRuYW1lTGlua2Jsb2dzaXplYmFzZWhlbGRtYWtlbWFpbnVzZXInKSAraG9sZGVuZHN3aXRoTmV3c3JlYWR3ZXJlc2lnbnRha2VoYXZlZ2FtZXNlZW5jYWxscGF0aHdlbGxwbHVzbWVudWZpbG1wYXJ0am9pbnRoaXNsaXN0Z29vZG5lZWR3YXlzd2VzdGpvYnNtaW5kYWxzb2xvZ29yaWNodXNlc2xhc3R0ZWFtYXJteWZvb2RraW5nd2lsbGVhc3R3YXJkYmVzdGZpcmVQYWdla25vd2F3YXkucG5nbW92ZXRoYW5sb2FkZ2l2ZXNlbGZub3RlbXVjaGZlZWRtYW55cm9ja2ljb25vbmNlbG9va2hpZGVkaWVkSG9tZXJ1bGVob3N0YWpheGluZm9jbHVibGF3c2xlc3NoYWxmc29tZXN1Y2h6b25lMTAwJW9uZXNjYXJlVGltZXJhY2VibHVlZm91cndlZWtmYWNlaG9wZWdhdmVoYXJkbG9zdHdoZW5wYXJra2VwdHBhc3NzaGlwcm9vbUhUTUxwbGFuVHlwZWRvbmVzYXZla2VlcGZsYWdsaW5rc29sZGZpdmV0b29rcmF0ZXRvd25qdW1wdGh1c2RhcmtjYXJkZmlsZWZlYXJzdGF5a2lsbHRoYXRmYWxsYXV0b2V2ZXIuY29tdGFsa3Nob3B2b3RlZGVlcG1vZGVyZXN0dHVybmJvcm5iYW5kZmVsbHJvc2V1cmwoc2tpbnJvbGVjb21lYWN0c2FnZXNtZWV0Z29sZC5qcGdpdGVtdmFyeWZlbHR0aGVuc2VuZGRyb3BWaWV3Y29weTEuMCI8L2E+c3RvcGVsc2VsaWVzdG91cnBhY2suZ2lmcGFzdGNzcz9ncmF5bWVhbiZndDtyaWRlc2hvdGxhdGVzYWlkcm9hZHZhciBmZWVsam9obnJpY2twb3J0ZmFzdCdVQS1kZWFkPC9iPnBvb3JiaWxsdHlwZVUuUy53b29kbXVzdDJweDtJbmZvcmFua3dpZGV3YW50d2FsbGxlYWRbMF07cGF1bHdhdmVzdXJlJCgnI3dhaXRtYXNzYXJtc2dvZXNnYWlubGFuZ3BhaWQhLS0gbG9ja3VuaXRyb290d2Fsa2Zpcm13aWZleG1sInNvbmd0ZXN0MjBweGtpbmRyb3dzdG9vbGZvbnRtYWlsc2FmZXN0YXJtYXBzY29yZXJhaW5mbG93YmFieXNwYW5zYXlzNHB4OzZweDthcnRzZm9vdHJlYWx3aWtpaGVhdHN0ZXB0cmlwb3JnL2xha2V3ZWFrdG9sZEZvcm1jYXN0ZmFuc2Jhbmt2ZXJ5cnVuc2p1bHl0YXNrMXB4O2dvYWxncmV3c2xvd2VkZ2VpZD0ic2V0czVweDsuanM/NDBweGlmIChzb29uc2VhdG5vbmV0dWJlemVyb3NlbnRyZWVkZmFjdGludG9naWZ0aGFybTE4cHhjYW1laGlsbGJvbGR6b29tdm9pZGVhc3lyaW5nZmlsbHBlYWtpbml0Y29zdDNweDtqYWNrdGFnc2JpdHNyb2xsZWRpdGtuZXduZWFyPCEtLWdyb3dKU09OZHV0eU5hbWVzYWxleW91IGxvdHNwYWluamF6emNvbGRleWVzZmlzaHd3dy5yaXNrdGFic3ByZXYxMHB4cmlzZTI1cHhCbHVlZGluZzMwMCxiYWxsZm9yZGVhcm53aWxkYm94LmZhaXJsYWNrdmVyc3BhaXJqdW5ldGVjaGlmKCFwaWNrZXZpbCQoIiN3YXJtbG9yZGRvZXNwdWxsLDAwMGlkZWFkcmF3aHVnZXNwb3RmdW5kYnVybmhyZWZjZWxsa2V5c3RpY2tob3VybG9zc2Z1ZWwxMnB4c3VpdGRlYWxSU1MiYWdlZGdyZXlHRVQiZWFzZWFpbXNnaXJsYWlkczhweDtuYXZ5Z3JpZHRpcHMjOTk5d2Fyc2xhZHljYXJzKTsgfXBocD9oZWxsdGFsbHdob216aDrlKi8NCiAxMDBoYWxsLgoKQTdweDtwdXNoY2hhdDBweDtjcmV3Ki88L2hhc2g3NXB4ZmxhdHJhcmUgJiYgdGVsbGNhbXBvbnRvbGFpZG1pc3Nza2lwdGVudGZpbmVtYWxlZ2V0c3Bsb3Q0MDAsDQoNCmNvb2xmZWV0LnBocDxicj5lcmljbW9zdGd1aWRiZWxsZGVzY2hhaXJtYXRoYXRvbS9pbWcmIzgybHVja2NlbnQwMDA7dGlueWdvbmVodG1sc2VsbGRydWdGUkVFbm9kZW5pY2s/aWQ9bG9zZW51bGx2YXN0d2luZFJTUyB3ZWFycmVseWJlZW5zYW1lZHVrZW5hc2FjYXBld2lzaGd1bGZUMjM6aGl0c3Nsb3RnYXRla2lja2JsdXJ0aGV5MTVweCcnKTspOyI+bXNpZXdpbnNiaXJkc29ydGJldGFzZWVrVDE4Om9yZHN0cmVlbWFsbDYwcHhmYXJt4oCZc2JveXNbMF0uJyk7IlBPU1RiZWFya2lkcyk7fX1tYXJ5dGVuZChVSylxdWFkemg65i1zaXotLS0tcHJvcCcpOw1saWZ0VDE5OnZpY2VhbmR5ZGVidD5SU1Nwb29sbmVja2Jsb3dUMTY6ZG9vcmV2YWxUMTc6bGV0c2ZhaWxvcmFscG9sbG5vdmFjb2xzZ2VuZSDigJRzb2Z0cm9tZXRpbGxyb3NzPGgzPnBvdXJmYWRlcGluazx0cj5taW5pKXwhKG1pbmV6aDroYmFyc2hlYXIwMCk7bWlsayAtLT5pcm9uZnJlZGRpc2t3ZW50c29pbHB1dHMvanMvaG9seVQyMjpJU0JOVDIwOmFkYW1zZWVzPGgyPmpzb24nLCAnY29udFQyMTogUlNTbG9vcGFzaWFtb29uPC9wPnNvdWxMSU5FZm9ydGNhcnRUMTQ6PGgxPjgwcHghLS08OXB4O1QwNDptaWtlOjQ2Wm5pY2VpbmNoWW9ya3JpY2V6aDrkJykpO3B1cmVtYWdlcGFyYXRvbmVib25kOjM3Wl9vZl8nXSk7MDAwLHpoOud0YW5reWFyZGJvd2xidXNoOjU2WkphdmEzMHB4Cnx9CiVDMyU6MzRaamVmZkVYUEljYXNodmlzYWdvbGZzbm93emg66XF1ZXIuY3Nzc2lja21lYXRtaW4uYmluZGRlbGxoaXJlcGljc3JlbnQ6MzZaSFRUUC0yMDFmb3Rvd29sZkVORCB4Ym94OjU0WkJPRFlkaWNrOwp9CmV4aXQ6MzVadmFyc2JlYXQnfSk7ZGlldDk5OTthbm5lfX08L1tpXS5MYW5na23CsndpcmV0b3lzYWRkc3NlYWxhbGV4OwoJfWVjaG9uaW5lLm9yZzAwNSl0b255amV3c3NhbmRsZWdzcm9vZjAwMCkgMjAwd2luZWdlYXJkb2dzYm9vdGdhcnljdXRzdHlsZXRlbXB0aW9uLnhtbGNvY2tnYW5nJCgnLjUwcHhQaC5EbWlzY2FsYW5sb2FuZGVza21pbGVyeWFudW5peGRpc2MpO30KZHVzdGNsaXApLgoKNzBweC0yMDBEVkRzN10+PHRhcGVkZW1vaSsrKXdhZ2VldXJvcGhpbG9wdHNob2xlRkFRc2FzaW4tMjZUbGFic3BldHNVUkwgYnVsa2Nvb2s7fQ0KSEVBRFswXSlhYmJyanVhbigxOThsZXNodHdpbjwvaT5zb255Z3V5c2Z1Y2twaXBlfC0KITAwMiluZG93WzFdO1tdOwpMb2cgc2FsdA0KCQliYW5ndHJpbWJhdGgpew0KMDBweAp9KTtrbzrsZmVlc2FkPg1zOi8vIFtdO3RvbGxwbHVnKCl7CnsNCiAuanMnMjAwcGR1YWxib2F0LkpQRyk7Cn1xdW90KTsKCicpOwoNCn0NMjAxNDIwMTUyMDE2MjAxNzIwMTgyMDE5MjAyMDIwMjEyMDIyMjAyMzIwMjQyMDI1MjAyNjIwMjcyMDI4MjAyOTIwMzAyMDMxMjAzMjIwMzMyMDM0MjAzNTIwMzYyMDM3MjAxMzIwMTIyMDExMjAxMDIwMDkyMDA4MjAwNzIwMDYyMDA1MjAwNDIwMDMyMDAyMjAwMTIwMDAxOTk5MTk5ODE5OTcxOTk2MTk5NTE5OTQxOTkzMTk5MjE5OTExOTkwMTk4OTE5ODgxOTg3MTk4NjE5ODUxOTg0MTk4MzE5ODIxOTgxMTk4MDE5NzkxOTc4MTk3NzE5NzYxOTc1MTk3NDE5NzMxOTcyMTk3MTE5NzAxOTY5MTk2ODE5NjcxOTY2MTk2NTE5NjQxOTYzMTk2MjE5NjExOTYwMTk1OTE5NTgxOTU3MTk1NjE5NTUxOTU0MTk1MzE5NTIxOTUxMTk1MDEwMDAxMDI0MTM5NDAwMDA5OTk5Y29tb23DoXNlc3RlZXN0YXBlcm90b2RvaGFjZWNhZGFhw7FvYmllbmTDrWFhc8OtdmlkYWNhc29vdHJvZm9yb3NvbG9vdHJhY3VhbGRpam9zaWRvZ3JhbnRpcG90ZW1hZGViZWFsZ29xdcOpZXN0b25hZGF0cmVzcG9jb2Nhc2FiYWpvdG9kYXNpbm9hZ3VhcHVlc3Vub3NhbnRlZGljZWx1aXNlbGxhbWF5b3pvbmFhbW9ycGlzb29icmFjbGljZWxsb2Rpb3Nob3JhY2FzadC30LDQvdCw0L7QvNGA0LDRgNGD0YLQsNC90LXQv9C+0L7RgtC40LfQvdC+0LTQvtGC0L7QttC10L7QvdC40YXQndCw0LXQtdCx0YvQvNGL0JLRi9GB0L7QstGL0LLQvtCd0L7QvtCx0J/QvtC70LjQvdC40KDQpNCd0LXQnNGL0YLRi9Ce0L3QuNC80LTQsNCX0LDQlNCw0J3Rg9Ce0LHRgtC10JjQt9C10LnQvdGD0LzQvNCi0YvRg9C22YHZitij2YbZhdin2YXYudmD2YTYo9mI2LHYr9mK2KfZgdmJ2YfZiNmE2YXZhNmD2KfZiNmE2YfYqNiz2KfZhNil2YbZh9mK2KPZitmC2K/Zh9mE2KvZhdio2YfZhNmI2YTZitio2YTYp9mK2KjZg9i02YrYp9mF2KPZhdmG2KrYqNmK2YTZhtit2KjZh9mF2YXYtNmI2LRmaXJzdHZpZGVvbGlnaHR3b3JsZG1lZGlhd2hpdGVjbG9zZWJsYWNrcmlnaHRzbWFsbGJvb2tzcGxhY2VtdXNpY2ZpZWxkb3JkZXJwb2ludHZhbHVlbGV2ZWx0YWJsZWJvYXJkaG91c2Vncm91cHdvcmtzeWVhcnNzdGF0ZXRvZGF5d2F0ZXJzdGFydHN0eWxlZGVhdGhwb3dlcnBob25lbmlnaHRlcnJvcmlucHV0YWJvdXR0ZXJtc3RpdGxldG9vbHNldmVudGxvY2FsdGltZXNsYXJnZXdvcmRzZ2FtZXNzaG9ydHNwYWNlZm9jdXNjbGVhcm1vZGVsYmxvY2tndWlkZXJhZGlvc2hhcmV3b21lbmFnYWlubW9uZXlpbWFnZW5hbWVzeW91bmdsaW5lc2xhdGVyY29sb3JncmVlbmZyb250JmFtcDt3YXRjaGZvcmNlcHJpY2VydWxlc2JlZ2luYWZ0ZXJ2aXNpdGlzc3VlYXJlYXNiZWxvd2luZGV4dG90YWxob3Vyc2xhYmVscHJpbnRwcmVzc2J1aWx0bGlua3NzcGVlZHN0dWR5dHJhZGVmb3VuZHNlbnNldW5kZXJzaG93bmZvcm1zcmFuZ2VhZGRlZHN0aWxsbW92ZWR0YWtlbmFib3ZlZmxhc2hmaXhlZG9mdGVub3RoZXJ2aWV3c2NoZWNrbGVnYWxyaXZlcml0ZW1zcXVpY2tzaGFwZWh1bWFuZXhpc3Rnb2luZ21vdmlldGhpcmRiYXNpY3BlYWNlc3RhZ2V3aWR0aGxvZ2luaWRlYXN3cm90ZXBhZ2VzdXNlcnNkcml2ZXN0b3JlYnJlYWtzb3V0aHZvaWNlc2l0ZXNtb250aHdoZXJlYnVpbGR3aGljaGVhcnRoZm9ydW10aHJlZXNwb3J0cGFydHlDbGlja2xvd2VybGl2ZXNjbGFzc2xheWVyZW50cnlzdG9yeXVzYWdlc291bmRjb3VydHlvdXIgYmlydGhwb3B1cHR5cGVzYXBwbHlJbWFnZWJlaW5ndXBwZXJub3Rlc2V2ZXJ5c2hvd3NtZWFuc2V4dHJhbWF0Y2h0cmFja2tub3duZWFybHliZWdhbnN1cGVycGFwZXJub3J0aGxlYXJuZ2l2ZW5uYW1lZGVuZGVkVGVybXNwYXJ0c0dyb3VwYnJhbmR1c2luZ3dvbWFuZmFsc2VyZWFkeWF1ZGlvdGFrZXN3aGlsZS5jb20vbGl2ZWRjYXNlc2RhaWx5Y2hpbGRncmVhdGp1ZGdldGhvc2V1bml0c25ldmVyYnJvYWRjb2FzdGNvdmVyYXBwbGVmaWxlc2N5Y2xlc2NlbmVwbGFuc2NsaWNrd3JpdGVxdWVlbnBpZWNlZW1haWxmcmFtZW9sZGVycGhvdG9saW1pdGNhY2hlY2l2aWxzY2FsZWVudGVydGhlbWV0aGVyZXRvdWNoYm91bmRyb3lhbGFza2Vkd2hvbGVzaW5jZXN0b2NrIG5hbWVmYWl0aGhlYXJ0ZW1wdHlvZmZlcnNjb3Blb3duZWRtaWdodGFsYnVtdGhpbmtibG9vZGFycmF5bWFqb3J0cnVzdGNhbm9udW5pb25jb3VudHZhbGlkc3RvbmVTdHlsZUxvZ2luaGFwcHlvY2N1cmxlZnQ6ZnJlc2hxdWl0ZWZpbG1zZ3JhZGVuZWVkc3VyYmFuZmlnaHRiYXNpc2hvdmVyYXV0bztyb3V0ZS5odG1sbWl4ZWRmaW5hbFlvdXIgc2xpZGV0b3BpY2Jyb3duYWxvbmVkcmF3bnNwbGl0cmVhY2hSaWdodGRhdGVzbWFyY2hxdW90ZWdvb2RzTGlua3Nkb3VidGFzeW5jdGh1bWJhbGxvd2NoaWVmeW91dGhub3ZlbDEwcHg7c2VydmV1bnRpbGhhbmRzQ2hlY2tTcGFjZXF1ZXJ5amFtZXNlcXVhbHR3aWNlMCwwMDBTdGFydHBhbmVsc29uZ3Nyb3VuZGVpZ2h0c2hpZnR3b3J0aHBvc3RzbGVhZHN3ZWVrc2F2b2lkdGhlc2VtaWxlc3BsYW5lc21hcnRhbHBoYXBsYW50bWFya3NyYXRlc3BsYXlzY2xhaW1zYWxlc3RleHRzc3RhcnN3cm9uZzwvaDM+dGhpbmcub3JnL211bHRpaGVhcmRQb3dlcnN0YW5kdG9rZW5zb2xpZCh0aGlzYnJpbmdzaGlwc3N0YWZmdHJpZWRjYWxsc2Z1bGx5ZmFjdHNhZ2VudFRoaXMgLy8tLT5hZG1pbmVneXB0RXZlbnQxNXB4O0VtYWlsdHJ1ZSJjcm9zc3NwZW50YmxvZ3Nib3giPm5vdGVkbGVhdmVjaGluYXNpemVzZ3Vlc3Q8L2g0PnJvYm90aGVhdnl0cnVlLHNldmVuZ3JhbmRjcmltZXNpZ25zYXdhcmVkYW5jZXBoYXNlPjwhLS1lbl9VUyYjMzk7MjAwcHhfbmFtZWxhdGluZW5qb3lhamF4LmF0aW9uc21pdGhVLlMuIGhvbGRzcGV0ZXJpbmRpYW5hdiI+Y2hhaW5zY29yZWNvbWVzZG9pbmdwcmlvclNoYXJlMTk5MHNyb21hbmxpc3RzamFwYW5mYWxsc3RyaWFsb3duZXJhZ3JlZTwvaDI+YWJ1c2VhbGVydG9wZXJhIi0vL1djYXJkc2hpbGxzdGVhbXNQaG90b3RydXRoY2xlYW4ucGhwP3NhaW50bWV0YWxsb3Vpc21lYW50cHJvb2ZicmllZnJvdyI+Z2VucmV0cnVja2xvb2tzVmFsdWVGcmFtZS5uZXQvLS0+Cjx0cnkgewp2YXIgbWFrZXNjb3N0c3BsYWluYWR1bHRxdWVzdHRyYWlubGFib3JoZWxwc2NhdXNlbWFnaWNtb3RvcnRoZWlyMjUwcHhsZWFzdHN0ZXBzQ291bnRjb3VsZGdsYXNzc2lkZXNmdW5kc2hvdGVsYXdhcmRtb3V0aG1vdmVzcGFyaXNnaXZlc2R1dGNodGV4YXNmcnVpdG51bGwsfHxbXTt0b3AiPgo8IS0tUE9TVCJvY2Vhbjxici8+Zmxvb3JzcGVha2RlcHRoIHNpemViYW5rc2NhdGNoY2hhcnQyMHB4O2FsaWduZGVhbHN3b3VsZDUwcHg7dXJsPSJwYXJrc21vdXNlTW9zdCAuLi48L2Ftb25nYnJhaW5ib2R5IG5vbmU7YmFzZWRjYXJyeWRyYWZ0cmVmZXJwYWdlX2hvbWUubWV0ZXJkZWxheWRyZWFtcHJvdmVqb2ludDwvdHI+ZHJ1Z3M8IS0tIGFwcmlsaWRlYWxhbGxlbmV4YWN0Zm9ydGhjb2Rlc2xvZ2ljVmlldyBzZWVtc2JsYW5rcG9ydHMgKDIwMHNhdmVkX2xpbmtnb2Fsc2dyYW50Z3JlZWtob21lc3JpbmdzcmF0ZWQzMHB4O3dob3NlcGFyc2UoKTsiIEJsb2NrbGludXhqb25lc3BpeGVsJyk7Ij4pO2lmKC1sZWZ0ZGF2aWRob3JzZUZvY3VzcmFpc2Vib3hlc1RyYWNrZW1lbnQ8L2VtPmJhciI+LnNyYz10b3dlcmFsdD0iY2FibGVoZW5yeTI0cHg7c2V0dXBpdGFseXNoYXJwbWlub3J0YXN0ZXdhbnRzdGhpcy5yZXNldHdoZWVsZ2lybHMvY3NzLzEwMCU7Y2x1YnNzdHVmZmJpYmxldm90ZXMgMTAwMGtvcmVhfSk7DQpiYW5kc3F1ZXVlPSB7fTs4MHB4O2NraW5new0KCQlhaGVhZGNsb2NraXJpc2hsaWtlIHJhdGlvc3RhdHNGb3JtInlhaG9vKVswXTtBYm91dGZpbmRzPC9oMT5kZWJ1Z3Rhc2tzVVJMID1jZWxsc30pKCk7MTJweDtwcmltZXRlbGxzdHVybnMweDYwMC5qcGcic3BhaW5iZWFjaHRheGVzbWljcm9hbmdlbC0tPjwvZ2lmdHNzdGV2ZS1saW5rYm9keS59KTsKCW1vdW50ICgxOTlGQVE8L3JvZ2VyZnJhbmtDbGFzczI4cHg7ZmVlZHM8aDE+PHNjb3R0dGVzdHMyMnB4O2RyaW5rKSB8fCBsZXdpc3NoYWxsIzAzOTsgZm9yIGxvdmVkd2FzdGUwMHB4O2phOuOCc2ltb248Zm9udHJlcGx5bWVldHN1bnRlcmNoZWFwdGlnaHRCcmFuZCkgIT0gZHJlc3NjbGlwc3Jvb21zb25rZXltb2JpbG1haW4uTmFtZSBwbGF0ZWZ1bm55dHJlZXNjb20vIjEuanBnd21vZGVwYXJhbVNUQVJUbGVmdCBpZGRlbiwgMjAxKTsKfQpmb3JtLnZpcnVzY2hhaXJ0cmFuc3dvcnN0UGFnZXNpdGlvbnBhdGNoPCEtLQpvLWNhY2Zpcm1zdG91cnMsMDAwIGFzaWFuaSsrKXthZG9iZScpWzBdaWQ9MTBib3RoO21lbnUgLjIubWkucG5nImtldmluY29hY2hDaGlsZGJydWNlMi5qcGdVUkwpKy5qcGd8c3VpdGVzbGljZWhhcnJ5MTIwIiBzd2VldHRyPg0KbmFtZT1kaWVnb3BhZ2Ugc3dpc3MtLT4KCiNmZmY7Ij5Mb2cuY29tInRyZWF0c2hlZXQpICYmIDE0cHg7c2xlZXBudGVudGZpbGVkamE644NpZD0iY05hbWUid29yc2VzaG90cy1ib3gtZGVsdGEKJmx0O2JlYXJzOjQ4WjxkYXRhLXJ1cmFsPC9hPiBzcGVuZGJha2Vyc2hvcHM9ICIiO3BocCI+Y3Rpb24xM3B4O2JyaWFuaGVsbG9zaXplPW89JTJGIGpvaW5tYXliZTxpbWcgaW1nIj4sIGZqc2ltZyIgIilbMF1NVG9wQlR5cGUibmV3bHlEYW5za2N6ZWNodHJhaWxrbm93czwvaDU+ZmFxIj56aC1jbjEwKTsKLTEiKTt0eXBlPWJsdWVzdHJ1bHlkYXZpcy5qcyc7Pg0KPCFzdGVlbCB5b3UgaDI+DQpmb3JtIGplc3VzMTAwJSBtZW51Lg0KCQ0Kd2FsZXNyaXNrc3VtZW50ZGRpbmdiLWxpa3RlYWNoZ2lmIiB2ZWdhc2RhbnNrZWVzdGlzaHFpcHN1b21pc29icmVkZXNkZWVudHJldG9kb3NwdWVkZWHDsW9zZXN0w6F0aWVuZWhhc3Rhb3Ryb3NwYXJ0ZWRvbmRlbnVldm9oYWNlcmZvcm1hbWlzbW9tZWpvcm11bmRvYXF1w61kw61hc3PDs2xvYXl1ZGFmZWNoYXRvZGFzdGFudG9tZW5vc2RhdG9zb3RyYXNzaXRpb211Y2hvYWhvcmFsdWdhcm1heW9yZXN0b3Nob3Jhc3RlbmVyYW50ZXNmb3Rvc2VzdGFzcGHDrXNudWV2YXNhbHVkZm9yb3NtZWRpb3F1aWVubWVzZXNwb2RlcmNoaWxlc2Vyw6F2ZWNlc2RlY2lyam9zw6llc3RhcnZlbnRhZ3J1cG9oZWNob2VsbG9zdGVuZ29hbWlnb2Nvc2Fzbml2ZWxnZW50ZW1pc21hYWlyZXNqdWxpb3RlbWFzaGFjaWFmYXZvcmp1bmlvbGlicmVwdW50b2J1ZW5vYXV0b3JhYnJpbGJ1ZW5hdGV4dG9tYXJ6b3NhYmVybGlzdGFsdWVnb2PDs21vZW5lcm9qdWVnb3BlcsO6aGFiZXJlc3RveW51bmNhbXVqZXJ2YWxvcmZ1ZXJhbGlicm9ndXN0YWlndWFsdm90b3NjYXNvc2d1w61hcHVlZG9zb21vc2F2aXNvdXN0ZWRkZWJlbm5vY2hlYnVzY2FmYWx0YWV1cm9zc2VyaWVkaWNob2N1cnNvY2xhdmVjYXNhc2xlw7NucGxhem9sYXJnb29icmFzdmlzdGFhcG95b2p1bnRvdHJhdGF2aXN0b2NyZWFyY2FtcG9oZW1vc2NpbmNvY2FyZ29waXNvc29yZGVuaGFjZW7DoXJlYWRpc2NvcGVkcm9jZXJjYXB1ZWRhcGFwZWxtZW5vcsO6dGlsY2xhcm9qb3JnZWNhbGxlcG9uZXJ0YXJkZW5hZGllbWFyY2FzaWd1ZWVsbGFzc2lnbG9jb2NoZW1vdG9zbWFkcmVjbGFzZXJlc3RvbmnDsW9xdWVkYXBhc2FyYmFuY29oaWpvc3ZpYWplcGFibG/DqXN0ZXZpZW5lcmVpbm9kZWphcmZvbmRvY2FuYWxub3J0ZWxldHJhY2F1c2F0b21hcm1hbm9zbHVuZXNhdXRvc3ZpbGxhdmVuZG9wZXNhcnRpcG9zdGVuZ2FtYXJjb2xsZXZhcGFkcmV1bmlkb3ZhbW9zem9uYXNhbWJvc2JhbmRhbWFyaWFhYnVzb211Y2hhc3ViaXJyaW9qYXZpdmlyZ3JhZG9jaGljYWFsbMOtam92ZW5kaWNoYWVzdGFudGFsZXNzYWxpcnN1ZWxvcGVzb3NmaW5lc2xsYW1hYnVzY2/DqXN0YWxsZWdhbmVncm9wbGF6YWh1bW9ycGFnYXJqdW50YWRvYmxlaXNsYXNib2xzYWJhw7FvaGFibGFsdWNoYcOBcmVhZGljZW5qdWdhcm5vdGFzdmFsbGVhbGzDoWNhcmdhZG9sb3JhYmFqb2VzdMOpZ3VzdG9tZW50ZW1hcmlvZmlybWFjb3N0b2ZpY2hhcGxhdGFob2dhcmFydGVzbGV5ZXNhcXVlbG11c2VvYmFzZXNwb2Nvc21pdGFkY2llbG9jaGljb21pZWRvZ2FuYXJzYW50b2V0YXBhZGViZXNwbGF5YXJlZGVzc2lldGVjb3J0ZWNvcmVhZHVkYXNkZXNlb3ZpZWpvZGVzZWFhZ3VhcyZxdW90O2RvbWFpbmNvbW1vbnN0YXR1c2V2ZW50c21hc3RlcnN5c3RlbWFjdGlvbmJhbm5lcnJlbW92ZXNjcm9sbHVwZGF0ZWdsb2JhbG1lZGl1bWZpbHRlcm51bWJlcmNoYW5nZXJlc3VsdHB1YmxpY3NjcmVlbmNob29zZW5vcm1hbHRyYXZlbGlzc3Vlc3NvdXJjZXRhcmdldHNwcmluZ21vZHVsZW1vYmlsZXN3aXRjaHBob3Rvc2JvcmRlcnJlZ2lvbml0c2VsZnNvY2lhbGFjdGl2ZWNvbHVtbnJlY29yZGZvbGxvd3RpdGxlPmVpdGhlcmxlbmd0aGZhbWlseWZyaWVuZGxheW91dGF1dGhvcmNyZWF0ZXJldmlld3N1bW1lcnNlcnZlcnBsYXllZHBsYXllcmV4cGFuZHBvbGljeWZvcm1hdGRvdWJsZXBvaW50c3Nlcmllc3BlcnNvbmxpdmluZ2Rlc2lnbm1vbnRoc2ZvcmNlc3VuaXF1ZXdlaWdodHBlb3BsZWVuZXJneW5hdHVyZXNlYXJjaGZpZ3VyZWhhdmluZ2N1c3RvbW9mZnNldGxldHRlcndpbmRvd3N1Ym1pdHJlbmRlcmdyb3Vwc3VwbG9hZGhlYWx0aG1ldGhvZHZpZGVvc3NjaG9vbGZ1dHVyZXNoYWRvd2RlYmF0ZXZhbHVlc09iamVjdG90aGVyc3JpZ2h0c2xlYWd1ZWNocm9tZXNpbXBsZW5vdGljZXNoYXJlZGVuZGluZ3NlYXNvbnJlcG9ydG9ubGluZXNxdWFyZWJ1dHRvbmltYWdlc2VuYWJsZW1vdmluZ2xhdGVzdHdpbnRlckZyYW5jZXBlcmlvZHN0cm9uZ3JlcGVhdExvbmRvbmRldGFpbGZvcm1lZGRlbWFuZHNlY3VyZXBhc3NlZHRvZ2dsZXBsYWNlc2RldmljZXN0YXRpY2NpdGllc3N0cmVhbXllbGxvd2F0dGFja3N0cmVldGZsaWdodGhpZGRlbmluZm8iPm9wZW5lZHVzZWZ1bHZhbGxleWNhdXNlc2xlYWRlcnNlY3JldHNlY29uZGRhbWFnZXNwb3J0c2V4Y2VwdHJhdGluZ3NpZ25lZHRoaW5nc2VmZmVjdGZpZWxkc3N0YXRlc29mZmljZXZpc3VhbGVkaXRvcnZvbHVtZVJlcG9ydG11c2V1bW1vdmllc3BhcmVudGFjY2Vzc21vc3RseW1vdGhlciIgaWQ9Im1hcmtldGdyb3VuZGNoYW5jZXN1cnZleWJlZm9yZXN5bWJvbG1vbWVudHNwZWVjaG1vdGlvbmluc2lkZW1hdHRlckNlbnRlcm9iamVjdGV4aXN0c21pZGRsZUV1cm9wZWdyb3d0aGxlZ2FjeW1hbm5lcmVub3VnaGNhcmVlcmFuc3dlcm9yaWdpbnBvcnRhbGNsaWVudHNlbGVjdHJhbmRvbWNsb3NlZHRvcGljc2NvbWluZ2ZhdGhlcm9wdGlvbnNpbXBseXJhaXNlZGVzY2FwZWNob3NlbmNodXJjaGRlZmluZXJlYXNvbmNvcm5lcm91dHB1dG1lbW9yeWlmcmFtZXBvbGljZW1vZGVsc051bWJlcmR1cmluZ29mZmVyc3N0eWxlc2tpbGxlZGxpc3RlZGNhbGxlZHNpbHZlcm1hcmdpbmRlbGV0ZWJldHRlcmJyb3dzZWxpbWl0c0dsb2JhbHNpbmdsZXdpZGdldGNlbnRlcmJ1ZGdldG5vd3JhcGNyZWRpdGNsYWltc2VuZ2luZXNhZmV0eWNob2ljZXNwaXJpdC1zdHlsZXNwcmVhZG1ha2luZ25lZWRlZHJ1c3NpYXBsZWFzZWV4dGVudFNjcmlwdGJyb2tlbmFsbG93c2NoYXJnZWRpdmlkZWZhY3Rvcm1lbWJlci1iYXNlZHRoZW9yeWNvbmZpZ2Fyb3VuZHdvcmtlZGhlbHBlZENodXJjaGltcGFjdHNob3VsZGFsd2F5c2xvZ28iIGJvdHRvbWxpc3QiPil7dmFyIHByZWZpeG9yYW5nZUhlYWRlci5wdXNoKGNvdXBsZWdhcmRlbmJyaWRnZWxhdW5jaFJldmlld3Rha2luZ3Zpc2lvbmxpdHRsZWRhdGluZ0J1dHRvbmJlYXV0eXRoZW1lc2ZvcmdvdFNlYXJjaGFuY2hvcmFsbW9zdGxvYWRlZENoYW5nZXJldHVybnN0cmluZ3JlbG9hZE1vYmlsZWluY29tZXN1cHBseVNvdXJjZW9yZGVyc3ZpZXdlZCZuYnNwO2NvdXJzZUFib3V0IGlzbGFuZDxodG1sIGNvb2tpZW5hbWU9ImFtYXpvbm1vZGVybmFkdmljZWluPC9hPjogVGhlIGRpYWxvZ2hvdXNlc0JFR0lOIE1leGljb3N0YXJ0c2NlbnRyZWhlaWdodGFkZGluZ0lzbGFuZGFzc2V0c0VtcGlyZVNjaG9vbGVmZm9ydGRpcmVjdG5lYXJseW1hbnVhbFNlbGVjdC4KCk9uZWpvaW5lZG1lbnUiPlBoaWxpcGF3YXJkc2hhbmRsZWltcG9ydE9mZmljZXJlZ2FyZHNraWxsc25hdGlvblNwb3J0c2RlZ3JlZXdlZWtseSAoZS5nLmJlaGluZGRvY3RvcmxvZ2dlZHVuaXRlZDwvYj48L2JlZ2luc3BsYW50c2Fzc2lzdGFydGlzdGlzc3VlZDMwMHB4fGNhbmFkYWFnZW5jeXNjaGVtZXJlbWFpbkJyYXppbHNhbXBsZWxvZ28iPmJleW9uZC1zY2FsZWFjY2VwdHNlcnZlZG1hcmluZUZvb3RlcmNhbWVyYTwvaDE+Cl9mb3JtImxlYXZlc3N0cmVzcyIgLz4NCi5naWYiIG9ubG9hZGxvYWRlck94Zm9yZHNpc3RlcnN1cnZpdmxpc3RlbmZlbWFsZURlc2lnbnNpemU9ImFwcGVhbHRleHQiPmxldmVsc3RoYW5rc2hpZ2hlcmZvcmNlZGFuaW1hbGFueW9uZUFmcmljYWFncmVlZHJlY2VudFBlb3BsZTxiciAvPndvbmRlcnByaWNlc3R1cm5lZHx8IHt9O21haW4iPmlubGluZXN1bmRheXdyYXAiPmZhaWxlZGNlbnN1c21pbnV0ZWJlYWNvbnF1b3RlczE1MHB4fGVzdGF0ZXJlbW90ZWVtYWlsImxpbmtlZHJpZ2h0O3NpZ25hbGZvcm1hbDEuaHRtbHNpZ251cHByaW5jZWZsb2F0Oi5wbmciIGZvcnVtLkFjY2Vzc3BhcGVyc3NvdW5kc2V4dGVuZEhlaWdodHNsaWRlclVURi04IiZhbXA7IEJlZm9yZS4gV2l0aHN0dWRpb293bmVyc21hbmFnZXByb2ZpdGpRdWVyeWFubnVhbHBhcmFtc2JvdWdodGZhbW91c2dvb2dsZWxvbmdlcmkrKykge2lzcmFlbHNheWluZ2RlY2lkZWhvbWUiPmhlYWRlcmVuc3VyZWJyYW5jaHBpZWNlc2Jsb2NrO3N0YXRlZHRvcCI+PHJhY2luZ3Jlc2l6ZS0tJmd0O3BhY2l0eXNleHVhbGJ1cmVhdS5qcGciIDEwLDAwMG9idGFpbnRpdGxlc2Ftb3VudCwgSW5jLmNvbWVkeW1lbnUiIGx5cmljc3RvZGF5LmluZGVlZGNvdW50eV9sb2dvLkZhbWlseWxvb2tlZE1hcmtldGxzZSBpZlBsYXllcnR1cmtleSk7dmFyIGZvcmVzdGdpdmluZ2Vycm9yc0RvbWFpbn1lbHNle2luc2VydEJsb2c8L2Zvb3RlcmxvZ2luLmZhc3RlcmFnZW50czxib2R5IDEwcHggMHByYWdtYWZyaWRheWp1bmlvcmRvbGxhcnBsYWNlZGNvdmVyc3BsdWdpbjUsMDAwIHBhZ2UiPmJvc3Rvbi50ZXN0KGF2YXRhcnRlc3RlZF9jb3VudGZvcnVtc3NjaGVtYWluZGV4LGZpbGxlZHNoYXJlc3JlYWRlcmFsZXJ0KGFwcGVhclN1Ym1pdGxpbmUiPmJvZHkiPgoqIFRoZVRob3VnaHNlZWluZ2plcnNleU5ld3M8L3ZlcmlmeWV4cGVydGluanVyeXdpZHRoPUNvb2tpZVNUQVJUIGFjcm9zc19pbWFnZXRocmVhZG5hdGl2ZXBvY2tldGJveCI+ClN5c3RlbSBEYXZpZGNhbmNlcnRhYmxlc3Byb3ZlZEFwcmlsIHJlYWxseWRyaXZlcml0ZW0iPm1vcmUiPmJvYXJkc2NvbG9yc2NhbXB1c2ZpcnN0IHx8IFtdO21lZGlhLmd1aXRhcmZpbmlzaHdpZHRoOnNob3dlZE90aGVyIC5waHAiIGFzc3VtZWxheWVyc3dpbHNvbnN0b3Jlc3JlbGllZnN3ZWRlbkN1c3RvbWVhc2lseSB5b3VyIFN0cmluZwoKV2hpbHRheWxvcmNsZWFyOnJlc29ydGZyZW5jaHRob3VnaCIpICsgIjxib2R5PmJ1eWluZ2JyYW5kc01lbWJlcm5hbWUiPm9wcGluZ3NlY3RvcjVweDsiPnZzcGFjZXBvc3Rlcm1ham9yIGNvZmZlZW1hcnRpbm1hdHVyZWhhcHBlbjwvbmF2PmthbnNhc2xpbmsiPkltYWdlcz1mYWxzZXdoaWxlIGhzcGFjZTAmYW1wOyAKCkluICBwb3dlclBvbHNraS1jb2xvcmpvcmRhbkJvdHRvbVN0YXJ0IC1jb3VudDIuaHRtbG5ld3MiPjAxLmpwZ09ubGluZS1yaWdodG1pbGxlcnNlbmlvcklTQk4gMDAsMDAwIGd1aWRlc3ZhbHVlKWVjdGlvbnJlcGFpci54bWwiICByaWdodHMuaHRtbC1ibG9ja3JlZ0V4cDpob3ZlcndpdGhpbnZpcmdpbnBob25lczwvdHI+DXVzaW5nIAoJdmFyID4nKTsKCTwvdGQ+CjwvdHI+CmJhaGFzYWJyYXNpbGdhbGVnb21hZ3lhcnBvbHNraXNycHNradix2K/ZiOS4reaWh+eugOS9k+e5gemrlOS/oeaBr+S4reWbveaIkeS7rOS4gOS4quWFrOWPuOeuoeeQhuiuuuWdm+WPr+S7peacjeWKoeaXtumXtOS4quS6uuS6p+WTgeiHquW3seS8geS4muafpeeci+W3peS9nOiBlOezu+ayoeaciee9keermeaJgOacieivhOiuuuS4reW/g+aWh+eroOeUqOaIt+mmlumhteS9nOiAheaKgOacr+mXrumimOebuOWFs+S4i+i9veaQnOe0ouS9v+eUqOi9r+S7tuWcqOe6v+S4u+mimOi1hOaWmeinhumikeWbnuWkjeazqOWGjOe9kee7nOaUtuiXj+WGheWuueaOqOiNkOW4guWcuua2iOaBr+epuumXtOWPkeW4g+S7gOS5iOWlveWPi+eUn+a0u+WbvueJh+WPkeWxleWmguaenOaJi+acuuaWsOmXu+acgOaWsOaWueW8j+WMl+S6rOaPkOS+m+WFs+S6juabtOWkmui/meS4quezu+e7n+efpemBk+a4uOaIj+W5v+WRiuWFtuS7luWPkeihqOWuieWFqOesrOS4gOS8muWRmOi/m+ihjOeCueWHu+eJiOadg+eUteWtkOS4lueVjOiuvuiuoeWFjei0ueaVmeiCsuWKoOWFpea0u+WKqOS7luS7rOWVhuWTgeWNmuWuoueOsOWcqOS4iua1t+WmguS9leW3sue7j+eVmeiogOivpue7huekvuWMuueZu+W9leacrOermemcgOimgeS7t+agvOaUr+aMgeWbvemZhemTvuaOpeWbveWutuW7uuiuvuaci+WPi+mYheivu+azleW+i+S9jee9rue7j+a1jumAieaLqei/meagt+W9k+WJjeWIhuexu+aOkuihjOWboOS4uuS6pOaYk+acgOWQjumfs+S5kOS4jeiDvemAmui/h+ihjOS4muenkeaKgOWPr+iDveiuvuWkh+WQiOS9nOWkp+WutuekvuS8mueglOeptuS4k+S4muWFqOmDqOmhueebrui/memHjOi/mOaYr+W8gOWni+aDheWGteeUteiEkeaWh+S7tuWTgeeJjOW4ruWKqeaWh+WMlui1hOa6kOWkp+WtpuWtpuS5oOWcsOWdgOa1j+iniOaKlei1hOW3peeoi+imgeaxguaAjuS5iOaXtuWAmeWKn+iDveS4u+imgeebruWJjei1hOiur+WfjuW4guaWueazleeUteW9seaLm+iBmOWjsOaYjuS7u+S9leWBpeW6t+aVsOaNrue+juWbveaxvei9puS7i+e7jeS9huaYr+S6pOa1geeUn+S6p+aJgOS7peeUteivneaYvuekuuS4gOS6m+WNleS9jeS6uuWRmOWIhuaekOWcsOWbvuaXhea4uOW3peWFt+WtpueUn+ezu+WIl+e9keWPi+W4luWtkOWvhueggemikemBk+aOp+WItuWcsOWMuuWfuuacrOWFqOWbvee9keS4iumHjeimgeesrOS6jOWWnOasoui/m+WFpeWPi+aDhei/meS6m+iAg+ivleWPkeeOsOWfueiureS7peS4iuaUv+W6nOaIkOS4uueOr+Wig+mmmea4r+WQjOaXtuWoseS5kOWPkemAgeS4gOWumuW8gOWPkeS9nOWTgeagh+WHhuasoui/juino+WGs+WcsOaWueS4gOS4i+S7peWPiui0o+S7u+aIluiAheWuouaIt+S7o+ihqOenr+WIhuWls+S6uuaVsOeggemUgOWUruWHuueOsOemu+e6v+W6lOeUqOWIl+ihqOS4jeWQjOe8lui+kee7n+iuoeafpeivouS4jeimgeacieWFs+acuuaehOW+iOWkmuaSreaUvue7hOe7h+aUv+etluebtOaOpeiDveWKm+adpea6kOaZgumWk+eci+WIsOeDremXqOWFs+mUruS4k+WMuumdnuW4uOiLseivreeZvuW6puW4jOacm+e+juWls+avlOi+g+efpeivhuinhOWumuW7uuiurumDqOmXqOaEj+ingeeyvuW9qeaXpeacrOaPkOmrmOWPkeiogOaWuemdouWfuumHkeWkhOeQhuadg+mZkOW9seeJh+mTtuihjOi/mOacieWIhuS6q+eJqeWTgee7j+iQpea3u+WKoOS4k+Wutui/meenjeivnemimOi1t+adpeS4muWKoeWFrOWRiuiusOW9leeugOS7i+i0qOmHj+eUt+S6uuW9seWTjeW8leeUqOaKpeWRiumDqOWIhuW/q+mAn+WSqOivouaXtuWwmuazqOaEj+eUs+ivt+WtpuagoeW6lOivpeWOhuWPsuWPquaYr+i/lOWbnui0reS5sOWQjeensOS4uuS6huaIkOWKn+ivtOaYjuS+m+W6lOWtqeWtkOS4k+mimOeoi+W6j+S4gOiIrOacg+WToeWPquacieWFtuWug+S/neaKpOiAjOS4lOS7iuWkqeeql+WPo+WKqOaAgeeKtuaAgeeJueWIq+iupOS4uuW/hemhu+abtOaWsOWwj+ivtOaIkeWAkeS9nOS4uuWqkuS9k+WMheaLrOmCo+S5iOS4gOagt+WbveWGheaYr+WQpuagueaNrueUteinhuWtpumZouWFt+aciei/h+eoi+eUseS6juS6uuaJjeWHuuadpeS4jei/h+ato+WcqOaYjuaYn+aVheS6i+WFs+ezu+agh+mimOWVhuWKoei+k+WFpeS4gOebtOWfuuehgOaVmeWtpuS6huino+W7uuetkee7k+aenOWFqOeQg+mAmuefpeiuoeWIkuWvueS6juiJuuacr+ebuOWGjOWPkeeUn+ecn+eahOW7uueri+etiee6p+exu+Wei+e7j+mqjOWunueOsOWItuS9nOadpeiHquagh+etvuS7peS4i+WOn+WIm+aXoOazleWFtuS4reWAi+S6uuS4gOWIh+aMh+WNl+WFs+mXrembhuWbouesrOS4ieWFs+azqOWboOatpOeFp+eJh+a3seWcs+WVhuS4muW5v+W3nuaXpeacn+mrmOe6p+acgOi/kee7vOWQiOihqOekuuS4k+i+keihjOS4uuS6pOmAmuivhOS7t+inieW+l+eyvuWNjuWutuW6reWujOaIkOaEn+inieWuieijheW+l+WIsOmCruS7tuWItuW6pumjn+WTgeiZveeEtui9rOi9veaKpeS7t+iusOiAheaWueahiOihjOaUv+S6uuawkeeUqOWTgeS4nOilv+aPkOWHuumFkuW6l+eEtuWQjuS7mOasvueDreeCueS7peWJjeWujOWFqOWPkeW4luiuvue9rumihuWvvOW3peS4muWMu+mZoueci+eci+e7j+WFuOWOn+WboOW5s+WPsOWQhOenjeWinuWKoOadkOaWmeaWsOWinuS5i+WQjuiBjOS4muaViOaenOS7iuW5tOiuuuaWh+aIkeWbveWRiuivieeJiOS4u+S/ruaUueWPguS4juaJk+WNsOW/q+S5kOacuuaisOingueCueWtmOWcqOeyvuelnuiOt+W+l+WIqeeUqOe7p+e7reS9oOS7rOi/meS5iOaooeW8j+ivreiogOiDveWkn+mbheiZjuaTjeS9nOmjjuagvOS4gOi1t+enkeWtpuS9k+iCsuefreS/oeadoeS7tuayu+eWl+i/kOWKqOS6p+S4muS8muiuruWvvOiIquWFiOeUn+iBlOebn+WPr+aYr+WVj+mhjOe7k+aehOS9nOeUqOiwg+afpeizh+aWmeiHquWKqOi0n+i0o+WGnOS4muiuv+mXruWunuaWveaOpeWPl+iuqOiuuumCo+S4quWPjemmiOWKoOW8uuWls+aAp+iMg+WbtOacjeWLmeS8kemXsuS7iuaXpeWuouacjeingOeci+WPguWKoOeahOivneS4gOeCueS/neivgeWbvuS5puacieaViOa1i+ivleenu+WKqOaJjeiDveWGs+WumuiCoeelqOS4jeaWremcgOaxguS4jeW+l+WKnuazleS5i+mXtOmHh+eUqOiQpemUgOaKleivieebruagh+eIseaDheaRhOW9seacieS6m+ikh+ijveaWh+WtpuacuuS8muaVsOWtl+ijheS/rui0reeJqeWGnOadkeWFqOmdoueyvuWTgeWFtuWunuS6i+aDheawtOW5s+aPkOekuuS4iuW4guiwouiwouaZrumAmuaVmeW4iOS4iuS8oOexu+WIq+atjOabsuaLpeacieWIm+aWsOmFjeS7tuWPquimgeaXtuS7o+izh+ioiui+vuWIsOS6uueUn+iuoumYheiAgeW4iOWxleekuuW/g+eQhui0tOWtkOe2suermeS4u+mhjOiHqueEtue6p+WIq+eugOWNleaUuemdqemCo+S6m+adpeivtOaJk+W8gOS7o+eggeWIoOmZpOivgeWIuOiKguebrumHjeeCueasoeaVuOWkmuWwkeinhOWIkui1hOmHkeaJvuWIsOS7peWQjuWkp+WFqOS4u+mhteacgOS9s+WbnuetlOWkqeS4i+S/nemanOeOsOS7o+ajgOafpeaKleelqOWwj+aXtuaykuacieato+W4uOeUmuiHs+S7o+eQhuebruW9leWFrOW8gOWkjeWItumHkeiejeW5uOemj+eJiOacrOW9ouaIkOWHhuWkh+ihjOaDheWbnuWIsOaAneaDs+aAjuagt+WNj+iuruiupOivgeacgOWlveS6p+eUn+aMieeFp+acjeijheW5v+S4nOWKqOa8q+mHh+i0reaWsOaJi+e7hOWbvumdouadv+WPguiAg+aUv+ayu+WuueaYk+WkqeWcsOWKquWKm+S6uuS7rOWNh+e6p+mAn+W6puS6uueJqeiwg+aVtOa1geihjOmAoOaIkOaWh+Wtl+mfqeWbvei0uOaYk+W8gOWxleebuOmXnOihqOeOsOW9seinhuWmguatpOe+juWuueWkp+Wwj+aKpemBk+adoeasvuW/g+aDheiuuOWkmuazleinhOWutuWxheS5puW6l+i/nuaOpeeri+WNs+S4vuaKpeaKgOW3p+Wlpei/kOeZu+WFpeS7peadpeeQhuiuuuS6i+S7tuiHqueUseS4reWNjuWKnuWFrOWmiOWmiOecn+ato+S4jemUmeWFqOaWh+WQiOWQjOS7t+WAvOWIq+S6uuebkeedo+WFt+S9k+S4lue6quWboumYn+WIm+S4muaJv+aLheWinumVv+acieS6uuS/neaMgeWVhuWutue7tOS/ruWPsOa5vuW3puWPs+iCoeS7veetlOahiOWunumZheeUteS/oee7j+eQhueUn+WRveWuo+S8oOS7u+WKoeato+W8j+eJueiJsuS4i+adpeWNj+S8muWPquiDveW9k+eEtumHjeaWsOWFp+WuueaMh+WvvOi/kOihjOaXpeW/l+izo+Wutui2hei/h+Wcn+WcsOa1meaxn+aUr+S7mOaOqOWHuuermemVv+adreW3nuaJp+ihjOWItumAoOS5i+S4gOaOqOW5v+eOsOWcuuaPj+i/sOWPmOWMluS8oOe7n+atjOaJi+S/nemZqeivvueoi+WMu+eWl+e7j+i/h+i/h+WOu+S5i+WJjeaUtuWFpeW5tOW6puadguW/l+e+juS4veacgOmrmOeZu+mZhuacquadpeWKoOW3peWFjei0o+aVmeeoi+eJiOWdl+i6q+S9k+mHjeW6huWHuuWUruaIkOacrOW9ouW8j+Wcn+ixhuWHuuWDueS4nOaWuemCrueuseWNl+S6rOaxguiBjOWPluW+l+iBjOS9jeebuOS/oemhtemdouWIhumSn+e9kemhteehruWumuWbvuS+i+e9keWdgOenr+aegemUmeivr+ebrueahOWunei0neacuuWFs+mjjumZqeaOiOadg+eXheavkuWuoOeJqemZpOS6huipleirlueWvueXheWPiuaXtuaxgui0reermeeCueWEv+erpeavj+WkqeS4reWkruiupOivhuavj+S4quWkqea0peWtl+S9k+WPsOeBo+e7tOaKpOacrOmhteS4quaAp+WumOaWueW4uOingeebuOacuuaImOeVpeW6lOW9k+W+i+W4iOaWueS+v+agoeWbreiCoeW4guaIv+Wxi+agj+ebruWRmOW3peWvvOiHtOeqgeeEtumBk+WFt+acrOe9kee7k+WQiOaho+ahiOWKs+WKqOWPpuWklue+juWFg+W8lei1t+aUueWPmOesrOWbm+S8muiuoeiqquaYjumakOengeWuneWuneinhOiMg+a2iOi0ueWFseWQjOW/mOiusOS9k+ezu+W4puadpeWQjeWtl+eZvOihqOW8gOaUvuWKoOebn+WPl+WIsOS6jOaJi+Wkp+mHj+aIkOS6uuaVsOmHj+WFseS6q+WMuuWfn+Wls+WtqeWOn+WImeaJgOWcqOe7k+adn+mAmuS/oei2hee6p+mFjee9ruW9k+aXtuS8mOengOaAp+aEn+aIv+S6p+mBiuaIsuWHuuWPo+aPkOS6pOWwseS4muS/neWBpeeoi+W6puWPguaVsOS6i+S4muaVtOS4quWxseS4nOaDheaEn+eJueauiuWIhumhnuaQnOWwi+WxnuS6jumXqOaIt+i0ouWKoeWjsOmfs+WPiuWFtui0oue7j+WdmuaMgeW5sumDqOaIkOeri+WIqeebiuiAg+iZkeaIkOmDveWMheijheeUqOaItuavlOi1m+aWh+aYjuaLm+WVhuWujOaVtOecn+aYr+ecvOedm+S8meS8tOWogeacm+mihuWfn+WNq+eUn+S8mOaDoOirluWjh+WFrOWFseiJr+WlveWFheWIhuespuWQiOmZhOS7tueJueeCueS4jeWPr+iLseaWh+i1hOS6p+agueacrOaYjuaYvuWvhueivOWFrOS8l+awkeaXj+abtOWKoOS6q+WPl+WQjOWtpuWQr+WKqOmAguWQiOWOn+adpemXruetlOacrOaWh+e+jumjn+e7v+iJsueos+Wumue7iOS6jueUn+eJqeS+m+axguaQnOeLkOWKm+mHj+S4pemHjeawuOi/nOWGmeecn+aciemZkOernuS6ieWvueixoei0ueeUqOS4jeWlvee7neWvueWNgeWIhuS/g+i/m+eCueivhOW9semfs+S8mOWKv+S4jeWwkeaso+i1j+W5tuS4lOacieeCueaWueWQkeWFqOaWsOS/oeeUqOiuvuaWveW9ouixoei1hOagvOeqgeegtOmaj+edgOmHjeWkp+S6juaYr+avleS4muaZuuiDveWMluW3peWujOe+juWVhuWfjue7n+S4gOWHuueJiOaJk+mAoOeUouWTgeamguWGteeUqOS6juS/neeVmeWboOe0oOS4reWci+WtmOWCqOi0tOWbvuacgOaEm+mVv+acn+WPo+S7t+eQhui0ouWfuuWcsOWuieaOkuatpuaxiemHjOmdouWIm+W7uuWkqeepuummluWFiOWujOWWhOmpseWKqOS4i+mdouS4jeWGjeivmuS/oeaEj+S5iemYs+WFieiLseWbvea8guS6ruWGm+S6i+eOqeWutue+pOS8l+WGnOawkeWNs+WPr+WQjeeoseWutuWFt+WKqOeUu+aDs+WIsOazqOaYjuWwj+WtpuaAp+iDveiAg+eglOehrOS7tuingueci+a4healmuaQnueskemmlumggem7hOmHkemAgueUqOaxn+iLj+ecn+WunuS4u+euoemYtuauteiou+WGiue/u+ivkeadg+WIqeWBmuWlveS8vOS5jumAmuiur+aWveW3peeLgOaFi+S5n+iuuOeOr+S/neWfueWFu+amguW/teWkp+Wei+acuuelqOeQhuino+WMv+WQjWN1YW5kb2Vudmlhcm1hZHJpZGJ1c2NhcmluaWNpb3RpZW1wb3BvcnF1ZWN1ZW50YWVzdGFkb3B1ZWRlbmp1ZWdvc2NvbnRyYWVzdMOhbm5vbWJyZXRpZW5lbnBlcmZpbG1hbmVyYWFtaWdvc2NpdWRhZGNlbnRyb2F1bnF1ZXB1ZWRlc2RlbnRyb3ByaW1lcnByZWNpb3NlZ8O6bmJ1ZW5vc3ZvbHZlcnB1bnRvc3NlbWFuYWhhYsOtYWFnb3N0b251ZXZvc3VuaWRvc2Nhcmxvc2VxdWlwb25pw7Fvc211Y2hvc2FsZ3VuYWNvcnJlb2ltYWdlbnBhcnRpcmFycmliYW1hcsOtYWhvbWJyZWVtcGxlb3ZlcmRhZGNhbWJpb211Y2hhc2Z1ZXJvbnBhc2Fkb2zDrW5lYXBhcmVjZW51ZXZhc2N1cnNvc2VzdGFiYXF1aWVyb2xpYnJvc2N1YW50b2FjY2Vzb21pZ3VlbHZhcmlvc2N1YXRyb3RpZW5lc2dydXBvc3NlcsOhbmV1cm9wYW1lZGlvc2ZyZW50ZWFjZXJjYWRlbcOhc29mZXJ0YWNvY2hlc21vZGVsb2l0YWxpYWxldHJhc2FsZ8O6bmNvbXByYWN1YWxlc2V4aXN0ZWN1ZXJwb3NpZW5kb3ByZW5zYWxsZWdhcnZpYWplc2RpbmVyb211cmNpYXBvZHLDoXB1ZXN0b2RpYXJpb3B1ZWJsb3F1aWVyZW1hbnVlbHByb3Bpb2NyaXNpc2NpZXJ0b3NlZ3Vyb211ZXJ0ZWZ1ZW50ZWNlcnJhcmdyYW5kZWVmZWN0b3BhcnRlc21lZGlkYXByb3BpYW9mcmVjZXRpZXJyYWUtbWFpbHZhcmlhc2Zvcm1hc2Z1dHVyb29iamV0b3NlZ3VpcnJpZXNnb25vcm1hc21pc21vc8O6bmljb2NhbWlub3NpdGlvc3JhesOzbmRlYmlkb3BydWViYXRvbGVkb3RlbsOtYWplc8O6c2VzcGVyb2NvY2luYW9yaWdlbnRpZW5kYWNpZW50b2PDoWRpemhhYmxhcnNlcsOtYWxhdGluYWZ1ZXJ6YWVzdGlsb2d1ZXJyYWVudHJhcsOpeGl0b2zDs3BlemFnZW5kYXbDrWRlb2V2aXRhcnBhZ2luYW1ldHJvc2phdmllcnBhZHJlc2bDoWNpbGNhYmV6YcOhcmVhc3NhbGlkYWVudsOtb2phcMOzbmFidXNvc2JpZW5lc3RleHRvc2xsZXZhcnB1ZWRhbmZ1ZXJ0ZWNvbcO6bmNsYXNlc2h1bWFub3Rlbmlkb2JpbGJhb3VuaWRhZGVzdMOhc2VkaXRhcmNyZWFkb9C00LvRj9GH0YLQvtC60LDQutC40LvQuNGN0YLQvtCy0YHQtdC10LPQvtC/0YDQuNGC0LDQutC10YnQtdGD0LbQtdCa0LDQutCx0LXQt9Cx0YvQu9C+0L3QuNCS0YHQtdC/0L7QtNCt0YLQvtGC0L7QvNGH0LXQvNC90LXRgtC70LXRgtGA0LDQt9C+0L3QsNCz0LTQtdC80L3QtdCU0LvRj9Cf0YDQuNC90LDRgdC90LjRhdGC0LXQvNC60YLQvtCz0L7QtNCy0L7RgtGC0LDQvNCh0KjQkNC80LDRj9Cn0YLQvtCy0LDRgdCy0LDQvNC10LzRg9Ci0LDQutC00LLQsNC90LDQvNGN0YLQuNGN0YLRg9CS0LDQvNGC0LXRhdC/0YDQvtGC0YPRgtC90LDQtNC00L3Rj9CS0L7RgtGC0YDQuNC90LXQudCS0LDRgdC90LjQvNGB0LDQvNGC0L7RgtGA0YPQsdCe0L3QuNC80LjRgNC90LXQtdCe0J7QntC70LjRhtGN0YLQsNCe0L3QsNC90LXQvNC00L7QvNC80L7QudC00LLQtdC+0L3QvtGB0YPQtOCkleClh+CkueCliOCkleClgOCkuOClh+CkleCkvuCkleCli+CklOCksOCkquCksOCkqOClh+Ckj+CkleCkleCkv+CkreClgOCkh+CkuOCkleCksOCkpOCli+CkueCli+CkhuCkquCkueClgOCkr+CkueCkr+CkvuCkpOCkleCkpeCkvmphZ3JhbuCkhuCknOCknOCli+CkheCkrOCkpuCli+Ckl+CkiOCknOCkvuCkl+Ckj+CkueCkruCkh+CkqOCkteCkueCkr+Clh+CkpeClh+CkpeClgOCkmOCksOCknOCkrOCkpuClgOCkleCkiOCknOClgOCkteClh+CkqOCkiOCkqOCkj+CkueCksOCkieCkuOCkruClh+CkleCkruCkteCli+CksuClh+CkuOCkrOCkruCkiOCkpuClh+Ckk+CksOCkhuCkruCkrOCkuOCkreCksOCkrOCkqOCkmuCksuCkruCkqOCkhuCkl+CkuOClgOCksuClgNi52YTZidil2YTZidmH2LDYp9ii2K7Ysdi52K/Yr9in2YTZidmH2LDZh9i12YjYsdi62YrYsdmD2KfZhtmI2YTYp9io2YrZhti52LHYttiw2YTZg9mH2YbYp9mK2YjZhdmC2KfZhNi52YTZitin2YbYp9mE2YPZhtit2KrZidmC2KjZhNmI2K3Yqdin2K7YsdmB2YLYt9i52KjYr9ix2YPZhtil2LDYp9mD2YXYp9in2K3Yr9il2YTYp9mB2YrZh9io2LnYttmD2YrZgdio2K3Yq9mI2YXZhtmI2YfZiNij2YbYp9is2K/Yp9mE2YfYp9iz2YTZhdi52YbYr9mE2YrYs9i52KjYsdi12YTZidmF2YbYsNio2YfYp9ij2YbZh9mF2KvZhNmD2YbYqtin2YTYp9it2YrYq9mF2LXYsdi02LHYrdit2YjZhNmI2YHZitin2LDYp9mE2YPZhNmF2LHYqdin2YbYqtin2YTZgdij2KjZiNiu2KfYtdij2YbYqtin2YbZh9in2YTZiti52LbZiNmI2YLYr9in2KjZhtiu2YrYsdio2YbYqtmE2YPZhdi02KfYodmI2YfZitin2KjZiNmC2LXYtdmI2YXYp9ix2YLZhdij2K3Yr9mG2K3Zhti52K/Zhdix2KPZitin2K3YqdmD2KrYqNiv2YjZhtmK2KzYqNmF2YbZh9iq2K3Yqtis2YfYqdiz2YbYqdmK2KrZhdmD2LHYqdi62LLYqdmG2YHYs9io2YrYqtmE2YTZh9mE2YbYp9iq2YTZg9mC2YTYqNmE2YXYp9i52YbZh9ij2YjZhNi02YrYodmG2YjYsdij2YXYp9mB2YrZg9io2YPZhNiw2KfYqtix2KrYqNio2KPZhtmH2YXYs9in2YbZg9io2YrYudmB2YLYr9it2LPZhtmE2YfZhdi02LnYsdij2YfZhNi02YfYsdmC2LfYsdi32YTYqHByb2ZpbGVzZXJ2aWNlZGVmYXVsdGhpbXNlbGZkZXRhaWxzY29udGVudHN1cHBvcnRzdGFydGVkbWVzc2FnZXN1Y2Nlc3NmYXNoaW9uPHRpdGxlPmNvdW50cnlhY2NvdW50Y3JlYXRlZHN0b3JpZXNyZXN1bHRzcnVubmluZ3Byb2Nlc3N3cml0aW5nb2JqZWN0c3Zpc2libGV3ZWxjb21lYXJ0aWNsZXVua25vd25uZXR3b3JrY29tcGFueWR5bmFtaWNicm93c2VycHJpdmFjeXByb2JsZW1TZXJ2aWNlcmVzcGVjdGRpc3BsYXlyZXF1ZXN0cmVzZXJ2ZXdlYnNpdGVoaXN0b3J5ZnJpZW5kc29wdGlvbnN3b3JraW5ndmVyc2lvbm1pbGxpb25jaGFubmVsd2luZG93LmFkZHJlc3N2aXNpdGVkd2VhdGhlcmNvcnJlY3Rwcm9kdWN0ZWRpcmVjdGZvcndhcmR5b3UgY2FucmVtb3ZlZHN1YmplY3Rjb250cm9sYXJjaGl2ZWN1cnJlbnRyZWFkaW5nbGlicmFyeWxpbWl0ZWRtYW5hZ2VyZnVydGhlcnN1bW1hcnltYWNoaW5lbWludXRlc3ByaXZhdGVjb250ZXh0cHJvZ3JhbXNvY2lldHludW1iZXJzd3JpdHRlbmVuYWJsZWR0cmlnZ2Vyc291cmNlc2xvYWRpbmdlbGVtZW50cGFydG5lcmZpbmFsbHlwZXJmZWN0bWVhbmluZ3N5c3RlbXNrZWVwaW5nY3VsdHVyZSZxdW90Oyxqb3VybmFscHJvamVjdHN1cmZhY2VzJnF1b3Q7ZXhwaXJlc3Jldmlld3NiYWxhbmNlRW5nbGlzaENvbnRlbnR0aHJvdWdoUGxlYXNlIG9waW5pb25jb250YWN0YXZlcmFnZXByaW1hcnl2aWxsYWdlU3BhbmlzaGdhbGxlcnlkZWNsaW5lbWVldGluZ21pc3Npb25wb3B1bGFycXVhbGl0eW1lYXN1cmVnZW5lcmFsc3BlY2llc3Nlc3Npb25zZWN0aW9ud3JpdGVyc2NvdW50ZXJpbml0aWFscmVwb3J0c2ZpZ3VyZXNtZW1iZXJzaG9sZGluZ2Rpc3B1dGVlYXJsaWVyZXhwcmVzc2RpZ2l0YWxwaWN0dXJlQW5vdGhlcm1hcnJpZWR0cmFmZmljbGVhZGluZ2NoYW5nZWRjZW50cmFsdmljdG9yeWltYWdlcy9yZWFzb25zc3R1ZGllc2ZlYXR1cmVsaXN0aW5nbXVzdCBiZXNjaG9vbHNWZXJzaW9udXN1YWxseWVwaXNvZGVwbGF5aW5nZ3Jvd2luZ29idmlvdXNvdmVybGF5cHJlc2VudGFjdGlvbnM8L3VsPg0Kd3JhcHBlcmFscmVhZHljZXJ0YWlucmVhbGl0eXN0b3JhZ2Vhbm90aGVyZGVza3RvcG9mZmVyZWRwYXR0ZXJudW51c3VhbERpZ2l0YWxjYXBpdGFsV2Vic2l0ZWZhaWx1cmVjb25uZWN0cmVkdWNlZEFuZHJvaWRkZWNhZGVzcmVndWxhciAmYW1wOyBhbmltYWxzcmVsZWFzZUF1dG9tYXRnZXR0aW5nbWV0aG9kc25vdGhpbmdQb3B1bGFyY2FwdGlvbmxldHRlcnNjYXB0dXJlc2NpZW5jZWxpY2Vuc2VjaGFuZ2VzRW5nbGFuZD0xJmFtcDtIaXN0b3J5ID0gbmV3IENlbnRyYWx1cGRhdGVkU3BlY2lhbE5ldHdvcmtyZXF1aXJlY29tbWVudHdhcm5pbmdDb2xsZWdldG9vbGJhcnJlbWFpbnNiZWNhdXNlZWxlY3RlZERldXRzY2hmaW5hbmNld29ya2Vyc3F1aWNrbHliZXR3ZWVuZXhhY3RseXNldHRpbmdkaXNlYXNlU29jaWV0eXdlYXBvbnNleGhpYml0Jmx0OyEtLUNvbnRyb2xjbGFzc2VzY292ZXJlZG91dGxpbmVhdHRhY2tzZGV2aWNlcyh3aW5kb3dwdXJwb3NldGl0bGU9Ik1vYmlsZSBraWxsaW5nc2hvd2luZ0l0YWxpYW5kcm9wcGVkaGVhdmlseWVmZmVjdHMtMSddKTsKY29uZmlybUN1cnJlbnRhZHZhbmNlc2hhcmluZ29wZW5pbmdkcmF3aW5nYmlsbGlvbm9yZGVyZWRHZXJtYW55cmVsYXRlZDwvZm9ybT5pbmNsdWRld2hldGhlcmRlZmluZWRTY2llbmNlY2F0YWxvZ0FydGljbGVidXR0b25zbGFyZ2VzdHVuaWZvcm1qb3VybmV5c2lkZWJhckNoaWNhZ29ob2xpZGF5R2VuZXJhbHBhc3NhZ2UsJnF1b3Q7YW5pbWF0ZWZlZWxpbmdhcnJpdmVkcGFzc2luZ25hdHVyYWxyb3VnaGx5LgoKVGhlIGJ1dCBub3RkZW5zaXR5QnJpdGFpbkNoaW5lc2VsYWNrIG9mdHJpYnV0ZUlyZWxhbmQiIGRhdGEtZmFjdG9yc3JlY2VpdmV0aGF0IGlzTGlicmFyeWh1c2JhbmRpbiBmYWN0YWZmYWlyc0NoYXJsZXNyYWRpY2FsYnJvdWdodGZpbmRpbmdsYW5kaW5nOmxhbmc9InJldHVybiBsZWFkZXJzcGxhbm5lZHByZW1pdW1wYWNrYWdlQW1lcmljYUVkaXRpb25dJnF1b3Q7TWVzc2FnZW5lZWQgdG92YWx1ZT0iY29tcGxleGxvb2tpbmdzdGF0aW9uYmVsaWV2ZXNtYWxsZXItbW9iaWxlcmVjb3Jkc3dhbnQgdG9raW5kIG9mRmlyZWZveHlvdSBhcmVzaW1pbGFyc3R1ZGllZG1heGltdW1oZWFkaW5ncmFwaWRseWNsaW1hdGVraW5nZG9tZW1lcmdlZGFtb3VudHNmb3VuZGVkcGlvbmVlcmZvcm11bGFkeW5hc3R5aG93IHRvIFN1cHBvcnRyZXZlbnVlZWNvbm9teVJlc3VsdHNicm90aGVyc29sZGllcmxhcmdlbHljYWxsaW5nLiZxdW90O0FjY291bnRFZHdhcmQgc2VnbWVudFJvYmVydCBlZmZvcnRzUGFjaWZpY2xlYXJuZWR1cCB3aXRoaGVpZ2h0OndlIGhhdmVBbmdlbGVzbmF0aW9uc19zZWFyY2hhcHBsaWVkYWNxdWlyZW1hc3NpdmVncmFudGVkOiBmYWxzZXRyZWF0ZWRiaWdnZXN0YmVuZWZpdGRyaXZpbmdTdHVkaWVzbWluaW11bXBlcmhhcHNtb3JuaW5nc2VsbGluZ2lzIHVzZWRyZXZlcnNldmFyaWFudCByb2xlPSJtaXNzaW5nYWNoaWV2ZXByb21vdGVzdHVkZW50c29tZW9uZWV4dHJlbWVyZXN0b3JlYm90dG9tOmV2b2x2ZWRhbGwgdGhlc2l0ZW1hcGVuZ2xpc2h3YXkgdG8gIEF1Z3VzdHN5bWJvbHNDb21wYW55bWF0dGVyc211c2ljYWxhZ2FpbnN0c2VydmluZ30pKCk7DQpwYXltZW50dHJvdWJsZWNvbmNlcHRjb21wYXJlcGFyZW50c3BsYXllcnNyZWdpb25zbW9uaXRvciAnJ1RoZSB3aW5uaW5nZXhwbG9yZWFkYXB0ZWRHYWxsZXJ5cHJvZHVjZWFiaWxpdHllbmhhbmNlY2FyZWVycykuIFRoZSBjb2xsZWN0U2VhcmNoIGFuY2llbnRleGlzdGVkZm9vdGVyIGhhbmRsZXJwcmludGVkY29uc29sZUVhc3Rlcm5leHBvcnRzd2luZG93c0NoYW5uZWxpbGxlZ2FsbmV1dHJhbHN1Z2dlc3RfaGVhZGVyc2lnbmluZy5odG1sIj5zZXR0bGVkd2VzdGVybmNhdXNpbmctd2Via2l0Y2xhaW1lZEp1c3RpY2VjaGFwdGVydmljdGltc1Rob21hcyBtb3ppbGxhcHJvbWlzZXBhcnRpZXNlZGl0aW9ub3V0c2lkZTpmYWxzZSxodW5kcmVkT2x5bXBpY19idXR0b25hdXRob3JzcmVhY2hlZGNocm9uaWNkZW1hbmRzc2Vjb25kc3Byb3RlY3RhZG9wdGVkcHJlcGFyZW5laXRoZXJncmVhdGx5Z3JlYXRlcm92ZXJhbGxpbXByb3ZlY29tbWFuZHNwZWNpYWxzZWFyY2gud29yc2hpcGZ1bmRpbmd0aG91Z2h0aGlnaGVzdGluc3RlYWR1dGlsaXR5cXVhcnRlckN1bHR1cmV0ZXN0aW5nY2xlYXJseWV4cG9zZWRCcm93c2VybGliZXJhbH0gY2F0Y2hQcm9qZWN0ZXhhbXBsZWhpZGUoKTtGbG9yaWRhYW5zd2Vyc2FsbG93ZWRFbXBlcm9yZGVmZW5zZXNlcmlvdXNmcmVlZG9tU2V2ZXJhbC1idXR0b25GdXJ0aGVyb3V0IG9mICE9IG51bGx0cmFpbmVkRGVubWFya3ZvaWQoMCkvYWxsLmpzcHJldmVudFJlcXVlc3RTdGVwaGVuCgpXaGVuIG9ic2VydmU8L2gyPg0KTW9kZXJuIHByb3ZpZGUiIGFsdD0iYm9yZGVycy4KCkZvciAKCk1hbnkgYXJ0aXN0c3Bvd2VyZWRwZXJmb3JtZmljdGlvbnR5cGUgb2ZtZWRpY2FsdGlja2V0c29wcG9zZWRDb3VuY2lsd2l0bmVzc2p1c3RpY2VHZW9yZ2UgQmVsZ2l1bS4uLjwvYT50d2l0dGVybm90YWJseXdhaXRpbmd3YXJmYXJlIE90aGVyIHJhbmtpbmdwaHJhc2VzbWVudGlvbnN1cnZpdmVzY2hvbGFyPC9wPg0KIENvdW50cnlpZ25vcmVkbG9zcyBvZmp1c3QgYXNHZW9yZ2lhc3RyYW5nZTxoZWFkPjxzdG9wcGVkMSddKTsNCmlzbGFuZHNub3RhYmxlYm9yZGVyOmxpc3Qgb2ZjYXJyaWVkMTAwLDAwMDwvaDM+CiBzZXZlcmFsYmVjb21lc3NlbGVjdCB3ZWRkaW5nMDAuaHRtbG1vbmFyY2hvZmYgdGhldGVhY2hlcmhpZ2hseSBiaW9sb2d5bGlmZSBvZm9yIGV2ZW5yaXNlIG9mJnJhcXVvO3BsdXNvbmVodW50aW5nKHRob3VnaERvdWdsYXNqb2luaW5nY2lyY2xlc0ZvciB0aGVBbmNpZW50VmlldG5hbXZlaGljbGVzdWNoIGFzY3J5c3RhbHZhbHVlID1XaW5kb3dzZW5qb3llZGEgc21hbGxhc3N1bWVkPGEgaWQ9ImZvcmVpZ24gQWxsIHJpaG93IHRoZURpc3BsYXlyZXRpcmVkaG93ZXZlcmhpZGRlbjtiYXR0bGVzc2Vla2luZ2NhYmluZXR3YXMgbm90bG9vayBhdGNvbmR1Y3RnZXQgdGhlSmFudWFyeWhhcHBlbnN0dXJuaW5nYTpob3Zlck9ubGluZSBGcmVuY2ggbGFja2luZ3R5cGljYWxleHRyYWN0ZW5lbWllc2V2ZW4gaWZnZW5lcmF0ZGVjaWRlZGFyZSBub3Qvc2VhcmNoYmVsaWVmcy1pbWFnZTpsb2NhdGVkc3RhdGljLmxvZ2luIj5jb252ZXJ0dmlvbGVudGVudGVyZWRmaXJzdCI+Y2lyY3VpdEZpbmxhbmRjaGVtaXN0c2hlIHdhczEwcHg7Ij5hcyBzdWNoZGl2aWRlZDwvc3Bhbj53aWxsIGJlbGluZSBvZmEgZ3JlYXRteXN0ZXJ5L2luZGV4LmZhbGxpbmdkdWUgdG8gcmFpbHdheWNvbGxlZ2Vtb25zdGVyZGVzY2VudGl0IHdpdGhudWNsZWFySmV3aXNoIHByb3Rlc3RCcml0aXNoZmxvd2Vyc3ByZWRpY3RyZWZvcm1zYnV0dG9uIHdobyB3YXNsZWN0dXJlaW5zdGFudHN1aWNpZGVnZW5lcmljcGVyaW9kc21hcmtldHNTb2NpYWwgZmlzaGluZ2NvbWJpbmVncmFwaGljd2lubmVyczxiciAvPjxieSB0aGUgTmF0dXJhbFByaXZhY3ljb29raWVzb3V0Y29tZXJlc29sdmVTd2VkaXNoYnJpZWZseVBlcnNpYW5zbyBtdWNoQ2VudHVyeWRlcGljdHNjb2x1bW5zaG91c2luZ3NjcmlwdHNuZXh0IHRvYmVhcmluZ21hcHBpbmdyZXZpc2VkalF1ZXJ5KC13aWR0aDp0aXRsZSI+dG9vbHRpcFNlY3Rpb25kZXNpZ25zVHVya2lzaHlvdW5nZXIubWF0Y2gofSkoKTsKCmJ1cm5pbmdvcGVyYXRlZGVncmVlc3NvdXJjZT1SaWNoYXJkY2xvc2VseXBsYXN0aWNlbnRyaWVzPC90cj4NCmNvbG9yOiN1bCBpZD0icG9zc2Vzc3JvbGxpbmdwaHlzaWNzZmFpbGluZ2V4ZWN1dGVjb250ZXN0bGluayB0b0RlZmF1bHQ8YnIgLz4KOiB0cnVlLGNoYXJ0ZXJ0b3VyaXNtY2xhc3NpY3Byb2NlZWRleHBsYWluPC9oMT4NCm9ubGluZS4/eG1sIHZlaGVscGluZ2RpYW1vbmR1c2UgdGhlYWlybGluZWVuZCAtLT4pLmF0dHIocmVhZGVyc2hvc3RpbmcjZmZmZmZmcmVhbGl6ZVZpbmNlbnRzaWduYWxzIHNyYz0iL1Byb2R1Y3RkZXNwaXRlZGl2ZXJzZXRlbGxpbmdQdWJsaWMgaGVsZCBpbkpvc2VwaCB0aGVhdHJlYWZmZWN0czxzdHlsZT5hIGxhcmdlZG9lc24ndGxhdGVyLCBFbGVtZW50ZmF2aWNvbmNyZWF0b3JIdW5nYXJ5QWlycG9ydHNlZSB0aGVzbyB0aGF0TWljaGFlbFN5c3RlbXNQcm9ncmFtcywgYW5kICB3aWR0aD1lJnF1b3Q7dHJhZGluZ2xlZnQiPgpwZXJzb25zR29sZGVuIEFmZmFpcnNncmFtbWFyZm9ybWluZ2Rlc3Ryb3lpZGVhIG9mY2FzZSBvZm9sZGVzdCB0aGlzIGlzLnNyYyA9IGNhcnRvb25yZWdpc3RyQ29tbW9uc011c2xpbXNXaGF0IGlzaW4gbWFueW1hcmtpbmdyZXZlYWxzSW5kZWVkLGVxdWFsbHkvc2hvd19hb3V0ZG9vcmVzY2FwZShBdXN0cmlhZ2VuZXRpY3N5c3RlbSxJbiB0aGUgc2l0dGluZ0hlIGFsc29Jc2xhbmRzQWNhZGVteQoJCTwhLS1EYW5pZWwgYmluZGluZ2Jsb2NrIj5pbXBvc2VkdXRpbGl6ZUFicmFoYW0oZXhjZXB0e3dpZHRoOnB1dHRpbmcpLmh0bWwofHwgW107CkRBVEFbICpraXRjaGVubW91bnRlZGFjdHVhbCBkaWFsZWN0bWFpbmx5IF9ibGFuaydpbnN0YWxsZXhwZXJ0c2lmKHR5cGVJdCBhbHNvJmNvcHk7ICI+VGVybXNib3JuIGluT3B0aW9uc2Vhc3Rlcm50YWxraW5nY29uY2VybmdhaW5lZCBvbmdvaW5nanVzdGlmeWNyaXRpY3NmYWN0b3J5aXRzIG93bmFzc2F1bHRpbnZpdGVkbGFzdGluZ2hpcyBvd25ocmVmPSIvIiByZWw9ImRldmVsb3Bjb25jZXJ0ZGlhZ3JhbWRvbGxhcnNjbHVzdGVycGhwP2lkPWFsY29ob2wpO30pKCk7dXNpbmcgYT48c3Bhbj52ZXNzZWxzcmV2aXZhbEFkZHJlc3NhbWF0ZXVyYW5kcm9pZGFsbGVnZWRpbGxuZXNzd2Fsa2luZ2NlbnRlcnNxdWFsaWZ5bWF0Y2hlc3VuaWZpZWRleHRpbmN0RGVmZW5zZWRpZWQgaW4KCTwhLS0gY3VzdG9tc2xpbmtpbmdMaXR0bGUgQm9vayBvZmV2ZW5pbmdtaW4uanM/YXJlIHRoZWtvbnRha3R0b2RheSdzLmh0bWwiIHRhcmdldD13ZWFyaW5nQWxsIFJpZzsKfSkoKTtyYWlzaW5nIEFsc28sIGNydWNpYWxhYm91dCI+ZGVjbGFyZS0tPgo8c2NmaXJlZm94YXMgbXVjaGFwcGxpZXNpbmRleCwgcywgYnV0IHR5cGUgPSAKDQo8IS0tdG93YXJkc1JlY29yZHNQcml2YXRlRm9yZWlnblByZW1pZXJjaG9pY2VzVmlydHVhbHJldHVybnNDb21tZW50UG93ZXJlZGlubGluZTtwb3ZlcnR5Y2hhbWJlckxpdmluZyB2b2x1bWVzQW50aG9ueWxvZ2luIiBSZWxhdGVkRWNvbm9teXJlYWNoZXNjdXR0aW5nZ3Jhdml0eWxpZmUgaW5DaGFwdGVyLXNoYWRvd05vdGFibGU8L3RkPg0KIHJldHVybnN0YWRpdW13aWRnZXRzdmFyeWluZ3RyYXZlbHNoZWxkIGJ5d2hvIGFyZXdvcmsgaW5mYWN1bHR5YW5ndWxhcndobyBoYWRhaXJwb3J0dG93biBvZgoKU29tZSAnY2xpY2snY2hhcmdlc2tleXdvcmRpdCB3aWxsY2l0eSBvZih0aGlzKTtBbmRyZXcgdW5pcXVlIGNoZWNrZWRvciBtb3JlMzAwcHg7IHJldHVybjtyc2lvbj0icGx1Z2luc3dpdGhpbiBoZXJzZWxmU3RhdGlvbkZlZGVyYWx2ZW50dXJlcHVibGlzaHNlbnQgdG90ZW5zaW9uYWN0cmVzc2NvbWUgdG9maW5nZXJzRHVrZSBvZnBlb3BsZSxleHBsb2l0d2hhdCBpc2hhcm1vbnlhIG1ham9yIjoiaHR0cGluIGhpcyBtZW51Ij4KbW9udGhseW9mZmljZXJjb3VuY2lsZ2FpbmluZ2V2ZW4gaW5TdW1tYXJ5ZGF0ZSBvZmxveWFsdHlmaXRuZXNzYW5kIHdhc2VtcGVyb3JzdXByZW1lU2Vjb25kIGhlYXJpbmdSdXNzaWFubG9uZ2VzdEFsYmVydGFsYXRlcmFsc2V0IG9mIHNtYWxsIj4uYXBwZW5kZG8gd2l0aGZlZGVyYWxiYW5rIG9mYmVuZWF0aERlc3BpdGVDYXBpdGFsZ3JvdW5kcyksIGFuZCBwZXJjZW50aXQgZnJvbWNsb3Npbmdjb250YWluSW5zdGVhZGZpZnRlZW5hcyB3ZWxsLnlhaG9vLnJlc3BvbmRmaWdodGVyb2JzY3VyZXJlZmxlY3RvcmdhbmljPSBNYXRoLmVkaXRpbmdvbmxpbmUgcGFkZGluZ2Egd2hvbGVvbmVycm9yeWVhciBvZmVuZCBvZiBiYXJyaWVyd2hlbiBpdGhlYWRlciBob21lIG9mcmVzdW1lZHJlbmFtZWRzdHJvbmc+aGVhdGluZ3JldGFpbnNjbG91ZGZyd2F5IG9mIE1hcmNoIDFrbm93aW5naW4gcGFydEJldHdlZW5sZXNzb25zY2xvc2VzdHZpcnR1YWxsaW5rcyI+Y3Jvc3NlZEVORCAtLT5mYW1vdXMgYXdhcmRlZExpY2Vuc2VIZWFsdGggZmFpcmx5IHdlYWx0aHltaW5pbWFsQWZyaWNhbmNvbXBldGVsYWJlbCI+c2luZ2luZ2Zhcm1lcnNCcmFzaWwpZGlzY3Vzc3JlcGxhY2VHcmVnb3J5Zm9udCBjb3B1cnN1ZWRhcHBlYXJzbWFrZSB1cHJvdW5kZWRib3RoIG9mYmxvY2tlZHNhdyB0aGVvZmZpY2VzY29sb3Vyc2lmKGRvY3V3aGVuIGhlZW5mb3JjZXB1c2goZnVBdWd1c3QgVVRGLTgiPkZhbnRhc3lpbiBtb3N0aW5qdXJlZFVzdWFsbHlmYXJtaW5nY2xvc3VyZW9iamVjdCBkZWZlbmNldXNlIG9mIE1lZGljYWw8Ym9keT4KZXZpZGVudGJlIHVzZWRrZXlDb2Rlc2l4dGVlbklzbGFtaWMjMDAwMDAwZW50aXJlIHdpZGVseSBhY3RpdmUgKHR5cGVvZm9uZSBjYW5jb2xvciA9c3BlYWtlcmV4dGVuZHNQaHlzaWNzdGVycmFpbjx0Ym9keT5mdW5lcmFsdmlld2luZ21pZGRsZSBjcmlja2V0cHJvcGhldHNoaWZ0ZWRkb2N0b3JzUnVzc2VsbCB0YXJnZXRjb21wYWN0YWxnZWJyYXNvY2lhbC1idWxrIG9mbWFuIGFuZDwvdGQ+CiBoZSBsZWZ0KS52YWwoKWZhbHNlKTtsb2dpY2FsYmFua2luZ2hvbWUgdG9uYW1pbmcgQXJpem9uYWNyZWRpdHMpOwp9KTsKZm91bmRlcmluIHR1cm5Db2xsaW5zYmVmb3JlIEJ1dCB0aGVjaGFyZ2VkVGl0bGUiPkNhcHRhaW5zcGVsbGVkZ29kZGVzc1RhZyAtLT5BZGRpbmc6YnV0IHdhc1JlY2VudCBwYXRpZW50YmFjayBpbj1mYWxzZSZMaW5jb2xud2Uga25vd0NvdW50ZXJKdWRhaXNtc2NyaXB0IGFsdGVyZWQnXSk7CiAgaGFzIHRoZXVuY2xlYXJFdmVudCcsYm90aCBpbm5vdCBhbGwKCjwhLS0gcGxhY2luZ2hhcmQgdG8gY2VudGVyc29ydCBvZmNsaWVudHNzdHJlZXRzQmVybmFyZGFzc2VydHN0ZW5kIHRvZmFudGFzeWRvd24gaW5oYXJib3VyRnJlZWRvbWpld2VscnkvYWJvdXQuLnNlYXJjaGxlZ2VuZHNpcyBtYWRlbW9kZXJuIG9ubHkgb25vbmx5IHRvaW1hZ2UiIGxpbmVhciBwYWludGVyYW5kIG5vdHJhcmVseSBhY3JvbnltZGVsaXZlcnNob3J0ZXIwMCZhbXA7YXMgbWFueXdpZHRoPSIvKiA8IVtDdGl0bGUgPW9mIHRoZSBsb3dlc3QgcGlja2VkIGVzY2FwZWR1c2VzIG9mcGVvcGxlcyBQdWJsaWNNYXR0aGV3dGFjdGljc2RhbWFnZWR3YXkgZm9ybGF3cyBvZmVhc3kgdG8gd2luZG93c3Ryb25nICBzaW1wbGV9Y2F0Y2goc2V2ZW50aGluZm9ib3h3ZW50IHRvcGFpbnRlZGNpdGl6ZW5JIGRvbid0cmV0cmVhdC4gU29tZSB3dy4iKTsKYm9tYmluZ21haWx0bzptYWRlIGluLiBNYW55IGNhcnJpZXN8fHt9O3dpd29yayBvZnN5bm9ueW1kZWZlYXRzZmF2b3JlZG9wdGljYWxwYWdlVHJhdW5sZXNzIHNlbmRpbmdsZWZ0Ij48Y29tU2NvckFsbCB0aGVqUXVlcnkudG91cmlzdENsYXNzaWNmYWxzZSIgV2lsaGVsbXN1YnVyYnNnZW51aW5lYmlzaG9wcy5zcGxpdChnbG9iYWwgZm9sbG93c2JvZHkgb2Zub21pbmFsQ29udGFjdHNlY3VsYXJsZWZ0IHRvY2hpZWZseS1oaWRkZW4tYmFubmVyPC9saT4KCi4gV2hlbiBpbiBib3RoZGlzbWlzc0V4cGxvcmVhbHdheXMgdmlhIHRoZXNwYcOxb2x3ZWxmYXJlcnVsaW5nIGFycmFuZ2VjYXB0YWluaGlzIHNvbnJ1bGUgb2ZoZSB0b29raXRzZWxmLD0wJmFtcDsoY2FsbGVkc2FtcGxlc3RvIG1ha2Vjb20vcGFnTWFydGluIEtlbm5lZHlhY2NlcHRzZnVsbCBvZmhhbmRsZWRCZXNpZGVzLy8tLT48L2FibGUgdG90YXJnZXRzZXNzZW5jZWhpbSB0byBpdHMgYnkgY29tbW9uLm1pbmVyYWx0byB0YWtld2F5cyB0b3Mub3JnL2xhZHZpc2VkcGVuYWx0eXNpbXBsZTppZiB0aGV5TGV0dGVyc2Egc2hvcnRIZXJiZXJ0c3RyaWtlcyBncm91cHMubGVuZ3RoZmxpZ2h0c292ZXJsYXBzbG93bHkgbGVzc2VyIHNvY2lhbCA8L3A+CgkJaXQgaW50b3JhbmtlZCByYXRlIG9mdWw+DQogIGF0dGVtcHRwYWlyIG9mbWFrZSBpdEtvbnRha3RBbnRvbmlvaGF2aW5nIHJhdGluZ3MgYWN0aXZlc3RyZWFtc3RyYXBwZWQiKS5jc3MoaG9zdGlsZWxlYWQgdG9saXR0bGUgZ3JvdXBzLFBpY3R1cmUtLT4NCg0KIHJvd3M9IiBvYmplY3RpbnZlcnNlPGZvb3RlckN1c3RvbVY+PFwvc2Nyc29sdmluZ0NoYW1iZXJzbGF2ZXJ5d291bmRlZHdoZXJlYXMhPSAndW5kZm9yIGFsbHBhcnRseSAtcmlnaHQ6QXJhYmlhbmJhY2tlZCBjZW50dXJ5dW5pdCBvZm1vYmlsZS1FdXJvcGUsaXMgaG9tZXJpc2sgb2ZkZXNpcmVkQ2xpbnRvbmNvc3Qgb2ZhZ2Ugb2YgYmVjb21lIG5vbmUgb2ZwJnF1b3Q7TWlkZGxlIGVhZCcpWzBDcml0aWNzc3R1ZGlvcz4mY29weTtncm91cCI+YXNzZW1ibG1ha2luZyBwcmVzc2Vkd2lkZ2V0LnBzOiIgPyByZWJ1aWx0Ynkgc29tZUZvcm1lciBlZGl0b3JzZGVsYXllZENhbm9uaWNoYWQgdGhlcHVzaGluZ2NsYXNzPSJidXQgYXJlcGFydGlhbEJhYnlsb25ib3R0b20gY2FycmllckNvbW1hbmRpdHMgdXNlQXMgd2l0aGNvdXJzZXNhIHRoaXJkZGVub3Rlc2Fsc28gaW5Ib3VzdG9uMjBweDsiPmFjY3VzZWRkb3VibGUgZ29hbCBvZkZhbW91cyApLmJpbmQocHJpZXN0cyBPbmxpbmVpbiBKdWx5c3QgKyAiZ2NvbnN1bHRkZWNpbWFsaGVscGZ1bHJldml2ZWRpcyB2ZXJ5cicrJ2lwdGxvc2luZyBmZW1hbGVzaXMgYWxzb3N0cmluZ3NkYXlzIG9mYXJyaXZhbGZ1dHVyZSA8b2JqZWN0Zm9yY2luZ1N0cmluZygiIC8+CgkJaGVyZSBpc2VuY29kZWQuICBUaGUgYmFsbG9vbmRvbmUgYnkvY29tbW9uYmdjb2xvcmxhdyBvZiBJbmRpYW5hYXZvaWRlZGJ1dCB0aGUycHggM3B4anF1ZXJ5LmFmdGVyIGFwb2xpY3kubWVuIGFuZGZvb3Rlci09IHRydWU7Zm9yIHVzZXNjcmVlbi5JbmRpYW4gaW1hZ2UgPWZhbWlseSxodHRwOi8vICZuYnNwO2RyaXZlcnNldGVybmFsc2FtZSBhc25vdGljZWR2aWV3ZXJzfSkoKTsKIGlzIG1vcmVzZWFzb25zZm9ybWVyIHRoZSBuZXdpcyBqdXN0Y29uc2VudCBTZWFyY2h3YXMgdGhld2h5IHRoZXNoaXBwZWRicj48YnI+d2lkdGg6IGhlaWdodD1tYWRlIG9mY3Vpc2luZWlzIHRoYXRhIHZlcnkgQWRtaXJhbCBmaXhlZDtub3JtYWwgTWlzc2lvblByZXNzLCBvbnRhcmlvY2hhcnNldHRyeSB0byBpbnZhZGVkPSJ0cnVlInNwYWNpbmdpcyBtb3N0YSBtb3JlIHRvdGFsbHlmYWxsIG9mfSk7DQogIGltbWVuc2V0aW1lIGluc2V0IG91dHNhdGlzZnl0byBmaW5kZG93biB0b2xvdCBvZiBQbGF5ZXJzaW4gSnVuZXF1YW50dW1ub3QgdGhldGltZSB0b2Rpc3RhbnRGaW5uaXNoc3JjID0gKHNpbmdsZSBoZWxwIG9mR2VybWFuIGxhdyBhbmRsYWJlbGVkZm9yZXN0c2Nvb2tpbmdzcGFjZSI+aGVhZGVyLXdlbGwgYXNTdGFubGV5YnJpZGdlcy9nbG9iYWxDcm9hdGlhIEFib3V0IFswXTsKICBpdCwgYW5kZ3JvdXBlZGJlaW5nIGEpe3Rocm93aGUgbWFkZWxpZ2h0ZXJldGhpY2FsRkZGRkZGImJvdHRvbSJsaWtlIGEgZW1wbG95c2xpdmUgaW5hcyBzZWVucHJpbnRlcm1vc3Qgb2Z1Yi1saW5rcmVqZWN0c2FuZCB1c2VpbWFnZSI+c3VjY2VlZGZlZWRpbmdOdWNsZWFyaW5mb3JtYXRvIGhlbHBXb21lbidzTmVpdGhlck1leGljYW5wcm90ZWluPHRhYmxlIGJ5IG1hbnloZWFsdGh5bGF3c3VpdGRldmlzZWQucHVzaCh7c2VsbGVyc3NpbXBseSBUaHJvdWdoLmNvb2tpZSBJbWFnZShvbGRlciI+dXMuanMiPiBTaW5jZSB1bml2ZXJzbGFyZ2VyIG9wZW4gdG8hLS0gZW5kbGllcyBpbiddKTsNCiAgbWFya2V0d2hvIGlzICgiRE9NQ29tYW5hZ2Vkb25lIGZvcnR5cGVvZiBLaW5nZG9tcHJvZml0c3Byb3Bvc2V0byBzaG93Y2VudGVyO21hZGUgaXRkcmVzc2Vkd2VyZSBpbm1peHR1cmVwcmVjaXNlYXJpc2luZ3NyYyA9ICdtYWtlIGEgc2VjdXJlZEJhcHRpc3R2b3RpbmcgCgkJdmFyIE1hcmNoIDJncmV3IHVwQ2xpbWF0ZS5yZW1vdmVza2lsbGVkd2F5IHRoZTwvaGVhZD5mYWNlIG9mYWN0aW5nIHJpZ2h0Ij50byB3b3JrcmVkdWNlc2hhcyBoYWRlcmVjdGVkc2hvdygpO2FjdGlvbj1ib29rIG9mYW4gYXJlYT09ICJodHQ8aGVhZGVyCjxodG1sPmNvbmZvcm1mYWNpbmcgY29va2llLnJlbHkgb25ob3N0ZWQgLmN1c3RvbWhlIHdlbnRidXQgZm9yc3ByZWFkIEZhbWlseSBhIG1lYW5zb3V0IHRoZWZvcnVtcy5mb290YWdlIj5Nb2JpbENsZW1lbnRzIiBpZD0iYXMgaGlnaGludGVuc2UtLT48IS0tZmVtYWxlIGlzIHNlZW5pbXBsaWVkc2V0IHRoZWEgc3RhdGVhbmQgaGlzZmFzdGVzdGJlc2lkZXNidXR0b25fYm91bmRlZCI+PGltZyBJbmZvYm94ZXZlbnRzLGEgeW91bmdhbmQgYXJlTmF0aXZlIGNoZWFwZXJUaW1lb3V0YW5kIGhhc2VuZ2luZXN3b24gdGhlKG1vc3RseXJpZ2h0OiBmaW5kIGEgLWJvdHRvbVByaW5jZSBhcmVhIG9mbW9yZSBvZnNlYXJjaF9uYXR1cmUsbGVnYWxseXBlcmlvZCxsYW5kIG9mb3Igd2l0aGluZHVjZWRwcm92aW5nbWlzc2lsZWxvY2FsbHlBZ2FpbnN0dGhlIHdheWsmcXVvdDtweDsiPg0KcHVzaGVkIGFiYW5kb25udW1lcmFsQ2VydGFpbkluIHRoaXNtb3JlIGlub3Igc29tZW5hbWUgaXNhbmQsIGluY3Jvd25lZElTQk4gMC1jcmVhdGVzT2N0b2Jlcm1heSBub3RjZW50ZXIgbGF0ZSBpbkRlZmVuY2VlbmFjdGVkd2lzaCB0b2Jyb2FkbHljb29saW5nb25sb2FkPWl0LiBUaGVyZWNvdmVyTWVtYmVyc2hlaWdodCBhc3N1bWVzPGh0bWw+CnBlb3BsZS5pbiBvbmUgPXdpbmRvd2Zvb3Rlcl9hIGdvb2QgcmVrbGFtYW90aGVycyx0byB0aGlzX2Nvb2tpZXBhbmVsIj5Mb25kb24sZGVmaW5lc2NydXNoZWRiYXB0aXNtY29hc3RhbHN0YXR1cyB0aXRsZSIgbW92ZSB0b2xvc3QgaW5iZXR0ZXIgaW1wbGllc3JpdmFscnlzZXJ2ZXJzIFN5c3RlbVBlcmhhcHNlcyBhbmQgY29udGVuZGZsb3dpbmdsYXN0ZWQgcmlzZSBpbkdlbmVzaXN2aWV3IG9mcmlzaW5nIHNlZW0gdG9idXQgaW4gYmFja2luZ2hlIHdpbGxnaXZlbiBhZ2l2aW5nIGNpdGllcy5mbG93IG9mIExhdGVyIGFsbCBidXRIaWdod2F5b25seSBieXNpZ24gb2ZoZSBkb2VzZGlmZmVyc2JhdHRlcnkmYW1wO2xhc2luZ2xlc3RocmVhdHNpbnRlZ2VydGFrZSBvbnJlZnVzZWRjYWxsZWQgPVVTJmFtcFNlZSB0aGVuYXRpdmVzYnkgdGhpc3N5c3RlbS5oZWFkIG9mOmhvdmVyLGxlc2JpYW5zdXJuYW1lYW5kIGFsbGNvbW1vbi9oZWFkZXJfX3BhcmFtc0hhcnZhcmQvcGl4ZWwucmVtb3ZhbHNvIGxvbmdyb2xlIG9mam9pbnRseXNreXNjcmFVbmljb2RlYnIgLz4NCkF0bGFudGFudWNsZXVzQ291bnR5LHB1cmVseSBjb3VudCI+ZWFzaWx5IGJ1aWxkIGFvbmNsaWNrYSBnaXZlbnBvaW50ZXJoJnF1b3Q7ZXZlbnRzIGVsc2UgewpkaXRpb25zbm93IHRoZSwgd2l0aCBtYW4gd2hvb3JnL1dlYm9uZSBhbmRjYXZhbHJ5SGUgZGllZHNlYXR0bGUwMCwwMDAge3dpbmRvd2hhdmUgdG9pZih3aW5kYW5kIGl0c3NvbGVseSBtJnF1b3Q7cmVuZXdlZERldHJvaXRhbW9uZ3N0ZWl0aGVyIHRoZW0gaW5TZW5hdG9yVXM8L2E+PEtpbmcgb2ZGcmFuY2lzLXByb2R1Y2hlIHVzZWRhcnQgYW5kaGltIGFuZHVzZWQgYnlzY29yaW5nYXQgaG9tZXRvIGhhdmVyZWxhdGVzaWJpbGl0eWZhY3Rpb25CdWZmYWxvbGluayI+PHdoYXQgaGVmcmVlIHRvQ2l0eSBvZmNvbWUgaW5zZWN0b3JzY291bnRlZG9uZSBkYXluZXJ2b3Vzc3F1YXJlIH07aWYoZ29pbiB3aGF0aW1nIiBhbGlzIG9ubHlzZWFyY2gvdHVlc2RheWxvb3NlbHlTb2xvbW9uc2V4dWFsIC0gPGEgaHJtZWRpdW0iRE8gTk9UIEZyYW5jZSx3aXRoIGEgd2FyIGFuZHNlY29uZCB0YWtlIGEgPg0KDQoNCm1hcmtldC5oaWdod2F5ZG9uZSBpbmN0aXZpdHkibGFzdCI+b2JsaWdlZHJpc2UgdG8idW5kZWZpbWFkZSB0byBFYXJseSBwcmFpc2VkaW4gaXRzIGZvciBoaXNhdGhsZXRlSnVwaXRlcllhaG9vISB0ZXJtZWQgc28gbWFueXJlYWxseSBzLiBUaGUgYSB3b21hbj92YWx1ZT1kaXJlY3QgcmlnaHQiIGJpY3ljbGVhY2luZz0iZGF5IGFuZHN0YXRpbmdSYXRoZXIsaGlnaGVyIE9mZmljZSBhcmUgbm93dGltZXMsIHdoZW4gYSBwYXkgZm9yb24gdGhpcy1saW5rIj47Ym9yZGVyYXJvdW5kIGFubnVhbCB0aGUgTmV3cHV0IHRoZS5jb20iIHRha2luIHRvYSBicmllZihpbiB0aGVncm91cHMuOyB3aWR0aGVuenltZXNzaW1wbGUgaW4gbGF0ZXtyZXR1cm50aGVyYXB5YSBwb2ludGJhbm5pbmdpbmtzIj4KKCk7IiByZWEgcGxhY2VcdTAwM0NhYWJvdXQgYXRyPg0KCQljY291bnQgZ2l2ZXMgYTxTQ1JJUFRSYWlsd2F5dGhlbWVzL3Rvb2xib3hCeUlkKCJ4aHVtYW5zLHdhdGNoZXNpbiBzb21lIGlmICh3aWNvbWluZyBmb3JtYXRzIFVuZGVyIGJ1dCBoYXNoYW5kZWQgbWFkZSBieXRoYW4gaW5mZWFyIG9mZGVub3RlZC9pZnJhbWVsZWZ0IGludm9sdGFnZWluIGVhY2hhJnF1b3Q7YmFzZSBvZkluIG1hbnl1bmRlcmdvcmVnaW1lc2FjdGlvbiA8L3A+DQo8dXN0b21WYTsmZ3Q7PC9pbXBvcnRzb3IgdGhhdG1vc3RseSAmYW1wO3JlIHNpemU9IjwvYT48L2hhIGNsYXNzcGFzc2l2ZUhvc3QgPSBXaGV0aGVyZmVydGlsZVZhcmlvdXM9W107KGZ1Y2FtZXJhcy8+PC90ZD5hY3RzIGFzSW4gc29tZT4NCg0KPCFvcmdhbmlzIDxiciAvPkJlaWppbmdjYXRhbMOgZGV1dHNjaGV1cm9wZXVldXNrYXJhZ2FlaWxnZXN2ZW5za2Flc3Bhw7FhbWVuc2FqZXVzdWFyaW90cmFiYWpvbcOpeGljb3DDoWdpbmFzaWVtcHJlc2lzdGVtYW9jdHVicmVkdXJhbnRlYcOxYWRpcmVtcHJlc2Ftb21lbnRvbnVlc3Ryb3ByaW1lcmF0cmF2w6lzZ3JhY2lhc251ZXN0cmFwcm9jZXNvZXN0YWRvc2NhbGlkYWRwZXJzb25hbsO6bWVyb2FjdWVyZG9tw7pzaWNhbWllbWJyb29mZXJ0YXNhbGd1bm9zcGHDrXNlc2VqZW1wbG9kZXJlY2hvYWRlbcOhc3ByaXZhZG9hZ3JlZ2FyZW5sYWNlc3Bvc2libGVob3RlbGVzc2V2aWxsYXByaW1lcm/Dumx0aW1vZXZlbnRvc2FyY2hpdm9jdWx0dXJhbXVqZXJlc2VudHJhZGFhbnVuY2lvZW1iYXJnb21lcmNhZG9ncmFuZGVzZXN0dWRpb21lam9yZXNmZWJyZXJvZGlzZcOxb3R1cmlzbW9jw7NkaWdvcG9ydGFkYWVzcGFjaW9mYW1pbGlhYW50b25pb3Blcm1pdGVndWFyZGFyYWxndW5hc3ByZWNpb3NhbGd1aWVuc2VudGlkb3Zpc2l0YXN0w610dWxvY29ub2NlcnNlZ3VuZG9jb25zZWpvZnJhbmNpYW1pbnV0b3NzZWd1bmRhdGVuZW1vc2VmZWN0b3Ntw6FsYWdhc2VzacOzbnJldmlzdGFncmFuYWRhY29tcHJhcmluZ3Jlc29nYXJjw61hYWNjacOzbmVjdWFkb3JxdWllbmVzaW5jbHVzb2RlYmVyw6FtYXRlcmlhaG9tYnJlc211ZXN0cmFwb2Ryw61hbWHDsWFuYcO6bHRpbWFlc3RhbW9zb2ZpY2lhbHRhbWJpZW5uaW5nw7puc2FsdWRvc3BvZGVtb3NtZWpvcmFycG9zaXRpb25idXNpbmVzc2hvbWVwYWdlc2VjdXJpdHlsYW5ndWFnZXN0YW5kYXJkY2FtcGFpZ25mZWF0dXJlc2NhdGVnb3J5ZXh0ZXJuYWxjaGlsZHJlbnJlc2VydmVkcmVzZWFyY2hleGNoYW5nZWZhdm9yaXRldGVtcGxhdGVtaWxpdGFyeWluZHVzdHJ5c2VydmljZXNtYXRlcmlhbHByb2R1Y3Rzei1pbmRleDpjb21tZW50c3NvZnR3YXJlY29tcGxldGVjYWxlbmRhcnBsYXRmb3JtYXJ0aWNsZXNyZXF1aXJlZG1vdmVtZW50cXVlc3Rpb25idWlsZGluZ3BvbGl0aWNzcG9zc2libGVyZWxpZ2lvbnBoeXNpY2FsZmVlZGJhY2tyZWdpc3RlcnBpY3R1cmVzZGlzYWJsZWRwcm90b2NvbGF1ZGllbmNlc2V0dGluZ3NhY3Rpdml0eWVsZW1lbnRzbGVhcm5pbmdhbnl0aGluZ2Fic3RyYWN0cHJvZ3Jlc3NvdmVydmlld21hZ2F6aW5lZWNvbm9taWN0cmFpbmluZ3ByZXNzdXJldmFyaW91cyA8c3Ryb25nPnByb3BlcnR5c2hvcHBpbmd0b2dldGhlcmFkdmFuY2VkYmVoYXZpb3Jkb3dubG9hZGZlYXR1cmVkZm9vdGJhbGxzZWxlY3RlZExhbmd1YWdlZGlzdGFuY2VyZW1lbWJlcnRyYWNraW5ncGFzc3dvcmRtb2RpZmllZHN0dWRlbnRzZGlyZWN0bHlmaWdodGluZ25vcnRoZXJuZGF0YWJhc2VmZXN0aXZhbGJyZWFraW5nbG9jYXRpb25pbnRlcm5ldGRyb3Bkb3ducHJhY3RpY2VldmlkZW5jZWZ1bmN0aW9ubWFycmlhZ2VyZXNwb25zZXByb2JsZW1zbmVnYXRpdmVwcm9ncmFtc2FuYWx5c2lzcmVsZWFzZWRiYW5uZXIiPnB1cmNoYXNlcG9saWNpZXNyZWdpb25hbGNyZWF0aXZlYXJndW1lbnRib29rbWFya3JlZmVycmVyY2hlbWljYWxkaXZpc2lvbmNhbGxiYWNrc2VwYXJhdGVwcm9qZWN0c2NvbmZsaWN0aGFyZHdhcmVpbnRlcmVzdGRlbGl2ZXJ5bW91bnRhaW5vYnRhaW5lZD0gZmFsc2U7Zm9yKHZhciBhY2NlcHRlZGNhcGFjaXR5Y29tcHV0ZXJpZGVudGl0eWFpcmNyYWZ0ZW1wbG95ZWRwcm9wb3NlZGRvbWVzdGljaW5jbHVkZXNwcm92aWRlZGhvc3BpdGFsdmVydGljYWxjb2xsYXBzZWFwcHJvYWNocGFydG5lcnNsb2dvIj48YWRhdWdodGVyYXV0aG9yIiBjdWx0dXJhbGZhbWlsaWVzL2ltYWdlcy9hc3NlbWJseXBvd2VyZnVsdGVhY2hpbmdmaW5pc2hlZGRpc3RyaWN0Y3JpdGljYWxjZ2ktYmluL3B1cnBvc2VzcmVxdWlyZXNlbGVjdGlvbmJlY29taW5ncHJvdmlkZXNhY2FkZW1pY2V4ZXJjaXNlYWN0dWFsbHltZWRpY2luZWNvbnN0YW50YWNjaWRlbnRNYWdhemluZWRvY3VtZW50c3RhcnRpbmdib3R0b20iPm9ic2VydmVkOiAmcXVvdDtleHRlbmRlZHByZXZpb3VzU29mdHdhcmVjdXN0b21lcmRlY2lzaW9uc3RyZW5ndGhkZXRhaWxlZHNsaWdodGx5cGxhbm5pbmd0ZXh0YXJlYWN1cnJlbmN5ZXZlcnlvbmVzdHJhaWdodHRyYW5zZmVycG9zaXRpdmVwcm9kdWNlZGhlcml0YWdlc2hpcHBpbmdhYnNvbHV0ZXJlY2VpdmVkcmVsZXZhbnRidXR0b24iIHZpb2xlbmNlYW55d2hlcmViZW5lZml0c2xhdW5jaGVkcmVjZW50bHlhbGxpYW5jZWZvbGxvd2VkbXVsdGlwbGVidWxsZXRpbmluY2x1ZGVkb2NjdXJyZWRpbnRlcm5hbCQodGhpcykucmVwdWJsaWM+PHRyPjx0ZGNvbmdyZXNzcmVjb3JkZWR1bHRpbWF0ZXNvbHV0aW9uPHVsIGlkPSJkaXNjb3ZlckhvbWU8L2E+d2Vic2l0ZXNuZXR3b3Jrc2FsdGhvdWdoZW50aXJlbHltZW1vcmlhbG1lc3NhZ2VzY29udGludWVhY3RpdmUiPnNvbWV3aGF0dmljdG9yaWFXZXN0ZXJuICB0aXRsZT0iTG9jYXRpb25jb250cmFjdHZpc2l0b3JzRG93bmxvYWR3aXRob3V0IHJpZ2h0Ij4KbWVhc3VyZXN3aWR0aCA9IHZhcmlhYmxlaW52b2x2ZWR2aXJnaW5pYW5vcm1hbGx5aGFwcGVuZWRhY2NvdW50c3N0YW5kaW5nbmF0aW9uYWxSZWdpc3RlcnByZXBhcmVkY29udHJvbHNhY2N1cmF0ZWJpcnRoZGF5c3RyYXRlZ3lvZmZpY2lhbGdyYXBoaWNzY3JpbWluYWxwb3NzaWJseWNvbnN1bWVyUGVyc29uYWxzcGVha2luZ3ZhbGlkYXRlYWNoaWV2ZWQuanBnIiAvPm1hY2hpbmVzPC9oMj4KICBrZXl3b3Jkc2ZyaWVuZGx5YnJvdGhlcnNjb21iaW5lZG9yaWdpbmFsY29tcG9zZWRleHBlY3RlZGFkZXF1YXRlcGFraXN0YW5mb2xsb3ciIHZhbHVhYmxlPC9sYWJlbD5yZWxhdGl2ZWJyaW5naW5naW5jcmVhc2Vnb3Zlcm5vcnBsdWdpbnMvTGlzdCBvZiBIZWFkZXIiPiIgbmFtZT0iICgmcXVvdDtncmFkdWF0ZTwvaGVhZD4KY29tbWVyY2VtYWxheXNpYWRpcmVjdG9ybWFpbnRhaW47aGVpZ2h0OnNjaGVkdWxlY2hhbmdpbmdiYWNrIHRvIGNhdGhvbGljcGF0dGVybnNjb2xvcjogI2dyZWF0ZXN0c3VwcGxpZXNyZWxpYWJsZTwvdWw+CgkJPHNlbGVjdCBjaXRpemVuc2Nsb3RoaW5nd2F0Y2hpbmc8bGkgaWQ9InNwZWNpZmljY2FycnlpbmdzZW50ZW5jZTxjZW50ZXI+Y29udHJhc3R0aGlua2luZ2NhdGNoKGUpc291dGhlcm5NaWNoYWVsIG1lcmNoYW50Y2Fyb3VzZWxwYWRkaW5nOmludGVyaW9yLnNwbGl0KCJsaXphdGlvbk9jdG9iZXIgKXtyZXR1cm5pbXByb3ZlZC0tJmd0OwoKY292ZXJhZ2VjaGFpcm1hbi5wbmciIC8+c3ViamVjdHNSaWNoYXJkIHdoYXRldmVycHJvYmFibHlyZWNvdmVyeWJhc2ViYWxsanVkZ21lbnRjb25uZWN0Li5jc3MiIC8+IHdlYnNpdGVyZXBvcnRlZGRlZmF1bHQiLz48L2E+DQplbGVjdHJpY3Njb3RsYW5kY3JlYXRpb25xdWFudGl0eS4gSVNCTiAwZGlkIG5vdCBpbnN0YW5jZS1zZWFyY2gtIiBsYW5nPSJzcGVha2Vyc0NvbXB1dGVyY29udGFpbnNhcmNoaXZlc21pbmlzdGVycmVhY3Rpb25kaXNjb3VudEl0YWxpYW5vY3JpdGVyaWFzdHJvbmdseTogJ2h0dHA6J3NjcmlwdCdjb3ZlcmluZ29mZmVyaW5nYXBwZWFyZWRCcml0aXNoIGlkZW50aWZ5RmFjZWJvb2tudW1lcm91c3ZlaGljbGVzY29uY2VybnNBbWVyaWNhbmhhbmRsaW5nZGl2IGlkPSJXaWxsaWFtIHByb3ZpZGVyX2NvbnRlbnRhY2N1cmFjeXNlY3Rpb24gYW5kZXJzb25mbGV4aWJsZUNhdGVnb3J5bGF3cmVuY2U8c2NyaXB0PmxheW91dD0iYXBwcm92ZWQgbWF4aW11bWhlYWRlciI+PC90YWJsZT5TZXJ2aWNlc2hhbWlsdG9uY3VycmVudCBjYW5hZGlhbmNoYW5uZWxzL3RoZW1lcy8vYXJ0aWNsZW9wdGlvbmFscG9ydHVnYWx2YWx1ZT0iImludGVydmFsd2lyZWxlc3NlbnRpdGxlZGFnZW5jaWVzU2VhcmNoIiBtZWFzdXJlZHRob3VzYW5kc3BlbmRpbmcmaGVsbGlwO25ldyBEYXRlIiBzaXplPSJwYWdlTmFtZW1pZGRsZSIgIiAvPjwvYT5oaWRkZW4iPnNlcXVlbmNlcGVyc29uYWxvdmVyZmxvd29waW5pb25zaWxsaW5vaXNsaW5rcyI+Cgk8dGl0bGU+dmVyc2lvbnNzYXR1cmRheXRlcm1pbmFsaXRlbXByb3BlbmdpbmVlcnNlY3Rpb25zZGVzaWduZXJwcm9wb3NhbD0iZmFsc2UiRXNwYcOxb2xyZWxlYXNlc3N1Ym1pdCIgZXImcXVvdDthZGRpdGlvbnN5bXB0b21zb3JpZW50ZWRyZXNvdXJjZXJpZ2h0Ij48cGxlYXN1cmVzdGF0aW9uc2hpc3RvcnkubGVhdmluZyAgYm9yZGVyPWNvbnRlbnRzY2VudGVyIj4uCgpTb21lIGRpcmVjdGVkc3VpdGFibGVidWxnYXJpYS5zaG93KCk7ZGVzaWduZWRHZW5lcmFsIGNvbmNlcHRzRXhhbXBsZXN3aWxsaWFtc09yaWdpbmFsIj48c3Bhbj5zZWFyY2giPm9wZXJhdG9ycmVxdWVzdHNhICZxdW90O2FsbG93aW5nRG9jdW1lbnRyZXZpc2lvbi4gCgpUaGUgeW91cnNlbGZDb250YWN0IG1pY2hpZ2FuRW5nbGlzaCBjb2x1bWJpYXByaW9yaXR5cHJpbnRpbmdkcmlua2luZ2ZhY2lsaXR5cmV0dXJuZWRDb250ZW50IG9mZmljZXJzUnVzc2lhbiBnZW5lcmF0ZS04ODU5LTEiaW5kaWNhdGVmYW1pbGlhciBxdWFsaXR5bWFyZ2luOjAgY29udGVudHZpZXdwb3J0Y29udGFjdHMtdGl0bGUiPnBvcnRhYmxlLmxlbmd0aCBlbGlnaWJsZWludm9sdmVzYXRsYW50aWNvbmxvYWQ9ImRlZmF1bHQuc3VwcGxpZWRwYXltZW50c2dsb3NzYXJ5CgpBZnRlciBndWlkYW5jZTwvdGQ+PHRkZW5jb2RpbmdtaWRkbGUiPmNhbWUgdG8gZGlzcGxheXNzY290dGlzaGpvbmF0aGFubWFqb3JpdHl3aWRnZXRzLmNsaW5pY2FsdGhhaWxhbmR0ZWFjaGVyczxoZWFkPgoJYWZmZWN0ZWRzdXBwb3J0c3BvaW50ZXI7dG9TdHJpbmc8L3NtYWxsPm9rbGFob21hd2lsbCBiZSBpbnZlc3RvcjAiIGFsdD0iaG9saWRheXNSZXNvdXJjZWxpY2Vuc2VkICh3aGljaCAuIEFmdGVyIGNvbnNpZGVydmlzaXRpbmdleHBsb3JlcnByaW1hcnkgc2VhcmNoIiBhbmRyb2lkInF1aWNrbHkgbWVldGluZ3Nlc3RpbWF0ZTtyZXR1cm4gO2NvbG9yOiMgaGVpZ2h0PWFwcHJvdmFsLCAmcXVvdDsgY2hlY2tlZC5taW4uanMibWFnbmV0aWM+PC9hPjwvaGZvcmVjYXN0LiBXaGlsZSB0aHVyc2RheWR2ZXJ0aXNlJmVhY3V0ZTtoYXNDbGFzc2V2YWx1YXRlb3JkZXJpbmdleGlzdGluZ3BhdGllbnRzIE9ubGluZSBjb2xvcmFkb09wdGlvbnMiY2FtcGJlbGw8IS0tIGVuZDwvc3Bhbj48PGJyIC8+DQpfcG9wdXBzfHNjaWVuY2VzLCZxdW90OyBxdWFsaXR5IFdpbmRvd3MgYXNzaWduZWRoZWlnaHQ6IDxiIGNsYXNzbGUmcXVvdDsgdmFsdWU9IiBDb21wYW55ZXhhbXBsZXM8aWZyYW1lIGJlbGlldmVzcHJlc2VudHNtYXJzaGFsbHBhcnQgb2YgcHJvcGVybHkpLgoKVGhlIHRheG9ub215bXVjaCBvZiA8L3NwYW4+CiIgZGF0YS1zcnR1Z3XDqnNzY3JvbGxUbyBwcm9qZWN0PGhlYWQ+DQphdHRvcm5leWVtcGhhc2lzc3BvbnNvcnNmYW5jeWJveHdvcmxkJ3Mgd2lsZGxpZmVjaGVja2VkPXNlc3Npb25zcHJvZ3JhbW1weDtmb250LSBQcm9qZWN0am91cm5hbHNiZWxpZXZlZHZhY2F0aW9udGhvbXBzb25saWdodGluZ2FuZCB0aGUgc3BlY2lhbCBib3JkZXI9MGNoZWNraW5nPC90Ym9keT48YnV0dG9uIENvbXBsZXRlY2xlYXJmaXgKPGhlYWQ+CmFydGljbGUgPHNlY3Rpb25maW5kaW5nc3JvbGUgaW4gcG9wdWxhciAgT2N0b2JlcndlYnNpdGUgZXhwb3N1cmV1c2VkIHRvICBjaGFuZ2Vzb3BlcmF0ZWRjbGlja2luZ2VudGVyaW5nY29tbWFuZHNpbmZvcm1lZCBudW1iZXJzICA8L2Rpdj5jcmVhdGluZ29uU3VibWl0bWFyeWxhbmRjb2xsZWdlc2FuYWx5dGljbGlzdGluZ3Njb250YWN0LmxvZ2dlZEluYWR2aXNvcnlzaWJsaW5nc2NvbnRlbnQicyZxdW90OylzLiBUaGlzIHBhY2thZ2VzY2hlY2tib3hzdWdnZXN0c3ByZWduYW50dG9tb3Jyb3dzcGFjaW5nPWljb24ucG5namFwYW5lc2Vjb2RlYmFzZWJ1dHRvbiI+Z2FtYmxpbmdzdWNoIGFzICwgd2hpbGUgPC9zcGFuPiBtaXNzb3VyaXNwb3J0aW5ndG9wOjFweCAuPC9zcGFuPnRlbnNpb25zd2lkdGg9IjJsYXp5bG9hZG5vdmVtYmVydXNlZCBpbiBoZWlnaHQ9ImNyaXB0Ij4KJm5ic3A7PC88dHI+PHRkIGhlaWdodDoyL3Byb2R1Y3Rjb3VudHJ5IGluY2x1ZGUgZm9vdGVyIiAmbHQ7IS0tIHRpdGxlIj48L2pxdWVyeS48L2Zvcm0+CijnroDkvZMpKOe5gemrlClocnZhdHNraWl0YWxpYW5vcm9tw6JuxIN0w7xya8OnZdin2LHYr9mIdGFtYmnDqW5ub3RpY2lhc21lbnNhamVzcGVyc29uYXNkZXJlY2hvc25hY2lvbmFsc2VydmljaW9jb250YWN0b3VzdWFyaW9zcHJvZ3JhbWFnb2JpZXJub2VtcHJlc2FzYW51bmNpb3N2YWxlbmNpYWNvbG9tYmlhZGVzcHXDqXNkZXBvcnRlc3Byb3llY3RvcHJvZHVjdG9ww7pibGljb25vc290cm9zaGlzdG9yaWFwcmVzZW50ZW1pbGxvbmVzbWVkaWFudGVwcmVndW50YWFudGVyaW9ycmVjdXJzb3Nwcm9ibGVtYXNhbnRpYWdvbnVlc3Ryb3NvcGluacOzbmltcHJpbWlybWllbnRyYXNhbcOpcmljYXZlbmRlZG9yc29jaWVkYWRyZXNwZWN0b3JlYWxpemFycmVnaXN0cm9wYWxhYnJhc2ludGVyw6lzZW50b25jZXNlc3BlY2lhbG1pZW1icm9zcmVhbGlkYWRjw7NyZG9iYXphcmFnb3phcMOhZ2luYXNzb2NpYWxlc2Jsb3F1ZWFyZ2VzdGnDs25hbHF1aWxlcnNpc3RlbWFzY2llbmNpYXNjb21wbGV0b3ZlcnNpw7NuY29tcGxldGFlc3R1ZGlvc3DDumJsaWNhb2JqZXRpdm9hbGljYW50ZWJ1c2NhZG9yY2FudGlkYWRlbnRyYWRhc2FjY2lvbmVzYXJjaGl2b3NzdXBlcmlvcm1heW9yw61hYWxlbWFuaWFmdW5jacOzbsO6bHRpbW9zaGFjaWVuZG9hcXVlbGxvc2VkaWNpw7NuZmVybmFuZG9hbWJpZW50ZWZhY2Vib29rbnVlc3RyYXNjbGllbnRlc3Byb2Nlc29zYmFzdGFudGVwcmVzZW50YXJlcG9ydGFyY29uZ3Jlc29wdWJsaWNhcmNvbWVyY2lvY29udHJhdG9qw7N2ZW5lc2Rpc3RyaXRvdMOpY25pY2Fjb25qdW50b2VuZXJnw61hdHJhYmFqYXJhc3R1cmlhc3JlY2llbnRldXRpbGl6YXJib2xldMOtbnNhbHZhZG9yY29ycmVjdGF0cmFiYWpvc3ByaW1lcm9zbmVnb2Npb3NsaWJlcnRhZGRldGFsbGVzcGFudGFsbGFwcsOzeGltb2FsbWVyw61hYW5pbWFsZXNxdWnDqW5lc2NvcmF6w7Nuc2VjY2nDs25idXNjYW5kb29wY2lvbmVzZXh0ZXJpb3Jjb25jZXB0b3RvZGF2w61hZ2FsZXLDrWFlc2NyaWJpcm1lZGljaW5hbGljZW5jaWFjb25zdWx0YWFzcGVjdG9zY3LDrXRpY2Fkw7NsYXJlc2p1c3RpY2lhZGViZXLDoW5wZXLDrW9kb25lY2VzaXRhbWFudGVuZXJwZXF1ZcOxb3JlY2liaWRhdHJpYnVuYWx0ZW5lcmlmZWNhbmNpw7NuY2FuYXJpYXNkZXNjYXJnYWRpdmVyc29zbWFsbG9yY2FyZXF1aWVyZXTDqWNuaWNvZGViZXLDrWF2aXZpZW5kYWZpbmFuemFzYWRlbGFudGVmdW5jaW9uYWNvbnNlam9zZGlmw61jaWxjaXVkYWRlc2FudGlndWFzYXZhbnphZGF0w6lybWlub3VuaWRhZGVzc8OhbmNoZXpjYW1wYcOxYXNvZnRvbmljcmV2aXN0YXNjb250aWVuZXNlY3RvcmVzbW9tZW50b3NmYWN1bHRhZGNyw6lkaXRvZGl2ZXJzYXNzdXB1ZXN0b2ZhY3RvcmVzc2VndW5kb3NwZXF1ZcOxYdCz0L7QtNCw0LXRgdC70LjQtdGB0YLRjNCx0YvQu9C+0LHRi9GC0YzRjdGC0L7QvNCV0YHQu9C40YLQvtCz0L7QvNC10L3Rj9Cy0YHQtdGF0Y3RgtC+0LnQtNCw0LbQtdCx0YvQu9C40LPQvtC00YPQtNC10L3RjNGN0YLQvtGC0LHRi9C70LDRgdC10LHRj9C+0LTQuNC90YHQtdCx0LXQvdCw0LTQvtGB0LDQudGC0YTQvtGC0L7QvdC10LPQvtGB0LLQvtC40YHQstC+0LnQuNCz0YDRi9GC0L7QttC10LLRgdC10LzRgdCy0L7RjtC70LjRiNGM0Y3RgtC40YXQv9C+0LrQsNC00L3QtdC50LTQvtC80LDQvNC40YDQsNC70LjQsdC+0YLQtdC80YPRhdC+0YLRj9C00LLRg9GF0YHQtdGC0LjQu9GO0LTQuNC00LXQu9C+0LzQuNGA0LXRgtC10LHRj9GB0LLQvtC10LLQuNC00LXRh9C10LPQvtGN0YLQuNC80YHRh9C10YLRgtC10LzRi9GG0LXQvdGL0YHRgtCw0LvQstC10LTRjNGC0LXQvNC10LLQvtC00YvRgtC10LHQtdCy0YvRiNC10L3QsNC80LjRgtC40L/QsNGC0L7QvNGD0L/RgNCw0LLQu9C40YbQsNC+0LTQvdCw0LPQvtC00YvQt9C90LDRjtC80L7Qs9GD0LTRgNGD0LPQstGB0LXQudC40LTQtdGC0LrQuNC90L7QvtC00L3QvtC00LXQu9Cw0LTQtdC70LXRgdGA0L7QutC40Y7QvdGP0LLQtdGB0YzQldGB0YLRjNGA0LDQt9Cw0L3QsNGI0LjYp9mE2YTZh9in2YTYqtmK2KzZhdmK2LnYrtin2LXYqdin2YTYsNmK2LnZhNmK2YfYrNiv2YrYr9in2YTYotmG2KfZhNix2K/Yqtit2YPZhdi12YHYrdip2YPYp9mG2KrYp9mE2YTZitmK2YPZiNmG2LTYqNmD2KnZgdmK2YfYp9io2YbYp9iq2K3ZiNin2KHYo9mD2KvYsdiu2YTYp9mE2KfZhNit2KjYr9mE2YrZhNiv2LHZiNiz2KfYtti62LfYqtmD2YjZhtmH2YbYp9mD2LPYp9it2KnZhtin2K/Zitin2YTYt9io2LnZhNmK2YPYtNmD2LHYp9mK2YXZg9mG2YXZhtmH2KfYtNix2YPYqdix2KbZitiz2YbYtNmK2LfZhdin2LDYp9in2YTZgdmG2LTYqNin2KjYqti52KjYsdix2K3Zhdip2YPYp9mB2KnZitmC2YjZhNmF2LHZg9iy2YPZhNmF2KnYo9it2YXYr9mC2YTYqNmK2YrYudmG2YrYtdmI2LHYqdi32LHZitmC2LTYp9ix2YPYrNmI2KfZhNij2K7YsdmJ2YXYudmG2KfYp9io2K3Yq9i52LHZiNi22KjYtNmD2YTZhdiz2KzZhNio2YbYp9mG2K7Yp9mE2K/Zg9iq2KfYqNmD2YTZitip2KjYr9mI2YbYo9mK2LbYp9mK2YjYrNiv2YHYsdmK2YLZg9iq2KjYqtij2YHYttmE2YXYt9io2K7Yp9mD2KvYsdio2KfYsdmD2KfZgdi22YTYp9it2YTZidmG2YHYs9mH2KPZitin2YXYsdiv2YjYr9ij2YbZh9in2K/ZitmG2KfYp9mE2KfZhtmF2LnYsdi22KrYudmE2YXYr9in2K7ZhNmF2YXZg9mGAEH0suYAC1wBAAEAAQABAAIAAgACAAIABAAEAAQABAAAAQIDBAUGBwcGBQQDAgEACAkKCwwNDg8PDg0MCwoJCBAREhMUFRYXFxYVFBMSERAYGRobHB0eHx8eHRwbGhkY/////wBB2LPmAAvk6QT/////AQAAAAIAAAACAAAAAQAAAAEAAAADAAAA//8AAQAAAAEAAP//AAEAAAAIAAgACAAIAAAAAQACAAMABAAFAAYAB3Jlc291cmNlc2NvdW50cmllc3F1ZXN0aW9uc2VxdWlwbWVudGNvbW11bml0eWF2YWlsYWJsZWhpZ2hsaWdodERURC94aHRtbG1hcmtldGluZ2tub3dsZWRnZXNvbWV0aGluZ2NvbnRhaW5lcmRpcmVjdGlvbnN1YnNjcmliZWFkdmVydGlzZWNoYXJhY3RlciIgdmFsdWU9Ijwvc2VsZWN0PkF1c3RyYWxpYSIgY2xhc3M9InNpdHVhdGlvbmF1dGhvcml0eWZvbGxvd2luZ3ByaW1hcmlseW9wZXJhdGlvbmNoYWxsZW5nZWRldmVsb3BlZGFub255bW91c2Z1bmN0aW9uIGZ1bmN0aW9uc2NvbXBhbmllc3N0cnVjdHVyZWFncmVlbWVudCIgdGl0bGU9InBvdGVudGlhbGVkdWNhdGlvbmFyZ3VtZW50c3NlY29uZGFyeWNvcHlyaWdodGxhbmd1YWdlc2V4Y2x1c2l2ZWNvbmRpdGlvbjwvZm9ybT4NCnN0YXRlbWVudGF0dGVudGlvbkJpb2dyYXBoeX0gZWxzZSB7CnNvbHV0aW9uc3doZW4gdGhlIEFuYWx5dGljc3RlbXBsYXRlc2Rhbmdlcm91c3NhdGVsbGl0ZWRvY3VtZW50c3B1Ymxpc2hlcmltcG9ydGFudHByb3RvdHlwZWluZmx1ZW5jZSZyYXF1bzs8L2VmZmVjdGl2ZWdlbmVyYWxseXRyYW5zZm9ybWJlYXV0aWZ1bHRyYW5zcG9ydG9yZ2FuaXplZHB1Ymxpc2hlZHByb21pbmVudHVudGlsIHRoZXRodW1ibmFpbE5hdGlvbmFsIC5mb2N1cygpO292ZXIgdGhlIG1pZ3JhdGlvbmFubm91bmNlZGZvb3RlciI+CmV4Y2VwdGlvbmxlc3MgdGhhbmV4cGVuc2l2ZWZvcm1hdGlvbmZyYW1ld29ya3RlcnJpdG9yeW5kaWNhdGlvbmN1cnJlbnRseWNsYXNzTmFtZWNyaXRpY2lzbXRyYWRpdGlvbmVsc2V3aGVyZUFsZXhhbmRlcmFwcG9pbnRlZG1hdGVyaWFsc2Jyb2FkY2FzdG1lbnRpb25lZGFmZmlsaWF0ZTwvb3B0aW9uPnRyZWF0bWVudGRpZmZlcmVudC9kZWZhdWx0LlByZXNpZGVudG9uY2xpY2s9ImJpb2dyYXBoeW90aGVyd2lzZXBlcm1hbmVudEZyYW7Dp2Fpc0hvbGx5d29vZGV4cGFuc2lvbnN0YW5kYXJkczwvc3R5bGU+CnJlZHVjdGlvbkRlY2VtYmVyIHByZWZlcnJlZENhbWJyaWRnZW9wcG9uZW50c0J1c2luZXNzIGNvbmZ1c2lvbj4KPHRpdGxlPnByZXNlbnRlZGV4cGxhaW5lZGRvZXMgbm90IHdvcmxkd2lkZWludGVyZmFjZXBvc2l0aW9uc25ld3NwYXBlcjwvdGFibGU+Cm1vdW50YWluc2xpa2UgdGhlIGVzc2VudGlhbGZpbmFuY2lhbHNlbGVjdGlvbmFjdGlvbj0iL2FiYW5kb25lZEVkdWNhdGlvbnBhcnNlSW50KHN0YWJpbGl0eXVuYWJsZSB0bzwvdGl0bGU+CnJlbGF0aW9uc05vdGUgdGhhdGVmZmljaWVudHBlcmZvcm1lZHR3byB5ZWFyc1NpbmNlIHRoZXRoZXJlZm9yZXdyYXBwZXIiPmFsdGVybmF0ZWluY3JlYXNlZEJhdHRsZSBvZnBlcmNlaXZlZHRyeWluZyB0b25lY2Vzc2FyeXBvcnRyYXllZGVsZWN0aW9uc0VsaXphYmV0aDwvaWZyYW1lPmRpc2NvdmVyeWluc3VyYW5jZXMubGVuZ3RoO2xlZ2VuZGFyeUdlb2dyYXBoeWNhbmRpZGF0ZWNvcnBvcmF0ZXNvbWV0aW1lc3NlcnZpY2VzLmluaGVyaXRlZDwvc3Ryb25nPkNvbW11bml0eXJlbGlnaW91c2xvY2F0aW9uc0NvbW1pdHRlZWJ1aWxkaW5nc3RoZSB3b3JsZG5vIGxvbmdlcmJlZ2lubmluZ3JlZmVyZW5jZWNhbm5vdCBiZWZyZXF1ZW5jeXR5cGljYWxseWludG8gdGhlIHJlbGF0aXZlO3JlY29yZGluZ3ByZXNpZGVudGluaXRpYWxseXRlY2huaXF1ZXRoZSBvdGhlcml0IGNhbiBiZWV4aXN0ZW5jZXVuZGVybGluZXRoaXMgdGltZXRlbGVwaG9uZWl0ZW1zY29wZXByYWN0aWNlc2FkdmFudGFnZSk7cmV0dXJuIEZvciBvdGhlcnByb3ZpZGluZ2RlbW9jcmFjeWJvdGggdGhlIGV4dGVuc2l2ZXN1ZmZlcmluZ3N1cHBvcnRlZGNvbXB1dGVycyBmdW5jdGlvbnByYWN0aWNhbHNhaWQgdGhhdGl0IG1heSBiZUVuZ2xpc2g8L2Zyb20gdGhlIHNjaGVkdWxlZGRvd25sb2FkczwvbGFiZWw+CnN1c3BlY3RlZG1hcmdpbjogMHNwaXJpdHVhbDwvaGVhZD4KCm1pY3Jvc29mdGdyYWR1YWxseWRpc2N1c3NlZGhlIGJlY2FtZWV4ZWN1dGl2ZWpxdWVyeS5qc2hvdXNlaG9sZGNvbmZpcm1lZHB1cmNoYXNlZGxpdGVyYWxseWRlc3Ryb3llZHVwIHRvIHRoZXZhcmlhdGlvbnJlbWFpbmluZ2l0IGlzIG5vdGNlbnR1cmllc0phcGFuZXNlIGFtb25nIHRoZWNvbXBsZXRlZGFsZ29yaXRobWludGVyZXN0c3JlYmVsbGlvbnVuZGVmaW5lZGVuY291cmFnZXJlc2l6YWJsZWludm9sdmluZ3NlbnNpdGl2ZXVuaXZlcnNhbHByb3Zpc2lvbihhbHRob3VnaGZlYXR1cmluZ2NvbmR1Y3RlZCksIHdoaWNoIGNvbnRpbnVlZC1oZWFkZXIiPkZlYnJ1YXJ5IG51bWVyb3VzIG92ZXJmbG93OmNvbXBvbmVudGZyYWdtZW50c2V4Y2VsbGVudGNvbHNwYW49InRlY2huaWNhbG5lYXIgdGhlIEFkdmFuY2VkIHNvdXJjZSBvZmV4cHJlc3NlZEhvbmcgS29uZyBGYWNlYm9va211bHRpcGxlIG1lY2hhbmlzbWVsZXZhdGlvbm9mZmVuc2l2ZTwvZm9ybT4KCXNwb25zb3JlZGRvY3VtZW50Lm9yICZxdW90O3RoZXJlIGFyZXRob3NlIHdob21vdmVtZW50c3Byb2Nlc3Nlc2RpZmZpY3VsdHN1Ym1pdHRlZHJlY29tbWVuZGNvbnZpbmNlZHByb21vdGluZyIgd2lkdGg9Ii5yZXBsYWNlKGNsYXNzaWNhbGNvYWxpdGlvbmhpcyBmaXJzdGRlY2lzaW9uc2Fzc2lzdGFudGluZGljYXRlZGV2b2x1dGlvbi13cmFwcGVyImVub3VnaCB0b2Fsb25nIHRoZWRlbGl2ZXJlZC0tPg0KPCEtLUFtZXJpY2FuIHByb3RlY3RlZE5vdmVtYmVyIDwvc3R5bGU+PGZ1cm5pdHVyZUludGVybmV0ICBvbmJsdXI9InN1c3BlbmRlZHJlY2lwaWVudGJhc2VkIG9uIE1vcmVvdmVyLGFib2xpc2hlZGNvbGxlY3RlZHdlcmUgbWFkZWVtb3Rpb25hbGVtZXJnZW5jeW5hcnJhdGl2ZWFkdm9jYXRlc3B4O2JvcmRlcmNvbW1pdHRlZGRpcj0ibHRyImVtcGxveWVlc3Jlc2VhcmNoLiBzZWxlY3RlZHN1Y2Nlc3NvcmN1c3RvbWVyc2Rpc3BsYXllZFNlcHRlbWJlcmFkZENsYXNzKEZhY2Vib29rIHN1Z2dlc3RlZGFuZCBsYXRlcm9wZXJhdGluZ2VsYWJvcmF0ZVNvbWV0aW1lc0luc3RpdHV0ZWNlcnRhaW5seWluc3RhbGxlZGZvbGxvd2Vyc0plcnVzYWxlbXRoZXkgaGF2ZWNvbXB1dGluZ2dlbmVyYXRlZHByb3ZpbmNlc2d1YXJhbnRlZWFyYml0cmFyeXJlY29nbml6ZXdhbnRlZCB0b3B4O3dpZHRoOnRoZW9yeSBvZmJlaGF2aW91cldoaWxlIHRoZWVzdGltYXRlZGJlZ2FuIHRvIGl0IGJlY2FtZW1hZ25pdHVkZW11c3QgaGF2ZW1vcmUgdGhhbkRpcmVjdG9yeWV4dGVuc2lvbnNlY3JldGFyeW5hdHVyYWxseW9jY3VycmluZ3ZhcmlhYmxlc2dpdmVuIHRoZXBsYXRmb3JtLjwvbGFiZWw+PGZhaWxlZCB0b2NvbXBvdW5kc2tpbmRzIG9mIHNvY2lldGllc2Fsb25nc2lkZSAtLSZndDsKCnNvdXRod2VzdHRoZSByaWdodHJhZGlhdGlvbm1heSBoYXZlIHVuZXNjYXBlKHNwb2tlbiBpbiIgaHJlZj0iL3Byb2dyYW1tZW9ubHkgdGhlIGNvbWUgZnJvbWRpcmVjdG9yeWJ1cmllZCBpbmEgc2ltaWxhcnRoZXkgd2VyZTwvZm9udD48L05vcndlZ2lhbnNwZWNpZmllZHByb2R1Y2luZ3Bhc3NlbmdlcihuZXcgRGF0ZXRlbXBvcmFyeWZpY3Rpb25hbEFmdGVyIHRoZWVxdWF0aW9uc2Rvd25sb2FkLnJlZ3VsYXJseWRldmVsb3BlcmFib3ZlIHRoZWxpbmtlZCB0b3BoZW5vbWVuYXBlcmlvZCBvZnRvb2x0aXAiPnN1YnN0YW5jZWF1dG9tYXRpY2FzcGVjdCBvZkFtb25nIHRoZWNvbm5lY3RlZGVzdGltYXRlc0FpciBGb3JjZXN5c3RlbSBvZm9iamVjdGl2ZWltbWVkaWF0ZW1ha2luZyBpdHBhaW50aW5nc2NvbnF1ZXJlZGFyZSBzdGlsbHByb2NlZHVyZWdyb3d0aCBvZmhlYWRlZCBieUV1cm9wZWFuIGRpdmlzaW9uc21vbGVjdWxlc2ZyYW5jaGlzZWludGVudGlvbmF0dHJhY3RlZGNoaWxkaG9vZGFsc28gdXNlZGRlZGljYXRlZHNpbmdhcG9yZWRlZ3JlZSBvZmZhdGhlciBvZmNvbmZsaWN0czwvYT48L3A+CmNhbWUgZnJvbXdlcmUgdXNlZG5vdGUgdGhhdHJlY2VpdmluZ0V4ZWN1dGl2ZWV2ZW4gbW9yZWFjY2VzcyB0b2NvbW1hbmRlclBvbGl0aWNhbG11c2ljaWFuc2RlbGljaW91c3ByaXNvbmVyc2FkdmVudCBvZlVURi04IiAvPjwhW0NEQVRBWyI+Q29udGFjdFNvdXRoZXJuIGJnY29sb3I9InNlcmllcyBvZi4gSXQgd2FzIGluIEV1cm9wZXBlcm1pdHRlZHZhbGlkYXRlLmFwcGVhcmluZ29mZmljaWFsc3NlcmlvdXNseS1sYW5ndWFnZWluaXRpYXRlZGV4dGVuZGluZ2xvbmctdGVybWluZmxhdGlvbnN1Y2ggdGhhdGdldENvb2tpZW1hcmtlZCBieTwvYnV0dG9uPmltcGxlbWVudGJ1dCBpdCBpc2luY3JlYXNlc2Rvd24gdGhlIHJlcXVpcmluZ2RlcGVuZGVudC0tPgo8IS0tIGludGVydmlld1dpdGggdGhlIGNvcGllcyBvZmNvbnNlbnN1c3dhcyBidWlsdFZlbmV6dWVsYShmb3JtZXJseXRoZSBzdGF0ZXBlcnNvbm5lbHN0cmF0ZWdpY2Zhdm91ciBvZmludmVudGlvbldpa2lwZWRpYWNvbnRpbmVudHZpcnR1YWxseXdoaWNoIHdhc3ByaW5jaXBsZUNvbXBsZXRlIGlkZW50aWNhbHNob3cgdGhhdHByaW1pdGl2ZWF3YXkgZnJvbW1vbGVjdWxhcnByZWNpc2VseWRpc3NvbHZlZFVuZGVyIHRoZXZlcnNpb249Ij4mbmJzcDs8L0l0IGlzIHRoZSBUaGlzIGlzIHdpbGwgaGF2ZW9yZ2FuaXNtc3NvbWUgdGltZUZyaWVkcmljaHdhcyBmaXJzdHRoZSBvbmx5IGZhY3QgdGhhdGZvcm0gaWQ9InByZWNlZGluZ1RlY2huaWNhbHBoeXNpY2lzdG9jY3VycyBpbm5hdmlnYXRvcnNlY3Rpb24iPnNwYW4gaWQ9InNvdWdodCB0b2JlbG93IHRoZXN1cnZpdmluZ308L3N0eWxlPmhpcyBkZWF0aGFzIGluIHRoZWNhdXNlZCBieXBhcnRpYWxseWV4aXN0aW5nIHVzaW5nIHRoZXdhcyBnaXZlbmEgbGlzdCBvZmxldmVscyBvZm5vdGlvbiBvZk9mZmljaWFsIGRpc21pc3NlZHNjaWVudGlzdHJlc2VtYmxlc2R1cGxpY2F0ZWV4cGxvc2l2ZXJlY292ZXJlZGFsbCBvdGhlcmdhbGxlcmllc3twYWRkaW5nOnBlb3BsZSBvZnJlZ2lvbiBvZmFkZHJlc3Nlc2Fzc29jaWF0ZWltZyBhbHQ9ImluIG1vZGVybnNob3VsZCBiZW1ldGhvZCBvZnJlcG9ydGluZ3RpbWVzdGFtcG5lZWRlZCB0b3RoZSBHcmVhdHJlZ2FyZGluZ3NlZW1lZCB0b3ZpZXdlZCBhc2ltcGFjdCBvbmlkZWEgdGhhdHRoZSBXb3JsZGhlaWdodCBvZmV4cGFuZGluZ1RoZXNlIGFyZWN1cnJlbnQiPmNhcmVmdWxseW1haW50YWluc2NoYXJnZSBvZkNsYXNzaWNhbGFkZHJlc3NlZHByZWRpY3RlZG93bmVyc2hpcDxkaXYgaWQ9InJpZ2h0Ij4NCnJlc2lkZW5jZWxlYXZlIHRoZWNvbnRlbnQiPmFyZSBvZnRlbiAgfSkoKTsNCnByb2JhYmx5IFByb2Zlc3Nvci1idXR0b24iIHJlc3BvbmRlZHNheXMgdGhhdGhhZCB0byBiZXBsYWNlZCBpbkh1bmdhcmlhbnN0YXR1cyBvZnNlcnZlcyBhc1VuaXZlcnNhbGV4ZWN1dGlvbmFnZ3JlZ2F0ZWZvciB3aGljaGluZmVjdGlvbmFncmVlZCB0b2hvd2V2ZXIsIHBvcHVsYXIiPnBsYWNlZCBvbmNvbnN0cnVjdGVsZWN0b3JhbHN5bWJvbCBvZmluY2x1ZGluZ3JldHVybiB0b2FyY2hpdGVjdENocmlzdGlhbnByZXZpb3VzIGxpdmluZyBpbmVhc2llciB0b3Byb2Zlc3NvcgombHQ7IS0tIGVmZmVjdCBvZmFuYWx5dGljc3dhcyB0YWtlbndoZXJlIHRoZXRvb2sgb3ZlcmJlbGllZiBpbkFmcmlrYWFuc2FzIGZhciBhc3ByZXZlbnRlZHdvcmsgd2l0aGEgc3BlY2lhbDxmaWVsZHNldENocmlzdG1hc1JldHJpZXZlZAoKSW4gdGhlIGJhY2sgaW50b25vcnRoZWFzdG1hZ2F6aW5lcz48c3Ryb25nPmNvbW1pdHRlZWdvdmVybmluZ2dyb3VwcyBvZnN0b3JlZCBpbmVzdGFibGlzaGEgZ2VuZXJhbGl0cyBmaXJzdHRoZWlyIG93bnBvcHVsYXRlZGFuIG9iamVjdENhcmliYmVhbmFsbG93IHRoZWRpc3RyaWN0c3dpc2NvbnNpbmxvY2F0aW9uLjsgd2lkdGg6IGluaGFiaXRlZFNvY2lhbGlzdEphbnVhcnkgMTwvZm9vdGVyPnNpbWlsYXJseWNob2ljZSBvZnRoZSBzYW1lIHNwZWNpZmljIGJ1c2luZXNzIFRoZSBmaXJzdC5sZW5ndGg7IGRlc2lyZSB0b2RlYWwgd2l0aHNpbmNlIHRoZXVzZXJBZ2VudGNvbmNlaXZlZGluZGV4LnBocGFzICZxdW90O2VuZ2FnZSBpbnJlY2VudGx5LGZldyB5ZWFyc3dlcmUgYWxzbwo8aGVhZD4KPGVkaXRlZCBieWFyZSBrbm93bmNpdGllcyBpbmFjY2Vzc2tleWNvbmRlbW5lZGFsc28gaGF2ZXNlcnZpY2VzLGZhbWlseSBvZlNjaG9vbCBvZmNvbnZlcnRlZG5hdHVyZSBvZiBsYW5ndWFnZW1pbmlzdGVyczwvb2JqZWN0PnRoZXJlIGlzIGEgcG9wdWxhcnNlcXVlbmNlc2Fkdm9jYXRlZFRoZXkgd2VyZWFueSBvdGhlcmxvY2F0aW9uPWVudGVyIHRoZW11Y2ggbW9yZXJlZmxlY3RlZHdhcyBuYW1lZG9yaWdpbmFsIGEgdHlwaWNhbHdoZW4gdGhleWVuZ2luZWVyc2NvdWxkIG5vdHJlc2lkZW50c3dlZG5lc2RheXRoZSB0aGlyZCBwcm9kdWN0c0phbnVhcnkgMndoYXQgdGhleWEgY2VydGFpbnJlYWN0aW9uc3Byb2Nlc3NvcmFmdGVyIGhpc3RoZSBsYXN0IGNvbnRhaW5lZCI+PC9kaXY+CjwvYT48L3RkPmRlcGVuZCBvbnNlYXJjaCI+CnBpZWNlcyBvZmNvbXBldGluZ1JlZmVyZW5jZXRlbm5lc3NlZXdoaWNoIGhhcyB2ZXJzaW9uPTwvc3Bhbj4gPDwvaGVhZGVyPmdpdmVzIHRoZWhpc3RvcmlhbnZhbHVlPSIiPnBhZGRpbmc6MHZpZXcgdGhhdHRvZ2V0aGVyLHRoZSBtb3N0IHdhcyBmb3VuZHN1YnNldCBvZmF0dGFjayBvbmNoaWxkcmVuLHBvaW50cyBvZnBlcnNvbmFsIHBvc2l0aW9uOmFsbGVnZWRseUNsZXZlbGFuZHdhcyBsYXRlcmFuZCBhZnRlcmFyZSBnaXZlbndhcyBzdGlsbHNjcm9sbGluZ2Rlc2lnbiBvZm1ha2VzIHRoZW11Y2ggbGVzc0FtZXJpY2Fucy4KCkFmdGVyICwgYnV0IHRoZU11c2V1bSBvZmxvdWlzaWFuYShmcm9tIHRoZW1pbm5lc290YXBhcnRpY2xlc2EgcHJvY2Vzc0RvbWluaWNhbnZvbHVtZSBvZnJldHVybmluZ2RlZmVuc2l2ZTAwcHh8cmlnaG1hZGUgZnJvbW1vdXNlb3ZlciIgc3R5bGU9InN0YXRlcyBvZih3aGljaCBpc2NvbnRpbnVlc0ZyYW5jaXNjb2J1aWxkaW5nIHdpdGhvdXQgYXdpdGggc29tZXdobyB3b3VsZGEgZm9ybSBvZmEgcGFydCBvZmJlZm9yZSBpdGtub3duIGFzICBTZXJ2aWNlc2xvY2F0aW9uIGFuZCBvZnRlbm1lYXN1cmluZ2FuZCBpdCBpc3BhcGVyYmFja3ZhbHVlcyBvZg0KPHRpdGxlPj0gd2luZG93LmRldGVybWluZWVyJnF1b3Q7IHBsYXllZCBieWFuZCBlYXJseTwvY2VudGVyPmZyb20gdGhpc3RoZSB0aHJlZXBvd2VyIGFuZG9mICZxdW90O2lubmVySFRNTDxhIGhyZWY9Ink6aW5saW5lO0NodXJjaCBvZnRoZSBldmVudHZlcnkgaGlnaG9mZmljaWFsIC1oZWlnaHQ6IGNvbnRlbnQ9Ii9jZ2ktYmluL3RvIGNyZWF0ZWFmcmlrYWFuc2VzcGVyYW50b2ZyYW7Dp2Fpc2xhdHZpZcWhdWxpZXR1dmnFs8SMZcWhdGluYcSNZcWhdGluYeC5hOC4l+C4ouaXpeacrOiqnueugOS9k+Wtl+e5gemrlOWtl+2VnOq1reyWtOS4uuS7gOS5iOiuoeeul+acuueslOiusOacrOiojuirluWNgOacjeWKoeWZqOS6kuiBlOe9keaIv+WcsOS6p+S/seS5kOmDqOWHuueJiOekvuaOkuihjOamnOmDqOiQveagvOi/m+S4gOatpeaUr+S7mOWunemqjOivgeeggeWnlOWRmOS8muaVsOaNruW6k+a2iOi0ueiAheWKnuWFrOWupOiuqOiuuuWMuua3seWcs+W4guaSreaUvuWZqOWMl+S6rOW4guWkp+WtpueUn+i2iuadpei2iueuoeeQhuWRmOS/oeaBr+e9kXNlcnZpY2lvc2FydMOtY3Vsb2FyZ2VudGluYWJhcmNlbG9uYWN1YWxxdWllcnB1YmxpY2Fkb3Byb2R1Y3Rvc3BvbMOtdGljYXJlc3B1ZXN0YXdpa2lwZWRpYXNpZ3VpZW50ZWLDunNxdWVkYWNvbXVuaWRhZHNlZ3VyaWRhZHByaW5jaXBhbHByZWd1bnRhc2NvbnRlbmlkb3Jlc3BvbmRlcnZlbmV6dWVsYXByb2JsZW1hc2RpY2llbWJyZXJlbGFjacOzbm5vdmllbWJyZXNpbWlsYXJlc3Byb3llY3Rvc3Byb2dyYW1hc2luc3RpdHV0b2FjdGl2aWRhZGVuY3VlbnRyYWVjb25vbcOtYWltw6FnZW5lc2NvbnRhY3RhcmRlc2Nhcmdhcm5lY2VzYXJpb2F0ZW5jacOzbnRlbMOpZm9ub2NvbWlzacOzbmNhbmNpb25lc2NhcGFjaWRhZGVuY29udHJhcmFuw6FsaXNpc2Zhdm9yaXRvc3TDqXJtaW5vc3Byb3ZpbmNpYWV0aXF1ZXRhc2VsZW1lbnRvc2Z1bmNpb25lc3Jlc3VsdGFkb2NhcsOhY3RlcnByb3BpZWRhZHByaW5jaXBpb25lY2VzaWRhZG11bmljaXBhbGNyZWFjacOzbmRlc2Nhcmdhc3ByZXNlbmNpYWNvbWVyY2lhbG9waW5pb25lc2VqZXJjaWNpb2VkaXRvcmlhbHNhbGFtYW5jYWdvbnrDoWxlemRvY3VtZW50b3BlbMOtY3VsYXJlY2llbnRlc2dlbmVyYWxlc3RhcnJhZ29uYXByw6FjdGljYW5vdmVkYWRlc3Byb3B1ZXN0YXBhY2llbnRlc3TDqWNuaWNhc29iamV0aXZvc2NvbnRhY3Rvc+CkruClh+CkguCksuCkv+Ckj+CkueCliOCkguCkl+Ckr+CkvuCkuOCkvuCkpeCkj+CkteCkguCksOCkueClh+CkleCli+CkiOCkleClgeCkm+CksOCkueCkvuCkrOCkvuCkpuCkleCkueCkvuCkuOCkreClgOCkueClgeCkj+CksOCkueClgOCkruCliOCkguCkpuCkv+CkqOCkrOCkvuCkpGRpcGxvZG9jc+CkuOCkruCkr+CksOClguCkquCkqOCkvuCkruCkquCkpOCkvuCkq+Ckv+CksOCklOCkuOCkpOCkpOCksOCkueCksuCli+Ckl+CkueClgeCkhuCkrOCkvuCksOCkpuClh+CktuCkueClgeCkiOCkluClh+CksuCkr+CkpuCkv+CkleCkvuCkruCkteClh+CkrOCkpOClgOCkqOCkrOClgOCkmuCkruCljOCkpOCkuOCkvuCksuCksuClh+CkluCknOClieCkrOCkruCkpuCkpuCkpOCkpeCkvuCkqOCkueClgOCktuCkueCksOCkheCksuCkl+CkleCkreClgOCkqOCkl+CksOCkquCkvuCkuOCksOCkvuCkpOCkleCkv+Ckj+CkieCkuOClh+Ckl+Ckr+ClgOCkueClguCkgeCkhuCkl+Clh+Ckn+ClgOCkruCkluCli+CknOCkleCkvuCksOCkheCkreClgOCkl+Ckr+Clh+CkpOClgeCkruCkteCli+Ckn+CkpuClh+CkguCkheCkl+CksOCkkOCkuOClh+CkruClh+CksuCksuCkl+CkvuCkueCkvuCksuCkiuCkquCksOCkmuCkvuCksOCkkOCkuOCkvuCkpuClh+CksOCknOCkv+CkuOCkpuCkv+CksuCkrOCkguCkpuCkrOCkqOCkvuCkueClguCkguCksuCkvuCkluCknOClgOCkpOCkrOCkn+CkqOCkruCkv+CksuCkh+CkuOClh+CkhuCkqOClh+CkqOCkr+CkvuCkleClgeCksuCksuClieCkl+CkreCkvuCkl+CksOClh+CksuCknOCkl+CkueCksOCkvuCkruCksuCkl+Clh+CkquClh+CknOCkueCkvuCkpeCkh+CkuOClgOCkuOCkueClgOCkleCksuCkvuCkoOClgOCkleCkueCkvuCkgeCkpuClguCksOCkpOCkueCkpOCkuOCkvuCkpOCkr+CkvuCkpuCkhuCkr+CkvuCkquCkvuCkleCkleCljOCkqOCktuCkvuCkruCkpuClh+CkluCkr+CkueClgOCksOCkvuCkr+CkluClgeCkpuCksuCkl+ClgGNhdGVnb3JpZXNleHBlcmllbmNlPC90aXRsZT4NCkNvcHlyaWdodCBqYXZhc2NyaXB0Y29uZGl0aW9uc2V2ZXJ5dGhpbmc8cCBjbGFzcz0idGVjaG5vbG9neWJhY2tncm91bmQ8YSBjbGFzcz0ibWFuYWdlbWVudCZjb3B5OyAyMDFqYXZhU2NyaXB0Y2hhcmFjdGVyc2JyZWFkY3J1bWJ0aGVtc2VsdmVzaG9yaXpvbnRhbGdvdmVybm1lbnRDYWxpZm9ybmlhYWN0aXZpdGllc2Rpc2NvdmVyZWROYXZpZ2F0aW9udHJhbnNpdGlvbmNvbm5lY3Rpb25uYXZpZ2F0aW9uYXBwZWFyYW5jZTwvdGl0bGU+PG1jaGVja2JveCIgdGVjaG5pcXVlc3Byb3RlY3Rpb25hcHBhcmVudGx5YXMgd2VsbCBhc3VudCcsICdVQS1yZXNvbHV0aW9ub3BlcmF0aW9uc3RlbGV2aXNpb250cmFuc2xhdGVkV2FzaGluZ3Rvbm5hdmlnYXRvci4gPSB3aW5kb3cuaW1wcmVzc2lvbiZsdDticiZndDtsaXRlcmF0dXJlcG9wdWxhdGlvbmJnY29sb3I9IiNlc3BlY2lhbGx5IGNvbnRlbnQ9InByb2R1Y3Rpb25uZXdzbGV0dGVycHJvcGVydGllc2RlZmluaXRpb25sZWFkZXJzaGlwVGVjaG5vbG9neVBhcmxpYW1lbnRjb21wYXJpc29udWwgY2xhc3M9Ii5pbmRleE9mKCJjb25jbHVzaW9uZGlzY3Vzc2lvbmNvbXBvbmVudHNiaW9sb2dpY2FsUmV2b2x1dGlvbl9jb250YWluZXJ1bmRlcnN0b29kbm9zY3JpcHQ+PHBlcm1pc3Npb25lYWNoIG90aGVyYXRtb3NwaGVyZSBvbmZvY3VzPSI8Zm9ybSBpZD0icHJvY2Vzc2luZ3RoaXMudmFsdWVnZW5lcmF0aW9uQ29uZmVyZW5jZXN1YnNlcXVlbnR3ZWxsLWtub3dudmFyaWF0aW9uc3JlcHV0YXRpb25waGVub21lbm9uZGlzY2lwbGluZWxvZ28ucG5nIiAoZG9jdW1lbnQsYm91bmRhcmllc2V4cHJlc3Npb25zZXR0bGVtZW50QmFja2dyb3VuZG91dCBvZiB0aGVlbnRlcnByaXNlKCJodHRwczoiIHVuZXNjYXBlKCJwYXNzd29yZCIgZGVtb2NyYXRpYzxhIGhyZWY9Ii93cmFwcGVyIj4KbWVtYmVyc2hpcGxpbmd1aXN0aWNweDtwYWRkaW5ncGhpbG9zb3BoeWFzc2lzdGFuY2V1bml2ZXJzaXR5ZmFjaWxpdGllc3JlY29nbml6ZWRwcmVmZXJlbmNlaWYgKHR5cGVvZm1haW50YWluZWR2b2NhYnVsYXJ5aHlwb3RoZXNpcy5zdWJtaXQoKTsmYW1wO25ic3A7YW5ub3RhdGlvbmJlaGluZCB0aGVGb3VuZGF0aW9ucHVibGlzaGVyImFzc3VtcHRpb25pbnRyb2R1Y2VkY29ycnVwdGlvbnNjaWVudGlzdHNleHBsaWNpdGx5aW5zdGVhZCBvZmRpbWVuc2lvbnMgb25DbGljaz0iY29uc2lkZXJlZGRlcGFydG1lbnRvY2N1cGF0aW9uc29vbiBhZnRlcmludmVzdG1lbnRwcm9ub3VuY2VkaWRlbnRpZmllZGV4cGVyaW1lbnRNYW5hZ2VtZW50Z2VvZ3JhcGhpYyIgaGVpZ2h0PSJsaW5rIHJlbD0iLnJlcGxhY2UoL2RlcHJlc3Npb25jb25mZXJlbmNlcHVuaXNobWVudGVsaW1pbmF0ZWRyZXNpc3RhbmNlYWRhcHRhdGlvbm9wcG9zaXRpb253ZWxsIGtub3duc3VwcGxlbWVudGRldGVybWluZWRoMSBjbGFzcz0iMHB4O21hcmdpbm1lY2hhbmljYWxzdGF0aXN0aWNzY2VsZWJyYXRlZEdvdmVybm1lbnQKCkR1cmluZyB0ZGV2ZWxvcGVyc2FydGlmaWNpYWxlcXVpdmFsZW50b3JpZ2luYXRlZENvbW1pc3Npb25hdHRhY2htZW50PHNwYW4gaWQ9InRoZXJlIHdlcmVOZWRlcmxhbmRzYmV5b25kIHRoZXJlZ2lzdGVyZWRqb3VybmFsaXN0ZnJlcXVlbnRseWFsbCBvZiB0aGVsYW5nPSJlbiIgPC9zdHlsZT4NCmFic29sdXRlOyBzdXBwb3J0aW5nZXh0cmVtZWx5IG1haW5zdHJlYW08L3N0cm9uZz4gcG9wdWxhcml0eWVtcGxveW1lbnQ8L3RhYmxlPg0KIGNvbHNwYW49IjwvZm9ybT4KICBjb252ZXJzaW9uYWJvdXQgdGhlIDwvcD48L2Rpdj5pbnRlZ3JhdGVkIiBsYW5nPSJlblBvcnR1Z3Vlc2VzdWJzdGl0dXRlaW5kaXZpZHVhbGltcG9zc2libGVtdWx0aW1lZGlhYWxtb3N0IGFsbHB4IHNvbGlkICNhcGFydCBmcm9tc3ViamVjdCB0b2luIEVuZ2xpc2hjcml0aWNpemVkZXhjZXB0IGZvcmd1aWRlbGluZXNvcmlnaW5hbGx5cmVtYXJrYWJsZXRoZSBzZWNvbmRoMiBjbGFzcz0iPGEgdGl0bGU9IihpbmNsdWRpbmdwYXJhbWV0ZXJzcHJvaGliaXRlZD0gImh0dHA6Ly9kaWN0aW9uYXJ5cGVyY2VwdGlvbnJldm9sdXRpb25mb3VuZGF0aW9ucHg7aGVpZ2h0OnN1Y2Nlc3NmdWxzdXBwb3J0ZXJzbWlsbGVubml1bWhpcyBmYXRoZXJ0aGUgJnF1b3Q7bm8tcmVwZWF0O2NvbW1lcmNpYWxpbmR1c3RyaWFsZW5jb3VyYWdlZGFtb3VudCBvZiB1bm9mZmljaWFsZWZmaWNpZW5jeVJlZmVyZW5jZXNjb29yZGluYXRlZGlzY2xhaW1lcmV4cGVkaXRpb25kZXZlbG9waW5nY2FsY3VsYXRlZHNpbXBsaWZpZWRsZWdpdGltYXRlc3Vic3RyaW5nKDAiIGNsYXNzPSJjb21wbGV0ZWx5aWxsdXN0cmF0ZWZpdmUgeWVhcnNpbnN0cnVtZW50UHVibGlzaGluZzEiIGNsYXNzPSJwc3ljaG9sb2d5Y29uZmlkZW5jZW51bWJlciBvZiBhYnNlbmNlIG9mZm9jdXNlZCBvbmpvaW5lZCB0aGVzdHJ1Y3R1cmVzcHJldmlvdXNseT48L2lmcmFtZT5vbmNlIGFnYWluYnV0IHJhdGhlcmltbWlncmFudHNvZiBjb3Vyc2UsYSBncm91cCBvZkxpdGVyYXR1cmVVbmxpa2UgdGhlPC9hPiZuYnNwOwpmdW5jdGlvbiBpdCB3YXMgdGhlQ29udmVudGlvbmF1dG9tb2JpbGVQcm90ZXN0YW50YWdncmVzc2l2ZWFmdGVyIHRoZSBTaW1pbGFybHksIiAvPjwvZGl2PmNvbGxlY3Rpb24NCmZ1bmN0aW9udmlzaWJpbGl0eXRoZSB1c2Ugb2Z2b2x1bnRlZXJzYXR0cmFjdGlvbnVuZGVyIHRoZSB0aHJlYXRlbmVkKjwhW0NEQVRBW2ltcG9ydGFuY2VpbiBnZW5lcmFsdGhlIGxhdHRlcjwvZm9ybT4KPC8uaW5kZXhPZignaSA9IDA7IGkgPGRpZmZlcmVuY2VkZXZvdGVkIHRvdHJhZGl0aW9uc3NlYXJjaCBmb3J1bHRpbWF0ZWx5dG91cm5hbWVudGF0dHJpYnV0ZXNzby1jYWxsZWQgfQo8L3N0eWxlPmV2YWx1YXRpb25lbXBoYXNpemVkYWNjZXNzaWJsZTwvc2VjdGlvbj5zdWNjZXNzaW9uYWxvbmcgd2l0aE1lYW53aGlsZSxpbmR1c3RyaWVzPC9hPjxiciAvPmhhcyBiZWNvbWVhc3BlY3RzIG9mVGVsZXZpc2lvbnN1ZmZpY2llbnRiYXNrZXRiYWxsYm90aCBzaWRlc2NvbnRpbnVpbmdhbiBhcnRpY2xlPGltZyBhbHQ9ImFkdmVudHVyZXNoaXMgbW90aGVybWFuY2hlc3RlcnByaW5jaXBsZXNwYXJ0aWN1bGFyY29tbWVudGFyeWVmZmVjdHMgb2ZkZWNpZGVkIHRvIj48c3Ryb25nPnB1Ymxpc2hlcnNKb3VybmFsIG9mZGlmZmljdWx0eWZhY2lsaXRhdGVhY2NlcHRhYmxlc3R5bGUuY3NzIglmdW5jdGlvbiBpbm5vdmF0aW9uPkNvcHlyaWdodHNpdHVhdGlvbnN3b3VsZCBoYXZlYnVzaW5lc3Nlc0RpY3Rpb25hcnlzdGF0ZW1lbnRzb2Z0ZW4gdXNlZHBlcnNpc3RlbnRpbiBKYW51YXJ5Y29tcHJpc2luZzwvdGl0bGU+CglkaXBsb21hdGljY29udGFpbmluZ3BlcmZvcm1pbmdleHRlbnNpb25zbWF5IG5vdCBiZWNvbmNlcHQgb2Ygb25jbGljaz0iSXQgaXMgYWxzb2ZpbmFuY2lhbCBtYWtpbmcgdGhlTHV4ZW1ib3VyZ2FkZGl0aW9uYWxhcmUgY2FsbGVkZW5nYWdlZCBpbiJzY3JpcHQiKTtidXQgaXQgd2FzZWxlY3Ryb25pY29uc3VibWl0PSIKPCEtLSBFbmQgZWxlY3RyaWNhbG9mZmljaWFsbHlzdWdnZXN0aW9udG9wIG9mIHRoZXVubGlrZSB0aGVBdXN0cmFsaWFuT3JpZ2luYWxseXJlZmVyZW5jZXMKPC9oZWFkPg0KcmVjb2duaXNlZGluaXRpYWxpemVsaW1pdGVkIHRvQWxleGFuZHJpYXJldGlyZW1lbnRBZHZlbnR1cmVzZm91ciB5ZWFycwoKJmx0OyEtLSBpbmNyZWFzaW5nZGVjb3JhdGlvbmgzIGNsYXNzPSJvcmlnaW5zIG9mb2JsaWdhdGlvbnJlZ3VsYXRpb25jbGFzc2lmaWVkKGZ1bmN0aW9uKGFkdmFudGFnZXNiZWluZyB0aGUgaGlzdG9yaWFuczxiYXNlIGhyZWZyZXBlYXRlZGx5d2lsbGluZyB0b2NvbXBhcmFibGVkZXNpZ25hdGVkbm9taW5hdGlvbmZ1bmN0aW9uYWxpbnNpZGUgdGhlcmV2ZWxhdGlvbmVuZCBvZiB0aGVzIGZvciB0aGUgYXV0aG9yaXplZHJlZnVzZWQgdG90YWtlIHBsYWNlYXV0b25vbW91c2NvbXByb21pc2Vwb2xpdGljYWwgcmVzdGF1cmFudHR3byBvZiB0aGVGZWJydWFyeSAycXVhbGl0eSBvZnN3Zm9iamVjdC51bmRlcnN0YW5kbmVhcmx5IGFsbHdyaXR0ZW4gYnlpbnRlcnZpZXdzIiB3aWR0aD0iMXdpdGhkcmF3YWxmbG9hdDpsZWZ0aXMgdXN1YWxseWNhbmRpZGF0ZXNuZXdzcGFwZXJzbXlzdGVyaW91c0RlcGFydG1lbnRiZXN0IGtub3ducGFybGlhbWVudHN1cHByZXNzZWRjb252ZW5pZW50cmVtZW1iZXJlZGRpZmZlcmVudCBzeXN0ZW1hdGljaGFzIGxlZCB0b3Byb3BhZ2FuZGFjb250cm9sbGVkaW5mbHVlbmNlc2NlcmVtb25pYWxwcm9jbGFpbWVkUHJvdGVjdGlvbmxpIGNsYXNzPSJTY2llbnRpZmljY2xhc3M9Im5vLXRyYWRlbWFya3Ntb3JlIHRoYW4gd2lkZXNwcmVhZExpYmVyYXRpb250b29rIHBsYWNlZGF5IG9mIHRoZWFzIGxvbmcgYXNpbXByaXNvbmVkQWRkaXRpb25hbAo8aGVhZD4KPG1MYWJvcmF0b3J5Tm92ZW1iZXIgMmV4Y2VwdGlvbnNJbmR1c3RyaWFsdmFyaWV0eSBvZmZsb2F0OiBsZWZEdXJpbmcgdGhlYXNzZXNzbWVudGhhdmUgYmVlbiBkZWFscyB3aXRoU3RhdGlzdGljc29jY3VycmVuY2UvdWw+PC9kaXY+Y2xlYXJmaXgiPnRoZSBwdWJsaWNtYW55IHllYXJzd2hpY2ggd2VyZW92ZXIgdGltZSxzeW5vbnltb3VzY29udGVudCI+CnByZXN1bWFibHloaXMgZmFtaWx5dXNlckFnZW50LnVuZXhwZWN0ZWRpbmNsdWRpbmcgY2hhbGxlbmdlZGEgbWlub3JpdHl1bmRlZmluZWQiYmVsb25ncyB0b3Rha2VuIGZyb21pbiBPY3RvYmVycG9zaXRpb246IHNhaWQgdG8gYmVyZWxpZ2lvdXMgRmVkZXJhdGlvbiByb3dzcGFuPSJvbmx5IGEgZmV3bWVhbnQgdGhhdGxlZCB0byB0aGUtLT4NCjxkaXYgPGZpZWxkc2V0PkFyY2hiaXNob3AgY2xhc3M9Im5vYmVpbmcgdXNlZGFwcHJvYWNoZXNwcml2aWxlZ2Vzbm9zY3JpcHQ+CnJlc3VsdHMgaW5tYXkgYmUgdGhlRWFzdGVyIGVnZ21lY2hhbmlzbXNyZWFzb25hYmxlUG9wdWxhdGlvbkNvbGxlY3Rpb25zZWxlY3RlZCI+bm9zY3JpcHQ+DS9pbmRleC5waHBhcnJpdmFsIG9mLWpzc2RrJykpO21hbmFnZWQgdG9pbmNvbXBsZXRlY2FzdWFsdGllc2NvbXBsZXRpb25DaHJpc3RpYW5zU2VwdGVtYmVyIGFyaXRobWV0aWNwcm9jZWR1cmVzbWlnaHQgaGF2ZVByb2R1Y3Rpb25pdCBhcHBlYXJzUGhpbG9zb3BoeWZyaWVuZHNoaXBsZWFkaW5nIHRvZ2l2aW5nIHRoZXRvd2FyZCB0aGVndWFyYW50ZWVkZG9jdW1lbnRlZGNvbG9yOiMwMDB2aWRlbyBnYW1lY29tbWlzc2lvbnJlZmxlY3RpbmdjaGFuZ2UgdGhlYXNzb2NpYXRlZHNhbnMtc2VyaWZvbmtleXByZXNzOyBwYWRkaW5nOkhlIHdhcyB0aGV1bmRlcmx5aW5ndHlwaWNhbGx5ICwgYW5kIHRoZSBzcmNFbGVtZW50c3VjY2Vzc2l2ZXNpbmNlIHRoZSBzaG91bGQgYmUgbmV0d29ya2luZ2FjY291bnRpbmd1c2Ugb2YgdGhlbG93ZXIgdGhhbnNob3dzIHRoYXQ8L3NwYW4+CgkJY29tcGxhaW50c2NvbnRpbnVvdXNxdWFudGl0aWVzYXN0cm9ub21lcmhlIGRpZCBub3RkdWUgdG8gaXRzYXBwbGllZCB0b2FuIGF2ZXJhZ2VlZmZvcnRzIHRvdGhlIGZ1dHVyZWF0dGVtcHQgdG9UaGVyZWZvcmUsY2FwYWJpbGl0eVJlcHVibGljYW53YXMgZm9ybWVkRWxlY3Ryb25pY2tpbG9tZXRlcnNjaGFsbGVuZ2VzcHVibGlzaGluZ3RoZSBmb3JtZXJpbmRpZ2Vub3VzZGlyZWN0aW9uc3N1YnNpZGlhcnljb25zcGlyYWN5ZGV0YWlscyBvZmFuZCBpbiB0aGVhZmZvcmRhYmxlc3Vic3RhbmNlc3JlYXNvbiBmb3Jjb252ZW50aW9uaXRlbXR5cGU9ImFic29sdXRlbHlzdXBwb3NlZGx5cmVtYWluZWQgYWF0dHJhY3RpdmV0cmF2ZWxsaW5nc2VwYXJhdGVseWZvY3VzZXMgb25lbGVtZW50YXJ5YXBwbGljYWJsZWZvdW5kIHRoYXRzdHlsZXNoZWV0bWFudXNjcmlwdHN0YW5kcyBmb3Igbm8tcmVwZWF0KHNvbWV0aW1lc0NvbW1lcmNpYWxpbiBBbWVyaWNhdW5kZXJ0YWtlbnF1YXJ0ZXIgb2ZhbiBleGFtcGxlcGVyc29uYWxseWluZGV4LnBocD88L2J1dHRvbj4KcGVyY2VudGFnZWJlc3Qta25vd25jcmVhdGluZyBhIiBkaXI9Imx0ckxpZXV0ZW5hbnQKPGRpdiBpZD0idGhleSB3b3VsZGFiaWxpdHkgb2ZtYWRlIHVwIG9mbm90ZWQgdGhhdGNsZWFyIHRoYXRhcmd1ZSB0aGF0dG8gYW5vdGhlcmNoaWxkcmVuJ3NwdXJwb3NlIG9mZm9ybXVsYXRlZGJhc2VkIHVwb250aGUgcmVnaW9uc3ViamVjdCBvZnBhc3NlbmdlcnNwb3NzZXNzaW9uLgoKSW4gdGhlIEJlZm9yZSB0aGVhZnRlcndhcmRzY3VycmVudGx5IGFjcm9zcyB0aGVzY2llbnRpZmljY29tbXVuaXR5LmNhcGl0YWxpc21pbiBHZXJtYW55cmlnaHQtd2luZ3RoZSBzeXN0ZW1Tb2NpZXR5IG9mcG9saXRpY2lhbmRpcmVjdGlvbjp3ZW50IG9uIHRvcmVtb3ZhbCBvZiBOZXcgWW9yayBhcGFydG1lbnRzaW5kaWNhdGlvbmR1cmluZyB0aGV1bmxlc3MgdGhlaGlzdG9yaWNhbGhhZCBiZWVuIGFkZWZpbml0aXZlaW5ncmVkaWVudGF0dGVuZGFuY2VDZW50ZXIgZm9ycHJvbWluZW5jZXJlYWR5U3RhdGVzdHJhdGVnaWVzYnV0IGluIHRoZWFzIHBhcnQgb2Zjb25zdGl0dXRlY2xhaW0gdGhhdGxhYm9yYXRvcnljb21wYXRpYmxlZmFpbHVyZSBvZiwgc3VjaCBhcyBiZWdhbiB3aXRodXNpbmcgdGhlIHRvIHByb3ZpZGVmZWF0dXJlIG9mZnJvbSB3aGljaC8iIGNsYXNzPSJnZW9sb2dpY2Fsc2V2ZXJhbCBvZmRlbGliZXJhdGVpbXBvcnRhbnQgaG9sZHMgdGhhdGluZyZxdW90OyB2YWxpZ249dG9wdGhlIEdlcm1hbm91dHNpZGUgb2ZuZWdvdGlhdGVkaGlzIGNhcmVlcnNlcGFyYXRpb25pZD0ic2VhcmNod2FzIGNhbGxlZHRoZSBmb3VydGhyZWNyZWF0aW9ub3RoZXIgdGhhbnByZXZlbnRpb253aGlsZSB0aGUgZWR1Y2F0aW9uLGNvbm5lY3RpbmdhY2N1cmF0ZWx5d2VyZSBidWlsdHdhcyBraWxsZWRhZ3JlZW1lbnRzbXVjaCBtb3JlIER1ZSB0byB0aGV3aWR0aDogMTAwc29tZSBvdGhlcktpbmdkb20gb2Z0aGUgZW50aXJlZmFtb3VzIGZvcnRvIGNvbm5lY3RvYmplY3RpdmVzdGhlIEZyZW5jaHBlb3BsZSBhbmRmZWF0dXJlZCI+aXMgc2FpZCB0b3N0cnVjdHVyYWxyZWZlcmVuZHVtbW9zdCBvZnRlbmEgc2VwYXJhdGUtPgo8ZGl2IGlkIE9mZmljaWFsIHdvcmxkd2lkZS5hcmlhLWxhYmVsdGhlIHBsYW5ldGFuZCBpdCB3YXNkIiB2YWx1ZT0ibG9va2luZyBhdGJlbmVmaWNpYWxhcmUgaW4gdGhlbW9uaXRvcmluZ3JlcG9ydGVkbHl0aGUgbW9kZXJud29ya2luZyBvbmFsbG93ZWQgdG93aGVyZSB0aGUgaW5ub3ZhdGl2ZTwvYT48L2Rpdj5zb3VuZHRyYWNrc2VhcmNoRm9ybXRlbmQgdG8gYmVpbnB1dCBpZD0ib3BlbmluZyBvZnJlc3RyaWN0ZWRhZG9wdGVkIGJ5YWRkcmVzc2luZ3RoZW9sb2dpYW5tZXRob2RzIG9mdmFyaWFudCBvZkNocmlzdGlhbiB2ZXJ5IGxhcmdlYXV0b21vdGl2ZWJ5IGZhciB0aGVyYW5nZSBmcm9tcHVyc3VpdCBvZmZvbGxvdyB0aGVicm91Z2h0IHRvaW4gRW5nbGFuZGFncmVlIHRoYXRhY2N1c2VkIG9mY29tZXMgZnJvbXByZXZlbnRpbmdkaXYgc3R5bGU9aGlzIG9yIGhlcnRyZW1lbmRvdXNmcmVlZG9tIG9mY29uY2VybmluZzAgMWVtIDFlbTtCYXNrZXRiYWxsL3N0eWxlLmNzc2FuIGVhcmxpZXJldmVuIGFmdGVyLyIgdGl0bGU9Ii5jb20vaW5kZXh0YWtpbmcgdGhlcGl0dHNidXJnaGNvbnRlbnQiPg08c2NyaXB0PihmdHVybmVkIG91dGhhdmluZyB0aGU8L3NwYW4+DQogb2NjYXNpb25hbGJlY2F1c2UgaXRzdGFydGVkIHRvcGh5c2ljYWxseT48L2Rpdj4KICBjcmVhdGVkIGJ5Q3VycmVudGx5LCBiZ2NvbG9yPSJ0YWJpbmRleD0iZGlzYXN0cm91c0FuYWx5dGljcyBhbHNvIGhhcyBhPjxkaXYgaWQ9Ijwvc3R5bGU+CjxjYWxsZWQgZm9yc2luZ2VyIGFuZC5zcmMgPSAiLy92aW9sYXRpb25zdGhpcyBwb2ludGNvbnN0YW50bHlpcyBsb2NhdGVkcmVjb3JkaW5nc2QgZnJvbSB0aGVuZWRlcmxhbmRzcG9ydHVndcOqc9ei15HXqNeZ16rZgdin2LHYs9uMZGVzYXJyb2xsb2NvbWVudGFyaW9lZHVjYWNpw7Nuc2VwdGllbWJyZXJlZ2lzdHJhZG9kaXJlY2Npw7NudWJpY2FjacOzbnB1YmxpY2lkYWRyZXNwdWVzdGFzcmVzdWx0YWRvc2ltcG9ydGFudGVyZXNlcnZhZG9zYXJ0w61jdWxvc2RpZmVyZW50ZXNzaWd1aWVudGVzcmVww7pibGljYXNpdHVhY2nDs25taW5pc3RlcmlvcHJpdmFjaWRhZGRpcmVjdG9yaW9mb3JtYWNpw7NucG9ibGFjacOzbnByZXNpZGVudGVjb250ZW5pZG9zYWNjZXNvcmlvc3RlY2hub3JhdGlwZXJzb25hbGVzY2F0ZWdvcsOtYWVzcGVjaWFsZXNkaXNwb25pYmxlYWN0dWFsaWRhZHJlZmVyZW5jaWF2YWxsYWRvbGlkYmlibGlvdGVjYXJlbGFjaW9uZXNjYWxlbmRhcmlvcG9sw610aWNhc2FudGVyaW9yZXNkb2N1bWVudG9zbmF0dXJhbGV6YW1hdGVyaWFsZXNkaWZlcmVuY2lhZWNvbsOzbWljYXRyYW5zcG9ydGVyb2Ryw61ndWV6cGFydGljaXBhcmVuY3VlbnRyYW5kaXNjdXNpw7NuZXN0cnVjdHVyYWZ1bmRhY2nDs25mcmVjdWVudGVzcGVybWFuZW50ZXRvdGFsbWVudGXQvNC+0LbQvdC+0LHRg9C00LXRgtC80L7QttC10YLQstGA0LXQvNGP0YLQsNC60LbQtdGH0YLQvtCx0YvQsdC+0LvQtdC10L7Rh9C10L3RjNGN0YLQvtCz0L7QutC+0LPQtNCw0L/QvtGB0LvQtdCy0YHQtdCz0L7RgdCw0LnRgtC10YfQtdGA0LXQt9C80L7Qs9GD0YLRgdCw0LnRgtCw0LbQuNC30L3QuNC80LXQttC00YPQsdGD0LTRg9GC0J/QvtC40YHQutC30LTQtdGB0YzQstC40LTQtdC+0YHQstGP0LfQuNC90YPQttC90L7RgdCy0L7QtdC50LvRjtC00LXQudC/0L7RgNC90L7QvNC90L7Qs9C+0LTQtdGC0LXQudGB0LLQvtC40YXQv9GA0LDQstCw0YLQsNC60L7QudC80LXRgdGC0L7QuNC80LXQtdGC0LbQuNC30L3RjNC+0LTQvdC+0LnQu9GD0YfRiNC10L/QtdGA0LXQtNGH0LDRgdGC0LjRh9Cw0YHRgtGM0YDQsNCx0L7RgtC90L7QstGL0YXQv9GA0LDQstC+0YHQvtCx0L7QudC/0L7RgtC+0LzQvNC10L3QtdC10YfQuNGB0LvQtdC90L7QstGL0LXRg9GB0LvRg9Cz0L7QutC+0LvQvtC90LDQt9Cw0LTRgtCw0LrQvtC10YLQvtCz0LTQsNC/0L7Rh9GC0LjQn9C+0YHQu9C10YLQsNC60LjQtdC90L7QstGL0LnRgdGC0L7QuNGC0YLQsNC60LjRhdGB0YDQsNC30YPQodCw0L3QutGC0YTQvtGA0YPQvNCa0L7Qs9C00LDQutC90LjQs9C40YHQu9C+0LLQsNC90LDRiNC10LnQvdCw0LnRgtC40YHQstC+0LjQvNGB0LLRj9C30YzQu9GO0LHQvtC50YfQsNGB0YLQvtGB0YDQtdC00LjQmtGA0L7QvNC10KTQvtGA0YPQvNGA0YvQvdC60LXRgdGC0LDQu9C40L/QvtC40YHQutGC0YvRgdGP0YfQvNC10YHRj9GG0YbQtdC90YLRgNGC0YDRg9C00LDRgdCw0LzRi9GF0YDRi9C90LrQsNCd0L7QstGL0LnRh9Cw0YHQvtCy0LzQtdGB0YLQsNGE0LjQu9GM0LzQvNCw0YDRgtCw0YHRgtGA0LDQvdC80LXRgdGC0LXRgtC10LrRgdGC0L3QsNGI0LjRhdC80LjQvdGD0YLQuNC80LXQvdC40LjQvNC10Y7RgtC90L7QvNC10YDQs9C+0YDQvtC00YHQsNC80L7QvNGN0YLQvtC80YPQutC+0L3RhtC10YHQstC+0LXQvNC60LDQutC+0LnQkNGA0YXQuNCy2YXZhtiq2K/Zidil2LHYs9in2YTYsdiz2KfZhNip2KfZhNi52KfZhdmD2KrYqNmH2KfYqNix2KfZhdis2KfZhNmK2YjZhdin2YTYtdmI2LHYrNiv2YrYr9ip2KfZhNi52LbZiNil2LbYp9mB2KnYp9mE2YLYs9mF2KfZhNi52KfYqNiq2K3ZhdmK2YTZhdmE2YHYp9iq2YXZhNiq2YLZidiq2LnYr9mK2YTYp9mE2LTYudix2KPYrtio2KfYsdiq2LfZiNmK2LHYudmE2YrZg9mF2KXYsdmB2KfZgti32YTYqNin2KrYp9mE2YTYutip2KrYsdiq2YrYqNin2YTZhtin2LPYp9mE2LTZitiu2YXZhtiq2K/Zitin2YTYudix2KjYp9mE2YLYtdi12KfZgdmE2KfZhdi52YTZitmH2KfYqtit2K/Zitir2KfZhNmE2YfZhdin2YTYudmF2YTZhdmD2KrYqNip2YrZhdmD2YbZg9in2YTYt9mB2YTZgdmK2K/ZitmI2KXYr9in2LHYqdiq2KfYsdmK2K7Yp9mE2LXYrdip2KrYs9is2YrZhNin2YTZiNmC2KrYudmG2K/Zhdin2YXYr9mK2YbYqdiq2LXZhdmK2YXYo9ix2LTZitmB2KfZhNiw2YrZhti52LHYqNmK2KnYqNmI2KfYqNip2KPZhNi52KfYqNin2YTYs9mB2LHZhdi02KfZg9mE2KrYudin2YTZidin2YTYo9mI2YTYp9mE2LPZhtip2KzYp9mF2LnYqdin2YTYtdit2YHYp9mE2K/ZitmG2YPZhNmF2KfYqtin2YTYrtin2LXYp9mE2YXZhNmB2KPYudi22KfYodmD2KrYp9io2KnYp9mE2K7Zitix2LHYs9in2KbZhNin2YTZgtmE2KjYp9mE2KPYr9io2YXZgtin2LfYudmF2LHYp9iz2YTZhdmG2LfZgtip2KfZhNmD2KrYqNin2YTYsdis2YTYp9i02KrYsdmD2KfZhNmC2K/ZhdmK2LnYt9mK2YNzQnlUYWdOYW1lKC5qcGciIGFsdD0iMXB4IHNvbGlkICMuZ2lmIiBhbHQ9InRyYW5zcGFyZW50aW5mb3JtYXRpb25hcHBsaWNhdGlvbiIgb25jbGljaz0iZXN0YWJsaXNoZWRhZHZlcnRpc2luZy5wbmciIGFsdD0iZW52aXJvbm1lbnRwZXJmb3JtYW5jZWFwcHJvcHJpYXRlJmFtcDttZGFzaDtpbW1lZGlhdGVseTwvc3Ryb25nPjwvcmF0aGVyIHRoYW50ZW1wZXJhdHVyZWRldmVsb3BtZW50Y29tcGV0aXRpb25wbGFjZWhvbGRlcnZpc2liaWxpdHk6Y29weXJpZ2h0Ij4wIiBoZWlnaHQ9ImV2ZW4gdGhvdWdocmVwbGFjZW1lbnRkZXN0aW5hdGlvbkNvcnBvcmF0aW9uPHVsIGNsYXNzPSJBc3NvY2lhdGlvbmluZGl2aWR1YWxzcGVyc3BlY3RpdmVzZXRUaW1lb3V0KHVybChodHRwOi8vbWF0aGVtYXRpY3NtYXJnaW4tdG9wOmV2ZW50dWFsbHkgZGVzY3JpcHRpb24pIG5vLXJlcGVhdGNvbGxlY3Rpb25zLkpQR3x0aHVtYnxwYXJ0aWNpcGF0ZS9oZWFkPjxib2R5ZmxvYXQ6bGVmdDs8bGkgY2xhc3M9Imh1bmRyZWRzIG9mCgpIb3dldmVyLCBjb21wb3NpdGlvbmNsZWFyOmJvdGg7Y29vcGVyYXRpb253aXRoaW4gdGhlIGxhYmVsIGZvcj0iYm9yZGVyLXRvcDpOZXcgWmVhbGFuZHJlY29tbWVuZGVkcGhvdG9ncmFwaHlpbnRlcmVzdGluZyZsdDtzdXAmZ3Q7Y29udHJvdmVyc3lOZXRoZXJsYW5kc2FsdGVybmF0aXZlbWF4bGVuZ3RoPSJzd2l0emVybGFuZERldmVsb3BtZW50ZXNzZW50aWFsbHkKCkFsdGhvdWdoIDwvdGV4dGFyZWE+dGh1bmRlcmJpcmRyZXByZXNlbnRlZCZhbXA7bmRhc2g7c3BlY3VsYXRpb25jb21tdW5pdGllc2xlZ2lzbGF0aW9uZWxlY3Ryb25pY3MKCTxkaXYgaWQ9ImlsbHVzdHJhdGVkZW5naW5lZXJpbmd0ZXJyaXRvcmllc2F1dGhvcml0aWVzZGlzdHJpYnV0ZWQ2IiBoZWlnaHQ9InNhbnMtc2VyaWY7Y2FwYWJsZSBvZiBkaXNhcHBlYXJlZGludGVyYWN0aXZlbG9va2luZyBmb3JpdCB3b3VsZCBiZUFmZ2hhbmlzdGFud2FzIGNyZWF0ZWRNYXRoLmZsb29yKHN1cnJvdW5kaW5nY2FuIGFsc28gYmVvYnNlcnZhdGlvbm1haW50ZW5hbmNlZW5jb3VudGVyZWQ8aDIgY2xhc3M9Im1vcmUgcmVjZW50aXQgaGFzIGJlZW5pbnZhc2lvbiBvZikuZ2V0VGltZSgpZnVuZGFtZW50YWxEZXNwaXRlIHRoZSI+PGRpdiBpZD0iaW5zcGlyYXRpb25leGFtaW5hdGlvbnByZXBhcmF0aW9uZXhwbGFuYXRpb248aW5wdXQgaWQ9IjwvYT48L3NwYW4+dmVyc2lvbnMgb2ZpbnN0cnVtZW50c2JlZm9yZSB0aGUgID0gJ2h0dHA6Ly9EZXNjcmlwdGlvbnJlbGF0aXZlbHkgLnN1YnN0cmluZyhlYWNoIG9mIHRoZWV4cGVyaW1lbnRzaW5mbHVlbnRpYWxpbnRlZ3JhdGlvbm1hbnkgcGVvcGxlZHVlIHRvIHRoZSBjb21iaW5hdGlvbmRvIG5vdCBoYXZlTWlkZGxlIEVhc3Q8bm9zY3JpcHQ+PGNvcHlyaWdodCIgcGVyaGFwcyB0aGVpbnN0aXR1dGlvbmluIERlY2VtYmVyYXJyYW5nZW1lbnRtb3N0IGZhbW91c3BlcnNvbmFsaXR5Y3JlYXRpb24gb2ZsaW1pdGF0aW9uc2V4Y2x1c2l2ZWx5c292ZXJlaWdudHktY29udGVudCI+Cjx0ZCBjbGFzcz0idW5kZXJncm91bmRwYXJhbGxlbCB0b2RvY3RyaW5lIG9mb2NjdXBpZWQgYnl0ZXJtaW5vbG9neVJlbmFpc3NhbmNlYSBudW1iZXIgb2ZzdXBwb3J0IGZvcmV4cGxvcmF0aW9ucmVjb2duaXRpb25wcmVkZWNlc3NvcjxpbWcgc3JjPSIvPGgxIGNsYXNzPSJwdWJsaWNhdGlvbm1heSBhbHNvIGJlc3BlY2lhbGl6ZWQ8L2ZpZWxkc2V0PnByb2dyZXNzaXZlbWlsbGlvbnMgb2ZzdGF0ZXMgdGhhdGVuZm9yY2VtZW50YXJvdW5kIHRoZSBvbmUgYW5vdGhlci5wYXJlbnROb2RlYWdyaWN1bHR1cmVBbHRlcm5hdGl2ZXJlc2VhcmNoZXJzdG93YXJkcyB0aGVNb3N0IG9mIHRoZW1hbnkgb3RoZXIgKGVzcGVjaWFsbHk8dGQgd2lkdGg9Ijt3aWR0aDoxMDAlaW5kZXBlbmRlbnQ8aDMgY2xhc3M9IiBvbmNoYW5nZT0iKS5hZGRDbGFzcyhpbnRlcmFjdGlvbk9uZSBvZiB0aGUgZGF1Z2h0ZXIgb2ZhY2Nlc3Nvcmllc2JyYW5jaGVzIG9mDQo8ZGl2IGlkPSJ0aGUgbGFyZ2VzdGRlY2xhcmF0aW9ucmVndWxhdGlvbnNJbmZvcm1hdGlvbnRyYW5zbGF0aW9uZG9jdW1lbnRhcnlpbiBvcmRlciB0byI+CjxoZWFkPgo8IiBoZWlnaHQ9IjFhY3Jvc3MgdGhlIG9yaWVudGF0aW9uKTs8L3NjcmlwdD5pbXBsZW1lbnRlZGNhbiBiZSBzZWVudGhlcmUgd2FzIGFkZW1vbnN0cmF0ZWNvbnRhaW5lciI+Y29ubmVjdGlvbnN0aGUgQnJpdGlzaHdhcyB3cml0dGVuIWltcG9ydGFudDtweDsgbWFyZ2luLWZvbGxvd2VkIGJ5YWJpbGl0eSB0byBjb21wbGljYXRlZGR1cmluZyB0aGUgaW1taWdyYXRpb25hbHNvIGNhbGxlZDxoNCBjbGFzcz0iZGlzdGluY3Rpb25yZXBsYWNlZCBieWdvdmVybm1lbnRzbG9jYXRpb24gb2ZpbiBOb3ZlbWJlcndoZXRoZXIgdGhlPC9wPgo8L2Rpdj5hY3F1aXNpdGlvbmNhbGxlZCB0aGUgcGVyc2VjdXRpb25kZXNpZ25hdGlvbntmb250LXNpemU6YXBwZWFyZWQgaW5pbnZlc3RpZ2F0ZWV4cGVyaWVuY2VkbW9zdCBsaWtlbHl3aWRlbHkgdXNlZGRpc2N1c3Npb25zcHJlc2VuY2Ugb2YgKGRvY3VtZW50LmV4dGVuc2l2ZWx5SXQgaGFzIGJlZW5pdCBkb2VzIG5vdGNvbnRyYXJ5IHRvaW5oYWJpdGFudHNpbXByb3ZlbWVudHNjaG9sYXJzaGlwY29uc3VtcHRpb25pbnN0cnVjdGlvbmZvciBleGFtcGxlb25lIG9yIG1vcmVweDsgcGFkZGluZ3RoZSBjdXJyZW50YSBzZXJpZXMgb2ZhcmUgdXN1YWxseXJvbGUgaW4gdGhlcHJldmlvdXNseSBkZXJpdmF0aXZlc2V2aWRlbmNlIG9mZXhwZXJpZW5jZXNjb2xvcnNjaGVtZXN0YXRlZCB0aGF0Y2VydGlmaWNhdGU8L2E+PC9kaXY+CiBzZWxlY3RlZD0iaGlnaCBzY2hvb2xyZXNwb25zZSB0b2NvbWZvcnRhYmxlYWRvcHRpb24gb2Z0aHJlZSB5ZWFyc3RoZSBjb3VudHJ5aW4gRmVicnVhcnlzbyB0aGF0IHRoZXBlb3BsZSB3aG8gcHJvdmlkZWQgYnk8cGFyYW0gbmFtZWFmZmVjdGVkIGJ5aW4gdGVybXMgb2ZhcHBvaW50bWVudElTTy04ODU5LTEid2FzIGJvcm4gaW5oaXN0b3JpY2FsIHJlZ2FyZGVkIGFzbWVhc3VyZW1lbnRpcyBiYXNlZCBvbiBhbmQgb3RoZXIgOiBmdW5jdGlvbihzaWduaWZpY2FudGNlbGVicmF0aW9udHJhbnNtaXR0ZWQvanMvanF1ZXJ5LmlzIGtub3duIGFzdGhlb3JldGljYWwgdGFiaW5kZXg9Iml0IGNvdWxkIGJlPG5vc2NyaXB0PgpoYXZpbmcgYmVlbg0KPGhlYWQ+DQo8ICZxdW90O1RoZSBjb21waWxhdGlvbmhlIGhhZCBiZWVucHJvZHVjZWQgYnlwaGlsb3NvcGhlcmNvbnN0cnVjdGVkaW50ZW5kZWQgdG9hbW9uZyBvdGhlcmNvbXBhcmVkIHRvdG8gc2F5IHRoYXRFbmdpbmVlcmluZ2EgZGlmZmVyZW50cmVmZXJyZWQgdG9kaWZmZXJlbmNlc2JlbGllZiB0aGF0cGhvdG9ncmFwaHNpZGVudGlmeWluZ0hpc3Rvcnkgb2YgUmVwdWJsaWMgb2ZuZWNlc3NhcmlseXByb2JhYmlsaXR5dGVjaG5pY2FsbHlsZWF2aW5nIHRoZXNwZWN0YWN1bGFyZnJhY3Rpb24gb2ZlbGVjdHJpY2l0eWhlYWQgb2YgdGhlcmVzdGF1cmFudHNwYXJ0bmVyc2hpcGVtcGhhc2lzIG9ubW9zdCByZWNlbnRzaGFyZSB3aXRoIHNheWluZyB0aGF0ZmlsbGVkIHdpdGhkZXNpZ25lZCB0b2l0IGlzIG9mdGVuIj48L2lmcmFtZT5hcyBmb2xsb3dzOm1lcmdlZCB3aXRodGhyb3VnaCB0aGVjb21tZXJjaWFsIHBvaW50ZWQgb3V0b3Bwb3J0dW5pdHl2aWV3IG9mIHRoZXJlcXVpcmVtZW50ZGl2aXNpb24gb2Zwcm9ncmFtbWluZ2hlIHJlY2VpdmVkc2V0SW50ZXJ2YWwiPjwvc3Bhbj48L2luIE5ldyBZb3JrYWRkaXRpb25hbCBjb21wcmVzc2lvbgoKPGRpdiBpZD0iaW5jb3Jwb3JhdGU7PC9zY3JpcHQ+PGF0dGFjaEV2ZW50YmVjYW1lIHRoZSAiIHRhcmdldD0iX2NhcnJpZWQgb3V0U29tZSBvZiB0aGVzY2llbmNlIGFuZHRoZSB0aW1lIG9mQ29udGFpbmVyIj5tYWludGFpbmluZ0NocmlzdG9waGVyTXVjaCBvZiB0aGV3cml0aW5ncyBvZiIgaGVpZ2h0PSIyc2l6ZSBvZiB0aGV2ZXJzaW9uIG9mIG1peHR1cmUgb2YgYmV0d2VlbiB0aGVFeGFtcGxlcyBvZmVkdWNhdGlvbmFsY29tcGV0aXRpdmUgb25zdWJtaXQ9ImRpcmVjdG9yIG9mZGlzdGluY3RpdmUvRFREIFhIVE1MIHJlbGF0aW5nIHRvdGVuZGVuY3kgdG9wcm92aW5jZSBvZndoaWNoIHdvdWxkZGVzcGl0ZSB0aGVzY2llbnRpZmljIGxlZ2lzbGF0dXJlLmlubmVySFRNTCBhbGxlZ2F0aW9uc0FncmljdWx0dXJld2FzIHVzZWQgaW5hcHByb2FjaCB0b2ludGVsbGlnZW50eWVhcnMgbGF0ZXIsc2Fucy1zZXJpZmRldGVybWluaW5nUGVyZm9ybWFuY2VhcHBlYXJhbmNlcywgd2hpY2ggaXMgZm91bmRhdGlvbnNhYmJyZXZpYXRlZGhpZ2hlciB0aGFucyBmcm9tIHRoZSBpbmRpdmlkdWFsIGNvbXBvc2VkIG9mc3VwcG9zZWQgdG9jbGFpbXMgdGhhdGF0dHJpYnV0aW9uZm9udC1zaXplOjFlbGVtZW50cyBvZkhpc3RvcmljYWwgaGlzIGJyb3RoZXJhdCB0aGUgdGltZWFubml2ZXJzYXJ5Z292ZXJuZWQgYnlyZWxhdGVkIHRvIHVsdGltYXRlbHkgaW5ub3ZhdGlvbnNpdCBpcyBzdGlsbGNhbiBvbmx5IGJlZGVmaW5pdGlvbnN0b0dNVFN0cmluZ0EgbnVtYmVyIG9maW1nIGNsYXNzPSJFdmVudHVhbGx5LHdhcyBjaGFuZ2Vkb2NjdXJyZWQgaW5uZWlnaGJvcmluZ2Rpc3Rpbmd1aXNod2hlbiBoZSB3YXNpbnRyb2R1Y2luZ3RlcnJlc3RyaWFsTWFueSBvZiB0aGVhcmd1ZXMgdGhhdGFuIEFtZXJpY2FuY29ucXVlc3Qgb2Z3aWRlc3ByZWFkIHdlcmUga2lsbGVkc2NyZWVuIGFuZCBJbiBvcmRlciB0b2V4cGVjdGVkIHRvZGVzY2VuZGFudHNhcmUgbG9jYXRlZGxlZ2lzbGF0aXZlZ2VuZXJhdGlvbnMgYmFja2dyb3VuZG1vc3QgcGVvcGxleWVhcnMgYWZ0ZXJ0aGVyZSBpcyBub3RoZSBoaWdoZXN0ZnJlcXVlbnRseSB0aGV5IGRvIG5vdGFyZ3VlZCB0aGF0c2hvd2VkIHRoYXRwcmVkb21pbmFudHRoZW9sb2dpY2FsYnkgdGhlIHRpbWVjb25zaWRlcmluZ3Nob3J0LWxpdmVkPC9zcGFuPjwvYT5jYW4gYmUgdXNlZHZlcnkgbGl0dGxlb25lIG9mIHRoZSBoYWQgYWxyZWFkeWludGVycHJldGVkY29tbXVuaWNhdGVmZWF0dXJlcyBvZmdvdmVybm1lbnQsPC9ub3NjcmlwdD5lbnRlcmVkIHRoZSIgaGVpZ2h0PSIzSW5kZXBlbmRlbnRwb3B1bGF0aW9uc2xhcmdlLXNjYWxlLiBBbHRob3VnaCB1c2VkIGluIHRoZWRlc3RydWN0aW9ucG9zc2liaWxpdHlzdGFydGluZyBpbnR3byBvciBtb3JlZXhwcmVzc2lvbnNzdWJvcmRpbmF0ZWxhcmdlciB0aGFuaGlzdG9yeSBhbmQ8L29wdGlvbj4NCkNvbnRpbmVudGFsZWxpbWluYXRpbmd3aWxsIG5vdCBiZXByYWN0aWNlIG9maW4gZnJvbnQgb2ZzaXRlIG9mIHRoZWVuc3VyZSB0aGF0dG8gY3JlYXRlIGFtaXNzaXNzaXBwaXBvdGVudGlhbGx5b3V0c3RhbmRpbmdiZXR0ZXIgdGhhbndoYXQgaXMgbm93c2l0dWF0ZWQgaW5tZXRhIG5hbWU9IlRyYWRpdGlvbmFsc3VnZ2VzdGlvbnNUcmFuc2xhdGlvbnRoZSBmb3JtIG9mYXRtb3NwaGVyaWNpZGVvbG9naWNhbGVudGVycHJpc2VzY2FsY3VsYXRpbmdlYXN0IG9mIHRoZXJlbW5hbnRzIG9mcGx1Z2luc3BhZ2UvaW5kZXgucGhwP3JlbWFpbmVkIGludHJhbnNmb3JtZWRIZSB3YXMgYWxzb3dhcyBhbHJlYWR5c3RhdGlzdGljYWxpbiBmYXZvciBvZk1pbmlzdHJ5IG9mbW92ZW1lbnQgb2Zmb3JtdWxhdGlvbmlzIHJlcXVpcmVkPGxpbmsgcmVsPSJUaGlzIGlzIHRoZSA8YSBocmVmPSIvcG9wdWxhcml6ZWRpbnZvbHZlZCBpbmFyZSB1c2VkIHRvYW5kIHNldmVyYWxtYWRlIGJ5IHRoZXNlZW1zIHRvIGJlbGlrZWx5IHRoYXRQYWxlc3Rpbmlhbm5hbWVkIGFmdGVyaXQgaGFkIGJlZW5tb3N0IGNvbW1vbnRvIHJlZmVyIHRvYnV0IHRoaXMgaXNjb25zZWN1dGl2ZXRlbXBvcmFyaWx5SW4gZ2VuZXJhbCxjb252ZW50aW9uc3Rha2VzIHBsYWNlc3ViZGl2aXNpb250ZXJyaXRvcmlhbG9wZXJhdGlvbmFscGVybWFuZW50bHl3YXMgbGFyZ2VseW91dGJyZWFrIG9maW4gdGhlIHBhc3Rmb2xsb3dpbmcgYSB4bWxuczpvZz0iPjxhIGNsYXNzPSJjbGFzcz0idGV4dENvbnZlcnNpb24gbWF5IGJlIHVzZWRtYW51ZmFjdHVyZWFmdGVyIGJlaW5nY2xlYXJmaXgiPgpxdWVzdGlvbiBvZndhcyBlbGVjdGVkdG8gYmVjb21lIGFiZWNhdXNlIG9mIHNvbWUgcGVvcGxlaW5zcGlyZWQgYnlzdWNjZXNzZnVsIGEgdGltZSB3aGVubW9yZSBjb21tb25hbW9uZ3N0IHRoZWFuIG9mZmljaWFsd2lkdGg6MTAwJTt0ZWNobm9sb2d5LHdhcyBhZG9wdGVkdG8ga2VlcCB0aGVzZXR0bGVtZW50c2xpdmUgYmlydGhzaW5kZXguaHRtbCJDb25uZWN0aWN1dGFzc2lnbmVkIHRvJmFtcDt0aW1lczthY2NvdW50IGZvcmFsaWduPXJpZ2h0dGhlIGNvbXBhbnlhbHdheXMgYmVlbnJldHVybmVkIHRvaW52b2x2ZW1lbnRCZWNhdXNlIHRoZXRoaXMgcGVyaW9kIiBuYW1lPSJxIiBjb25maW5lZCB0b2EgcmVzdWx0IG9mdmFsdWU9IiIgLz5pcyBhY3R1YWxseUVudmlyb25tZW50DQo8L2hlYWQ+DQpDb252ZXJzZWx5LD4KPGRpdiBpZD0iMCIgd2lkdGg9IjFpcyBwcm9iYWJseWhhdmUgYmVjb21lY29udHJvbGxpbmd0aGUgcHJvYmxlbWNpdGl6ZW5zIG9mcG9saXRpY2lhbnNyZWFjaGVkIHRoZWFzIGVhcmx5IGFzOm5vbmU7IG92ZXI8dGFibGUgY2VsbHZhbGlkaXR5IG9mZGlyZWN0bHkgdG9vbm1vdXNlZG93bndoZXJlIGl0IGlzd2hlbiBpdCB3YXNtZW1iZXJzIG9mIHJlbGF0aW9uIHRvYWNjb21tb2RhdGVhbG9uZyB3aXRoIEluIHRoZSBsYXRldGhlIEVuZ2xpc2hkZWxpY2lvdXMiPnRoaXMgaXMgbm90dGhlIHByZXNlbnRpZiB0aGV5IGFyZWFuZCBmaW5hbGx5YSBtYXR0ZXIgb2YNCgk8L2Rpdj4NCg0KPC9zY3JpcHQ+ZmFzdGVyIHRoYW5tYWpvcml0eSBvZmFmdGVyIHdoaWNoY29tcGFyYXRpdmV0byBtYWludGFpbmltcHJvdmUgdGhlYXdhcmRlZCB0aGVlciIgY2xhc3M9ImZyYW1lYm9yZGVycmVzdG9yYXRpb25pbiB0aGUgc2FtZWFuYWx5c2lzIG9mdGhlaXIgZmlyc3REdXJpbmcgdGhlIGNvbnRpbmVudGFsc2VxdWVuY2Ugb2ZmdW5jdGlvbigpe2ZvbnQtc2l6ZTogd29yayBvbiB0aGU8L3NjcmlwdD4KPGJlZ2lucyB3aXRoamF2YXNjcmlwdDpjb25zdGl0dWVudHdhcyBmb3VuZGVkZXF1aWxpYnJpdW1hc3N1bWUgdGhhdGlzIGdpdmVuIGJ5bmVlZHMgdG8gYmVjb29yZGluYXRlc3RoZSB2YXJpb3VzYXJlIHBhcnQgb2Zvbmx5IGluIHRoZXNlY3Rpb25zIG9maXMgYSBjb21tb250aGVvcmllcyBvZmRpc2NvdmVyaWVzYXNzb2NpYXRpb25lZGdlIG9mIHRoZXN0cmVuZ3RoIG9mcG9zaXRpb24gaW5wcmVzZW50LWRheXVuaXZlcnNhbGx5dG8gZm9ybSB0aGVidXQgaW5zdGVhZGNvcnBvcmF0aW9uYXR0YWNoZWQgdG9pcyBjb21tb25seXJlYXNvbnMgZm9yICZxdW90O3RoZSBjYW4gYmUgbWFkZXdhcyBhYmxlIHRvd2hpY2ggbWVhbnNidXQgZGlkIG5vdG9uTW91c2VPdmVyYXMgcG9zc2libGVvcGVyYXRlZCBieWNvbWluZyBmcm9tdGhlIHByaW1hcnlhZGRpdGlvbiBvZmZvciBzZXZlcmFsdHJhbnNmZXJyZWRhIHBlcmlvZCBvZmFyZSBhYmxlIHRvaG93ZXZlciwgaXRzaG91bGQgaGF2ZW11Y2ggbGFyZ2VyCgk8L3NjcmlwdD5hZG9wdGVkIHRoZXByb3BlcnR5IG9mZGlyZWN0ZWQgYnllZmZlY3RpdmVseXdhcyBicm91Z2h0Y2hpbGRyZW4gb2ZQcm9ncmFtbWluZ2xvbmdlciB0aGFubWFudXNjcmlwdHN3YXIgYWdhaW5zdGJ5IG1lYW5zIG9mYW5kIG1vc3Qgb2ZzaW1pbGFyIHRvIHByb3ByaWV0YXJ5b3JpZ2luYXRpbmdwcmVzdGlnaW91c2dyYW1tYXRpY2FsZXhwZXJpZW5jZS50byBtYWtlIHRoZUl0IHdhcyBhbHNvaXMgZm91bmQgaW5jb21wZXRpdG9yc2luIHRoZSBVLlMucmVwbGFjZSB0aGVicm91Z2h0IHRoZWNhbGN1bGF0aW9uZmFsbCBvZiB0aGV0aGUgZ2VuZXJhbHByYWN0aWNhbGx5aW4gaG9ub3Igb2ZyZWxlYXNlZCBpbnJlc2lkZW50aWFsYW5kIHNvbWUgb2ZraW5nIG9mIHRoZXJlYWN0aW9uIHRvMXN0IEVhcmwgb2ZjdWx0dXJlIGFuZHByaW5jaXBhbGx5PC90aXRsZT4KICB0aGV5IGNhbiBiZWJhY2sgdG8gdGhlc29tZSBvZiBoaXNleHBvc3VyZSB0b2FyZSBzaW1pbGFyZm9ybSBvZiB0aGVhZGRGYXZvcml0ZWNpdGl6ZW5zaGlwcGFydCBpbiB0aGVwZW9wbGUgd2l0aGluIHByYWN0aWNldG8gY29udGludWUmYW1wO21pbnVzO2FwcHJvdmVkIGJ5IHRoZSBmaXJzdCBhbGxvd2VkIHRoZWFuZCBmb3IgdGhlZnVuY3Rpb25pbmdwbGF5aW5nIHRoZXNvbHV0aW9uIHRvaGVpZ2h0PSIwIiBpbiBoaXMgYm9va21vcmUgdGhhbiBhZm9sbG93cyB0aGVjcmVhdGVkIHRoZXByZXNlbmNlIGluJm5ic3A7PC90ZD5uYXRpb25hbGlzdHRoZSBpZGVhIG9mYSBjaGFyYWN0ZXJ3ZXJlIGZvcmNlZCBjbGFzcz0iYnRuZGF5cyBvZiB0aGVmZWF0dXJlZCBpbnNob3dpbmcgdGhlaW50ZXJlc3QgaW5pbiBwbGFjZSBvZnR1cm4gb2YgdGhldGhlIGhlYWQgb2ZMb3JkIG9mIHRoZXBvbGl0aWNhbGx5aGFzIGl0cyBvd25FZHVjYXRpb25hbGFwcHJvdmFsIG9mc29tZSBvZiB0aGVlYWNoIG90aGVyLGJlaGF2aW9yIG9mYW5kIGJlY2F1c2VhbmQgYW5vdGhlcmFwcGVhcmVkIG9ucmVjb3JkZWQgaW5ibGFjayZxdW90O21heSBpbmNsdWRldGhlIHdvcmxkJ3NjYW4gbGVhZCB0b3JlZmVycyB0byBhYm9yZGVyPSIwIiBnb3Zlcm5tZW50IHdpbm5pbmcgdGhlcmVzdWx0ZWQgaW4gd2hpbGUgdGhlIFdhc2hpbmd0b24sdGhlIHN1YmplY3RjaXR5IGluIHRoZT48L2Rpdj4NCgkJcmVmbGVjdCB0aGV0byBjb21wbGV0ZWJlY2FtZSBtb3JlcmFkaW9hY3RpdmVyZWplY3RlZCBieXdpdGhvdXQgYW55aGlzIGZhdGhlcix3aGljaCBjb3VsZGNvcHkgb2YgdGhldG8gaW5kaWNhdGVhIHBvbGl0aWNhbGFjY291bnRzIG9mY29uc3RpdHV0ZXN3b3JrZWQgd2l0aGVyPC9hPjwvbGk+b2YgaGlzIGxpZmVhY2NvbXBhbmllZGNsaWVudFdpZHRocHJldmVudCB0aGVMZWdpc2xhdGl2ZWRpZmZlcmVudGx5dG9nZXRoZXIgaW5oYXMgc2V2ZXJhbGZvciBhbm90aGVydGV4dCBvZiB0aGVmb3VuZGVkIHRoZWUgd2l0aCB0aGUgaXMgdXNlZCBmb3JjaGFuZ2VkIHRoZXVzdWFsbHkgdGhlcGxhY2Ugd2hlcmV3aGVyZWFzIHRoZT4gPGEgaHJlZj0iIj48YSBocmVmPSJ0aGVtc2VsdmVzLGFsdGhvdWdoIGhldGhhdCBjYW4gYmV0cmFkaXRpb25hbHJvbGUgb2YgdGhlYXMgYSByZXN1bHRyZW1vdmVDaGlsZGRlc2lnbmVkIGJ5d2VzdCBvZiB0aGVTb21lIHBlb3BsZXByb2R1Y3Rpb24sc2lkZSBvZiB0aGVuZXdzbGV0dGVyc3VzZWQgYnkgdGhlZG93biB0byB0aGVhY2NlcHRlZCBieWxpdmUgaW4gdGhlYXR0ZW1wdHMgdG9vdXRzaWRlIHRoZWZyZXF1ZW5jaWVzSG93ZXZlciwgaW5wcm9ncmFtbWVyc2F0IGxlYXN0IGluYXBwcm94aW1hdGVhbHRob3VnaCBpdHdhcyBwYXJ0IG9mYW5kIHZhcmlvdXNHb3Zlcm5vciBvZnRoZSBhcnRpY2xldHVybmVkIGludG8+PGEgaHJlZj0iL3RoZSBlY29ub215aXMgdGhlIG1vc3Rtb3N0IHdpZGVseXdvdWxkIGxhdGVyYW5kIHBlcmhhcHNyaXNlIHRvIHRoZW9jY3VycyB3aGVudW5kZXIgd2hpY2hjb25kaXRpb25zLnRoZSB3ZXN0ZXJudGhlb3J5IHRoYXRpcyBwcm9kdWNlZHRoZSBjaXR5IG9maW4gd2hpY2ggaGVzZWVuIGluIHRoZXRoZSBjZW50cmFsYnVpbGRpbmcgb2ZtYW55IG9mIGhpc2FyZWEgb2YgdGhlaXMgdGhlIG9ubHltb3N0IG9mIHRoZW1hbnkgb2YgdGhldGhlIFdlc3Rlcm5UaGVyZSBpcyBub2V4dGVuZGVkIHRvU3RhdGlzdGljYWxjb2xzcGFuPTIgfHNob3J0IHN0b3J5cG9zc2libGUgdG90b3BvbG9naWNhbGNyaXRpY2FsIG9mcmVwb3J0ZWQgdG9hIENocmlzdGlhbmRlY2lzaW9uIHRvaXMgZXF1YWwgdG9wcm9ibGVtcyBvZlRoaXMgY2FuIGJlbWVyY2hhbmRpc2Vmb3IgbW9zdCBvZm5vIGV2aWRlbmNlZWRpdGlvbnMgb2ZlbGVtZW50cyBpbiZxdW90Oy4gVGhlY29tL2ltYWdlcy93aGljaCBtYWtlc3RoZSBwcm9jZXNzcmVtYWlucyB0aGVsaXRlcmF0dXJlLGlzIGEgbWVtYmVydGhlIHBvcHVsYXJ0aGUgYW5jaWVudHByb2JsZW1zIGludGltZSBvZiB0aGVkZWZlYXRlZCBieWJvZHkgb2YgdGhlYSBmZXcgeWVhcnNtdWNoIG9mIHRoZXRoZSB3b3JrIG9mQ2FsaWZvcm5pYSxzZXJ2ZWQgYXMgYWdvdmVybm1lbnQuY29uY2VwdHMgb2Ztb3ZlbWVudCBpbgkJPGRpdiBpZD0iaXQiIHZhbHVlPSJsYW5ndWFnZSBvZmFzIHRoZXkgYXJlcHJvZHVjZWQgaW5pcyB0aGF0IHRoZWV4cGxhaW4gdGhlZGl2PjwvZGl2PgpIb3dldmVyIHRoZWxlYWQgdG8gdGhlCTxhIGhyZWY9Ii93YXMgZ3JhbnRlZHBlb3BsZSBoYXZlY29udGludWFsbHl3YXMgc2VlbiBhc2FuZCByZWxhdGVkdGhlIHJvbGUgb2Zwcm9wb3NlZCBieW9mIHRoZSBiZXN0ZWFjaCBvdGhlci5Db25zdGFudGluZXBlb3BsZSBmcm9tZGlhbGVjdHMgb2Z0byByZXZpc2lvbndhcyByZW5hbWVkYSBzb3VyY2Ugb2Z0aGUgaW5pdGlhbGxhdW5jaGVkIGlucHJvdmlkZSB0aGV0byB0aGUgd2VzdHdoZXJlIHRoZXJlYW5kIHNpbWlsYXJiZXR3ZWVuIHR3b2lzIGFsc28gdGhlRW5nbGlzaCBhbmRjb25kaXRpb25zLHRoYXQgaXQgd2FzZW50aXRsZWQgdG90aGVtc2VsdmVzLnF1YW50aXR5IG9mcmFuc3BhcmVuY3l0aGUgc2FtZSBhc3RvIGpvaW4gdGhlY291bnRyeSBhbmR0aGlzIGlzIHRoZVRoaXMgbGVkIHRvYSBzdGF0ZW1lbnRjb250cmFzdCB0b2xhc3RJbmRleE9mdGhyb3VnaCBoaXNpcyBkZXNpZ25lZHRoZSB0ZXJtIGlzaXMgcHJvdmlkZWRwcm90ZWN0IHRoZW5nPC9hPjwvbGk+VGhlIGN1cnJlbnR0aGUgc2l0ZSBvZnN1YnN0YW50aWFsZXhwZXJpZW5jZSxpbiB0aGUgV2VzdHRoZXkgc2hvdWxkc2xvdmVuxI1pbmFjb21lbnRhcmlvc3VuaXZlcnNpZGFkY29uZGljaW9uZXNhY3RpdmlkYWRlc2V4cGVyaWVuY2lhdGVjbm9sb2fDrWFwcm9kdWNjacOzbnB1bnR1YWNpw7NuYXBsaWNhY2nDs25jb250cmFzZcOxYWNhdGVnb3LDrWFzcmVnaXN0cmFyc2Vwcm9mZXNpb25hbHRyYXRhbWllbnRvcmVnw61zdHJhdGVzZWNyZXRhcsOtYXByaW5jaXBhbGVzcHJvdGVjY2nDs25pbXBvcnRhbnRlc2ltcG9ydGFuY2lhcG9zaWJpbGlkYWRpbnRlcmVzYW50ZWNyZWNpbWllbnRvbmVjZXNpZGFkZXNzdXNjcmliaXJzZWFzb2NpYWNpw7NuZGlzcG9uaWJsZXNldmFsdWFjacOzbmVzdHVkaWFudGVzcmVzcG9uc2FibGVyZXNvbHVjacOzbmd1YWRhbGFqYXJhcmVnaXN0cmFkb3NvcG9ydHVuaWRhZGNvbWVyY2lhbGVzZm90b2dyYWbDrWFhdXRvcmlkYWRlc2luZ2VuaWVyw61hdGVsZXZpc2nDs25jb21wZXRlbmNpYW9wZXJhY2lvbmVzZXN0YWJsZWNpZG9zaW1wbGVtZW50ZWFjdHVhbG1lbnRlbmF2ZWdhY2nDs25jb25mb3JtaWRhZGxpbmUtaGVpZ2h0OmZvbnQtZmFtaWx5OiIgOiAiaHR0cDovL2FwcGxpY2F0aW9uc2xpbmsiIGhyZWY9InNwZWNpZmljYWxseS8vPCFbQ0RBVEFbCk9yZ2FuaXphdGlvbmRpc3RyaWJ1dGlvbjBweDsgaGVpZ2h0OnJlbGF0aW9uc2hpcGRldmljZS13aWR0aDxkaXYgY2xhc3M9IjxsYWJlbCBmb3I9InJlZ2lzdHJhdGlvbjwvbm9zY3JpcHQ+Ci9pbmRleC5odG1sIndpbmRvdy5vcGVuKCAhaW1wb3J0YW50O2FwcGxpY2F0aW9uL2luZGVwZW5kZW5jZS8vd3d3Lmdvb2dsZW9yZ2FuaXphdGlvbmF1dG9jb21wbGV0ZXJlcXVpcmVtZW50c2NvbnNlcnZhdGl2ZTxmb3JtIG5hbWU9ImludGVsbGVjdHVhbG1hcmdpbi1sZWZ0OjE4dGggY2VudHVyeWFuIGltcG9ydGFudGluc3RpdHV0aW9uc2FiYnJldmlhdGlvbjxpbWcgY2xhc3M9Im9yZ2FuaXNhdGlvbmNpdmlsaXphdGlvbjE5dGggY2VudHVyeWFyY2hpdGVjdHVyZWluY29ycG9yYXRlZDIwdGggY2VudHVyeS1jb250YWluZXIiPm1vc3Qgbm90YWJseS8+PC9hPjwvZGl2Pm5vdGlmaWNhdGlvbid1bmRlZmluZWQnKUZ1cnRoZXJtb3JlLGJlbGlldmUgdGhhdGlubmVySFRNTCA9IHByaW9yIHRvIHRoZWRyYW1hdGljYWxseXJlZmVycmluZyB0b25lZ290aWF0aW9uc2hlYWRxdWFydGVyc1NvdXRoIEFmcmljYXVuc3VjY2Vzc2Z1bFBlbm5zeWx2YW5pYUFzIGEgcmVzdWx0LDxodG1sIGxhbmc9IiZsdDsvc3VwJmd0O2RlYWxpbmcgd2l0aHBoaWxhZGVscGhpYWhpc3RvcmljYWxseSk7PC9zY3JpcHQ+CnBhZGRpbmctdG9wOmV4cGVyaW1lbnRhbGdldEF0dHJpYnV0ZWluc3RydWN0aW9uc3RlY2hub2xvZ2llc3BhcnQgb2YgdGhlID1mdW5jdGlvbigpe3N1YnNjcmlwdGlvbmwuZHRkIj4NCjxodGdlb2dyYXBoaWNhbENvbnN0aXR1dGlvbicsIGZ1bmN0aW9uKHN1cHBvcnRlZCBieWFncmljdWx0dXJhbGNvbnN0cnVjdGlvbnB1YmxpY2F0aW9uc2ZvbnQtc2l6ZTogMWEgdmFyaWV0eSBvZjxkaXYgc3R5bGU9IkVuY3ljbG9wZWRpYWlmcmFtZSBzcmM9ImRlbW9uc3RyYXRlZGFjY29tcGxpc2hlZHVuaXZlcnNpdGllc0RlbW9ncmFwaGljcyk7PC9zY3JpcHQ+PGRlZGljYXRlZCB0b2tub3dsZWRnZSBvZnNhdGlzZmFjdGlvbnBhcnRpY3VsYXJseTwvZGl2PjwvZGl2PkVuZ2xpc2ggKFVTKWFwcGVuZENoaWxkKHRyYW5zbWlzc2lvbnMuIEhvd2V2ZXIsIGludGVsbGlnZW5jZSIgdGFiaW5kZXg9ImZsb2F0OnJpZ2h0O0NvbW1vbndlYWx0aHJhbmdpbmcgZnJvbWluIHdoaWNoIHRoZWF0IGxlYXN0IG9uZXJlcHJvZHVjdGlvbmVuY3ljbG9wZWRpYTtmb250LXNpemU6MWp1cmlzZGljdGlvbmF0IHRoYXQgdGltZSI+PGEgY2xhc3M9IkluIGFkZGl0aW9uLGRlc2NyaXB0aW9uK2NvbnZlcnNhdGlvbmNvbnRhY3Qgd2l0aGlzIGdlbmVyYWxseXIiIGNvbnRlbnQ9InJlcHJlc2VudGluZyZsdDttYXRoJmd0O3ByZXNlbnRhdGlvbm9jY2FzaW9uYWxseTxpbWcgd2lkdGg9Im5hdmlnYXRpb24iPmNvbXBlbnNhdGlvbmNoYW1waW9uc2hpcG1lZGlhPSJhbGwiIHZpb2xhdGlvbiBvZnJlZmVyZW5jZSB0b3JldHVybiB0cnVlO1N0cmljdC8vRU4iIHRyYW5zYWN0aW9uc2ludGVydmVudGlvbnZlcmlmaWNhdGlvbkluZm9ybWF0aW9uIGRpZmZpY3VsdGllc0NoYW1waW9uc2hpcGNhcGFiaWxpdGllczwhW2VuZGlmXS0tPn0KPC9zY3JpcHQ+CkNocmlzdGlhbml0eWZvciBleGFtcGxlLFByb2Zlc3Npb25hbHJlc3RyaWN0aW9uc3N1Z2dlc3QgdGhhdHdhcyByZWxlYXNlZChzdWNoIGFzIHRoZXJlbW92ZUNsYXNzKHVuZW1wbG95bWVudHRoZSBBbWVyaWNhbnN0cnVjdHVyZSBvZi9pbmRleC5odG1sIHB1Ymxpc2hlZCBpbnNwYW4gY2xhc3M9IiI+PGEgaHJlZj0iL2ludHJvZHVjdGlvbmJlbG9uZ2luZyB0b2NsYWltZWQgdGhhdGNvbnNlcXVlbmNlczxtZXRhIG5hbWU9Ikd1aWRlIHRvIHRoZW92ZXJ3aGVsbWluZ2FnYWluc3QgdGhlIGNvbmNlbnRyYXRlZCwKLm5vbnRvdWNoIG9ic2VydmF0aW9uczwvYT4KPC9kaXY+CmYgKGRvY3VtZW50LmJvcmRlcjogMXB4IHtmb250LXNpemU6MXRyZWF0bWVudCBvZjAiIGhlaWdodD0iMW1vZGlmaWNhdGlvbkluZGVwZW5kZW5jZWRpdmlkZWQgaW50b2dyZWF0ZXIgdGhhbmFjaGlldmVtZW50c2VzdGFibGlzaGluZ0phdmFTY3JpcHQiIG5ldmVydGhlbGVzc3NpZ25pZmljYW5jZUJyb2FkY2FzdGluZz4mbmJzcDs8L3RkPmNvbnRhaW5lciI+CnN1Y2ggYXMgdGhlIGluZmx1ZW5jZSBvZmEgcGFydGljdWxhcnNyYz0naHR0cDovL25hdmlnYXRpb24iIGhhbGYgb2YgdGhlIHN1YnN0YW50aWFsICZuYnNwOzwvZGl2PmFkdmFudGFnZSBvZmRpc2NvdmVyeSBvZmZ1bmRhbWVudGFsIG1ldHJvcG9saXRhbnRoZSBvcHBvc2l0ZSIgeG1sOmxhbmc9ImRlbGliZXJhdGVseWFsaWduPWNlbnRlcmV2b2x1dGlvbiBvZnByZXNlcnZhdGlvbmltcHJvdmVtZW50c2JlZ2lubmluZyBpbkplc3VzIENocmlzdFB1YmxpY2F0aW9uc2Rpc2FncmVlbWVudHRleHQtYWxpZ246ciwgZnVuY3Rpb24oKXNpbWlsYXJpdGllc2JvZHk+PC9odG1sPmlzIGN1cnJlbnRseWFscGhhYmV0aWNhbGlzIHNvbWV0aW1lc3R5cGU9ImltYWdlL21hbnkgb2YgdGhlIGZsb3c6aGlkZGVuO2F2YWlsYWJsZSBpbmRlc2NyaWJlIHRoZWV4aXN0ZW5jZSBvZmFsbCBvdmVyIHRoZXRoZSBJbnRlcm5ldAk8dWwgY2xhc3M9Imluc3RhbGxhdGlvbm5laWdoYm9yaG9vZGFybWVkIGZvcmNlc3JlZHVjaW5nIHRoZWNvbnRpbnVlcyB0b05vbmV0aGVsZXNzLHRlbXBlcmF0dXJlcwoJCTxhIGhyZWY9ImNsb3NlIHRvIHRoZWV4YW1wbGVzIG9mIGlzIGFib3V0IHRoZShzZWUgYmVsb3cpLiIgaWQ9InNlYXJjaHByb2Zlc3Npb25hbGlzIGF2YWlsYWJsZXRoZSBvZmZpY2lhbAkJPC9zY3JpcHQ+CgoJCTxkaXYgaWQ9ImFjY2VsZXJhdGlvbnRocm91Z2ggdGhlIEhhbGwgb2YgRmFtZWRlc2NyaXB0aW9uc3RyYW5zbGF0aW9uc2ludGVyZmVyZW5jZSB0eXBlPSd0ZXh0L3JlY2VudCB5ZWFyc2luIHRoZSB3b3JsZHZlcnkgcG9wdWxhcntiYWNrZ3JvdW5kOnRyYWRpdGlvbmFsIHNvbWUgb2YgdGhlIGNvbm5lY3RlZCB0b2V4cGxvaXRhdGlvbmVtZXJnZW5jZSBvZmNvbnN0aXR1dGlvbkEgSGlzdG9yeSBvZnNpZ25pZmljYW50IG1hbnVmYWN0dXJlZGV4cGVjdGF0aW9ucz48bm9zY3JpcHQ+PGNhbiBiZSBmb3VuZGJlY2F1c2UgdGhlIGhhcyBub3QgYmVlbm5laWdoYm91cmluZ3dpdGhvdXQgdGhlIGFkZGVkIHRvIHRoZQk8bGkgY2xhc3M9Imluc3RydW1lbnRhbFNvdmlldCBVbmlvbmFja25vd2xlZGdlZHdoaWNoIGNhbiBiZW5hbWUgZm9yIHRoZWF0dGVudGlvbiB0b2F0dGVtcHRzIHRvIGRldmVsb3BtZW50c0luIGZhY3QsIHRoZTxsaSBjbGFzcz0iYWltcGxpY2F0aW9uc3N1aXRhYmxlIGZvcm11Y2ggb2YgdGhlIGNvbG9uaXphdGlvbnByZXNpZGVudGlhbGNhbmNlbEJ1YmJsZSBJbmZvcm1hdGlvbm1vc3Qgb2YgdGhlIGlzIGRlc2NyaWJlZHJlc3Qgb2YgdGhlIG1vcmUgb3IgbGVzc2luIFNlcHRlbWJlckludGVsbGlnZW5jZXNyYz0iaHR0cDovL3B4OyBoZWlnaHQ6IGF2YWlsYWJsZSB0b21hbnVmYWN0dXJlcmh1bWFuIHJpZ2h0c2xpbmsgaHJlZj0iL2F2YWlsYWJpbGl0eXByb3BvcnRpb25hbG91dHNpZGUgdGhlIGFzdHJvbm9taWNhbGh1bWFuIGJlaW5nc25hbWUgb2YgdGhlIGFyZSBmb3VuZCBpbmFyZSBiYXNlZCBvbnNtYWxsZXIgdGhhbmEgcGVyc29uIHdob2V4cGFuc2lvbiBvZmFyZ3VpbmcgdGhhdG5vdyBrbm93biBhc0luIHRoZSBlYXJseWludGVybWVkaWF0ZWRlcml2ZWQgZnJvbVNjYW5kaW5hdmlhbjwvYT48L2Rpdj4NCmNvbnNpZGVyIHRoZWFuIGVzdGltYXRlZHRoZSBOYXRpb25hbDxkaXYgaWQ9InBhZ3Jlc3VsdGluZyBpbmNvbW1pc3Npb25lZGFuYWxvZ291cyB0b2FyZSByZXF1aXJlZC91bD4KPC9kaXY+CndhcyBiYXNlZCBvbmFuZCBiZWNhbWUgYSZuYnNwOyZuYnNwO3QiIHZhbHVlPSIiIHdhcyBjYXB0dXJlZG5vIG1vcmUgdGhhbnJlc3BlY3RpdmVseWNvbnRpbnVlIHRvID4NCjxoZWFkPg0KPHdlcmUgY3JlYXRlZG1vcmUgZ2VuZXJhbGluZm9ybWF0aW9uIHVzZWQgZm9yIHRoZWluZGVwZW5kZW50IHRoZSBJbXBlcmlhbGNvbXBvbmVudCBvZnRvIHRoZSBub3J0aGluY2x1ZGUgdGhlIENvbnN0cnVjdGlvbnNpZGUgb2YgdGhlIHdvdWxkIG5vdCBiZWZvciBpbnN0YW5jZWludmVudGlvbiBvZm1vcmUgY29tcGxleGNvbGxlY3RpdmVseWJhY2tncm91bmQ6IHRleHQtYWxpZ246IGl0cyBvcmlnaW5hbGludG8gYWNjb3VudHRoaXMgcHJvY2Vzc2FuIGV4dGVuc2l2ZWhvd2V2ZXIsIHRoZXRoZXkgYXJlIG5vdHJlamVjdGVkIHRoZWNyaXRpY2lzbSBvZmR1cmluZyB3aGljaHByb2JhYmx5IHRoZXRoaXMgYXJ0aWNsZShmdW5jdGlvbigpe0l0IHNob3VsZCBiZWFuIGFncmVlbWVudGFjY2lkZW50YWxseWRpZmZlcnMgZnJvbUFyY2hpdGVjdHVyZWJldHRlciBrbm93bmFycmFuZ2VtZW50c2luZmx1ZW5jZSBvbmF0dGVuZGVkIHRoZWlkZW50aWNhbCB0b3NvdXRoIG9mIHRoZXBhc3MgdGhyb3VnaHhtbCIgdGl0bGU9IndlaWdodDpib2xkO2NyZWF0aW5nIHRoZWRpc3BsYXk6bm9uZXJlcGxhY2VkIHRoZTxpbWcgc3JjPSIvaWh0dHBzOi8vd3d3LldvcmxkIFdhciBJSXRlc3RpbW9uaWFsc2ZvdW5kIGluIHRoZXJlcXVpcmVkIHRvIGFuZCB0aGF0IHRoZWJldHdlZW4gdGhlIHdhcyBkZXNpZ25lZGNvbnNpc3RzIG9mIGNvbnNpZGVyYWJseXB1Ymxpc2hlZCBieXRoZSBsYW5ndWFnZUNvbnNlcnZhdGlvbmNvbnNpc3RlZCBvZnJlZmVyIHRvIHRoZWJhY2sgdG8gdGhlIGNzcyIgbWVkaWE9IlBlb3BsZSBmcm9tIGF2YWlsYWJsZSBvbnByb3ZlZCB0byBiZXN1Z2dlc3Rpb25zIndhcyBrbm93biBhc3ZhcmlldGllcyBvZmxpa2VseSB0byBiZWNvbXByaXNlZCBvZnN1cHBvcnQgdGhlIGhhbmRzIG9mIHRoZWNvdXBsZWQgd2l0aGNvbm5lY3QgYW5kIGJvcmRlcjpub25lO3BlcmZvcm1hbmNlc2JlZm9yZSBiZWluZ2xhdGVyIGJlY2FtZWNhbGN1bGF0aW9uc29mdGVuIGNhbGxlZHJlc2lkZW50cyBvZm1lYW5pbmcgdGhhdD48bGkgY2xhc3M9ImV2aWRlbmNlIGZvcmV4cGxhbmF0aW9uc2Vudmlyb25tZW50cyI+PC9hPjwvZGl2PndoaWNoIGFsbG93c0ludHJvZHVjdGlvbmRldmVsb3BlZCBieWEgd2lkZSByYW5nZW9uIGJlaGFsZiBvZnZhbGlnbj0idG9wInByaW5jaXBsZSBvZmF0IHRoZSB0aW1lLDwvbm9zY3JpcHQ+DXNhaWQgdG8gaGF2ZWluIHRoZSBmaXJzdHdoaWxlIG90aGVyc2h5cG90aGV0aWNhbHBoaWxvc29waGVyc3Bvd2VyIG9mIHRoZWNvbnRhaW5lZCBpbnBlcmZvcm1lZCBieWluYWJpbGl0eSB0b3dlcmUgd3JpdHRlbnNwYW4gc3R5bGU9ImlucHV0IG5hbWU9InRoZSBxdWVzdGlvbmludGVuZGVkIGZvcnJlamVjdGlvbiBvZmltcGxpZXMgdGhhdGludmVudGVkIHRoZXRoZSBzdGFuZGFyZHdhcyBwcm9iYWJseWxpbmsgYmV0d2VlbnByb2Zlc3NvciBvZmludGVyYWN0aW9uc2NoYW5naW5nIHRoZUluZGlhbiBPY2VhbiBjbGFzcz0ibGFzdHdvcmtpbmcgd2l0aCdodHRwOi8vd3d3LnllYXJzIGJlZm9yZVRoaXMgd2FzIHRoZXJlY3JlYXRpb25hbGVudGVyaW5nIHRoZW1lYXN1cmVtZW50c2FuIGV4dHJlbWVseXZhbHVlIG9mIHRoZXN0YXJ0IG9mIHRoZQo8L3NjcmlwdD4KCmFuIGVmZm9ydCB0b2luY3JlYXNlIHRoZXRvIHRoZSBzb3V0aHNwYWNpbmc9IjAiPnN1ZmZpY2llbnRseXRoZSBFdXJvcGVhbmNvbnZlcnRlZCB0b2NsZWFyVGltZW91dGRpZCBub3QgaGF2ZWNvbnNlcXVlbnRseWZvciB0aGUgbmV4dGV4dGVuc2lvbiBvZmVjb25vbWljIGFuZGFsdGhvdWdoIHRoZWFyZSBwcm9kdWNlZGFuZCB3aXRoIHRoZWluc3VmZmljaWVudGdpdmVuIGJ5IHRoZXN0YXRpbmcgdGhhdGV4cGVuZGl0dXJlczwvc3Bhbj48L2E+CnRob3VnaHQgdGhhdG9uIHRoZSBiYXNpc2NlbGxwYWRkaW5nPWltYWdlIG9mIHRoZXJldHVybmluZyB0b2luZm9ybWF0aW9uLHNlcGFyYXRlZCBieWFzc2Fzc2luYXRlZHMiIGNvbnRlbnQ9ImF1dGhvcml0eSBvZm5vcnRod2VzdGVybjwvZGl2Pgo8ZGl2ICI+PC9kaXY+DQogIGNvbnN1bHRhdGlvbmNvbW11bml0eSBvZnRoZSBuYXRpb25hbGl0IHNob3VsZCBiZXBhcnRpY2lwYW50cyBhbGlnbj0ibGVmdHRoZSBncmVhdGVzdHNlbGVjdGlvbiBvZnN1cGVybmF0dXJhbGRlcGVuZGVudCBvbmlzIG1lbnRpb25lZGFsbG93aW5nIHRoZXdhcyBpbnZlbnRlZGFjY29tcGFueWluZ2hpcyBwZXJzb25hbGF2YWlsYWJsZSBhdHN0dWR5IG9mIHRoZW9uIHRoZSBvdGhlcmV4ZWN1dGlvbiBvZkh1bWFuIFJpZ2h0c3Rlcm1zIG9mIHRoZWFzc29jaWF0aW9uc3Jlc2VhcmNoIGFuZHN1Y2NlZWRlZCBieWRlZmVhdGVkIHRoZWFuZCBmcm9tIHRoZWJ1dCB0aGV5IGFyZWNvbW1hbmRlciBvZnN0YXRlIG9mIHRoZXllYXJzIG9mIGFnZXRoZSBzdHVkeSBvZjx1bCBjbGFzcz0ic3BsYWNlIGluIHRoZXdoZXJlIGhlIHdhczxsaSBjbGFzcz0iZnRoZXJlIGFyZSBub3doaWNoIGJlY2FtZWhlIHB1Ymxpc2hlZGV4cHJlc3NlZCBpbnRvIHdoaWNoIHRoZWNvbW1pc3Npb25lcmZvbnQtd2VpZ2h0OnRlcnJpdG9yeSBvZmV4dGVuc2lvbnMiPlJvbWFuIEVtcGlyZWVxdWFsIHRvIHRoZUluIGNvbnRyYXN0LGhvd2V2ZXIsIGFuZGlzIHR5cGljYWxseWFuZCBoaXMgd2lmZShhbHNvIGNhbGxlZD48dWwgY2xhc3M9ImVmZmVjdGl2ZWx5IGV2b2x2ZWQgaW50b3NlZW0gdG8gaGF2ZXdoaWNoIGlzIHRoZXRoZXJlIHdhcyBub2FuIGV4Y2VsbGVudGFsbCBvZiB0aGVzZWRlc2NyaWJlZCBieUluIHByYWN0aWNlLGJyb2FkY2FzdGluZ2NoYXJnZWQgd2l0aHJlZmxlY3RlZCBpbnN1YmplY3RlZCB0b21pbGl0YXJ5IGFuZHRvIHRoZSBwb2ludGVjb25vbWljYWxseXNldFRhcmdldGluZ2FyZSBhY3R1YWxseXZpY3Rvcnkgb3ZlcigpOzwvc2NyaXB0PmNvbnRpbnVvdXNseXJlcXVpcmVkIGZvcmV2b2x1dGlvbmFyeWFuIGVmZmVjdGl2ZW5vcnRoIG9mIHRoZSwgd2hpY2ggd2FzIGZyb250IG9mIHRoZW9yIG90aGVyd2lzZXNvbWUgZm9ybSBvZmhhZCBub3QgYmVlbmdlbmVyYXRlZCBieWluZm9ybWF0aW9uLnBlcm1pdHRlZCB0b2luY2x1ZGVzIHRoZWRldmVsb3BtZW50LGVudGVyZWQgaW50b3RoZSBwcmV2aW91c2NvbnNpc3RlbnRseWFyZSBrbm93biBhc3RoZSBmaWVsZCBvZnRoaXMgdHlwZSBvZmdpdmVuIHRvIHRoZXRoZSB0aXRsZSBvZmNvbnRhaW5zIHRoZWluc3RhbmNlcyBvZmluIHRoZSBub3J0aGR1ZSB0byB0aGVpcmFyZSBkZXNpZ25lZGNvcnBvcmF0aW9uc3dhcyB0aGF0IHRoZW9uZSBvZiB0aGVzZW1vcmUgcG9wdWxhcnN1Y2NlZWRlZCBpbnN1cHBvcnQgZnJvbWluIGRpZmZlcmVudGRvbWluYXRlZCBieWRlc2lnbmVkIGZvcm93bmVyc2hpcCBvZmFuZCBwb3NzaWJseXN0YW5kYXJkaXplZHJlc3BvbnNlVGV4dHdhcyBpbnRlbmRlZHJlY2VpdmVkIHRoZWFzc3VtZWQgdGhhdGFyZWFzIG9mIHRoZXByaW1hcmlseSBpbnRoZSBiYXNpcyBvZmluIHRoZSBzZW5zZWFjY291bnRzIGZvcmRlc3Ryb3llZCBieWF0IGxlYXN0IHR3b3dhcyBkZWNsYXJlZGNvdWxkIG5vdCBiZVNlY3JldGFyeSBvZmFwcGVhciB0byBiZW1hcmdpbi10b3A6MS9eXHMrfFxzKyQvZ2Upe3Rocm93IGV9O3RoZSBzdGFydCBvZnR3byBzZXBhcmF0ZWxhbmd1YWdlIGFuZHdobyBoYWQgYmVlbm9wZXJhdGlvbiBvZmRlYXRoIG9mIHRoZXJlYWwgbnVtYmVycwk8bGluayByZWw9InByb3ZpZGVkIHRoZXRoZSBzdG9yeSBvZmNvbXBldGl0aW9uc2VuZ2xpc2ggKFVLKWVuZ2xpc2ggKFVTKdCc0L7QvdCz0L7Qu9Ch0YDQv9GB0LrQuNGB0YDQv9GB0LrQuNGB0YDQv9GB0LrQvtmE2LnYsdio2YrYqeato+mrlOS4reaWh+eugOS9k+S4reaWh+e5geS9k+S4reaWh+aciemZkOWFrOWPuOS6uuawkeaUv+W6nOmYv+mHjOW3tOW3tOekvuS8muS4u+S5ieaTjeS9nOezu+e7n+aUv+etluazleinhGluZm9ybWFjacOzbmhlcnJhbWllbnRhc2VsZWN0csOzbmljb2Rlc2NyaXBjacOzbmNsYXNpZmljYWRvc2Nvbm9jaW1pZW50b3B1YmxpY2FjacOzbnJlbGFjaW9uYWRhc2luZm9ybcOhdGljYXJlbGFjaW9uYWRvc2RlcGFydGFtZW50b3RyYWJhamFkb3Jlc2RpcmVjdGFtZW50ZWF5dW50YW1pZW50b21lcmNhZG9MaWJyZWNvbnTDoWN0ZW5vc2hhYml0YWNpb25lc2N1bXBsaW1pZW50b3Jlc3RhdXJhbnRlc2Rpc3Bvc2ljacOzbmNvbnNlY3VlbmNpYWVsZWN0csOzbmljYWFwbGljYWNpb25lc2Rlc2NvbmVjdGFkb2luc3RhbGFjacOzbnJlYWxpemFjacOzbnV0aWxpemFjacOzbmVuY2ljbG9wZWRpYWVuZmVybWVkYWRlc2luc3RydW1lbnRvc2V4cGVyaWVuY2lhc2luc3RpdHVjacOzbnBhcnRpY3VsYXJlc3N1YmNhdGVnb3JpYdGC0L7Qu9GM0LrQvtCg0L7RgdGB0LjQuNGA0LDQsdC+0YLRi9Cx0L7Qu9GM0YjQtdC/0YDQvtGB0YLQvtC80L7QttC10YLQtdC00YDRg9Cz0LjRhdGB0LvRg9GH0LDQtdGB0LXQudGH0LDRgdCy0YHQtdCz0LTQsNCg0L7RgdGB0LjRj9Cc0L7RgdC60LLQtdC00YDRg9Cz0LjQtdCz0L7RgNC+0LTQsNCy0L7Qv9GA0L7RgdC00LDQvdC90YvRhdC00L7Qu9C20L3Ri9C40LzQtdC90L3QvtCc0L7RgdC60LLRi9GA0YPQsdC70LXQudCc0L7RgdC60LLQsNGB0YLRgNCw0L3Ri9C90LjRh9C10LPQvtGA0LDQsdC+0YLQtdC00L7Qu9C20LXQvdGD0YHQu9GD0LPQuNGC0LXQv9C10YDRjNCe0LTQvdCw0LrQvtC/0L7RgtC+0LzRg9GA0LDQsdC+0YLRg9Cw0L/RgNC10LvRj9Cy0L7QvtCx0YnQtdC+0LTQvdC+0LPQvtGB0LLQvtC10LPQvtGB0YLQsNGC0YzQuNC00YDRg9Cz0L7QudGE0L7RgNGD0LzQtdGF0L7RgNC+0YjQvtC/0YDQvtGC0LjQstGB0YHRi9C70LrQsNC60LDQttC00YvQudCy0LvQsNGB0YLQuNCz0YDRg9C/0L/Ri9Cy0LzQtdGB0YLQtdGA0LDQsdC+0YLQsNGB0LrQsNC30LDQu9C/0LXRgNCy0YvQudC00LXQu9Cw0YLRjNC00LXQvdGM0LPQuNC/0LXRgNC40L7QtNCx0LjQt9C90LXRgdC+0YHQvdC+0LLQtdC80L7QvNC10L3RgtC60YPQv9C40YLRjNC00L7Qu9C20L3QsNGA0LDQvNC60LDRhdC90LDRh9Cw0LvQvtCg0LDQsdC+0YLQsNCi0L7Qu9GM0LrQvtGB0L7QstGB0LXQvNCy0YLQvtGA0L7QudC90LDRh9Cw0LvQsNGB0L/QuNGB0L7QutGB0LvRg9C20LHRi9GB0LjRgdGC0LXQvNC/0LXRh9Cw0YLQuNC90L7QstC+0LPQvtC/0L7QvNC+0YnQuNGB0LDQudGC0L7QstC/0L7Rh9C10LzRg9C/0L7QvNC+0YnRjNC00L7Qu9C20L3QvtGB0YHRi9C70LrQuNCx0YvRgdGC0YDQvtC00LDQvdC90YvQtdC80L3QvtCz0LjQtdC/0YDQvtC10LrRgtCh0LXQudGH0LDRgdC80L7QtNC10LvQuNGC0LDQutC+0LPQvtC+0L3Qu9Cw0LnQvdCz0L7RgNC+0LTQtdCy0LXRgNGB0LjRj9GB0YLRgNCw0L3QtdGE0LjQu9GM0LzRi9GD0YDQvtCy0L3Rj9GA0LDQt9C90YvRhdC40YHQutCw0YLRjNC90LXQtNC10LvRjtGP0L3QstCw0YDRj9C80LXQvdGM0YjQtdC80L3QvtCz0LjRhdC00LDQvdC90L7QudC30L3QsNGH0LjRgtC90LXQu9GM0LfRj9GE0L7RgNGD0LzQsNCi0LXQv9C10YDRjNC80LXRgdGP0YbQsNC30LDRidC40YLRi9Cb0YPRh9GI0LjQteCkqOCkueClgOCkguCkleCksOCkqOClh+CkheCkquCkqOClh+CkleCkv+Ckr+CkvuCkleCksOClh+CkguCkheCkqOCljeCkr+CkleCljeCkr+CkvuCkl+CkvuCkh+CkoeCkrOCkvuCksOClh+CkleCkv+CkuOClgOCkpuCkv+Ckr+CkvuCkquCkueCksuClh+CkuOCkv+CkguCkueCkreCkvuCksOCkpOCkheCkquCkqOClgOCkteCkvuCksuClh+CkuOClh+CkteCkvuCkleCksOCkpOClh+CkruClh+CksOClh+CkueCli+CkqOClh+CkuOCkleCkpOClh+CkrOCkueClgeCkpOCkuOCkvuCkh+Ckn+CkueCli+Ckl+CkvuCknOCkvuCkqOClh+CkruCkv+CkqOCkn+CkleCksOCkpOCkvuCkleCksOCkqOCkvuCkieCkqOCkleClh+Ckr+CkueCkvuCkgeCkuOCkrOCkuOClh+CkreCkvuCkt+CkvuCkhuCkquCkleClh+CksuCkv+Ckr+Clh+CktuClgeCksOClguCkh+CkuOCkleClh+CkmOCkguCkn+Clh+CkruClh+CksOClgOCkuOCkleCkpOCkvuCkruClh+CksOCkvuCksuClh+CkleCksOCkheCkp+Ckv+CkleCkheCkquCkqOCkvuCkuOCkruCkvuCknOCkruClgeCkneClh+CkleCkvuCksOCko+CkueCli+CkpOCkvuCkleCkoeCkvOClgOCkr+CkueCkvuCkguCkueCli+Ckn+CksuCktuCkrOCljeCkpuCksuCkv+Ckr+CkvuCknOClgOCkteCkqOCknOCkvuCkpOCkvuCkleCliOCkuOClh+CkhuCkquCkleCkvuCkteCkvuCksuClgOCkpuClh+CkqOClh+CkquClguCksOClgOCkquCkvuCkqOClgOCkieCkuOCkleClh+CkueCli+Ckl+ClgOCkrOCliOCkoOCkleCkhuCkquCkleClgOCkteCksOCljeCkt+Ckl+CkvuCkguCkteCkhuCkquCkleCli+CknOCkv+CksuCkvuCknOCkvuCkqOCkvuCkuOCkueCkruCkpOCkueCkruClh+CkguCkieCkqOCkleClgOCkr+CkvuCkueClguCkpuCksOCljeCknOCkuOClguCkmuClgOCkquCkuOCkguCkpuCkuOCkteCkvuCksuCkueCli+CkqOCkvuCkueCli+CkpOClgOCknOCliOCkuOClh+CkteCkvuCkquCkuOCknOCkqOCkpOCkvuCkqOClh+CkpOCkvuCknOCkvuCksOClgOCkmOCkvuCkr+CksuCknOCkv+CksuClh+CkqOClgOCkmuClh+CknOCkvuCkguCkmuCkquCkpOCljeCksOCkl+ClguCkl+CksuCknOCkvuCkpOClh+CkrOCkvuCkueCksOCkhuCkquCkqOClh+CkteCkvuCkueCkqOCkh+CkuOCkleCkvuCkuOClgeCkrOCkueCksOCkueCkqOClh+Ckh+CkuOCkuOClh+CkuOCkueCkv+CkpOCkrOCkoeCkvOClh+CkmOCkn+CkqOCkvuCkpOCksuCkvuCktuCkquCkvuCkguCkmuCktuCljeCksOClgOCkrOCkoeCkvOClgOCkueCli+CkpOClh+CkuOCkvuCkiOCkn+CktuCkvuCkr+CkpuCkuOCkleCkpOClgOCknOCkvuCkpOClgOCkteCkvuCksuCkvuCkueCknOCkvuCksOCkquCkn+CkqOCkvuCksOCkluCkqOClh+CkuOCkoeCkvOCkleCkruCkv+CksuCkvuCkieCkuOCkleClgOCkleClh+CkteCksuCksuCkl+CkpOCkvuCkluCkvuCkqOCkvuCkheCksOCljeCkpeCknOCkueCkvuCkguCkpuClh+CkluCkvuCkquCkueCksuClgOCkqOCkv+Ckr+CkruCkrOCkv+CkqOCkvuCkrOCliOCkguCkleCkleCkueClgOCkguCkleCkueCkqOCkvuCkpuClh+CkpOCkvuCkueCkruCksuClh+CkleCkvuCkq+ClgOCknOCkrOCkleCkv+CkpOClgeCksOCkpOCkruCkvuCkguCkl+CkteCkueClgOCkguCksOCli+CknOCkvOCkruCkv+CksuClgOCkhuCksOCli+CkquCkuOClh+CkqOCkvuCkr+CkvuCkpuCkteCksuClh+CkqOClh+CkluCkvuCkpOCkvuCkleCksOClgOCkrOCkieCkqOCkleCkvuCknOCkteCkvuCkrOCkquClguCksOCkvuCkrOCkoeCkvOCkvuCkuOCljOCkpuCkvuCktuClh+Ckr+CksOCkleCkv+Ckr+Clh+CkleCkueCkvuCkguCkheCkleCkuOCksOCkrOCkqOCkvuCkj+CkteCkueCkvuCkguCkuOCljeCkpeCksuCkruCkv+CksuClh+CksuClh+CkluCkleCkteCkv+Ckt+Ckr+CkleCljeCksOCkguCkuOCkruClguCkueCkpeCkvuCkqOCkvtiq2LPYqti32YrYudmF2LTYp9ix2YPYqdio2YjYp9iz2LfYqdin2YTYtdmB2K3YqdmF2YjYp9i22YrYudin2YTYrtin2LXYqdin2YTZhdiy2YrYr9in2YTYudin2YXYqdin2YTZg9in2KrYqNin2YTYsdiv2YjYr9io2LHZhtin2YXYrNin2YTYr9mI2YTYqdin2YTYudin2YTZhdin2YTZhdmI2YLYudin2YTYudix2KjZitin2YTYs9ix2YrYudin2YTYrNmI2KfZhNin2YTYsNmH2KfYqNin2YTYrdmK2KfYqdin2YTYrdmC2YjZgtin2YTZg9ix2YrZhdin2YTYudix2KfZgtmF2K3ZgdmI2LjYqdin2YTYq9in2YbZitmF2LTYp9mH2K/Yqdin2YTZhdix2KPYqdin2YTZgtix2KLZhtin2YTYtNio2KfYqNin2YTYrdmI2KfYsdin2YTYrNiv2YrYr9in2YTYo9iz2LHYqdin2YTYudmE2YjZhdmF2KzZhdmI2LnYqdin2YTYsdit2YXZhtin2YTZhtmC2KfYt9mB2YTYs9i32YrZhtin2YTZg9mI2YrYqtin2YTYr9mG2YrYp9io2LHZg9in2KrZh9in2YTYsdmK2KfYttiq2K3Zitin2KrZitio2KrZiNmC2YrYqtin2YTYo9mI2YTZidin2YTYqNix2YrYr9in2YTZg9mE2KfZhdin2YTYsdin2KjYt9in2YTYtNiu2LXZitiz2YrYp9ix2KfYqtin2YTYq9in2YTYq9in2YTYtdmE2KfYqdin2YTYrdiv2YrYq9in2YTYstmI2KfYsdin2YTYrtmE2YrYrNin2YTYrNmF2YrYudin2YTYudin2YXZh9in2YTYrNmF2KfZhNin2YTYs9in2LnYqdmF2LTYp9mH2K/Zh9in2YTYsdim2YrYs9in2YTYr9iu2YjZhNin2YTZgdmG2YrYqdin2YTZg9iq2KfYqNin2YTYr9mI2LHZitin2YTYr9ix2YjYs9in2LPYqti62LHZgtiq2LXYp9mF2YrZhdin2YTYqNmG2KfYqtin2YTYudi42YrZhWVudGVydGFpbm1lbnR1bmRlcnN0YW5kaW5nID0gZnVuY3Rpb24oKS5qcGciIHdpZHRoPSJjb25maWd1cmF0aW9uLnBuZyIgd2lkdGg9Ijxib2R5IGNsYXNzPSJNYXRoLnJhbmRvbSgpY29udGVtcG9yYXJ5IFVuaXRlZCBTdGF0ZXNjaXJjdW1zdGFuY2VzLmFwcGVuZENoaWxkKG9yZ2FuaXphdGlvbnM8c3BhbiBjbGFzcz0iIj48aW1nIHNyYz0iL2Rpc3Rpbmd1aXNoZWR0aG91c2FuZHMgb2YgY29tbXVuaWNhdGlvbmNsZWFyIj48L2Rpdj5pbnZlc3RpZ2F0aW9uZmF2aWNvbi5pY28iIG1hcmdpbi1yaWdodDpiYXNlZCBvbiB0aGUgTWFzc2FjaHVzZXR0c3RhYmxlIGJvcmRlcj1pbnRlcm5hdGlvbmFsYWxzbyBrbm93biBhc3Byb251bmNpYXRpb25iYWNrZ3JvdW5kOiNmcGFkZGluZy1sZWZ0OkZvciBleGFtcGxlLCBtaXNjZWxsYW5lb3VzJmx0Oy9tYXRoJmd0O3BzeWNob2xvZ2ljYWxpbiBwYXJ0aWN1bGFyZWFyY2giIHR5cGU9ImZvcm0gbWV0aG9kPSJhcyBvcHBvc2VkIHRvU3VwcmVtZSBDb3VydG9jY2FzaW9uYWxseSBBZGRpdGlvbmFsbHksTm9ydGggQW1lcmljYXB4O2JhY2tncm91bmRvcHBvcnR1bml0aWVzRW50ZXJ0YWlubWVudC50b0xvd2VyQ2FzZShtYW51ZmFjdHVyaW5ncHJvZmVzc2lvbmFsIGNvbWJpbmVkIHdpdGhGb3IgaW5zdGFuY2UsY29uc2lzdGluZyBvZiIgbWF4bGVuZ3RoPSJyZXR1cm4gZmFsc2U7Y29uc2Npb3VzbmVzc01lZGl0ZXJyYW5lYW5leHRyYW9yZGluYXJ5YXNzYXNzaW5hdGlvbnN1YnNlcXVlbnRseSBidXR0b24gdHlwZT0idGhlIG51bWJlciBvZnRoZSBvcmlnaW5hbCBjb21wcmVoZW5zaXZlcmVmZXJzIHRvIHRoZTwvdWw+CjwvZGl2PgpwaGlsb3NvcGhpY2FsbG9jYXRpb24uaHJlZndhcyBwdWJsaXNoZWRTYW4gRnJhbmNpc2NvKGZ1bmN0aW9uKCl7CjxkaXYgaWQ9Im1haW5zb3BoaXN0aWNhdGVkbWF0aGVtYXRpY2FsIC9oZWFkPg0KPGJvZHlzdWdnZXN0cyB0aGF0ZG9jdW1lbnRhdGlvbmNvbmNlbnRyYXRpb25yZWxhdGlvbnNoaXBzbWF5IGhhdmUgYmVlbihmb3IgZXhhbXBsZSxUaGlzIGFydGljbGUgaW4gc29tZSBjYXNlc3BhcnRzIG9mIHRoZSBkZWZpbml0aW9uIG9mR3JlYXQgQnJpdGFpbiBjZWxscGFkZGluZz1lcXVpdmFsZW50IHRvcGxhY2Vob2xkZXI9IjsgZm9udC1zaXplOiBqdXN0aWZpY2F0aW9uYmVsaWV2ZWQgdGhhdHN1ZmZlcmVkIGZyb21hdHRlbXB0ZWQgdG8gbGVhZGVyIG9mIHRoZWNyaXB0IiBzcmM9Ii8oZnVuY3Rpb24oKSB7YXJlIGF2YWlsYWJsZQoJPGxpbmsgcmVsPSIgc3JjPSdodHRwOi8vaW50ZXJlc3RlZCBpbmNvbnZlbnRpb25hbCAiIGFsdD0iIiAvPjwvYXJlIGdlbmVyYWxseWhhcyBhbHNvIGJlZW5tb3N0IHBvcHVsYXIgY29ycmVzcG9uZGluZ2NyZWRpdGVkIHdpdGh0eWxlPSJib3JkZXI6PC9hPjwvc3Bhbj48Ly5naWYiIHdpZHRoPSI8aWZyYW1lIHNyYz0idGFibGUgY2xhc3M9ImlubGluZS1ibG9jazthY2NvcmRpbmcgdG8gdG9nZXRoZXIgd2l0aGFwcHJveGltYXRlbHlwYXJsaWFtZW50YXJ5bW9yZSBhbmQgbW9yZWRpc3BsYXk6bm9uZTt0cmFkaXRpb25hbGx5cHJlZG9taW5hbnRseSZuYnNwO3wmbmJzcDsmbmJzcDs8L3NwYW4+IGNlbGxzcGFjaW5nPTxpbnB1dCBuYW1lPSJvciIgY29udGVudD0iY29udHJvdmVyc2lhbHByb3BlcnR5PSJvZzoveC1zaG9ja3dhdmUtZGVtb25zdHJhdGlvbnN1cnJvdW5kZWQgYnlOZXZlcnRoZWxlc3Msd2FzIHRoZSBmaXJzdGNvbnNpZGVyYWJsZSBBbHRob3VnaCB0aGUgY29sbGFib3JhdGlvbnNob3VsZCBub3QgYmVwcm9wb3J0aW9uIG9mPHNwYW4gc3R5bGU9Imtub3duIGFzIHRoZSBzaG9ydGx5IGFmdGVyZm9yIGluc3RhbmNlLGRlc2NyaWJlZCBhcyAvaGVhZD4KPGJvZHkgc3RhcnRpbmcgd2l0aGluY3JlYXNpbmdseSB0aGUgZmFjdCB0aGF0ZGlzY3Vzc2lvbiBvZm1pZGRsZSBvZiB0aGVhbiBpbmRpdmlkdWFsZGlmZmljdWx0IHRvIHBvaW50IG9mIHZpZXdob21vc2V4dWFsaXR5YWNjZXB0YW5jZSBvZjwvc3Bhbj48L2Rpdj5tYW51ZmFjdHVyZXJzb3JpZ2luIG9mIHRoZWNvbW1vbmx5IHVzZWRpbXBvcnRhbmNlIG9mZGVub21pbmF0aW9uc2JhY2tncm91bmQ6ICNsZW5ndGggb2YgdGhlZGV0ZXJtaW5hdGlvbmEgc2lnbmlmaWNhbnQiIGJvcmRlcj0iMCI+cmV2b2x1dGlvbmFyeXByaW5jaXBsZXMgb2ZpcyBjb25zaWRlcmVkd2FzIGRldmVsb3BlZEluZG8tRXVyb3BlYW52dWxuZXJhYmxlIHRvcHJvcG9uZW50cyBvZmFyZSBzb21ldGltZXNjbG9zZXIgdG8gdGhlTmV3IFlvcmsgQ2l0eSBuYW1lPSJzZWFyY2hhdHRyaWJ1dGVkIHRvY291cnNlIG9mIHRoZW1hdGhlbWF0aWNpYW5ieSB0aGUgZW5kIG9mYXQgdGhlIGVuZCBvZiIgYm9yZGVyPSIwIiB0ZWNobm9sb2dpY2FsLnJlbW92ZUNsYXNzKGJyYW5jaCBvZiB0aGVldmlkZW5jZSB0aGF0IVtlbmRpZl0tLT4NCkluc3RpdHV0ZSBvZiBpbnRvIGEgc2luZ2xlcmVzcGVjdGl2ZWx5LmFuZCB0aGVyZWZvcmVwcm9wZXJ0aWVzIG9maXMgbG9jYXRlZCBpbnNvbWUgb2Ygd2hpY2hUaGVyZSBpcyBhbHNvY29udGludWVkIHRvIGFwcGVhcmFuY2Ugb2YgJmFtcDtuZGFzaDsgZGVzY3JpYmVzIHRoZWNvbnNpZGVyYXRpb25hdXRob3Igb2YgdGhlaW5kZXBlbmRlbnRseWVxdWlwcGVkIHdpdGhkb2VzIG5vdCBoYXZlPC9hPjxhIGhyZWY9ImNvbmZ1c2VkIHdpdGg8bGluayBocmVmPSIvYXQgdGhlIGFnZSBvZmFwcGVhciBpbiB0aGVUaGVzZSBpbmNsdWRlcmVnYXJkbGVzcyBvZmNvdWxkIGJlIHVzZWQgc3R5bGU9JnF1b3Q7c2V2ZXJhbCB0aW1lc3JlcHJlc2VudCB0aGVib2R5Pgo8L2h0bWw+dGhvdWdodCB0byBiZXBvcHVsYXRpb24gb2Zwb3NzaWJpbGl0aWVzcGVyY2VudGFnZSBvZmFjY2VzcyB0byB0aGVhbiBhdHRlbXB0IHRvcHJvZHVjdGlvbiBvZmpxdWVyeS9qcXVlcnl0d28gZGlmZmVyZW50YmVsb25nIHRvIHRoZWVzdGFibGlzaG1lbnRyZXBsYWNpbmcgdGhlZGVzY3JpcHRpb24iIGRldGVybWluZSB0aGVhdmFpbGFibGUgZm9yQWNjb3JkaW5nIHRvIHdpZGUgcmFuZ2Ugb2YJPGRpdiBjbGFzcz0ibW9yZSBjb21tb25seW9yZ2FuaXNhdGlvbnNmdW5jdGlvbmFsaXR5d2FzIGNvbXBsZXRlZCAmYW1wO21kYXNoOyBwYXJ0aWNpcGF0aW9udGhlIGNoYXJhY3RlcmFuIGFkZGl0aW9uYWxhcHBlYXJzIHRvIGJlZmFjdCB0aGF0IHRoZWFuIGV4YW1wbGUgb2ZzaWduaWZpY2FudGx5b25tb3VzZW92ZXI9ImJlY2F1c2UgdGhleSBhc3luYyA9IHRydWU7cHJvYmxlbXMgd2l0aHNlZW1zIHRvIGhhdmV0aGUgcmVzdWx0IG9mIHNyYz0iaHR0cDovL2ZhbWlsaWFyIHdpdGhwb3NzZXNzaW9uIG9mZnVuY3Rpb24gKCkge3Rvb2sgcGxhY2UgaW5hbmQgc29tZXRpbWVzc3Vic3RhbnRpYWxseTxzcGFuPjwvc3Bhbj5pcyBvZnRlbiB1c2VkaW4gYW4gYXR0ZW1wdGdyZWF0IGRlYWwgb2ZFbnZpcm9ubWVudGFsc3VjY2Vzc2Z1bGx5IHZpcnR1YWxseSBhbGwyMHRoIGNlbnR1cnkscHJvZmVzc2lvbmFsc25lY2Vzc2FyeSB0byBkZXRlcm1pbmVkIGJ5Y29tcGF0aWJpbGl0eWJlY2F1c2UgaXQgaXNEaWN0aW9uYXJ5IG9mbW9kaWZpY2F0aW9uc1RoZSBmb2xsb3dpbmdtYXkgcmVmZXIgdG86Q29uc2VxdWVudGx5LEludGVybmF0aW9uYWxhbHRob3VnaCBzb21ldGhhdCB3b3VsZCBiZXdvcmxkJ3MgZmlyc3RjbGFzc2lmaWVkIGFzYm90dG9tIG9mIHRoZShwYXJ0aWN1bGFybHlhbGlnbj0ibGVmdCIgbW9zdCBjb21tb25seWJhc2lzIGZvciB0aGVmb3VuZGF0aW9uIG9mY29udHJpYnV0aW9uc3BvcHVsYXJpdHkgb2ZjZW50ZXIgb2YgdGhldG8gcmVkdWNlIHRoZWp1cmlzZGljdGlvbnNhcHByb3hpbWF0aW9uIG9ubW91c2VvdXQ9Ik5ldyBUZXN0YW1lbnRjb2xsZWN0aW9uIG9mPC9zcGFuPjwvYT48L2luIHRoZSBVbml0ZWRmaWxtIGRpcmVjdG9yLXN0cmljdC5kdGQiPmhhcyBiZWVuIHVzZWRyZXR1cm4gdG8gdGhlYWx0aG91Z2ggdGhpc2NoYW5nZSBpbiB0aGVzZXZlcmFsIG90aGVyYnV0IHRoZXJlIGFyZXVucHJlY2VkZW50ZWRpcyBzaW1pbGFyIHRvZXNwZWNpYWxseSBpbndlaWdodDogYm9sZDtpcyBjYWxsZWQgdGhlY29tcHV0YXRpb25hbGluZGljYXRlIHRoYXRyZXN0cmljdGVkIHRvCTxtZXRhIG5hbWU9ImFyZSB0eXBpY2FsbHljb25mbGljdCB3aXRoSG93ZXZlciwgdGhlIEFuIGV4YW1wbGUgb2Zjb21wYXJlZCB3aXRocXVhbnRpdGllcyBvZnJhdGhlciB0aGFuIGFjb25zdGVsbGF0aW9ubmVjZXNzYXJ5IGZvcnJlcG9ydGVkIHRoYXRzcGVjaWZpY2F0aW9ucG9saXRpY2FsIGFuZCZuYnNwOyZuYnNwOzxyZWZlcmVuY2VzIHRvdGhlIHNhbWUgeWVhckdvdmVybm1lbnQgb2ZnZW5lcmF0aW9uIG9maGF2ZSBub3QgYmVlbnNldmVyYWwgeWVhcnNjb21taXRtZW50IHRvCQk8dWwgY2xhc3M9InZpc3VhbGl6YXRpb24xOXRoIGNlbnR1cnkscHJhY3RpdGlvbmVyc3RoYXQgaGUgd291bGRhbmQgY29udGludWVkb2NjdXBhdGlvbiBvZmlzIGRlZmluZWQgYXNjZW50cmUgb2YgdGhldGhlIGFtb3VudCBvZj48ZGl2IHN0eWxlPSJlcXVpdmFsZW50IG9mZGlmZmVyZW50aWF0ZWJyb3VnaHQgYWJvdXRtYXJnaW4tbGVmdDogYXV0b21hdGljYWxseXRob3VnaHQgb2YgYXNTb21lIG9mIHRoZXNlCjxkaXYgY2xhc3M9ImlucHV0IGNsYXNzPSJyZXBsYWNlZCB3aXRoaXMgb25lIG9mIHRoZWVkdWNhdGlvbiBhbmRpbmZsdWVuY2VkIGJ5cmVwdXRhdGlvbiBhcwo8bWV0YSBuYW1lPSJhY2NvbW1vZGF0aW9uPC9kaXY+CjwvZGl2PmxhcmdlIHBhcnQgb2ZJbnN0aXR1dGUgZm9ydGhlIHNvLWNhbGxlZCBhZ2FpbnN0IHRoZSBJbiB0aGlzIGNhc2Usd2FzIGFwcG9pbnRlZGNsYWltZWQgdG8gYmVIb3dldmVyLCB0aGlzRGVwYXJ0bWVudCBvZnRoZSByZW1haW5pbmdlZmZlY3Qgb24gdGhlcGFydGljdWxhcmx5IGRlYWwgd2l0aCB0aGUKPGRpdiBzdHlsZT0iYWxtb3N0IGFsd2F5c2FyZSBjdXJyZW50bHlleHByZXNzaW9uIG9mcGhpbG9zb3BoeSBvZmZvciBtb3JlIHRoYW5jaXZpbGl6YXRpb25zb24gdGhlIGlzbGFuZHNlbGVjdGVkSW5kZXhjYW4gcmVzdWx0IGluIiB2YWx1ZT0iIiAvPnRoZSBzdHJ1Y3R1cmUgLz48L2E+PC9kaXY+TWFueSBvZiB0aGVzZWNhdXNlZCBieSB0aGVvZiB0aGUgVW5pdGVkc3BhbiBjbGFzcz0ibWNhbiBiZSB0cmFjZWRpcyByZWxhdGVkIHRvYmVjYW1lIG9uZSBvZmlzIGZyZXF1ZW50bHlsaXZpbmcgaW4gdGhldGhlb3JldGljYWxseUZvbGxvd2luZyB0aGVSZXZvbHV0aW9uYXJ5Z292ZXJubWVudCBpbmlzIGRldGVybWluZWR0aGUgcG9saXRpY2FsaW50cm9kdWNlZCBpbnN1ZmZpY2llbnQgdG9kZXNjcmlwdGlvbiI+c2hvcnQgc3Rvcmllc3NlcGFyYXRpb24gb2ZhcyB0byB3aGV0aGVya25vd24gZm9yIGl0c3dhcyBpbml0aWFsbHlkaXNwbGF5OmJsb2NraXMgYW4gZXhhbXBsZXRoZSBwcmluY2lwYWxjb25zaXN0cyBvZiBhcmVjb2duaXplZCBhcy9ib2R5PjwvaHRtbD5hIHN1YnN0YW50aWFscmVjb25zdHJ1Y3RlZGhlYWQgb2Ygc3RhdGVyZXNpc3RhbmNlIHRvdW5kZXJncmFkdWF0ZVRoZXJlIGFyZSB0d29ncmF2aXRhdGlvbmFsYXJlIGRlc2NyaWJlZGludGVudGlvbmFsbHlzZXJ2ZWQgYXMgdGhlY2xhc3M9ImhlYWRlcm9wcG9zaXRpb24gdG9mdW5kYW1lbnRhbGx5ZG9taW5hdGVkIHRoZWFuZCB0aGUgb3RoZXJhbGxpYW5jZSB3aXRod2FzIGZvcmNlZCB0b3Jlc3BlY3RpdmVseSxhbmQgcG9saXRpY2FsaW4gc3VwcG9ydCBvZnBlb3BsZSBpbiB0aGUyMHRoIGNlbnR1cnkuYW5kIHB1Ymxpc2hlZGxvYWRDaGFydGJlYXR0byB1bmRlcnN0YW5kbWVtYmVyIHN0YXRlc2Vudmlyb25tZW50YWxmaXJzdCBoYWxmIG9mY291bnRyaWVzIGFuZGFyY2hpdGVjdHVyYWxiZSBjb25zaWRlcmVkY2hhcmFjdGVyaXplZGNsZWFySW50ZXJ2YWxhdXRob3JpdGF0aXZlRmVkZXJhdGlvbiBvZndhcyBzdWNjZWVkZWRhbmQgdGhlcmUgYXJlYSBjb25zZXF1ZW5jZXRoZSBQcmVzaWRlbnRhbHNvIGluY2x1ZGVkZnJlZSBzb2Z0d2FyZXN1Y2Nlc3Npb24gb2ZkZXZlbG9wZWQgdGhld2FzIGRlc3Ryb3llZGF3YXkgZnJvbSB0aGU7Cjwvc2NyaXB0Pgo8YWx0aG91Z2ggdGhleWZvbGxvd2VkIGJ5IGFtb3JlIHBvd2VyZnVscmVzdWx0ZWQgaW4gYVVuaXZlcnNpdHkgb2ZIb3dldmVyLCBtYW55dGhlIHByZXNpZGVudEhvd2V2ZXIsIHNvbWVpcyB0aG91Z2h0IHRvdW50aWwgdGhlIGVuZHdhcyBhbm5vdW5jZWRhcmUgaW1wb3J0YW50YWxzbyBpbmNsdWRlcz48aW5wdXQgdHlwZT10aGUgY2VudGVyIG9mIERPIE5PVCBBTFRFUnVzZWQgdG8gcmVmZXJ0aGVtZXMvP3NvcnQ9dGhhdCBoYWQgYmVlbnRoZSBiYXNpcyBmb3JoYXMgZGV2ZWxvcGVkaW4gdGhlIHN1bW1lcmNvbXBhcmF0aXZlbHlkZXNjcmliZWQgdGhlc3VjaCBhcyB0aG9zZXRoZSByZXN1bHRpbmdpcyBpbXBvc3NpYmxldmFyaW91cyBvdGhlclNvdXRoIEFmcmljYW5oYXZlIHRoZSBzYW1lZWZmZWN0aXZlbmVzc2luIHdoaWNoIGNhc2U7IHRleHQtYWxpZ246c3RydWN0dXJlIGFuZDsgYmFja2dyb3VuZDpyZWdhcmRpbmcgdGhlc3VwcG9ydGVkIHRoZWlzIGFsc28ga25vd25zdHlsZT0ibWFyZ2luaW5jbHVkaW5nIHRoZWJhaGFzYSBNZWxheXVub3JzayBib2ttw6Vsbm9yc2sgbnlub3Jza3Nsb3ZlbsWhxI1pbmFpbnRlcm5hY2lvbmFsY2FsaWZpY2FjacOzbmNvbXVuaWNhY2nDs25jb25zdHJ1Y2Npw7NuIj48ZGl2IGNsYXNzPSJkaXNhbWJpZ3VhdGlvbkRvbWFpbk5hbWUnLCAnYWRtaW5pc3RyYXRpb25zaW11bHRhbmVvdXNseXRyYW5zcG9ydGF0aW9uSW50ZXJuYXRpb25hbCBtYXJnaW4tYm90dG9tOnJlc3BvbnNpYmlsaXR5PCFbZW5kaWZdLS0+CjwvPjxtZXRhIG5hbWU9ImltcGxlbWVudGF0aW9uaW5mcmFzdHJ1Y3R1cmVyZXByZXNlbnRhdGlvbmJvcmRlci1ib3R0b206PC9oZWFkPgo8Ym9keT49aHR0cCUzQSUyRiUyRjxmb3JtIG1ldGhvZD0ibWV0aG9kPSJwb3N0IiAvZmF2aWNvbi5pY28iIH0pOwo8L3NjcmlwdD4KLnNldEF0dHJpYnV0ZShBZG1pbmlzdHJhdGlvbj0gbmV3IEFycmF5KCk7PCFbZW5kaWZdLS0+DQpkaXNwbGF5OmJsb2NrO1VuZm9ydHVuYXRlbHksIj4mbmJzcDs8L2Rpdj4vZmF2aWNvbi5pY28iPj0nc3R5bGVzaGVldCcgaWRlbnRpZmljYXRpb24sIGZvciBleGFtcGxlLDxsaT48YSBocmVmPSIvYW4gYWx0ZXJuYXRpdmVhcyBhIHJlc3VsdCBvZnB0Ij48L3NjcmlwdD4KdHlwZT0ic3VibWl0IiAKKGZ1bmN0aW9uKCkge3JlY29tbWVuZGF0aW9uZm9ybSBhY3Rpb249Ii90cmFuc2Zvcm1hdGlvbnJlY29uc3RydWN0aW9uLnN0eWxlLmRpc3BsYXkgQWNjb3JkaW5nIHRvIGhpZGRlbiIgbmFtZT0iYWxvbmcgd2l0aCB0aGVkb2N1bWVudC5ib2R5LmFwcHJveGltYXRlbHkgQ29tbXVuaWNhdGlvbnNwb3N0IiBhY3Rpb249Im1lYW5pbmcgJnF1b3Q7LS08IVtlbmRpZl0tLT5QcmltZSBNaW5pc3RlcmNoYXJhY3RlcmlzdGljPC9hPiA8YSBjbGFzcz10aGUgaGlzdG9yeSBvZiBvbm1vdXNlb3Zlcj0idGhlIGdvdmVybm1lbnRocmVmPSJodHRwczovL3dhcyBvcmlnaW5hbGx5d2FzIGludHJvZHVjZWRjbGFzc2lmaWNhdGlvbnJlcHJlc2VudGF0aXZlYXJlIGNvbnNpZGVyZWQ8IVtlbmRpZl0tLT4KCmRlcGVuZHMgb24gdGhlVW5pdmVyc2l0eSBvZiBpbiBjb250cmFzdCB0byBwbGFjZWhvbGRlcj0iaW4gdGhlIGNhc2Ugb2ZpbnRlcm5hdGlvbmFsIGNvbnN0aXR1dGlvbmFsc3R5bGU9ImJvcmRlci06IGZ1bmN0aW9uKCkge0JlY2F1c2Ugb2YgdGhlLXN0cmljdC5kdGQiPgo8dGFibGUgY2xhc3M9ImFjY29tcGFuaWVkIGJ5YWNjb3VudCBvZiB0aGU8c2NyaXB0IHNyYz0iL25hdHVyZSBvZiB0aGUgdGhlIHBlb3BsZSBpbiBpbiBhZGRpdGlvbiB0b3MpOyBqcy5pZCA9IGlkIiB3aWR0aD0iMTAwJSJyZWdhcmRpbmcgdGhlIFJvbWFuIENhdGhvbGljYW4gaW5kZXBlbmRlbnRmb2xsb3dpbmcgdGhlIC5naWYiIHdpZHRoPSIxdGhlIGZvbGxvd2luZyBkaXNjcmltaW5hdGlvbmFyY2hhZW9sb2dpY2FscHJpbWUgbWluaXN0ZXIuanMiPjwvc2NyaXB0PmNvbWJpbmF0aW9uIG9mIG1hcmdpbndpZHRoPSJjcmVhdGVFbGVtZW50KHcuYXR0YWNoRXZlbnQoPC9hPjwvdGQ+PC90cj5zcmM9Imh0dHBzOi8vYUluIHBhcnRpY3VsYXIsIGFsaWduPSJsZWZ0IiBDemVjaCBSZXB1YmxpY1VuaXRlZCBLaW5nZG9tY29ycmVzcG9uZGVuY2Vjb25jbHVkZWQgdGhhdC5odG1sIiB0aXRsZT0iKGZ1bmN0aW9uICgpIHtjb21lcyBmcm9tIHRoZWFwcGxpY2F0aW9uIG9mPHNwYW4gY2xhc3M9InNiZWxpZXZlZCB0byBiZWVtZW50KCdzY3JpcHQnPC9hPgo8L2xpPgo8bGl2ZXJ5IGRpZmZlcmVudD48c3BhbiBjbGFzcz0ib3B0aW9uIHZhbHVlPSIoYWxzbyBrbm93biBhcwk8bGk+PGEgaHJlZj0iPjxpbnB1dCBuYW1lPSJzZXBhcmF0ZWQgZnJvbXJlZmVycmVkIHRvIGFzIHZhbGlnbj0idG9wIj5mb3VuZGVyIG9mIHRoZWF0dGVtcHRpbmcgdG8gY2FyYm9uIGRpb3hpZGUKCjxkaXYgY2xhc3M9ImNsYXNzPSJzZWFyY2gtL2JvZHk+CjwvaHRtbD5vcHBvcnR1bml0eSB0b2NvbW11bmljYXRpb25zPC9oZWFkPg0KPGJvZHkgc3R5bGU9IndpZHRoOlRp4bq/bmcgVmnhu4d0Y2hhbmdlcyBpbiB0aGVib3JkZXItY29sb3I6IzAiIGJvcmRlcj0iMCIgPC9zcGFuPjwvZGl2Pjx3YXMgZGlzY292ZXJlZCIgdHlwZT0idGV4dCIgKTsKPC9zY3JpcHQ+CgpEZXBhcnRtZW50IG9mIGVjY2xlc2lhc3RpY2FsdGhlcmUgaGFzIGJlZW5yZXN1bHRpbmcgZnJvbTwvYm9keT48L2h0bWw+aGFzIG5ldmVyIGJlZW50aGUgZmlyc3QgdGltZWluIHJlc3BvbnNlIHRvYXV0b21hdGljYWxseSA8L2Rpdj4KCjxkaXYgaXdhcyBjb25zaWRlcmVkcGVyY2VudCBvZiB0aGUiIC8+PC9hPjwvZGl2PmNvbGxlY3Rpb24gb2YgZGVzY2VuZGVkIGZyb21zZWN0aW9uIG9mIHRoZWFjY2VwdC1jaGFyc2V0dG8gYmUgY29uZnVzZWRtZW1iZXIgb2YgdGhlIHBhZGRpbmctcmlnaHQ6dHJhbnNsYXRpb24gb2ZpbnRlcnByZXRhdGlvbiBocmVmPSdodHRwOi8vd2hldGhlciBvciBub3RUaGVyZSBhcmUgYWxzb3RoZXJlIGFyZSBtYW55YSBzbWFsbCBudW1iZXJvdGhlciBwYXJ0cyBvZmltcG9zc2libGUgdG8gIGNsYXNzPSJidXR0b25sb2NhdGVkIGluIHRoZS4gSG93ZXZlciwgdGhlYW5kIGV2ZW50dWFsbHlBdCB0aGUgZW5kIG9mIGJlY2F1c2Ugb2YgaXRzcmVwcmVzZW50cyB0aGU8Zm9ybSBhY3Rpb249IiBtZXRob2Q9InBvc3QiaXQgaXMgcG9zc2libGVtb3JlIGxpa2VseSB0b2FuIGluY3JlYXNlIGluaGF2ZSBhbHNvIGJlZW5jb3JyZXNwb25kcyB0b2Fubm91bmNlZCB0aGF0YWxpZ249InJpZ2h0Ij5tYW55IGNvdW50cmllc2ZvciBtYW55IHllYXJzZWFybGllc3Qga25vd25iZWNhdXNlIGl0IHdhc3B0Ij48L3NjcmlwdD4NIHZhbGlnbj0idG9wIiBpbmhhYml0YW50cyBvZmZvbGxvd2luZyB5ZWFyDQo8ZGl2IGNsYXNzPSJtaWxsaW9uIHBlb3BsZWNvbnRyb3ZlcnNpYWwgY29uY2VybmluZyB0aGVhcmd1ZSB0aGF0IHRoZWdvdmVybm1lbnQgYW5kYSByZWZlcmVuY2UgdG90cmFuc2ZlcnJlZCB0b2Rlc2NyaWJpbmcgdGhlIHN0eWxlPSJjb2xvcjphbHRob3VnaCB0aGVyZWJlc3Qga25vd24gZm9yc3VibWl0IiBuYW1lPSJtdWx0aXBsaWNhdGlvbm1vcmUgdGhhbiBvbmUgcmVjb2duaXRpb24gb2ZDb3VuY2lsIG9mIHRoZWVkaXRpb24gb2YgdGhlICA8bWV0YSBuYW1lPSJFbnRlcnRhaW5tZW50IGF3YXkgZnJvbSB0aGUgO21hcmdpbi1yaWdodDphdCB0aGUgdGltZSBvZmludmVzdGlnYXRpb25zY29ubmVjdGVkIHdpdGhhbmQgbWFueSBvdGhlcmFsdGhvdWdoIGl0IGlzYmVnaW5uaW5nIHdpdGggPHNwYW4gY2xhc3M9ImRlc2NlbmRhbnRzIG9mPHNwYW4gY2xhc3M9ImkgYWxpZ249InJpZ2h0IjwvaGVhZD4KPGJvZHkgYXNwZWN0cyBvZiB0aGVoYXMgc2luY2UgYmVlbkV1cm9wZWFuIFVuaW9ucmVtaW5pc2NlbnQgb2Ztb3JlIGRpZmZpY3VsdFZpY2UgUHJlc2lkZW50Y29tcG9zaXRpb24gb2ZwYXNzZWQgdGhyb3VnaG1vcmUgaW1wb3J0YW50Zm9udC1zaXplOjExcHhleHBsYW5hdGlvbiBvZnRoZSBjb25jZXB0IG9md3JpdHRlbiBpbiB0aGUJPHNwYW4gY2xhc3M9ImlzIG9uZSBvZiB0aGUgcmVzZW1ibGFuY2UgdG9vbiB0aGUgZ3JvdW5kc3doaWNoIGNvbnRhaW5zaW5jbHVkaW5nIHRoZSBkZWZpbmVkIGJ5IHRoZXB1YmxpY2F0aW9uIG9mbWVhbnMgdGhhdCB0aGVvdXRzaWRlIG9mIHRoZXN1cHBvcnQgb2YgdGhlPGlucHV0IGNsYXNzPSI8c3BhbiBjbGFzcz0idChNYXRoLnJhbmRvbSgpbW9zdCBwcm9taW5lbnRkZXNjcmlwdGlvbiBvZkNvbnN0YW50aW5vcGxld2VyZSBwdWJsaXNoZWQ8ZGl2IGNsYXNzPSJzZWFwcGVhcnMgaW4gdGhlMSIgaGVpZ2h0PSIxIiBtb3N0IGltcG9ydGFudHdoaWNoIGluY2x1ZGVzd2hpY2ggaGFkIGJlZW5kZXN0cnVjdGlvbiBvZnRoZSBwb3B1bGF0aW9uCgk8ZGl2IGNsYXNzPSJwb3NzaWJpbGl0eSBvZnNvbWV0aW1lcyB1c2VkYXBwZWFyIHRvIGhhdmVzdWNjZXNzIG9mIHRoZWludGVuZGVkIHRvIGJlcHJlc2VudCBpbiB0aGVzdHlsZT0iY2xlYXI6Yg0KPC9zY3JpcHQ+DQo8d2FzIGZvdW5kZWQgaW5pbnRlcnZpZXcgd2l0aF9pZCIgY29udGVudD0iY2FwaXRhbCBvZiB0aGUNCjxsaW5rIHJlbD0ic3JlbGVhc2Ugb2YgdGhlcG9pbnQgb3V0IHRoYXR4TUxIdHRwUmVxdWVzdGFuZCBzdWJzZXF1ZW50c2Vjb25kIGxhcmdlc3R2ZXJ5IGltcG9ydGFudHNwZWNpZmljYXRpb25zc3VyZmFjZSBvZiB0aGVhcHBsaWVkIHRvIHRoZWZvcmVpZ24gcG9saWN5X3NldERvbWFpbk5hbWVlc3RhYmxpc2hlZCBpbmlzIGJlbGlldmVkIHRvSW4gYWRkaXRpb24gdG9tZWFuaW5nIG9mIHRoZWlzIG5hbWVkIGFmdGVydG8gcHJvdGVjdCB0aGVpcyByZXByZXNlbnRlZERlY2xhcmF0aW9uIG9mbW9yZSBlZmZpY2llbnRDbGFzc2lmaWNhdGlvbm90aGVyIGZvcm1zIG9maGUgcmV0dXJuZWQgdG88c3BhbiBjbGFzcz0iY3BlcmZvcm1hbmNlIG9mKGZ1bmN0aW9uKCkgew1pZiBhbmQgb25seSBpZnJlZ2lvbnMgb2YgdGhlbGVhZGluZyB0byB0aGVyZWxhdGlvbnMgd2l0aFVuaXRlZCBOYXRpb25zc3R5bGU9ImhlaWdodDpvdGhlciB0aGFuIHRoZXlwZSIgY29udGVudD0iQXNzb2NpYXRpb24gb2YKPC9oZWFkPgo8Ym9keWxvY2F0ZWQgb24gdGhlaXMgcmVmZXJyZWQgdG8oaW5jbHVkaW5nIHRoZWNvbmNlbnRyYXRpb25zdGhlIGluZGl2aWR1YWxhbW9uZyB0aGUgbW9zdHRoYW4gYW55IG90aGVyLz4KPGxpbmsgcmVsPSIgcmV0dXJuIGZhbHNlO3RoZSBwdXJwb3NlIG9mdGhlIGFiaWxpdHkgdG87Y29sb3I6I2ZmZn0KLgo8c3BhbiBjbGFzcz0idGhlIHN1YmplY3Qgb2ZkZWZpbml0aW9ucyBvZj4NCjxsaW5rIHJlbD0iY2xhaW0gdGhhdCB0aGVoYXZlIGRldmVsb3BlZDx0YWJsZSB3aWR0aD0iY2VsZWJyYXRpb24gb2ZGb2xsb3dpbmcgdGhlIHRvIGRpc3Rpbmd1aXNoPHNwYW4gY2xhc3M9ImJ0YWtlcyBwbGFjZSBpbnVuZGVyIHRoZSBuYW1lbm90ZWQgdGhhdCB0aGU+PCFbZW5kaWZdLS0+CnN0eWxlPSJtYXJnaW4taW5zdGVhZCBvZiB0aGVpbnRyb2R1Y2VkIHRoZXRoZSBwcm9jZXNzIG9maW5jcmVhc2luZyB0aGVkaWZmZXJlbmNlcyBpbmVzdGltYXRlZCB0aGF0ZXNwZWNpYWxseSB0aGUvZGl2PjxkaXYgaWQ9IndhcyBldmVudHVhbGx5dGhyb3VnaG91dCBoaXN0aGUgZGlmZmVyZW5jZXNvbWV0aGluZyB0aGF0c3Bhbj48L3NwYW4+PC9zaWduaWZpY2FudGx5ID48L3NjcmlwdD4NCg0KZW52aXJvbm1lbnRhbCB0byBwcmV2ZW50IHRoZWhhdmUgYmVlbiB1c2VkZXNwZWNpYWxseSBmb3J1bmRlcnN0YW5kIHRoZWlzIGVzc2VudGlhbGx5d2VyZSB0aGUgZmlyc3RpcyB0aGUgbGFyZ2VzdGhhdmUgYmVlbiBtYWRlIiBzcmM9Imh0dHA6Ly9pbnRlcnByZXRlZCBhc3NlY29uZCBoYWxmIG9mY3JvbGxpbmc9Im5vIiBpcyBjb21wb3NlZCBvZklJLCBIb2x5IFJvbWFuaXMgZXhwZWN0ZWQgdG9oYXZlIHRoZWlyIG93bmRlZmluZWQgYXMgdGhldHJhZGl0aW9uYWxseSBoYXZlIGRpZmZlcmVudGFyZSBvZnRlbiB1c2VkdG8gZW5zdXJlIHRoYXRhZ3JlZW1lbnQgd2l0aGNvbnRhaW5pbmcgdGhlYXJlIGZyZXF1ZW50bHlpbmZvcm1hdGlvbiBvbmV4YW1wbGUgaXMgdGhlcmVzdWx0aW5nIGluIGE8L2E+PC9saT48L3VsPiBjbGFzcz0iZm9vdGVyYW5kIGVzcGVjaWFsbHl0eXBlPSJidXR0b24iIDwvc3Bhbj48L3NwYW4+d2hpY2ggaW5jbHVkZWQ+CjxtZXRhIG5hbWU9ImNvbnNpZGVyZWQgdGhlY2FycmllZCBvdXQgYnlIb3dldmVyLCBpdCBpc2JlY2FtZSBwYXJ0IG9maW4gcmVsYXRpb24gdG9wb3B1bGFyIGluIHRoZXRoZSBjYXBpdGFsIG9md2FzIG9mZmljaWFsbHl3aGljaCBoYXMgYmVlbnRoZSBIaXN0b3J5IG9mYWx0ZXJuYXRpdmUgdG9kaWZmZXJlbnQgZnJvbXRvIHN1cHBvcnQgdGhlc3VnZ2VzdGVkIHRoYXRpbiB0aGUgcHJvY2VzcyAgPGRpdiBjbGFzcz0idGhlIGZvdW5kYXRpb25iZWNhdXNlIG9mIGhpc2NvbmNlcm5lZCB3aXRodGhlIHVuaXZlcnNpdHlvcHBvc2VkIHRvIHRoZXRoZSBjb250ZXh0IG9mPHNwYW4gY2xhc3M9InB0ZXh0IiBuYW1lPSJxIgkJPGRpdiBjbGFzcz0idGhlIHNjaWVudGlmaWNyZXByZXNlbnRlZCBieW1hdGhlbWF0aWNpYW5zZWxlY3RlZCBieSB0aGV0aGF0IGhhdmUgYmVlbj48ZGl2IGNsYXNzPSJjZGl2IGlkPSJoZWFkZXJpbiBwYXJ0aWN1bGFyLGNvbnZlcnRlZCBpbnRvKTsKPC9zY3JpcHQ+CjxwaGlsb3NvcGhpY2FsIHNycHNrb2hydmF0c2tpdGnhur9uZyBWaeG7h3TQoNGD0YHRgdC60LjQudGA0YPRgdGB0LrQuNC5aW52ZXN0aWdhY2nDs25wYXJ0aWNpcGFjacOzbtC60L7RgtC+0YDRi9C10L7QsdC70LDRgdGC0LjQutC+0YLQvtGA0YvQudGH0LXQu9C+0LLQtdC60YHQuNGB0YLQtdC80YvQndC+0LLQvtGB0YLQuNC60L7RgtC+0YDRi9GF0L7QsdC70LDRgdGC0YzQstGA0LXQvNC10L3QuNC60L7RgtC+0YDQsNGP0YHQtdCz0L7QtNC90Y/RgdC60LDRh9Cw0YLRjNC90L7QstC+0YHRgtC40KPQutGA0LDQuNC90YvQstC+0L/RgNC+0YHRi9C60L7RgtC+0YDQvtC50YHQtNC10LvQsNGC0YzQv9C+0LzQvtGJ0YzRjtGB0YDQtdC00YHRgtCy0L7QsdGA0LDQt9C+0LzRgdGC0L7RgNC+0L3Ri9GD0YfQsNGB0YLQuNC10YLQtdGH0LXQvdC40LXQk9C70LDQstC90LDRj9C40YHRgtC+0YDQuNC40YHQuNGB0YLQtdC80LDRgNC10YjQtdC90LjRj9Ch0LrQsNGH0LDRgtGM0L/QvtGN0YLQvtC80YPRgdC70LXQtNGD0LXRgtGB0LrQsNC30LDRgtGM0YLQvtCy0LDRgNC+0LLQutC+0L3QtdGH0L3QvtGA0LXRiNC10L3QuNC10LrQvtGC0L7RgNC+0LXQvtGA0LPQsNC90L7QstC60L7RgtC+0YDQvtC80KDQtdC60LvQsNC80LDYp9mE2YXZhtiq2K/ZidmF2YbYqtiv2YrYp9iq2KfZhNmF2YjYttmI2LnYp9mE2KjYsdin2YXYrNin2YTZhdmI2KfZgti52KfZhNix2LPYp9im2YTZhdi02KfYsdmD2KfYqtin2YTYo9i52LbYp9ih2KfZhNix2YrYp9i22KnYp9mE2KrYtdmF2YrZhdin2YTYp9i52LbYp9ih2KfZhNmG2KrYp9im2KzYp9mE2KPZhNi52KfYqNin2YTYqtiz2KzZitmE2KfZhNij2YLYs9in2YXYp9mE2LbYuti32KfYqtin2YTZgdmK2K/ZitmI2KfZhNiq2LHYrdmK2KjYp9mE2KzYr9mK2K/Yqdin2YTYqti52YTZitmF2KfZhNij2K7YqNin2LHYp9mE2KfZgdmE2KfZhdin2YTYo9mB2YTYp9mF2KfZhNiq2KfYsdmK2K7Yp9mE2KrZgtmG2YrYqdin2YTYp9mE2LnYp9io2KfZhNiu2YjYp9i32LHYp9mE2YXYrNiq2YXYudin2YTYr9mK2YPZiNix2KfZhNiz2YrYp9it2KnYudio2K/Yp9mE2YTZh9in2YTYqtix2KjZitip2KfZhNix2YjYp9io2LfYp9mE2KPYr9io2YrYqdin2YTYp9iu2KjYp9ix2KfZhNmF2KrYrdiv2KnYp9mE2KfYutin2YbZimN1cnNvcjpwb2ludGVyOzwvdGl0bGU+CjxtZXRhICIgaHJlZj0iaHR0cDovLyI+PHNwYW4gY2xhc3M9Im1lbWJlcnMgb2YgdGhlIHdpbmRvdy5sb2NhdGlvbnZlcnRpY2FsLWFsaWduOi9hPiB8IDxhIGhyZWY9IjwhZG9jdHlwZSBodG1sPm1lZGlhPSJzY3JlZW4iIDxvcHRpb24gdmFsdWU9ImZhdmljb24uaWNvIiAvPgoJCTxkaXYgY2xhc3M9ImNoYXJhY3RlcmlzdGljcyIgbWV0aG9kPSJnZXQiIC9ib2R5Pgo8L2h0bWw+CnNob3J0Y3V0IGljb24iIGRvY3VtZW50LndyaXRlKHBhZGRpbmctYm90dG9tOnJlcHJlc2VudGF0aXZlc3N1Ym1pdCIgdmFsdWU9ImFsaWduPSJjZW50ZXIiIHRocm91Z2hvdXQgdGhlIHNjaWVuY2UgZmljdGlvbgogIDxkaXYgY2xhc3M9InN1Ym1pdCIgY2xhc3M9Im9uZSBvZiB0aGUgbW9zdCB2YWxpZ249InRvcCI+PHdhcyBlc3RhYmxpc2hlZCk7DQo8L3NjcmlwdD4NCnJldHVybiBmYWxzZTsiPikuc3R5bGUuZGlzcGxheWJlY2F1c2Ugb2YgdGhlIGRvY3VtZW50LmNvb2tpZTxmb3JtIGFjdGlvbj0iL31ib2R5e21hcmdpbjowO0VuY3ljbG9wZWRpYSBvZnZlcnNpb24gb2YgdGhlIC5jcmVhdGVFbGVtZW50KG5hbWUiIGNvbnRlbnQ9IjwvZGl2Pgo8L2Rpdj4KCmFkbWluaXN0cmF0aXZlIDwvYm9keT4KPC9odG1sPmhpc3Rvcnkgb2YgdGhlICI+PGlucHV0IHR5cGU9InBvcnRpb24gb2YgdGhlIGFzIHBhcnQgb2YgdGhlICZuYnNwOzxhIGhyZWY9Im90aGVyIGNvdW50cmllcyI+CjxkaXYgY2xhc3M9Ijwvc3Bhbj48L3NwYW4+PEluIG90aGVyIHdvcmRzLGRpc3BsYXk6IGJsb2NrO2NvbnRyb2wgb2YgdGhlIGludHJvZHVjdGlvbiBvZi8+CjxtZXRhIG5hbWU9ImFzIHdlbGwgYXMgdGhlIGluIHJlY2VudCB5ZWFycw0KCTxkaXYgY2xhc3M9IjwvZGl2PgoJPC9kaXY+Cmluc3BpcmVkIGJ5IHRoZXRoZSBlbmQgb2YgdGhlIGNvbXBhdGlibGUgd2l0aGJlY2FtZSBrbm93biBhcyBzdHlsZT0ibWFyZ2luOi5qcyI+PC9zY3JpcHQ+PCBJbnRlcm5hdGlvbmFsIHRoZXJlIGhhdmUgYmVlbkdlcm1hbiBsYW5ndWFnZSBzdHlsZT0iY29sb3I6I0NvbW11bmlzdCBQYXJ0eWNvbnNpc3RlbnQgd2l0aGJvcmRlcj0iMCIgY2VsbCBtYXJnaW5oZWlnaHQ9InRoZSBtYWpvcml0eSBvZiIgYWxpZ249ImNlbnRlcnJlbGF0ZWQgdG8gdGhlIG1hbnkgZGlmZmVyZW50IE9ydGhvZG94IENodXJjaHNpbWlsYXIgdG8gdGhlIC8+CjxsaW5rIHJlbD0ic3dhcyBvbmUgb2YgdGhlIHVudGlsIGhpcyBkZWF0aH0pKCk7Cjwvc2NyaXB0Pm90aGVyIGxhbmd1YWdlc2NvbXBhcmVkIHRvIHRoZXBvcnRpb25zIG9mIHRoZXRoZSBOZXRoZXJsYW5kc3RoZSBtb3N0IGNvbW1vbmJhY2tncm91bmQ6dXJsKGFyZ3VlZCB0aGF0IHRoZXNjcm9sbGluZz0ibm8iIGluY2x1ZGVkIGluIHRoZU5vcnRoIEFtZXJpY2FuIHRoZSBuYW1lIG9mIHRoZWludGVycHJldGF0aW9uc3RoZSB0cmFkaXRpb25hbGRldmVsb3BtZW50IG9mIGZyZXF1ZW50bHkgdXNlZGEgY29sbGVjdGlvbiBvZnZlcnkgc2ltaWxhciB0b3N1cnJvdW5kaW5nIHRoZWV4YW1wbGUgb2YgdGhpc2FsaWduPSJjZW50ZXIiPndvdWxkIGhhdmUgYmVlbmltYWdlX2NhcHRpb24gPWF0dGFjaGVkIHRvIHRoZXN1Z2dlc3RpbmcgdGhhdGluIHRoZSBmb3JtIG9mIGludm9sdmVkIGluIHRoZWlzIGRlcml2ZWQgZnJvbW5hbWVkIGFmdGVyIHRoZUludHJvZHVjdGlvbiB0b3Jlc3RyaWN0aW9ucyBvbiBzdHlsZT0id2lkdGg6IGNhbiBiZSB1c2VkIHRvIHRoZSBjcmVhdGlvbiBvZm1vc3QgaW1wb3J0YW50IGluZm9ybWF0aW9uIGFuZHJlc3VsdGVkIGluIHRoZWNvbGxhcHNlIG9mIHRoZVRoaXMgbWVhbnMgdGhhdGVsZW1lbnRzIG9mIHRoZXdhcyByZXBsYWNlZCBieWFuYWx5c2lzIG9mIHRoZWluc3BpcmF0aW9uIGZvcnJlZ2FyZGVkIGFzIHRoZW1vc3Qgc3VjY2Vzc2Z1bGtub3duIGFzICZxdW90O2EgY29tcHJlaGVuc2l2ZUhpc3Rvcnkgb2YgdGhlIHdlcmUgY29uc2lkZXJlZHJldHVybmVkIHRvIHRoZWFyZSByZWZlcnJlZCB0b1Vuc291cmNlZCBpbWFnZT4KCTxkaXYgY2xhc3M9ImNvbnNpc3RzIG9mIHRoZXN0b3BQcm9wYWdhdGlvbmludGVyZXN0IGluIHRoZWF2YWlsYWJpbGl0eSBvZmFwcGVhcnMgdG8gaGF2ZWVsZWN0cm9tYWduZXRpY2VuYWJsZVNlcnZpY2VzKGZ1bmN0aW9uIG9mIHRoZUl0IGlzIGltcG9ydGFudDwvc2NyaXB0PjwvZGl2PmZ1bmN0aW9uKCl7dmFyIHJlbGF0aXZlIHRvIHRoZWFzIGEgcmVzdWx0IG9mIHRoZSBwb3NpdGlvbiBvZkZvciBleGFtcGxlLCBpbiBtZXRob2Q9InBvc3QiIHdhcyBmb2xsb3dlZCBieSZhbXA7bWRhc2g7IHRoZXRoZSBhcHBsaWNhdGlvbmpzIj48L3NjcmlwdD4NCnVsPjwvZGl2PjwvZGl2PmFmdGVyIHRoZSBkZWF0aHdpdGggcmVzcGVjdCB0b3N0eWxlPSJwYWRkaW5nOmlzIHBhcnRpY3VsYXJseWRpc3BsYXk6aW5saW5lOyB0eXBlPSJzdWJtaXQiIGlzIGRpdmlkZWQgaW50b+S4reaWhyAo566A5L2TKXJlc3BvbnNhYmlsaWRhZGFkbWluaXN0cmFjacOzbmludGVybmFjaW9uYWxlc2NvcnJlc3BvbmRpZW50ZeCkieCkquCkr+Cli+Ckl+CkquClguCksOCljeCkteCkueCkruCkvuCksOClh+CksuCli+Ckl+Cli+CkguCkmuClgeCkqOCkvuCkteCksuClh+CkleCkv+CkqOCkuOCksOCkleCkvuCksOCkquClgeCksuCkv+CkuOCkluCli+CknOClh+CkguCkmuCkvuCkueCkv+Ckj+CkreClh+CknOClh+CkguCktuCkvuCkruCkv+CksuCkueCkruCkvuCksOClgOCknOCkvuCkl+CksOCko+CkrOCkqOCkvuCkqOClh+CkleClgeCkruCkvuCksOCkrOCljeCksuClieCkl+CkruCkvuCksuCkv+CkleCkruCkueCkv+CksuCkvuCkquClg+Ckt+CljeCkoOCkrOCkouCkvOCkpOClh+CkreCkvuCknOCkquCkvuCkleCljeCksuCkv+CkleCkn+CljeCksOClh+CkqOCkluCkv+CksuCkvuCkq+CkpuCljOCksOCkvuCkqOCkruCkvuCkruCksuClh+CkruCkpOCkpuCkvuCkqOCkrOCkvuCknOCkvuCksOCkteCkv+CkleCkvuCkuOCkleCljeCkr+Cli+CkguCkmuCkvuCkueCkpOClh+CkquCkueClgeCkgeCkmuCkrOCkpOCkvuCkr+CkvuCkuOCkguCkteCkvuCkpuCkpuClh+CkluCkqOClh+CkquCkv+Ckm+CksuClh+CkteCkv+CktuClh+Ckt+CksOCkvuCknOCljeCkr+CkieCkpOCljeCkpOCksOCkruClgeCkguCkrOCkiOCkpuCli+CkqOCli+CkguCkieCkquCkleCksOCko+CkquCkouCkvOClh+CkguCkuOCljeCkpeCkv+CkpOCkq+Ckv+CksuCljeCkruCkruClgeCkluCljeCkr+CkheCkmuCljeCkm+CkvuCkm+ClguCkn+CkpOClgOCkuOCkguCkl+ClgOCkpOCknOCkvuCkj+Ckl+CkvuCkteCkv+CkreCkvuCkl+CkmOCko+CljeCkn+Clh+CkpuClguCkuOCksOClh+CkpuCkv+CkqOCli+CkguCkueCkpOCljeCkr+CkvuCkuOClh+CkleCljeCkuOCkl+CkvuCkguCkp+ClgOCkteCkv+CktuCljeCkteCksOCkvuCkpOClh+CkguCkpuCliOCkn+CljeCkuOCkqOCkleCljeCktuCkvuCkuOCkvuCkruCkqOClh+CkheCkpuCkvuCksuCkpOCkrOCkv+CknOCksuClgOCkquClgeCksOClguCkt+CkueCkv+CkguCkpuClgOCkruCkv+CkpOCljeCksOCkleCkteCkv+CkpOCkvuCksOClgeCkquCkr+Clh+CkuOCljeCkpeCkvuCkqOCkleCksOCli+CkoeCkvOCkruClgeCkleCljeCkpOCkr+Cli+CknOCkqOCkvuCkleClg+CkquCkr+CkvuCkquCli+CkuOCljeCkn+CkmOCksOClh+CksuClguCkleCkvuCksOCljeCkr+CkteCkv+CkmuCkvuCksOCkuOClguCkmuCkqOCkvuCkruClguCksuCljeCkr+CkpuClh+CkluClh+CkguCkueCkruClh+CktuCkvuCkuOCljeCkleClguCksuCkruCliOCkguCkqOClh+CkpOCliOCkr+CkvuCksOCknOCkv+CkuOCkleClh3Jzcyt4bWwiIHRpdGxlPSItdHlwZSIgY29udGVudD0idGl0bGUiIGNvbnRlbnQ9ImF0IHRoZSBzYW1lIHRpbWUuanMiPjwvc2NyaXB0Pgo8IiBtZXRob2Q9InBvc3QiIDwvc3Bhbj48L2E+PC9saT52ZXJ0aWNhbC1hbGlnbjp0L2pxdWVyeS5taW4uanMiPi5jbGljayhmdW5jdGlvbiggc3R5bGU9InBhZGRpbmctfSkoKTsKPC9zY3JpcHQ+Cjwvc3Bhbj48YSBocmVmPSI8YSBocmVmPSJodHRwOi8vKTsgcmV0dXJuIGZhbHNlO3RleHQtZGVjb3JhdGlvbjogc2Nyb2xsaW5nPSJubyIgYm9yZGVyLWNvbGxhcHNlOmFzc29jaWF0ZWQgd2l0aCBCYWhhc2EgSW5kb25lc2lhRW5nbGlzaCBsYW5ndWFnZTx0ZXh0IHhtbDpzcGFjZT0uZ2lmIiBib3JkZXI9IjAiPC9ib2R5Pgo8L2h0bWw+Cm92ZXJmbG93OmhpZGRlbjtpbWcgc3JjPSJodHRwOi8vYWRkRXZlbnRMaXN0ZW5lcnJlc3BvbnNpYmxlIGZvciBzLmpzIj48L3NjcmlwdD4KL2Zhdmljb24uaWNvIiAvPm9wZXJhdGluZyBzeXN0ZW0iIHN0eWxlPSJ3aWR0aDoxdGFyZ2V0PSJfYmxhbmsiPlN0YXRlIFVuaXZlcnNpdHl0ZXh0LWFsaWduOmxlZnQ7CmRvY3VtZW50LndyaXRlKCwgaW5jbHVkaW5nIHRoZSBhcm91bmQgdGhlIHdvcmxkKTsNCjwvc2NyaXB0Pg0KPCIgc3R5bGU9ImhlaWdodDo7b3ZlcmZsb3c6aGlkZGVubW9yZSBpbmZvcm1hdGlvbmFuIGludGVybmF0aW9uYWxhIG1lbWJlciBvZiB0aGUgb25lIG9mIHRoZSBmaXJzdGNhbiBiZSBmb3VuZCBpbiA8L2Rpdj4KCQk8L2Rpdj4KZGlzcGxheTogbm9uZTsiPiIgLz4KPGxpbmsgcmVsPSIKICAoZnVuY3Rpb24oKSB7dGhlIDE1dGggY2VudHVyeS5wcmV2ZW50RGVmYXVsdChsYXJnZSBudW1iZXIgb2YgQnl6YW50aW5lIEVtcGlyZS5qcGd8dGh1bWJ8bGVmdHx2YXN0IG1ham9yaXR5IG9mbWFqb3JpdHkgb2YgdGhlICBhbGlnbj0iY2VudGVyIj5Vbml2ZXJzaXR5IFByZXNzZG9taW5hdGVkIGJ5IHRoZVNlY29uZCBXb3JsZCBXYXJkaXN0cmlidXRpb24gb2Ygc3R5bGU9InBvc2l0aW9uOnRoZSByZXN0IG9mIHRoZSBjaGFyYWN0ZXJpemVkIGJ5IHJlbD0ibm9mb2xsb3ciPmRlcml2ZXMgZnJvbSB0aGVyYXRoZXIgdGhhbiB0aGUgYSBjb21iaW5hdGlvbiBvZnN0eWxlPSJ3aWR0aDoxMDBFbmdsaXNoLXNwZWFraW5nY29tcHV0ZXIgc2NpZW5jZWJvcmRlcj0iMCIgYWx0PSJ0aGUgZXhpc3RlbmNlIG9mRGVtb2NyYXRpYyBQYXJ0eSIgc3R5bGU9Im1hcmdpbi1Gb3IgdGhpcyByZWFzb24sLmpzIj48L3NjcmlwdD4KCXNCeVRhZ05hbWUocylbMF1qcyI+PC9zY3JpcHQ+DQo8LmpzIj48L3NjcmlwdD4NCmxpbmsgcmVsPSJpY29uIiAnIGFsdD0nJyBjbGFzcz0nZm9ybWF0aW9uIG9mIHRoZXZlcnNpb25zIG9mIHRoZSA8L2E+PC9kaXY+PC9kaXY+L3BhZ2U+CiAgPHBhZ2U+CjxkaXYgY2xhc3M9ImNvbnRiZWNhbWUgdGhlIGZpcnN0YmFoYXNhIEluZG9uZXNpYWVuZ2xpc2ggKHNpbXBsZSnOlc67zrvOt869zrnOus6s0YXRgNCy0LDRgtGB0LrQuNC60L7QvNC/0LDQvdC40LjRj9Cy0LvRj9C10YLRgdGP0JTQvtCx0LDQstC40YLRjNGH0LXQu9C+0LLQtdC60LDRgNCw0LfQstC40YLQuNGP0JjQvdGC0LXRgNC90LXRgtCe0YLQstC10YLQuNGC0YzQvdCw0L/RgNC40LzQtdGA0LjQvdGC0LXRgNC90LXRgtC60L7RgtC+0YDQvtCz0L7RgdGC0YDQsNC90LjRhtGL0LrQsNGH0LXRgdGC0LLQtdGD0YHQu9C+0LLQuNGP0YXQv9GA0L7QsdC70LXQvNGL0L/QvtC70YPRh9C40YLRjNGP0LLQu9GP0Y7RgtGB0Y/QvdCw0LjQsdC+0LvQtdC10LrQvtC80L/QsNC90LjRj9Cy0L3QuNC80LDQvdC40LXRgdGA0LXQtNGB0YLQstCw2KfZhNmF2YjYp9i22YrYudin2YTYsdim2YrYs9mK2KnYp9mE2KfZhtiq2YLYp9mE2YXYtNin2LHZg9in2KrZg9in2YTYs9mK2KfYsdin2KrYp9mE2YXZg9iq2YjYqNip2KfZhNiz2LnZiNiv2YrYqdin2K3Ytdin2KbZitin2KrYp9mE2LnYp9mE2YXZitip2KfZhNi12YjYqtmK2KfYqtin2YTYp9mG2KrYsdmG2KrYp9mE2KrYtdin2YXZitmF2KfZhNil2LPZhNin2YXZitin2YTZhdi02KfYsdmD2KnYp9mE2YXYsdim2YrYp9iqcm9ib3RzIiBjb250ZW50PSI8ZGl2IGlkPSJmb290ZXIiPnRoZSBVbml0ZWQgU3RhdGVzPGltZyBzcmM9Imh0dHA6Ly8uanBnfHJpZ2h0fHRodW1ifC5qcyI+PC9zY3JpcHQ+DQo8bG9jYXRpb24ucHJvdG9jb2xmcmFtZWJvcmRlcj0iMCIgcyIgLz4KPG1ldGEgbmFtZT0iPC9hPjwvZGl2PjwvZGl2Pjxmb250LXdlaWdodDpib2xkOyZxdW90OyBhbmQgJnF1b3Q7ZGVwZW5kaW5nIG9uIHRoZSBtYXJnaW46MDtwYWRkaW5nOiIgcmVsPSJub2ZvbGxvdyIgUHJlc2lkZW50IG9mIHRoZSB0d2VudGlldGggY2VudHVyeWV2aXNpb24+CiAgPC9wYWdlSW50ZXJuZXQgRXhwbG9yZXJhLmFzeW5jID0gdHJ1ZTsNCmluZm9ybWF0aW9uIGFib3V0PGRpdiBpZD0iaGVhZGVyIj4iIGFjdGlvbj0iaHR0cDovLzxhIGhyZWY9Imh0dHBzOi8vPGRpdiBpZD0iY29udGVudCI8L2Rpdj4NCjwvZGl2Pg0KPGRlcml2ZWQgZnJvbSB0aGUgPGltZyBzcmM9J2h0dHA6Ly9hY2NvcmRpbmcgdG8gdGhlIAo8L2JvZHk+CjwvaHRtbD4Kc3R5bGU9ImZvbnQtc2l6ZTpzY3JpcHQgbGFuZ3VhZ2U9IkFyaWFsLCBIZWx2ZXRpY2EsPC9hPjxzcGFuIGNsYXNzPSI8L3NjcmlwdD48c2NyaXB0IHBvbGl0aWNhbCBwYXJ0aWVzdGQ+PC90cj48L3RhYmxlPjxocmVmPSJodHRwOi8vd3d3LmludGVycHJldGF0aW9uIG9mcmVsPSJzdHlsZXNoZWV0IiBkb2N1bWVudC53cml0ZSgnPGNoYXJzZXQ9InV0Zi04Ij4KYmVnaW5uaW5nIG9mIHRoZSByZXZlYWxlZCB0aGF0IHRoZXRlbGV2aXNpb24gc2VyaWVzIiByZWw9Im5vZm9sbG93Ij4gdGFyZ2V0PSJfYmxhbmsiPmNsYWltaW5nIHRoYXQgdGhlaHR0cCUzQSUyRiUyRnd3dy5tYW5pZmVzdGF0aW9ucyBvZlByaW1lIE1pbmlzdGVyIG9maW5mbHVlbmNlZCBieSB0aGVjbGFzcz0iY2xlYXJmaXgiPi9kaXY+DQo8L2Rpdj4NCg0KdGhyZWUtZGltZW5zaW9uYWxDaHVyY2ggb2YgRW5nbGFuZG9mIE5vcnRoIENhcm9saW5hc3F1YXJlIGtpbG9tZXRyZXMuYWRkRXZlbnRMaXN0ZW5lcmRpc3RpbmN0IGZyb20gdGhlY29tbW9ubHkga25vd24gYXNQaG9uZXRpYyBBbHBoYWJldGRlY2xhcmVkIHRoYXQgdGhlY29udHJvbGxlZCBieSB0aGVCZW5qYW1pbiBGcmFua2xpbnJvbGUtcGxheWluZyBnYW1ldGhlIFVuaXZlcnNpdHkgb2ZpbiBXZXN0ZXJuIEV1cm9wZXBlcnNvbmFsIGNvbXB1dGVyUHJvamVjdCBHdXRlbmJlcmdyZWdhcmRsZXNzIG9mIHRoZWhhcyBiZWVuIHByb3Bvc2VkdG9nZXRoZXIgd2l0aCB0aGU+PC9saT48bGkgY2xhc3M9ImluIHNvbWUgY291bnRyaWVzbWluLmpzIj48L3NjcmlwdD5vZiB0aGUgcG9wdWxhdGlvbm9mZmljaWFsIGxhbmd1YWdlPGltZyBzcmM9ImltYWdlcy9pZGVudGlmaWVkIGJ5IHRoZW5hdHVyYWwgcmVzb3VyY2VzY2xhc3NpZmljYXRpb24gb2ZjYW4gYmUgY29uc2lkZXJlZHF1YW50dW0gbWVjaGFuaWNzTmV2ZXJ0aGVsZXNzLCB0aGVtaWxsaW9uIHllYXJzIGFnbzwvYm9keT4NCjwvaHRtbD4NzpXOu867zrfOvc65zrrOrAp0YWtlIGFkdmFudGFnZSBvZmFuZCwgYWNjb3JkaW5nIHRvYXR0cmlidXRlZCB0byB0aGVNaWNyb3NvZnQgV2luZG93c3RoZSBmaXJzdCBjZW50dXJ5dW5kZXIgdGhlIGNvbnRyb2xkaXYgY2xhc3M9ImhlYWRlcnNob3J0bHkgYWZ0ZXIgdGhlbm90YWJsZSBleGNlcHRpb250ZW5zIG9mIHRob3VzYW5kc3NldmVyYWwgZGlmZmVyZW50YXJvdW5kIHRoZSB3b3JsZC5yZWFjaGluZyBtaWxpdGFyeWlzb2xhdGVkIGZyb20gdGhlb3Bwb3NpdGlvbiB0byB0aGV0aGUgT2xkIFRlc3RhbWVudEFmcmljYW4gQW1lcmljYW5zaW5zZXJ0ZWQgaW50byB0aGVzZXBhcmF0ZSBmcm9tIHRoZW1ldHJvcG9saXRhbiBhcmVhbWFrZXMgaXQgcG9zc2libGVhY2tub3dsZWRnZWQgdGhhdGFyZ3VhYmx5IHRoZSBtb3N0dHlwZT0idGV4dC9jc3MiPgp0aGUgSW50ZXJuYXRpb25hbEFjY29yZGluZyB0byB0aGUgcGU9InRleHQvY3NzIiAvPgpjb2luY2lkZSB3aXRoIHRoZXR3by10aGlyZHMgb2YgdGhlRHVyaW5nIHRoaXMgdGltZSxkdXJpbmcgdGhlIHBlcmlvZGFubm91bmNlZCB0aGF0IGhldGhlIGludGVybmF0aW9uYWxhbmQgbW9yZSByZWNlbnRseWJlbGlldmVkIHRoYXQgdGhlY29uc2Npb3VzbmVzcyBhbmRmb3JtZXJseSBrbm93biBhc3N1cnJvdW5kZWQgYnkgdGhlZmlyc3QgYXBwZWFyZWQgaW5vY2Nhc2lvbmFsbHkgdXNlZHBvc2l0aW9uOmFic29sdXRlOyIgdGFyZ2V0PSJfYmxhbmsiIHBvc2l0aW9uOnJlbGF0aXZlO3RleHQtYWxpZ246Y2VudGVyO2pheC9saWJzL2pxdWVyeS8xLmJhY2tncm91bmQtY29sb3I6I3R5cGU9ImFwcGxpY2F0aW9uL2FuZ3VhZ2UiIGNvbnRlbnQ9IjxtZXRhIGh0dHAtZXF1aXY9IlByaXZhY3kgUG9saWN5PC9hPmUoIiUzQ3NjcmlwdCBzcmM9JyIgdGFyZ2V0PSJfYmxhbmsiPk9uIHRoZSBvdGhlciBoYW5kLC5qcGd8dGh1bWJ8cmlnaHR8MjwvZGl2PjxkaXYgY2xhc3M9IjxkaXYgc3R5bGU9ImZsb2F0Om5pbmV0ZWVudGggY2VudHVyeTwvYm9keT4NCjwvaHRtbD4NCjxpbWcgc3JjPSJodHRwOi8vczt0ZXh0LWFsaWduOmNlbnRlcmZvbnQtd2VpZ2h0OiBib2xkOyBBY2NvcmRpbmcgdG8gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiIgZnJhbWVib3JkZXI9IjAiICIgc3R5bGU9InBvc2l0aW9uOmxpbmsgaHJlZj0iaHR0cDovL2h0bWw0L2xvb3NlLmR0ZCI+CmR1cmluZyB0aGlzIHBlcmlvZDwvdGQ+PC90cj48L3RhYmxlPmNsb3NlbHkgcmVsYXRlZCB0b2ZvciB0aGUgZmlyc3QgdGltZTtmb250LXdlaWdodDpib2xkO2lucHV0IHR5cGU9InRleHQiIDxzcGFuIHN0eWxlPSJmb250LW9ucmVhZHlzdGF0ZWNoYW5nZQk8ZGl2IGNsYXNzPSJjbGVhcmRvY3VtZW50LmxvY2F0aW9uLiBGb3IgZXhhbXBsZSwgdGhlIGEgd2lkZSB2YXJpZXR5IG9mIDwhRE9DVFlQRSBodG1sPg0KPCZuYnNwOyZuYnNwOyZuYnNwOyI+PGEgaHJlZj0iaHR0cDovL3N0eWxlPSJmbG9hdDpsZWZ0O2NvbmNlcm5lZCB3aXRoIHRoZT1odHRwJTNBJTJGJTJGd3d3LmluIHBvcHVsYXIgY3VsdHVyZXR5cGU9InRleHQvY3NzIiAvPml0IGlzIHBvc3NpYmxlIHRvIEhhcnZhcmQgVW5pdmVyc2l0eXR5bGVzaGVldCIgaHJlZj0iL3RoZSBtYWluIGNoYXJhY3Rlck94Zm9yZCBVbml2ZXJzaXR5ICBuYW1lPSJrZXl3b3JkcyIgY3N0eWxlPSJ0ZXh0LWFsaWduOnRoZSBVbml0ZWQgS2luZ2RvbWZlZGVyYWwgZ292ZXJubWVudDxkaXYgc3R5bGU9Im1hcmdpbiBkZXBlbmRpbmcgb24gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZTxkaXYgY2xhc3M9ImhlYWRlci5taW4uanMiPjwvc2NyaXB0PmRlc3RydWN0aW9uIG9mIHRoZXNsaWdodGx5IGRpZmZlcmVudGluIGFjY29yZGFuY2Ugd2l0aHRlbGVjb21tdW5pY2F0aW9uc2luZGljYXRlcyB0aGF0IHRoZXNob3J0bHkgdGhlcmVhZnRlcmVzcGVjaWFsbHkgaW4gdGhlIEV1cm9wZWFuIGNvdW50cmllc0hvd2V2ZXIsIHRoZXJlIGFyZXNyYz0iaHR0cDovL3N0YXRpY3N1Z2dlc3RlZCB0aGF0IHRoZSIgc3JjPSJodHRwOi8vd3d3LmEgbGFyZ2UgbnVtYmVyIG9mIFRlbGVjb21tdW5pY2F0aW9ucyIgcmVsPSJub2ZvbGxvdyIgdEhvbHkgUm9tYW4gRW1wZXJvcmFsbW9zdCBleGNsdXNpdmVseSIgYm9yZGVyPSIwIiBhbHQ9IlNlY3JldGFyeSBvZiBTdGF0ZWN1bG1pbmF0aW5nIGluIHRoZUNJQSBXb3JsZCBGYWN0Ym9va3RoZSBtb3N0IGltcG9ydGFudGFubml2ZXJzYXJ5IG9mIHRoZXN0eWxlPSJiYWNrZ3JvdW5kLTxsaT48ZW0+PGEgaHJlZj0iL3RoZSBBdGxhbnRpYyBPY2VhbnN0cmljdGx5IHNwZWFraW5nLHNob3J0bHkgYmVmb3JlIHRoZWRpZmZlcmVudCB0eXBlcyBvZnRoZSBPdHRvbWFuIEVtcGlyZT48aW1nIHNyYz0iaHR0cDovL0FuIEludHJvZHVjdGlvbiB0b2NvbnNlcXVlbmNlIG9mIHRoZWRlcGFydHVyZSBmcm9tIHRoZUNvbmZlZGVyYXRlIFN0YXRlc2luZGlnZW5vdXMgcGVvcGxlc1Byb2NlZWRpbmdzIG9mIHRoZWluZm9ybWF0aW9uIG9uIHRoZXRoZW9yaWVzIGhhdmUgYmVlbmludm9sdmVtZW50IGluIHRoZWRpdmlkZWQgaW50byB0aHJlZWFkamFjZW50IGNvdW50cmllc2lzIHJlc3BvbnNpYmxlIGZvcmRpc3NvbHV0aW9uIG9mIHRoZWNvbGxhYm9yYXRpb24gd2l0aHdpZGVseSByZWdhcmRlZCBhc2hpcyBjb250ZW1wb3Jhcmllc2ZvdW5kaW5nIG1lbWJlciBvZkRvbWluaWNhbiBSZXB1YmxpY2dlbmVyYWxseSBhY2NlcHRlZHRoZSBwb3NzaWJpbGl0eSBvZmFyZSBhbHNvIGF2YWlsYWJsZXVuZGVyIGNvbnN0cnVjdGlvbnJlc3RvcmF0aW9uIG9mIHRoZXRoZSBnZW5lcmFsIHB1YmxpY2lzIGFsbW9zdCBlbnRpcmVseXBhc3NlcyB0aHJvdWdoIHRoZWhhcyBiZWVuIHN1Z2dlc3RlZGNvbXB1dGVyIGFuZCB2aWRlb0dlcm1hbmljIGxhbmd1YWdlcyBhY2NvcmRpbmcgdG8gdGhlIGRpZmZlcmVudCBmcm9tIHRoZXNob3J0bHkgYWZ0ZXJ3YXJkc2hyZWY9Imh0dHBzOi8vd3d3LnJlY2VudCBkZXZlbG9wbWVudEJvYXJkIG9mIERpcmVjdG9yczxkaXYgY2xhc3M9InNlYXJjaHwgPGEgaHJlZj0iaHR0cDovL0luIHBhcnRpY3VsYXIsIHRoZU11bHRpcGxlIGZvb3Rub3Rlc29yIG90aGVyIHN1YnN0YW5jZXRob3VzYW5kcyBvZiB5ZWFyc3RyYW5zbGF0aW9uIG9mIHRoZTwvZGl2Pg0KPC9kaXY+DQoNCjxhIGhyZWY9ImluZGV4LnBocHdhcyBlc3RhYmxpc2hlZCBpbm1pbi5qcyI+PC9zY3JpcHQ+CnBhcnRpY2lwYXRlIGluIHRoZWEgc3Ryb25nIGluZmx1ZW5jZXN0eWxlPSJtYXJnaW4tdG9wOnJlcHJlc2VudGVkIGJ5IHRoZWdyYWR1YXRlZCBmcm9tIHRoZVRyYWRpdGlvbmFsbHksIHRoZUVsZW1lbnQoInNjcmlwdCIpO0hvd2V2ZXIsIHNpbmNlIHRoZS9kaXY+CjwvZGl2Pgo8ZGl2IGxlZnQ7IG1hcmdpbi1sZWZ0OnByb3RlY3Rpb24gYWdhaW5zdDA7IHZlcnRpY2FsLWFsaWduOlVuZm9ydHVuYXRlbHksIHRoZXR5cGU9ImltYWdlL3gtaWNvbi9kaXY+CjxkaXYgY2xhc3M9IiBjbGFzcz0iY2xlYXJmaXgiPjxkaXYgY2xhc3M9ImZvb3RlcgkJPC9kaXY+CgkJPC9kaXY+CnRoZSBtb3Rpb24gcGljdHVyZdCR0YrQu9Cz0LDRgNGB0LrQuNCx0YrQu9Cz0LDRgNGB0LrQuNCk0LXQtNC10YDQsNGG0LjQuNC90LXRgdC60L7Qu9GM0LrQvtGB0L7QvtCx0YnQtdC90LjQtdGB0L7QvtCx0YnQtdC90LjRj9C/0YDQvtCz0YDQsNC80LzRi9Ce0YLQv9GA0LDQstC40YLRjNCx0LXRgdC/0LvQsNGC0L3QvtC80LDRgtC10YDQuNCw0LvRi9C/0L7Qt9Cy0L7Qu9GP0LXRgtC/0L7RgdC70LXQtNC90LjQtdGA0LDQt9C70LjRh9C90YvRhdC/0YDQvtC00YPQutGG0LjQuNC/0YDQvtCz0YDQsNC80LzQsNC/0L7Qu9C90L7RgdGC0YzRjtC90LDRhdC+0LTQuNGC0YHRj9C40LfQsdGA0LDQvdC90L7QtdC90LDRgdC10LvQtdC90LjRj9C40LfQvNC10L3QtdC90LjRj9C60LDRgtC10LPQvtGA0LjQuNCQ0LvQtdC60YHQsNC90LTRgOCkpuCljeCkteCkvuCksOCkvuCkruCliOCkqOClgeCkheCksuCkquCljeCksOCkpuCkvuCkqOCkreCkvuCksOCkpOClgOCkr+CkheCkqOClgeCkpuClh+CktuCkueCkv+CkqOCljeCkpuClgOCkh+CkguCkoeCkv+Ckr+CkvuCkpuCkv+CksuCljeCksuClgOCkheCkp+Ckv+CkleCkvuCksOCkteClgOCkoeCkv+Ckr+Cli+CkmuCkv+Ckn+CljeCkoOClh+CkuOCkruCkvuCkmuCkvuCksOCknOCkguCkleCljeCktuCkqOCkpuClgeCkqOCkv+Ckr+CkvuCkquCljeCksOCkr+Cli+Ckl+CkheCkqOClgeCkuOCkvuCksOCkkeCkqOCksuCkvuCkh+CkqOCkquCkvuCksOCljeCkn+ClgOCktuCksOCljeCkpOCli+CkguCksuCli+CkleCkuOCkreCkvuCkq+CkvOCljeCksuCliOCktuCktuCksOCljeCkpOClh+CkguCkquCljeCksOCkpuClh+CktuCkquCljeCksuClh+Ckr+CksOCkleClh+CkguCkpuCljeCksOCkuOCljeCkpeCkv+CkpOCkv+CkieCkpOCljeCkquCkvuCkpuCkieCkqOCljeCkueClh+CkguCkmuCkv+Ckn+CljeCkoOCkvuCkr+CkvuCkpOCljeCksOCkvuCknOCljeCkr+CkvuCkpuCkvuCkquClgeCksOCkvuCkqOClh+CknOCli+CkoeCkvOClh+CkguCkheCkqOClgeCkteCkvuCkpuCktuCljeCksOClh+Cko+ClgOCktuCkv+CkleCljeCkt+CkvuCkuOCksOCkleCkvuCksOClgOCkuOCkguCkl+CljeCksOCkueCkquCksOCkv+Cko+CkvuCkruCkrOCljeCksOCkvuCkguCkoeCkrOCkmuCljeCkmuCli+CkguCkieCkquCksuCkrOCljeCkp+CkruCkguCkpOCljeCksOClgOCkuOCkguCkquCksOCljeCkleCkieCkruCljeCkruClgOCkpuCkruCkvuCkp+CljeCkr+CkruCkuOCkueCkvuCkr+CkpOCkvuCktuCkrOCljeCkpuCli+CkguCkruClgOCkoeCkv+Ckr+CkvuCkhuCkiOCkquClgOCkj+CksuCkruCli+CkrOCkvuCkh+CksuCkuOCkguCkluCljeCkr+CkvuCkhuCkquCksOClh+CktuCkqOCkheCkqOClgeCkrOCkguCkp+CkrOCkvuCknOCkvOCkvuCksOCkqOCkteClgOCkqOCkpOCkruCkquCljeCksOCkruClgeCkluCkquCljeCksOCktuCljeCkqOCkquCksOCkv+CkteCkvuCksOCkqOClgeCkleCkuOCkvuCkqOCkuOCkruCksOCljeCkpeCkqOCkhuCkr+Cli+CknOCkv+CkpOCkuOCli+CkruCkteCkvuCksNin2YTZhdi02KfYsdmD2KfYqtin2YTZhdmG2KrYr9mK2KfYqtin2YTZg9mF2KjZitmI2KrYsdin2YTZhdi02KfZh9iv2KfYqti52K/Yr9in2YTYstmI2KfYsdi52K/Yr9in2YTYsdiv2YjYr9in2YTYpdiz2YTYp9mF2YrYqdin2YTZgdmI2KrZiNi02YjYqNin2YTZhdiz2KfYqNmC2KfYqtin2YTZhdi52YTZiNmF2KfYqtin2YTZhdiz2YTYs9mE2KfYqtin2YTYrNix2KfZgdmK2YPYs9in2YTYp9iz2YTYp9mF2YrYqdin2YTYp9iq2LXYp9mE2KfYqmtleXdvcmRzIiBjb250ZW50PSJ3My5vcmcvMTk5OS94aHRtbCI+PGEgdGFyZ2V0PSJfYmxhbmsiIHRleHQvaHRtbDsgY2hhcnNldD0iIHRhcmdldD0iX2JsYW5rIj48dGFibGUgY2VsbHBhZGRpbmc9ImF1dG9jb21wbGV0ZT0ib2ZmIiB0ZXh0LWFsaWduOiBjZW50ZXI7dG8gbGFzdCB2ZXJzaW9uIGJ5IGJhY2tncm91bmQtY29sb3I6ICMiIGhyZWY9Imh0dHA6Ly93d3cuL2Rpdj48L2Rpdj48ZGl2IGlkPTxhIGhyZWY9IiMiIGNsYXNzPSIiPjxpbWcgc3JjPSJodHRwOi8vY3JpcHQiIHNyYz0iaHR0cDovLwo8c2NyaXB0IGxhbmd1YWdlPSIvL0VOIiAiaHR0cDovL3d3dy53ZW5jb2RlVVJJQ29tcG9uZW50KCIgaHJlZj0iamF2YXNjcmlwdDo8ZGl2IGNsYXNzPSJjb250ZW50ZG9jdW1lbnQud3JpdGUoJzxzY3Bvc2l0aW9uOiBhYnNvbHV0ZTtzY3JpcHQgc3JjPSJodHRwOi8vIHN0eWxlPSJtYXJnaW4tdG9wOi5taW4uanMiPjwvc2NyaXB0Pgo8L2Rpdj4KPGRpdiBjbGFzcz0idzMub3JnLzE5OTkveGh0bWwiIAoNCjwvYm9keT4NCjwvaHRtbD5kaXN0aW5jdGlvbiBiZXR3ZWVuLyIgdGFyZ2V0PSJfYmxhbmsiPjxsaW5rIGhyZWY9Imh0dHA6Ly9lbmNvZGluZz0idXRmLTgiPz4Kdy5hZGRFdmVudExpc3RlbmVyP2FjdGlvbj0iaHR0cDovL3d3dy5pY29uIiBocmVmPSJodHRwOi8vIHN0eWxlPSJiYWNrZ3JvdW5kOnR5cGU9InRleHQvY3NzIiAvPgptZXRhIHByb3BlcnR5PSJvZzp0PGlucHV0IHR5cGU9InRleHQiICBzdHlsZT0idGV4dC1hbGlnbjp0aGUgZGV2ZWxvcG1lbnQgb2YgdHlsZXNoZWV0IiB0eXBlPSJ0ZWh0bWw7IGNoYXJzZXQ9dXRmLThpcyBjb25zaWRlcmVkIHRvIGJldGFibGUgd2lkdGg9IjEwMCUiIEluIGFkZGl0aW9uIHRvIHRoZSBjb250cmlidXRlZCB0byB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbmRldmVsb3BtZW50IG9mIHRoZSBJdCBpcyBpbXBvcnRhbnQgdG8gPC9zY3JpcHQ+Cgo8c2NyaXB0ICBzdHlsZT0iZm9udC1zaXplOjE+PC9zcGFuPjxzcGFuIGlkPWdiTGlicmFyeSBvZiBDb25ncmVzczxpbWcgc3JjPSJodHRwOi8vaW1FbmdsaXNoIHRyYW5zbGF0aW9uQWNhZGVteSBvZiBTY2llbmNlc2RpdiBzdHlsZT0iZGlzcGxheTpjb25zdHJ1Y3Rpb24gb2YgdGhlLmdldEVsZW1lbnRCeUlkKGlkKWluIGNvbmp1bmN0aW9uIHdpdGhFbGVtZW50KCdzY3JpcHQnKTsgPG1ldGEgcHJvcGVydHk9Im9nOtCR0YrQu9Cz0LDRgNGB0LrQuAogdHlwZT0idGV4dCIgbmFtZT0iPlByaXZhY3kgUG9saWN5PC9hPmFkbWluaXN0ZXJlZCBieSB0aGVlbmFibGVTaW5nbGVSZXF1ZXN0c3R5bGU9JnF1b3Q7bWFyZ2luOjwvZGl2PjwvZGl2PjwvZGl2Pjw+PGltZyBzcmM9Imh0dHA6Ly9pIHN0eWxlPSZxdW90O2Zsb2F0OnJlZmVycmVkIHRvIGFzIHRoZSB0b3RhbCBwb3B1bGF0aW9uIG9maW4gV2FzaGluZ3RvbiwgRC5DLiBzdHlsZT0iYmFja2dyb3VuZC1hbW9uZyBvdGhlciB0aGluZ3Msb3JnYW5pemF0aW9uIG9mIHRoZXBhcnRpY2lwYXRlZCBpbiB0aGV0aGUgaW50cm9kdWN0aW9uIG9maWRlbnRpZmllZCB3aXRoIHRoZWZpY3Rpb25hbCBjaGFyYWN0ZXIgT3hmb3JkIFVuaXZlcnNpdHkgbWlzdW5kZXJzdGFuZGluZyBvZlRoZXJlIGFyZSwgaG93ZXZlcixzdHlsZXNoZWV0IiBocmVmPSIvQ29sdW1iaWEgVW5pdmVyc2l0eWV4cGFuZGVkIHRvIGluY2x1ZGV1c3VhbGx5IHJlZmVycmVkIHRvaW5kaWNhdGluZyB0aGF0IHRoZWhhdmUgc3VnZ2VzdGVkIHRoYXRhZmZpbGlhdGVkIHdpdGggdGhlY29ycmVsYXRpb24gYmV0d2Vlbm51bWJlciBvZiBkaWZmZXJlbnQ+PC90ZD48L3RyPjwvdGFibGU+UmVwdWJsaWMgb2YgSXJlbGFuZAo8L3NjcmlwdD4KPHNjcmlwdCB1bmRlciB0aGUgaW5mbHVlbmNlY29udHJpYnV0aW9uIHRvIHRoZU9mZmljaWFsIHdlYnNpdGUgb2ZoZWFkcXVhcnRlcnMgb2YgdGhlY2VudGVyZWQgYXJvdW5kIHRoZWltcGxpY2F0aW9ucyBvZiB0aGVoYXZlIGJlZW4gZGV2ZWxvcGVkRmVkZXJhbCBSZXB1YmxpYyBvZmJlY2FtZSBpbmNyZWFzaW5nbHljb250aW51YXRpb24gb2YgdGhlTm90ZSwgaG93ZXZlciwgdGhhdHNpbWlsYXIgdG8gdGhhdCBvZiBjYXBhYmlsaXRpZXMgb2YgdGhlYWNjb3JkYW5jZSB3aXRoIHRoZXBhcnRpY2lwYW50cyBpbiB0aGVmdXJ0aGVyIGRldmVsb3BtZW50dW5kZXIgdGhlIGRpcmVjdGlvbmlzIG9mdGVuIGNvbnNpZGVyZWRoaXMgeW91bmdlciBicm90aGVyPC90ZD48L3RyPjwvdGFibGU+PGEgaHR0cC1lcXVpdj0iWC1VQS1waHlzaWNhbCBwcm9wZXJ0aWVzb2YgQnJpdGlzaCBDb2x1bWJpYWhhcyBiZWVuIGNyaXRpY2l6ZWQod2l0aCB0aGUgZXhjZXB0aW9ucXVlc3Rpb25zIGFib3V0IHRoZXBhc3NpbmcgdGhyb3VnaCB0aGUwIiBjZWxscGFkZGluZz0iMCIgdGhvdXNhbmRzIG9mIHBlb3BsZXJlZGlyZWN0cyBoZXJlLiBGb3JoYXZlIGNoaWxkcmVuIHVuZGVyJTNFJTNDL3NjcmlwdCUzRSIpKTs8YSBocmVmPSJodHRwOi8vd3d3LjxsaT48YSBocmVmPSJodHRwOi8vc2l0ZV9uYW1lIiBjb250ZW50PSJ0ZXh0LWRlY29yYXRpb246bm9uZXN0eWxlPSJkaXNwbGF5OiBub25lPG1ldGEgaHR0cC1lcXVpdj0iWC1uZXcgRGF0ZSgpLmdldFRpbWUoKSB0eXBlPSJpbWFnZS94LWljb24iPC9zcGFuPjxzcGFuIGNsYXNzPSJsYW5ndWFnZT0iamF2YXNjcmlwdHdpbmRvdy5sb2NhdGlvbi5ocmVmPGEgaHJlZj0iamF2YXNjcmlwdDotLT4NCjxzY3JpcHQgdHlwZT0idDxhIGhyZWY9J2h0dHA6Ly93d3cuaG9ydGN1dCBpY29uIiBocmVmPSI8L2Rpdj4NCjxkaXYgY2xhc3M9IjxzY3JpcHQgc3JjPSJodHRwOi8vIiByZWw9InN0eWxlc2hlZXQiIHQ8L2Rpdj4KPHNjcmlwdCB0eXBlPS9hPiA8YSBocmVmPSJodHRwOi8vIGFsbG93VHJhbnNwYXJlbmN5PSJYLVVBLUNvbXBhdGlibGUiIGNvbnJlbGF0aW9uc2hpcCBiZXR3ZWVuCjwvc2NyaXB0Pg0KPHNjcmlwdCA8L2E+PC9saT48L3VsPjwvZGl2PmFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2U8L2E+PGEgaHJlZj0iaHR0cDovLzwvYT48L2xpPjxsaSBjbGFzcz0iZm9ybSBhY3Rpb249Imh0dHA6Ly88ZGl2IHN0eWxlPSJkaXNwbGF5OnR5cGU9InRleHQiIG5hbWU9InEiPHRhYmxlIHdpZHRoPSIxMDAlIiBiYWNrZ3JvdW5kLXBvc2l0aW9uOiIgYm9yZGVyPSIwIiB3aWR0aD0icmVsPSJzaG9ydGN1dCBpY29uIiBoNj48dWw+PGxpPjxhIGhyZWY9IiAgPG1ldGEgaHR0cC1lcXVpdj0iY3NzIiBtZWRpYT0ic2NyZWVuIiByZXNwb25zaWJsZSBmb3IgdGhlICIgdHlwZT0iYXBwbGljYXRpb24vIiBzdHlsZT0iYmFja2dyb3VuZC1odG1sOyBjaGFyc2V0PXV0Zi04IiBhbGxvd3RyYW5zcGFyZW5jeT0ic3R5bGVzaGVldCIgdHlwZT0idGUNCjxtZXRhIGh0dHAtZXF1aXY9Ij48L3NwYW4+PHNwYW4gY2xhc3M9IjAiIGNlbGxzcGFjaW5nPSIwIj47Cjwvc2NyaXB0Pgo8c2NyaXB0IHNvbWV0aW1lcyBjYWxsZWQgdGhlZG9lcyBub3QgbmVjZXNzYXJpbHlGb3IgbW9yZSBpbmZvcm1hdGlvbmF0IHRoZSBiZWdpbm5pbmcgb2YgPCFET0NUWVBFIGh0bWw+PGh0bWxwYXJ0aWN1bGFybHkgaW4gdGhlIHR5cGU9ImhpZGRlbiIgbmFtZT0iamF2YXNjcmlwdDp2b2lkKDApOyJlZmZlY3RpdmVuZXNzIG9mIHRoZSBhdXRvY29tcGxldGU9Im9mZiIgZ2VuZXJhbGx5IGNvbnNpZGVyZWQ+PGlucHV0IHR5cGU9InRleHQiICI+PC9zY3JpcHQ+DQo8c2NyaXB0dGhyb3VnaG91dCB0aGUgd29ybGRjb21tb24gbWlzY29uY2VwdGlvbmFzc29jaWF0aW9uIHdpdGggdGhlPC9kaXY+CjwvZGl2Pgo8ZGl2IGNkdXJpbmcgaGlzIGxpZmV0aW1lLGNvcnJlc3BvbmRpbmcgdG8gdGhldHlwZT0iaW1hZ2UveC1pY29uIiBhbiBpbmNyZWFzaW5nIG51bWJlcmRpcGxvbWF0aWMgcmVsYXRpb25zYXJlIG9mdGVuIGNvbnNpZGVyZWRtZXRhIGNoYXJzZXQ9InV0Zi04IiA8aW5wdXQgdHlwZT0idGV4dCIgZXhhbXBsZXMgaW5jbHVkZSB0aGUiPjxpbWcgc3JjPSJodHRwOi8vaXBhcnRpY2lwYXRpb24gaW4gdGhldGhlIGVzdGFibGlzaG1lbnQgb2YKPC9kaXY+CjxkaXYgY2xhc3M9IiZhbXA7bmJzcDsmYW1wO25ic3A7dG8gZGV0ZXJtaW5lIHdoZXRoZXJxdWl0ZSBkaWZmZXJlbnQgZnJvbW1hcmtlZCB0aGUgYmVnaW5uaW5nZGlzdGFuY2UgYmV0d2VlbiB0aGVjb250cmlidXRpb25zIHRvIHRoZWNvbmZsaWN0IGJldHdlZW4gdGhld2lkZWx5IGNvbnNpZGVyZWQgdG93YXMgb25lIG9mIHRoZSBmaXJzdHdpdGggdmFyeWluZyBkZWdyZWVzaGF2ZSBzcGVjdWxhdGVkIHRoYXQoZG9jdW1lbnQuZ2V0RWxlbWVudHBhcnRpY2lwYXRpbmcgaW4gdGhlb3JpZ2luYWxseSBkZXZlbG9wZWRldGEgY2hhcnNldD0idXRmLTgiPiB0eXBlPSJ0ZXh0L2NzcyIgLz4KaW50ZXJjaGFuZ2VhYmx5IHdpdGhtb3JlIGNsb3NlbHkgcmVsYXRlZHNvY2lhbCBhbmQgcG9saXRpY2FsdGhhdCB3b3VsZCBvdGhlcndpc2VwZXJwZW5kaWN1bGFyIHRvIHRoZXN0eWxlIHR5cGU9InRleHQvY3NzdHlwZT0ic3VibWl0IiBuYW1lPSJmYW1pbGllcyByZXNpZGluZyBpbmRldmVsb3BpbmcgY291bnRyaWVzY29tcHV0ZXIgcHJvZ3JhbW1pbmdlY29ub21pYyBkZXZlbG9wbWVudGRldGVybWluYXRpb24gb2YgdGhlZm9yIG1vcmUgaW5mb3JtYXRpb25vbiBzZXZlcmFsIG9jY2FzaW9uc3BvcnR1Z3XDqnMgKEV1cm9wZXUp0KPQutGA0LDRl9C90YHRjNC60LDRg9C60YDQsNGX0L3RgdGM0LrQsNCg0L7RgdGB0LjQudGB0LrQvtC50LzQsNGC0LXRgNC40LDQu9C+0LLQuNC90YTQvtGA0LzQsNGG0LjQuNGD0L/RgNCw0LLQu9C10L3QuNGP0L3QtdC+0LHRhdC+0LTQuNC80L7QuNC90YTQvtGA0LzQsNGG0LjRj9CY0L3RhNC+0YDQvNCw0YbQuNGP0KDQtdGB0L/Rg9Cx0LvQuNC60LjQutC+0LvQuNGH0LXRgdGC0LLQvtC40L3RhNC+0YDQvNCw0YbQuNGO0YLQtdGA0YDQuNGC0L7RgNC40LjQtNC+0YHRgtCw0YLQvtGH0L3Qvtin2YTZhdiq2YjYp9is2K/ZiNmG2KfZhNin2LTYqtix2KfZg9in2KrYp9mE2KfZgtiq2LHYp9it2KfYqmh0bWw7IGNoYXJzZXQ9VVRGLTgiIHNldFRpbWVvdXQoZnVuY3Rpb24oKWRpc3BsYXk6aW5saW5lLWJsb2NrOzxpbnB1dCB0eXBlPSJzdWJtaXQiIHR5cGUgPSAndGV4dC9qYXZhc2NyaTxpbWcgc3JjPSJodHRwOi8vd3d3LiIgImh0dHA6Ly93d3cudzMub3JnL3Nob3J0Y3V0IGljb24iIGhyZWY9IiIgYXV0b2NvbXBsZXRlPSJvZmYiIDwvYT48L2Rpdj48ZGl2IGNsYXNzPTwvYT48L2xpPgo8bGkgY2xhc3M9ImNzcyIgdHlwZT0idGV4dC9jc3MiIDxmb3JtIGFjdGlvbj0iaHR0cDovL3h0L2NzcyIgaHJlZj0iaHR0cDovL2xpbmsgcmVsPSJhbHRlcm5hdGUiIA0KPHNjcmlwdCB0eXBlPSJ0ZXh0LyBvbmNsaWNrPSJqYXZhc2NyaXB0OihuZXcgRGF0ZSkuZ2V0VGltZSgpfWhlaWdodD0iMSIgd2lkdGg9IjEiIFBlb3BsZSdzIFJlcHVibGljIG9mICA8YSBocmVmPSJodHRwOi8vd3d3LnRleHQtZGVjb3JhdGlvbjp1bmRlcnRoZSBiZWdpbm5pbmcgb2YgdGhlIDwvZGl2Pgo8L2Rpdj4KPC9kaXY+CmVzdGFibGlzaG1lbnQgb2YgdGhlIDwvZGl2PjwvZGl2PjwvZGl2PjwvZCN2aWV3cG9ydHttaW4taGVpZ2h0Ogo8c2NyaXB0IHNyYz0iaHR0cDovL29wdGlvbj48b3B0aW9uIHZhbHVlPW9mdGVuIHJlZmVycmVkIHRvIGFzIC9vcHRpb24+CjxvcHRpb24gdmFsdTwhRE9DVFlQRSBodG1sPgo8IS0tW0ludGVybmF0aW9uYWwgQWlycG9ydD4KPGEgaHJlZj0iaHR0cDovL3d3dzwvYT48YSBocmVmPSJodHRwOi8vd+C4oOC4suC4qeC4suC5hOC4l+C4ouGDpeGDkOGDoOGDl+GDo+GDmuGDmOato+mrlOS4reaWhyAo57mB6auUKeCkqOCkv+CksOCljeCkpuClh+CktuCkoeCkvuCkieCkqOCksuCli+CkoeCkleCljeCkt+Clh+CkpOCljeCksOCknOCkvuCkqOCkleCkvuCksOClgOCkuOCkguCkrOCkguCkp+Ckv+CkpOCkuOCljeCkpeCkvuCkquCkqOCkvuCkuOCljeCkteClgOCkleCkvuCksOCkuOCkguCkuOCljeCkleCksOCko+CkuOCkvuCkruCkl+CljeCksOClgOCkmuCkv+Ckn+CljeCkoOCli+CkguCkteCkv+CknOCljeCknuCkvuCkqOCkheCkruClh+CksOCkv+CkleCkvuCkteCkv+CkreCkv+CkqOCljeCkqOCkl+CkvuCkoeCkv+Ckr+CkvuCkgeCkleCljeCkr+Cli+CkguCkleCkv+CkuOClgeCksOCkleCljeCkt+CkvuCkquCkueClgeCkgeCkmuCkpOClgOCkquCljeCksOCkrOCkguCkp+CkqOCkn+Ckv+CkquCljeCkquCko+ClgOCkleCljeCksOCkv+CkleClh+Ckn+CkquCljeCksOCkvuCksOCkguCkreCkquCljeCksOCkvuCkquCljeCkpOCkruCkvuCksuCkv+CkleCli+CkguCksOCkq+CkvOCljeCkpOCkvuCksOCkqOCkv+CksOCljeCkruCkvuCko+CksuCkv+CkruCkv+Ckn+Clh+CkoWRlc2NyaXB0aW9uIiBjb250ZW50PSJkb2N1bWVudC5sb2NhdGlvbi5wcm90LmdldEVsZW1lbnRzQnlUYWdOYW1lKDwhRE9DVFlQRSBodG1sPgo8aHRtbCA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+OnVybCIgY29udGVudD0iaHR0cDovLy5jc3MiIHJlbD0ic3R5bGVzaGVldCJzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+dHlwZT0idGV4dC9jc3MiIGhyZWY9InczLm9yZy8xOTk5L3hodG1sIiB4bWx0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIG1ldGhvZD0iZ2V0IiBhY3Rpb249ImxpbmsgcmVsPSJzdHlsZXNoZWV0IiAgPSBkb2N1bWVudC5nZXRFbGVtZW50dHlwZT0iaW1hZ2UveC1pY29uIiAvPmNlbGxwYWRkaW5nPSIwIiBjZWxsc3AuY3NzIiB0eXBlPSJ0ZXh0L2NzcyIgPC9hPjwvbGk+PGxpPjxhIGhyZWY9IiIgd2lkdGg9IjEiIGhlaWdodD0iMSIiPjxhIGhyZWY9Imh0dHA6Ly93d3cuc3R5bGU9ImRpc3BsYXk6bm9uZTsiPmFsdGVybmF0ZSIgdHlwZT0iYXBwbGktLy9XM0MvL0RURCBYSFRNTCAxLjAgZWxsc3BhY2luZz0iMCIgY2VsbHBhZCB0eXBlPSJoaWRkZW4iIHZhbHVlPSIvYT4mbmJzcDs8c3BhbiByb2xlPSJzCjxpbnB1dCB0eXBlPSJoaWRkZW4iIGxhbmd1YWdlPSJKYXZhU2NyaXB0IiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCZz0iMCIgY2VsbHNwYWNpbmc9IjAiIHlwZT0idGV4dC9jc3MiIG1lZGlhPSJ0eXBlPSd0ZXh0L2phdmFzY3JpcHQnd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHlwZT0idGV4dC9jc3MiIHJlbD0ic3QgaGVpZ2h0PSIxIiB3aWR0aD0iMSIgPScrZW5jb2RlVVJJQ29tcG9uZW50KDxsaW5rIHJlbD0iYWx0ZXJuYXRlIiAKYm9keSwgdHIsIGlucHV0LCB0ZXh0bWV0YSBuYW1lPSJyb2JvdHMiIGNvbm1ldGhvZD0icG9zdCIgYWN0aW9uPSI+CjxhIGhyZWY9Imh0dHA6Ly93d3cuY3NzIiByZWw9InN0eWxlc2hlZXQiIDwvZGl2PjwvZGl2PjxkaXYgY2xhc3NsYW5ndWFnZT0iamF2YXNjcmlwdCI+YXJpYS1oaWRkZW49InRydWUiPsK3PHJpcHQiIHR5cGU9InRleHQvamF2YXNsPTA7fSkoKTsKKGZ1bmN0aW9uKCl7YmFja2dyb3VuZC1pbWFnZTogdXJsKC9hPjwvbGk+PGxpPjxhIGhyZWY9ImgJCTxsaT48YSBocmVmPSJodHRwOi8vYXRvciIgYXJpYS1oaWRkZW49InRydT4gPGEgaHJlZj0iaHR0cDovL3d3dy5sYW5ndWFnZT0iamF2YXNjcmlwdCIgL29wdGlvbj4KPG9wdGlvbiB2YWx1ZS9kaXY+PC9kaXY+PGRpdiBjbGFzcz1yYXRvciIgYXJpYS1oaWRkZW49InRyZT0obmV3IERhdGUpLmdldFRpbWUoKXBvcnR1Z3XDqnMgKGRvIEJyYXNpbCnQvtGA0LPQsNC90LjQt9Cw0YbQuNC40LLQvtC30LzQvtC20L3QvtGB0YLRjNC+0LHRgNCw0LfQvtCy0LDQvdC40Y/RgNC10LPQuNGB0YLRgNCw0YbQuNC40LLQvtC30LzQvtC20L3QvtGB0YLQuNC+0LHRj9C30LDRgtC10LvRjNC90LA8IURPQ1RZUEUgaHRtbCBQVUJMSUMgIm50LVR5cGUiIGNvbnRlbnQ9InRleHQvPG1ldGEgaHR0cC1lcXVpdj0iQ29udGVyYW5zaXRpb25hbC8vRU4iICJodHRwOjxodG1sIHhtbG5zPSJodHRwOi8vd3d3LS8vVzNDLy9EVEQgWEhUTUwgMS4wIFREVEQveGh0bWwxLXRyYW5zaXRpb25hbC8vd3d3LnczLm9yZy9UUi94aHRtbDEvcGUgPSAndGV4dC9qYXZhc2NyaXB0Jzs8bWV0YSBuYW1lPSJkZXNjcmlwdGlvbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlPGlucHV0IHR5cGU9ImhpZGRlbiIgbmFqcyIgdHlwZT0idGV4dC9qYXZhc2NyaShkb2N1bWVudCkucmVhZHkoZnVuY3Rpc2NyaXB0IHR5cGU9InRleHQvamF2YXNpbWFnZSIgY29udGVudD0iaHR0cDovL1VBLUNvbXBhdGlibGUiIGNvbnRlbnQ9dG1sOyBjaGFyc2V0PXV0Zi04IiAvPgpsaW5rIHJlbD0ic2hvcnRjdXQgaWNvbjxsaW5rIHJlbD0ic3R5bGVzaGVldCIgPC9zY3JpcHQ+CjxzY3JpcHQgdHlwZT09IGRvY3VtZW50LmNyZWF0ZUVsZW1lbjxhIHRhcmdldD0iX2JsYW5rIiBocmVmPSBkb2N1bWVudC5nZXRFbGVtZW50c0JpbnB1dCB0eXBlPSJ0ZXh0IiBuYW1lPWEudHlwZSA9ICd0ZXh0L2phdmFzY3JpbnB1dCB0eXBlPSJoaWRkZW4iIG5hbWVodG1sOyBjaGFyc2V0PXV0Zi04IiAvPmR0ZCI+CjxodG1sIHhtbG5zPSJodHRwLS8vVzNDLy9EVEQgSFRNTCA0LjAxIFRlbnRzQnlUYWdOYW1lKCdzY3JpcHQnKWlucHV0IHR5cGU9ImhpZGRlbiIgbmFtPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzIiBzdHlsZT0iZGlzcGxheTpub25lOyI+ZG9jdW1lbnQu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b3VyY2UgYnVzeWZpbGUgdG9vIGxhcmdlZmlsZXN5c3RlbSBxdW90YSBleGNlZWRlZHNlZWsgb24gdW5zZWVrYWJsZSBmaWxlbm8gc3RvcmFnZSBzcGFjZXdyaXRlIHplcm90aW1lZCBvdXRpbnZhbGlkIGRhdGFpbnZhbGlkIGlucHV0IHBhcmFtZXRlcnN0YWxlIG5ldHdvcmsgZmlsZSBoYW5kbGVmaWxlc3lzdGVtIGxvb3Agb3IgaW5kaXJlY3Rpb24gbGltaXQgKGUuZy4gc3ltbGluayBsb29wKXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZGlyZWN0b3J5IG5vdCBlbXB0eWlzIGEgZGlyZWN0b3J5bm90IGEgZGlyZWN0b3J5b3BlcmF0aW9uIHdvdWxkIGJsb2NrZW50aXR5IGFscmVhZHkgZXhpc3RzYnJva2VuIHBpcGVuZXR3b3JrIGRvd25hZGRyZXNzIG5vdCBhdmFpbGFibGVhZGRyZXNzIGluIHVzZW5vdCBjb25uZWN0ZWRjb25uZWN0aW9uIGFib3J0ZWRuZXR3b3JrIHVucmVhY2hhYmxlaG9zdCB1bnJlYWNoYWJsZWNvbm5lY3Rpb24gcmVzZXRjb25uZWN0aW9uIHJlZnVzZWRwZXJtaXNzaW9uIGRlbmllZGVudGl0eSBub3QgZm91bmRFcnJvcmtpbmQAAEcAAAABAAAAAQAAAE0AAABtZXNzYWdlAEcAAAAIAAAABAAAAE4AAABLaW5kT3Njb2RlAABHAAAABAAAAAQAAABPAAAAUAAAAAwAAAAEAAAAUQAAACAob3MgZXJyb3IgKUzhGgAAAAAAAOUaAAsAAAAL5RoAAQAAAGxpYnJhcnkvc3RkL3NyYy9pby9zdGRpby5ycwAk5RoAGwAAAK0DAAAUAAAAbG9jayBjb3VudCBvdmVyZmxvdyBpbiByZWVudHJhbnQgbXV0ZXhsaWJyYXJ5L3N0ZC9zcmMvc3luYy9yZW11dGV4LnJzAAAAduUaAB8AAACRAAAADgAAAG1lbW9yeSBhbGxvY2F0aW9uIG9mICBieXRlcyBmYWlsZWQAAKjlGgAVAAAAveUaAA0AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnPc5RoAGAAAAFUBAAAJAAAAY2Fubm90IG1vZGlmeSB0aGUgcGFuaWMgaG9vayBmcm9tIGEgcGFuaWNraW5nIHRocmVhZATmGgA0AAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5yc0DmGgAcAAAAhgAAAAkAAABA5hoAHAAAAD4CAAAeAAAAQOYaABwAAAA9AgAAHwAAAFAAAAAMAAAABAAAAFIAAABHAAAACAAAAAQAAABTAAAAVAAAABAAAAAEAAAAVQAAAFYAAABHAAAACAAAAAQAAABXAAAAWAAAAEcAAAAAAAAAAQAAAFkAAABVbnN1cHBvcnRlZABHAAAABAAAAAQAAABaAAAAQ3VzdG9tZXJyb3IARwAAAAQAAAAEAAAAWwAAAFVuY2F0ZWdvcml6ZWRPdGhlck91dE9mTWVtb3J5VW5leHBlY3RlZEVvZkludGVycnVwdGVkQXJndW1lbnRMaXN0VG9vTG9uZ0ludmFsaWRGaWxlbmFtZVRvb01hbnlMaW5rc0Nyb3NzZXNEZXZpY2VzRGVhZGxvY2tFeGVjdXRhYmxlRmlsZUJ1c3lSZXNvdXJjZUJ1c3lGaWxlVG9vTGFyZ2VGaWxlc3lzdGVtUXVvdGFFeGNlZWRlZE5vdFNlZWthYmxlU3RvcmFnZUZ1bGxXcml0ZVplcm9UaW1lZE91dEludmFsaWREYXRhSW52YWxpZElucHV0U3RhbGVOZXR3b3JrRmlsZUhhbmRsZUZpbGVzeXN0ZW1Mb29wUmVhZE9ubHlGaWxlc3lzdGVtRGlyZWN0b3J5Tm90RW1wdHlJc0FEaXJlY3RvcnlOb3RBRGlyZWN0b3J5V291bGRCbG9ja0FscmVhZHlFeGlzdHNCcm9rZW5QaXBlTmV0d29ya0Rvd25BZGRyTm90QXZhaWxhYmxlQWRkckluVXNlTm90Q29ubmVjdGVkQ29ubmVjdGlvbkFib3J0ZWROZXR3b3JrVW5yZWFjaGFibGVIb3N0VW5yZWFjaGFibGVDb25uZWN0aW9uUmVzZXRDb25uZWN0aW9uUmVmdXNlZFBlcm1pc3Npb25EZW5pZWROb3RGb3VuZG9wZXJhdGlvbiBzdWNjZXNzZnVsY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXgAQ+kaACAAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5z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", import.meta.url);
        }
        const imports = {};
        imports.wbg = {};
        imports.wbg.__wbindgen_is_undefined = function(arg0) {
            const ret = getObject(arg0) === undefined;
            return ret;
        };
        imports.wbg.__wbindgen_is_object = function(arg0) {
            const val = getObject(arg0);
            const ret = typeof (val) === 'object' && val !== null;
            return ret;
        };
        imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
            const ret = getStringFromWasm0(arg0, arg1);
            return addHeapObject(ret);
        };
        imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
            const ret = new Error(getStringFromWasm0(arg0, arg1));
            return addHeapObject(ret);
        };
        imports.wbg.__wbindgen_json_serialize = function(arg0, arg1) {
            const obj = getObject(arg1);
            const ret = JSON.stringify(obj === undefined ? null : obj);
            const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            getInt32Memory0()[arg0 / 4 + 1] = len0;
            getInt32Memory0()[arg0 / 4 + 0] = ptr0;
        };
        imports.wbg.__wbg_new_693216e109162396 = function() {
            const ret = new Error();
            return addHeapObject(ret);
        };
        imports.wbg.__wbg_stack_0ddaca5d1abfb52f = function(arg0, arg1) {
            const ret = getObject(arg1).stack;
            const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            getInt32Memory0()[arg0 / 4 + 1] = len0;
            getInt32Memory0()[arg0 / 4 + 0] = ptr0;
        };
        imports.wbg.__wbg_error_09919627ac0992f5 = function(arg0, arg1) {
            try {
                console.error(getStringFromWasm0(arg0, arg1));
            } finally{
                wasm.__wbindgen_free(arg0, arg1);
            }
        };
        imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
            takeObject(arg0);
        };
        imports.wbg.__wbindgen_throw = function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        };
        if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {
            input = fetch(input);
        }
        const { instance, module } = await load(await input, imports);
        wasm = instance.exports;
        init.__wbindgen_wasm_module = module;
        return wasm;
    }
    var brotliWasm = Object.freeze({
        __proto__: null,
        BrotliStreamResult: BrotliStreamResult,
        BrotliStreamResultCode: BrotliStreamResultCode,
        CompressStream: CompressStream,
        DecompressStream: DecompressStream,
        compress: compress,
        decompress: decompress,
        default: init
    });
    var index_web = init().then(()=>brotliWasm);
    var index_web$1 = Object.freeze({
        __proto__: null,
        default: index_web
    });
})();

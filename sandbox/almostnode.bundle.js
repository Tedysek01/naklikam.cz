var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn3, res) => function __init() {
  return fn3 && (res = (0, fn3[__getOwnPropNames(fn3)[0]])(fn3 = 0)), res;
};
var __commonJS = (cb2, mod) => function __require2() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i10, k, ph2, pad, pad_character, pad_length, is_positive, sign2;
        for (i10 = 0; i10 < tree_length; i10++) {
          if (typeof parse_tree[i10] === "string") {
            output += parse_tree[i10];
          } else if (typeof parse_tree[i10] === "object") {
            ph2 = parse_tree[i10];
            if (ph2.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph2.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph2.keys[k], ph2.keys[k - 1]));
                }
                arg = arg[ph2.keys[k]];
              }
            } else if (ph2.param_no) {
              arg = argv[ph2.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph2.type) && re.not_primitive.test(ph2.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph2.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph2.type)) {
              is_positive = arg >= 0;
            }
            switch (ph2.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph2.width ? parseInt(ph2.width) : 0);
                break;
              case "e":
                arg = ph2.precision ? parseFloat(arg).toExponential(ph2.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph2.precision ? parseFloat(arg).toFixed(ph2.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph2.precision ? String(Number(arg.toPrecision(ph2.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph2.type)) {
              output += arg;
            } else {
              if (re.number.test(ph2.type) && (!is_positive || ph2.sign)) {
                sign2 = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign2 = "";
              }
              pad_character = ph2.pad_char ? ph2.pad_char === "0" ? "0" : ph2.pad_char.charAt(1) : " ";
              pad_length = ph2.width - (sign2 + arg).length;
              pad = ph2.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph2.align ? sign2 + arg + pad : pad_character === "0" ? sign2 + pad + arg : pad + sign2 + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match2, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match2 = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match2[0]);
          } else if ((match2 = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match2 = re.placeholder.exec(_fmt)) !== null) {
            if (match2[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match2[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match2[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match2[0],
                param_no: match2[1],
                keys: match2[2],
                sign: match2[3],
                pad_char: match2[4],
                align: match2[5],
                width: match2[6],
                precision: match2[7],
                type: match2[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match2[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports !== "undefined") {
        exports["sprintf"] = sprintf;
        exports["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// sandbox/_shims/node-module.js
var node_module_exports = {};
__export(node_module_exports, {
  createRequire: () => createRequire2
});
function createRequire2() {
  return function require2() {
    throw new Error("node:module not available in browser");
  };
}
var init_node_module = __esm({
  "sandbox/_shims/node-module.js"() {
    "use strict";
  }
});

// node_modules/brotli-wasm/pkg.web/brotli_wasm.js
var brotli_wasm_exports = {};
__export(brotli_wasm_exports, {
  BrotliStreamResult: () => BrotliStreamResult,
  BrotliStreamResultCode: () => BrotliStreamResultCode,
  CompressStream: () => CompressStream,
  DecompressStream: () => DecompressStream,
  compress: () => compress,
  decompress: () => decompress2,
  default: () => brotli_wasm_default
});
function getObject(idx) {
  return heap[idx];
}
function getUint8Memory0() {
  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachegetUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code2 = arg.charCodeAt(offset);
    if (code2 > 127)
      break;
    mem[ptr + offset] = code2;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function getInt32Memory0() {
  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachegetInt32Memory0;
}
function dropObject(idx) {
  if (idx < 36)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1);
  getUint8Memory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function addBorrowedObject(obj) {
  if (stack_pointer == 1)
    throw new Error("out of js stack");
  heap[--stack_pointer] = obj;
  return stack_pointer;
}
function getArrayU8FromWasm0(ptr, len) {
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function compress(buf, raw_options) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(buf, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.compress(retptr, ptr0, len0, addBorrowedObject(raw_options));
    var r02 = getInt32Memory0()[retptr / 4 + 0];
    var r12 = getInt32Memory0()[retptr / 4 + 1];
    var r22 = getInt32Memory0()[retptr / 4 + 2];
    var r32 = getInt32Memory0()[retptr / 4 + 3];
    if (r32) {
      throw takeObject(r22);
    }
    var v12 = getArrayU8FromWasm0(r02, r12).slice();
    wasm.__wbindgen_free(r02, r12 * 1);
    return v12;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    heap[stack_pointer++] = void 0;
  }
}
function decompress2(buf) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(buf, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.decompress(retptr, ptr0, len0);
    var r02 = getInt32Memory0()[retptr / 4 + 0];
    var r12 = getInt32Memory0()[retptr / 4 + 1];
    var r22 = getInt32Memory0()[retptr / 4 + 2];
    var r32 = getInt32Memory0()[retptr / 4 + 3];
    if (r32) {
      throw takeObject(r22);
    }
    var v12 = getArrayU8FromWasm0(r02, r12).slice();
    wasm.__wbindgen_free(r02, r12 * 1);
    return v12;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
async function load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e11) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e11);
        } else {
          throw e11;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
async function init2(input) {
  if (typeof input === "undefined") {
    input = new URL("brotli_wasm_bg.wasm", import.meta.url);
  }
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_json_serialize = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = JSON.stringify(obj === void 0 ? null : obj);
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbg_new_693216e109162396 = function() {
    const ret = new Error();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_stack_0ddaca5d1abfb52f = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbg_error_09919627ac0992f5 = function(arg0, arg1) {
    try {
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_free(arg0, arg1);
    }
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  const { instance, module: module2 } = await load(await input, imports);
  wasm = instance.exports;
  init2.__wbindgen_wasm_module = module2;
  return wasm;
}
var wasm, heap, cachedTextDecoder, cachegetUint8Memory0, heap_next, WASM_VECTOR_LEN, cachedTextEncoder, encodeString, cachegetInt32Memory0, stack_pointer, BrotliStreamResultCode, BrotliStreamResult, CompressStream, DecompressStream, brotli_wasm_default;
var init_brotli_wasm = __esm({
  "node_modules/brotli-wasm/pkg.web/brotli_wasm.js"() {
    heap = new Array(32).fill(void 0);
    heap.push(void 0, null, true, false);
    cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    cachegetUint8Memory0 = null;
    heap_next = heap.length;
    WASM_VECTOR_LEN = 0;
    cachedTextEncoder = new TextEncoder("utf-8");
    encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    cachegetInt32Memory0 = null;
    stack_pointer = 32;
    BrotliStreamResultCode = Object.freeze({ ResultSuccess: 1, "1": "ResultSuccess", NeedsMoreInput: 2, "2": "NeedsMoreInput", NeedsMoreOutput: 3, "3": "NeedsMoreOutput" });
    BrotliStreamResult = class _BrotliStreamResult {
      static __wrap(ptr) {
        const obj = Object.create(_BrotliStreamResult.prototype);
        obj.ptr = ptr;
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_brotlistreamresult_free(ptr);
      }
      /**
      * Result code.
      *
      * See [`BrotliStreamResultCode`] for available values.
      *
      * When error, the error code is not passed here but rather goes to `Err`.
      */
      get code() {
        const ret = wasm.__wbg_get_brotlistreamresult_code(this.ptr);
        return ret >>> 0;
      }
      /**
      * Result code.
      *
      * See [`BrotliStreamResultCode`] for available values.
      *
      * When error, the error code is not passed here but rather goes to `Err`.
      * @param {number} arg0
      */
      set code(arg0) {
        wasm.__wbg_set_brotlistreamresult_code(this.ptr, arg0);
      }
      /**
      * Output buffer
      */
      get buf() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.__wbg_get_brotlistreamresult_buf(retptr, this.ptr);
          var r02 = getInt32Memory0()[retptr / 4 + 0];
          var r12 = getInt32Memory0()[retptr / 4 + 1];
          var v02 = getArrayU8FromWasm0(r02, r12).slice();
          wasm.__wbindgen_free(r02, r12 * 1);
          return v02;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * Output buffer
      * @param {Uint8Array} arg0
      */
      set buf(arg0) {
        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_brotlistreamresult_buf(this.ptr, ptr0, len0);
      }
      /**
      * Consumed bytes of the input buffer
      */
      get input_offset() {
        const ret = wasm.__wbg_get_brotlistreamresult_input_offset(this.ptr);
        return ret >>> 0;
      }
      /**
      * Consumed bytes of the input buffer
      * @param {number} arg0
      */
      set input_offset(arg0) {
        wasm.__wbg_set_brotlistreamresult_input_offset(this.ptr, arg0);
      }
    };
    CompressStream = class _CompressStream {
      static __wrap(ptr) {
        const obj = Object.create(_CompressStream.prototype);
        obj.ptr = ptr;
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_compressstream_free(ptr);
      }
      /**
      * @param {number | undefined} quality
      */
      constructor(quality) {
        const ret = wasm.compressstream_new(!isLikeNone(quality), isLikeNone(quality) ? 0 : quality);
        return _CompressStream.__wrap(ret);
      }
      /**
      * @param {Uint8Array | undefined} input_opt
      * @param {number} output_size
      * @returns {BrotliStreamResult}
      */
      compress(input_opt, output_size) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          var ptr0 = isLikeNone(input_opt) ? 0 : passArray8ToWasm0(input_opt, wasm.__wbindgen_malloc);
          var len0 = WASM_VECTOR_LEN;
          wasm.compressstream_compress(retptr, this.ptr, ptr0, len0, output_size);
          var r02 = getInt32Memory0()[retptr / 4 + 0];
          var r12 = getInt32Memory0()[retptr / 4 + 1];
          var r22 = getInt32Memory0()[retptr / 4 + 2];
          if (r22) {
            throw takeObject(r12);
          }
          return BrotliStreamResult.__wrap(r02);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @returns {number}
      */
      total_out() {
        const ret = wasm.compressstream_total_out(this.ptr);
        return ret >>> 0;
      }
    };
    DecompressStream = class _DecompressStream {
      static __wrap(ptr) {
        const obj = Object.create(_DecompressStream.prototype);
        obj.ptr = ptr;
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_decompressstream_free(ptr);
      }
      /**
      */
      constructor() {
        const ret = wasm.decompressstream_new();
        return _DecompressStream.__wrap(ret);
      }
      /**
      * @param {Uint8Array} input
      * @param {number} output_size
      * @returns {BrotliStreamResult}
      */
      decompress(input, output_size) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);
          const len0 = WASM_VECTOR_LEN;
          wasm.decompressstream_decompress(retptr, this.ptr, ptr0, len0, output_size);
          var r02 = getInt32Memory0()[retptr / 4 + 0];
          var r12 = getInt32Memory0()[retptr / 4 + 1];
          var r22 = getInt32Memory0()[retptr / 4 + 2];
          if (r22) {
            throw takeObject(r12);
          }
          return BrotliStreamResult.__wrap(r02);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @returns {number}
      */
      total_out() {
        const ret = wasm.decompressstream_total_out(this.ptr);
        return ret >>> 0;
      }
    };
    brotli_wasm_default = init2;
  }
});

// node_modules/brotli-wasm/index.web.js
var index_web_exports = {};
__export(index_web_exports, {
  default: () => index_web_default
});
var index_web_default;
var init_index_web = __esm({
  "node_modules/brotli-wasm/index.web.js"() {
    init_brotli_wasm();
    index_web_default = brotli_wasm_default().then(() => brotli_wasm_exports);
  }
});

// node_modules/almostnode/node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s10, w) => {
  s10.pending_buf[s10.pending++] = w & 255;
  s10.pending_buf[s10.pending++] = w >>> 8 & 255;
};
var send_bits = (s10, value2, length2) => {
  if (s10.bi_valid > Buf_size - length2) {
    s10.bi_buf |= value2 << s10.bi_valid & 65535;
    put_short(s10, s10.bi_buf);
    s10.bi_buf = value2 >> Buf_size - s10.bi_valid;
    s10.bi_valid += length2 - Buf_size;
  } else {
    s10.bi_buf |= value2 << s10.bi_valid & 65535;
    s10.bi_valid += length2;
  }
};
var send_code = (s10, c, tree) => {
  send_bits(
    s10,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code2, len) => {
  let res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s10) => {
  if (s10.bi_valid === 16) {
    put_short(s10, s10.bi_buf);
    s10.bi_buf = 0;
    s10.bi_valid = 0;
  } else if (s10.bi_valid >= 8) {
    s10.pending_buf[s10.pending++] = s10.bi_buf & 255;
    s10.bi_buf >>= 8;
    s10.bi_valid -= 8;
  }
};
var gen_bitlen = (s10, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n10, m;
  let bits;
  let xbits;
  let f10;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s10.bl_count[bits] = 0;
  }
  tree[s10.heap[s10.heap_max] * 2 + 1] = 0;
  for (h = s10.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n10 = s10.heap[h];
    bits = tree[tree[n10 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n10 * 2 + 1] = bits;
    if (n10 > max_code) {
      continue;
    }
    s10.bl_count[bits]++;
    xbits = 0;
    if (n10 >= base) {
      xbits = extra[n10 - base];
    }
    f10 = tree[n10 * 2];
    s10.opt_len += f10 * (bits + xbits);
    if (has_stree) {
      s10.static_len += f10 * (stree[n10 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s10.bl_count[bits] === 0) {
      bits--;
    }
    s10.bl_count[bits]--;
    s10.bl_count[bits + 1] += 2;
    s10.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n10 = s10.bl_count[bits];
    while (n10 !== 0) {
      m = s10.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s10.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n10--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code2 = 0;
  let bits;
  let n10;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code2 = code2 + bl_count[bits - 1] << 1;
    next_code[bits] = code2;
  }
  for (n10 = 0; n10 <= max_code; n10++) {
    let len = tree[n10 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n10 * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n10;
  let bits;
  let length2;
  let code2;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length2 = 0;
  for (code2 = 0; code2 < LENGTH_CODES$1 - 1; code2++) {
    base_length[code2] = length2;
    for (n10 = 0; n10 < 1 << extra_lbits[code2]; n10++) {
      _length_code[length2++] = code2;
    }
  }
  _length_code[length2 - 1] = code2;
  dist = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist[code2] = dist;
    for (n10 = 0; n10 < 1 << extra_dbits[code2]; n10++) {
      _dist_code[dist++] = code2;
    }
  }
  dist >>= 7;
  for (; code2 < D_CODES$1; code2++) {
    base_dist[code2] = dist << 7;
    for (n10 = 0; n10 < 1 << extra_dbits[code2] - 7; n10++) {
      _dist_code[256 + dist++] = code2;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n10 = 0;
  while (n10 <= 143) {
    static_ltree[n10 * 2 + 1] = 8;
    n10++;
    bl_count[8]++;
  }
  while (n10 <= 255) {
    static_ltree[n10 * 2 + 1] = 9;
    n10++;
    bl_count[9]++;
  }
  while (n10 <= 279) {
    static_ltree[n10 * 2 + 1] = 7;
    n10++;
    bl_count[7]++;
  }
  while (n10 <= 287) {
    static_ltree[n10 * 2 + 1] = 8;
    n10++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n10 = 0; n10 < D_CODES$1; n10++) {
    static_dtree[n10 * 2 + 1] = 5;
    static_dtree[n10 * 2] = bi_reverse(n10, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s10) => {
  let n10;
  for (n10 = 0; n10 < L_CODES$1; n10++) {
    s10.dyn_ltree[n10 * 2] = 0;
  }
  for (n10 = 0; n10 < D_CODES$1; n10++) {
    s10.dyn_dtree[n10 * 2] = 0;
  }
  for (n10 = 0; n10 < BL_CODES$1; n10++) {
    s10.bl_tree[n10 * 2] = 0;
  }
  s10.dyn_ltree[END_BLOCK * 2] = 1;
  s10.opt_len = s10.static_len = 0;
  s10.sym_next = s10.matches = 0;
};
var bi_windup = (s10) => {
  if (s10.bi_valid > 8) {
    put_short(s10, s10.bi_buf);
  } else if (s10.bi_valid > 0) {
    s10.pending_buf[s10.pending++] = s10.bi_buf;
  }
  s10.bi_buf = 0;
  s10.bi_valid = 0;
};
var smaller = (tree, n10, m, depth) => {
  const _n2 = n10 * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n10] <= depth[m];
};
var pqdownheap = (s10, tree, k) => {
  const v = s10.heap[k];
  let j = k << 1;
  while (j <= s10.heap_len) {
    if (j < s10.heap_len && smaller(tree, s10.heap[j + 1], s10.heap[j], s10.depth)) {
      j++;
    }
    if (smaller(tree, v, s10.heap[j], s10.depth)) {
      break;
    }
    s10.heap[k] = s10.heap[j];
    k = j;
    j <<= 1;
  }
  s10.heap[k] = v;
};
var compress_block = (s10, ltree, dtree) => {
  let dist;
  let lc2;
  let sx2 = 0;
  let code2;
  let extra;
  if (s10.sym_next !== 0) {
    do {
      dist = s10.pending_buf[s10.sym_buf + sx2++] & 255;
      dist += (s10.pending_buf[s10.sym_buf + sx2++] & 255) << 8;
      lc2 = s10.pending_buf[s10.sym_buf + sx2++];
      if (dist === 0) {
        send_code(s10, lc2, ltree);
      } else {
        code2 = _length_code[lc2];
        send_code(s10, code2 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code2];
        if (extra !== 0) {
          lc2 -= base_length[code2];
          send_bits(s10, lc2, extra);
        }
        dist--;
        code2 = d_code(dist);
        send_code(s10, code2, dtree);
        extra = extra_dbits[code2];
        if (extra !== 0) {
          dist -= base_dist[code2];
          send_bits(s10, dist, extra);
        }
      }
    } while (sx2 < s10.sym_next);
  }
  send_code(s10, END_BLOCK, ltree);
};
var build_tree = (s10, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n10, m;
  let max_code = -1;
  let node2;
  s10.heap_len = 0;
  s10.heap_max = HEAP_SIZE$1;
  for (n10 = 0; n10 < elems; n10++) {
    if (tree[n10 * 2] !== 0) {
      s10.heap[++s10.heap_len] = max_code = n10;
      s10.depth[n10] = 0;
    } else {
      tree[n10 * 2 + 1] = 0;
    }
  }
  while (s10.heap_len < 2) {
    node2 = s10.heap[++s10.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node2 * 2] = 1;
    s10.depth[node2] = 0;
    s10.opt_len--;
    if (has_stree) {
      s10.static_len -= stree[node2 * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n10 = s10.heap_len >> 1; n10 >= 1; n10--) {
    pqdownheap(s10, tree, n10);
  }
  node2 = elems;
  do {
    n10 = s10.heap[
      1
      /*SMALLEST*/
    ];
    s10.heap[
      1
      /*SMALLEST*/
    ] = s10.heap[s10.heap_len--];
    pqdownheap(
      s10,
      tree,
      1
      /*SMALLEST*/
    );
    m = s10.heap[
      1
      /*SMALLEST*/
    ];
    s10.heap[--s10.heap_max] = n10;
    s10.heap[--s10.heap_max] = m;
    tree[node2 * 2] = tree[n10 * 2] + tree[m * 2];
    s10.depth[node2] = (s10.depth[n10] >= s10.depth[m] ? s10.depth[n10] : s10.depth[m]) + 1;
    tree[n10 * 2 + 1] = tree[m * 2 + 1] = node2;
    s10.heap[
      1
      /*SMALLEST*/
    ] = node2++;
    pqdownheap(
      s10,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s10.heap_len >= 2);
  s10.heap[--s10.heap_max] = s10.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s10, desc);
  gen_codes(tree, max_code, s10.bl_count);
};
var scan_tree = (s10, tree, max_code) => {
  let n10;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n10 = 0; n10 <= max_code; n10++) {
    curlen = nextlen;
    nextlen = tree[(n10 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s10.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s10.bl_tree[curlen * 2]++;
      }
      s10.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s10.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s10.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s10, tree, max_code) => {
  let n10;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n10 = 0; n10 <= max_code; n10++) {
    curlen = nextlen;
    nextlen = tree[(n10 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s10, curlen, s10.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s10, curlen, s10.bl_tree);
        count--;
      }
      send_code(s10, REP_3_6, s10.bl_tree);
      send_bits(s10, count - 3, 2);
    } else if (count <= 10) {
      send_code(s10, REPZ_3_10, s10.bl_tree);
      send_bits(s10, count - 3, 3);
    } else {
      send_code(s10, REPZ_11_138, s10.bl_tree);
      send_bits(s10, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s10) => {
  let max_blindex;
  scan_tree(s10, s10.dyn_ltree, s10.l_desc.max_code);
  scan_tree(s10, s10.dyn_dtree, s10.d_desc.max_code);
  build_tree(s10, s10.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s10.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s10.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s10, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s10, lcodes - 257, 5);
  send_bits(s10, dcodes - 1, 5);
  send_bits(s10, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s10, s10.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s10, s10.dyn_ltree, lcodes - 1);
  send_tree(s10, s10.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s10) => {
  let block_mask = 4093624447;
  let n10;
  for (n10 = 0; n10 <= 31; n10++, block_mask >>>= 1) {
    if (block_mask & 1 && s10.dyn_ltree[n10 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s10.dyn_ltree[9 * 2] !== 0 || s10.dyn_ltree[10 * 2] !== 0 || s10.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n10 = 32; n10 < LITERALS$1; n10++) {
    if (s10.dyn_ltree[n10 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s10) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s10.l_desc = new TreeDesc(s10.dyn_ltree, static_l_desc);
  s10.d_desc = new TreeDesc(s10.dyn_dtree, static_d_desc);
  s10.bl_desc = new TreeDesc(s10.bl_tree, static_bl_desc);
  s10.bi_buf = 0;
  s10.bi_valid = 0;
  init_block(s10);
};
var _tr_stored_block$1 = (s10, buf, stored_len, last) => {
  send_bits(s10, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s10);
  put_short(s10, stored_len);
  put_short(s10, ~stored_len);
  if (stored_len) {
    s10.pending_buf.set(s10.window.subarray(buf, buf + stored_len), s10.pending);
  }
  s10.pending += stored_len;
};
var _tr_align$1 = (s10) => {
  send_bits(s10, STATIC_TREES << 1, 3);
  send_code(s10, END_BLOCK, static_ltree);
  bi_flush(s10);
};
var _tr_flush_block$1 = (s10, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s10.level > 0) {
    if (s10.strm.data_type === Z_UNKNOWN$1) {
      s10.strm.data_type = detect_data_type(s10);
    }
    build_tree(s10, s10.l_desc);
    build_tree(s10, s10.d_desc);
    max_blindex = build_bl_tree(s10);
    opt_lenb = s10.opt_len + 3 + 7 >>> 3;
    static_lenb = s10.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s10, buf, stored_len, last);
  } else if (s10.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s10, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s10, static_ltree, static_dtree);
  } else {
    send_bits(s10, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s10, s10.l_desc.max_code + 1, s10.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s10, s10.dyn_ltree, s10.dyn_dtree);
  }
  init_block(s10);
  if (last) {
    bi_windup(s10);
  }
};
var _tr_tally$1 = (s10, dist, lc2) => {
  s10.pending_buf[s10.sym_buf + s10.sym_next++] = dist;
  s10.pending_buf[s10.sym_buf + s10.sym_next++] = dist >> 8;
  s10.pending_buf[s10.sym_buf + s10.sym_next++] = lc2;
  if (dist === 0) {
    s10.dyn_ltree[lc2 * 2]++;
  } else {
    s10.matches++;
    dist--;
    s10.dyn_ltree[(_length_code[lc2] + LITERALS$1 + 1) * 2]++;
    s10.dyn_dtree[d_code(dist) * 2]++;
  }
  return s10.sym_next === s10.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s12 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n10 = 0;
  while (len !== 0) {
    n10 = len > 2e3 ? 2e3 : len;
    len -= n10;
    do {
      s12 = s12 + buf[pos++] | 0;
      s22 = s22 + s12 | 0;
    } while (--n10);
    s12 %= 65521;
    s22 %= 65521;
  }
  return s12 | s22 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n10 = 0; n10 < 256; n10++) {
    c = n10;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n10] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t10 = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i10 = pos; i10 < end; i10++) {
    crc = crc >>> 8 ^ t10[(crc ^ buf[i10]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$22 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$22;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f10) => {
  return f10 * 2 - (f10 > 4 ? 9 : 0);
};
var zero2 = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s10) => {
  let n10, m;
  let p;
  let wsize = s10.w_size;
  n10 = s10.hash_size;
  p = n10;
  do {
    m = s10.head[--p];
    s10.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n10);
  n10 = wsize;
  p = n10;
  do {
    m = s10.prev[--p];
    s10.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n10);
};
var HASH_ZLIB = (s10, prev, data2) => (prev << s10.hash_shift ^ data2) & s10.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s10 = strm.state;
  let len = s10.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s10.pending_buf.subarray(s10.pending_out, s10.pending_out + len), strm.next_out);
  strm.next_out += len;
  s10.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s10.pending -= len;
  if (s10.pending === 0) {
    s10.pending_out = 0;
  }
};
var flush_block_only = (s10, last) => {
  _tr_flush_block(s10, s10.block_start >= 0 ? s10.block_start : -1, s10.strstart - s10.block_start, last);
  s10.block_start = s10.strstart;
  flush_pending(s10.strm);
};
var put_byte = (s10, b) => {
  s10.pending_buf[s10.pending++] = b;
};
var putShortMSB = (s10, b) => {
  s10.pending_buf[s10.pending++] = b >>> 8 & 255;
  s10.pending_buf[s10.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s10, cur_match) => {
  let chain_length = s10.max_chain_length;
  let scan = s10.strstart;
  let match2;
  let len;
  let best_len = s10.prev_length;
  let nice_match = s10.nice_match;
  const limit = s10.strstart > s10.w_size - MIN_LOOKAHEAD ? s10.strstart - (s10.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s10.window;
  const wmask = s10.w_mask;
  const prev = s10.prev;
  const strend = s10.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s10.prev_length >= s10.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s10.lookahead) {
    nice_match = s10.lookahead;
  }
  do {
    match2 = cur_match;
    if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match2++;
    do {
    } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s10.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s10.lookahead) {
    return best_len;
  }
  return s10.lookahead;
};
var fill_window = (s10) => {
  const _w_size = s10.w_size;
  let n10, more, str;
  do {
    more = s10.window_size - s10.lookahead - s10.strstart;
    if (s10.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s10.window.set(s10.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s10.match_start -= _w_size;
      s10.strstart -= _w_size;
      s10.block_start -= _w_size;
      if (s10.insert > s10.strstart) {
        s10.insert = s10.strstart;
      }
      slide_hash(s10);
      more += _w_size;
    }
    if (s10.strm.avail_in === 0) {
      break;
    }
    n10 = read_buf(s10.strm, s10.window, s10.strstart + s10.lookahead, more);
    s10.lookahead += n10;
    if (s10.lookahead + s10.insert >= MIN_MATCH) {
      str = s10.strstart - s10.insert;
      s10.ins_h = s10.window[str];
      s10.ins_h = HASH(s10, s10.ins_h, s10.window[str + 1]);
      while (s10.insert) {
        s10.ins_h = HASH(s10, s10.ins_h, s10.window[str + MIN_MATCH - 1]);
        s10.prev[str & s10.w_mask] = s10.head[s10.ins_h];
        s10.head[s10.ins_h] = str;
        str++;
        s10.insert--;
        if (s10.lookahead + s10.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s10.lookahead < MIN_LOOKAHEAD && s10.strm.avail_in !== 0);
};
var deflate_stored = (s10, flush2) => {
  let min_block = s10.pending_buf_size - 5 > s10.w_size ? s10.w_size : s10.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s10.strm.avail_in;
  do {
    len = 65535;
    have = s10.bi_valid + 42 >> 3;
    if (s10.strm.avail_out < have) {
      break;
    }
    have = s10.strm.avail_out - have;
    left = s10.strstart - s10.block_start;
    if (len > left + s10.strm.avail_in) {
      len = left + s10.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush2 !== Z_FINISH$3 || flush2 === Z_NO_FLUSH$2 || len !== left + s10.strm.avail_in)) {
      break;
    }
    last = flush2 === Z_FINISH$3 && len === left + s10.strm.avail_in ? 1 : 0;
    _tr_stored_block(s10, 0, 0, last);
    s10.pending_buf[s10.pending - 4] = len;
    s10.pending_buf[s10.pending - 3] = len >> 8;
    s10.pending_buf[s10.pending - 2] = ~len;
    s10.pending_buf[s10.pending - 1] = ~len >> 8;
    flush_pending(s10.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s10.strm.output.set(s10.window.subarray(s10.block_start, s10.block_start + left), s10.strm.next_out);
      s10.strm.next_out += left;
      s10.strm.avail_out -= left;
      s10.strm.total_out += left;
      s10.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s10.strm, s10.strm.output, s10.strm.next_out, len);
      s10.strm.next_out += len;
      s10.strm.avail_out -= len;
      s10.strm.total_out += len;
    }
  } while (last === 0);
  used -= s10.strm.avail_in;
  if (used) {
    if (used >= s10.w_size) {
      s10.matches = 2;
      s10.window.set(s10.strm.input.subarray(s10.strm.next_in - s10.w_size, s10.strm.next_in), 0);
      s10.strstart = s10.w_size;
      s10.insert = s10.strstart;
    } else {
      if (s10.window_size - s10.strstart <= used) {
        s10.strstart -= s10.w_size;
        s10.window.set(s10.window.subarray(s10.w_size, s10.w_size + s10.strstart), 0);
        if (s10.matches < 2) {
          s10.matches++;
        }
        if (s10.insert > s10.strstart) {
          s10.insert = s10.strstart;
        }
      }
      s10.window.set(s10.strm.input.subarray(s10.strm.next_in - used, s10.strm.next_in), s10.strstart);
      s10.strstart += used;
      s10.insert += used > s10.w_size - s10.insert ? s10.w_size - s10.insert : used;
    }
    s10.block_start = s10.strstart;
  }
  if (s10.high_water < s10.strstart) {
    s10.high_water = s10.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush2 !== Z_NO_FLUSH$2 && flush2 !== Z_FINISH$3 && s10.strm.avail_in === 0 && s10.strstart === s10.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s10.window_size - s10.strstart;
  if (s10.strm.avail_in > have && s10.block_start >= s10.w_size) {
    s10.block_start -= s10.w_size;
    s10.strstart -= s10.w_size;
    s10.window.set(s10.window.subarray(s10.w_size, s10.w_size + s10.strstart), 0);
    if (s10.matches < 2) {
      s10.matches++;
    }
    have += s10.w_size;
    if (s10.insert > s10.strstart) {
      s10.insert = s10.strstart;
    }
  }
  if (have > s10.strm.avail_in) {
    have = s10.strm.avail_in;
  }
  if (have) {
    read_buf(s10.strm, s10.window, s10.strstart, have);
    s10.strstart += have;
    s10.insert += have > s10.w_size - s10.insert ? s10.w_size - s10.insert : have;
  }
  if (s10.high_water < s10.strstart) {
    s10.high_water = s10.strstart;
  }
  have = s10.bi_valid + 42 >> 3;
  have = s10.pending_buf_size - have > 65535 ? 65535 : s10.pending_buf_size - have;
  min_block = have > s10.w_size ? s10.w_size : have;
  left = s10.strstart - s10.block_start;
  if (left >= min_block || (left || flush2 === Z_FINISH$3) && flush2 !== Z_NO_FLUSH$2 && s10.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush2 === Z_FINISH$3 && s10.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s10, s10.block_start, len, last);
    s10.block_start += len;
    flush_pending(s10.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s10, flush2) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s10.lookahead < MIN_LOOKAHEAD) {
      fill_window(s10);
      if (s10.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s10.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s10.lookahead >= MIN_MATCH) {
      s10.ins_h = HASH(s10, s10.ins_h, s10.window[s10.strstart + MIN_MATCH - 1]);
      hash_head = s10.prev[s10.strstart & s10.w_mask] = s10.head[s10.ins_h];
      s10.head[s10.ins_h] = s10.strstart;
    }
    if (hash_head !== 0 && s10.strstart - hash_head <= s10.w_size - MIN_LOOKAHEAD) {
      s10.match_length = longest_match(s10, hash_head);
    }
    if (s10.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s10, s10.strstart - s10.match_start, s10.match_length - MIN_MATCH);
      s10.lookahead -= s10.match_length;
      if (s10.match_length <= s10.max_lazy_match && s10.lookahead >= MIN_MATCH) {
        s10.match_length--;
        do {
          s10.strstart++;
          s10.ins_h = HASH(s10, s10.ins_h, s10.window[s10.strstart + MIN_MATCH - 1]);
          hash_head = s10.prev[s10.strstart & s10.w_mask] = s10.head[s10.ins_h];
          s10.head[s10.ins_h] = s10.strstart;
        } while (--s10.match_length !== 0);
        s10.strstart++;
      } else {
        s10.strstart += s10.match_length;
        s10.match_length = 0;
        s10.ins_h = s10.window[s10.strstart];
        s10.ins_h = HASH(s10, s10.ins_h, s10.window[s10.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s10, 0, s10.window[s10.strstart]);
      s10.lookahead--;
      s10.strstart++;
    }
    if (bflush) {
      flush_block_only(s10, false);
      if (s10.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s10.insert = s10.strstart < MIN_MATCH - 1 ? s10.strstart : MIN_MATCH - 1;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s10, true);
    if (s10.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s10.sym_next) {
    flush_block_only(s10, false);
    if (s10.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s10, flush2) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s10.lookahead < MIN_LOOKAHEAD) {
      fill_window(s10);
      if (s10.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s10.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s10.lookahead >= MIN_MATCH) {
      s10.ins_h = HASH(s10, s10.ins_h, s10.window[s10.strstart + MIN_MATCH - 1]);
      hash_head = s10.prev[s10.strstart & s10.w_mask] = s10.head[s10.ins_h];
      s10.head[s10.ins_h] = s10.strstart;
    }
    s10.prev_length = s10.match_length;
    s10.prev_match = s10.match_start;
    s10.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s10.prev_length < s10.max_lazy_match && s10.strstart - hash_head <= s10.w_size - MIN_LOOKAHEAD) {
      s10.match_length = longest_match(s10, hash_head);
      if (s10.match_length <= 5 && (s10.strategy === Z_FILTERED || s10.match_length === MIN_MATCH && s10.strstart - s10.match_start > 4096)) {
        s10.match_length = MIN_MATCH - 1;
      }
    }
    if (s10.prev_length >= MIN_MATCH && s10.match_length <= s10.prev_length) {
      max_insert = s10.strstart + s10.lookahead - MIN_MATCH;
      bflush = _tr_tally(s10, s10.strstart - 1 - s10.prev_match, s10.prev_length - MIN_MATCH);
      s10.lookahead -= s10.prev_length - 1;
      s10.prev_length -= 2;
      do {
        if (++s10.strstart <= max_insert) {
          s10.ins_h = HASH(s10, s10.ins_h, s10.window[s10.strstart + MIN_MATCH - 1]);
          hash_head = s10.prev[s10.strstart & s10.w_mask] = s10.head[s10.ins_h];
          s10.head[s10.ins_h] = s10.strstart;
        }
      } while (--s10.prev_length !== 0);
      s10.match_available = 0;
      s10.match_length = MIN_MATCH - 1;
      s10.strstart++;
      if (bflush) {
        flush_block_only(s10, false);
        if (s10.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s10.match_available) {
      bflush = _tr_tally(s10, 0, s10.window[s10.strstart - 1]);
      if (bflush) {
        flush_block_only(s10, false);
      }
      s10.strstart++;
      s10.lookahead--;
      if (s10.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s10.match_available = 1;
      s10.strstart++;
      s10.lookahead--;
    }
  }
  if (s10.match_available) {
    bflush = _tr_tally(s10, 0, s10.window[s10.strstart - 1]);
    s10.match_available = 0;
  }
  s10.insert = s10.strstart < MIN_MATCH - 1 ? s10.strstart : MIN_MATCH - 1;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s10, true);
    if (s10.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s10.sym_next) {
    flush_block_only(s10, false);
    if (s10.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s10, flush2) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s10.window;
  for (; ; ) {
    if (s10.lookahead <= MAX_MATCH) {
      fill_window(s10);
      if (s10.lookahead <= MAX_MATCH && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s10.lookahead === 0) {
        break;
      }
    }
    s10.match_length = 0;
    if (s10.lookahead >= MIN_MATCH && s10.strstart > 0) {
      scan = s10.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s10.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s10.match_length = MAX_MATCH - (strend - scan);
        if (s10.match_length > s10.lookahead) {
          s10.match_length = s10.lookahead;
        }
      }
    }
    if (s10.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s10, 1, s10.match_length - MIN_MATCH);
      s10.lookahead -= s10.match_length;
      s10.strstart += s10.match_length;
      s10.match_length = 0;
    } else {
      bflush = _tr_tally(s10, 0, s10.window[s10.strstart]);
      s10.lookahead--;
      s10.strstart++;
    }
    if (bflush) {
      flush_block_only(s10, false);
      if (s10.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s10.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s10, true);
    if (s10.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s10.sym_next) {
    flush_block_only(s10, false);
    if (s10.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s10, flush2) => {
  let bflush;
  for (; ; ) {
    if (s10.lookahead === 0) {
      fill_window(s10);
      if (s10.lookahead === 0) {
        if (flush2 === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s10.match_length = 0;
    bflush = _tr_tally(s10, 0, s10.window[s10.strstart]);
    s10.lookahead--;
    s10.strstart++;
    if (bflush) {
      flush_block_only(s10, false);
      if (s10.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s10.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s10, true);
    if (s10.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s10.sym_next) {
    flush_block_only(s10, false);
    if (s10.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s10) => {
  s10.window_size = 2 * s10.w_size;
  zero2(s10.head);
  s10.max_lazy_match = configuration_table[s10.level].max_lazy;
  s10.good_match = configuration_table[s10.level].good_length;
  s10.nice_match = configuration_table[s10.level].nice_length;
  s10.max_chain_length = configuration_table[s10.level].max_chain;
  s10.strstart = 0;
  s10.block_start = 0;
  s10.lookahead = 0;
  s10.insert = 0;
  s10.match_length = s10.prev_length = MIN_MATCH - 1;
  s10.match_available = 0;
  s10.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero2(this.dyn_ltree);
  zero2(this.dyn_dtree);
  zero2(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero2(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero2(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s10 = strm.state;
  if (!s10 || s10.strm !== strm || s10.status !== INIT_STATE && //#ifdef GZIP
  s10.status !== GZIP_STATE && //#endif
  s10.status !== EXTRA_STATE && s10.status !== NAME_STATE && s10.status !== COMMENT_STATE && s10.status !== HCRC_STATE && s10.status !== BUSY_STATE && s10.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s10 = strm.state;
  s10.pending = 0;
  s10.pending_out = 0;
  if (s10.wrap < 0) {
    s10.wrap = -s10.wrap;
  }
  s10.status = //#ifdef GZIP
  s10.wrap === 2 ? GZIP_STATE : (
    //#endif
    s10.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s10.wrap === 2 ? 0 : 1;
  s10.last_flush = -2;
  _tr_init(s10);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap2 !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s10 = new DeflateState();
  strm.state = s10;
  s10.strm = strm;
  s10.status = INIT_STATE;
  s10.wrap = wrap2;
  s10.gzhead = null;
  s10.w_bits = windowBits;
  s10.w_size = 1 << s10.w_bits;
  s10.w_mask = s10.w_size - 1;
  s10.hash_bits = memLevel + 7;
  s10.hash_size = 1 << s10.hash_bits;
  s10.hash_mask = s10.hash_size - 1;
  s10.hash_shift = ~~((s10.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s10.window = new Uint8Array(s10.w_size * 2);
  s10.head = new Uint16Array(s10.hash_size);
  s10.prev = new Uint16Array(s10.w_size);
  s10.lit_bufsize = 1 << memLevel + 6;
  s10.pending_buf_size = s10.lit_bufsize * 4;
  s10.pending_buf = new Uint8Array(s10.pending_buf_size);
  s10.sym_buf = s10.lit_bufsize;
  s10.sym_end = (s10.lit_bufsize - 1) * 3;
  s10.level = level;
  s10.strategy = strategy;
  s10.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush2) => {
  if (deflateStateCheck(strm) || flush2 > Z_BLOCK$1 || flush2 < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s10 = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s10.status === FINISH_STATE && flush2 !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s10.last_flush;
  s10.last_flush = flush2;
  if (s10.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s10.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush2) <= rank(old_flush) && flush2 !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s10.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s10.status === INIT_STATE && s10.wrap === 0) {
    s10.status = BUSY_STATE;
  }
  if (s10.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s10.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s10.strategy >= Z_HUFFMAN_ONLY || s10.level < 2) {
      level_flags = 0;
    } else if (s10.level < 6) {
      level_flags = 1;
    } else if (s10.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s10.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s10, header);
    if (s10.strstart !== 0) {
      putShortMSB(s10, strm.adler >>> 16);
      putShortMSB(s10, strm.adler & 65535);
    }
    strm.adler = 1;
    s10.status = BUSY_STATE;
    flush_pending(strm);
    if (s10.pending !== 0) {
      s10.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s10.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s10, 31);
    put_byte(s10, 139);
    put_byte(s10, 8);
    if (!s10.gzhead) {
      put_byte(s10, 0);
      put_byte(s10, 0);
      put_byte(s10, 0);
      put_byte(s10, 0);
      put_byte(s10, 0);
      put_byte(s10, s10.level === 9 ? 2 : s10.strategy >= Z_HUFFMAN_ONLY || s10.level < 2 ? 4 : 0);
      put_byte(s10, OS_CODE);
      s10.status = BUSY_STATE;
      flush_pending(strm);
      if (s10.pending !== 0) {
        s10.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s10,
        (s10.gzhead.text ? 1 : 0) + (s10.gzhead.hcrc ? 2 : 0) + (!s10.gzhead.extra ? 0 : 4) + (!s10.gzhead.name ? 0 : 8) + (!s10.gzhead.comment ? 0 : 16)
      );
      put_byte(s10, s10.gzhead.time & 255);
      put_byte(s10, s10.gzhead.time >> 8 & 255);
      put_byte(s10, s10.gzhead.time >> 16 & 255);
      put_byte(s10, s10.gzhead.time >> 24 & 255);
      put_byte(s10, s10.level === 9 ? 2 : s10.strategy >= Z_HUFFMAN_ONLY || s10.level < 2 ? 4 : 0);
      put_byte(s10, s10.gzhead.os & 255);
      if (s10.gzhead.extra && s10.gzhead.extra.length) {
        put_byte(s10, s10.gzhead.extra.length & 255);
        put_byte(s10, s10.gzhead.extra.length >> 8 & 255);
      }
      if (s10.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s10.pending_buf, s10.pending, 0);
      }
      s10.gzindex = 0;
      s10.status = EXTRA_STATE;
    }
  }
  if (s10.status === EXTRA_STATE) {
    if (s10.gzhead.extra) {
      let beg = s10.pending;
      let left = (s10.gzhead.extra.length & 65535) - s10.gzindex;
      while (s10.pending + left > s10.pending_buf_size) {
        let copy = s10.pending_buf_size - s10.pending;
        s10.pending_buf.set(s10.gzhead.extra.subarray(s10.gzindex, s10.gzindex + copy), s10.pending);
        s10.pending = s10.pending_buf_size;
        if (s10.gzhead.hcrc && s10.pending > beg) {
          strm.adler = crc32_1(strm.adler, s10.pending_buf, s10.pending - beg, beg);
        }
        s10.gzindex += copy;
        flush_pending(strm);
        if (s10.pending !== 0) {
          s10.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s10.gzhead.extra);
      s10.pending_buf.set(gzhead_extra.subarray(s10.gzindex, s10.gzindex + left), s10.pending);
      s10.pending += left;
      if (s10.gzhead.hcrc && s10.pending > beg) {
        strm.adler = crc32_1(strm.adler, s10.pending_buf, s10.pending - beg, beg);
      }
      s10.gzindex = 0;
    }
    s10.status = NAME_STATE;
  }
  if (s10.status === NAME_STATE) {
    if (s10.gzhead.name) {
      let beg = s10.pending;
      let val;
      do {
        if (s10.pending === s10.pending_buf_size) {
          if (s10.gzhead.hcrc && s10.pending > beg) {
            strm.adler = crc32_1(strm.adler, s10.pending_buf, s10.pending - beg, beg);
          }
          flush_pending(strm);
          if (s10.pending !== 0) {
            s10.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s10.gzindex < s10.gzhead.name.length) {
          val = s10.gzhead.name.charCodeAt(s10.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s10, val);
      } while (val !== 0);
      if (s10.gzhead.hcrc && s10.pending > beg) {
        strm.adler = crc32_1(strm.adler, s10.pending_buf, s10.pending - beg, beg);
      }
      s10.gzindex = 0;
    }
    s10.status = COMMENT_STATE;
  }
  if (s10.status === COMMENT_STATE) {
    if (s10.gzhead.comment) {
      let beg = s10.pending;
      let val;
      do {
        if (s10.pending === s10.pending_buf_size) {
          if (s10.gzhead.hcrc && s10.pending > beg) {
            strm.adler = crc32_1(strm.adler, s10.pending_buf, s10.pending - beg, beg);
          }
          flush_pending(strm);
          if (s10.pending !== 0) {
            s10.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s10.gzindex < s10.gzhead.comment.length) {
          val = s10.gzhead.comment.charCodeAt(s10.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s10, val);
      } while (val !== 0);
      if (s10.gzhead.hcrc && s10.pending > beg) {
        strm.adler = crc32_1(strm.adler, s10.pending_buf, s10.pending - beg, beg);
      }
    }
    s10.status = HCRC_STATE;
  }
  if (s10.status === HCRC_STATE) {
    if (s10.gzhead.hcrc) {
      if (s10.pending + 2 > s10.pending_buf_size) {
        flush_pending(strm);
        if (s10.pending !== 0) {
          s10.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s10, strm.adler & 255);
      put_byte(s10, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s10.status = BUSY_STATE;
    flush_pending(strm);
    if (s10.pending !== 0) {
      s10.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s10.lookahead !== 0 || flush2 !== Z_NO_FLUSH$2 && s10.status !== FINISH_STATE) {
    let bstate = s10.level === 0 ? deflate_stored(s10, flush2) : s10.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s10, flush2) : s10.strategy === Z_RLE ? deflate_rle(s10, flush2) : configuration_table[s10.level].func(s10, flush2);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s10.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s10.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush2 === Z_PARTIAL_FLUSH) {
        _tr_align(s10);
      } else if (flush2 !== Z_BLOCK$1) {
        _tr_stored_block(s10, 0, 0, false);
        if (flush2 === Z_FULL_FLUSH$1) {
          zero2(s10.head);
          if (s10.lookahead === 0) {
            s10.strstart = 0;
            s10.block_start = 0;
            s10.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s10.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush2 !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s10.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s10.wrap === 2) {
    put_byte(s10, strm.adler & 255);
    put_byte(s10, strm.adler >> 8 & 255);
    put_byte(s10, strm.adler >> 16 & 255);
    put_byte(s10, strm.adler >> 24 & 255);
    put_byte(s10, strm.total_in & 255);
    put_byte(s10, strm.total_in >> 8 & 255);
    put_byte(s10, strm.total_in >> 16 & 255);
    put_byte(s10, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s10, strm.adler >>> 16);
    putShortMSB(s10, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s10.wrap > 0) {
    s10.wrap = -s10.wrap;
  }
  return s10.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s10 = strm.state;
  const wrap2 = s10.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s10.status !== INIT_STATE || s10.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap2 === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s10.wrap = 0;
  if (dictLength >= s10.w_size) {
    if (wrap2 === 0) {
      zero2(s10.head);
      s10.strstart = 0;
      s10.block_start = 0;
      s10.insert = 0;
    }
    let tmpDict = new Uint8Array(s10.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s10.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s10.w_size;
  }
  const avail = strm.avail_in;
  const next2 = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s10);
  while (s10.lookahead >= MIN_MATCH) {
    let str = s10.strstart;
    let n10 = s10.lookahead - (MIN_MATCH - 1);
    do {
      s10.ins_h = HASH(s10, s10.ins_h, s10.window[str + MIN_MATCH - 1]);
      s10.prev[str & s10.w_mask] = s10.head[s10.ins_h];
      s10.head[s10.ins_h] = str;
      str++;
    } while (--n10);
    s10.strstart = str;
    s10.lookahead = MIN_MATCH - 1;
    fill_window(s10);
  }
  s10.strstart += s10.lookahead;
  s10.block_start = s10.strstart;
  s10.insert = s10.lookahead;
  s10.lookahead = 0;
  s10.match_length = s10.prev_length = MIN_MATCH - 1;
  s10.match_available = 0;
  strm.next_in = next2;
  strm.input = input;
  strm.avail_in = avail;
  s10.wrap = wrap2;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i10 = 0, l = chunks.length; i10 < l; i10++) {
    len += chunks[i10].length;
  }
  const result = new Uint8Array(len);
  for (let i10 = 0, pos = 0, l = chunks.length; i10 < l; i10++) {
    let chunk = chunks[i10];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q5 = 0; q5 < 256; q5++) {
  _utf8len[q5] = q5 >= 252 ? 6 : q5 >= 248 ? 5 : q5 >= 240 ? 4 : q5 >= 224 ? 3 : q5 >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c22, m_pos, i10, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i10 = 0, m_pos = 0; i10 < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i10++] = c;
    } else if (c < 2048) {
      buf[i10++] = 192 | c >>> 6;
      buf[i10++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i10++] = 224 | c >>> 12;
      buf[i10++] = 128 | c >>> 6 & 63;
      buf[i10++] = 128 | c & 63;
    } else {
      buf[i10++] = 240 | c >>> 18;
      buf[i10++] = 128 | c >>> 12 & 63;
      buf[i10++] = 128 | c >>> 6 & 63;
      buf[i10++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i10 = 0; i10 < len; i10++) {
    result += String.fromCharCode(buf[i10]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i10, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i10 = 0; i10 < len; ) {
    let c = buf[i10++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i10 += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i10 < len) {
      c = c << 6 | buf[i10++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$22;
function Deflate$1(options2) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options2 || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data2 === "string") {
    strm.input = strings.string2buf(data2);
  } else if (toString$1.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options2) {
  const deflator = new Deflate$1(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return deflate$1(input, options2);
}
function gzip$1(input, options2) {
  options2 = options2 || {};
  options2.gzip = true;
  return deflate$1(input, options2);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$12 = constants$22;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$12
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op2;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op2 = here >>> 24;
          hold >>>= op2;
          bits -= op2;
          op2 = here >>> 16 & 255;
          if (op2 === 0) {
            output[_out++] = here & 65535;
          } else if (op2 & 16) {
            len = here & 65535;
            op2 &= 15;
            if (op2) {
              if (bits < op2) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op2) - 1;
              hold >>>= op2;
              bits -= op2;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op2 = here >>> 24;
                hold >>>= op2;
                bits -= op2;
                op2 = here >>> 16 & 255;
                if (op2 & 16) {
                  dist = here & 65535;
                  op2 &= 15;
                  if (bits < op2) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op2) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op2) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op2;
                  bits -= op2;
                  op2 = _out - beg;
                  if (dist > op2) {
                    op2 = dist - op2;
                    if (op2 > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op2;
                      if (op2 < len) {
                        len -= op2;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op2);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op2) {
                      from += wsize + wnext - op2;
                      op2 -= wnext;
                      if (op2 < len) {
                        len -= op2;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op2);
                        from = 0;
                        if (wnext < len) {
                          op2 = wnext;
                          len -= op2;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op2);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op2;
                      if (op2 < len) {
                        len -= op2;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op2);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op2 & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op2) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op2 & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op2) - 1)];
            continue dolen;
          } else if (op2 & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type2, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root2 = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next2;
  let base = null;
  let match2;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root2 = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root2 > max) {
    root2 = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root2 < min) {
    root2 = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base = extra = work;
    match2 = 20;
  } else if (type2 === LENS$1) {
    base = lbase;
    extra = lext;
    match2 = 257;
  } else {
    base = dbase;
    extra = dext;
    match2 = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next2 = table_index;
  curr = root2;
  drop = 0;
  low = -1;
  used = 1 << root2;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match2) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match2) {
      here_op = extra[work[sym] - match2];
      here_val = base[work[sym] - match2];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next2 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root2 && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root2;
      }
      next2 += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root2 << 24 | curr << 16 | next2 - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next2 + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root2;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$22;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH2 = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q5) => {
  return (q5 >>> 24 & 255) + (q5 >>> 8 & 65280) + ((q5 & 65280) << 8) + ((q5 & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap2;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap2;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush2) => {
  let state;
  let input, output;
  let next2;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n10;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next2 = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next2,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next2 + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next2);
              }
              have -= copy;
              next2 += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next2 + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next2);
            }
            have -= copy;
            next2 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next2 + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next2);
            }
            have -= copy;
            next2 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush2 === Z_BLOCK || flush2 === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush2 === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush2 === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next2, next2 + copy), put);
            have -= copy;
            next2 += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n10 = here_bits + 2;
                while (bits < n10) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n10 = here_bits + 3;
                while (bits < n10) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n10 = here_bits + 7;
                while (bits < n10) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush2 === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next2 = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n10 = state.extra;
            while (bits < n10) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n10 = state.extra;
            while (bits < n10) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH2;
        case MATCH2:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next2++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next2;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush2 !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush2 === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString2 = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$22;
function Inflate$1(options2) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options2 || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString2.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data2[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options2) {
  const inflator = new Inflate$1(options2);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return inflate$1(input, options2);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants2 = constants$22;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants: constants2
};
var { Deflate, deflate: deflate2, deflateRaw: deflateRaw2, gzip: gzip2 } = deflate_1$1;
var { Inflate, inflate: inflate2, inflateRaw: inflateRaw2, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate2;
var deflateRaw_1 = deflateRaw2;
var gzip_1 = gzip2;
var Inflate_1 = Inflate;
var inflate_1 = inflate2;
var inflateRaw_1 = inflateRaw2;
var ungzip_1 = ungzip;
var constants_1 = constants$22;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};

// node_modules/just-bash/dist/bundle/browser.js
var import_sprintf_js = __toESM(require_sprintf(), 1);

// node_modules/@isaacs/balanced-match/dist/esm/index.js
var balanced = (a, b, str) => {
  const ma2 = a instanceof RegExp ? maybeMatch(a, str) : a;
  const mb2 = b instanceof RegExp ? maybeMatch(b, str) : b;
  const r10 = ma2 !== null && mb2 != null && range(ma2, mb2, str);
  return r10 && {
    start: r10[0],
    end: r10[1],
    pre: str.slice(0, r10[0]),
    body: str.slice(r10[0] + ma2.length, r10[1]),
    post: str.slice(r10[1] + mb2.length)
  };
};
var maybeMatch = (reg, str) => {
  const m = str.match(reg);
  return m ? m[0] : null;
};
var range = (a, b, str) => {
  let begs, beg, left, right = void 0, result;
  let ai2 = str.indexOf(a);
  let bi2 = str.indexOf(b, ai2 + 1);
  let i10 = ai2;
  if (ai2 >= 0 && bi2 > 0) {
    if (a === b) {
      return [ai2, bi2];
    }
    begs = [];
    left = str.length;
    while (i10 >= 0 && !result) {
      if (i10 === ai2) {
        begs.push(i10);
        ai2 = str.indexOf(a, i10 + 1);
      } else if (begs.length === 1) {
        const r10 = begs.pop();
        if (r10 !== void 0)
          result = [r10, bi2];
      } else {
        beg = begs.pop();
        if (beg !== void 0 && beg < left) {
          left = beg;
          right = bi2;
        }
        bi2 = str.indexOf(b, i10 + 1);
      }
      i10 = ai2 < bi2 && ai2 >= 0 ? ai2 : bi2;
    }
    if (begs.length && right !== void 0) {
      result = [left, right];
    }
  }
  return result;
};

// node_modules/@isaacs/brace-expansion/dist/esm/index.js
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
var escSlashPattern = new RegExp(escSlash, "g");
var escOpenPattern = new RegExp(escOpen, "g");
var escClosePattern = new RegExp(escClose, "g");
var escCommaPattern = new RegExp(escComma, "g");
var escPeriodPattern = new RegExp(escPeriod, "g");
var slashPattern = /\\\\/g;
var openPattern = /\\{/g;
var closePattern = /\\}/g;
var commaPattern = /\\,/g;
var periodPattern = /\\./g;
var EXPANSION_MAX = 1e5;
function numeric(str) {
  return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
  return str.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
}
function parseCommaParts(str) {
  if (!str) {
    return [""];
  }
  const parts = [];
  const m = balanced("{", "}", str);
  if (!m) {
    return str.split(",");
  }
  const { pre, body, post } = m;
  const p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  const postParts = parseCommaParts(post);
  if (post.length) {
    ;
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expand(str, options2 = {}) {
  if (!str) {
    return [];
  }
  const { max = EXPANSION_MAX } = options2;
  if (str.slice(0, 2) === "{}") {
    str = "\\{\\}" + str.slice(2);
  }
  return expand_(escapeBraces(str), max, true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el2) {
  return /^-?0\d/.test(el2);
}
function lte(i10, y) {
  return i10 <= y;
}
function gte(i10, y) {
  return i10 >= y;
}
function expand_(str, max, isTop) {
  const expansions = [];
  const m = balanced("{", "}", str);
  if (!m)
    return [str];
  const pre = m.pre;
  const post = m.post.length ? expand_(m.post, max, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (let k = 0; k < post.length && k < max; k++) {
      const expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    const isSequence = isNumericSequence || isAlphaSequence;
    const isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,(?!,).*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand_(str, max, true);
      }
      return [str];
    }
    let n10;
    if (isSequence) {
      n10 = m.body.split(/\.\./);
    } else {
      n10 = parseCommaParts(m.body);
      if (n10.length === 1 && n10[0] !== void 0) {
        n10 = expand_(n10[0], max, false).map(embrace);
        if (n10.length === 1) {
          return post.map((p) => m.pre + n10[0] + p);
        }
      }
    }
    let N10;
    if (isSequence && n10[0] !== void 0 && n10[1] !== void 0) {
      const x = numeric(n10[0]);
      const y = numeric(n10[1]);
      const width = Math.max(n10[0].length, n10[1].length);
      let incr = n10.length === 3 && n10[2] !== void 0 ? Math.abs(numeric(n10[2])) : 1;
      let test = lte;
      const reverse2 = y < x;
      if (reverse2) {
        incr *= -1;
        test = gte;
      }
      const pad = n10.some(isPadded);
      N10 = [];
      for (let i10 = x; test(i10, y); i10 += incr) {
        let c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i10);
          if (c === "\\") {
            c = "";
          }
        } else {
          c = String(i10);
          if (pad) {
            const need = width - c.length;
            if (need > 0) {
              const z = new Array(need + 1).join("0");
              if (i10 < 0) {
                c = "-" + z + c.slice(1);
              } else {
                c = z + c;
              }
            }
          }
        }
        N10.push(c);
      }
    } else {
      N10 = [];
      for (let j = 0; j < n10.length; j++) {
        N10.push.apply(N10, expand_(n10[j], max, false));
      }
    }
    for (let j = 0; j < N10.length; j++) {
      for (let k = 0; k < post.length && expansions.length < max; k++) {
        const expansion = pre + N10[j] + post[k];
        if (!isTop || isSequence || expansion) {
          expansions.push(expansion);
        }
      }
    }
  }
  return expansions;
}

// node_modules/just-bash/node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/just-bash/node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s10) => s10.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s10) => s10.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i10 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i10 < glob.length) {
      const c = glob.charAt(i10);
      if ((c === "!" || c === "^") && i10 === pos + 1) {
        negate = true;
        i10++;
        continue;
      }
      if (c === "]" && sawStart && !escaping) {
        endPos = i10 + 1;
        break;
      }
      sawStart = true;
      if (c === "\\") {
        if (!escaping) {
          escaping = true;
          i10++;
          continue;
        }
      }
      if (c === "[" && !escaping) {
        for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
          if (glob.startsWith(cls, i10)) {
            if (rangeStart) {
              return ["$.", false, glob.length - pos, true];
            }
            i10 += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
        } else if (c === rangeStart) {
          ranges.push(braceEscape(c));
        }
        rangeStart = "";
        i10++;
        continue;
      }
      if (glob.startsWith("-]", i10 + 1)) {
        ranges.push(braceEscape(c + "-"));
        i10 += 2;
        continue;
      }
      if (glob.startsWith("-", i10 + 1)) {
        rangeStart = c;
        i10 += 2;
        continue;
      }
      ranges.push(braceEscape(c));
      i10++;
    }
  if (endPos < i10) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r10 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r10), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/just-bash/node_modules/minimatch/dist/esm/unescape.js
var unescape2 = (s10, { windowsPathsNoEscape = false, magicalBraces = true } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s10.replace(/\[([^\/\\])\]/g, "$1") : s10.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  }
  return windowsPathsNoEscape ? s10.replace(/\[([^\/\\{}])\]/g, "$1") : s10.replace(/((?!\\).|^)\[([^\/\\{}])\]/g, "$1$2").replace(/\\([^\/{}])/g, "$1");
};

// node_modules/just-bash/node_modules/minimatch/dist/esm/ast.js
var types2 = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types2.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s10) => s10.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type2, parent, options2 = {}) {
    this.type = type2;
    if (type2)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options2 : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type2 === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p of this.#parts) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p) => String(p)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n10;
    while (n10 = this.#negs.pop()) {
      if (n10.type !== "!")
        continue;
      let p = n10;
      let pp3 = p.#parent;
      while (pp3) {
        for (let i10 = p.#parentIndex + 1; !pp3.type && i10 < pp3.#parts.length; i10++) {
          for (const part of n10.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp3.#parts[i10]);
          }
        }
        p = pp3;
        pp3 = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
        throw new Error("invalid part: " + p);
      }
      this.#parts.push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p = this.#parent;
    for (let i10 = 0; i10 < this.#parentIndex; i10++) {
      const pp3 = p.#parts[i10];
      if (!(pp3 instanceof _AST && pp3.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl2 = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl2 - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new _AST(this.type, parent);
    for (const p of this.#parts) {
      c.copyIn(p);
    }
    return c;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i11 = pos;
      let acc2 = "";
      while (i11 < str.length) {
        const c = str.charAt(i11++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i11 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i11 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i11;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str.charAt(i11) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c, ast);
          i11 = _AST.#parseAST(str, ext2, i11, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i11;
    }
    let i10 = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i10 < str.length) {
      const c = str.charAt(i10++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i10 === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i10 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i10;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str.charAt(i10) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c, part);
        part.push(ext2);
        i10 = _AST.#parseAST(str, ext2, i10, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i10;
      }
      acc += c;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str.substring(pos - 1)];
    return i10;
  }
  static fromGlob(pattern, options2 = {}) {
    const ast = new _AST(null, void 0, options2);
    _AST.#parseAST(pattern, ast, 0, options2);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd() && !this.#parts.some((s10) => typeof s10 !== "string");
      const src = this.#parts.map((p) => {
        const [re, _10, hasMagic, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape2(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s10 = this.toString();
      this.#parts = [s10];
      this.type = null;
      this.#hasMagic = void 0;
      return [s10, unescape2(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close2 = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close2;
    }
    return [
      final,
      unescape2(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _10, _hasMagic, uflag] = p.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob, hasMagic, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i10 = 0; i10 < glob.length; i10++) {
      const c = glob.charAt(i10);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i10 === glob.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob, i10);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i10 += consumed - 1;
          hasMagic = hasMagic || magic;
          continue;
        }
      }
      if (c === "*") {
        re += noEmpty && glob === "*" ? starNoEmpty : star;
        hasMagic = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape2(glob), !!hasMagic, uflag];
  }
};

// node_modules/just-bash/node_modules/minimatch/dist/esm/escape.js
var escape2 = (s10, { windowsPathsNoEscape = false, magicalBraces = false } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s10.replace(/[?*()[\]{}]/g, "[$&]") : s10.replace(/[?*()[\]\\{}]/g, "\\$&");
  }
  return windowsPathsNoEscape ? s10.replace(/[?*()[\]]/g, "[$&]") : s10.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/just-bash/node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options2 = {}) => {
  assertValidPattern(pattern);
  if (!options2.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options2).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f10) => !f10.startsWith(".") && f10.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f10) => f10.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f10) => !f10.startsWith(".") && f10.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f10) => f10.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f10) => !f10.startsWith(".") && f10.includes(".");
var starDotStarTestDot = (f10) => f10 !== "." && f10 !== ".." && f10.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f10) => f10 !== "." && f10 !== ".." && f10.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f10) => f10.length !== 0 && !f10.startsWith(".");
var starTestDot = (f10) => f10.length !== 0 && f10 !== "." && f10 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$02, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$02]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f10) => noext(f10) && f10.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$02, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$02]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f10) => noext(f10) && f10.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$02, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$02]);
  return !ext2 ? noext : (f10) => noext(f10) && f10.endsWith(ext2);
};
var qmarksTest = ([$02, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$02]);
  return !ext2 ? noext : (f10) => noext(f10) && f10.endsWith(ext2);
};
var qmarksTestNoExt = ([$02]) => {
  const len = $02.length;
  return (f10) => f10.length === len && !f10.startsWith(".");
};
var qmarksTestNoExtDot = ([$02]) => {
  const len = $02.length;
  return (f10) => f10.length === len && f10 !== "." && f10 !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path2 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep2 = defaultPlatform === "win32" ? path2.win32.sep : path2.posix.sep;
minimatch.sep = sep2;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options2 = {}) => (p) => minimatch(p, pattern, options2);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options2 = {}) => orig(p, pattern, ext(def, options2));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options2 = {}) {
        super(pattern, ext(def, options2));
      }
      static defaults(options2) {
        return orig.defaults(ext(def, options2)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type2, parent, options2 = {}) {
        super(type2, parent, ext(def, options2));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options2 = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options2));
      }
    },
    unescape: (s10, options2 = {}) => orig.unescape(s10, ext(def, options2)),
    escape: (s10, options2 = {}) => orig.escape(s10, ext(def, options2)),
    filter: (pattern, options2 = {}) => orig.filter(pattern, ext(def, options2)),
    defaults: (options2) => orig.defaults(ext(def, options2)),
    makeRe: (pattern, options2 = {}) => orig.makeRe(pattern, ext(def, options2)),
    braceExpand: (pattern, options2 = {}) => orig.braceExpand(pattern, ext(def, options2)),
    match: (list2, pattern, options2 = {}) => orig.match(list2, pattern, ext(def, options2)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options2 = {}) => {
  assertValidPattern(pattern);
  if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options2 = {}) => new Minimatch(pattern, options2).makeRe();
minimatch.makeRe = makeRe;
var match = (list2, pattern, options2 = {}) => {
  const mm2 = new Minimatch(pattern, options2);
  list2 = list2.filter((f10) => mm2.match(f10));
  if (mm2.options.nonull && !list2.length) {
    list2.push(pattern);
  }
  return list2;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s10) => s10.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options2 = {}) {
    assertValidPattern(pattern);
    options2 = options2 || {};
    this.options = options2;
    this.pattern = pattern;
    this.platform = options2.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options2.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options2.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options2.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options2.windowsNoMagicRoot !== void 0 ? options2.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._10) {
  }
  make() {
    const pattern = this.pattern;
    const options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options2.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s10) => this.slashSplit(s10));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s10, _10, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s10[0] === "" && s10[1] === "" && (s10[2] === "?" || !globMagic.test(s10[2])) && !globMagic.test(s10[3]);
        const isDrive = /^[a-z]:/i.test(s10[0]);
        if (isUNC) {
          return [...s10.slice(0, 4), ...s10.slice(4).map((ss2) => this.parse(ss2))];
        } else if (isDrive) {
          return [s10[0], ...s10.slice(1).map((ss2) => this.parse(ss2))];
        }
      }
      return s10.map((ss2) => this.parse(ss2));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s10) => s10.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i10 = 0; i10 < this.set.length; i10++) {
        const p = this.set[i10];
        if (p[0] === "" && p[1] === "" && this.globParts[i10][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i10 = 0; i10 < globParts.length; i10++) {
        for (let j = 0; j < globParts[i10].length; j++) {
          if (globParts[i10][j] === "**") {
            globParts[i10][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs2 = -1;
      while (-1 !== (gs2 = parts.indexOf("**", gs2 + 1))) {
        let i10 = gs2;
        while (parts[i10 + 1] === "**") {
          i10++;
        }
        if (i10 !== gs2) {
          parts.splice(gs2, i10 - gs2);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i10 = 1; i10 < parts.length - 1; i10++) {
          const p = parts[i10];
          if (i10 === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i10, 1);
            i10--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd2 = 0;
      while (-1 !== (dd2 = parts.indexOf("..", dd2 + 1))) {
        const p = parts[dd2 - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd2 - 1, 2);
          dd2 -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs2 = -1;
        while (-1 !== (gs2 = parts.indexOf("**", gs2 + 1))) {
          let gss = gs2;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs2) {
            parts.splice(gs2 + 1, gss - gs2);
          }
          let next2 = parts[gs2 + 1];
          const p = parts[gs2 + 2];
          const p22 = parts[gs2 + 3];
          if (next2 !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p22 || p22 === "." || p22 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs2, 1);
          const other = parts.slice(0);
          other[gs2] = "**";
          globParts.push(other);
          gs2--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i10 = 1; i10 < parts.length - 1; i10++) {
            const p = parts[i10];
            if (i10 === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i10, 1);
              i10--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd2 = 0;
        while (-1 !== (dd2 = parts.indexOf("..", dd2 + 1))) {
          const p = parts[dd2 - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd2 === 1 && parts[dd2 + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd2 - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd2 -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i10 = 0; i10 < globParts.length - 1; i10++) {
      for (let j = i10 + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i10], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i10] = [];
          globParts[j] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs2) => gs2.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai2 = 0;
    let bi2 = 0;
    let result = [];
    let which = "";
    while (ai2 < a.length && bi2 < b.length) {
      if (a[ai2] === b[bi2]) {
        result.push(which === "b" ? b[bi2] : a[ai2]);
        ai2++;
        bi2++;
      } else if (emptyGSMatch && a[ai2] === "**" && b[bi2] === a[ai2 + 1]) {
        result.push(a[ai2]);
        ai2++;
      } else if (emptyGSMatch && b[bi2] === "**" && a[ai2] === b[bi2 + 1]) {
        result.push(b[bi2]);
        bi2++;
      } else if (a[ai2] === "*" && b[bi2] && (this.options.dot || !b[bi2].startsWith(".")) && b[bi2] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai2]);
        ai2++;
        bi2++;
      } else if (b[bi2] === "*" && a[ai2] && (this.options.dot || !a[ai2].startsWith(".")) && a[ai2] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi2]);
        ai2++;
        bi2++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i10 = 0; i10 < pattern.length && pattern.charAt(i10) === "!"; i10++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options2 = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd2, pd2] = [file[fdi], pattern[pdi]];
        if (fd2.toLowerCase() === pd2.toLowerCase()) {
          pattern[pdi] = fd2;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi2 = 0, pi2 = 0, fl2 = file.length, pl2 = pattern.length; fi2 < fl2 && pi2 < pl2; fi2++, pi2++) {
      this.debug("matchOne loop");
      var p = pattern[pi2];
      var f10 = file[fi2];
      this.debug(pattern, p, f10);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f10]);
        var fr2 = fi2;
        var pr2 = pi2 + 1;
        if (pr2 === pl2) {
          this.debug("** at the end");
          for (; fi2 < fl2; fi2++) {
            if (file[fi2] === "." || file[fi2] === ".." || !options2.dot && file[fi2].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr2 < fl2) {
          var swallowee = file[fr2];
          this.debug("\nglobstar while", file, fr2, pattern, pr2, swallowee);
          if (this.matchOne(file.slice(fr2), pattern.slice(pr2), partial)) {
            this.debug("globstar found match!", fr2, fl2, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr2, pattern, pr2);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr2++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr2, pattern, pr2);
          if (fr2 === fl2) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f10 === p;
        this.debug("string match", p, f10, hit);
      } else {
        hit = p.test(f10);
        this.debug("pattern match", p, f10, hit);
      }
      if (!hit)
        return false;
    }
    if (fi2 === fl2 && pi2 === pl2) {
      return true;
    } else if (fi2 === fl2) {
      return partial;
    } else if (pi2 === pl2) {
      return fi2 === fl2 - 1 && file[fi2] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options2 = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options2.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options2.nocase ? options2.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options2.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options2.nocase ? options2.dot ? qmarksTestNocaseDot : qmarksTestNocase : options2.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options2.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options2 = this.options;
    const twoStar = options2.noglobstar ? star2 : options2.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options2.nocase ? ["i"] : []);
    let re = set.map((pattern) => {
      const pp3 = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f10 of p.flags.split(""))
            flags.add(f10);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp3.forEach((p, i10) => {
        const next2 = pp3[i10 + 1];
        const prev = pp3[i10 - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next2 !== void 0 && next2 !== GLOBSTAR) {
            pp3[i10 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next2;
          } else {
            pp3[i10] = twoStar;
          }
        } else if (next2 === void 0) {
          pp3[i10 - 1] = prev + "(?:\\/|\\/" + twoStar + ")?";
        } else if (next2 !== GLOBSTAR) {
          pp3[i10 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next2;
          pp3[i10 + 1] = GLOBSTAR;
        }
      });
      const filtered = pp3.filter((p) => p !== GLOBSTAR);
      if (this.partial && filtered.length >= 1) {
        const prefixes = [];
        for (let i10 = 1; i10 <= filtered.length; i10++) {
          prefixes.push(filtered.slice(0, i10).join("/"));
        }
        return "(?:" + prefixes.join("|") + ")";
      }
      return filtered.join("/");
    }).join("|");
    const [open2, close2] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open2 + re + close2 + "$";
    if (this.partial) {
      re = "^(?:\\/|" + open2 + re.slice(1, -1) + close2 + ")$";
    }
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex2) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f10, partial = this.partial) {
    this.debug("match", f10, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f10 === "";
    }
    if (f10 === "/" && partial) {
      return true;
    }
    const options2 = this.options;
    if (this.isWindows) {
      f10 = f10.split("\\").join("/");
    }
    const ff2 = this.slashSplit(f10);
    this.debug(this.pattern, "split", ff2);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename2 = ff2[ff2.length - 1];
    if (!filename2) {
      for (let i10 = ff2.length - 2; !filename2 && i10 >= 0; i10--) {
        filename2 = ff2[i10];
      }
    }
    for (let i10 = 0; i10 < set.length; i10++) {
      const pattern = set[i10];
      let file = ff2;
      if (options2.matchBase && pattern.length === 1) {
        file = [filename2];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options2.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options2.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape2;
minimatch.unescape = unescape2;

// sandbox/_shims/node-zlib.js
function gunzipSync2() {
  throw new Error("node:zlib not available in browser");
}
function gzipSync2() {
  throw new Error("node:zlib not available in browser");
}
var constants3 = {};

// node_modules/diff/libesm/diff/base.js
var Diff = class {
  diff(oldStr, newStr, options2 = {}) {
    let callback;
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    } else if ("callback" in options2) {
      callback = options2.callback;
    }
    const oldString = this.castInput(oldStr, options2);
    const newString = this.castInput(newStr, options2);
    const oldTokens = this.removeEmpty(this.tokenize(oldString, options2));
    const newTokens = this.removeEmpty(this.tokenize(newString, options2));
    return this.diffWithOptionsObj(oldTokens, newTokens, options2, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options2, callback) {
    var _a3;
    const done = (value2) => {
      value2 = this.postProcess(value2, options2);
      if (callback) {
        setTimeout(function() {
          callback(value2);
        }, 0);
        return void 0;
      } else {
        return value2;
      }
    };
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options2.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options2.maxEditLength);
    }
    const maxExecutionTime = (_a3 = options2.timeout) !== null && _a3 !== void 0 ? _a3 : Infinity;
    const abortAfterTimestamp = Date.now() + maxExecutionTime;
    const bestPath = [{ oldPos: -1, lastComponent: void 0 }];
    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options2);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
    }
    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    const execEditLength = () => {
      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        let canAdd = false;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = this.addToPath(addPath, true, false, 0, options2);
        } else {
          basePath = this.addToPath(removePath, false, true, 1, options2);
        }
        newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options2);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    };
    if (callback) {
      (function exec2() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback(void 0);
          }
          if (!execEditLength()) {
            exec2();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        const ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }
  addToPath(path3, added, removed, oldPosInc, options2) {
    const last = path3.lastComponent;
    if (last && !options2.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path3.oldPos + oldPosInc,
        lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
      };
    } else {
      return {
        oldPos: path3.oldPos + oldPosInc,
        lastComponent: { count: 1, added, removed, previousComponent: last }
      };
    }
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options2) {
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options2)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options2.oneChangePerToken) {
        basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
      }
    }
    if (commonCount && !options2.oneChangePerToken) {
      basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }
  equals(left, right, options2) {
    if (options2.comparator) {
      return options2.comparator(left, right);
    } else {
      return left === right || !!options2.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }
  removeEmpty(array) {
    const ret = [];
    for (let i10 = 0; i10 < array.length; i10++) {
      if (array[i10]) {
        ret.push(array[i10]);
      }
    }
    return ret;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  castInput(value2, options2) {
    return value2;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tokenize(value2, options2) {
    return Array.from(value2);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options2) {
    return changeObjects;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    while (lastComponent) {
      components.push(lastComponent);
      nextComponent = lastComponent.previousComponent;
      delete lastComponent.previousComponent;
      lastComponent = nextComponent;
    }
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0, newPos = 0, oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (!component.removed) {
        if (!component.added && this.useLongestToken) {
          let value2 = newTokens.slice(newPos, newPos + component.count);
          value2 = value2.map(function(value3, i10) {
            const oldValue = oldTokens[oldPos + i10];
            return oldValue.length > value3.length ? oldValue : value3;
          });
          component.value = this.join(value2);
        } else {
          component.value = this.join(newTokens.slice(newPos, newPos + component.count));
        }
        newPos += component.count;
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
        oldPos += component.count;
      }
    }
    return components;
  }
};

// node_modules/diff/libesm/diff/line.js
var LineDiff = class extends Diff {
  constructor() {
    super(...arguments);
    this.tokenize = tokenize2;
  }
  equals(left, right, options2) {
    if (options2.ignoreWhitespace) {
      if (!options2.newlineIsToken || !left.includes("\n")) {
        left = left.trim();
      }
      if (!options2.newlineIsToken || !right.includes("\n")) {
        right = right.trim();
      }
    } else if (options2.ignoreNewlineAtEof && !options2.newlineIsToken) {
      if (left.endsWith("\n")) {
        left = left.slice(0, -1);
      }
      if (right.endsWith("\n")) {
        right = right.slice(0, -1);
      }
    }
    return super.equals(left, right, options2);
  }
};
var lineDiff = new LineDiff();
function diffLines(oldStr, newStr, options2) {
  return lineDiff.diff(oldStr, newStr, options2);
}
function tokenize2(value2, options2) {
  if (options2.stripTrailingCr) {
    value2 = value2.replace(/\r\n/g, "\n");
  }
  const retLines = [], linesAndNewlines = value2.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (let i10 = 0; i10 < linesAndNewlines.length; i10++) {
    const line = linesAndNewlines[i10];
    if (i10 % 2 && !options2.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
}

// node_modules/diff/libesm/patch/create.js
var INCLUDE_HEADERS = {
  includeIndex: true,
  includeUnderline: true,
  includeFileHeaders: true
};
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2) {
  let optionsObj;
  if (!options2) {
    optionsObj = {};
  } else if (typeof options2 === "function") {
    optionsObj = { callback: options2 };
  } else {
    optionsObj = options2;
  }
  if (typeof optionsObj.context === "undefined") {
    optionsObj.context = 4;
  }
  const context2 = optionsObj.context;
  if (optionsObj.newlineIsToken) {
    throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
  }
  if (!optionsObj.callback) {
    return diffLinesResultToPatch(diffLines(oldStr, newStr, optionsObj));
  } else {
    const { callback } = optionsObj;
    diffLines(oldStr, newStr, Object.assign(Object.assign({}, optionsObj), { callback: (diff) => {
      const patch = diffLinesResultToPatch(diff);
      callback(patch);
    } }));
  }
  function diffLinesResultToPatch(diff) {
    if (!diff) {
      return;
    }
    diff.push({ value: "", lines: [] });
    function contextLines(lines) {
      return lines.map(function(entry) {
        return " " + entry;
      });
    }
    const hunks = [];
    let oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
    for (let i10 = 0; i10 < diff.length; i10++) {
      const current = diff[i10], lines = current.lines || splitLines(current.value);
      current.lines = lines;
      if (current.added || current.removed) {
        if (!oldRangeStart) {
          const prev = diff[i10 - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;
          if (prev) {
            curRange = context2 > 0 ? contextLines(prev.lines.slice(-context2)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        }
        for (const line of lines) {
          curRange.push((current.added ? "+" : "-") + line);
        }
        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        if (oldRangeStart) {
          if (lines.length <= context2 * 2 && i10 < diff.length - 2) {
            for (const line of contextLines(lines)) {
              curRange.push(line);
            }
          } else {
            const contextSize = Math.min(lines.length, context2);
            for (const line of contextLines(lines.slice(0, contextSize))) {
              curRange.push(line);
            }
            const hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            hunks.push(hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }
        oldLine += lines.length;
        newLine += lines.length;
      }
    }
    for (const hunk of hunks) {
      for (let i10 = 0; i10 < hunk.lines.length; i10++) {
        if (hunk.lines[i10].endsWith("\n")) {
          hunk.lines[i10] = hunk.lines[i10].slice(0, -1);
        } else {
          hunk.lines.splice(i10 + 1, 0, "\\ No newline at end of file");
          i10++;
        }
      }
    }
    return {
      oldFileName,
      newFileName,
      oldHeader,
      newHeader,
      hunks
    };
  }
}
function formatPatch(patch, headerOptions) {
  if (!headerOptions) {
    headerOptions = INCLUDE_HEADERS;
  }
  if (Array.isArray(patch)) {
    if (patch.length > 1 && !headerOptions.includeFileHeaders) {
      throw new Error("Cannot omit file headers on a multi-file patch. (The result would be unparseable; how would a tool trying to apply the patch know which changes are to which file?)");
    }
    return patch.map((p) => formatPatch(p, headerOptions)).join("\n");
  }
  const ret = [];
  if (headerOptions.includeIndex && patch.oldFileName == patch.newFileName) {
    ret.push("Index: " + patch.oldFileName);
  }
  if (headerOptions.includeUnderline) {
    ret.push("===================================================================");
  }
  if (headerOptions.includeFileHeaders) {
    ret.push("--- " + patch.oldFileName + (typeof patch.oldHeader === "undefined" ? "" : "	" + patch.oldHeader));
    ret.push("+++ " + patch.newFileName + (typeof patch.newHeader === "undefined" ? "" : "	" + patch.newHeader));
  }
  for (let i10 = 0; i10 < patch.hunks.length; i10++) {
    const hunk = patch.hunks[i10];
    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }
    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }
    ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
    for (const line of hunk.lines) {
      ret.push(line);
    }
  }
  return ret.join("\n") + "\n";
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2) {
  if (typeof options2 === "function") {
    options2 = { callback: options2 };
  }
  if (!(options2 === null || options2 === void 0 ? void 0 : options2.callback)) {
    const patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2);
    if (!patchObj) {
      return;
    }
    return formatPatch(patchObj, options2 === null || options2 === void 0 ? void 0 : options2.headerOptions);
  } else {
    const { callback } = options2;
    structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, Object.assign(Object.assign({}, options2), { callback: (patchObj) => {
      if (!patchObj) {
        callback(void 0);
      } else {
        callback(formatPatch(patchObj, options2.headerOptions));
      }
    } }));
  }
}
function splitLines(text) {
  const hasTrailingNl = text.endsWith("\n");
  const result = text.split("\n").map((line) => line + "\n");
  if (hasTrailingNl) {
    result.pop();
  } else {
    result.push(result.pop().slice(0, -1));
  }
  return result;
}

// node_modules/turndown/lib/turndown.browser.es.js
function extend(destination) {
  for (var i10 = 1; i10 < arguments.length; i10++) {
    var source = arguments[i10];
    for (var key in source) {
      if (source.hasOwnProperty(key))
        destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n")
    indexEnd--;
  return string.substring(0, indexEnd);
}
function trimNewlines(string) {
  return trimTrailingNewlines(trimLeadingNewlines(string));
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node2) {
  return is(node2, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node2) {
  return is(node2, voidElements);
}
function hasVoid(node2) {
  return has2(node2, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node2) {
  return is(node2, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node2) {
  return has2(node2, meaningfulWhenBlankElements);
}
function is(node2, tagNames) {
  return tagNames.indexOf(node2.nodeName) >= 0;
}
function has2(node2, tagNames) {
  return node2.getElementsByTagName && tagNames.some(function(tagName) {
    return node2.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node2, options2) {
    return options2.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node2, options2) {
    var hLevel = Number(node2.nodeName.charAt(1));
    if (options2.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = trimNewlines(content).replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node2) {
    var parent = node2.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node2) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node2, options2) {
    var prefix = options2.bulletListMarker + "   ";
    var parent = node2.parentNode;
    if (parent.nodeName === "OL") {
      var start = parent.getAttribute("start");
      var index2 = Array.prototype.indexOf.call(parent.children, node2);
      prefix = (start ? Number(start) + index2 : index2 + 1) + ".  ";
    }
    var isParagraph = /\n$/.test(content);
    content = trimNewlines(content) + (isParagraph ? "\n" : "");
    content = content.replace(/\n/gm, "\n" + " ".repeat(prefix.length));
    return prefix + content + (node2.nextSibling ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node2, options2) {
    return options2.codeBlockStyle === "indented" && node2.nodeName === "PRE" && node2.firstChild && node2.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node2, options2) {
    return "\n\n    " + node2.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node2, options2) {
    return options2.codeBlockStyle === "fenced" && node2.nodeName === "PRE" && node2.firstChild && node2.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node2, options2) {
    var className = node2.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code2 = node2.firstChild.textContent;
    var fenceChar = options2.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match2;
    while (match2 = fenceInCodeRegex.exec(code2)) {
      if (match2[0].length >= fenceSize) {
        fenceSize = match2[0].length + 1;
      }
    }
    var fence = repeat(fenceChar, fenceSize);
    return "\n\n" + fence + language + "\n" + code2.replace(/\n$/, "") + "\n" + fence + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node2, options2) {
    return "\n\n" + options2.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node2, options2) {
    return options2.linkStyle === "inlined" && node2.nodeName === "A" && node2.getAttribute("href");
  },
  replacement: function(content, node2) {
    var href = node2.getAttribute("href");
    if (href)
      href = href.replace(/([()])/g, "\\$1");
    var title = cleanAttribute(node2.getAttribute("title"));
    if (title)
      title = ' "' + title.replace(/"/g, '\\"') + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node2, options2) {
    return options2.linkStyle === "referenced" && node2.nodeName === "A" && node2.getAttribute("href");
  },
  replacement: function(content, node2, options2) {
    var href = node2.getAttribute("href");
    var title = cleanAttribute(node2.getAttribute("title"));
    if (title)
      title = ' "' + title + '"';
    var replacement;
    var reference;
    switch (options2.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference = "[" + content + "]: " + href + title;
        break;
      default:
        var id2 = this.references.length + 1;
        replacement = "[" + content + "][" + id2 + "]";
        reference = "[" + id2 + "]: " + href + title;
    }
    this.references.push(reference);
    return replacement;
  },
  references: [],
  append: function(options2) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node2, options2) {
    if (!content.trim())
      return "";
    return options2.emDelimiter + content + options2.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node2, options2) {
    if (!content.trim())
      return "";
    return options2.strongDelimiter + content + options2.strongDelimiter;
  }
};
rules.code = {
  filter: function(node2) {
    var hasSiblings = node2.previousSibling || node2.nextSibling;
    var isCodeBlock = node2.parentNode.nodeName === "PRE" && !hasSiblings;
    return node2.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content)
      return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter2 = "`";
    var matches = content.match(/`+/gm) || [];
    while (matches.indexOf(delimiter2) !== -1)
      delimiter2 = delimiter2 + "`";
    return delimiter2 + extraSpace + content + extraSpace + delimiter2;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node2) {
    var alt = cleanAttribute(node2.getAttribute("alt"));
    var src = node2.getAttribute("src") || "";
    var title = cleanAttribute(node2.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options2) {
  this.options = options2;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options2.blankReplacement
  };
  this.keepReplacement = options2.keepReplacement;
  this.defaultRule = {
    replacement: options2.defaultReplacement
  };
  this.array = [];
  for (var key in options2.rules)
    this.array.push(options2.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter2) {
    this._keep.unshift({
      filter: filter2,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter2) {
    this._remove.unshift({
      filter: filter2,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node2) {
    if (node2.isBlank)
      return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node2, this.options))
      return rule;
    if (rule = findRule(this._keep, node2, this.options))
      return rule;
    if (rule = findRule(this._remove, node2, this.options))
      return rule;
    return this.defaultRule;
  },
  forEach: function(fn3) {
    for (var i10 = 0; i10 < this.array.length; i10++)
      fn3(this.array[i10], i10);
  }
};
function findRule(rules2, node2, options2) {
  for (var i10 = 0; i10 < rules2.length; i10++) {
    var rule = rules2[i10];
    if (filterValue(rule, node2, options2))
      return rule;
  }
  return void 0;
}
function filterValue(rule, node2, options2) {
  var filter2 = rule.filter;
  if (typeof filter2 === "string") {
    if (filter2 === node2.nodeName.toLowerCase())
      return true;
  } else if (Array.isArray(filter2)) {
    if (filter2.indexOf(node2.nodeName.toLowerCase()) > -1)
      return true;
  } else if (typeof filter2 === "function") {
    if (filter2.call(rule, node2, options2))
      return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options2) {
  var element = options2.element;
  var isBlock2 = options2.isBlock;
  var isVoid2 = options2.isVoid;
  var isPre = options2.isPre || function(node3) {
    return node3.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element))
    return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node2 = next(prev, element, isPre);
  while (node2 !== element) {
    if (node2.nodeType === 3 || node2.nodeType === 4) {
      var text = node2.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
        text = text.substr(1);
      }
      if (!text) {
        node2 = remove(node2);
        continue;
      }
      node2.data = text;
      prevText = node2;
    } else if (node2.nodeType === 1) {
      if (isBlock2(node2) || node2.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node2) || isPre(node2)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node2 = remove(node2);
      continue;
    }
    var nextNode = next(prev, node2, isPre);
    prev = node2;
    node2 = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove(prevText);
    }
  }
}
function remove(node2) {
  var next2 = node2.nextSibling || node2.parentNode;
  node2.parentNode.removeChild(node2);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser2 = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser2().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e11) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser2 = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser2.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser2.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser2;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e11) {
    if (root.ActiveXObject)
      useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options2) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options2.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node2) {
  return node2.nodeName === "PRE" || node2.nodeName === "CODE";
}
function Node2(node2, options2) {
  node2.isBlock = isBlock(node2);
  node2.isCode = node2.nodeName === "CODE" || node2.parentNode.isCode;
  node2.isBlank = isBlank(node2);
  node2.flankingWhitespace = flankingWhitespace(node2, options2);
  return node2;
}
function isBlank(node2) {
  return !isVoid(node2) && !isMeaningfulWhenBlank(node2) && /^\s*$/i.test(node2.textContent) && !hasVoid(node2) && !hasMeaningfulWhenBlank(node2);
}
function flankingWhitespace(node2, options2) {
  if (node2.isBlock || options2.preformattedCode && node2.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node2.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node2, options2)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node2, options2)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    // whole string for whitespace-only strings
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    // empty for whitespace-only strings
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node2, options2) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node2.previousSibling;
    regExp = / $/;
  } else {
    sibling = node2.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options2.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options2) {
  if (!(this instanceof TurndownService))
    return new TurndownService(options2);
  var defaults2 = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node2) {
      return node2.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node2) {
      return node2.isBlock ? "\n\n" + node2.outerHTML + "\n\n" : node2.outerHTML;
    },
    defaultReplacement: function(content, node2) {
      return node2.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults2, options2);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + " is not a string, or an element/document/fragment node."
      );
    }
    if (input === "")
      return "";
    var output = process2.call(this, new RootNode(input, this.options));
    return postProcess.call(this, output);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(plugin) {
    if (Array.isArray(plugin)) {
      for (var i10 = 0; i10 < plugin.length; i10++)
        this.use(plugin[i10]);
    } else if (typeof plugin === "function") {
      plugin(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(filter2) {
    this.rules.keep(filter2);
    return this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(filter2) {
    this.rules.remove(filter2);
    return this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape3) {
      return accumulator.replace(escape3[0], escape3[1]);
    }, string);
  }
};
function process2(parentNode) {
  var self = this;
  return reduce.call(parentNode.childNodes, function(output, node2) {
    node2 = new Node2(node2, self.options);
    var replacement = "";
    if (node2.nodeType === 3) {
      replacement = node2.isCode ? node2.nodeValue : self.escape(node2.nodeValue);
    } else if (node2.nodeType === 1) {
      replacement = replacementForNode.call(self, node2);
    }
    return join2(output, replacement);
  }, "");
}
function postProcess(output) {
  var self = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join2(output, rule.append(self.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node2) {
  var rule = this.rules.forNode(node2);
  var content = process2.call(this, node2);
  var whitespace = node2.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing)
    content = content.trim();
  return whitespace.leading + rule.replacement(content, node2, this.options) + whitespace.trailing;
}
function join2(output, replacement) {
  var s12 = trimTrailingNewlines(output);
  var s22 = trimLeadingNewlines(replacement);
  var nls = Math.max(output.length - s12.length, replacement.length - s22.length);
  var separator = "\n\n".substring(0, nls);
  return s12 + separator + s22;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var turndown_browser_es_default = TurndownService;

// node_modules/just-bash/dist/bundle/browser.js
var Og = Object.create;
var $o = Object.defineProperty;
var Rg = Object.getOwnPropertyDescriptor;
var $g = Object.getOwnPropertyNames;
var Tg = Object.getPrototypeOf;
var Pg = Object.prototype.hasOwnProperty;
var _s = ((e11) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(e11, { get: (t10, n10) => (typeof __require < "u" ? __require : t10)[n10] }) : e11)(function(e11) {
  if (typeof __require < "u")
    return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + e11 + '" is not supported');
});
var I = (e11, t10) => () => (e11 && (t10 = e11(e11 = 0)), t10);
var Ls = (e11, t10) => () => (t10 || e11((t10 = { exports: {} }).exports, t10), t10.exports);
var Q = (e11, t10) => {
  for (var n10 in t10)
    $o(e11, n10, { get: t10[n10], enumerable: true });
};
var Dg = (e11, t10, n10, r10) => {
  if (t10 && typeof t10 == "object" || typeof t10 == "function")
    for (let s10 of $g(t10))
      !Pg.call(e11, s10) && s10 !== n10 && $o(e11, s10, { get: () => t10[s10], enumerable: !(r10 = Rg(t10, s10)) || r10.enumerable });
  return e11;
};
var lu = (e11, t10, n10) => (n10 = e11 != null ? Og(Tg(e11)) : {}, Dg(t10 || !e11 || !e11.__esModule ? $o(n10, "default", { value: e11, enumerable: true }) : n10, e11));
var cu = {};
Q(cu, { echoCommand: () => Lg, flagsForFuzzing: () => Fg });
function _g(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; )
    if (e11[n10] === "\\") {
      if (n10 + 1 >= e11.length) {
        t10 += "\\";
        break;
      }
      let r10 = e11[n10 + 1];
      switch (r10) {
        case "\\":
          t10 += "\\", n10 += 2;
          break;
        case "n":
          t10 += `
`, n10 += 2;
          break;
        case "t":
          t10 += "	", n10 += 2;
          break;
        case "r":
          t10 += "\r", n10 += 2;
          break;
        case "a":
          t10 += "\x07", n10 += 2;
          break;
        case "b":
          t10 += "\b", n10 += 2;
          break;
        case "f":
          t10 += "\f", n10 += 2;
          break;
        case "v":
          t10 += "\v", n10 += 2;
          break;
        case "e":
        case "E":
          t10 += "\x1B", n10 += 2;
          break;
        case "c":
          return { output: t10, stop: true };
        case "0": {
          let s10 = "", i10 = n10 + 2;
          for (; i10 < e11.length && i10 < n10 + 5 && /[0-7]/.test(e11[i10]); )
            s10 += e11[i10], i10++;
          if (s10.length === 0)
            t10 += "\0";
          else {
            let o10 = parseInt(s10, 8) % 256;
            t10 += String.fromCharCode(o10);
          }
          n10 = i10;
          break;
        }
        case "x": {
          let s10 = "", i10 = n10 + 2;
          for (; i10 < e11.length && i10 < n10 + 4 && /[0-9a-fA-F]/.test(e11[i10]); )
            s10 += e11[i10], i10++;
          if (s10.length === 0)
            t10 += "\\x", n10 += 2;
          else {
            let o10 = parseInt(s10, 16);
            t10 += String.fromCharCode(o10), n10 = i10;
          }
          break;
        }
        case "u": {
          let s10 = "", i10 = n10 + 2;
          for (; i10 < e11.length && i10 < n10 + 6 && /[0-9a-fA-F]/.test(e11[i10]); )
            s10 += e11[i10], i10++;
          if (s10.length === 0)
            t10 += "\\u", n10 += 2;
          else {
            let o10 = parseInt(s10, 16);
            t10 += String.fromCodePoint(o10), n10 = i10;
          }
          break;
        }
        case "U": {
          let s10 = "", i10 = n10 + 2;
          for (; i10 < e11.length && i10 < n10 + 10 && /[0-9a-fA-F]/.test(e11[i10]); )
            s10 += e11[i10], i10++;
          if (s10.length === 0)
            t10 += "\\U", n10 += 2;
          else {
            let o10 = parseInt(s10, 16);
            try {
              t10 += String.fromCodePoint(o10);
            } catch {
              t10 += `\\U${s10}`;
            }
            n10 = i10;
          }
          break;
        }
        default:
          t10 += `\\${r10}`, n10 += 2;
      }
    } else
      t10 += e11[n10], n10++;
  return { output: t10, stop: false };
}
var Lg;
var Fg;
var uu = I(() => {
  "use strict";
  Lg = { name: "echo", async execute(e11, t10) {
    let n10 = false, r10 = t10.xpgEcho ?? false, s10 = 0;
    for (; s10 < e11.length; ) {
      let o10 = e11[s10];
      if (o10 === "-n")
        n10 = true, s10++;
      else if (o10 === "-e")
        r10 = true, s10++;
      else if (o10 === "-E")
        r10 = false, s10++;
      else if (o10 === "-ne" || o10 === "-en")
        n10 = true, r10 = true, s10++;
      else
        break;
    }
    let i10 = e11.slice(s10).join(" ");
    if (r10) {
      let o10 = _g(i10);
      if (i10 = o10.output, o10.stop)
        return { stdout: i10, stderr: "", exitCode: 0 };
    }
    return n10 || (i10 += `
`), { stdout: i10, stderr: "", exitCode: 0 };
  } }, Fg = { name: "echo", flags: [{ flag: "-n", type: "boolean" }, { flag: "-e", type: "boolean" }, { flag: "-E", type: "boolean" }], stdinType: "none", needsArgs: true };
});
function M(e11) {
  let t10 = `${e11.name} - ${e11.summary}

`;
  if (t10 += `Usage: ${e11.usage}
`, e11.description) {
    if (t10 += `
Description:
`, typeof e11.description == "string")
      for (let n10 of e11.description.split(`
`))
        t10 += n10 ? `  ${n10}
` : `
`;
    else if (e11.description.length > 0)
      for (let n10 of e11.description)
        t10 += n10 ? `  ${n10}
` : `
`;
  }
  if (e11.options && e11.options.length > 0) {
    t10 += `
Options:
`;
    for (let n10 of e11.options)
      t10 += `  ${n10}
`;
  }
  if (e11.examples && e11.examples.length > 0) {
    t10 += `
Examples:
`;
    for (let n10 of e11.examples)
      t10 += `  ${n10}
`;
  }
  if (e11.notes && e11.notes.length > 0) {
    t10 += `
Notes:
`;
    for (let n10 of e11.notes)
      t10 += `  ${n10}
`;
  }
  return { stdout: t10, stderr: "", exitCode: 0 };
}
function U2(e11) {
  return e11.includes("--help");
}
function Y(e11, t10) {
  return { stdout: "", stderr: t10.startsWith("--") ? `${e11}: unrecognized option '${t10}'
` : `${e11}: invalid option -- '${t10.replace(/^-/, "")}'
`, exitCode: 1 };
}
var se = I(() => {
  "use strict";
});
function be(e11, t10, n10) {
  let r10 = /* @__PURE__ */ new Map(), s10 = /* @__PURE__ */ new Map();
  for (let [l, c] of Object.entries(n10)) {
    let u = { name: l, type: c.type };
    c.short && r10.set(c.short, u), c.long && s10.set(c.long, u);
  }
  let i10 = /* @__PURE__ */ Object.create(null);
  for (let [l, c] of Object.entries(n10))
    c.default !== void 0 ? i10[l] = c.default : c.type === "boolean" && (i10[l] = false);
  let o10 = [], a = false;
  for (let l = 0; l < t10.length; l++) {
    let c = t10[l];
    if (a || !c.startsWith("-") || c === "-") {
      o10.push(c);
      continue;
    }
    if (c === "--") {
      a = true;
      continue;
    }
    if (c.startsWith("--")) {
      let u = c.indexOf("="), f10, p;
      u !== -1 ? (f10 = c.slice(2, u), p = c.slice(u + 1)) : f10 = c.slice(2);
      let h = s10.get(f10);
      if (!h)
        return { ok: false, error: Y(e11, c) };
      let { name: m, type: d } = h;
      if (d === "boolean")
        i10[m] = true;
      else {
        if (p === void 0) {
          if (l + 1 >= t10.length)
            return { ok: false, error: { stdout: "", stderr: `${e11}: option '--${f10}' requires an argument
`, exitCode: 1 } };
          p = t10[++l];
        }
        i10[m] = d === "number" ? parseInt(p, 10) : p;
      }
    } else {
      let u = c.slice(1);
      for (let f10 = 0; f10 < u.length; f10++) {
        let p = u[f10], h = r10.get(p);
        if (!h)
          return { ok: false, error: Y(e11, `-${p}`) };
        let { name: m, type: d } = h;
        if (d === "boolean")
          i10[m] = true;
        else {
          let g;
          if (f10 + 1 < u.length)
            g = u.slice(f10 + 1);
          else if (l + 1 < t10.length)
            g = t10[++l];
          else
            return { ok: false, error: { stdout: "", stderr: `${e11}: option requires an argument -- '${p}'
`, exitCode: 1 } };
          i10[m] = d === "number" ? parseInt(g, 10) : g;
          break;
        }
      }
    }
  }
  return { ok: true, result: { flags: i10, positional: o10 } };
}
var qe = I(() => {
  "use strict";
  se();
});
var lr = I(() => {
  "use strict";
});
async function zn(e11, t10, n10) {
  let { cmdName: r10, allowStdinMarker: s10 = true, stopOnError: i10 = false, batchSize: o10 = 100 } = n10;
  if (t10.length === 0)
    return { files: [{ filename: "", content: e11.stdin }], stderr: "", exitCode: 0 };
  let a = [], l = "", c = 0;
  for (let u = 0; u < t10.length; u += o10) {
    let f10 = t10.slice(u, u + o10), p = await Promise.all(f10.map(async (h) => {
      if (s10 && h === "-")
        return { filename: "-", content: e11.stdin, error: null };
      try {
        let m = e11.fs.resolvePath(e11.cwd, h), d = await e11.fs.readFile(m, "binary");
        return { filename: h, content: d, error: null };
      } catch {
        return { filename: h, content: "", error: `${r10}: ${h}: No such file or directory
` };
      }
    }));
    for (let h of p)
      if (h.error) {
        if (l += h.error, c = 1, i10)
          return { files: a, stderr: l, exitCode: c };
      } else
        a.push({ filename: h.filename, content: h.content });
  }
  return { files: a, stderr: l, exitCode: c };
}
async function cr(e11, t10, n10) {
  let r10 = await zn(e11, t10, { ...n10, stopOnError: true });
  return r10.exitCode !== 0 ? { ok: false, error: { stdout: "", stderr: r10.stderr, exitCode: r10.exitCode } } : { ok: true, content: r10.files.map((i10) => i10.content).join("") };
}
var Hn = I(() => {
  "use strict";
  lr();
});
var fu = {};
Q(fu, { catCommand: () => Wg, flagsForFuzzing: () => zg });
function Bg(e11, t10) {
  let n10 = e11.split(`
`), r10 = e11.endsWith(`
`), s10 = r10 ? n10.slice(0, -1) : n10;
  return { content: s10.map((o10, a) => `${String(t10 + a).padStart(6, " ")}	${o10}`).join(`
`) + (r10 ? `
` : ""), nextLineNumber: t10 + s10.length };
}
var Mg;
var Ug;
var Wg;
var zg;
var pu = I(() => {
  "use strict";
  qe();
  Hn();
  se();
  Mg = { name: "cat", summary: "concatenate files and print on the standard output", usage: "cat [OPTION]... [FILE]...", options: ["-n, --number           number all output lines", "    --help             display this help and exit"] }, Ug = { number: { short: "n", long: "number", type: "boolean" } }, Wg = { name: "cat", async execute(e11, t10) {
    if (U2(e11))
      return M(Mg);
    let n10 = be("cat", e11, Ug);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.number, s10 = n10.result.positional, i10 = await zn(t10, s10, { cmdName: "cat", allowStdinMarker: true, stopOnError: false }), o10 = "", a = 1;
    for (let { content: l } of i10.files)
      if (r10) {
        let c = Bg(l, a);
        o10 += c.content, a = c.nextLineNumber;
      } else
        o10 += l;
    return { stdout: o10, stderr: i10.stderr, exitCode: i10.exitCode };
  } };
  zg = { name: "cat", flags: [{ flag: "-n", type: "boolean" }, { flag: "-A", type: "boolean" }, { flag: "-b", type: "boolean" }, { flag: "-s", type: "boolean" }, { flag: "-v", type: "boolean" }, { flag: "-e", type: "boolean" }, { flag: "-t", type: "boolean" }], stdinType: "text", needsFiles: true };
});
function Fs(e11) {
  return e11 instanceof ft || e11 instanceof pt || e11 instanceof at;
}
var gt;
var ft;
var pt;
var at;
var kt;
var yt;
var pe;
var $e;
var wt;
var on2;
var ur;
var te;
var an;
var Ut;
var ye = I(() => {
  "use strict";
  gt = class extends Error {
    stdout;
    stderr;
    constructor(t10, n10 = "", r10 = "") {
      super(t10), this.stdout = n10, this.stderr = r10;
    }
    prependOutput(t10, n10) {
      this.stdout = t10 + this.stdout, this.stderr = n10 + this.stderr;
    }
  }, ft = class extends gt {
    levels;
    name = "BreakError";
    constructor(t10 = 1, n10 = "", r10 = "") {
      super("break", n10, r10), this.levels = t10;
    }
  }, pt = class extends gt {
    levels;
    name = "ContinueError";
    constructor(t10 = 1, n10 = "", r10 = "") {
      super("continue", n10, r10), this.levels = t10;
    }
  }, at = class extends gt {
    exitCode;
    name = "ReturnError";
    constructor(t10 = 0, n10 = "", r10 = "") {
      super("return", n10, r10), this.exitCode = t10;
    }
  }, kt = class extends gt {
    exitCode;
    name = "ErrexitError";
    constructor(t10, n10 = "", r10 = "") {
      super(`errexit: command exited with status ${t10}`, n10, r10), this.exitCode = t10;
    }
  }, yt = class extends gt {
    varName;
    name = "NounsetError";
    constructor(t10, n10 = "") {
      super(`${t10}: unbound variable`, n10, `bash: ${t10}: unbound variable
`), this.varName = t10;
    }
  }, pe = class extends gt {
    exitCode;
    name = "ExitError";
    constructor(t10, n10 = "", r10 = "") {
      super("exit", n10, r10), this.exitCode = t10;
    }
  }, $e = class extends gt {
    name = "ArithmeticError";
    fatal;
    constructor(t10, n10 = "", r10 = "", s10 = false) {
      super(t10, n10, r10), this.stderr = r10 || `bash: ${t10}
`, this.fatal = s10;
    }
  }, wt = class extends gt {
    name = "BadSubstitutionError";
    constructor(t10, n10 = "", r10 = "") {
      super(t10, n10, r10), this.stderr = r10 || `bash: ${t10}: bad substitution
`;
    }
  }, on2 = class extends gt {
    name = "GlobError";
    constructor(t10, n10 = "", r10 = "") {
      super(`no match: ${t10}`, n10, r10), this.stderr = r10 || `bash: no match: ${t10}
`;
    }
  }, ur = class extends gt {
    name = "BraceExpansionError";
    constructor(t10, n10 = "", r10 = "") {
      super(t10, n10, r10), this.stderr = r10 || `bash: ${t10}
`;
    }
  }, te = class extends gt {
    limitType;
    name = "ExecutionLimitError";
    static EXIT_CODE = 126;
    constructor(t10, n10, r10 = "", s10 = "") {
      super(t10, r10, s10), this.limitType = n10, this.stderr = s10 || `bash: ${t10}
`;
    }
  }, an = class extends gt {
    name = "SubshellExitError";
    constructor(t10 = "", n10 = "") {
      super("subshell exit", t10, n10);
    }
  };
  Ut = class extends gt {
    exitCode;
    name = "PosixFatalError";
    constructor(t10, n10 = "", r10 = "") {
      super("posix fatal error", n10, r10), this.exitCode = t10;
    }
  };
});
function Me(e11) {
  return e11 instanceof Error ? e11.message : String(e11);
}
var Wt = I(() => {
  "use strict";
});
function Ms(e11, t10, n10) {
  let r10 = e11;
  n10 >= 0 && r10.length > n10 && (r10 = r10.slice(0, n10));
  let s10 = Math.abs(t10);
  return s10 > r10.length && (t10 < 0 ? r10 = r10.padEnd(s10, " ") : r10 = r10.padStart(s10, " ")), r10;
}
function hu(e11, t10) {
  let n10 = t10, r10 = 0, s10 = -1, i10 = false;
  for (n10 < e11.length && e11[n10] === "-" && (i10 = true, n10++); n10 < e11.length && /\d/.test(e11[n10]); )
    r10 = r10 * 10 + parseInt(e11[n10], 10), n10++;
  if (n10 < e11.length && e11[n10] === ".")
    for (n10++, s10 = 0; n10 < e11.length && /\d/.test(e11[n10]); )
      s10 = s10 * 10 + parseInt(e11[n10], 10), n10++;
  return i10 && r10 > 0 && (r10 = -r10), [r10, s10, n10 - t10];
}
function Us(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; )
    if (e11[n10] === "\\" && n10 + 1 < e11.length)
      switch (e11[n10 + 1]) {
        case "n":
          t10 += `
`, n10 += 2;
          break;
        case "t":
          t10 += "	", n10 += 2;
          break;
        case "r":
          t10 += "\r", n10 += 2;
          break;
        case "\\":
          t10 += "\\", n10 += 2;
          break;
        case "a":
          t10 += "\x07", n10 += 2;
          break;
        case "b":
          t10 += "\b", n10 += 2;
          break;
        case "f":
          t10 += "\f", n10 += 2;
          break;
        case "v":
          t10 += "\v", n10 += 2;
          break;
        case "e":
        case "E":
          t10 += "\x1B", n10 += 2;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7": {
          let s10 = "", i10 = n10 + 1;
          for (; i10 < e11.length && i10 < n10 + 4 && /[0-7]/.test(e11[i10]); )
            s10 += e11[i10], i10++;
          t10 += String.fromCharCode(parseInt(s10, 8)), n10 = i10;
          break;
        }
        case "x": {
          let s10 = [], i10 = n10;
          for (; i10 + 3 < e11.length && e11[i10] === "\\" && e11[i10 + 1] === "x" && /[0-9a-fA-F]{2}/.test(e11.slice(i10 + 2, i10 + 4)); )
            s10.push(parseInt(e11.slice(i10 + 2, i10 + 4), 16)), i10 += 4;
          if (s10.length > 0) {
            try {
              let o10 = new TextDecoder("utf-8", { fatal: true });
              t10 += o10.decode(new Uint8Array(s10));
            } catch {
              for (let o10 of s10)
                t10 += String.fromCharCode(o10);
            }
            n10 = i10;
          } else
            t10 += e11[n10], n10++;
          break;
        }
        case "u": {
          let s10 = "", i10 = n10 + 2;
          for (; i10 < e11.length && i10 < n10 + 6 && /[0-9a-fA-F]/.test(e11[i10]); )
            s10 += e11[i10], i10++;
          s10 ? (t10 += String.fromCodePoint(parseInt(s10, 16)), n10 = i10) : (t10 += "\\u", n10 += 2);
          break;
        }
        case "U": {
          let s10 = "", i10 = n10 + 2;
          for (; i10 < e11.length && i10 < n10 + 10 && /[0-9a-fA-F]/.test(e11[i10]); )
            s10 += e11[i10], i10++;
          s10 ? (t10 += String.fromCodePoint(parseInt(s10, 16)), n10 = i10) : (t10 += "\\U", n10 += 2);
          break;
        }
        default:
          t10 += e11[n10], n10++;
      }
    else
      t10 += e11[n10], n10++;
  return t10;
}
var To = I(() => {
  "use strict";
});
function gu(e11, t10, n10) {
  let r10 = new Date(t10 * 1e3), s10 = "", i10 = 0;
  for (; i10 < e11.length; )
    if (e11[i10] === "%" && i10 + 1 < e11.length) {
      let o10 = e11[i10 + 1], a = jg(r10, o10, n10);
      a !== null ? (s10 += a, i10 += 2) : (s10 += e11[i10], i10++);
    } else
      s10 += e11[i10], i10++;
  return s10;
}
function Hg(e11, t10) {
  let n10 = { year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", weekday: "short", hour12: false, timeZone: t10 };
  try {
    let s10 = new Intl.DateTimeFormat("en-US", n10).formatToParts(e11), i10 = (l) => s10.find((c) => c.type === l)?.value ?? "", o10 = /* @__PURE__ */ new Map([["Sun", 0], ["Mon", 1], ["Tue", 2], ["Wed", 3], ["Thu", 4], ["Fri", 5], ["Sat", 6]]), a = i10("weekday");
    return { year: Number.parseInt(i10("year"), 10) || e11.getFullYear(), month: Number.parseInt(i10("month"), 10) || e11.getMonth() + 1, day: Number.parseInt(i10("day"), 10) || e11.getDate(), hour: Number.parseInt(i10("hour"), 10) || e11.getHours(), minute: Number.parseInt(i10("minute"), 10) || e11.getMinutes(), second: Number.parseInt(i10("second"), 10) || e11.getSeconds(), weekday: o10.get(a) ?? e11.getDay() };
  } catch {
    return { year: e11.getFullYear(), month: e11.getMonth() + 1, day: e11.getDate(), hour: e11.getHours(), minute: e11.getMinutes(), second: e11.getSeconds(), weekday: e11.getDay() };
  }
}
function jg(e11, t10, n10) {
  let r10 = Hg(e11, n10), s10 = (l, c = 2) => String(l).padStart(c, "0"), i10 = yu(r10.year, r10.month, r10.day), o10 = du(r10.year, r10.month, r10.day, r10.weekday, 0), a = du(r10.year, r10.month, r10.day, r10.weekday, 1);
  switch (t10) {
    case "a":
      return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][r10.weekday];
    case "A":
      return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][r10.weekday];
    case "b":
    case "h":
      return ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][r10.month - 1];
    case "B":
      return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][r10.month - 1];
    case "c":
      return `${["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][r10.weekday]} ${["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][r10.month - 1]} ${String(r10.day).padStart(2, " ")} ${s10(r10.hour)}:${s10(r10.minute)}:${s10(r10.second)} ${r10.year}`;
    case "C":
      return s10(Math.floor(r10.year / 100));
    case "d":
      return s10(r10.day);
    case "D":
      return `${s10(r10.month)}/${s10(r10.day)}/${s10(r10.year % 100)}`;
    case "e":
      return String(r10.day).padStart(2, " ");
    case "F":
      return `${r10.year}-${s10(r10.month)}-${s10(r10.day)}`;
    case "g":
      return s10(mu(r10.year, r10.month, r10.day) % 100);
    case "G":
      return String(mu(r10.year, r10.month, r10.day));
    case "H":
      return s10(r10.hour);
    case "I":
      return s10(r10.hour % 12 || 12);
    case "j":
      return String(i10).padStart(3, "0");
    case "k":
      return String(r10.hour).padStart(2, " ");
    case "l":
      return String(r10.hour % 12 || 12).padStart(2, " ");
    case "m":
      return s10(r10.month);
    case "M":
      return s10(r10.minute);
    case "n":
      return `
`;
    case "N":
      return "000000000";
    case "p":
      return r10.hour < 12 ? "AM" : "PM";
    case "P":
      return r10.hour < 12 ? "am" : "pm";
    case "r":
      return `${s10(r10.hour % 12 || 12)}:${s10(r10.minute)}:${s10(r10.second)} ${r10.hour < 12 ? "AM" : "PM"}`;
    case "R":
      return `${s10(r10.hour)}:${s10(r10.minute)}`;
    case "s":
      return String(Math.floor(e11.getTime() / 1e3));
    case "S":
      return s10(r10.second);
    case "t":
      return "	";
    case "T":
      return `${s10(r10.hour)}:${s10(r10.minute)}:${s10(r10.second)}`;
    case "u":
      return String(r10.weekday === 0 ? 7 : r10.weekday);
    case "U":
      return s10(o10);
    case "V":
      return s10(qg(r10.year, r10.month, r10.day));
    case "w":
      return String(r10.weekday);
    case "W":
      return s10(a);
    case "x":
      return `${s10(r10.month)}/${s10(r10.day)}/${s10(r10.year % 100)}`;
    case "X":
      return `${s10(r10.hour)}:${s10(r10.minute)}:${s10(r10.second)}`;
    case "y":
      return s10(r10.year % 100);
    case "Y":
      return String(r10.year);
    case "z":
      return Gg(e11, n10);
    case "Z":
      return Vg(e11, n10);
    case "%":
      return "%";
    default:
      return null;
  }
}
function Gg(e11, t10) {
  if (!t10) {
    let o10 = -e11.getTimezoneOffset(), a = o10 >= 0 ? "+" : "-", l = Math.floor(Math.abs(o10) / 60), c = Math.abs(o10) % 60;
    return `${a}${String(l).padStart(2, "0")}${String(c).padStart(2, "0")}`;
  }
  try {
    let l = new Intl.DateTimeFormat("en-US", { timeZone: t10, timeZoneName: "longOffset" }).formatToParts(e11).find((c) => c.type === "timeZoneName");
    if (l) {
      let c = l.value.match(/GMT([+-])(\d{2}):(\d{2})/);
      if (c)
        return `${c[1]}${c[2]}${c[3]}`;
      if (l.value === "GMT" || l.value === "UTC")
        return "+0000";
    }
  } catch {
  }
  let n10 = -e11.getTimezoneOffset(), r10 = n10 >= 0 ? "+" : "-", s10 = Math.floor(Math.abs(n10) / 60), i10 = Math.abs(n10) % 60;
  return `${r10}${String(s10).padStart(2, "0")}${String(i10).padStart(2, "0")}`;
}
function Vg(e11, t10) {
  try {
    return new Intl.DateTimeFormat("en-US", { timeZone: t10, timeZoneName: "short" }).formatToParts(e11).find((i10) => i10.type === "timeZoneName")?.value ?? "UTC";
  } catch {
    return "UTC";
  }
}
function yu(e11, t10, n10) {
  let r10 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  (e11 % 4 === 0 && e11 % 100 !== 0 || e11 % 400 === 0) && (r10[1] = 29);
  let i10 = n10;
  for (let o10 = 0; o10 < t10 - 1; o10++)
    i10 += r10[o10];
  return i10;
}
function du(e11, t10, n10, r10, s10) {
  let i10 = yu(e11, t10, n10), l = (new Date(e11, 0, 1).getDay() - s10 + 7) % 7, c = (r10 - s10 + 7) % 7, u = i10 - 1 + l;
  return Math.floor((u - c + 7) / 7);
}
function qg(e11, t10, n10) {
  let r10 = new Date(e11, t10 - 1, n10, 12, 0, 0);
  r10.setDate(r10.getDate() + 3 - (r10.getDay() + 6) % 7);
  let s10 = new Date(r10.getFullYear(), 0, 4);
  s10.setDate(s10.getDate() + 3 - (s10.getDay() + 6) % 7);
  let i10 = r10.getTime() - s10.getTime();
  return 1 + Math.round(i10 / (10080 * 60 * 1e3));
}
function mu(e11, t10, n10) {
  let r10 = new Date(e11, t10 - 1, n10, 12, 0, 0);
  return r10.setDate(r10.getDate() + 3 - (r10.getDay() + 6) % 7), r10.getFullYear();
}
var wu = I(() => {
  "use strict";
});
var xu = {};
Q(xu, { flagsForFuzzing: () => o7, printfCommand: () => Kg });
function Zg(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; ) {
    let r10 = e11[n10];
    if (r10 < 128) {
      t10 += String.fromCharCode(r10), n10++;
      continue;
    }
    if ((r10 & 224) === 192) {
      if (n10 + 1 < e11.length && (e11[n10 + 1] & 192) === 128 && r10 >= 194) {
        let s10 = (r10 & 31) << 6 | e11[n10 + 1] & 63;
        t10 += String.fromCharCode(s10), n10 += 2;
        continue;
      }
      t10 += String.fromCharCode(r10), n10++;
      continue;
    }
    if ((r10 & 240) === 224) {
      if (n10 + 2 < e11.length && (e11[n10 + 1] & 192) === 128 && (e11[n10 + 2] & 192) === 128) {
        if (r10 === 224 && e11[n10 + 1] < 160) {
          t10 += String.fromCharCode(r10), n10++;
          continue;
        }
        let s10 = (r10 & 15) << 12 | (e11[n10 + 1] & 63) << 6 | e11[n10 + 2] & 63;
        if (s10 >= 55296 && s10 <= 57343) {
          t10 += String.fromCharCode(r10), n10++;
          continue;
        }
        t10 += String.fromCharCode(s10), n10 += 3;
        continue;
      }
      t10 += String.fromCharCode(r10), n10++;
      continue;
    }
    if ((r10 & 248) === 240 && r10 <= 244) {
      if (n10 + 3 < e11.length && (e11[n10 + 1] & 192) === 128 && (e11[n10 + 2] & 192) === 128 && (e11[n10 + 3] & 192) === 128) {
        if (r10 === 240 && e11[n10 + 1] < 144) {
          t10 += String.fromCharCode(r10), n10++;
          continue;
        }
        let s10 = (r10 & 7) << 18 | (e11[n10 + 1] & 63) << 12 | (e11[n10 + 2] & 63) << 6 | e11[n10 + 3] & 63;
        if (s10 > 1114111) {
          t10 += String.fromCharCode(r10), n10++;
          continue;
        }
        t10 += String.fromCodePoint(s10), n10 += 4;
        continue;
      }
      t10 += String.fromCharCode(r10), n10++;
      continue;
    }
    t10 += String.fromCharCode(r10), n10++;
  }
  return t10;
}
function Xg(e11, t10, n10, r10) {
  let s10 = "", i10 = 0, o10 = 0, a = false, l = "";
  for (; i10 < e11.length; )
    if (e11[i10] === "%" && i10 + 1 < e11.length) {
      let c = i10;
      if (i10++, e11[i10] === "%") {
        s10 += "%", i10++;
        continue;
      }
      let u = e11.slice(c).match(/^%(-?\d*)(?:\.(\d+))?\(([^)]*)\)T/);
      if (u) {
        let S = u[1] ? parseInt(u[1], 10) : 0, O = u[2] ? parseInt(u[2], 10) : -1, R10 = u[3], F4 = u[0], $ = t10[n10 + o10] || "";
        o10++;
        let z;
        $ === "" || $ === "-1" || $ === "-2" ? z = Math.floor(Date.now() / 1e3) : z = parseInt($, 10) || 0;
        let k = gu(R10, z, r10);
        if (O >= 0 && k.length > O && (k = k.slice(0, O)), S !== 0) {
          let N10 = Math.abs(S);
          k.length < N10 && (S < 0 ? k = k.padEnd(N10, " ") : k = k.padStart(N10, " "));
        }
        s10 += k, i10 = c + F4.length;
        continue;
      }
      for (; i10 < e11.length && "+-0 #'".includes(e11[i10]); )
        i10++;
      let f10 = false;
      if (e11[i10] === "*")
        f10 = true, i10++;
      else
        for (; i10 < e11.length && /\d/.test(e11[i10]); )
          i10++;
      let p = false;
      if (e11[i10] === ".")
        if (i10++, e11[i10] === "*")
          p = true, i10++;
        else
          for (; i10 < e11.length && /\d/.test(e11[i10]); )
            i10++;
      i10 < e11.length && "hlL".includes(e11[i10]) && i10++;
      let h = e11[i10] || "";
      i10++;
      let d = e11.slice(c, i10);
      if (f10) {
        let S = parseInt(t10[n10 + o10] || "0", 10);
        o10++, d = d.replace("*", String(S));
      }
      if (p) {
        let S = parseInt(t10[n10 + o10] || "0", 10);
        o10++, d = d.replace(".*", `.${S}`);
      }
      let g = t10[n10 + o10] || "";
      o10++;
      let { value: y, parseError: w, parseErrMsg: b, stopped: x } = Yg(d, h, g);
      if (s10 += y, w && (a = true, b && (l = b)), x)
        return { result: s10, argsConsumed: o10, error: a, errMsg: l, stopped: true };
    } else
      s10 += e11[i10], i10++;
  return { result: s10, argsConsumed: o10, error: a, errMsg: l, stopped: false };
}
function Yg(e11, t10, n10) {
  let r10 = false, s10 = "";
  switch (t10) {
    case "d":
    case "i": {
      let i10 = Ws(n10);
      return r10 = Kt, r10 && (s10 = `printf: ${n10}: invalid number
`), { value: bu(e11, i10), parseError: r10, parseErrMsg: s10 };
    }
    case "o": {
      let i10 = Ws(n10);
      return r10 = Kt, r10 && (s10 = `printf: ${n10}: invalid number
`), { value: Jg(e11, i10), parseError: r10, parseErrMsg: s10 };
    }
    case "u": {
      let i10 = Ws(n10);
      r10 = Kt, r10 && (s10 = `printf: ${n10}: invalid number
`);
      let o10 = i10 < 0 ? i10 >>> 0 : i10;
      return { value: bu(e11.replace("u", "d"), o10), parseError: r10, parseErrMsg: s10 };
    }
    case "x":
    case "X": {
      let i10 = Ws(n10);
      return r10 = Kt, r10 && (s10 = `printf: ${n10}: invalid number
`), { value: e7(e11, i10), parseError: r10, parseErrMsg: s10 };
    }
    case "e":
    case "E":
    case "f":
    case "F":
    case "g":
    case "G": {
      let i10 = parseFloat(n10) || 0;
      return { value: s7(e11, t10, i10), parseError: false, parseErrMsg: "" };
    }
    case "c": {
      if (n10 === "")
        return { value: "", parseError: false, parseErrMsg: "" };
      let a = new TextEncoder().encode(n10)[0];
      return { value: String.fromCharCode(a), parseError: false, parseErrMsg: "" };
    }
    case "s":
      return { value: n7(e11, n10), parseError: false, parseErrMsg: "" };
    case "q":
      return { value: r7(e11, n10), parseError: false, parseErrMsg: "" };
    case "b": {
      let i10 = i7(n10);
      return { value: i10.value, parseError: false, parseErrMsg: "", stopped: i10.stopped };
    }
    default:
      try {
        return { value: (0, import_sprintf_js.sprintf)(e11, n10), parseError: false, parseErrMsg: "" };
      } catch {
        return { value: "", parseError: true, parseErrMsg: `printf: [sprintf] unexpected placeholder
` };
      }
  }
}
function Ws(e11) {
  Kt = false;
  let t10 = e11.trimStart(), n10 = t10 !== t10.trimEnd();
  if (e11 = t10.trimEnd(), e11.startsWith("'") && e11.length >= 2 || e11.startsWith('"') && e11.length >= 2)
    return e11.charCodeAt(1);
  if (e11.startsWith("\\'") && e11.length >= 3 || e11.startsWith('\\"') && e11.length >= 3)
    return e11.charCodeAt(2);
  if (e11.startsWith("+") && (e11 = e11.slice(1)), e11.startsWith("0x") || e11.startsWith("0X")) {
    let r10 = parseInt(e11, 16);
    return Number.isNaN(r10) ? (Kt = true, 0) : (n10 && (Kt = true), r10);
  }
  if (e11.startsWith("0") && e11.length > 1 && /^-?0[0-7]+$/.test(e11))
    return n10 && (Kt = true), parseInt(e11, 8) || 0;
  if (/^\d+#/.test(e11)) {
    Kt = true;
    let r10 = e11.match(/^(\d+)#/);
    return r10 ? parseInt(r10[1], 10) : 0;
  }
  if (e11 !== "" && !/^-?\d+$/.test(e11)) {
    Kt = true;
    let r10 = parseInt(e11, 10);
    return Number.isNaN(r10) ? 0 : r10;
  }
  return n10 && (Kt = true), parseInt(e11, 10) || 0;
}
function bu(e11, t10) {
  let n10 = e11.match(/^%([- +#0']*)(\d*)(\.(\d*))?[diu]$/);
  if (!n10)
    return (0, import_sprintf_js.sprintf)(e11.replace(/\.\d*/, ""), t10);
  let r10 = n10[1] || "", s10 = n10[2] ? parseInt(n10[2], 10) : 0, i10 = n10[3] !== void 0 ? n10[4] ? parseInt(n10[4], 10) : 0 : -1, o10 = t10 < 0, a = Math.abs(t10), l = String(a);
  i10 >= 0 && (l = l.padStart(i10, "0"));
  let c = "";
  o10 ? c = "-" : r10.includes("+") ? c = "+" : r10.includes(" ") && (c = " ");
  let u = c + l;
  return s10 > u.length && (r10.includes("-") ? u = u.padEnd(s10, " ") : r10.includes("0") && i10 < 0 ? u = c + l.padStart(s10 - c.length, "0") : u = u.padStart(s10, " ")), u;
}
function Jg(e11, t10) {
  let n10 = e11.match(/^%([- +#0']*)(\d*)(\.(\d*))?o$/);
  if (!n10)
    return (0, import_sprintf_js.sprintf)(e11, t10);
  let r10 = n10[1] || "", s10 = n10[2] ? parseInt(n10[2], 10) : 0, i10 = n10[3] !== void 0 ? n10[4] ? parseInt(n10[4], 10) : 0 : -1, o10 = Math.abs(t10).toString(8);
  i10 >= 0 && (o10 = o10.padStart(i10, "0")), r10.includes("#") && !o10.startsWith("0") && (o10 = `0${o10}`);
  let a = o10;
  return s10 > a.length && (r10.includes("-") ? a = a.padEnd(s10, " ") : r10.includes("0") && i10 < 0 ? a = a.padStart(s10, "0") : a = a.padStart(s10, " ")), a;
}
function e7(e11, t10) {
  let n10 = e11.includes("X"), r10 = e11.match(/^%([- +#0']*)(\d*)(\.(\d*))?[xX]$/);
  if (!r10)
    return (0, import_sprintf_js.sprintf)(e11, t10);
  let s10 = r10[1] || "", i10 = r10[2] ? parseInt(r10[2], 10) : 0, o10 = r10[3] !== void 0 ? r10[4] ? parseInt(r10[4], 10) : 0 : -1, a = Math.abs(t10).toString(16);
  n10 && (a = a.toUpperCase()), o10 >= 0 && (a = a.padStart(o10, "0"));
  let l = "";
  s10.includes("#") && t10 !== 0 && (l = n10 ? "0X" : "0x");
  let c = l + a;
  return i10 > c.length && (s10.includes("-") ? c = c.padEnd(i10, " ") : s10.includes("0") && o10 < 0 ? c = l + a.padStart(i10 - l.length, "0") : c = c.padStart(i10, " ")), c;
}
function t7(e11) {
  if (e11 === "")
    return "''";
  if (/^[a-zA-Z0-9_./-]+$/.test(e11))
    return e11;
  if (/[\x00-\x1f\x7f-\xff]/.test(e11)) {
    let r10 = "$'";
    for (let s10 of e11) {
      let i10 = s10.charCodeAt(0);
      s10 === "'" ? r10 += "\\'" : s10 === "\\" ? r10 += "\\\\" : s10 === `
` ? r10 += "\\n" : s10 === "	" ? r10 += "\\t" : s10 === "\r" ? r10 += "\\r" : s10 === "\x07" ? r10 += "\\a" : s10 === "\b" ? r10 += "\\b" : s10 === "\f" ? r10 += "\\f" : s10 === "\v" ? r10 += "\\v" : s10 === "\x1B" ? r10 += "\\E" : i10 < 32 || i10 >= 127 && i10 <= 255 ? r10 += `\\${i10.toString(8).padStart(3, "0")}` : s10 === '"' ? r10 += '\\"' : r10 += s10;
    }
    return r10 += "'", r10;
  }
  let n10 = "";
  for (let r10 of e11)
    " 	|&;<>()$`\\\"'*?[#~=%!{}".includes(r10) ? n10 += `\\${r10}` : n10 += r10;
  return n10;
}
function n7(e11, t10) {
  let n10 = e11.match(/^%(-?)(\d*)(\.(\d*))?s$/);
  if (!n10)
    return (0, import_sprintf_js.sprintf)(e11.replace(/0+(?=\d)/, ""), t10);
  let r10 = n10[1] === "-", s10 = n10[2] ? parseInt(n10[2], 10) : 0, i10 = n10[3] !== void 0 ? n10[4] ? parseInt(n10[4], 10) : 0 : -1, o10 = r10 ? -s10 : s10;
  return Ms(t10, o10, i10);
}
function r7(e11, t10) {
  let n10 = t7(t10), r10 = e11.match(/^%(-?)(\d*)q$/);
  if (!r10)
    return n10;
  let s10 = r10[1] === "-", i10 = r10[2] ? parseInt(r10[2], 10) : 0, o10 = n10;
  return i10 > o10.length && (s10 ? o10 = o10.padEnd(i10, " ") : o10 = o10.padStart(i10, " ")), o10;
}
function s7(e11, t10, n10) {
  let r10 = e11.match(/^%([- +#0']*)(\d*)(\.(\d*))?[eEfFgG]$/);
  if (!r10)
    return (0, import_sprintf_js.sprintf)(e11, n10);
  let s10 = r10[1] || "", i10 = r10[2] ? parseInt(r10[2], 10) : 0, o10 = r10[3] !== void 0 ? r10[4] ? parseInt(r10[4], 10) : 0 : 6, a, l = t10.toLowerCase();
  if (l === "e" ? (a = n10.toExponential(o10), a = a.replace(/e([+-])(\d)$/, "e$10$2"), t10 === "E" && (a = a.toUpperCase())) : l === "f" ? (a = n10.toFixed(o10), s10.includes("#") && o10 === 0 && !a.includes(".") && (a += ".")) : l === "g" ? (a = n10.toPrecision(o10 || 1), s10.includes("#") || (a = a.replace(/\.?0+$/, ""), a = a.replace(/\.?0+e/, "e")), a = a.replace(/e([+-])(\d)$/, "e$10$2"), t10 === "G" && (a = a.toUpperCase())) : a = n10.toString(), n10 >= 0 && (s10.includes("+") ? a = `+${a}` : s10.includes(" ") && (a = ` ${a}`)), i10 > a.length)
    if (s10.includes("-"))
      a = a.padEnd(i10, " ");
    else if (s10.includes("0")) {
      let c = a.match(/^[+ -]/)?.[0] || "", u = c ? a.slice(1) : a;
      a = c + u.padStart(i10 - c.length, "0");
    } else
      a = a.padStart(i10, " ");
  return a;
}
function i7(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; )
    if (e11[n10] === "\\" && n10 + 1 < e11.length)
      switch (e11[n10 + 1]) {
        case "n":
          t10 += `
`, n10 += 2;
          break;
        case "t":
          t10 += "	", n10 += 2;
          break;
        case "r":
          t10 += "\r", n10 += 2;
          break;
        case "\\":
          t10 += "\\", n10 += 2;
          break;
        case "a":
          t10 += "\x07", n10 += 2;
          break;
        case "b":
          t10 += "\b", n10 += 2;
          break;
        case "f":
          t10 += "\f", n10 += 2;
          break;
        case "v":
          t10 += "\v", n10 += 2;
          break;
        case "c":
          return { value: t10, stopped: true };
        case "x": {
          let s10 = [], i10 = n10;
          for (; i10 + 1 < e11.length && e11[i10] === "\\" && e11[i10 + 1] === "x"; ) {
            let o10 = "", a = i10 + 2;
            for (; a < e11.length && a < i10 + 4 && /[0-9a-fA-F]/.test(e11[a]); )
              o10 += e11[a], a++;
            if (o10)
              s10.push(parseInt(o10, 16)), i10 = a;
            else
              break;
          }
          s10.length > 0 ? (t10 += Zg(s10), n10 = i10) : (t10 += "\\x", n10 += 2);
          break;
        }
        case "u": {
          let s10 = "", i10 = n10 + 2;
          for (; i10 < e11.length && i10 < n10 + 6 && /[0-9a-fA-F]/.test(e11[i10]); )
            s10 += e11[i10], i10++;
          s10 ? (t10 += String.fromCodePoint(parseInt(s10, 16)), n10 = i10) : (t10 += "\\u", n10 += 2);
          break;
        }
        case "0": {
          let s10 = "", i10 = n10 + 2;
          for (; i10 < e11.length && i10 < n10 + 5 && /[0-7]/.test(e11[i10]); )
            s10 += e11[i10], i10++;
          s10 ? t10 += String.fromCharCode(parseInt(s10, 8)) : t10 += "\0", n10 = i10;
          break;
        }
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7": {
          let s10 = "", i10 = n10 + 1;
          for (; i10 < e11.length && i10 < n10 + 4 && /[0-7]/.test(e11[i10]); )
            s10 += e11[i10], i10++;
          t10 += String.fromCharCode(parseInt(s10, 8)), n10 = i10;
          break;
        }
        default:
          t10 += e11[n10], n10++;
      }
    else
      t10 += e11[n10], n10++;
  return { value: t10, stopped: false };
}
var Qg;
var Kg;
var Kt;
var o7;
var Eu = I(() => {
  "use strict";
  ye();
  Wt();
  se();
  To();
  wu();
  Qg = { name: "printf", summary: "format and print data", usage: "printf [-v var] FORMAT [ARGUMENT...]", options: ["    -v var     assign the output to shell variable VAR rather than display it", "    --help     display this help and exit"], notes: ["FORMAT controls the output like in C printf.", "Escape sequences: \\n (newline), \\t (tab), \\\\ (backslash)", "Format specifiers: %s (string), %d (integer), %f (float), %x (hex), %o (octal), %% (literal %)", "Width and precision: %10s (width 10), %.2f (2 decimal places), %010d (zero-padded)", "Flags: %- (left-justify), %+ (show sign), %0 (zero-pad)"] }, Kg = { name: "printf", async execute(e11, t10) {
    if (U2(e11))
      return M(Qg);
    if (e11.length === 0)
      return { stdout: "", stderr: `printf: usage: printf format [arguments]
`, exitCode: 2 };
    let n10 = null, r10 = 0;
    for (; r10 < e11.length; ) {
      let o10 = e11[r10];
      if (o10 === "--") {
        r10++;
        break;
      }
      if (o10 === "-v") {
        if (r10 + 1 >= e11.length)
          return { stdout: "", stderr: `printf: -v: option requires an argument
`, exitCode: 1 };
        if (n10 = e11[r10 + 1], !/^[a-zA-Z_][a-zA-Z0-9_]*(\[[^\]]+\])?$/.test(n10))
          return { stdout: "", stderr: `printf: \`${n10}': not a valid identifier
`, exitCode: 2 };
        r10 += 2;
      } else {
        if (o10.startsWith("-") && o10 !== "-")
          break;
        break;
      }
    }
    if (r10 >= e11.length)
      return { stdout: "", stderr: `printf: usage: printf format [arguments]
`, exitCode: 1 };
    let s10 = e11[r10], i10 = e11.slice(r10 + 1);
    try {
      let o10 = Us(s10), a = "", l = 0, c = false, u = "", f10 = t10.env.get("TZ"), p = t10.limits?.maxStringLength;
      do {
        let { result: h, argsConsumed: m, error: d, errMsg: g, stopped: y } = Xg(o10, i10, l, f10);
        if (a += h, p !== void 0 && p > 0 && a.length > p)
          throw new te(`printf: output size limit exceeded (${p} bytes)`, "string_length");
        if (l += m, d && (c = true, g && (u = g)), y)
          break;
      } while (l < i10.length && l > 0);
      if (l === 0 && i10.length > 0, n10) {
        let h = n10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(['"]?)(.+?)\2\]$/);
        if (h) {
          let m = h[1], d = h[3];
          d = d.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (g, y) => t10.env.get(y) ?? ""), t10.env.set(`${m}_${d}`, a);
        } else
          t10.env.set(n10, a);
        return { stdout: "", stderr: u, exitCode: c ? 1 : 0 };
      }
      return { stdout: a, stderr: u, exitCode: c ? 1 : 0 };
    } catch (o10) {
      if (o10 instanceof te)
        throw o10;
      return { stdout: "", stderr: `printf: ${Me(o10)}
`, exitCode: 1 };
    }
  } };
  Kt = false;
  o7 = { name: "printf", flags: [{ flag: "-v", type: "value", valueHint: "string" }], stdinType: "none", needsArgs: true };
});
var Cu = {};
Q(Cu, { flagsForFuzzing: () => f7, lsCommand: () => c7 });
function Bs(e11) {
  if (e11 < 1024)
    return String(e11);
  if (e11 < 1024 * 1024) {
    let n10 = e11 / 1024;
    return n10 < 10 ? `${n10.toFixed(1)}K` : `${Math.round(n10)}K`;
  }
  if (e11 < 1024 * 1024 * 1024) {
    let n10 = e11 / 1048576;
    return n10 < 10 ? `${n10.toFixed(1)}M` : `${Math.round(n10)}M`;
  }
  let t10 = e11 / (1024 * 1024 * 1024);
  return t10 < 10 ? `${t10.toFixed(1)}G` : `${Math.round(t10)}G`;
}
function zs(e11) {
  let n10 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][e11.getMonth()], r10 = String(e11.getDate()).padStart(2, " "), s10 = /* @__PURE__ */ new Date(), i10 = new Date(s10.getTime() - 4320 * 60 * 60 * 1e3);
  if (e11 > i10) {
    let a = String(e11.getHours()).padStart(2, "0"), l = String(e11.getMinutes()).padStart(2, "0");
    return `${n10} ${r10} ${a}:${l}`;
  }
  let o10 = e11.getFullYear();
  return `${n10} ${r10}  ${o10}`;
}
async function u7(e11, t10, n10, r10, s10, i10 = false, o10 = false, a = false) {
  let l = n10 || r10, c = t10.fs.getAllPaths(), u = t10.fs.resolvePath(t10.cwd, "."), f10 = [];
  for (let p of c) {
    let h = p.startsWith(u) && p.slice(u.length + 1) || p;
    if (minimatch(h, e11) || minimatch(p, e11)) {
      let m = h.split("/").pop() || h;
      if (!l && m.startsWith("."))
        continue;
      f10.push(h || p);
    }
  }
  if (f10.length === 0)
    return { stdout: "", stderr: `ls: ${e11}: No such file or directory
`, exitCode: 2 };
  if (a) {
    let p = [];
    for (let h of f10) {
      let m = t10.fs.resolvePath(t10.cwd, h);
      try {
        let d = await t10.fs.stat(m);
        p.push({ path: h, size: d.size ?? 0 });
      } catch {
        p.push({ path: h, size: 0 });
      }
    }
    p.sort((h, m) => m.size - h.size), f10.length = 0, f10.push(...p.map((h) => h.path));
  } else
    f10.sort();
  if (i10 && f10.reverse(), s10) {
    let p = [];
    for (let h of f10) {
      let m = t10.fs.resolvePath(t10.cwd, h);
      try {
        let d = await t10.fs.stat(m), g = d.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", y = d.isDirectory ? "/" : "", w = d.size ?? 0, b = o10 ? Bs(w).padStart(5) : String(w).padStart(5), x = d.mtime ?? /* @__PURE__ */ new Date(0), S = zs(x);
        p.push(`${g} 1 user user ${b} ${S} ${h}${y}`);
      } catch {
        p.push(`-rw-r--r-- 1 user user     0 Jan  1 00:00 ${h}`);
      }
    }
    return { stdout: `${p.join(`
`)}
`, stderr: "", exitCode: 0 };
  }
  return { stdout: `${f10.join(`
`)}
`, stderr: "", exitCode: 0 };
}
async function Su(e11, t10, n10, r10, s10, i10, o10, a = false, l = false, c = false, u = false) {
  let f10 = n10 || r10, p = t10.fs.resolvePath(t10.cwd, e11);
  try {
    let h = await t10.fs.stat(p);
    if (!h.isDirectory) {
      if (s10) {
        let g = h.size ?? 0, y = l ? Bs(g).padStart(5) : String(g).padStart(5), w = h.mtime ?? /* @__PURE__ */ new Date(0), b = zs(w);
        return { stdout: `-rw-r--r-- 1 user user ${y} ${b} ${e11}
`, stderr: "", exitCode: 0 };
      }
      return { stdout: `${e11}
`, stderr: "", exitCode: 0 };
    }
    let m = await t10.fs.readdir(p);
    if (f10 || (m = m.filter((g) => !g.startsWith("."))), c) {
      let g = [];
      for (let y of m) {
        let w = p === "/" ? `/${y}` : `${p}/${y}`;
        try {
          let b = await t10.fs.stat(w);
          g.push({ name: y, size: b.size ?? 0 });
        } catch {
          g.push({ name: y, size: 0 });
        }
      }
      g.sort((y, w) => w.size - y.size), m = g.map((y) => y.name);
    } else
      m.sort();
    n10 && (m = [".", "..", ...m]), a && m.reverse();
    let d = "";
    if ((i10 || o10) && (d += `${e11}:
`), s10) {
      d += `total ${m.length}
`;
      let g = m.filter((x) => x === "." || x === ".."), y = m.filter((x) => x !== "." && x !== "..");
      for (let x of g)
        d += `drwxr-xr-x 1 user user     0 Jan  1 00:00 ${x}
`;
      let w = [];
      for (let x = 0; x < y.length; x += 100) {
        let S = y.slice(x, x + 100), O = await Promise.all(S.map(async (R10) => {
          let F4 = p === "/" ? `/${R10}` : `${p}/${R10}`;
          try {
            let $ = await t10.fs.stat(F4), z = $.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", k = $.isDirectory ? "/" : "", N10 = $.size ?? 0, P = l ? Bs(N10).padStart(5) : String(N10).padStart(5), v = $.mtime ?? /* @__PURE__ */ new Date(0), T = zs(v);
            return { name: R10, line: `${z} 1 user user ${P} ${T} ${R10}${k}
` };
          } catch {
            return { name: R10, line: `-rw-r--r-- 1 user user     0 Jan  1 00:00 ${R10}
` };
          }
        }));
        w.push(...O);
      }
      let b = new Map(y.map((x, S) => [x, S]));
      w.sort((x, S) => (b.get(x.name) ?? 0) - (b.get(S.name) ?? 0));
      for (let { line: x } of w)
        d += x;
    } else
      d += m.join(`
`) + (m.length ? `
` : "");
    if (i10) {
      let g = m.filter((b) => b !== "." && b !== ".."), y = [];
      if (t10.fs.readdirWithFileTypes)
        y = (await t10.fs.readdirWithFileTypes(p)).filter((x) => x.isDirectory && g.includes(x.name)).map((x) => ({ name: x.name, isDirectory: true }));
      else
        for (let b = 0; b < g.length; b += 100) {
          let x = g.slice(b, b + 100), S = await Promise.all(x.map(async (O) => {
            let R10 = p === "/" ? `/${O}` : `${p}/${O}`;
            try {
              let F4 = await t10.fs.stat(R10);
              return { name: O, isDirectory: F4.isDirectory };
            } catch {
              return { name: O, isDirectory: false };
            }
          }));
          y.push(...S.filter((O) => O.isDirectory));
        }
      y.sort((b, x) => b.name.localeCompare(x.name)), a && y.reverse();
      let w = [];
      for (let b = 0; b < y.length; b += 100) {
        let x = y.slice(b, b + 100), S = await Promise.all(x.map(async (O) => {
          let R10 = e11 === "." ? `./${O.name}` : `${e11}/${O.name}`, F4 = await Su(R10, t10, n10, r10, s10, i10, false, a, l, c, true);
          return { name: O.name, result: F4 };
        }));
        w.push(...S);
      }
      w.sort((b, x) => b.name.localeCompare(x.name)), a && w.reverse();
      for (let { result: b } of w)
        d += `
`, d += b.stdout;
    }
    return { stdout: d, stderr: "", exitCode: 0 };
  } catch {
    return { stdout: "", stderr: `ls: ${e11}: No such file or directory
`, exitCode: 2 };
  }
}
var a7;
var l7;
var c7;
var f7;
var Nu = I(() => {
  "use strict";
  qe();
  lr();
  se();
  a7 = { name: "ls", summary: "list directory contents", usage: "ls [OPTION]... [FILE]...", options: ["-a, --all            do not ignore entries starting with .", "-A, --almost-all     do not list . and ..", "-d, --directory      list directories themselves, not their contents", "-h, --human-readable with -l, print sizes like 1K 234M 2G etc.", "-l                   use a long listing format", "-r, --reverse        reverse order while sorting", "-R, --recursive      list subdirectories recursively", "-S                   sort by file size, largest first", "-t                   sort by time, newest first", "-1                   list one file per line", "    --help           display this help and exit"] }, l7 = { showAll: { short: "a", long: "all", type: "boolean" }, showAlmostAll: { short: "A", long: "almost-all", type: "boolean" }, longFormat: { short: "l", type: "boolean" }, humanReadable: { short: "h", long: "human-readable", type: "boolean" }, recursive: { short: "R", long: "recursive", type: "boolean" }, reverse: { short: "r", long: "reverse", type: "boolean" }, sortBySize: { short: "S", type: "boolean" }, directoryOnly: { short: "d", long: "directory", type: "boolean" }, sortByTime: { short: "t", type: "boolean" }, onePerLine: { short: "1", type: "boolean" } }, c7 = { name: "ls", async execute(e11, t10) {
    if (U2(e11))
      return M(a7);
    let n10 = be("ls", e11, l7);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.showAll, s10 = n10.result.flags.showAlmostAll, i10 = n10.result.flags.longFormat, o10 = n10.result.flags.humanReadable, a = n10.result.flags.recursive, l = n10.result.flags.reverse, c = n10.result.flags.sortBySize, u = n10.result.flags.directoryOnly, f10 = n10.result.flags.sortByTime;
    n10.result.flags.onePerLine;
    let p = n10.result.positional;
    p.length === 0 && p.push(".");
    let h = "", m = "", d = 0;
    for (let g = 0; g < p.length; g++) {
      let y = p[g];
      if (g > 0 && h && !h.endsWith(`

`) && (h += `
`), u) {
        let w = t10.fs.resolvePath(t10.cwd, y);
        try {
          let b = await t10.fs.stat(w);
          if (i10) {
            let x = b.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", S = b.isDirectory ? "/" : "", O = b.size ?? 0, R10 = o10 ? Bs(O).padStart(5) : String(O).padStart(5), F4 = b.mtime ?? /* @__PURE__ */ new Date(0), $ = zs(F4);
            h += `${x} 1 user user ${R10} ${$} ${y}${S}
`;
          } else
            h += `${y}
`;
        } catch {
          m += `ls: cannot access '${y}': No such file or directory
`, d = 2;
        }
        continue;
      }
      if (y.includes("*") || y.includes("?") || y.includes("[")) {
        let w = await u7(y, t10, r10, s10, i10, l, o10, c);
        h += w.stdout, m += w.stderr, w.exitCode !== 0 && (d = w.exitCode);
      } else {
        let w = await Su(y, t10, r10, s10, i10, a, p.length > 1, l, o10, c);
        h += w.stdout, m += w.stderr, w.exitCode !== 0 && (d = w.exitCode);
      }
    }
    return { stdout: h, stderr: m, exitCode: d };
  } };
  f7 = { name: "ls", flags: [{ flag: "-a", type: "boolean" }, { flag: "-A", type: "boolean" }, { flag: "-l", type: "boolean" }, { flag: "-h", type: "boolean" }, { flag: "-R", type: "boolean" }, { flag: "-r", type: "boolean" }, { flag: "-S", type: "boolean" }, { flag: "-d", type: "boolean" }, { flag: "-t", type: "boolean" }, { flag: "-1", type: "boolean" }], needsFiles: true };
});
var ku = {};
Q(ku, { flagsForFuzzing: () => d7, mkdirCommand: () => h7 });
var p7;
var h7;
var d7;
var vu = I(() => {
  "use strict";
  Wt();
  qe();
  p7 = { recursive: { short: "p", long: "parents", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, h7 = { name: "mkdir", async execute(e11, t10) {
    let n10 = be("mkdir", e11, p7);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.recursive, s10 = n10.result.flags.verbose, i10 = n10.result.positional;
    if (i10.length === 0)
      return { stdout: "", stderr: `mkdir: missing operand
`, exitCode: 1 };
    let o10 = "", a = "", l = 0;
    for (let c of i10)
      try {
        let u = t10.fs.resolvePath(t10.cwd, c);
        await t10.fs.mkdir(u, { recursive: r10 }), s10 && (o10 += `mkdir: created directory '${c}'
`);
      } catch (u) {
        let f10 = Me(u);
        f10.includes("ENOENT") || f10.includes("no such file") ? a += `mkdir: cannot create directory '${c}': No such file or directory
` : f10.includes("EEXIST") || f10.includes("already exists") ? a += `mkdir: cannot create directory '${c}': File exists
` : a += `mkdir: cannot create directory '${c}': ${f10}
`, l = 1;
      }
    return { stdout: o10, stderr: a, exitCode: l };
  } }, d7 = { name: "mkdir", flags: [{ flag: "-p", type: "boolean" }, { flag: "-v", type: "boolean" }], needsArgs: true };
});
var Ru = {};
Q(Ru, { flagsForFuzzing: () => b7, rmdirCommand: () => y7 });
async function w7(e11, t10, n10, r10) {
  let s10 = "", i10 = "", a = e11.fs.resolvePath(e11.cwd, t10), l = await Iu(e11, a, t10, r10);
  if (s10 += l.stdout, i10 += l.stderr, l.exitCode !== 0)
    return { stdout: s10, stderr: i10, exitCode: l.exitCode };
  if (n10) {
    let c = a, u = t10;
    for (; ; ) {
      let f10 = Ou(c), p = Ou(u);
      if (f10 === c || f10 === "/" || f10 === "." || p === "." || p === "")
        break;
      let h = await Iu(e11, f10, p, r10);
      if (s10 += h.stdout, h.exitCode !== 0)
        break;
      c = f10, u = p;
    }
  }
  return { stdout: s10, stderr: i10, exitCode: 0 };
}
async function Iu(e11, t10, n10, r10) {
  try {
    if (!await e11.fs.exists(t10))
      return { stdout: "", stderr: `rmdir: failed to remove '${n10}': No such file or directory
`, exitCode: 1 };
    if (!(await e11.fs.stat(t10)).isDirectory)
      return { stdout: "", stderr: `rmdir: failed to remove '${n10}': Not a directory
`, exitCode: 1 };
    if ((await e11.fs.readdir(t10)).length > 0)
      return { stdout: "", stderr: `rmdir: failed to remove '${n10}': Directory not empty
`, exitCode: 1 };
    await e11.fs.rm(t10, { recursive: false, force: false });
    let a = "";
    return r10 && (a = `rmdir: removing directory, '${n10}'
`), { stdout: a, stderr: "", exitCode: 0 };
  } catch (s10) {
    let i10 = Me(s10);
    return { stdout: "", stderr: `rmdir: failed to remove '${n10}': ${i10}
`, exitCode: 1 };
  }
}
function Ou(e11) {
  let t10 = e11.replace(/\/+$/, ""), n10 = t10.lastIndexOf("/");
  return n10 === -1 ? "." : n10 === 0 ? "/" : t10.substring(0, n10);
}
var m7;
var g7;
var y7;
var b7;
var $u = I(() => {
  "use strict";
  Wt();
  qe();
  m7 = `Usage: rmdir [-pv] DIRECTORY...
Remove empty directories.

Options:
  -p, --parents   Remove DIRECTORY and its ancestors
  -v, --verbose   Output a diagnostic for every directory processed`, g7 = { parents: { short: "p", long: "parents", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" }, help: { long: "help", type: "boolean" } }, y7 = { name: "rmdir", async execute(e11, t10) {
    let n10 = be("rmdir", e11, g7);
    if (!n10.ok)
      return n10.error;
    if (n10.result.flags.help)
      return { stdout: `${m7}
`, stderr: "", exitCode: 0 };
    let r10 = n10.result.flags.parents, s10 = n10.result.flags.verbose, i10 = n10.result.positional;
    if (i10.length === 0)
      return { stdout: "", stderr: `rmdir: missing operand
`, exitCode: 1 };
    let o10 = "", a = "", l = 0;
    for (let c of i10) {
      let u = await w7(t10, c, r10, s10);
      o10 += u.stdout, a += u.stderr, u.exitCode !== 0 && (l = u.exitCode);
    }
    return { stdout: o10, stderr: a, exitCode: l };
  } };
  b7 = { name: "rmdir", flags: [{ flag: "-p", type: "boolean" }, { flag: "-v", type: "boolean" }], needsArgs: true };
});
var Tu = {};
Q(Tu, { flagsForFuzzing: () => A7, touchCommand: () => E7 });
function x7(e11) {
  let t10 = e11.replace(/\//g, "-"), n10 = new Date(t10);
  if (!Number.isNaN(n10.getTime()))
    return n10;
  let r10 = t10.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (r10) {
    let [, i10, o10, a] = r10;
    if (n10 = new Date(Number.parseInt(i10, 10), Number.parseInt(o10, 10) - 1, Number.parseInt(a, 10)), !Number.isNaN(n10.getTime()))
      return n10;
  }
  let s10 = t10.match(/^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})$/);
  if (s10) {
    let [, i10, o10, a, l, c, u] = s10;
    if (n10 = new Date(Number.parseInt(i10, 10), Number.parseInt(o10, 10) - 1, Number.parseInt(a, 10), Number.parseInt(l, 10), Number.parseInt(c, 10), Number.parseInt(u, 10)), !Number.isNaN(n10.getTime()))
      return n10;
  }
  return null;
}
var E7;
var A7;
var Pu = I(() => {
  "use strict";
  Wt();
  se();
  E7 = { name: "touch", async execute(e11, t10) {
    let n10 = [], r10 = null, s10 = false;
    for (let l = 0; l < e11.length; l++) {
      let c = e11[l];
      if (c === "--") {
        n10.push(...e11.slice(l + 1));
        break;
      } else if (c === "-d" || c === "--date") {
        if (l + 1 >= e11.length)
          return { stdout: "", stderr: `touch: option requires an argument -- 'd'
`, exitCode: 1 };
        r10 = e11[++l];
      } else if (c.startsWith("--date="))
        r10 = c.slice(7);
      else if (c === "-c" || c === "--no-create")
        s10 = true;
      else if (c === "-a" || c === "-m" || c === "-r" || c === "-t")
        (c === "-r" || c === "-t") && l++;
      else {
        if (c.startsWith("--"))
          return Y("touch", c);
        if (c.startsWith("-") && c.length > 1) {
          let u = false;
          for (let f10 of c.slice(1))
            if (f10 === "c")
              s10 = true;
            else if (!(f10 === "a" || f10 === "m"))
              if (f10 === "d") {
                if (l + 1 >= e11.length)
                  return { stdout: "", stderr: `touch: option requires an argument -- 'd'
`, exitCode: 1 };
                r10 = e11[++l], u = true;
                break;
              } else if (f10 === "r" || f10 === "t") {
                l++, u = true;
                break;
              } else
                return Y("touch", `-${f10}`);
          if (u)
            continue;
        } else
          n10.push(c);
      }
    }
    if (n10.length === 0)
      return { stdout: "", stderr: `touch: missing file operand
`, exitCode: 1 };
    let i10 = null;
    if (r10 !== null && (i10 = x7(r10), i10 === null))
      return { stdout: "", stderr: `touch: invalid date format '${r10}'
`, exitCode: 1 };
    let o10 = "", a = 0;
    for (let l of n10)
      try {
        let c = t10.fs.resolvePath(t10.cwd, l);
        if (!await t10.fs.exists(c)) {
          if (s10)
            continue;
          await t10.fs.writeFile(c, "");
        }
        let f10 = i10 ?? /* @__PURE__ */ new Date();
        await t10.fs.utimes(c, f10, f10);
      } catch (c) {
        o10 += `touch: cannot touch '${l}': ${Me(c)}
`, a = 1;
      }
    return { stdout: "", stderr: o10, exitCode: a };
  } }, A7 = { name: "touch", flags: [{ flag: "-c", type: "boolean" }, { flag: "-a", type: "boolean" }, { flag: "-m", type: "boolean" }, { flag: "-d", type: "value", valueHint: "string" }], needsArgs: true };
});
var Du = {};
Q(Du, { flagsForFuzzing: () => N7, rmCommand: () => C7 });
var S7;
var C7;
var N7;
var _u = I(() => {
  "use strict";
  Wt();
  qe();
  S7 = { recursive: { short: "r", long: "recursive", type: "boolean" }, recursiveUpper: { short: "R", type: "boolean" }, force: { short: "f", long: "force", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, C7 = { name: "rm", async execute(e11, t10) {
    let n10 = be("rm", e11, S7);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.recursive || n10.result.flags.recursiveUpper, s10 = n10.result.flags.force, i10 = n10.result.flags.verbose, o10 = n10.result.positional;
    if (o10.length === 0)
      return s10 ? { stdout: "", stderr: "", exitCode: 0 } : { stdout: "", stderr: `rm: missing operand
`, exitCode: 1 };
    let a = "", l = "", c = 0;
    for (let u of o10)
      try {
        let f10 = t10.fs.resolvePath(t10.cwd, u);
        if ((await t10.fs.stat(f10)).isDirectory && !r10) {
          l += `rm: cannot remove '${u}': Is a directory
`, c = 1;
          continue;
        }
        await t10.fs.rm(f10, { recursive: r10, force: s10 }), i10 && (a += `removed '${u}'
`);
      } catch (f10) {
        if (!s10) {
          let p = Me(f10);
          p.includes("ENOENT") || p.includes("no such file") ? l += `rm: cannot remove '${u}': No such file or directory
` : p.includes("ENOTEMPTY") || p.includes("not empty") ? l += `rm: cannot remove '${u}': Directory not empty
` : l += `rm: cannot remove '${u}': ${p}
`, c = 1;
        }
      }
    return { stdout: a, stderr: l, exitCode: c };
  } }, N7 = { name: "rm", flags: [{ flag: "-r", type: "boolean" }, { flag: "-R", type: "boolean" }, { flag: "-f", type: "boolean" }, { flag: "-v", type: "boolean" }], needsArgs: true };
});
var Lu = {};
Q(Lu, { cpCommand: () => I7, flagsForFuzzing: () => O7 });
var k7;
var v7;
var I7;
var O7;
var Fu = I(() => {
  "use strict";
  Wt();
  qe();
  se();
  k7 = { name: "cp", summary: "copy files and directories", usage: "cp [OPTION]... SOURCE... DEST", options: ["-r, -R, --recursive  copy directories recursively", "-n, --no-clobber     do not overwrite an existing file", "-p, --preserve       preserve file attributes", "-v, --verbose        explain what is being done", "    --help           display this help and exit"] }, v7 = { recursive: { short: "r", long: "recursive", type: "boolean" }, recursiveUpper: { short: "R", type: "boolean" }, noClobber: { short: "n", long: "no-clobber", type: "boolean" }, preserve: { short: "p", long: "preserve", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, I7 = { name: "cp", async execute(e11, t10) {
    if (U2(e11))
      return M(k7);
    let n10 = be("cp", e11, v7);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.recursive || n10.result.flags.recursiveUpper, s10 = n10.result.flags.noClobber, i10 = n10.result.flags.preserve, o10 = n10.result.flags.verbose, a = n10.result.positional;
    if (a.length < 2)
      return { stdout: "", stderr: `cp: missing destination file operand
`, exitCode: 1 };
    let l = a.pop() ?? "", c = a, u = t10.fs.resolvePath(t10.cwd, l), f10 = "", p = "", h = 0, m = false;
    try {
      m = (await t10.fs.stat(u)).isDirectory;
    } catch {
    }
    if (c.length > 1 && !m)
      return { stdout: "", stderr: `cp: target '${l}' is not a directory
`, exitCode: 1 };
    for (let d of c)
      try {
        let g = t10.fs.resolvePath(t10.cwd, d), y = await t10.fs.stat(g), w = u;
        if (m) {
          let b = d.split("/").pop() || d;
          w = u === "/" ? `/${b}` : `${u}/${b}`;
        }
        if (y.isDirectory && !r10) {
          p += `cp: -r not specified; omitting directory '${d}'
`, h = 1;
          continue;
        }
        if (s10)
          try {
            await t10.fs.stat(w);
            continue;
          } catch {
          }
        await t10.fs.cp(g, w, { recursive: r10 }), o10 && (f10 += `'${d}' -> '${w}'
`);
      } catch (g) {
        let y = Me(g);
        y.includes("ENOENT") || y.includes("no such file") ? p += `cp: cannot stat '${d}': No such file or directory
` : p += `cp: cannot copy '${d}': ${y}
`, h = 1;
      }
    return { stdout: f10, stderr: p, exitCode: h };
  } }, O7 = { name: "cp", flags: [{ flag: "-r", type: "boolean" }, { flag: "-R", type: "boolean" }, { flag: "-n", type: "boolean" }, { flag: "-p", type: "boolean" }, { flag: "-v", type: "boolean" }], needsArgs: true, minArgs: 2 };
});
var Mu = {};
Q(Mu, { flagsForFuzzing: () => P7, mvCommand: () => T7 });
var R7;
var $7;
var T7;
var P7;
var Uu = I(() => {
  "use strict";
  Wt();
  qe();
  se();
  R7 = { name: "mv", summary: "move (rename) files", usage: "mv [OPTION]... SOURCE... DEST", options: ["-f, --force       do not prompt before overwriting", "-n, --no-clobber  do not overwrite an existing file", "-v, --verbose     explain what is being done", "    --help        display this help and exit"] }, $7 = { force: { short: "f", long: "force", type: "boolean" }, noClobber: { short: "n", long: "no-clobber", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, T7 = { name: "mv", async execute(e11, t10) {
    if (U2(e11))
      return M(R7);
    let n10 = be("mv", e11, $7);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.force, s10 = n10.result.flags.noClobber, i10 = n10.result.flags.verbose, o10 = n10.result.positional;
    if (s10 && (r10 = false), o10.length < 2)
      return { stdout: "", stderr: `mv: missing destination file operand
`, exitCode: 1 };
    let a = o10.pop() ?? "", l = o10, c = t10.fs.resolvePath(t10.cwd, a), u = "", f10 = "", p = 0, h = false;
    try {
      h = (await t10.fs.stat(c)).isDirectory;
    } catch {
    }
    if (l.length > 1 && !h)
      return { stdout: "", stderr: `mv: target '${a}' is not a directory
`, exitCode: 1 };
    for (let m of l)
      try {
        let d = t10.fs.resolvePath(t10.cwd, m), g = c;
        if (h) {
          let y = m.split("/").pop() || m;
          g = c === "/" ? `/${y}` : `${c}/${y}`;
        }
        if (s10)
          try {
            await t10.fs.stat(g);
            continue;
          } catch {
          }
        if (await t10.fs.mv(d, g), i10) {
          let y = h ? `${a}/${m.split("/").pop() || m}` : a;
          u += `renamed '${m}' -> '${y}'
`;
        }
      } catch (d) {
        let g = Me(d);
        g.includes("ENOENT") || g.includes("no such file") ? f10 += `mv: cannot stat '${m}': No such file or directory
` : f10 += `mv: cannot move '${m}': ${g}
`, p = 1;
      }
    return { stdout: u, stderr: f10, exitCode: p };
  } }, P7 = { name: "mv", flags: [{ flag: "-f", type: "boolean" }, { flag: "-n", type: "boolean" }, { flag: "-v", type: "boolean" }], needsArgs: true, minArgs: 2 };
});
var Wu = {};
Q(Wu, { flagsForFuzzing: () => L7, lnCommand: () => _7 });
var D7;
var _7;
var L7;
var Bu = I(() => {
  "use strict";
  se();
  D7 = { name: "ln", summary: "make links between files", usage: "ln [OPTIONS] TARGET LINK_NAME", options: ["-s      create a symbolic link instead of a hard link", "-f      remove existing destination files", "-n      treat LINK_NAME as a normal file if it is a symbolic link to a directory", "-v      print name of each linked file", "    --help display this help and exit"] }, _7 = { name: "ln", async execute(e11, t10) {
    if (U2(e11))
      return M(D7);
    let n10 = false, r10 = false, s10 = false, i10 = 0;
    for (; i10 < e11.length && e11[i10].startsWith("-"); ) {
      let f10 = e11[i10];
      if (f10 === "-s" || f10 === "--symbolic")
        n10 = true, i10++;
      else if (f10 === "-f" || f10 === "--force")
        r10 = true, i10++;
      else if (f10 === "-v" || f10 === "--verbose")
        s10 = true, i10++;
      else if (f10 === "-n" || f10 === "--no-dereference")
        i10++;
      else if (/^-[sfvn]+$/.test(f10))
        f10.includes("s") && (n10 = true), f10.includes("f") && (r10 = true), f10.includes("v") && (s10 = true), i10++;
      else if (f10 === "--") {
        i10++;
        break;
      } else
        return { stdout: "", stderr: `ln: invalid option -- '${f10.slice(1)}'
`, exitCode: 1 };
    }
    let o10 = e11.slice(i10);
    if (o10.length < 2)
      return { stdout: "", stderr: `ln: missing file operand
`, exitCode: 1 };
    let a = o10[0], l = o10[1], c = t10.fs.resolvePath(t10.cwd, l);
    if (await t10.fs.exists(c))
      if (r10)
        try {
          await t10.fs.rm(c, { force: true });
        } catch {
          return { stdout: "", stderr: `ln: cannot remove '${l}': Permission denied
`, exitCode: 1 };
        }
      else
        return { stdout: "", stderr: `ln: failed to create ${n10 ? "symbolic " : ""}link '${l}': File exists
`, exitCode: 1 };
    try {
      if (n10)
        await t10.fs.symlink(a, c);
      else {
        let f10 = t10.fs.resolvePath(t10.cwd, a);
        if (!await t10.fs.exists(f10))
          return { stdout: "", stderr: `ln: failed to access '${a}': No such file or directory
`, exitCode: 1 };
        await t10.fs.link(f10, c);
      }
    } catch (f10) {
      let p = f10;
      return p.message.includes("EPERM") ? { stdout: "", stderr: `ln: '${a}': hard link not allowed for directory
`, exitCode: 1 } : { stdout: "", stderr: `ln: ${p.message}
`, exitCode: 1 };
    }
    let u = "";
    return s10 && (u = `'${l}' -> '${a}'
`), { stdout: u, stderr: "", exitCode: 0 };
  } }, L7 = { name: "ln", flags: [{ flag: "-s", type: "boolean" }, { flag: "-f", type: "boolean" }, { flag: "-n", type: "boolean" }, { flag: "-v", type: "boolean" }], needsArgs: true, minArgs: 2 };
});
var Hu = {};
Q(Hu, { chmodCommand: () => M7, flagsForFuzzing: () => U7 });
async function zu(e11, t10, n10, r10, s10) {
  let i10 = "", o10 = await e11.fs.readdir(t10);
  for (let a of o10) {
    let l = t10 === "/" ? `/${a}` : `${t10}/${a}`, c;
    if (n10 !== void 0)
      c = n10;
    else if (r10 !== void 0) {
      let f10 = await e11.fs.stat(l);
      c = Po(r10, f10.mode);
    } else
      c = 420;
    await e11.fs.chmod(l, c), s10 && (i10 += `mode of '${l}' changed to ${c.toString(8).padStart(4, "0")}
`), (await e11.fs.stat(l)).isDirectory && (i10 += await zu(e11, l, n10, r10, s10));
  }
  return i10;
}
function Po(e11, t10 = 420) {
  if (/^[0-7]+$/.test(e11))
    return parseInt(e11, 8);
  let n10 = t10 & 4095, r10 = e11.split(",");
  for (let s10 of r10) {
    let i10 = s10.match(/^([ugoa]*)([+\-=])([rwxXst]*)$/);
    if (!i10)
      throw new Error(`Invalid mode: ${e11}`);
    let o10 = i10[1] || "a", a = i10[2], l = i10[3];
    (o10 === "a" || o10 === "") && (o10 = "ugo");
    let c = 0;
    l.includes("r") && (c |= 4), l.includes("w") && (c |= 2), (l.includes("x") || l.includes("X")) && (c |= 1);
    let u = 0;
    l.includes("s") && (o10.includes("u") && (u |= 2048), o10.includes("g") && (u |= 1024)), l.includes("t") && (u |= 512);
    for (let f10 of o10) {
      let p = 0;
      f10 === "u" ? p = 6 : f10 === "g" ? p = 3 : f10 === "o" && (p = 0);
      let h = c << p;
      a === "+" ? n10 |= h : a === "-" ? n10 &= ~h : a === "=" && (n10 &= ~(7 << p), n10 |= h);
    }
    a === "+" ? n10 |= u : a === "-" ? n10 &= ~u : a === "=" && (l.includes("s") && (o10.includes("u") && (n10 &= -2049, n10 |= u & 2048), o10.includes("g") && (n10 &= -1025, n10 |= u & 1024)), l.includes("t") && (n10 &= -513, n10 |= u & 512));
  }
  return n10;
}
var F7;
var M7;
var U7;
var ju = I(() => {
  "use strict";
  se();
  F7 = { name: "chmod", summary: "change file mode bits", usage: "chmod [OPTIONS] MODE FILE...", options: ["-R      change files recursively", "-v      output a diagnostic for every file processed", "    --help display this help and exit"] }, M7 = { name: "chmod", async execute(e11, t10) {
    if (U2(e11))
      return M(F7);
    if (e11.length < 2)
      return { stdout: "", stderr: `chmod: missing operand
`, exitCode: 1 };
    let n10 = false, r10 = false, s10 = 0;
    for (; s10 < e11.length && e11[s10].startsWith("-"); ) {
      let p = e11[s10];
      if (p === "-R" || p === "--recursive")
        n10 = true, s10++;
      else if (p === "-v" || p === "--verbose")
        r10 = true, s10++;
      else if (p === "--") {
        s10++;
        break;
      } else {
        if (/^[+-]?[rwxugo]+/.test(p) || /^\d+$/.test(p))
          break;
        if (/^-[Rv]+$/.test(p)) {
          p.includes("R") && (n10 = true), p.includes("v") && (r10 = true), s10++;
          continue;
        }
        return { stdout: "", stderr: `chmod: invalid option -- '${p.slice(1)}'
`, exitCode: 1 };
      }
    }
    if (e11.length - s10 < 2)
      return { stdout: "", stderr: `chmod: missing operand
`, exitCode: 1 };
    let i10 = e11[s10], o10 = e11.slice(s10 + 1), a = /^[0-7]+$/.test(i10), l;
    if (a)
      l = parseInt(i10, 8);
    else
      try {
        Po(i10, 420);
      } catch {
        return { stdout: "", stderr: `chmod: invalid mode: '${i10}'
`, exitCode: 1 };
      }
    let c = "", u = "", f10 = false;
    for (let p of o10) {
      let h = t10.fs.resolvePath(t10.cwd, p);
      try {
        let m;
        if (a && l !== void 0)
          m = l;
        else {
          let d = await t10.fs.stat(h);
          m = Po(i10, d.mode);
        }
        if (await t10.fs.chmod(h, m), r10 && (c += `mode of '${p}' changed to ${m.toString(8).padStart(4, "0")}
`), n10 && (await t10.fs.stat(h)).isDirectory) {
          let g = await zu(t10, h, a ? l : void 0, a ? void 0 : i10, r10);
          c += g;
        }
      } catch {
        u += `chmod: cannot access '${p}': No such file or directory
`, f10 = true;
      }
    }
    return { stdout: c, stderr: u, exitCode: f10 ? 1 : 0 };
  } };
  U7 = { name: "chmod", flags: [{ flag: "-R", type: "boolean" }, { flag: "-v", type: "boolean" }], needsArgs: true, minArgs: 2 };
});
var Gu = {};
Q(Gu, { flagsForFuzzing: () => B7, pwdCommand: () => W7 });
var W7;
var B7;
var Vu = I(() => {
  "use strict";
  W7 = { name: "pwd", async execute(e11, t10) {
    let n10 = false;
    for (let s10 of e11)
      if (s10 === "-P")
        n10 = true;
      else if (s10 === "-L")
        n10 = false;
      else {
        if (s10 === "--")
          break;
        s10.startsWith("-");
      }
    let r10 = t10.cwd;
    if (n10)
      try {
        r10 = await t10.fs.realpath(t10.cwd);
      } catch {
      }
    return { stdout: `${r10}
`, stderr: "", exitCode: 0 };
  } }, B7 = { name: "pwd", flags: [{ flag: "-P", type: "boolean" }, { flag: "-L", type: "boolean" }] };
});
var qu = {};
Q(qu, { flagsForFuzzing: () => j7, readlinkCommand: () => H7 });
var z7;
var H7;
var j7;
var Zu = I(() => {
  "use strict";
  se();
  z7 = { name: "readlink", summary: "print resolved symbolic links or canonical file names", usage: "readlink [OPTIONS] FILE...", options: ["-f      canonicalize by following every symlink in every component of the given name recursively", "    --help display this help and exit"] }, H7 = { name: "readlink", async execute(e11, t10) {
    if (U2(e11))
      return M(z7);
    let n10 = false, r10 = 0;
    for (; r10 < e11.length && e11[r10].startsWith("-"); ) {
      let a = e11[r10];
      if (a === "-f" || a === "--canonicalize")
        n10 = true, r10++;
      else if (a === "--") {
        r10++;
        break;
      } else
        return { stdout: "", stderr: `readlink: invalid option -- '${a.slice(1)}'
`, exitCode: 1 };
    }
    let s10 = e11.slice(r10);
    if (s10.length === 0)
      return { stdout: "", stderr: `readlink: missing operand
`, exitCode: 1 };
    let i10 = "", o10 = false;
    for (let a of s10) {
      let l = t10.fs.resolvePath(t10.cwd, a);
      try {
        if (n10) {
          let c = l, u = /* @__PURE__ */ new Set();
          for (; !u.has(c); ) {
            u.add(c);
            try {
              let f10 = await t10.fs.readlink(c);
              if (f10.startsWith("/"))
                c = f10;
              else {
                let p = c.substring(0, c.lastIndexOf("/")) || "/";
                c = t10.fs.resolvePath(p, f10);
              }
            } catch {
              break;
            }
          }
          i10 += `${c}
`;
        } else {
          let c = await t10.fs.readlink(l);
          i10 += `${c}
`;
        }
      } catch {
        n10 ? i10 += `${l}
` : o10 = true;
      }
    }
    return { stdout: i10, stderr: "", exitCode: o10 ? 1 : 0 };
  } }, j7 = { name: "readlink", flags: [{ flag: "-f", type: "boolean" }, { flag: "-e", type: "boolean" }], needsArgs: true };
});
function Hs(e11, t10) {
  let n10 = 10, r10 = null, s10 = false, i10 = false, o10 = false, a = [];
  for (let l = 0; l < e11.length; l++) {
    let c = e11[l];
    if (c === "-n" && l + 1 < e11.length) {
      let u = e11[++l];
      t10 === "tail" && u.startsWith("+") ? (o10 = true, n10 = parseInt(u.slice(1), 10)) : n10 = parseInt(u, 10);
    } else if (t10 === "tail" && c.startsWith("-n+"))
      o10 = true, n10 = parseInt(c.slice(3), 10);
    else if (c.startsWith("-n"))
      n10 = parseInt(c.slice(2), 10);
    else if (c === "-c" && l + 1 < e11.length)
      r10 = parseInt(e11[++l], 10);
    else if (c.startsWith("-c"))
      r10 = parseInt(c.slice(2), 10);
    else if (c.startsWith("--bytes="))
      r10 = parseInt(c.slice(8), 10);
    else if (c.startsWith("--lines="))
      n10 = parseInt(c.slice(8), 10);
    else if (c === "-q" || c === "--quiet" || c === "--silent")
      s10 = true;
    else if (c === "-v" || c === "--verbose")
      i10 = true;
    else if (c.match(/^-\d+$/))
      n10 = parseInt(c.slice(1), 10);
    else {
      if (c.startsWith("--"))
        return { ok: false, error: Y(t10, c) };
      if (c.startsWith("-") && c !== "-")
        return { ok: false, error: Y(t10, c) };
      a.push(c);
    }
  }
  return r10 !== null && (Number.isNaN(r10) || r10 < 0) ? { ok: false, error: { stdout: "", stderr: `${t10}: invalid number of bytes
`, exitCode: 1 } } : Number.isNaN(n10) || n10 < 0 ? { ok: false, error: { stdout: "", stderr: `${t10}: invalid number of lines
`, exitCode: 1 } } : { ok: true, options: { lines: n10, bytes: r10, quiet: s10, verbose: i10, files: a, fromLine: o10 } };
}
async function js(e11, t10, n10, r10) {
  let { quiet: s10, verbose: i10, files: o10 } = t10;
  if (o10.length === 0)
    return { stdout: r10(e11.stdin), stderr: "", exitCode: 0 };
  let a = "", l = "", c = 0, u = i10 || !s10 && o10.length > 1, f10 = 0;
  for (let p = 0; p < o10.length; p++) {
    let h = o10[p];
    try {
      let m = e11.fs.resolvePath(e11.cwd, h), d = await e11.fs.readFile(m);
      u && (f10 > 0 && (a += `
`), a += `==> ${h} <==
`), a += r10(d), f10++;
    } catch {
      l += `${n10}: ${h}: No such file or directory
`, c = 1;
    }
  }
  return { stdout: a, stderr: l, exitCode: c };
}
function Qu(e11, t10, n10) {
  if (n10 !== null)
    return e11.slice(0, n10);
  if (t10 === 0)
    return "";
  let r10 = 0, s10 = 0, i10 = e11.length;
  for (; r10 < i10 && s10 < t10; ) {
    let o10 = e11.indexOf(`
`, r10);
    if (o10 === -1)
      return `${e11}
`;
    s10++, r10 = o10 + 1;
  }
  return r10 > 0 ? e11.slice(0, r10) : "";
}
function Ku(e11, t10, n10, r10) {
  if (n10 !== null)
    return e11.slice(-n10);
  let s10 = e11.length;
  if (s10 === 0)
    return "";
  if (r10) {
    let l = 0, c = 1;
    for (; l < s10 && c < t10; ) {
      let f10 = e11.indexOf(`
`, l);
      if (f10 === -1)
        break;
      c++, l = f10 + 1;
    }
    let u = e11.slice(l);
    return u.endsWith(`
`) ? u : `${u}
`;
  }
  if (t10 === 0)
    return "";
  let i10 = s10 - 1;
  e11[i10] === `
` && i10--;
  let o10 = 0;
  for (; i10 >= 0 && o10 < t10; ) {
    if (e11[i10] === `
` && (o10++, o10 === t10)) {
      i10++;
      break;
    }
    i10--;
  }
  i10 < 0 && (i10 = 0);
  let a = e11.slice(i10);
  return e11[s10 - 1] === `
` ? a : `${a}
`;
}
var Do = I(() => {
  "use strict";
  se();
});
var Xu = {};
Q(Xu, { flagsForFuzzing: () => q7, headCommand: () => V7 });
var G7;
var V7;
var q7;
var Yu = I(() => {
  "use strict";
  se();
  Do();
  G7 = { name: "head", summary: "output the first part of files", usage: "head [OPTION]... [FILE]...", options: ["-c, --bytes=NUM    print the first NUM bytes", "-n, --lines=NUM    print the first NUM lines (default 10)", "-q, --quiet        never print headers giving file names", "-v, --verbose      always print headers giving file names", "    --help         display this help and exit"] }, V7 = { name: "head", async execute(e11, t10) {
    if (U2(e11))
      return M(G7);
    let n10 = Hs(e11, "head");
    if (!n10.ok)
      return n10.error;
    let { lines: r10, bytes: s10 } = n10.options;
    return js(t10, n10.options, "head", (i10) => Qu(i10, r10, s10));
  } }, q7 = { name: "head", flags: [{ flag: "-n", type: "value", valueHint: "number" }, { flag: "-c", type: "value", valueHint: "number" }, { flag: "-q", type: "boolean" }, { flag: "-v", type: "boolean" }], stdinType: "text", needsFiles: true };
});
var Ju = {};
Q(Ju, { flagsForFuzzing: () => K7, tailCommand: () => Q7 });
var Z7;
var Q7;
var K7;
var ef = I(() => {
  "use strict";
  Do();
  se();
  Z7 = { name: "tail", summary: "output the last part of files", usage: "tail [OPTION]... [FILE]...", options: ["-c, --bytes=NUM    print the last NUM bytes", "-n, --lines=NUM    print the last NUM lines (default 10)", "-n +NUM            print starting from line NUM", "-q, --quiet        never print headers giving file names", "-v, --verbose      always print headers giving file names", "    --help         display this help and exit"] }, Q7 = { name: "tail", async execute(e11, t10) {
    if (U2(e11))
      return M(Z7);
    let n10 = Hs(e11, "tail");
    if (!n10.ok)
      return n10.error;
    let { lines: r10, bytes: s10, fromLine: i10 } = n10.options;
    return js(t10, n10.options, "tail", (o10) => Ku(o10, r10, s10, i10 ?? false));
  } }, K7 = { name: "tail", flags: [{ flag: "-n", type: "value", valueHint: "number" }, { flag: "-c", type: "value", valueHint: "number" }, { flag: "-q", type: "boolean" }, { flag: "-v", type: "boolean" }], stdinType: "text", needsFiles: true };
});
var nf = {};
Q(nf, { flagsForFuzzing: () => e4, wcCommand: () => J7 });
function tf(e11) {
  let t10 = e11.length, n10 = 0, r10 = 0, s10 = false;
  for (let i10 = 0; i10 < t10; i10++) {
    let o10 = e11[i10];
    o10 === `
` ? (n10++, s10 && (r10++, s10 = false)) : o10 === " " || o10 === "	" || o10 === "\r" ? s10 && (r10++, s10 = false) : s10 = true;
  }
  return s10 && r10++, { lines: n10, words: r10, chars: t10 };
}
function _o(e11, t10, n10, r10, s10, i10) {
  let o10 = [];
  t10 && o10.push(String(e11.lines).padStart(i10)), n10 && o10.push(String(e11.words).padStart(i10)), r10 && o10.push(String(e11.chars).padStart(i10));
  let a = o10.join(" ");
  return s10 && (a += ` ${s10}`), a;
}
var X7;
var Y7;
var J7;
var e4;
var rf = I(() => {
  "use strict";
  qe();
  Hn();
  se();
  X7 = { name: "wc", summary: "print newline, word, and byte counts for each file", usage: "wc [OPTION]... [FILE]...", options: ["-c, --bytes      print the byte counts", "-m, --chars      print the character counts", "-l, --lines      print the newline counts", "-w, --words      print the word counts", "    --help       display this help and exit"] }, Y7 = { lines: { short: "l", long: "lines", type: "boolean" }, words: { short: "w", long: "words", type: "boolean" }, bytes: { short: "c", long: "bytes", type: "boolean" }, chars: { short: "m", long: "chars", type: "boolean" } }, J7 = { name: "wc", async execute(e11, t10) {
    if (U2(e11))
      return M(X7);
    let n10 = be("wc", e11, Y7);
    if (!n10.ok)
      return n10.error;
    let { lines: r10, words: s10 } = n10.result.flags, i10 = n10.result.flags.bytes || n10.result.flags.chars, o10 = n10.result.positional;
    !r10 && !s10 && !i10 && (r10 = s10 = i10 = true);
    let a = await zn(t10, o10, { cmdName: "wc", stopOnError: false });
    if (o10.length === 0) {
      let y = tf(a.files[0].content);
      return { stdout: `${_o(y, r10, s10, i10, "", 0)}
`, stderr: "", exitCode: 0 };
    }
    let l = [], c = 0, u = 0, f10 = 0;
    for (let { filename: y, content: w } of a.files) {
      let b = tf(w);
      c += b.lines, u += b.words, f10 += b.chars, l.push({ filename: y, stats: b });
    }
    let p = o10.length > 1 ? c : Math.max(...l.map((y) => y.stats.lines)), h = o10.length > 1 ? u : Math.max(...l.map((y) => y.stats.words)), m = o10.length > 1 ? f10 : Math.max(...l.map((y) => y.stats.chars)), d = o10.length > 1 ? 3 : 0;
    r10 && (d = Math.max(d, String(p).length)), s10 && (d = Math.max(d, String(h).length)), i10 && (d = Math.max(d, String(m).length));
    let g = "";
    for (let { filename: y, stats: w } of l)
      g += `${_o(w, r10, s10, i10, y, d)}
`;
    return o10.length > 1 && (g += `${_o({ lines: c, words: u, chars: f10 }, r10, s10, i10, "total", d)}
`), { stdout: g, stderr: a.stderr, exitCode: a.exitCode };
  } };
  e4 = { name: "wc", flags: [{ flag: "-l", type: "boolean" }, { flag: "-w", type: "boolean" }, { flag: "-c", type: "boolean" }, { flag: "-m", type: "boolean" }], stdinType: "text", needsFiles: true };
});
var of = {};
Q(of, { flagsForFuzzing: () => s4, statCommand: () => r4 });
function sf(e11, t10) {
  let n10 = t10 ? "d" : "-", r10 = [e11 & 256 ? "r" : "-", e11 & 128 ? "w" : "-", e11 & 64 ? "x" : "-", e11 & 32 ? "r" : "-", e11 & 16 ? "w" : "-", e11 & 8 ? "x" : "-", e11 & 4 ? "r" : "-", e11 & 2 ? "w" : "-", e11 & 1 ? "x" : "-"];
  return n10 + r10.join("");
}
var t4;
var n4;
var r4;
var s4;
var af = I(() => {
  "use strict";
  qe();
  se();
  t4 = { name: "stat", summary: "display file or file system status", usage: "stat [OPTION]... FILE...", options: ["-c FORMAT   use the specified FORMAT instead of the default", "    --help  display this help and exit"] }, n4 = { format: { short: "c", type: "string" } }, r4 = { name: "stat", async execute(e11, t10) {
    if (U2(e11))
      return M(t4);
    let n10 = be("stat", e11, n4);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.format ?? null, s10 = n10.result.positional;
    if (s10.length === 0)
      return { stdout: "", stderr: `stat: missing operand
`, exitCode: 1 };
    let i10 = "", o10 = "", a = false;
    for (let l of s10) {
      let c = t10.fs.resolvePath(t10.cwd, l);
      try {
        let u = await t10.fs.stat(c);
        if (r10) {
          let f10 = r10, p = u.mode.toString(8), h = sf(u.mode, u.isDirectory);
          f10 = f10.replace(/%n/g, l), f10 = f10.replace(/%N/g, `'${l}'`), f10 = f10.replace(/%s/g, String(u.size)), f10 = f10.replace(/%F/g, u.isDirectory ? "directory" : "regular file"), f10 = f10.replace(/%a/g, p), f10 = f10.replace(/%A/g, h), f10 = f10.replace(/%u/g, "1000"), f10 = f10.replace(/%U/g, "user"), f10 = f10.replace(/%g/g, "1000"), f10 = f10.replace(/%G/g, "group"), i10 += `${f10}
`;
        } else {
          let f10 = u.mode.toString(8).padStart(4, "0"), p = sf(u.mode, u.isDirectory);
          i10 += `  File: ${l}
`, i10 += `  Size: ${u.size}		Blocks: ${Math.ceil(u.size / 512)}
`, i10 += `Access: (${f10}/${p})
`, i10 += `Modify: ${u.mtime.toISOString()}
`;
        }
      } catch {
        o10 += `stat: cannot stat '${l}': No such file or directory
`, a = true;
      }
    }
    return { stdout: i10, stderr: o10, exitCode: a ? 1 : 0 };
  } };
  s4 = { name: "stat", flags: [{ flag: "-c", type: "value", valueHint: "format" }, { flag: "-L", type: "boolean" }], needsArgs: true };
});
var K;
var D;
var C;
var Gt;
var he;
var Ne;
var vf;
var vn;
var Gs;
var Lo;
var hr;
var dr;
var De;
var Fo;
var Xt;
var Mo;
var Uo;
var cn;
var Wo;
var Bo;
var je;
var we;
var zo;
var Vs;
var Qr;
var _;
var Ho;
var pr;
var jo;
var Go;
var Ce;
var lf;
var cf;
var uf;
var ff;
var pf;
var hf;
var df;
var mf;
var gf;
var yf;
var wf;
var bf;
var xf;
var Ef;
var Af;
var Sf;
var Cf;
var Nf;
var kf;
var ln;
var Kr;
var Vo;
var qo;
var Zo;
var Qo;
var Ko;
var In;
var If = I(() => {
  K = class e11 {
    static FOLD_CASE = 1;
    static LITERAL = 2;
    static CLASS_NL = 4;
    static DOT_NL = 8;
    static ONE_LINE = 16;
    static NON_GREEDY = 32;
    static PERL_X = 64;
    static UNICODE_GROUPS = 128;
    static WAS_DOLLAR = 256;
    static MATCH_NL = e11.CLASS_NL | e11.DOT_NL;
    static PERL = e11.CLASS_NL | e11.ONE_LINE | e11.PERL_X | e11.UNICODE_GROUPS;
    static POSIX = 0;
    static UNANCHORED = 0;
    static ANCHOR_START = 1;
    static ANCHOR_BOTH = 2;
  }, D = class {
    static CODES = /* @__PURE__ */ new Map([["\x07", 7], ["\b", 8], ["	", 9], [`
`, 10], ["\v", 11], ["\f", 12], ["\r", 13], [" ", 32], ['"', 34], ["$", 36], ["&", 38], ["(", 40], [")", 41], ["*", 42], ["+", 43], ["-", 45], [".", 46], ["0", 48], ["1", 49], ["2", 50], ["3", 51], ["4", 52], ["5", 53], ["6", 54], ["7", 55], ["8", 56], ["9", 57], [":", 58], ["<", 60], [">", 62], ["?", 63], ["A", 65], ["B", 66], ["C", 67], ["F", 70], ["P", 80], ["Q", 81], ["U", 85], ["Z", 90], ["[", 91], ["\\", 92], ["]", 93], ["^", 94], ["_", 95], ["a", 97], ["b", 98], ["f", 102], ["i", 105], ["m", 109], ["n", 110], ["r", 114], ["s", 115], ["t", 116], ["v", 118], ["x", 120], ["z", 122], ["{", 123], ["|", 124], ["}", 125]]);
    static toUpperCase(t10) {
      let n10 = String.fromCodePoint(t10).toUpperCase();
      if (n10.length > 1)
        return t10;
      let r10 = String.fromCodePoint(n10.codePointAt(0)).toLowerCase();
      return r10.length > 1 || r10.codePointAt(0) !== t10 ? t10 : n10.codePointAt(0);
    }
    static toLowerCase(t10) {
      let n10 = String.fromCodePoint(t10).toLowerCase();
      if (n10.length > 1)
        return t10;
      let r10 = String.fromCodePoint(n10.codePointAt(0)).toUpperCase();
      return r10.length > 1 || r10.codePointAt(0) !== t10 ? t10 : n10.codePointAt(0);
    }
  }, C = class {
    SIZE = 3;
    constructor(t10) {
      this.data = t10;
    }
    getLo(t10) {
      return this.data[t10 * this.SIZE];
    }
    getHi(t10) {
      return this.data[t10 * this.SIZE + 1];
    }
    getStride(t10) {
      return this.data[t10 * this.SIZE + 2];
    }
    get(t10) {
      let n10 = t10 * this.SIZE;
      return [this.data[n10], this.data[n10 + 1], this.data[n10 + 2]];
    }
    get length() {
      return this.data.length / this.SIZE;
    }
  }, Gt = class e11 {
    static CASE_ORBIT = /* @__PURE__ */ new Map([[75, 107], [107, 8490], [8490, 75], [83, 115], [115, 383], [383, 83], [181, 924], [924, 956], [956, 181], [197, 229], [229, 8491], [8491, 197], [452, 453], [453, 454], [454, 452], [455, 456], [456, 457], [457, 455], [458, 459], [459, 460], [460, 458], [497, 498], [498, 499], [499, 497], [837, 921], [921, 953], [953, 8126], [8126, 837], [914, 946], [946, 976], [976, 914], [917, 949], [949, 1013], [1013, 917], [920, 952], [952, 977], [977, 1012], [1012, 920], [922, 954], [954, 1008], [1008, 922], [928, 960], [960, 982], [982, 928], [929, 961], [961, 1009], [1009, 929], [931, 962], [962, 963], [963, 931], [934, 966], [966, 981], [981, 934], [937, 969], [969, 8486], [8486, 937], [1042, 1074], [1074, 7296], [7296, 1042], [1044, 1076], [1076, 7297], [7297, 1044], [1054, 1086], [1086, 7298], [7298, 1054], [1057, 1089], [1089, 7299], [7299, 1057], [1058, 1090], [1090, 7300], [7300, 7301], [7301, 1058], [1066, 1098], [1098, 7302], [7302, 1066], [1122, 1123], [1123, 7303], [7303, 1122], [7304, 42570], [42570, 42571], [42571, 7304], [7776, 7777], [7777, 7835], [7835, 7776], [223, 7838], [7838, 223], [8064, 8072], [8072, 8064], [8065, 8073], [8073, 8065], [8066, 8074], [8074, 8066], [8067, 8075], [8075, 8067], [8068, 8076], [8076, 8068], [8069, 8077], [8077, 8069], [8070, 8078], [8078, 8070], [8071, 8079], [8079, 8071], [8080, 8088], [8088, 8080], [8081, 8089], [8089, 8081], [8082, 8090], [8090, 8082], [8083, 8091], [8091, 8083], [8084, 8092], [8092, 8084], [8085, 8093], [8093, 8085], [8086, 8094], [8094, 8086], [8087, 8095], [8095, 8087], [8096, 8104], [8104, 8096], [8097, 8105], [8105, 8097], [8098, 8106], [8106, 8098], [8099, 8107], [8107, 8099], [8100, 8108], [8108, 8100], [8101, 8109], [8109, 8101], [8102, 8110], [8110, 8102], [8103, 8111], [8111, 8103], [8115, 8124], [8124, 8115], [8131, 8140], [8140, 8131], [912, 8147], [8147, 912], [944, 8163], [8163, 944], [8179, 8188], [8188, 8179], [64261, 64262], [64262, 64261], [66560, 66600], [66600, 66560], [66561, 66601], [66601, 66561], [66562, 66602], [66602, 66562], [66563, 66603], [66603, 66563], [66564, 66604], [66604, 66564], [66565, 66605], [66605, 66565], [66566, 66606], [66606, 66566], [66567, 66607], [66607, 66567], [66568, 66608], [66608, 66568], [66569, 66609], [66609, 66569], [66570, 66610], [66610, 66570], [66571, 66611], [66611, 66571], [66572, 66612], [66612, 66572], [66573, 66613], [66613, 66573], [66574, 66614], [66614, 66574], [66575, 66615], [66615, 66575], [66576, 66616], [66616, 66576], [66577, 66617], [66617, 66577], [66578, 66618], [66618, 66578], [66579, 66619], [66619, 66579], [66580, 66620], [66620, 66580], [66581, 66621], [66621, 66581], [66582, 66622], [66622, 66582], [66583, 66623], [66623, 66583], [66584, 66624], [66624, 66584], [66585, 66625], [66625, 66585], [66586, 66626], [66626, 66586], [66587, 66627], [66627, 66587], [66588, 66628], [66628, 66588], [66589, 66629], [66629, 66589], [66590, 66630], [66630, 66590], [66591, 66631], [66631, 66591], [66592, 66632], [66632, 66592], [66593, 66633], [66633, 66593], [66594, 66634], [66634, 66594], [66595, 66635], [66635, 66595], [66596, 66636], [66636, 66596], [66597, 66637], [66637, 66597], [66598, 66638], [66638, 66598], [66599, 66639], [66639, 66599], [66736, 66776], [66776, 66736], [66737, 66777], [66777, 66737], [66738, 66778], [66778, 66738], [66739, 66779], [66779, 66739], [66740, 66780], [66780, 66740], [66741, 66781], [66781, 66741], [66742, 66782], [66782, 66742], [66743, 66783], [66783, 66743], [66744, 66784], [66784, 66744], [66745, 66785], [66785, 66745], [66746, 66786], [66786, 66746], [66747, 66787], [66787, 66747], [66748, 66788], [66788, 66748], [66749, 66789], [66789, 66749], [66750, 66790], [66790, 66750], [66751, 66791], [66791, 66751], [66752, 66792], [66792, 66752], [66753, 66793], [66793, 66753], [66754, 66794], [66794, 66754], [66755, 66795], [66795, 66755], [66756, 66796], [66796, 66756], [66757, 66797], [66797, 66757], [66758, 66798], [66798, 66758], [66759, 66799], [66799, 66759], [66760, 66800], [66800, 66760], [66761, 66801], [66801, 66761], [66762, 66802], [66802, 66762], [66763, 66803], [66803, 66763], [66764, 66804], [66804, 66764], [66765, 66805], [66805, 66765], [66766, 66806], [66806, 66766], [66767, 66807], [66807, 66767], [66768, 66808], [66808, 66768], [66769, 66809], [66809, 66769], [66770, 66810], [66810, 66770], [66771, 66811], [66811, 66771], [66928, 66967], [66967, 66928], [66929, 66968], [66968, 66929], [66930, 66969], [66969, 66930], [66931, 66970], [66970, 66931], [66932, 66971], [66971, 66932], [66933, 66972], [66972, 66933], [66934, 66973], [66973, 66934], [66935, 66974], [66974, 66935], [66936, 66975], [66975, 66936], [66937, 66976], [66976, 66937], [66938, 66977], [66977, 66938], [66940, 66979], [66979, 66940], [66941, 66980], [66980, 66941], [66942, 66981], [66981, 66942], [66943, 66982], [66982, 66943], [66944, 66983], [66983, 66944], [66945, 66984], [66984, 66945], [66946, 66985], [66985, 66946], [66947, 66986], [66986, 66947], [66948, 66987], [66987, 66948], [66949, 66988], [66988, 66949], [66950, 66989], [66989, 66950], [66951, 66990], [66990, 66951], [66952, 66991], [66991, 66952], [66953, 66992], [66992, 66953], [66954, 66993], [66993, 66954], [66956, 66995], [66995, 66956], [66957, 66996], [66996, 66957], [66958, 66997], [66997, 66958], [66959, 66998], [66998, 66959], [66960, 66999], [66999, 66960], [66961, 67e3], [67e3, 66961], [66962, 67001], [67001, 66962], [66964, 67003], [67003, 66964], [66965, 67004], [67004, 66965], [68736, 68800], [68800, 68736], [68737, 68801], [68801, 68737], [68738, 68802], [68802, 68738], [68739, 68803], [68803, 68739], [68740, 68804], [68804, 68740], [68741, 68805], [68805, 68741], [68742, 68806], [68806, 68742], [68743, 68807], [68807, 68743], [68744, 68808], [68808, 68744], [68745, 68809], [68809, 68745], [68746, 68810], [68810, 68746], [68747, 68811], [68811, 68747], [68748, 68812], [68812, 68748], [68749, 68813], [68813, 68749], [68750, 68814], [68814, 68750], [68751, 68815], [68815, 68751], [68752, 68816], [68816, 68752], [68753, 68817], [68817, 68753], [68754, 68818], [68818, 68754], [68755, 68819], [68819, 68755], [68756, 68820], [68820, 68756], [68757, 68821], [68821, 68757], [68758, 68822], [68822, 68758], [68759, 68823], [68823, 68759], [68760, 68824], [68824, 68760], [68761, 68825], [68825, 68761], [68762, 68826], [68826, 68762], [68763, 68827], [68827, 68763], [68764, 68828], [68828, 68764], [68765, 68829], [68829, 68765], [68766, 68830], [68830, 68766], [68767, 68831], [68831, 68767], [68768, 68832], [68832, 68768], [68769, 68833], [68833, 68769], [68770, 68834], [68834, 68770], [68771, 68835], [68835, 68771], [68772, 68836], [68836, 68772], [68773, 68837], [68837, 68773], [68774, 68838], [68838, 68774], [68775, 68839], [68839, 68775], [68776, 68840], [68840, 68776], [68777, 68841], [68841, 68777], [68778, 68842], [68842, 68778], [68779, 68843], [68843, 68779], [68780, 68844], [68844, 68780], [68781, 68845], [68845, 68781], [68782, 68846], [68846, 68782], [68783, 68847], [68847, 68783], [68784, 68848], [68848, 68784], [68785, 68849], [68849, 68785], [68786, 68850], [68850, 68786], [68944, 68976], [68976, 68944], [68945, 68977], [68977, 68945], [68946, 68978], [68978, 68946], [68947, 68979], [68979, 68947], [68948, 68980], [68980, 68948], [68949, 68981], [68981, 68949], [68950, 68982], [68982, 68950], [68951, 68983], [68983, 68951], [68952, 68984], [68984, 68952], [68953, 68985], [68985, 68953], [68954, 68986], [68986, 68954], [68955, 68987], [68987, 68955], [68956, 68988], [68988, 68956], [68957, 68989], [68989, 68957], [68958, 68990], [68990, 68958], [68959, 68991], [68991, 68959], [68960, 68992], [68992, 68960], [68961, 68993], [68993, 68961], [68962, 68994], [68994, 68962], [68963, 68995], [68995, 68963], [68964, 68996], [68996, 68964], [68965, 68997], [68997, 68965], [71840, 71872], [71872, 71840], [71841, 71873], [71873, 71841], [71842, 71874], [71874, 71842], [71843, 71875], [71875, 71843], [71844, 71876], [71876, 71844], [71845, 71877], [71877, 71845], [71846, 71878], [71878, 71846], [71847, 71879], [71879, 71847], [71848, 71880], [71880, 71848], [71849, 71881], [71881, 71849], [71850, 71882], [71882, 71850], [71851, 71883], [71883, 71851], [71852, 71884], [71884, 71852], [71853, 71885], [71885, 71853], [71854, 71886], [71886, 71854], [71855, 71887], [71887, 71855], [71856, 71888], [71888, 71856], [71857, 71889], [71889, 71857], [71858, 71890], [71890, 71858], [71859, 71891], [71891, 71859], [71860, 71892], [71892, 71860], [71861, 71893], [71893, 71861], [71862, 71894], [71894, 71862], [71863, 71895], [71895, 71863], [71864, 71896], [71896, 71864], [71865, 71897], [71897, 71865], [71866, 71898], [71898, 71866], [71867, 71899], [71899, 71867], [71868, 71900], [71900, 71868], [71869, 71901], [71901, 71869], [71870, 71902], [71902, 71870], [71871, 71903], [71903, 71871], [93760, 93792], [93792, 93760], [93761, 93793], [93793, 93761], [93762, 93794], [93794, 93762], [93763, 93795], [93795, 93763], [93764, 93796], [93796, 93764], [93765, 93797], [93797, 93765], [93766, 93798], [93798, 93766], [93767, 93799], [93799, 93767], [93768, 93800], [93800, 93768], [93769, 93801], [93801, 93769], [93770, 93802], [93802, 93770], [93771, 93803], [93803, 93771], [93772, 93804], [93804, 93772], [93773, 93805], [93805, 93773], [93774, 93806], [93806, 93774], [93775, 93807], [93807, 93775], [93776, 93808], [93808, 93776], [93777, 93809], [93809, 93777], [93778, 93810], [93810, 93778], [93779, 93811], [93811, 93779], [93780, 93812], [93812, 93780], [93781, 93813], [93813, 93781], [93782, 93814], [93814, 93782], [93783, 93815], [93815, 93783], [93784, 93816], [93816, 93784], [93785, 93817], [93817, 93785], [93786, 93818], [93818, 93786], [93787, 93819], [93819, 93787], [93788, 93820], [93820, 93788], [93789, 93821], [93821, 93789], [93790, 93822], [93822, 93790], [93791, 93823], [93823, 93791], [125184, 125218], [125218, 125184], [125185, 125219], [125219, 125185], [125186, 125220], [125220, 125186], [125187, 125221], [125221, 125187], [125188, 125222], [125222, 125188], [125189, 125223], [125223, 125189], [125190, 125224], [125224, 125190], [125191, 125225], [125225, 125191], [125192, 125226], [125226, 125192], [125193, 125227], [125227, 125193], [125194, 125228], [125228, 125194], [125195, 125229], [125229, 125195], [125196, 125230], [125230, 125196], [125197, 125231], [125231, 125197], [125198, 125232], [125232, 125198], [125199, 125233], [125233, 125199], [125200, 125234], [125234, 125200], [125201, 125235], [125235, 125201], [125202, 125236], [125236, 125202], [125203, 125237], [125237, 125203], [125204, 125238], [125238, 125204], [125205, 125239], [125239, 125205], [125206, 125240], [125240, 125206], [125207, 125241], [125241, 125207], [125208, 125242], [125242, 125208], [125209, 125243], [125243, 125209], [125210, 125244], [125244, 125210], [125211, 125245], [125245, 125211], [125212, 125246], [125246, 125212], [125213, 125247], [125247, 125213], [125214, 125248], [125248, 125214], [125215, 125249], [125249, 125215], [125216, 125250], [125250, 125216], [125217, 125251], [125251, 125217]]);
    static C = new C(new Uint32Array([0, 31, 1, 127, 159, 1, 173, 888, 715, 889, 896, 7, 897, 899, 1, 907, 909, 2, 930, 1328, 398, 1367, 1368, 1, 1419, 1420, 1, 1424, 1480, 56, 1481, 1487, 1, 1515, 1518, 1, 1525, 1541, 1, 1564, 1757, 193, 1806, 1807, 1, 1867, 1868, 1, 1970, 1983, 1, 2043, 2044, 1, 2094, 2095, 1, 2111, 2140, 29, 2141, 2143, 2, 2155, 2159, 1, 2191, 2198, 1, 2274, 2436, 162, 2445, 2446, 1, 2449, 2450, 1, 2473, 2481, 8, 2483, 2485, 1, 2490, 2491, 1, 2501, 2502, 1, 2505, 2506, 1, 2511, 2518, 1, 2520, 2523, 1, 2526, 2532, 6, 2533, 2559, 26, 2560, 2564, 4, 2571, 2574, 1, 2577, 2578, 1, 2601, 2609, 8, 2612, 2618, 3, 2619, 2621, 2, 2627, 2630, 1, 2633, 2634, 1, 2638, 2640, 1, 2642, 2648, 1, 2653, 2655, 2, 2656, 2661, 1, 2679, 2688, 1, 2692, 2702, 10, 2706, 2729, 23, 2737, 2740, 3, 2746, 2747, 1, 2758, 2766, 4, 2767, 2769, 2, 2770, 2783, 1, 2788, 2789, 1, 2802, 2808, 1, 2816, 2820, 4, 2829, 2830, 1, 2833, 2834, 1, 2857, 2865, 8, 2868, 2874, 6, 2875, 2885, 10, 2886, 2889, 3, 2890, 2894, 4, 2895, 2900, 1, 2904, 2907, 1, 2910, 2916, 6, 2917, 2936, 19, 2937, 2945, 1, 2948, 2955, 7, 2956, 2957, 1, 2961, 2966, 5, 2967, 2968, 1, 2971, 2973, 2, 2976, 2978, 1, 2981, 2983, 1, 2987, 2989, 1, 3002, 3005, 1, 3011, 3013, 1, 3017, 3022, 5, 3023, 3025, 2, 3026, 3030, 1, 3032, 3045, 1, 3067, 3071, 1, 3085, 3089, 4, 3113, 3130, 17, 3131, 3141, 10, 3145, 3150, 5, 3151, 3156, 1, 3159, 3163, 4, 3164, 3166, 2, 3167, 3172, 5, 3173, 3184, 11, 3185, 3190, 1, 3213, 3217, 4, 3241, 3252, 11, 3258, 3259, 1, 3269, 3273, 4, 3278, 3284, 1, 3287, 3292, 1, 3295, 3300, 5, 3301, 3312, 11, 3316, 3327, 1, 3341, 3345, 4, 3397, 3401, 4, 3408, 3411, 1, 3428, 3429, 1, 3456, 3460, 4, 3479, 3481, 1, 3506, 3516, 10, 3518, 3519, 1, 3527, 3529, 1, 3531, 3534, 1, 3541, 3543, 2, 3552, 3557, 1, 3568, 3569, 1, 3573, 3584, 1, 3643, 3646, 1, 3676, 3712, 1, 3715, 3717, 2, 3723, 3748, 25, 3750, 3774, 24, 3775, 3781, 6, 3783, 3791, 8, 3802, 3803, 1, 3808, 3839, 1, 3912, 3949, 37, 3950, 3952, 1, 3992, 4029, 37, 4045, 4059, 14, 4060, 4095, 1, 4294, 4296, 2, 4297, 4300, 1, 4302, 4303, 1, 4681, 4686, 5, 4687, 4695, 8, 4697, 4702, 5, 4703, 4745, 42, 4750, 4751, 1, 4785, 4790, 5, 4791, 4799, 8, 4801, 4806, 5, 4807, 4823, 16, 4881, 4886, 5, 4887, 4955, 68, 4956, 4989, 33, 4990, 4991, 1, 5018, 5023, 1, 5110, 5111, 1, 5118, 5119, 1, 5789, 5791, 1, 5881, 5887, 1, 5910, 5918, 1, 5943, 5951, 1, 5972, 5983, 1, 5997, 6001, 4, 6004, 6015, 1, 6110, 6111, 1, 6122, 6127, 1, 6138, 6143, 1, 6158, 6170, 12, 6171, 6175, 1, 6265, 6271, 1, 6315, 6319, 1, 6390, 6399, 1, 6431, 6444, 13, 6445, 6447, 1, 6460, 6463, 1, 6465, 6467, 1, 6510, 6511, 1, 6517, 6527, 1, 6572, 6575, 1, 6602, 6607, 1, 6619, 6621, 1, 6684, 6685, 1, 6751, 6781, 30, 6782, 6794, 12, 6795, 6799, 1, 6810, 6815, 1, 6830, 6831, 1, 6863, 6911, 1, 6989, 7156, 167, 7157, 7163, 1, 7224, 7226, 1, 7242, 7244, 1, 7307, 7311, 1, 7355, 7356, 1, 7368, 7375, 1, 7419, 7423, 1, 7958, 7959, 1, 7966, 7967, 1, 8006, 8007, 1, 8014, 8015, 1, 8024, 8030, 2, 8062, 8063, 1, 8117, 8133, 16, 8148, 8149, 1, 8156, 8176, 20, 8177, 8181, 4, 8191, 8203, 12, 8204, 8207, 1, 8234, 8238, 1, 8288, 8303, 1, 8306, 8307, 1, 8335, 8349, 14, 8350, 8351, 1, 8385, 8399, 1, 8433, 8447, 1, 8588, 8591, 1, 9258, 9279, 1, 9291, 9311, 1, 11124, 11125, 1, 11158, 11508, 350, 11509, 11512, 1, 11558, 11560, 2, 11561, 11564, 1, 11566, 11567, 1, 11624, 11630, 1, 11633, 11646, 1, 11671, 11679, 1, 11687, 11743, 8, 11870, 11903, 1, 11930, 12020, 90, 12021, 12031, 1, 12246, 12271, 1, 12352, 12439, 87, 12440, 12544, 104, 12545, 12548, 1, 12592, 12687, 95, 12774, 12782, 1, 12831, 42125, 29294, 42126, 42127, 1, 42183, 42191, 1, 42540, 42559, 1, 42744, 42751, 1, 42958, 42959, 1, 42962, 42964, 2, 42973, 42993, 1, 43053, 43055, 1, 43066, 43071, 1, 43128, 43135, 1, 43206, 43213, 1, 43226, 43231, 1, 43348, 43358, 1, 43389, 43391, 1, 43470, 43482, 12, 43483, 43485, 1, 43519, 43575, 56, 43576, 43583, 1, 43598, 43599, 1, 43610, 43611, 1, 43715, 43738, 1, 43767, 43776, 1, 43783, 43784, 1, 43791, 43792, 1, 43799, 43807, 1, 43815, 43823, 8, 43884, 43887, 1, 44014, 44015, 1, 44026, 44031, 1, 55204, 55215, 1, 55239, 55242, 1, 55292, 63743, 1, 64110, 64111, 1, 64218, 64255, 1, 64263, 64274, 1, 64280, 64284, 1, 64311, 64317, 6, 64319, 64325, 3, 64451, 64466, 1, 64912, 64913, 1, 64968, 64974, 1, 64976, 65007, 1, 65050, 65055, 1, 65107, 65127, 20, 65132, 65135, 1, 65141, 65277, 136, 65278, 65280, 1, 65471, 65473, 1, 65480, 65481, 1, 65488, 65489, 1, 65496, 65497, 1, 65501, 65503, 1, 65511, 65519, 8, 65520, 65531, 1, 65534, 65535, 1, 65548, 65575, 27, 65595, 65598, 3, 65614, 65615, 1, 65630, 65663, 1, 65787, 65791, 1, 65795, 65798, 1, 65844, 65846, 1, 65935, 65949, 14, 65950, 65951, 1, 65953, 65999, 1, 66046, 66175, 1, 66205, 66207, 1, 66257, 66271, 1, 66300, 66303, 1, 66340, 66348, 1, 66379, 66383, 1, 66427, 66431, 1, 66462, 66500, 38, 66501, 66503, 1, 66518, 66559, 1, 66718, 66719, 1, 66730, 66735, 1, 66772, 66775, 1, 66812, 66815, 1, 66856, 66863, 1, 66916, 66926, 1, 66939, 66955, 16, 66963, 66966, 3, 66978, 66994, 16, 67002, 67005, 3, 67006, 67007, 1, 67060, 67071, 1, 67383, 67391, 1, 67414, 67423, 1, 67432, 67455, 1, 67462, 67505, 43, 67515, 67583, 1, 67590, 67591, 1, 67593, 67638, 45, 67641, 67643, 1, 67645, 67646, 1, 67670, 67743, 73, 67744, 67750, 1, 67760, 67807, 1, 67827, 67830, 3, 67831, 67834, 1, 67868, 67870, 1, 67898, 67902, 1, 67904, 67967, 1, 68024, 68027, 1, 68048, 68049, 1, 68100, 68103, 3, 68104, 68107, 1, 68116, 68120, 4, 68150, 68151, 1, 68155, 68158, 1, 68169, 68175, 1, 68185, 68191, 1, 68256, 68287, 1, 68327, 68330, 1, 68343, 68351, 1, 68406, 68408, 1, 68438, 68439, 1, 68467, 68471, 1, 68498, 68504, 1, 68509, 68520, 1, 68528, 68607, 1, 68681, 68735, 1, 68787, 68799, 1, 68851, 68857, 1, 68904, 68911, 1, 68922, 68927, 1, 68966, 68968, 1, 68998, 69005, 1, 69008, 69215, 1, 69247, 69290, 43, 69294, 69295, 1, 69298, 69313, 1, 69317, 69371, 1, 69416, 69423, 1, 69466, 69487, 1, 69514, 69551, 1, 69580, 69599, 1, 69623, 69631, 1, 69710, 69713, 1, 69750, 69758, 1, 69821, 69827, 6, 69828, 69839, 1, 69865, 69871, 1, 69882, 69887, 1, 69941, 69960, 19, 69961, 69967, 1, 70007, 70015, 1, 70112, 70133, 21, 70134, 70143, 1, 70162, 70210, 48, 70211, 70271, 1, 70279, 70281, 2, 70286, 70302, 16, 70314, 70319, 1, 70379, 70383, 1, 70394, 70399, 1, 70404, 70413, 9, 70414, 70417, 3, 70418, 70441, 23, 70449, 70452, 3, 70458, 70469, 11, 70470, 70473, 3, 70474, 70478, 4, 70479, 70481, 2, 70482, 70486, 1, 70488, 70492, 1, 70500, 70501, 1, 70509, 70511, 1, 70517, 70527, 1, 70538, 70540, 2, 70541, 70543, 2, 70582, 70593, 11, 70595, 70596, 1, 70598, 70603, 5, 70614, 70617, 3, 70618, 70624, 1, 70627, 70655, 1, 70748, 70754, 6, 70755, 70783, 1, 70856, 70863, 1, 70874, 71039, 1, 71094, 71095, 1, 71134, 71167, 1, 71237, 71247, 1, 71258, 71263, 1, 71277, 71295, 1, 71354, 71359, 1, 71370, 71375, 1, 71396, 71423, 1, 71451, 71452, 1, 71468, 71471, 1, 71495, 71679, 1, 71740, 71839, 1, 71923, 71934, 1, 71943, 71944, 1, 71946, 71947, 1, 71956, 71959, 3, 71990, 71993, 3, 71994, 72007, 13, 72008, 72015, 1, 72026, 72095, 1, 72104, 72105, 1, 72152, 72153, 1, 72165, 72191, 1, 72264, 72271, 1, 72355, 72367, 1, 72441, 72447, 1, 72458, 72639, 1, 72674, 72687, 1, 72698, 72703, 1, 72713, 72759, 46, 72774, 72783, 1, 72813, 72815, 1, 72848, 72849, 1, 72872, 72887, 15, 72888, 72959, 1, 72967, 72970, 3, 73015, 73017, 1, 73019, 73022, 3, 73032, 73039, 1, 73050, 73055, 1, 73062, 73065, 3, 73103, 73106, 3, 73113, 73119, 1, 73130, 73439, 1, 73465, 73471, 1, 73489, 73531, 42, 73532, 73533, 1, 73563, 73647, 1, 73649, 73663, 1, 73714, 73726, 1, 74650, 74751, 1, 74863, 74869, 6, 74870, 74879, 1, 75076, 77711, 1, 77811, 77823, 1, 78896, 78911, 1, 78934, 78943, 1, 82939, 82943, 1, 83527, 90367, 1, 90426, 92159, 1, 92729, 92735, 1, 92767, 92778, 11, 92779, 92781, 1, 92863, 92874, 11, 92875, 92879, 1, 92910, 92911, 1, 92918, 92927, 1, 92998, 93007, 1, 93018, 93026, 8, 93048, 93052, 1, 93072, 93503, 1, 93562, 93759, 1, 93851, 93951, 1, 94027, 94030, 1, 94088, 94094, 1, 94112, 94175, 1, 94181, 94191, 1, 94194, 94207, 1, 100344, 100351, 1, 101590, 101630, 1, 101641, 110575, 1, 110580, 110588, 8, 110591, 110883, 292, 110884, 110897, 1, 110899, 110927, 1, 110931, 110932, 1, 110934, 110947, 1, 110952, 110959, 1, 111356, 113663, 1, 113771, 113775, 1, 113789, 113791, 1, 113801, 113807, 1, 113818, 113819, 1, 113824, 117759, 1, 118010, 118015, 1, 118452, 118527, 1, 118574, 118575, 1, 118599, 118607, 1, 118724, 118783, 1, 119030, 119039, 1, 119079, 119080, 1, 119155, 119162, 1, 119275, 119295, 1, 119366, 119487, 1, 119508, 119519, 1, 119540, 119551, 1, 119639, 119647, 1, 119673, 119807, 1, 119893, 119965, 72, 119968, 119969, 1, 119971, 119972, 1, 119975, 119976, 1, 119981, 119994, 13, 119996, 120004, 8, 120070, 120075, 5, 120076, 120085, 9, 120093, 120122, 29, 120127, 120133, 6, 120135, 120137, 1, 120145, 120486, 341, 120487, 120780, 293, 120781, 121484, 703, 121485, 121498, 1, 121504, 121520, 16, 121521, 122623, 1, 122655, 122660, 1, 122667, 122879, 1, 122887, 122905, 18, 122906, 122914, 8, 122917, 122923, 6, 122924, 122927, 1, 122990, 123022, 1, 123024, 123135, 1, 123181, 123183, 1, 123198, 123199, 1, 123210, 123213, 1, 123216, 123535, 1, 123567, 123583, 1, 123642, 123646, 1, 123648, 124111, 1, 124154, 124367, 1, 124411, 124414, 1, 124416, 124895, 1, 124903, 124908, 5, 124911, 124927, 16, 125125, 125126, 1, 125143, 125183, 1, 125260, 125263, 1, 125274, 125277, 1, 125280, 126064, 1, 126133, 126208, 1, 126270, 126463, 1, 126468, 126496, 28, 126499, 126501, 2, 126502, 126504, 2, 126515, 126520, 5, 126522, 126524, 2, 126525, 126529, 1, 126531, 126534, 1, 126536, 126540, 2, 126544, 126547, 3, 126549, 126550, 1, 126552, 126560, 2, 126563, 126565, 2, 126566, 126571, 5, 126579, 126589, 5, 126591, 126602, 11, 126620, 126624, 1, 126628, 126634, 6, 126652, 126703, 1, 126706, 126975, 1, 127020, 127023, 1, 127124, 127135, 1, 127151, 127152, 1, 127168, 127184, 16, 127222, 127231, 1, 127406, 127461, 1, 127491, 127503, 1, 127548, 127551, 1, 127561, 127567, 1, 127570, 127583, 1, 127590, 127743, 1, 128728, 128731, 1, 128749, 128751, 1, 128765, 128767, 1, 128887, 128890, 1, 128986, 128991, 1, 129004, 129007, 1, 129009, 129023, 1, 129036, 129039, 1, 129096, 129103, 1, 129114, 129119, 1, 129160, 129167, 1, 129198, 129199, 1, 129212, 129215, 1, 129218, 129279, 1, 129620, 129631, 1, 129646, 129647, 1, 129661, 129663, 1, 129674, 129678, 1, 129735, 129741, 1, 129757, 129758, 1, 129770, 129775, 1, 129785, 129791, 1, 129939, 130042, 103, 130043, 131071, 1, 173792, 173823, 1, 177978, 177983, 1, 178206, 178207, 1, 183970, 183983, 1, 191457, 191471, 1, 192094, 194559, 1, 195102, 196607, 1, 201547, 201551, 1, 205744, 917759, 1, 918e3, 1114111, 1]));
    static Cc = new C(new Uint32Array([0, 31, 1, 127, 159, 1]));
    static Cf = new C(new Uint32Array([173, 1536, 1363, 1537, 1541, 1, 1564, 1757, 193, 1807, 2192, 385, 2193, 2274, 81, 6158, 8203, 2045, 8204, 8207, 1, 8234, 8238, 1, 8288, 8292, 1, 8294, 8303, 1, 65279, 65529, 250, 65530, 65531, 1, 69821, 69837, 16, 78896, 78911, 1, 113824, 113827, 1, 119155, 119162, 1, 917505, 917536, 31, 917537, 917631, 1]));
    static Co = new C(new Uint32Array([57344, 63743, 1, 983040, 1048573, 1, 1048576, 1114109, 1]));
    static Cs = new C(new Uint32Array([55296, 57343, 1]));
    static L = new C(new Uint32Array([65, 90, 1, 97, 122, 1, 170, 181, 11, 186, 192, 6, 193, 214, 1, 216, 246, 1, 248, 705, 1, 710, 721, 1, 736, 740, 1, 748, 750, 2, 880, 884, 1, 886, 887, 1, 890, 893, 1, 895, 902, 7, 904, 906, 1, 908, 910, 2, 911, 929, 1, 931, 1013, 1, 1015, 1153, 1, 1162, 1327, 1, 1329, 1366, 1, 1369, 1376, 7, 1377, 1416, 1, 1488, 1514, 1, 1519, 1522, 1, 1568, 1610, 1, 1646, 1647, 1, 1649, 1747, 1, 1749, 1765, 16, 1766, 1774, 8, 1775, 1786, 11, 1787, 1788, 1, 1791, 1808, 17, 1810, 1839, 1, 1869, 1957, 1, 1969, 1994, 25, 1995, 2026, 1, 2036, 2037, 1, 2042, 2048, 6, 2049, 2069, 1, 2074, 2084, 10, 2088, 2112, 24, 2113, 2136, 1, 2144, 2154, 1, 2160, 2183, 1, 2185, 2190, 1, 2208, 2249, 1, 2308, 2361, 1, 2365, 2384, 19, 2392, 2401, 1, 2417, 2432, 1, 2437, 2444, 1, 2447, 2448, 1, 2451, 2472, 1, 2474, 2480, 1, 2482, 2486, 4, 2487, 2489, 1, 2493, 2510, 17, 2524, 2525, 1, 2527, 2529, 1, 2544, 2545, 1, 2556, 2565, 9, 2566, 2570, 1, 2575, 2576, 1, 2579, 2600, 1, 2602, 2608, 1, 2610, 2611, 1, 2613, 2614, 1, 2616, 2617, 1, 2649, 2652, 1, 2654, 2674, 20, 2675, 2676, 1, 2693, 2701, 1, 2703, 2705, 1, 2707, 2728, 1, 2730, 2736, 1, 2738, 2739, 1, 2741, 2745, 1, 2749, 2768, 19, 2784, 2785, 1, 2809, 2821, 12, 2822, 2828, 1, 2831, 2832, 1, 2835, 2856, 1, 2858, 2864, 1, 2866, 2867, 1, 2869, 2873, 1, 2877, 2908, 31, 2909, 2911, 2, 2912, 2913, 1, 2929, 2947, 18, 2949, 2954, 1, 2958, 2960, 1, 2962, 2965, 1, 2969, 2970, 1, 2972, 2974, 2, 2975, 2979, 4, 2980, 2984, 4, 2985, 2986, 1, 2990, 3001, 1, 3024, 3077, 53, 3078, 3084, 1, 3086, 3088, 1, 3090, 3112, 1, 3114, 3129, 1, 3133, 3160, 27, 3161, 3162, 1, 3165, 3168, 3, 3169, 3200, 31, 3205, 3212, 1, 3214, 3216, 1, 3218, 3240, 1, 3242, 3251, 1, 3253, 3257, 1, 3261, 3293, 32, 3294, 3296, 2, 3297, 3313, 16, 3314, 3332, 18, 3333, 3340, 1, 3342, 3344, 1, 3346, 3386, 1, 3389, 3406, 17, 3412, 3414, 1, 3423, 3425, 1, 3450, 3455, 1, 3461, 3478, 1, 3482, 3505, 1, 3507, 3515, 1, 3517, 3520, 3, 3521, 3526, 1, 3585, 3632, 1, 3634, 3635, 1, 3648, 3654, 1, 3713, 3714, 1, 3716, 3718, 2, 3719, 3722, 1, 3724, 3747, 1, 3749, 3751, 2, 3752, 3760, 1, 3762, 3763, 1, 3773, 3776, 3, 3777, 3780, 1, 3782, 3804, 22, 3805, 3807, 1, 3840, 3904, 64, 3905, 3911, 1, 3913, 3948, 1, 3976, 3980, 1, 4096, 4138, 1, 4159, 4176, 17, 4177, 4181, 1, 4186, 4189, 1, 4193, 4197, 4, 4198, 4206, 8, 4207, 4208, 1, 4213, 4225, 1, 4238, 4256, 18, 4257, 4293, 1, 4295, 4301, 6, 4304, 4346, 1, 4348, 4680, 1, 4682, 4685, 1, 4688, 4694, 1, 4696, 4698, 2, 4699, 4701, 1, 4704, 4744, 1, 4746, 4749, 1, 4752, 4784, 1, 4786, 4789, 1, 4792, 4798, 1, 4800, 4802, 2, 4803, 4805, 1, 4808, 4822, 1, 4824, 4880, 1, 4882, 4885, 1, 4888, 4954, 1, 4992, 5007, 1, 5024, 5109, 1, 5112, 5117, 1, 5121, 5740, 1, 5743, 5759, 1, 5761, 5786, 1, 5792, 5866, 1, 5873, 5880, 1, 5888, 5905, 1, 5919, 5937, 1, 5952, 5969, 1, 5984, 5996, 1, 5998, 6e3, 1, 6016, 6067, 1, 6103, 6108, 5, 6176, 6264, 1, 6272, 6276, 1, 6279, 6312, 1, 6314, 6320, 6, 6321, 6389, 1, 6400, 6430, 1, 6480, 6509, 1, 6512, 6516, 1, 6528, 6571, 1, 6576, 6601, 1, 6656, 6678, 1, 6688, 6740, 1, 6823, 6917, 94, 6918, 6963, 1, 6981, 6988, 1, 7043, 7072, 1, 7086, 7087, 1, 7098, 7141, 1, 7168, 7203, 1, 7245, 7247, 1, 7258, 7293, 1, 7296, 7306, 1, 7312, 7354, 1, 7357, 7359, 1, 7401, 7404, 1, 7406, 7411, 1, 7413, 7414, 1, 7418, 7424, 6, 7425, 7615, 1, 7680, 7957, 1, 7960, 7965, 1, 7968, 8005, 1, 8008, 8013, 1, 8016, 8023, 1, 8025, 8031, 2, 8032, 8061, 1, 8064, 8116, 1, 8118, 8124, 1, 8126, 8130, 4, 8131, 8132, 1, 8134, 8140, 1, 8144, 8147, 1, 8150, 8155, 1, 8160, 8172, 1, 8178, 8180, 1, 8182, 8188, 1, 8305, 8319, 14, 8336, 8348, 1, 8450, 8455, 5, 8458, 8467, 1, 8469, 8473, 4, 8474, 8477, 1, 8484, 8490, 2, 8491, 8493, 1, 8495, 8505, 1, 8508, 8511, 1, 8517, 8521, 1, 8526, 8579, 53, 8580, 11264, 2684, 11265, 11492, 1, 11499, 11502, 1, 11506, 11507, 1, 11520, 11557, 1, 11559, 11565, 6, 11568, 11623, 1, 11631, 11648, 17, 11649, 11670, 1, 11680, 11686, 1, 11688, 11694, 1, 11696, 11702, 1, 11704, 11710, 1, 11712, 11718, 1, 11720, 11726, 1, 11728, 11734, 1, 11736, 11742, 1, 11823, 12293, 470, 12294, 12337, 43, 12338, 12341, 1, 12347, 12348, 1, 12353, 12438, 1, 12445, 12447, 1, 12449, 12538, 1, 12540, 12543, 1, 12549, 12591, 1, 12593, 12686, 1, 12704, 12735, 1, 12784, 12799, 1, 13312, 19903, 1, 19968, 42124, 1, 42192, 42237, 1, 42240, 42508, 1, 42512, 42527, 1, 42538, 42539, 1, 42560, 42606, 1, 42623, 42653, 1, 42656, 42725, 1, 42775, 42783, 1, 42786, 42888, 1, 42891, 42957, 1, 42960, 42961, 1, 42963, 42965, 2, 42966, 42972, 1, 42994, 43009, 1, 43011, 43013, 1, 43015, 43018, 1, 43020, 43042, 1, 43072, 43123, 1, 43138, 43187, 1, 43250, 43255, 1, 43259, 43261, 2, 43262, 43274, 12, 43275, 43301, 1, 43312, 43334, 1, 43360, 43388, 1, 43396, 43442, 1, 43471, 43488, 17, 43489, 43492, 1, 43494, 43503, 1, 43514, 43518, 1, 43520, 43560, 1, 43584, 43586, 1, 43588, 43595, 1, 43616, 43638, 1, 43642, 43646, 4, 43647, 43695, 1, 43697, 43701, 4, 43702, 43705, 3, 43706, 43709, 1, 43712, 43714, 2, 43739, 43741, 1, 43744, 43754, 1, 43762, 43764, 1, 43777, 43782, 1, 43785, 43790, 1, 43793, 43798, 1, 43808, 43814, 1, 43816, 43822, 1, 43824, 43866, 1, 43868, 43881, 1, 43888, 44002, 1, 44032, 55203, 1, 55216, 55238, 1, 55243, 55291, 1, 63744, 64109, 1, 64112, 64217, 1, 64256, 64262, 1, 64275, 64279, 1, 64285, 64287, 2, 64288, 64296, 1, 64298, 64310, 1, 64312, 64316, 1, 64318, 64320, 2, 64321, 64323, 2, 64324, 64326, 2, 64327, 64433, 1, 64467, 64829, 1, 64848, 64911, 1, 64914, 64967, 1, 65008, 65019, 1, 65136, 65140, 1, 65142, 65276, 1, 65313, 65338, 1, 65345, 65370, 1, 65382, 65470, 1, 65474, 65479, 1, 65482, 65487, 1, 65490, 65495, 1, 65498, 65500, 1, 65536, 65547, 1, 65549, 65574, 1, 65576, 65594, 1, 65596, 65597, 1, 65599, 65613, 1, 65616, 65629, 1, 65664, 65786, 1, 66176, 66204, 1, 66208, 66256, 1, 66304, 66335, 1, 66349, 66368, 1, 66370, 66377, 1, 66384, 66421, 1, 66432, 66461, 1, 66464, 66499, 1, 66504, 66511, 1, 66560, 66717, 1, 66736, 66771, 1, 66776, 66811, 1, 66816, 66855, 1, 66864, 66915, 1, 66928, 66938, 1, 66940, 66954, 1, 66956, 66962, 1, 66964, 66965, 1, 66967, 66977, 1, 66979, 66993, 1, 66995, 67001, 1, 67003, 67004, 1, 67008, 67059, 1, 67072, 67382, 1, 67392, 67413, 1, 67424, 67431, 1, 67456, 67461, 1, 67463, 67504, 1, 67506, 67514, 1, 67584, 67589, 1, 67592, 67594, 2, 67595, 67637, 1, 67639, 67640, 1, 67644, 67647, 3, 67648, 67669, 1, 67680, 67702, 1, 67712, 67742, 1, 67808, 67826, 1, 67828, 67829, 1, 67840, 67861, 1, 67872, 67897, 1, 67968, 68023, 1, 68030, 68031, 1, 68096, 68112, 16, 68113, 68115, 1, 68117, 68119, 1, 68121, 68149, 1, 68192, 68220, 1, 68224, 68252, 1, 68288, 68295, 1, 68297, 68324, 1, 68352, 68405, 1, 68416, 68437, 1, 68448, 68466, 1, 68480, 68497, 1, 68608, 68680, 1, 68736, 68786, 1, 68800, 68850, 1, 68864, 68899, 1, 68938, 68965, 1, 68975, 68997, 1, 69248, 69289, 1, 69296, 69297, 1, 69314, 69316, 1, 69376, 69404, 1, 69415, 69424, 9, 69425, 69445, 1, 69488, 69505, 1, 69552, 69572, 1, 69600, 69622, 1, 69635, 69687, 1, 69745, 69746, 1, 69749, 69763, 14, 69764, 69807, 1, 69840, 69864, 1, 69891, 69926, 1, 69956, 69959, 3, 69968, 70002, 1, 70006, 70019, 13, 70020, 70066, 1, 70081, 70084, 1, 70106, 70108, 2, 70144, 70161, 1, 70163, 70187, 1, 70207, 70208, 1, 70272, 70278, 1, 70280, 70282, 2, 70283, 70285, 1, 70287, 70301, 1, 70303, 70312, 1, 70320, 70366, 1, 70405, 70412, 1, 70415, 70416, 1, 70419, 70440, 1, 70442, 70448, 1, 70450, 70451, 1, 70453, 70457, 1, 70461, 70480, 19, 70493, 70497, 1, 70528, 70537, 1, 70539, 70542, 3, 70544, 70581, 1, 70583, 70609, 26, 70611, 70656, 45, 70657, 70708, 1, 70727, 70730, 1, 70751, 70753, 1, 70784, 70831, 1, 70852, 70853, 1, 70855, 71040, 185, 71041, 71086, 1, 71128, 71131, 1, 71168, 71215, 1, 71236, 71296, 60, 71297, 71338, 1, 71352, 71424, 72, 71425, 71450, 1, 71488, 71494, 1, 71680, 71723, 1, 71840, 71903, 1, 71935, 71942, 1, 71945, 71948, 3, 71949, 71955, 1, 71957, 71958, 1, 71960, 71983, 1, 71999, 72001, 2, 72096, 72103, 1, 72106, 72144, 1, 72161, 72163, 2, 72192, 72203, 11, 72204, 72242, 1, 72250, 72272, 22, 72284, 72329, 1, 72349, 72368, 19, 72369, 72440, 1, 72640, 72672, 1, 72704, 72712, 1, 72714, 72750, 1, 72768, 72818, 50, 72819, 72847, 1, 72960, 72966, 1, 72968, 72969, 1, 72971, 73008, 1, 73030, 73056, 26, 73057, 73061, 1, 73063, 73064, 1, 73066, 73097, 1, 73112, 73440, 328, 73441, 73458, 1, 73474, 73476, 2, 73477, 73488, 1, 73490, 73523, 1, 73648, 73728, 80, 73729, 74649, 1, 74880, 75075, 1, 77712, 77808, 1, 77824, 78895, 1, 78913, 78918, 1, 78944, 82938, 1, 82944, 83526, 1, 90368, 90397, 1, 92160, 92728, 1, 92736, 92766, 1, 92784, 92862, 1, 92880, 92909, 1, 92928, 92975, 1, 92992, 92995, 1, 93027, 93047, 1, 93053, 93071, 1, 93504, 93548, 1, 93760, 93823, 1, 93952, 94026, 1, 94032, 94099, 67, 94100, 94111, 1, 94176, 94177, 1, 94179, 94208, 29, 94209, 100343, 1, 100352, 101589, 1, 101631, 101640, 1, 110576, 110579, 1, 110581, 110587, 1, 110589, 110590, 1, 110592, 110882, 1, 110898, 110928, 30, 110929, 110930, 1, 110933, 110948, 15, 110949, 110951, 1, 110960, 111355, 1, 113664, 113770, 1, 113776, 113788, 1, 113792, 113800, 1, 113808, 113817, 1, 119808, 119892, 1, 119894, 119964, 1, 119966, 119967, 1, 119970, 119973, 3, 119974, 119977, 3, 119978, 119980, 1, 119982, 119993, 1, 119995, 119997, 2, 119998, 120003, 1, 120005, 120069, 1, 120071, 120074, 1, 120077, 120084, 1, 120086, 120092, 1, 120094, 120121, 1, 120123, 120126, 1, 120128, 120132, 1, 120134, 120138, 4, 120139, 120144, 1, 120146, 120485, 1, 120488, 120512, 1, 120514, 120538, 1, 120540, 120570, 1, 120572, 120596, 1, 120598, 120628, 1, 120630, 120654, 1, 120656, 120686, 1, 120688, 120712, 1, 120714, 120744, 1, 120746, 120770, 1, 120772, 120779, 1, 122624, 122654, 1, 122661, 122666, 1, 122928, 122989, 1, 123136, 123180, 1, 123191, 123197, 1, 123214, 123536, 322, 123537, 123565, 1, 123584, 123627, 1, 124112, 124139, 1, 124368, 124397, 1, 124400, 124896, 496, 124897, 124902, 1, 124904, 124907, 1, 124909, 124910, 1, 124912, 124926, 1, 124928, 125124, 1, 125184, 125251, 1, 125259, 126464, 1205, 126465, 126467, 1, 126469, 126495, 1, 126497, 126498, 1, 126500, 126503, 3, 126505, 126514, 1, 126516, 126519, 1, 126521, 126523, 2, 126530, 126535, 5, 126537, 126541, 2, 126542, 126543, 1, 126545, 126546, 1, 126548, 126551, 3, 126553, 126561, 2, 126562, 126564, 2, 126567, 126570, 1, 126572, 126578, 1, 126580, 126583, 1, 126585, 126588, 1, 126590, 126592, 2, 126593, 126601, 1, 126603, 126619, 1, 126625, 126627, 1, 126629, 126633, 1, 126635, 126651, 1, 131072, 173791, 1, 173824, 177977, 1, 177984, 178205, 1, 178208, 183969, 1, 183984, 191456, 1, 191472, 192093, 1, 194560, 195101, 1, 196608, 201546, 1, 201552, 205743, 1]));
    static foldL = new C(new Uint32Array([837, 837, 1]));
    static Ll = new C(new Uint32Array([97, 122, 1, 181, 223, 42, 224, 246, 1, 248, 255, 1, 257, 311, 2, 312, 328, 2, 329, 375, 2, 378, 382, 2, 383, 384, 1, 387, 389, 2, 392, 396, 4, 397, 402, 5, 405, 409, 4, 410, 411, 1, 414, 417, 3, 419, 421, 2, 424, 426, 2, 427, 429, 2, 432, 436, 4, 438, 441, 3, 442, 445, 3, 446, 447, 1, 454, 460, 3, 462, 476, 2, 477, 495, 2, 496, 499, 3, 501, 505, 4, 507, 563, 2, 564, 569, 1, 572, 575, 3, 576, 578, 2, 583, 591, 2, 592, 659, 1, 661, 687, 1, 881, 883, 2, 887, 891, 4, 892, 893, 1, 912, 940, 28, 941, 974, 1, 976, 977, 1, 981, 983, 1, 985, 1007, 2, 1008, 1011, 1, 1013, 1019, 3, 1020, 1072, 52, 1073, 1119, 1, 1121, 1153, 2, 1163, 1215, 2, 1218, 1230, 2, 1231, 1327, 2, 1376, 1416, 1, 4304, 4346, 1, 4349, 4351, 1, 5112, 5117, 1, 7296, 7304, 1, 7306, 7424, 118, 7425, 7467, 1, 7531, 7543, 1, 7545, 7578, 1, 7681, 7829, 2, 7830, 7837, 1, 7839, 7935, 2, 7936, 7943, 1, 7952, 7957, 1, 7968, 7975, 1, 7984, 7991, 1, 8e3, 8005, 1, 8016, 8023, 1, 8032, 8039, 1, 8048, 8061, 1, 8064, 8071, 1, 8080, 8087, 1, 8096, 8103, 1, 8112, 8116, 1, 8118, 8119, 1, 8126, 8130, 4, 8131, 8132, 1, 8134, 8135, 1, 8144, 8147, 1, 8150, 8151, 1, 8160, 8167, 1, 8178, 8180, 1, 8182, 8183, 1, 8458, 8462, 4, 8463, 8467, 4, 8495, 8505, 5, 8508, 8509, 1, 8518, 8521, 1, 8526, 8580, 54, 11312, 11359, 1, 11361, 11365, 4, 11366, 11372, 2, 11377, 11379, 2, 11380, 11382, 2, 11383, 11387, 1, 11393, 11491, 2, 11492, 11500, 8, 11502, 11507, 5, 11520, 11557, 1, 11559, 11565, 6, 42561, 42605, 2, 42625, 42651, 2, 42787, 42799, 2, 42800, 42801, 1, 42803, 42865, 2, 42866, 42872, 1, 42874, 42876, 2, 42879, 42887, 2, 42892, 42894, 2, 42897, 42899, 2, 42900, 42901, 1, 42903, 42921, 2, 42927, 42933, 6, 42935, 42947, 2, 42952, 42954, 2, 42957, 42961, 4, 42963, 42971, 2, 42998, 43002, 4, 43824, 43866, 1, 43872, 43880, 1, 43888, 43967, 1, 64256, 64262, 1, 64275, 64279, 1, 65345, 65370, 1, 66600, 66639, 1, 66776, 66811, 1, 66967, 66977, 1, 66979, 66993, 1, 66995, 67001, 1, 67003, 67004, 1, 68800, 68850, 1, 68976, 68997, 1, 71872, 71903, 1, 93792, 93823, 1, 119834, 119859, 1, 119886, 119892, 1, 119894, 119911, 1, 119938, 119963, 1, 119990, 119993, 1, 119995, 119997, 2, 119998, 120003, 1, 120005, 120015, 1, 120042, 120067, 1, 120094, 120119, 1, 120146, 120171, 1, 120198, 120223, 1, 120250, 120275, 1, 120302, 120327, 1, 120354, 120379, 1, 120406, 120431, 1, 120458, 120485, 1, 120514, 120538, 1, 120540, 120545, 1, 120572, 120596, 1, 120598, 120603, 1, 120630, 120654, 1, 120656, 120661, 1, 120688, 120712, 1, 120714, 120719, 1, 120746, 120770, 1, 120772, 120777, 1, 120779, 122624, 1845, 122625, 122633, 1, 122635, 122654, 1, 122661, 122666, 1, 125218, 125251, 1]));
    static foldLl = new C(new Uint32Array([65, 90, 1, 192, 214, 1, 216, 222, 1, 256, 302, 2, 306, 310, 2, 313, 327, 2, 330, 376, 2, 377, 381, 2, 385, 386, 1, 388, 390, 2, 391, 393, 2, 394, 395, 1, 398, 401, 1, 403, 404, 1, 406, 408, 1, 412, 413, 1, 415, 416, 1, 418, 422, 2, 423, 425, 2, 428, 430, 2, 431, 433, 2, 434, 435, 1, 437, 439, 2, 440, 444, 4, 452, 453, 1, 455, 456, 1, 458, 459, 1, 461, 475, 2, 478, 494, 2, 497, 498, 1, 500, 502, 2, 503, 504, 1, 506, 562, 2, 570, 571, 1, 573, 574, 1, 577, 579, 2, 580, 582, 1, 584, 590, 2, 837, 880, 43, 882, 886, 4, 895, 902, 7, 904, 906, 1, 908, 910, 2, 911, 913, 2, 914, 929, 1, 931, 939, 1, 975, 984, 9, 986, 1006, 2, 1012, 1015, 3, 1017, 1018, 1, 1021, 1071, 1, 1120, 1152, 2, 1162, 1216, 2, 1217, 1229, 2, 1232, 1326, 2, 1329, 1366, 1, 4256, 4293, 1, 4295, 4301, 6, 5024, 5109, 1, 7305, 7312, 7, 7313, 7354, 1, 7357, 7359, 1, 7680, 7828, 2, 7838, 7934, 2, 7944, 7951, 1, 7960, 7965, 1, 7976, 7983, 1, 7992, 7999, 1, 8008, 8013, 1, 8025, 8031, 2, 8040, 8047, 1, 8072, 8079, 1, 8088, 8095, 1, 8104, 8111, 1, 8120, 8124, 1, 8136, 8140, 1, 8152, 8155, 1, 8168, 8172, 1, 8184, 8188, 1, 8486, 8490, 4, 8491, 8498, 7, 8579, 11264, 2685, 11265, 11311, 1, 11360, 11362, 2, 11363, 11364, 1, 11367, 11373, 2, 11374, 11376, 1, 11378, 11381, 3, 11390, 11392, 1, 11394, 11490, 2, 11499, 11501, 2, 11506, 42560, 31054, 42562, 42604, 2, 42624, 42650, 2, 42786, 42798, 2, 42802, 42862, 2, 42873, 42877, 2, 42878, 42886, 2, 42891, 42893, 2, 42896, 42898, 2, 42902, 42922, 2, 42923, 42926, 1, 42928, 42932, 1, 42934, 42948, 2, 42949, 42951, 1, 42953, 42955, 2, 42956, 42960, 4, 42966, 42972, 2, 42997, 65313, 22316, 65314, 65338, 1, 66560, 66599, 1, 66736, 66771, 1, 66928, 66938, 1, 66940, 66954, 1, 66956, 66962, 1, 66964, 66965, 1, 68736, 68786, 1, 68944, 68965, 1, 71840, 71871, 1, 93760, 93791, 1, 125184, 125217, 1]));
    static Lm = new C(new Uint32Array([688, 705, 1, 710, 721, 1, 736, 740, 1, 748, 750, 2, 884, 890, 6, 1369, 1600, 231, 1765, 1766, 1, 2036, 2037, 1, 2042, 2074, 32, 2084, 2088, 4, 2249, 2417, 168, 3654, 3782, 128, 4348, 6103, 1755, 6211, 6823, 612, 7288, 7293, 1, 7468, 7530, 1, 7544, 7579, 35, 7580, 7615, 1, 8305, 8319, 14, 8336, 8348, 1, 11388, 11389, 1, 11631, 11823, 192, 12293, 12337, 44, 12338, 12341, 1, 12347, 12445, 98, 12446, 12540, 94, 12541, 12542, 1, 40981, 42232, 1251, 42233, 42237, 1, 42508, 42623, 115, 42652, 42653, 1, 42775, 42783, 1, 42864, 42888, 24, 42994, 42996, 1, 43e3, 43001, 1, 43471, 43494, 23, 43632, 43741, 109, 43763, 43764, 1, 43868, 43871, 1, 43881, 65392, 21511, 65438, 65439, 1, 67456, 67461, 1, 67463, 67504, 1, 67506, 67514, 1, 68942, 68975, 33, 92992, 92995, 1, 93504, 93506, 1, 93547, 93548, 1, 94099, 94111, 1, 94176, 94177, 1, 94179, 110576, 16397, 110577, 110579, 1, 110581, 110587, 1, 110589, 110590, 1, 122928, 122989, 1, 123191, 123197, 1, 124139, 125259, 1120]));
    static Lo = new C(new Uint32Array([170, 186, 16, 443, 448, 5, 449, 451, 1, 660, 1488, 828, 1489, 1514, 1, 1519, 1522, 1, 1568, 1599, 1, 1601, 1610, 1, 1646, 1647, 1, 1649, 1747, 1, 1749, 1774, 25, 1775, 1786, 11, 1787, 1788, 1, 1791, 1808, 17, 1810, 1839, 1, 1869, 1957, 1, 1969, 1994, 25, 1995, 2026, 1, 2048, 2069, 1, 2112, 2136, 1, 2144, 2154, 1, 2160, 2183, 1, 2185, 2190, 1, 2208, 2248, 1, 2308, 2361, 1, 2365, 2384, 19, 2392, 2401, 1, 2418, 2432, 1, 2437, 2444, 1, 2447, 2448, 1, 2451, 2472, 1, 2474, 2480, 1, 2482, 2486, 4, 2487, 2489, 1, 2493, 2510, 17, 2524, 2525, 1, 2527, 2529, 1, 2544, 2545, 1, 2556, 2565, 9, 2566, 2570, 1, 2575, 2576, 1, 2579, 2600, 1, 2602, 2608, 1, 2610, 2611, 1, 2613, 2614, 1, 2616, 2617, 1, 2649, 2652, 1, 2654, 2674, 20, 2675, 2676, 1, 2693, 2701, 1, 2703, 2705, 1, 2707, 2728, 1, 2730, 2736, 1, 2738, 2739, 1, 2741, 2745, 1, 2749, 2768, 19, 2784, 2785, 1, 2809, 2821, 12, 2822, 2828, 1, 2831, 2832, 1, 2835, 2856, 1, 2858, 2864, 1, 2866, 2867, 1, 2869, 2873, 1, 2877, 2908, 31, 2909, 2911, 2, 2912, 2913, 1, 2929, 2947, 18, 2949, 2954, 1, 2958, 2960, 1, 2962, 2965, 1, 2969, 2970, 1, 2972, 2974, 2, 2975, 2979, 4, 2980, 2984, 4, 2985, 2986, 1, 2990, 3001, 1, 3024, 3077, 53, 3078, 3084, 1, 3086, 3088, 1, 3090, 3112, 1, 3114, 3129, 1, 3133, 3160, 27, 3161, 3162, 1, 3165, 3168, 3, 3169, 3200, 31, 3205, 3212, 1, 3214, 3216, 1, 3218, 3240, 1, 3242, 3251, 1, 3253, 3257, 1, 3261, 3293, 32, 3294, 3296, 2, 3297, 3313, 16, 3314, 3332, 18, 3333, 3340, 1, 3342, 3344, 1, 3346, 3386, 1, 3389, 3406, 17, 3412, 3414, 1, 3423, 3425, 1, 3450, 3455, 1, 3461, 3478, 1, 3482, 3505, 1, 3507, 3515, 1, 3517, 3520, 3, 3521, 3526, 1, 3585, 3632, 1, 3634, 3635, 1, 3648, 3653, 1, 3713, 3714, 1, 3716, 3718, 2, 3719, 3722, 1, 3724, 3747, 1, 3749, 3751, 2, 3752, 3760, 1, 3762, 3763, 1, 3773, 3776, 3, 3777, 3780, 1, 3804, 3807, 1, 3840, 3904, 64, 3905, 3911, 1, 3913, 3948, 1, 3976, 3980, 1, 4096, 4138, 1, 4159, 4176, 17, 4177, 4181, 1, 4186, 4189, 1, 4193, 4197, 4, 4198, 4206, 8, 4207, 4208, 1, 4213, 4225, 1, 4238, 4352, 114, 4353, 4680, 1, 4682, 4685, 1, 4688, 4694, 1, 4696, 4698, 2, 4699, 4701, 1, 4704, 4744, 1, 4746, 4749, 1, 4752, 4784, 1, 4786, 4789, 1, 4792, 4798, 1, 4800, 4802, 2, 4803, 4805, 1, 4808, 4822, 1, 4824, 4880, 1, 4882, 4885, 1, 4888, 4954, 1, 4992, 5007, 1, 5121, 5740, 1, 5743, 5759, 1, 5761, 5786, 1, 5792, 5866, 1, 5873, 5880, 1, 5888, 5905, 1, 5919, 5937, 1, 5952, 5969, 1, 5984, 5996, 1, 5998, 6e3, 1, 6016, 6067, 1, 6108, 6176, 68, 6177, 6210, 1, 6212, 6264, 1, 6272, 6276, 1, 6279, 6312, 1, 6314, 6320, 6, 6321, 6389, 1, 6400, 6430, 1, 6480, 6509, 1, 6512, 6516, 1, 6528, 6571, 1, 6576, 6601, 1, 6656, 6678, 1, 6688, 6740, 1, 6917, 6963, 1, 6981, 6988, 1, 7043, 7072, 1, 7086, 7087, 1, 7098, 7141, 1, 7168, 7203, 1, 7245, 7247, 1, 7258, 7287, 1, 7401, 7404, 1, 7406, 7411, 1, 7413, 7414, 1, 7418, 8501, 1083, 8502, 8504, 1, 11568, 11623, 1, 11648, 11670, 1, 11680, 11686, 1, 11688, 11694, 1, 11696, 11702, 1, 11704, 11710, 1, 11712, 11718, 1, 11720, 11726, 1, 11728, 11734, 1, 11736, 11742, 1, 12294, 12348, 54, 12353, 12438, 1, 12447, 12449, 2, 12450, 12538, 1, 12543, 12549, 6, 12550, 12591, 1, 12593, 12686, 1, 12704, 12735, 1, 12784, 12799, 1, 13312, 19903, 1, 19968, 40980, 1, 40982, 42124, 1, 42192, 42231, 1, 42240, 42507, 1, 42512, 42527, 1, 42538, 42539, 1, 42606, 42656, 50, 42657, 42725, 1, 42895, 42999, 104, 43003, 43009, 1, 43011, 43013, 1, 43015, 43018, 1, 43020, 43042, 1, 43072, 43123, 1, 43138, 43187, 1, 43250, 43255, 1, 43259, 43261, 2, 43262, 43274, 12, 43275, 43301, 1, 43312, 43334, 1, 43360, 43388, 1, 43396, 43442, 1, 43488, 43492, 1, 43495, 43503, 1, 43514, 43518, 1, 43520, 43560, 1, 43584, 43586, 1, 43588, 43595, 1, 43616, 43631, 1, 43633, 43638, 1, 43642, 43646, 4, 43647, 43695, 1, 43697, 43701, 4, 43702, 43705, 3, 43706, 43709, 1, 43712, 43714, 2, 43739, 43740, 1, 43744, 43754, 1, 43762, 43777, 15, 43778, 43782, 1, 43785, 43790, 1, 43793, 43798, 1, 43808, 43814, 1, 43816, 43822, 1, 43968, 44002, 1, 44032, 55203, 1, 55216, 55238, 1, 55243, 55291, 1, 63744, 64109, 1, 64112, 64217, 1, 64285, 64287, 2, 64288, 64296, 1, 64298, 64310, 1, 64312, 64316, 1, 64318, 64320, 2, 64321, 64323, 2, 64324, 64326, 2, 64327, 64433, 1, 64467, 64829, 1, 64848, 64911, 1, 64914, 64967, 1, 65008, 65019, 1, 65136, 65140, 1, 65142, 65276, 1, 65382, 65391, 1, 65393, 65437, 1, 65440, 65470, 1, 65474, 65479, 1, 65482, 65487, 1, 65490, 65495, 1, 65498, 65500, 1, 65536, 65547, 1, 65549, 65574, 1, 65576, 65594, 1, 65596, 65597, 1, 65599, 65613, 1, 65616, 65629, 1, 65664, 65786, 1, 66176, 66204, 1, 66208, 66256, 1, 66304, 66335, 1, 66349, 66368, 1, 66370, 66377, 1, 66384, 66421, 1, 66432, 66461, 1, 66464, 66499, 1, 66504, 66511, 1, 66640, 66717, 1, 66816, 66855, 1, 66864, 66915, 1, 67008, 67059, 1, 67072, 67382, 1, 67392, 67413, 1, 67424, 67431, 1, 67584, 67589, 1, 67592, 67594, 2, 67595, 67637, 1, 67639, 67640, 1, 67644, 67647, 3, 67648, 67669, 1, 67680, 67702, 1, 67712, 67742, 1, 67808, 67826, 1, 67828, 67829, 1, 67840, 67861, 1, 67872, 67897, 1, 67968, 68023, 1, 68030, 68031, 1, 68096, 68112, 16, 68113, 68115, 1, 68117, 68119, 1, 68121, 68149, 1, 68192, 68220, 1, 68224, 68252, 1, 68288, 68295, 1, 68297, 68324, 1, 68352, 68405, 1, 68416, 68437, 1, 68448, 68466, 1, 68480, 68497, 1, 68608, 68680, 1, 68864, 68899, 1, 68938, 68941, 1, 68943, 69248, 305, 69249, 69289, 1, 69296, 69297, 1, 69314, 69316, 1, 69376, 69404, 1, 69415, 69424, 9, 69425, 69445, 1, 69488, 69505, 1, 69552, 69572, 1, 69600, 69622, 1, 69635, 69687, 1, 69745, 69746, 1, 69749, 69763, 14, 69764, 69807, 1, 69840, 69864, 1, 69891, 69926, 1, 69956, 69959, 3, 69968, 70002, 1, 70006, 70019, 13, 70020, 70066, 1, 70081, 70084, 1, 70106, 70108, 2, 70144, 70161, 1, 70163, 70187, 1, 70207, 70208, 1, 70272, 70278, 1, 70280, 70282, 2, 70283, 70285, 1, 70287, 70301, 1, 70303, 70312, 1, 70320, 70366, 1, 70405, 70412, 1, 70415, 70416, 1, 70419, 70440, 1, 70442, 70448, 1, 70450, 70451, 1, 70453, 70457, 1, 70461, 70480, 19, 70493, 70497, 1, 70528, 70537, 1, 70539, 70542, 3, 70544, 70581, 1, 70583, 70609, 26, 70611, 70656, 45, 70657, 70708, 1, 70727, 70730, 1, 70751, 70753, 1, 70784, 70831, 1, 70852, 70853, 1, 70855, 71040, 185, 71041, 71086, 1, 71128, 71131, 1, 71168, 71215, 1, 71236, 71296, 60, 71297, 71338, 1, 71352, 71424, 72, 71425, 71450, 1, 71488, 71494, 1, 71680, 71723, 1, 71935, 71942, 1, 71945, 71948, 3, 71949, 71955, 1, 71957, 71958, 1, 71960, 71983, 1, 71999, 72001, 2, 72096, 72103, 1, 72106, 72144, 1, 72161, 72163, 2, 72192, 72203, 11, 72204, 72242, 1, 72250, 72272, 22, 72284, 72329, 1, 72349, 72368, 19, 72369, 72440, 1, 72640, 72672, 1, 72704, 72712, 1, 72714, 72750, 1, 72768, 72818, 50, 72819, 72847, 1, 72960, 72966, 1, 72968, 72969, 1, 72971, 73008, 1, 73030, 73056, 26, 73057, 73061, 1, 73063, 73064, 1, 73066, 73097, 1, 73112, 73440, 328, 73441, 73458, 1, 73474, 73476, 2, 73477, 73488, 1, 73490, 73523, 1, 73648, 73728, 80, 73729, 74649, 1, 74880, 75075, 1, 77712, 77808, 1, 77824, 78895, 1, 78913, 78918, 1, 78944, 82938, 1, 82944, 83526, 1, 90368, 90397, 1, 92160, 92728, 1, 92736, 92766, 1, 92784, 92862, 1, 92880, 92909, 1, 92928, 92975, 1, 93027, 93047, 1, 93053, 93071, 1, 93507, 93546, 1, 93952, 94026, 1, 94032, 94208, 176, 94209, 100343, 1, 100352, 101589, 1, 101631, 101640, 1, 110592, 110882, 1, 110898, 110928, 30, 110929, 110930, 1, 110933, 110948, 15, 110949, 110951, 1, 110960, 111355, 1, 113664, 113770, 1, 113776, 113788, 1, 113792, 113800, 1, 113808, 113817, 1, 122634, 123136, 502, 123137, 123180, 1, 123214, 123536, 322, 123537, 123565, 1, 123584, 123627, 1, 124112, 124138, 1, 124368, 124397, 1, 124400, 124896, 496, 124897, 124902, 1, 124904, 124907, 1, 124909, 124910, 1, 124912, 124926, 1, 124928, 125124, 1, 126464, 126467, 1, 126469, 126495, 1, 126497, 126498, 1, 126500, 126503, 3, 126505, 126514, 1, 126516, 126519, 1, 126521, 126523, 2, 126530, 126535, 5, 126537, 126541, 2, 126542, 126543, 1, 126545, 126546, 1, 126548, 126551, 3, 126553, 126561, 2, 126562, 126564, 2, 126567, 126570, 1, 126572, 126578, 1, 126580, 126583, 1, 126585, 126588, 1, 126590, 126592, 2, 126593, 126601, 1, 126603, 126619, 1, 126625, 126627, 1, 126629, 126633, 1, 126635, 126651, 1, 131072, 173791, 1, 173824, 177977, 1, 177984, 178205, 1, 178208, 183969, 1, 183984, 191456, 1, 191472, 192093, 1, 194560, 195101, 1, 196608, 201546, 1, 201552, 205743, 1]));
    static Lt = new C(new Uint32Array([453, 459, 3, 498, 8072, 7574, 8073, 8079, 1, 8088, 8095, 1, 8104, 8111, 1, 8124, 8140, 16, 8188, 8188, 1]));
    static foldLt = new C(new Uint32Array([452, 454, 2, 455, 457, 2, 458, 460, 2, 497, 499, 2, 8064, 8071, 1, 8080, 8087, 1, 8096, 8103, 1, 8115, 8131, 16, 8179, 8179, 1]));
    static Lu = new C(new Uint32Array([65, 90, 1, 192, 214, 1, 216, 222, 1, 256, 310, 2, 313, 327, 2, 330, 376, 2, 377, 381, 2, 385, 386, 1, 388, 390, 2, 391, 393, 2, 394, 395, 1, 398, 401, 1, 403, 404, 1, 406, 408, 1, 412, 413, 1, 415, 416, 1, 418, 422, 2, 423, 425, 2, 428, 430, 2, 431, 433, 2, 434, 435, 1, 437, 439, 2, 440, 444, 4, 452, 461, 3, 463, 475, 2, 478, 494, 2, 497, 500, 3, 502, 504, 1, 506, 562, 2, 570, 571, 1, 573, 574, 1, 577, 579, 2, 580, 582, 1, 584, 590, 2, 880, 882, 2, 886, 895, 9, 902, 904, 2, 905, 906, 1, 908, 910, 2, 911, 913, 2, 914, 929, 1, 931, 939, 1, 975, 978, 3, 979, 980, 1, 984, 1006, 2, 1012, 1015, 3, 1017, 1018, 1, 1021, 1071, 1, 1120, 1152, 2, 1162, 1216, 2, 1217, 1229, 2, 1232, 1326, 2, 1329, 1366, 1, 4256, 4293, 1, 4295, 4301, 6, 5024, 5109, 1, 7305, 7312, 7, 7313, 7354, 1, 7357, 7359, 1, 7680, 7828, 2, 7838, 7934, 2, 7944, 7951, 1, 7960, 7965, 1, 7976, 7983, 1, 7992, 7999, 1, 8008, 8013, 1, 8025, 8031, 2, 8040, 8047, 1, 8120, 8123, 1, 8136, 8139, 1, 8152, 8155, 1, 8168, 8172, 1, 8184, 8187, 1, 8450, 8455, 5, 8459, 8461, 1, 8464, 8466, 1, 8469, 8473, 4, 8474, 8477, 1, 8484, 8490, 2, 8491, 8493, 1, 8496, 8499, 1, 8510, 8511, 1, 8517, 8579, 62, 11264, 11311, 1, 11360, 11362, 2, 11363, 11364, 1, 11367, 11373, 2, 11374, 11376, 1, 11378, 11381, 3, 11390, 11392, 1, 11394, 11490, 2, 11499, 11501, 2, 11506, 42560, 31054, 42562, 42604, 2, 42624, 42650, 2, 42786, 42798, 2, 42802, 42862, 2, 42873, 42877, 2, 42878, 42886, 2, 42891, 42893, 2, 42896, 42898, 2, 42902, 42922, 2, 42923, 42926, 1, 42928, 42932, 1, 42934, 42948, 2, 42949, 42951, 1, 42953, 42955, 2, 42956, 42960, 4, 42966, 42972, 2, 42997, 65313, 22316, 65314, 65338, 1, 66560, 66599, 1, 66736, 66771, 1, 66928, 66938, 1, 66940, 66954, 1, 66956, 66962, 1, 66964, 66965, 1, 68736, 68786, 1, 68944, 68965, 1, 71840, 71871, 1, 93760, 93791, 1, 119808, 119833, 1, 119860, 119885, 1, 119912, 119937, 1, 119964, 119966, 2, 119967, 119973, 3, 119974, 119977, 3, 119978, 119980, 1, 119982, 119989, 1, 120016, 120041, 1, 120068, 120069, 1, 120071, 120074, 1, 120077, 120084, 1, 120086, 120092, 1, 120120, 120121, 1, 120123, 120126, 1, 120128, 120132, 1, 120134, 120138, 4, 120139, 120144, 1, 120172, 120197, 1, 120224, 120249, 1, 120276, 120301, 1, 120328, 120353, 1, 120380, 120405, 1, 120432, 120457, 1, 120488, 120512, 1, 120546, 120570, 1, 120604, 120628, 1, 120662, 120686, 1, 120720, 120744, 1, 120778, 125184, 4406, 125185, 125217, 1]));
    static Upper = this.Lu;
    static foldLu = new C(new Uint32Array([97, 122, 1, 181, 223, 42, 224, 246, 1, 248, 255, 1, 257, 303, 2, 307, 311, 2, 314, 328, 2, 331, 375, 2, 378, 382, 2, 383, 384, 1, 387, 389, 2, 392, 396, 4, 402, 405, 3, 409, 411, 1, 414, 417, 3, 419, 421, 2, 424, 429, 5, 432, 436, 4, 438, 441, 3, 445, 447, 2, 453, 454, 1, 456, 457, 1, 459, 460, 1, 462, 476, 2, 477, 495, 2, 498, 499, 1, 501, 505, 4, 507, 543, 2, 547, 563, 2, 572, 575, 3, 576, 578, 2, 583, 591, 2, 592, 596, 1, 598, 599, 1, 601, 603, 2, 604, 608, 4, 609, 611, 2, 612, 614, 1, 616, 620, 1, 623, 625, 2, 626, 629, 3, 637, 640, 3, 642, 643, 1, 647, 652, 1, 658, 669, 11, 670, 837, 167, 881, 883, 2, 887, 891, 4, 892, 893, 1, 940, 943, 1, 945, 974, 1, 976, 977, 1, 981, 983, 1, 985, 1007, 2, 1008, 1011, 1, 1013, 1019, 3, 1072, 1119, 1, 1121, 1153, 2, 1163, 1215, 2, 1218, 1230, 2, 1231, 1327, 2, 1377, 1414, 1, 4304, 4346, 1, 4349, 4351, 1, 5112, 5117, 1, 7296, 7304, 1, 7306, 7545, 239, 7549, 7566, 17, 7681, 7829, 2, 7835, 7841, 6, 7843, 7935, 2, 7936, 7943, 1, 7952, 7957, 1, 7968, 7975, 1, 7984, 7991, 1, 8e3, 8005, 1, 8017, 8023, 2, 8032, 8039, 1, 8048, 8061, 1, 8112, 8113, 1, 8126, 8144, 18, 8145, 8160, 15, 8161, 8165, 4, 8526, 8580, 54, 11312, 11359, 1, 11361, 11365, 4, 11366, 11372, 2, 11379, 11382, 3, 11393, 11491, 2, 11500, 11502, 2, 11507, 11520, 13, 11521, 11557, 1, 11559, 11565, 6, 42561, 42605, 2, 42625, 42651, 2, 42787, 42799, 2, 42803, 42863, 2, 42874, 42876, 2, 42879, 42887, 2, 42892, 42897, 5, 42899, 42900, 1, 42903, 42921, 2, 42933, 42947, 2, 42952, 42954, 2, 42957, 42961, 4, 42967, 42971, 2, 42998, 43859, 861, 43888, 43967, 1, 65345, 65370, 1, 66600, 66639, 1, 66776, 66811, 1, 66967, 66977, 1, 66979, 66993, 1, 66995, 67001, 1, 67003, 67004, 1, 68800, 68850, 1, 68976, 68997, 1, 71872, 71903, 1, 93792, 93823, 1, 125218, 125251, 1]));
    static M = new C(new Uint32Array([768, 879, 1, 1155, 1161, 1, 1425, 1469, 1, 1471, 1473, 2, 1474, 1476, 2, 1477, 1479, 2, 1552, 1562, 1, 1611, 1631, 1, 1648, 1750, 102, 1751, 1756, 1, 1759, 1764, 1, 1767, 1768, 1, 1770, 1773, 1, 1809, 1840, 31, 1841, 1866, 1, 1958, 1968, 1, 2027, 2035, 1, 2045, 2070, 25, 2071, 2073, 1, 2075, 2083, 1, 2085, 2087, 1, 2089, 2093, 1, 2137, 2139, 1, 2199, 2207, 1, 2250, 2273, 1, 2275, 2307, 1, 2362, 2364, 1, 2366, 2383, 1, 2385, 2391, 1, 2402, 2403, 1, 2433, 2435, 1, 2492, 2494, 2, 2495, 2500, 1, 2503, 2504, 1, 2507, 2509, 1, 2519, 2530, 11, 2531, 2558, 27, 2561, 2563, 1, 2620, 2622, 2, 2623, 2626, 1, 2631, 2632, 1, 2635, 2637, 1, 2641, 2672, 31, 2673, 2677, 4, 2689, 2691, 1, 2748, 2750, 2, 2751, 2757, 1, 2759, 2761, 1, 2763, 2765, 1, 2786, 2787, 1, 2810, 2815, 1, 2817, 2819, 1, 2876, 2878, 2, 2879, 2884, 1, 2887, 2888, 1, 2891, 2893, 1, 2901, 2903, 1, 2914, 2915, 1, 2946, 3006, 60, 3007, 3010, 1, 3014, 3016, 1, 3018, 3021, 1, 3031, 3072, 41, 3073, 3076, 1, 3132, 3134, 2, 3135, 3140, 1, 3142, 3144, 1, 3146, 3149, 1, 3157, 3158, 1, 3170, 3171, 1, 3201, 3203, 1, 3260, 3262, 2, 3263, 3268, 1, 3270, 3272, 1, 3274, 3277, 1, 3285, 3286, 1, 3298, 3299, 1, 3315, 3328, 13, 3329, 3331, 1, 3387, 3388, 1, 3390, 3396, 1, 3398, 3400, 1, 3402, 3405, 1, 3415, 3426, 11, 3427, 3457, 30, 3458, 3459, 1, 3530, 3535, 5, 3536, 3540, 1, 3542, 3544, 2, 3545, 3551, 1, 3570, 3571, 1, 3633, 3636, 3, 3637, 3642, 1, 3655, 3662, 1, 3761, 3764, 3, 3765, 3772, 1, 3784, 3790, 1, 3864, 3865, 1, 3893, 3897, 2, 3902, 3903, 1, 3953, 3972, 1, 3974, 3975, 1, 3981, 3991, 1, 3993, 4028, 1, 4038, 4139, 101, 4140, 4158, 1, 4182, 4185, 1, 4190, 4192, 1, 4194, 4196, 1, 4199, 4205, 1, 4209, 4212, 1, 4226, 4237, 1, 4239, 4250, 11, 4251, 4253, 1, 4957, 4959, 1, 5906, 5909, 1, 5938, 5940, 1, 5970, 5971, 1, 6002, 6003, 1, 6068, 6099, 1, 6109, 6155, 46, 6156, 6157, 1, 6159, 6277, 118, 6278, 6313, 35, 6432, 6443, 1, 6448, 6459, 1, 6679, 6683, 1, 6741, 6750, 1, 6752, 6780, 1, 6783, 6832, 49, 6833, 6862, 1, 6912, 6916, 1, 6964, 6980, 1, 7019, 7027, 1, 7040, 7042, 1, 7073, 7085, 1, 7142, 7155, 1, 7204, 7223, 1, 7376, 7378, 1, 7380, 7400, 1, 7405, 7412, 7, 7415, 7417, 1, 7616, 7679, 1, 8400, 8432, 1, 11503, 11505, 1, 11647, 11744, 97, 11745, 11775, 1, 12330, 12335, 1, 12441, 12442, 1, 42607, 42610, 1, 42612, 42621, 1, 42654, 42655, 1, 42736, 42737, 1, 43010, 43014, 4, 43019, 43043, 24, 43044, 43047, 1, 43052, 43136, 84, 43137, 43188, 51, 43189, 43205, 1, 43232, 43249, 1, 43263, 43302, 39, 43303, 43309, 1, 43335, 43347, 1, 43392, 43395, 1, 43443, 43456, 1, 43493, 43561, 68, 43562, 43574, 1, 43587, 43596, 9, 43597, 43643, 46, 43644, 43645, 1, 43696, 43698, 2, 43699, 43700, 1, 43703, 43704, 1, 43710, 43711, 1, 43713, 43755, 42, 43756, 43759, 1, 43765, 43766, 1, 44003, 44010, 1, 44012, 44013, 1, 64286, 65024, 738, 65025, 65039, 1, 65056, 65071, 1, 66045, 66272, 227, 66422, 66426, 1, 68097, 68099, 1, 68101, 68102, 1, 68108, 68111, 1, 68152, 68154, 1, 68159, 68325, 166, 68326, 68900, 574, 68901, 68903, 1, 68969, 68973, 1, 69291, 69292, 1, 69372, 69375, 1, 69446, 69456, 1, 69506, 69509, 1, 69632, 69634, 1, 69688, 69702, 1, 69744, 69747, 3, 69748, 69759, 11, 69760, 69762, 1, 69808, 69818, 1, 69826, 69888, 62, 69889, 69890, 1, 69927, 69940, 1, 69957, 69958, 1, 70003, 70016, 13, 70017, 70018, 1, 70067, 70080, 1, 70089, 70092, 1, 70094, 70095, 1, 70188, 70199, 1, 70206, 70209, 3, 70367, 70378, 1, 70400, 70403, 1, 70459, 70460, 1, 70462, 70468, 1, 70471, 70472, 1, 70475, 70477, 1, 70487, 70498, 11, 70499, 70502, 3, 70503, 70508, 1, 70512, 70516, 1, 70584, 70592, 1, 70594, 70597, 3, 70599, 70602, 1, 70604, 70608, 1, 70610, 70625, 15, 70626, 70709, 83, 70710, 70726, 1, 70750, 70832, 82, 70833, 70851, 1, 71087, 71093, 1, 71096, 71104, 1, 71132, 71133, 1, 71216, 71232, 1, 71339, 71351, 1, 71453, 71467, 1, 71724, 71738, 1, 71984, 71989, 1, 71991, 71992, 1, 71995, 71998, 1, 72e3, 72002, 2, 72003, 72145, 142, 72146, 72151, 1, 72154, 72160, 1, 72164, 72193, 29, 72194, 72202, 1, 72243, 72249, 1, 72251, 72254, 1, 72263, 72273, 10, 72274, 72283, 1, 72330, 72345, 1, 72751, 72758, 1, 72760, 72767, 1, 72850, 72871, 1, 72873, 72886, 1, 73009, 73014, 1, 73018, 73020, 2, 73021, 73023, 2, 73024, 73029, 1, 73031, 73098, 67, 73099, 73102, 1, 73104, 73105, 1, 73107, 73111, 1, 73459, 73462, 1, 73472, 73473, 1, 73475, 73524, 49, 73525, 73530, 1, 73534, 73538, 1, 73562, 78912, 5350, 78919, 78933, 1, 90398, 90415, 1, 92912, 92916, 1, 92976, 92982, 1, 94031, 94033, 2, 94034, 94087, 1, 94095, 94098, 1, 94180, 94192, 12, 94193, 113821, 19628, 113822, 118528, 4706, 118529, 118573, 1, 118576, 118598, 1, 119141, 119145, 1, 119149, 119154, 1, 119163, 119170, 1, 119173, 119179, 1, 119210, 119213, 1, 119362, 119364, 1, 121344, 121398, 1, 121403, 121452, 1, 121461, 121476, 15, 121499, 121503, 1, 121505, 121519, 1, 122880, 122886, 1, 122888, 122904, 1, 122907, 122913, 1, 122915, 122916, 1, 122918, 122922, 1, 123023, 123184, 161, 123185, 123190, 1, 123566, 123628, 62, 123629, 123631, 1, 124140, 124143, 1, 124398, 124399, 1, 125136, 125142, 1, 125252, 125258, 1, 917760, 917999, 1]));
    static foldM = new C(new Uint32Array([921, 953, 32, 8126, 8126, 1]));
    static Mc = new C(new Uint32Array([2307, 2363, 56, 2366, 2368, 1, 2377, 2380, 1, 2382, 2383, 1, 2434, 2435, 1, 2494, 2496, 1, 2503, 2504, 1, 2507, 2508, 1, 2519, 2563, 44, 2622, 2624, 1, 2691, 2750, 59, 2751, 2752, 1, 2761, 2763, 2, 2764, 2818, 54, 2819, 2878, 59, 2880, 2887, 7, 2888, 2891, 3, 2892, 2903, 11, 3006, 3007, 1, 3009, 3010, 1, 3014, 3016, 1, 3018, 3020, 1, 3031, 3073, 42, 3074, 3075, 1, 3137, 3140, 1, 3202, 3203, 1, 3262, 3264, 2, 3265, 3268, 1, 3271, 3272, 1, 3274, 3275, 1, 3285, 3286, 1, 3315, 3330, 15, 3331, 3390, 59, 3391, 3392, 1, 3398, 3400, 1, 3402, 3404, 1, 3415, 3458, 43, 3459, 3535, 76, 3536, 3537, 1, 3544, 3551, 1, 3570, 3571, 1, 3902, 3903, 1, 3967, 4139, 172, 4140, 4145, 5, 4152, 4155, 3, 4156, 4182, 26, 4183, 4194, 11, 4195, 4196, 1, 4199, 4205, 1, 4227, 4228, 1, 4231, 4236, 1, 4239, 4250, 11, 4251, 4252, 1, 5909, 5940, 31, 6070, 6078, 8, 6079, 6085, 1, 6087, 6088, 1, 6435, 6438, 1, 6441, 6443, 1, 6448, 6449, 1, 6451, 6456, 1, 6681, 6682, 1, 6741, 6743, 2, 6753, 6755, 2, 6756, 6765, 9, 6766, 6770, 1, 6916, 6965, 49, 6971, 6973, 2, 6974, 6977, 1, 6979, 6980, 1, 7042, 7073, 31, 7078, 7079, 1, 7082, 7143, 61, 7146, 7148, 1, 7150, 7154, 4, 7155, 7204, 49, 7205, 7211, 1, 7220, 7221, 1, 7393, 7415, 22, 12334, 12335, 1, 43043, 43044, 1, 43047, 43136, 89, 43137, 43188, 51, 43189, 43203, 1, 43346, 43347, 1, 43395, 43444, 49, 43445, 43450, 5, 43451, 43454, 3, 43455, 43456, 1, 43567, 43568, 1, 43571, 43572, 1, 43597, 43643, 46, 43645, 43755, 110, 43758, 43759, 1, 43765, 44003, 238, 44004, 44006, 2, 44007, 44009, 2, 44010, 44012, 2, 69632, 69634, 2, 69762, 69808, 46, 69809, 69810, 1, 69815, 69816, 1, 69932, 69957, 25, 69958, 70018, 60, 70067, 70069, 1, 70079, 70080, 1, 70094, 70188, 94, 70189, 70190, 1, 70194, 70195, 1, 70197, 70368, 171, 70369, 70370, 1, 70402, 70403, 1, 70462, 70463, 1, 70465, 70468, 1, 70471, 70472, 1, 70475, 70477, 1, 70487, 70498, 11, 70499, 70584, 85, 70585, 70586, 1, 70594, 70597, 3, 70599, 70602, 1, 70604, 70605, 1, 70607, 70709, 102, 70710, 70711, 1, 70720, 70721, 1, 70725, 70832, 107, 70833, 70834, 1, 70841, 70843, 2, 70844, 70846, 1, 70849, 71087, 238, 71088, 71089, 1, 71096, 71099, 1, 71102, 71216, 114, 71217, 71218, 1, 71227, 71228, 1, 71230, 71340, 110, 71342, 71343, 1, 71350, 71454, 104, 71456, 71457, 1, 71462, 71724, 262, 71725, 71726, 1, 71736, 71984, 248, 71985, 71989, 1, 71991, 71992, 1, 71997, 72e3, 3, 72002, 72145, 143, 72146, 72147, 1, 72156, 72159, 1, 72164, 72249, 85, 72279, 72280, 1, 72343, 72751, 408, 72766, 72873, 107, 72881, 72884, 3, 73098, 73102, 1, 73107, 73108, 1, 73110, 73461, 351, 73462, 73475, 13, 73524, 73525, 1, 73534, 73535, 1, 73537, 90410, 16873, 90411, 90412, 1, 94033, 94087, 1, 94192, 94193, 1, 119141, 119142, 1, 119149, 119154, 1]));
    static Me = new C(new Uint32Array([1160, 1161, 1, 6846, 8413, 1567, 8414, 8416, 1, 8418, 8420, 1, 42608, 42610, 1]));
    static Mn = new C(new Uint32Array([768, 879, 1, 1155, 1159, 1, 1425, 1469, 1, 1471, 1473, 2, 1474, 1476, 2, 1477, 1479, 2, 1552, 1562, 1, 1611, 1631, 1, 1648, 1750, 102, 1751, 1756, 1, 1759, 1764, 1, 1767, 1768, 1, 1770, 1773, 1, 1809, 1840, 31, 1841, 1866, 1, 1958, 1968, 1, 2027, 2035, 1, 2045, 2070, 25, 2071, 2073, 1, 2075, 2083, 1, 2085, 2087, 1, 2089, 2093, 1, 2137, 2139, 1, 2199, 2207, 1, 2250, 2273, 1, 2275, 2306, 1, 2362, 2364, 2, 2369, 2376, 1, 2381, 2385, 4, 2386, 2391, 1, 2402, 2403, 1, 2433, 2492, 59, 2497, 2500, 1, 2509, 2530, 21, 2531, 2558, 27, 2561, 2562, 1, 2620, 2625, 5, 2626, 2631, 5, 2632, 2635, 3, 2636, 2637, 1, 2641, 2672, 31, 2673, 2677, 4, 2689, 2690, 1, 2748, 2753, 5, 2754, 2757, 1, 2759, 2760, 1, 2765, 2786, 21, 2787, 2810, 23, 2811, 2815, 1, 2817, 2876, 59, 2879, 2881, 2, 2882, 2884, 1, 2893, 2901, 8, 2902, 2914, 12, 2915, 2946, 31, 3008, 3021, 13, 3072, 3076, 4, 3132, 3134, 2, 3135, 3136, 1, 3142, 3144, 1, 3146, 3149, 1, 3157, 3158, 1, 3170, 3171, 1, 3201, 3260, 59, 3263, 3270, 7, 3276, 3277, 1, 3298, 3299, 1, 3328, 3329, 1, 3387, 3388, 1, 3393, 3396, 1, 3405, 3426, 21, 3427, 3457, 30, 3530, 3538, 8, 3539, 3540, 1, 3542, 3633, 91, 3636, 3642, 1, 3655, 3662, 1, 3761, 3764, 3, 3765, 3772, 1, 3784, 3790, 1, 3864, 3865, 1, 3893, 3897, 2, 3953, 3966, 1, 3968, 3972, 1, 3974, 3975, 1, 3981, 3991, 1, 3993, 4028, 1, 4038, 4141, 103, 4142, 4144, 1, 4146, 4151, 1, 4153, 4154, 1, 4157, 4158, 1, 4184, 4185, 1, 4190, 4192, 1, 4209, 4212, 1, 4226, 4229, 3, 4230, 4237, 7, 4253, 4957, 704, 4958, 4959, 1, 5906, 5908, 1, 5938, 5939, 1, 5970, 5971, 1, 6002, 6003, 1, 6068, 6069, 1, 6071, 6077, 1, 6086, 6089, 3, 6090, 6099, 1, 6109, 6155, 46, 6156, 6157, 1, 6159, 6277, 118, 6278, 6313, 35, 6432, 6434, 1, 6439, 6440, 1, 6450, 6457, 7, 6458, 6459, 1, 6679, 6680, 1, 6683, 6742, 59, 6744, 6750, 1, 6752, 6754, 2, 6757, 6764, 1, 6771, 6780, 1, 6783, 6832, 49, 6833, 6845, 1, 6847, 6862, 1, 6912, 6915, 1, 6964, 6966, 2, 6967, 6970, 1, 6972, 6978, 6, 7019, 7027, 1, 7040, 7041, 1, 7074, 7077, 1, 7080, 7081, 1, 7083, 7085, 1, 7142, 7144, 2, 7145, 7149, 4, 7151, 7153, 1, 7212, 7219, 1, 7222, 7223, 1, 7376, 7378, 1, 7380, 7392, 1, 7394, 7400, 1, 7405, 7412, 7, 7416, 7417, 1, 7616, 7679, 1, 8400, 8412, 1, 8417, 8421, 4, 8422, 8432, 1, 11503, 11505, 1, 11647, 11744, 97, 11745, 11775, 1, 12330, 12333, 1, 12441, 12442, 1, 42607, 42612, 5, 42613, 42621, 1, 42654, 42655, 1, 42736, 42737, 1, 43010, 43014, 4, 43019, 43045, 26, 43046, 43052, 6, 43204, 43205, 1, 43232, 43249, 1, 43263, 43302, 39, 43303, 43309, 1, 43335, 43345, 1, 43392, 43394, 1, 43443, 43446, 3, 43447, 43449, 1, 43452, 43453, 1, 43493, 43561, 68, 43562, 43566, 1, 43569, 43570, 1, 43573, 43574, 1, 43587, 43596, 9, 43644, 43696, 52, 43698, 43700, 1, 43703, 43704, 1, 43710, 43711, 1, 43713, 43756, 43, 43757, 43766, 9, 44005, 44008, 3, 44013, 64286, 20273, 65024, 65039, 1, 65056, 65071, 1, 66045, 66272, 227, 66422, 66426, 1, 68097, 68099, 1, 68101, 68102, 1, 68108, 68111, 1, 68152, 68154, 1, 68159, 68325, 166, 68326, 68900, 574, 68901, 68903, 1, 68969, 68973, 1, 69291, 69292, 1, 69372, 69375, 1, 69446, 69456, 1, 69506, 69509, 1, 69633, 69688, 55, 69689, 69702, 1, 69744, 69747, 3, 69748, 69759, 11, 69760, 69761, 1, 69811, 69814, 1, 69817, 69818, 1, 69826, 69888, 62, 69889, 69890, 1, 69927, 69931, 1, 69933, 69940, 1, 70003, 70016, 13, 70017, 70070, 53, 70071, 70078, 1, 70089, 70092, 1, 70095, 70191, 96, 70192, 70193, 1, 70196, 70198, 2, 70199, 70206, 7, 70209, 70367, 158, 70371, 70378, 1, 70400, 70401, 1, 70459, 70460, 1, 70464, 70502, 38, 70503, 70508, 1, 70512, 70516, 1, 70587, 70592, 1, 70606, 70610, 2, 70625, 70626, 1, 70712, 70719, 1, 70722, 70724, 1, 70726, 70750, 24, 70835, 70840, 1, 70842, 70847, 5, 70848, 70850, 2, 70851, 71090, 239, 71091, 71093, 1, 71100, 71101, 1, 71103, 71104, 1, 71132, 71133, 1, 71219, 71226, 1, 71229, 71231, 2, 71232, 71339, 107, 71341, 71344, 3, 71345, 71349, 1, 71351, 71453, 102, 71455, 71458, 3, 71459, 71461, 1, 71463, 71467, 1, 71727, 71735, 1, 71737, 71738, 1, 71995, 71996, 1, 71998, 72003, 5, 72148, 72151, 1, 72154, 72155, 1, 72160, 72193, 33, 72194, 72202, 1, 72243, 72248, 1, 72251, 72254, 1, 72263, 72273, 10, 72274, 72278, 1, 72281, 72283, 1, 72330, 72342, 1, 72344, 72345, 1, 72752, 72758, 1, 72760, 72765, 1, 72767, 72850, 83, 72851, 72871, 1, 72874, 72880, 1, 72882, 72883, 1, 72885, 72886, 1, 73009, 73014, 1, 73018, 73020, 2, 73021, 73023, 2, 73024, 73029, 1, 73031, 73104, 73, 73105, 73109, 4, 73111, 73459, 348, 73460, 73472, 12, 73473, 73526, 53, 73527, 73530, 1, 73536, 73538, 2, 73562, 78912, 5350, 78919, 78933, 1, 90398, 90409, 1, 90413, 90415, 1, 92912, 92916, 1, 92976, 92982, 1, 94031, 94095, 64, 94096, 94098, 1, 94180, 113821, 19641, 113822, 118528, 4706, 118529, 118573, 1, 118576, 118598, 1, 119143, 119145, 1, 119163, 119170, 1, 119173, 119179, 1, 119210, 119213, 1, 119362, 119364, 1, 121344, 121398, 1, 121403, 121452, 1, 121461, 121476, 15, 121499, 121503, 1, 121505, 121519, 1, 122880, 122886, 1, 122888, 122904, 1, 122907, 122913, 1, 122915, 122916, 1, 122918, 122922, 1, 123023, 123184, 161, 123185, 123190, 1, 123566, 123628, 62, 123629, 123631, 1, 124140, 124143, 1, 124398, 124399, 1, 125136, 125142, 1, 125252, 125258, 1, 917760, 917999, 1]));
    static foldMn = new C(new Uint32Array([921, 953, 32, 8126, 8126, 1]));
    static N = new C(new Uint32Array([48, 57, 1, 178, 179, 1, 185, 188, 3, 189, 190, 1, 1632, 1641, 1, 1776, 1785, 1, 1984, 1993, 1, 2406, 2415, 1, 2534, 2543, 1, 2548, 2553, 1, 2662, 2671, 1, 2790, 2799, 1, 2918, 2927, 1, 2930, 2935, 1, 3046, 3058, 1, 3174, 3183, 1, 3192, 3198, 1, 3302, 3311, 1, 3416, 3422, 1, 3430, 3448, 1, 3558, 3567, 1, 3664, 3673, 1, 3792, 3801, 1, 3872, 3891, 1, 4160, 4169, 1, 4240, 4249, 1, 4969, 4988, 1, 5870, 5872, 1, 6112, 6121, 1, 6128, 6137, 1, 6160, 6169, 1, 6470, 6479, 1, 6608, 6618, 1, 6784, 6793, 1, 6800, 6809, 1, 6992, 7001, 1, 7088, 7097, 1, 7232, 7241, 1, 7248, 7257, 1, 8304, 8308, 4, 8309, 8313, 1, 8320, 8329, 1, 8528, 8578, 1, 8581, 8585, 1, 9312, 9371, 1, 9450, 9471, 1, 10102, 10131, 1, 11517, 12295, 778, 12321, 12329, 1, 12344, 12346, 1, 12690, 12693, 1, 12832, 12841, 1, 12872, 12879, 1, 12881, 12895, 1, 12928, 12937, 1, 12977, 12991, 1, 42528, 42537, 1, 42726, 42735, 1, 43056, 43061, 1, 43216, 43225, 1, 43264, 43273, 1, 43472, 43481, 1, 43504, 43513, 1, 43600, 43609, 1, 44016, 44025, 1, 65296, 65305, 1, 65799, 65843, 1, 65856, 65912, 1, 65930, 65931, 1, 66273, 66299, 1, 66336, 66339, 1, 66369, 66378, 9, 66513, 66517, 1, 66720, 66729, 1, 67672, 67679, 1, 67705, 67711, 1, 67751, 67759, 1, 67835, 67839, 1, 67862, 67867, 1, 68028, 68029, 1, 68032, 68047, 1, 68050, 68095, 1, 68160, 68168, 1, 68221, 68222, 1, 68253, 68255, 1, 68331, 68335, 1, 68440, 68447, 1, 68472, 68479, 1, 68521, 68527, 1, 68858, 68863, 1, 68912, 68921, 1, 68928, 68937, 1, 69216, 69246, 1, 69405, 69414, 1, 69457, 69460, 1, 69573, 69579, 1, 69714, 69743, 1, 69872, 69881, 1, 69942, 69951, 1, 70096, 70105, 1, 70113, 70132, 1, 70384, 70393, 1, 70736, 70745, 1, 70864, 70873, 1, 71248, 71257, 1, 71360, 71369, 1, 71376, 71395, 1, 71472, 71483, 1, 71904, 71922, 1, 72016, 72025, 1, 72688, 72697, 1, 72784, 72812, 1, 73040, 73049, 1, 73120, 73129, 1, 73552, 73561, 1, 73664, 73684, 1, 74752, 74862, 1, 90416, 90425, 1, 92768, 92777, 1, 92864, 92873, 1, 93008, 93017, 1, 93019, 93025, 1, 93552, 93561, 1, 93824, 93846, 1, 118e3, 118009, 1, 119488, 119507, 1, 119520, 119539, 1, 119648, 119672, 1, 120782, 120831, 1, 123200, 123209, 1, 123632, 123641, 1, 124144, 124153, 1, 124401, 124410, 1, 125127, 125135, 1, 125264, 125273, 1, 126065, 126123, 1, 126125, 126127, 1, 126129, 126132, 1, 126209, 126253, 1, 126255, 126269, 1, 127232, 127244, 1, 130032, 130041, 1]));
    static Nd = new C(new Uint32Array([48, 57, 1, 1632, 1641, 1, 1776, 1785, 1, 1984, 1993, 1, 2406, 2415, 1, 2534, 2543, 1, 2662, 2671, 1, 2790, 2799, 1, 2918, 2927, 1, 3046, 3055, 1, 3174, 3183, 1, 3302, 3311, 1, 3430, 3439, 1, 3558, 3567, 1, 3664, 3673, 1, 3792, 3801, 1, 3872, 3881, 1, 4160, 4169, 1, 4240, 4249, 1, 6112, 6121, 1, 6160, 6169, 1, 6470, 6479, 1, 6608, 6617, 1, 6784, 6793, 1, 6800, 6809, 1, 6992, 7001, 1, 7088, 7097, 1, 7232, 7241, 1, 7248, 7257, 1, 42528, 42537, 1, 43216, 43225, 1, 43264, 43273, 1, 43472, 43481, 1, 43504, 43513, 1, 43600, 43609, 1, 44016, 44025, 1, 65296, 65305, 1, 66720, 66729, 1, 68912, 68921, 1, 68928, 68937, 1, 69734, 69743, 1, 69872, 69881, 1, 69942, 69951, 1, 70096, 70105, 1, 70384, 70393, 1, 70736, 70745, 1, 70864, 70873, 1, 71248, 71257, 1, 71360, 71369, 1, 71376, 71395, 1, 71472, 71481, 1, 71904, 71913, 1, 72016, 72025, 1, 72688, 72697, 1, 72784, 72793, 1, 73040, 73049, 1, 73120, 73129, 1, 73552, 73561, 1, 90416, 90425, 1, 92768, 92777, 1, 92864, 92873, 1, 93008, 93017, 1, 93552, 93561, 1, 118e3, 118009, 1, 120782, 120831, 1, 123200, 123209, 1, 123632, 123641, 1, 124144, 124153, 1, 124401, 124410, 1, 125264, 125273, 1, 130032, 130041, 1]));
    static Nl = new C(new Uint32Array([5870, 5872, 1, 8544, 8578, 1, 8581, 8584, 1, 12295, 12321, 26, 12322, 12329, 1, 12344, 12346, 1, 42726, 42735, 1, 65856, 65908, 1, 66369, 66378, 9, 66513, 66517, 1, 74752, 74862, 1]));
    static No = new C(new Uint32Array([178, 179, 1, 185, 188, 3, 189, 190, 1, 2548, 2553, 1, 2930, 2935, 1, 3056, 3058, 1, 3192, 3198, 1, 3416, 3422, 1, 3440, 3448, 1, 3882, 3891, 1, 4969, 4988, 1, 6128, 6137, 1, 6618, 8304, 1686, 8308, 8313, 1, 8320, 8329, 1, 8528, 8543, 1, 8585, 9312, 727, 9313, 9371, 1, 9450, 9471, 1, 10102, 10131, 1, 11517, 12690, 1173, 12691, 12693, 1, 12832, 12841, 1, 12872, 12879, 1, 12881, 12895, 1, 12928, 12937, 1, 12977, 12991, 1, 43056, 43061, 1, 65799, 65843, 1, 65909, 65912, 1, 65930, 65931, 1, 66273, 66299, 1, 66336, 66339, 1, 67672, 67679, 1, 67705, 67711, 1, 67751, 67759, 1, 67835, 67839, 1, 67862, 67867, 1, 68028, 68029, 1, 68032, 68047, 1, 68050, 68095, 1, 68160, 68168, 1, 68221, 68222, 1, 68253, 68255, 1, 68331, 68335, 1, 68440, 68447, 1, 68472, 68479, 1, 68521, 68527, 1, 68858, 68863, 1, 69216, 69246, 1, 69405, 69414, 1, 69457, 69460, 1, 69573, 69579, 1, 69714, 69733, 1, 70113, 70132, 1, 71482, 71483, 1, 71914, 71922, 1, 72794, 72812, 1, 73664, 73684, 1, 93019, 93025, 1, 93824, 93846, 1, 119488, 119507, 1, 119520, 119539, 1, 119648, 119672, 1, 125127, 125135, 1, 126065, 126123, 1, 126125, 126127, 1, 126129, 126132, 1, 126209, 126253, 1, 126255, 126269, 1, 127232, 127244, 1]));
    static P = new C(new Uint32Array([33, 35, 1, 37, 42, 1, 44, 47, 1, 58, 59, 1, 63, 64, 1, 91, 93, 1, 95, 123, 28, 125, 161, 36, 167, 171, 4, 182, 183, 1, 187, 191, 4, 894, 903, 9, 1370, 1375, 1, 1417, 1418, 1, 1470, 1472, 2, 1475, 1478, 3, 1523, 1524, 1, 1545, 1546, 1, 1548, 1549, 1, 1563, 1565, 2, 1566, 1567, 1, 1642, 1645, 1, 1748, 1792, 44, 1793, 1805, 1, 2039, 2041, 1, 2096, 2110, 1, 2142, 2404, 262, 2405, 2416, 11, 2557, 2678, 121, 2800, 3191, 391, 3204, 3572, 368, 3663, 3674, 11, 3675, 3844, 169, 3845, 3858, 1, 3860, 3898, 38, 3899, 3901, 1, 3973, 4048, 75, 4049, 4052, 1, 4057, 4058, 1, 4170, 4175, 1, 4347, 4960, 613, 4961, 4968, 1, 5120, 5742, 622, 5787, 5788, 1, 5867, 5869, 1, 5941, 5942, 1, 6100, 6102, 1, 6104, 6106, 1, 6144, 6154, 1, 6468, 6469, 1, 6686, 6687, 1, 6816, 6822, 1, 6824, 6829, 1, 6990, 6991, 1, 7002, 7008, 1, 7037, 7039, 1, 7164, 7167, 1, 7227, 7231, 1, 7294, 7295, 1, 7360, 7367, 1, 7379, 8208, 829, 8209, 8231, 1, 8240, 8259, 1, 8261, 8273, 1, 8275, 8286, 1, 8317, 8318, 1, 8333, 8334, 1, 8968, 8971, 1, 9001, 9002, 1, 10088, 10101, 1, 10181, 10182, 1, 10214, 10223, 1, 10627, 10648, 1, 10712, 10715, 1, 10748, 10749, 1, 11513, 11516, 1, 11518, 11519, 1, 11632, 11776, 144, 11777, 11822, 1, 11824, 11855, 1, 11858, 11869, 1, 12289, 12291, 1, 12296, 12305, 1, 12308, 12319, 1, 12336, 12349, 13, 12448, 12539, 91, 42238, 42239, 1, 42509, 42511, 1, 42611, 42622, 11, 42738, 42743, 1, 43124, 43127, 1, 43214, 43215, 1, 43256, 43258, 1, 43260, 43310, 50, 43311, 43359, 48, 43457, 43469, 1, 43486, 43487, 1, 43612, 43615, 1, 43742, 43743, 1, 43760, 43761, 1, 44011, 64830, 20819, 64831, 65040, 209, 65041, 65049, 1, 65072, 65106, 1, 65108, 65121, 1, 65123, 65128, 5, 65130, 65131, 1, 65281, 65283, 1, 65285, 65290, 1, 65292, 65295, 1, 65306, 65307, 1, 65311, 65312, 1, 65339, 65341, 1, 65343, 65371, 28, 65373, 65375, 2, 65376, 65381, 1, 65792, 65794, 1, 66463, 66512, 49, 66927, 67671, 744, 67871, 67903, 32, 68176, 68184, 1, 68223, 68336, 113, 68337, 68342, 1, 68409, 68415, 1, 68505, 68508, 1, 68974, 69293, 319, 69461, 69465, 1, 69510, 69513, 1, 69703, 69709, 1, 69819, 69820, 1, 69822, 69825, 1, 69952, 69955, 1, 70004, 70005, 1, 70085, 70088, 1, 70093, 70107, 14, 70109, 70111, 1, 70200, 70205, 1, 70313, 70612, 299, 70613, 70615, 2, 70616, 70731, 115, 70732, 70735, 1, 70746, 70747, 1, 70749, 70854, 105, 71105, 71127, 1, 71233, 71235, 1, 71264, 71276, 1, 71353, 71484, 131, 71485, 71486, 1, 71739, 72004, 265, 72005, 72006, 1, 72162, 72255, 93, 72256, 72262, 1, 72346, 72348, 1, 72350, 72354, 1, 72448, 72457, 1, 72673, 72769, 96, 72770, 72773, 1, 72816, 72817, 1, 73463, 73464, 1, 73539, 73551, 1, 73727, 74864, 1137, 74865, 74868, 1, 77809, 77810, 1, 92782, 92783, 1, 92917, 92983, 66, 92984, 92987, 1, 92996, 93549, 553, 93550, 93551, 1, 93847, 93850, 1, 94178, 113823, 19645, 121479, 121483, 1, 124415, 125278, 863, 125279, 125279, 1]));
    static Pc = new C(new Uint32Array([95, 8255, 8160, 8256, 8276, 20, 65075, 65076, 1, 65101, 65103, 1, 65343, 65343, 1]));
    static Pd = new C(new Uint32Array([45, 1418, 1373, 1470, 5120, 3650, 6150, 8208, 2058, 8209, 8213, 1, 11799, 11802, 3, 11834, 11835, 1, 11840, 11869, 29, 12316, 12336, 20, 12448, 65073, 52625, 65074, 65112, 38, 65123, 65293, 170, 68974, 69293, 319]));
    static Pe = new C(new Uint32Array([41, 93, 52, 125, 3899, 3774, 3901, 5788, 1887, 8262, 8318, 56, 8334, 8969, 635, 8971, 9002, 31, 10089, 10101, 2, 10182, 10215, 33, 10217, 10223, 2, 10628, 10648, 2, 10713, 10715, 2, 10749, 11811, 1062, 11813, 11817, 2, 11862, 11868, 2, 12297, 12305, 2, 12309, 12315, 2, 12318, 12319, 1, 64830, 65048, 218, 65078, 65092, 2, 65096, 65114, 18, 65116, 65118, 2, 65289, 65341, 52, 65373, 65379, 3]));
    static Pf = new C(new Uint32Array([187, 8217, 8030, 8221, 8250, 29, 11779, 11781, 2, 11786, 11789, 3, 11805, 11809, 4]));
    static Pi = new C(new Uint32Array([171, 8216, 8045, 8219, 8220, 1, 8223, 8249, 26, 11778, 11780, 2, 11785, 11788, 3, 11804, 11808, 4]));
    static Po = new C(new Uint32Array([33, 35, 1, 37, 39, 1, 42, 46, 2, 47, 58, 11, 59, 63, 4, 64, 92, 28, 161, 167, 6, 182, 183, 1, 191, 894, 703, 903, 1370, 467, 1371, 1375, 1, 1417, 1472, 55, 1475, 1478, 3, 1523, 1524, 1, 1545, 1546, 1, 1548, 1549, 1, 1563, 1565, 2, 1566, 1567, 1, 1642, 1645, 1, 1748, 1792, 44, 1793, 1805, 1, 2039, 2041, 1, 2096, 2110, 1, 2142, 2404, 262, 2405, 2416, 11, 2557, 2678, 121, 2800, 3191, 391, 3204, 3572, 368, 3663, 3674, 11, 3675, 3844, 169, 3845, 3858, 1, 3860, 3973, 113, 4048, 4052, 1, 4057, 4058, 1, 4170, 4175, 1, 4347, 4960, 613, 4961, 4968, 1, 5742, 5867, 125, 5868, 5869, 1, 5941, 5942, 1, 6100, 6102, 1, 6104, 6106, 1, 6144, 6149, 1, 6151, 6154, 1, 6468, 6469, 1, 6686, 6687, 1, 6816, 6822, 1, 6824, 6829, 1, 6990, 6991, 1, 7002, 7008, 1, 7037, 7039, 1, 7164, 7167, 1, 7227, 7231, 1, 7294, 7295, 1, 7360, 7367, 1, 7379, 8214, 835, 8215, 8224, 9, 8225, 8231, 1, 8240, 8248, 1, 8251, 8254, 1, 8257, 8259, 1, 8263, 8273, 1, 8275, 8277, 2, 8278, 8286, 1, 11513, 11516, 1, 11518, 11519, 1, 11632, 11776, 144, 11777, 11782, 5, 11783, 11784, 1, 11787, 11790, 3, 11791, 11798, 1, 11800, 11801, 1, 11803, 11806, 3, 11807, 11818, 11, 11819, 11822, 1, 11824, 11833, 1, 11836, 11839, 1, 11841, 11843, 2, 11844, 11855, 1, 11858, 11860, 1, 12289, 12291, 1, 12349, 12539, 190, 42238, 42239, 1, 42509, 42511, 1, 42611, 42622, 11, 42738, 42743, 1, 43124, 43127, 1, 43214, 43215, 1, 43256, 43258, 1, 43260, 43310, 50, 43311, 43359, 48, 43457, 43469, 1, 43486, 43487, 1, 43612, 43615, 1, 43742, 43743, 1, 43760, 43761, 1, 44011, 65040, 21029, 65041, 65046, 1, 65049, 65072, 23, 65093, 65094, 1, 65097, 65100, 1, 65104, 65106, 1, 65108, 65111, 1, 65119, 65121, 1, 65128, 65130, 2, 65131, 65281, 150, 65282, 65283, 1, 65285, 65287, 1, 65290, 65294, 2, 65295, 65306, 11, 65307, 65311, 4, 65312, 65340, 28, 65377, 65380, 3, 65381, 65792, 411, 65793, 65794, 1, 66463, 66512, 49, 66927, 67671, 744, 67871, 67903, 32, 68176, 68184, 1, 68223, 68336, 113, 68337, 68342, 1, 68409, 68415, 1, 68505, 68508, 1, 69461, 69465, 1, 69510, 69513, 1, 69703, 69709, 1, 69819, 69820, 1, 69822, 69825, 1, 69952, 69955, 1, 70004, 70005, 1, 70085, 70088, 1, 70093, 70107, 14, 70109, 70111, 1, 70200, 70205, 1, 70313, 70612, 299, 70613, 70615, 2, 70616, 70731, 115, 70732, 70735, 1, 70746, 70747, 1, 70749, 70854, 105, 71105, 71127, 1, 71233, 71235, 1, 71264, 71276, 1, 71353, 71484, 131, 71485, 71486, 1, 71739, 72004, 265, 72005, 72006, 1, 72162, 72255, 93, 72256, 72262, 1, 72346, 72348, 1, 72350, 72354, 1, 72448, 72457, 1, 72673, 72769, 96, 72770, 72773, 1, 72816, 72817, 1, 73463, 73464, 1, 73539, 73551, 1, 73727, 74864, 1137, 74865, 74868, 1, 77809, 77810, 1, 92782, 92783, 1, 92917, 92983, 66, 92984, 92987, 1, 92996, 93549, 553, 93550, 93551, 1, 93847, 93850, 1, 94178, 113823, 19645, 121479, 121483, 1, 124415, 125278, 863, 125279, 125279, 1]));
    static Ps = new C(new Uint32Array([40, 91, 51, 123, 3898, 3775, 3900, 5787, 1887, 8218, 8222, 4, 8261, 8317, 56, 8333, 8968, 635, 8970, 9001, 31, 10088, 10100, 2, 10181, 10214, 33, 10216, 10222, 2, 10627, 10647, 2, 10712, 10714, 2, 10748, 11810, 1062, 11812, 11816, 2, 11842, 11861, 19, 11863, 11867, 2, 12296, 12304, 2, 12308, 12314, 2, 12317, 64831, 52514, 65047, 65077, 30, 65079, 65091, 2, 65095, 65113, 18, 65115, 65117, 2, 65288, 65339, 51, 65371, 65375, 4, 65378, 65378, 1]));
    static S = new C(new Uint32Array([36, 43, 7, 60, 62, 1, 94, 96, 2, 124, 126, 2, 162, 166, 1, 168, 169, 1, 172, 174, 2, 175, 177, 1, 180, 184, 4, 215, 247, 32, 706, 709, 1, 722, 735, 1, 741, 747, 1, 749, 751, 2, 752, 767, 1, 885, 900, 15, 901, 1014, 113, 1154, 1421, 267, 1422, 1423, 1, 1542, 1544, 1, 1547, 1550, 3, 1551, 1758, 207, 1769, 1789, 20, 1790, 2038, 248, 2046, 2047, 1, 2184, 2546, 362, 2547, 2554, 7, 2555, 2801, 246, 2928, 3059, 131, 3060, 3066, 1, 3199, 3407, 208, 3449, 3647, 198, 3841, 3843, 1, 3859, 3861, 2, 3862, 3863, 1, 3866, 3871, 1, 3892, 3896, 2, 4030, 4037, 1, 4039, 4044, 1, 4046, 4047, 1, 4053, 4056, 1, 4254, 4255, 1, 5008, 5017, 1, 5741, 6107, 366, 6464, 6622, 158, 6623, 6655, 1, 7009, 7018, 1, 7028, 7036, 1, 8125, 8127, 2, 8128, 8129, 1, 8141, 8143, 1, 8157, 8159, 1, 8173, 8175, 1, 8189, 8190, 1, 8260, 8274, 14, 8314, 8316, 1, 8330, 8332, 1, 8352, 8384, 1, 8448, 8449, 1, 8451, 8454, 1, 8456, 8457, 1, 8468, 8470, 2, 8471, 8472, 1, 8478, 8483, 1, 8485, 8489, 2, 8494, 8506, 12, 8507, 8512, 5, 8513, 8516, 1, 8522, 8525, 1, 8527, 8586, 59, 8587, 8592, 5, 8593, 8967, 1, 8972, 9e3, 1, 9003, 9257, 1, 9280, 9290, 1, 9372, 9449, 1, 9472, 10087, 1, 10132, 10180, 1, 10183, 10213, 1, 10224, 10626, 1, 10649, 10711, 1, 10716, 10747, 1, 10750, 11123, 1, 11126, 11157, 1, 11159, 11263, 1, 11493, 11498, 1, 11856, 11857, 1, 11904, 11929, 1, 11931, 12019, 1, 12032, 12245, 1, 12272, 12287, 1, 12292, 12306, 14, 12307, 12320, 13, 12342, 12343, 1, 12350, 12351, 1, 12443, 12444, 1, 12688, 12689, 1, 12694, 12703, 1, 12736, 12773, 1, 12783, 12800, 17, 12801, 12830, 1, 12842, 12871, 1, 12880, 12896, 16, 12897, 12927, 1, 12938, 12976, 1, 12992, 13311, 1, 19904, 19967, 1, 42128, 42182, 1, 42752, 42774, 1, 42784, 42785, 1, 42889, 42890, 1, 43048, 43051, 1, 43062, 43065, 1, 43639, 43641, 1, 43867, 43882, 15, 43883, 64297, 20414, 64434, 64450, 1, 64832, 64847, 1, 64975, 65020, 45, 65021, 65023, 1, 65122, 65124, 2, 65125, 65126, 1, 65129, 65284, 155, 65291, 65308, 17, 65309, 65310, 1, 65342, 65344, 2, 65372, 65374, 2, 65504, 65510, 1, 65512, 65518, 1, 65532, 65533, 1, 65847, 65855, 1, 65913, 65929, 1, 65932, 65934, 1, 65936, 65948, 1, 65952, 66e3, 48, 66001, 66044, 1, 67703, 67704, 1, 68296, 69006, 710, 69007, 71487, 2480, 73685, 73713, 1, 92988, 92991, 1, 92997, 113820, 20823, 117760, 117999, 1, 118016, 118451, 1, 118608, 118723, 1, 118784, 119029, 1, 119040, 119078, 1, 119081, 119140, 1, 119146, 119148, 1, 119171, 119172, 1, 119180, 119209, 1, 119214, 119274, 1, 119296, 119361, 1, 119365, 119552, 187, 119553, 119638, 1, 120513, 120539, 26, 120571, 120597, 26, 120629, 120655, 26, 120687, 120713, 26, 120745, 120771, 26, 120832, 121343, 1, 121399, 121402, 1, 121453, 121460, 1, 121462, 121475, 1, 121477, 121478, 1, 123215, 123647, 432, 126124, 126128, 4, 126254, 126704, 450, 126705, 126976, 271, 126977, 127019, 1, 127024, 127123, 1, 127136, 127150, 1, 127153, 127167, 1, 127169, 127183, 1, 127185, 127221, 1, 127245, 127405, 1, 127462, 127490, 1, 127504, 127547, 1, 127552, 127560, 1, 127568, 127569, 1, 127584, 127589, 1, 127744, 128727, 1, 128732, 128748, 1, 128752, 128764, 1, 128768, 128886, 1, 128891, 128985, 1, 128992, 129003, 1, 129008, 129024, 16, 129025, 129035, 1, 129040, 129095, 1, 129104, 129113, 1, 129120, 129159, 1, 129168, 129197, 1, 129200, 129211, 1, 129216, 129217, 1, 129280, 129619, 1, 129632, 129645, 1, 129648, 129660, 1, 129664, 129673, 1, 129679, 129734, 1, 129742, 129756, 1, 129759, 129769, 1, 129776, 129784, 1, 129792, 129938, 1, 129940, 130031, 1]));
    static Sc = new C(new Uint32Array([36, 162, 126, 163, 165, 1, 1423, 1547, 124, 2046, 2047, 1, 2546, 2547, 1, 2555, 2801, 246, 3065, 3647, 582, 6107, 8352, 2245, 8353, 8384, 1, 43064, 65020, 21956, 65129, 65284, 155, 65504, 65505, 1, 65509, 65510, 1, 73693, 73696, 1, 123647, 126128, 2481]));
    static Sk = new C(new Uint32Array([94, 96, 2, 168, 175, 7, 180, 184, 4, 706, 709, 1, 722, 735, 1, 741, 747, 1, 749, 751, 2, 752, 767, 1, 885, 900, 15, 901, 2184, 1283, 8125, 8127, 2, 8128, 8129, 1, 8141, 8143, 1, 8157, 8159, 1, 8173, 8175, 1, 8189, 8190, 1, 12443, 12444, 1, 42752, 42774, 1, 42784, 42785, 1, 42889, 42890, 1, 43867, 43882, 15, 43883, 64434, 20551, 64435, 64450, 1, 65342, 65344, 2, 65507, 127995, 62488, 127996, 127999, 1]));
    static Sm = new C(new Uint32Array([43, 60, 17, 61, 62, 1, 124, 126, 2, 172, 177, 5, 215, 247, 32, 1014, 1542, 528, 1543, 1544, 1, 8260, 8274, 14, 8314, 8316, 1, 8330, 8332, 1, 8472, 8512, 40, 8513, 8516, 1, 8523, 8592, 69, 8593, 8596, 1, 8602, 8603, 1, 8608, 8614, 3, 8622, 8654, 32, 8655, 8658, 3, 8660, 8692, 32, 8693, 8959, 1, 8992, 8993, 1, 9084, 9115, 31, 9116, 9139, 1, 9180, 9185, 1, 9655, 9665, 10, 9720, 9727, 1, 9839, 10176, 337, 10177, 10180, 1, 10183, 10213, 1, 10224, 10239, 1, 10496, 10626, 1, 10649, 10711, 1, 10716, 10747, 1, 10750, 11007, 1, 11056, 11076, 1, 11079, 11084, 1, 64297, 65122, 825, 65124, 65126, 1, 65291, 65308, 17, 65309, 65310, 1, 65372, 65374, 2, 65506, 65513, 7, 65514, 65516, 1, 69006, 69007, 1, 120513, 120539, 26, 120571, 120597, 26, 120629, 120655, 26, 120687, 120713, 26, 120745, 120771, 26, 126704, 126705, 1]));
    static So = new C(new Uint32Array([166, 169, 3, 174, 176, 2, 1154, 1421, 267, 1422, 1550, 128, 1551, 1758, 207, 1769, 1789, 20, 1790, 2038, 248, 2554, 2928, 374, 3059, 3064, 1, 3066, 3199, 133, 3407, 3449, 42, 3841, 3843, 1, 3859, 3861, 2, 3862, 3863, 1, 3866, 3871, 1, 3892, 3896, 2, 4030, 4037, 1, 4039, 4044, 1, 4046, 4047, 1, 4053, 4056, 1, 4254, 4255, 1, 5008, 5017, 1, 5741, 6464, 723, 6622, 6655, 1, 7009, 7018, 1, 7028, 7036, 1, 8448, 8449, 1, 8451, 8454, 1, 8456, 8457, 1, 8468, 8470, 2, 8471, 8478, 7, 8479, 8483, 1, 8485, 8489, 2, 8494, 8506, 12, 8507, 8522, 15, 8524, 8525, 1, 8527, 8586, 59, 8587, 8597, 10, 8598, 8601, 1, 8604, 8607, 1, 8609, 8610, 1, 8612, 8613, 1, 8615, 8621, 1, 8623, 8653, 1, 8656, 8657, 1, 8659, 8661, 2, 8662, 8691, 1, 8960, 8967, 1, 8972, 8991, 1, 8994, 9e3, 1, 9003, 9083, 1, 9085, 9114, 1, 9140, 9179, 1, 9186, 9257, 1, 9280, 9290, 1, 9372, 9449, 1, 9472, 9654, 1, 9656, 9664, 1, 9666, 9719, 1, 9728, 9838, 1, 9840, 10087, 1, 10132, 10175, 1, 10240, 10495, 1, 11008, 11055, 1, 11077, 11078, 1, 11085, 11123, 1, 11126, 11157, 1, 11159, 11263, 1, 11493, 11498, 1, 11856, 11857, 1, 11904, 11929, 1, 11931, 12019, 1, 12032, 12245, 1, 12272, 12287, 1, 12292, 12306, 14, 12307, 12320, 13, 12342, 12343, 1, 12350, 12351, 1, 12688, 12689, 1, 12694, 12703, 1, 12736, 12773, 1, 12783, 12800, 17, 12801, 12830, 1, 12842, 12871, 1, 12880, 12896, 16, 12897, 12927, 1, 12938, 12976, 1, 12992, 13311, 1, 19904, 19967, 1, 42128, 42182, 1, 43048, 43051, 1, 43062, 43063, 1, 43065, 43639, 574, 43640, 43641, 1, 64832, 64847, 1, 64975, 65021, 46, 65022, 65023, 1, 65508, 65512, 4, 65517, 65518, 1, 65532, 65533, 1, 65847, 65855, 1, 65913, 65929, 1, 65932, 65934, 1, 65936, 65948, 1, 65952, 66e3, 48, 66001, 66044, 1, 67703, 67704, 1, 68296, 71487, 3191, 73685, 73692, 1, 73697, 73713, 1, 92988, 92991, 1, 92997, 113820, 20823, 117760, 117999, 1, 118016, 118451, 1, 118608, 118723, 1, 118784, 119029, 1, 119040, 119078, 1, 119081, 119140, 1, 119146, 119148, 1, 119171, 119172, 1, 119180, 119209, 1, 119214, 119274, 1, 119296, 119361, 1, 119365, 119552, 187, 119553, 119638, 1, 120832, 121343, 1, 121399, 121402, 1, 121453, 121460, 1, 121462, 121475, 1, 121477, 121478, 1, 123215, 126124, 2909, 126254, 126976, 722, 126977, 127019, 1, 127024, 127123, 1, 127136, 127150, 1, 127153, 127167, 1, 127169, 127183, 1, 127185, 127221, 1, 127245, 127405, 1, 127462, 127490, 1, 127504, 127547, 1, 127552, 127560, 1, 127568, 127569, 1, 127584, 127589, 1, 127744, 127994, 1, 128e3, 128727, 1, 128732, 128748, 1, 128752, 128764, 1, 128768, 128886, 1, 128891, 128985, 1, 128992, 129003, 1, 129008, 129024, 16, 129025, 129035, 1, 129040, 129095, 1, 129104, 129113, 1, 129120, 129159, 1, 129168, 129197, 1, 129200, 129211, 1, 129216, 129217, 1, 129280, 129619, 1, 129632, 129645, 1, 129648, 129660, 1, 129664, 129673, 1, 129679, 129734, 1, 129742, 129756, 1, 129759, 129769, 1, 129776, 129784, 1, 129792, 129938, 1, 129940, 130031, 1]));
    static Z = new C(new Uint32Array([32, 160, 128, 5760, 8192, 2432, 8193, 8202, 1, 8232, 8233, 1, 8239, 8287, 48, 12288, 12288, 1]));
    static Zl = new C(new Uint32Array([8232, 8232, 1]));
    static Zp = new C(new Uint32Array([8233, 8233, 1]));
    static Zs = new C(new Uint32Array([32, 160, 128, 5760, 8192, 2432, 8193, 8202, 1, 8239, 8287, 48, 12288, 12288, 1]));
    static Adlam = new C(new Uint32Array([125184, 125259, 1, 125264, 125273, 1, 125278, 125279, 1]));
    static Ahom = new C(new Uint32Array([71424, 71450, 1, 71453, 71467, 1, 71472, 71494, 1]));
    static Anatolian_Hieroglyphs = new C(new Uint32Array([82944, 83526, 1]));
    static Arabic = new C(new Uint32Array([1536, 1540, 1, 1542, 1547, 1, 1549, 1562, 1, 1564, 1566, 1, 1568, 1599, 1, 1601, 1610, 1, 1622, 1647, 1, 1649, 1756, 1, 1758, 1791, 1, 1872, 1919, 1, 2160, 2190, 1, 2192, 2193, 1, 2199, 2273, 1, 2275, 2303, 1, 64336, 64450, 1, 64467, 64829, 1, 64832, 64911, 1, 64914, 64967, 1, 64975, 65008, 33, 65009, 65023, 1, 65136, 65140, 1, 65142, 65276, 1, 69216, 69246, 1, 69314, 69316, 1, 69372, 69375, 1, 126464, 126467, 1, 126469, 126495, 1, 126497, 126498, 1, 126500, 126503, 3, 126505, 126514, 1, 126516, 126519, 1, 126521, 126523, 2, 126530, 126535, 5, 126537, 126541, 2, 126542, 126543, 1, 126545, 126546, 1, 126548, 126551, 3, 126553, 126561, 2, 126562, 126564, 2, 126567, 126570, 1, 126572, 126578, 1, 126580, 126583, 1, 126585, 126588, 1, 126590, 126592, 2, 126593, 126601, 1, 126603, 126619, 1, 126625, 126627, 1, 126629, 126633, 1, 126635, 126651, 1, 126704, 126705, 1]));
    static Armenian = new C(new Uint32Array([1329, 1366, 1, 1369, 1418, 1, 1421, 1423, 1, 64275, 64279, 1]));
    static Avestan = new C(new Uint32Array([68352, 68405, 1, 68409, 68415, 1]));
    static Balinese = new C(new Uint32Array([6912, 6988, 1, 6990, 7039, 1]));
    static Bamum = new C(new Uint32Array([42656, 42743, 1, 92160, 92728, 1]));
    static Bassa_Vah = new C(new Uint32Array([92880, 92909, 1, 92912, 92917, 1]));
    static Batak = new C(new Uint32Array([7104, 7155, 1, 7164, 7167, 1]));
    static Bengali = new C(new Uint32Array([2432, 2435, 1, 2437, 2444, 1, 2447, 2448, 1, 2451, 2472, 1, 2474, 2480, 1, 2482, 2486, 4, 2487, 2489, 1, 2492, 2500, 1, 2503, 2504, 1, 2507, 2510, 1, 2519, 2524, 5, 2525, 2527, 2, 2528, 2531, 1, 2534, 2558, 1]));
    static Bhaiksuki = new C(new Uint32Array([72704, 72712, 1, 72714, 72758, 1, 72760, 72773, 1, 72784, 72812, 1]));
    static Bopomofo = new C(new Uint32Array([746, 747, 1, 12549, 12591, 1, 12704, 12735, 1]));
    static Brahmi = new C(new Uint32Array([69632, 69709, 1, 69714, 69749, 1, 69759, 69759, 1]));
    static Braille = new C(new Uint32Array([10240, 10495, 1]));
    static Buginese = new C(new Uint32Array([6656, 6683, 1, 6686, 6687, 1]));
    static Buhid = new C(new Uint32Array([5952, 5971, 1]));
    static Canadian_Aboriginal = new C(new Uint32Array([5120, 5759, 1, 6320, 6389, 1, 72368, 72383, 1]));
    static Carian = new C(new Uint32Array([66208, 66256, 1]));
    static Caucasian_Albanian = new C(new Uint32Array([66864, 66915, 1, 66927, 66927, 1]));
    static Chakma = new C(new Uint32Array([69888, 69940, 1, 69942, 69959, 1]));
    static Cham = new C(new Uint32Array([43520, 43574, 1, 43584, 43597, 1, 43600, 43609, 1, 43612, 43615, 1]));
    static Cherokee = new C(new Uint32Array([5024, 5109, 1, 5112, 5117, 1, 43888, 43967, 1]));
    static Chorasmian = new C(new Uint32Array([69552, 69579, 1]));
    static Common = new C(new Uint32Array([0, 64, 1, 91, 96, 1, 123, 169, 1, 171, 185, 1, 187, 191, 1, 215, 247, 32, 697, 735, 1, 741, 745, 1, 748, 767, 1, 884, 894, 10, 901, 903, 2, 1541, 1548, 7, 1563, 1567, 4, 1600, 1757, 157, 2274, 2404, 130, 2405, 3647, 1242, 4053, 4056, 1, 4347, 5867, 1520, 5868, 5869, 1, 5941, 5942, 1, 6146, 6147, 1, 6149, 7379, 1230, 7393, 7401, 8, 7402, 7404, 1, 7406, 7411, 1, 7413, 7415, 1, 7418, 8192, 774, 8193, 8203, 1, 8206, 8292, 1, 8294, 8304, 1, 8308, 8318, 1, 8320, 8334, 1, 8352, 8384, 1, 8448, 8485, 1, 8487, 8489, 1, 8492, 8497, 1, 8499, 8525, 1, 8527, 8543, 1, 8585, 8587, 1, 8592, 9257, 1, 9280, 9290, 1, 9312, 10239, 1, 10496, 11123, 1, 11126, 11157, 1, 11159, 11263, 1, 11776, 11869, 1, 12272, 12292, 1, 12294, 12296, 2, 12297, 12320, 1, 12336, 12343, 1, 12348, 12351, 1, 12443, 12444, 1, 12448, 12539, 91, 12540, 12688, 148, 12689, 12703, 1, 12736, 12773, 1, 12783, 12832, 49, 12833, 12895, 1, 12927, 13007, 1, 13055, 13144, 89, 13145, 13311, 1, 19904, 19967, 1, 42752, 42785, 1, 42888, 42890, 1, 43056, 43065, 1, 43310, 43471, 161, 43867, 43882, 15, 43883, 64830, 20947, 64831, 65040, 209, 65041, 65049, 1, 65072, 65106, 1, 65108, 65126, 1, 65128, 65131, 1, 65279, 65281, 2, 65282, 65312, 1, 65339, 65344, 1, 65371, 65381, 1, 65392, 65438, 46, 65439, 65504, 65, 65505, 65510, 1, 65512, 65518, 1, 65529, 65533, 1, 65792, 65794, 1, 65799, 65843, 1, 65847, 65855, 1, 65936, 65948, 1, 66e3, 66044, 1, 66273, 66299, 1, 113824, 113827, 1, 117760, 118009, 1, 118016, 118451, 1, 118608, 118723, 1, 118784, 119029, 1, 119040, 119078, 1, 119081, 119142, 1, 119146, 119162, 1, 119171, 119172, 1, 119180, 119209, 1, 119214, 119274, 1, 119488, 119507, 1, 119520, 119539, 1, 119552, 119638, 1, 119648, 119672, 1, 119808, 119892, 1, 119894, 119964, 1, 119966, 119967, 1, 119970, 119973, 3, 119974, 119977, 3, 119978, 119980, 1, 119982, 119993, 1, 119995, 119997, 2, 119998, 120003, 1, 120005, 120069, 1, 120071, 120074, 1, 120077, 120084, 1, 120086, 120092, 1, 120094, 120121, 1, 120123, 120126, 1, 120128, 120132, 1, 120134, 120138, 4, 120139, 120144, 1, 120146, 120485, 1, 120488, 120779, 1, 120782, 120831, 1, 126065, 126132, 1, 126209, 126269, 1, 126976, 127019, 1, 127024, 127123, 1, 127136, 127150, 1, 127153, 127167, 1, 127169, 127183, 1, 127185, 127221, 1, 127232, 127405, 1, 127462, 127487, 1, 127489, 127490, 1, 127504, 127547, 1, 127552, 127560, 1, 127568, 127569, 1, 127584, 127589, 1, 127744, 128727, 1, 128732, 128748, 1, 128752, 128764, 1, 128768, 128886, 1, 128891, 128985, 1, 128992, 129003, 1, 129008, 129024, 16, 129025, 129035, 1, 129040, 129095, 1, 129104, 129113, 1, 129120, 129159, 1, 129168, 129197, 1, 129200, 129211, 1, 129216, 129217, 1, 129280, 129619, 1, 129632, 129645, 1, 129648, 129660, 1, 129664, 129673, 1, 129679, 129734, 1, 129742, 129756, 1, 129759, 129769, 1, 129776, 129784, 1, 129792, 129938, 1, 129940, 130041, 1, 917505, 917536, 31, 917537, 917631, 1]));
    static foldCommon = new C(new Uint32Array([924, 956, 32]));
    static Coptic = new C(new Uint32Array([994, 1007, 1, 11392, 11507, 1, 11513, 11519, 1]));
    static Cuneiform = new C(new Uint32Array([73728, 74649, 1, 74752, 74862, 1, 74864, 74868, 1, 74880, 75075, 1]));
    static Cypriot = new C(new Uint32Array([67584, 67589, 1, 67592, 67594, 2, 67595, 67637, 1, 67639, 67640, 1, 67644, 67647, 3]));
    static Cypro_Minoan = new C(new Uint32Array([77712, 77810, 1]));
    static Cyrillic = new C(new Uint32Array([1024, 1156, 1, 1159, 1327, 1, 7296, 7306, 1, 7467, 7544, 77, 11744, 11775, 1, 42560, 42655, 1, 65070, 65071, 1, 122928, 122989, 1, 123023, 123023, 1]));
    static Deseret = new C(new Uint32Array([66560, 66639, 1]));
    static Devanagari = new C(new Uint32Array([2304, 2384, 1, 2389, 2403, 1, 2406, 2431, 1, 43232, 43263, 1, 72448, 72457, 1]));
    static Dives_Akuru = new C(new Uint32Array([71936, 71942, 1, 71945, 71948, 3, 71949, 71955, 1, 71957, 71958, 1, 71960, 71989, 1, 71991, 71992, 1, 71995, 72006, 1, 72016, 72025, 1]));
    static Dogra = new C(new Uint32Array([71680, 71739, 1]));
    static Duployan = new C(new Uint32Array([113664, 113770, 1, 113776, 113788, 1, 113792, 113800, 1, 113808, 113817, 1, 113820, 113823, 1]));
    static Egyptian_Hieroglyphs = new C(new Uint32Array([77824, 78933, 1, 78944, 82938, 1]));
    static Elbasan = new C(new Uint32Array([66816, 66855, 1]));
    static Elymaic = new C(new Uint32Array([69600, 69622, 1]));
    static Ethiopic = new C(new Uint32Array([4608, 4680, 1, 4682, 4685, 1, 4688, 4694, 1, 4696, 4698, 2, 4699, 4701, 1, 4704, 4744, 1, 4746, 4749, 1, 4752, 4784, 1, 4786, 4789, 1, 4792, 4798, 1, 4800, 4802, 2, 4803, 4805, 1, 4808, 4822, 1, 4824, 4880, 1, 4882, 4885, 1, 4888, 4954, 1, 4957, 4988, 1, 4992, 5017, 1, 11648, 11670, 1, 11680, 11686, 1, 11688, 11694, 1, 11696, 11702, 1, 11704, 11710, 1, 11712, 11718, 1, 11720, 11726, 1, 11728, 11734, 1, 11736, 11742, 1, 43777, 43782, 1, 43785, 43790, 1, 43793, 43798, 1, 43808, 43814, 1, 43816, 43822, 1, 124896, 124902, 1, 124904, 124907, 1, 124909, 124910, 1, 124912, 124926, 1]));
    static Garay = new C(new Uint32Array([68928, 68965, 1, 68969, 68997, 1, 69006, 69007, 1]));
    static Georgian = new C(new Uint32Array([4256, 4293, 1, 4295, 4301, 6, 4304, 4346, 1, 4348, 4351, 1, 7312, 7354, 1, 7357, 7359, 1, 11520, 11557, 1, 11559, 11565, 6]));
    static Glagolitic = new C(new Uint32Array([11264, 11359, 1, 122880, 122886, 1, 122888, 122904, 1, 122907, 122913, 1, 122915, 122916, 1, 122918, 122922, 1]));
    static Gothic = new C(new Uint32Array([66352, 66378, 1]));
    static Grantha = new C(new Uint32Array([70400, 70403, 1, 70405, 70412, 1, 70415, 70416, 1, 70419, 70440, 1, 70442, 70448, 1, 70450, 70451, 1, 70453, 70457, 1, 70460, 70468, 1, 70471, 70472, 1, 70475, 70477, 1, 70480, 70487, 7, 70493, 70499, 1, 70502, 70508, 1, 70512, 70516, 1]));
    static Greek = new C(new Uint32Array([880, 883, 1, 885, 887, 1, 890, 893, 1, 895, 900, 5, 902, 904, 2, 905, 906, 1, 908, 910, 2, 911, 929, 1, 931, 993, 1, 1008, 1023, 1, 7462, 7466, 1, 7517, 7521, 1, 7526, 7530, 1, 7615, 7936, 321, 7937, 7957, 1, 7960, 7965, 1, 7968, 8005, 1, 8008, 8013, 1, 8016, 8023, 1, 8025, 8031, 2, 8032, 8061, 1, 8064, 8116, 1, 8118, 8132, 1, 8134, 8147, 1, 8150, 8155, 1, 8157, 8175, 1, 8178, 8180, 1, 8182, 8190, 1, 8486, 43877, 35391, 65856, 65934, 1, 65952, 119296, 53344, 119297, 119365, 1]));
    static foldGreek = new C(new Uint32Array([181, 837, 656]));
    static Gujarati = new C(new Uint32Array([2689, 2691, 1, 2693, 2701, 1, 2703, 2705, 1, 2707, 2728, 1, 2730, 2736, 1, 2738, 2739, 1, 2741, 2745, 1, 2748, 2757, 1, 2759, 2761, 1, 2763, 2765, 1, 2768, 2784, 16, 2785, 2787, 1, 2790, 2801, 1, 2809, 2815, 1]));
    static Gunjala_Gondi = new C(new Uint32Array([73056, 73061, 1, 73063, 73064, 1, 73066, 73102, 1, 73104, 73105, 1, 73107, 73112, 1, 73120, 73129, 1]));
    static Gurmukhi = new C(new Uint32Array([2561, 2563, 1, 2565, 2570, 1, 2575, 2576, 1, 2579, 2600, 1, 2602, 2608, 1, 2610, 2611, 1, 2613, 2614, 1, 2616, 2617, 1, 2620, 2622, 2, 2623, 2626, 1, 2631, 2632, 1, 2635, 2637, 1, 2641, 2649, 8, 2650, 2652, 1, 2654, 2662, 8, 2663, 2678, 1]));
    static Gurung_Khema = new C(new Uint32Array([90368, 90425, 1]));
    static Han = new C(new Uint32Array([11904, 11929, 1, 11931, 12019, 1, 12032, 12245, 1, 12293, 12295, 2, 12321, 12329, 1, 12344, 12347, 1, 13312, 19903, 1, 19968, 40959, 1, 63744, 64109, 1, 64112, 64217, 1, 94178, 94179, 1, 94192, 94193, 1, 131072, 173791, 1, 173824, 177977, 1, 177984, 178205, 1, 178208, 183969, 1, 183984, 191456, 1, 191472, 192093, 1, 194560, 195101, 1, 196608, 201546, 1, 201552, 205743, 1]));
    static Hangul = new C(new Uint32Array([4352, 4607, 1, 12334, 12335, 1, 12593, 12686, 1, 12800, 12830, 1, 12896, 12926, 1, 43360, 43388, 1, 44032, 55203, 1, 55216, 55238, 1, 55243, 55291, 1, 65440, 65470, 1, 65474, 65479, 1, 65482, 65487, 1, 65490, 65495, 1, 65498, 65500, 1]));
    static Hanifi_Rohingya = new C(new Uint32Array([68864, 68903, 1, 68912, 68921, 1]));
    static Hanunoo = new C(new Uint32Array([5920, 5940, 1]));
    static Hatran = new C(new Uint32Array([67808, 67826, 1, 67828, 67829, 1, 67835, 67839, 1]));
    static Hebrew = new C(new Uint32Array([1425, 1479, 1, 1488, 1514, 1, 1519, 1524, 1, 64285, 64310, 1, 64312, 64316, 1, 64318, 64320, 2, 64321, 64323, 2, 64324, 64326, 2, 64327, 64335, 1]));
    static Hiragana = new C(new Uint32Array([12353, 12438, 1, 12445, 12447, 1, 110593, 110879, 1, 110898, 110928, 30, 110929, 110930, 1, 127488, 127488, 1]));
    static Imperial_Aramaic = new C(new Uint32Array([67648, 67669, 1, 67671, 67679, 1]));
    static Inherited = new C(new Uint32Array([768, 879, 1, 1157, 1158, 1, 1611, 1621, 1, 1648, 2385, 737, 2386, 2388, 1, 6832, 6862, 1, 7376, 7378, 1, 7380, 7392, 1, 7394, 7400, 1, 7405, 7412, 7, 7416, 7417, 1, 7616, 7679, 1, 8204, 8205, 1, 8400, 8432, 1, 12330, 12333, 1, 12441, 12442, 1, 65024, 65039, 1, 65056, 65069, 1, 66045, 66272, 227, 70459, 118528, 48069, 118529, 118573, 1, 118576, 118598, 1, 119143, 119145, 1, 119163, 119170, 1, 119173, 119179, 1, 119210, 119213, 1, 917760, 917999, 1]));
    static foldInherited = new C(new Uint32Array([921, 953, 32, 8126, 8126, 1]));
    static Inscriptional_Pahlavi = new C(new Uint32Array([68448, 68466, 1, 68472, 68479, 1]));
    static Inscriptional_Parthian = new C(new Uint32Array([68416, 68437, 1, 68440, 68447, 1]));
    static Javanese = new C(new Uint32Array([43392, 43469, 1, 43472, 43481, 1, 43486, 43487, 1]));
    static Kaithi = new C(new Uint32Array([69760, 69826, 1, 69837, 69837, 1]));
    static Kannada = new C(new Uint32Array([3200, 3212, 1, 3214, 3216, 1, 3218, 3240, 1, 3242, 3251, 1, 3253, 3257, 1, 3260, 3268, 1, 3270, 3272, 1, 3274, 3277, 1, 3285, 3286, 1, 3293, 3294, 1, 3296, 3299, 1, 3302, 3311, 1, 3313, 3315, 1]));
    static Katakana = new C(new Uint32Array([12449, 12538, 1, 12541, 12543, 1, 12784, 12799, 1, 13008, 13054, 1, 13056, 13143, 1, 65382, 65391, 1, 65393, 65437, 1, 110576, 110579, 1, 110581, 110587, 1, 110589, 110590, 1, 110592, 110880, 288, 110881, 110882, 1, 110933, 110948, 15, 110949, 110951, 1]));
    static Kawi = new C(new Uint32Array([73472, 73488, 1, 73490, 73530, 1, 73534, 73562, 1]));
    static Kayah_Li = new C(new Uint32Array([43264, 43309, 1, 43311, 43311, 1]));
    static Kharoshthi = new C(new Uint32Array([68096, 68099, 1, 68101, 68102, 1, 68108, 68115, 1, 68117, 68119, 1, 68121, 68149, 1, 68152, 68154, 1, 68159, 68168, 1, 68176, 68184, 1]));
    static Khitan_Small_Script = new C(new Uint32Array([94180, 101120, 6940, 101121, 101589, 1, 101631, 101631, 1]));
    static Khmer = new C(new Uint32Array([6016, 6109, 1, 6112, 6121, 1, 6128, 6137, 1, 6624, 6655, 1]));
    static Khojki = new C(new Uint32Array([70144, 70161, 1, 70163, 70209, 1]));
    static Khudawadi = new C(new Uint32Array([70320, 70378, 1, 70384, 70393, 1]));
    static Kirat_Rai = new C(new Uint32Array([93504, 93561, 1]));
    static Lao = new C(new Uint32Array([3713, 3714, 1, 3716, 3718, 2, 3719, 3722, 1, 3724, 3747, 1, 3749, 3751, 2, 3752, 3773, 1, 3776, 3780, 1, 3782, 3784, 2, 3785, 3790, 1, 3792, 3801, 1, 3804, 3807, 1]));
    static Latin = new C(new Uint32Array([65, 90, 1, 97, 122, 1, 170, 186, 16, 192, 214, 1, 216, 246, 1, 248, 696, 1, 736, 740, 1, 7424, 7461, 1, 7468, 7516, 1, 7522, 7525, 1, 7531, 7543, 1, 7545, 7614, 1, 7680, 7935, 1, 8305, 8319, 14, 8336, 8348, 1, 8490, 8491, 1, 8498, 8526, 28, 8544, 8584, 1, 11360, 11391, 1, 42786, 42887, 1, 42891, 42957, 1, 42960, 42961, 1, 42963, 42965, 2, 42966, 42972, 1, 42994, 43007, 1, 43824, 43866, 1, 43868, 43876, 1, 43878, 43881, 1, 64256, 64262, 1, 65313, 65338, 1, 65345, 65370, 1, 67456, 67461, 1, 67463, 67504, 1, 67506, 67514, 1, 122624, 122654, 1, 122661, 122666, 1]));
    static Lepcha = new C(new Uint32Array([7168, 7223, 1, 7227, 7241, 1, 7245, 7247, 1]));
    static Limbu = new C(new Uint32Array([6400, 6430, 1, 6432, 6443, 1, 6448, 6459, 1, 6464, 6468, 4, 6469, 6479, 1]));
    static Linear_A = new C(new Uint32Array([67072, 67382, 1, 67392, 67413, 1, 67424, 67431, 1]));
    static Linear_B = new C(new Uint32Array([65536, 65547, 1, 65549, 65574, 1, 65576, 65594, 1, 65596, 65597, 1, 65599, 65613, 1, 65616, 65629, 1, 65664, 65786, 1]));
    static Lisu = new C(new Uint32Array([42192, 42239, 1, 73648, 73648, 1]));
    static Lycian = new C(new Uint32Array([66176, 66204, 1]));
    static Lydian = new C(new Uint32Array([67872, 67897, 1, 67903, 67903, 1]));
    static Mahajani = new C(new Uint32Array([69968, 70006, 1]));
    static Makasar = new C(new Uint32Array([73440, 73464, 1]));
    static Malayalam = new C(new Uint32Array([3328, 3340, 1, 3342, 3344, 1, 3346, 3396, 1, 3398, 3400, 1, 3402, 3407, 1, 3412, 3427, 1, 3430, 3455, 1]));
    static Mandaic = new C(new Uint32Array([2112, 2139, 1, 2142, 2142, 1]));
    static Manichaean = new C(new Uint32Array([68288, 68326, 1, 68331, 68342, 1]));
    static Marchen = new C(new Uint32Array([72816, 72847, 1, 72850, 72871, 1, 72873, 72886, 1]));
    static Masaram_Gondi = new C(new Uint32Array([72960, 72966, 1, 72968, 72969, 1, 72971, 73014, 1, 73018, 73020, 2, 73021, 73023, 2, 73024, 73031, 1, 73040, 73049, 1]));
    static Medefaidrin = new C(new Uint32Array([93760, 93850, 1]));
    static Meetei_Mayek = new C(new Uint32Array([43744, 43766, 1, 43968, 44013, 1, 44016, 44025, 1]));
    static Mende_Kikakui = new C(new Uint32Array([124928, 125124, 1, 125127, 125142, 1]));
    static Meroitic_Cursive = new C(new Uint32Array([68e3, 68023, 1, 68028, 68047, 1, 68050, 68095, 1]));
    static Meroitic_Hieroglyphs = new C(new Uint32Array([67968, 67999, 1]));
    static Miao = new C(new Uint32Array([93952, 94026, 1, 94031, 94087, 1, 94095, 94111, 1]));
    static Modi = new C(new Uint32Array([71168, 71236, 1, 71248, 71257, 1]));
    static Mongolian = new C(new Uint32Array([6144, 6145, 1, 6148, 6150, 2, 6151, 6169, 1, 6176, 6264, 1, 6272, 6314, 1, 71264, 71276, 1]));
    static Mro = new C(new Uint32Array([92736, 92766, 1, 92768, 92777, 1, 92782, 92783, 1]));
    static Multani = new C(new Uint32Array([70272, 70278, 1, 70280, 70282, 2, 70283, 70285, 1, 70287, 70301, 1, 70303, 70313, 1]));
    static Myanmar = new C(new Uint32Array([4096, 4255, 1, 43488, 43518, 1, 43616, 43647, 1, 71376, 71395, 1]));
    static Nabataean = new C(new Uint32Array([67712, 67742, 1, 67751, 67759, 1]));
    static Nag_Mundari = new C(new Uint32Array([124112, 124153, 1]));
    static Nandinagari = new C(new Uint32Array([72096, 72103, 1, 72106, 72151, 1, 72154, 72164, 1]));
    static New_Tai_Lue = new C(new Uint32Array([6528, 6571, 1, 6576, 6601, 1, 6608, 6618, 1, 6622, 6623, 1]));
    static Newa = new C(new Uint32Array([70656, 70747, 1, 70749, 70753, 1]));
    static Nko = new C(new Uint32Array([1984, 2042, 1, 2045, 2047, 1]));
    static Nushu = new C(new Uint32Array([94177, 110960, 16783, 110961, 111355, 1]));
    static Nyiakeng_Puachue_Hmong = new C(new Uint32Array([123136, 123180, 1, 123184, 123197, 1, 123200, 123209, 1, 123214, 123215, 1]));
    static Ogham = new C(new Uint32Array([5760, 5788, 1]));
    static Ol_Chiki = new C(new Uint32Array([7248, 7295, 1]));
    static Ol_Onal = new C(new Uint32Array([124368, 124410, 1, 124415, 124415, 1]));
    static Old_Hungarian = new C(new Uint32Array([68736, 68786, 1, 68800, 68850, 1, 68858, 68863, 1]));
    static Old_Italic = new C(new Uint32Array([66304, 66339, 1, 66349, 66351, 1]));
    static Old_North_Arabian = new C(new Uint32Array([68224, 68255, 1]));
    static Old_Permic = new C(new Uint32Array([66384, 66426, 1]));
    static Old_Persian = new C(new Uint32Array([66464, 66499, 1, 66504, 66517, 1]));
    static Old_Sogdian = new C(new Uint32Array([69376, 69415, 1]));
    static Old_South_Arabian = new C(new Uint32Array([68192, 68223, 1]));
    static Old_Turkic = new C(new Uint32Array([68608, 68680, 1]));
    static Old_Uyghur = new C(new Uint32Array([69488, 69513, 1]));
    static Oriya = new C(new Uint32Array([2817, 2819, 1, 2821, 2828, 1, 2831, 2832, 1, 2835, 2856, 1, 2858, 2864, 1, 2866, 2867, 1, 2869, 2873, 1, 2876, 2884, 1, 2887, 2888, 1, 2891, 2893, 1, 2901, 2903, 1, 2908, 2909, 1, 2911, 2915, 1, 2918, 2935, 1]));
    static Osage = new C(new Uint32Array([66736, 66771, 1, 66776, 66811, 1]));
    static Osmanya = new C(new Uint32Array([66688, 66717, 1, 66720, 66729, 1]));
    static Pahawh_Hmong = new C(new Uint32Array([92928, 92997, 1, 93008, 93017, 1, 93019, 93025, 1, 93027, 93047, 1, 93053, 93071, 1]));
    static Palmyrene = new C(new Uint32Array([67680, 67711, 1]));
    static Pau_Cin_Hau = new C(new Uint32Array([72384, 72440, 1]));
    static Phags_Pa = new C(new Uint32Array([43072, 43127, 1]));
    static Phoenician = new C(new Uint32Array([67840, 67867, 1, 67871, 67871, 1]));
    static Psalter_Pahlavi = new C(new Uint32Array([68480, 68497, 1, 68505, 68508, 1, 68521, 68527, 1]));
    static Rejang = new C(new Uint32Array([43312, 43347, 1, 43359, 43359, 1]));
    static Runic = new C(new Uint32Array([5792, 5866, 1, 5870, 5880, 1]));
    static Samaritan = new C(new Uint32Array([2048, 2093, 1, 2096, 2110, 1]));
    static Saurashtra = new C(new Uint32Array([43136, 43205, 1, 43214, 43225, 1]));
    static Sharada = new C(new Uint32Array([70016, 70111, 1]));
    static Shavian = new C(new Uint32Array([66640, 66687, 1]));
    static Siddham = new C(new Uint32Array([71040, 71093, 1, 71096, 71133, 1]));
    static SignWriting = new C(new Uint32Array([120832, 121483, 1, 121499, 121503, 1, 121505, 121519, 1]));
    static Sinhala = new C(new Uint32Array([3457, 3459, 1, 3461, 3478, 1, 3482, 3505, 1, 3507, 3515, 1, 3517, 3520, 3, 3521, 3526, 1, 3530, 3535, 5, 3536, 3540, 1, 3542, 3544, 2, 3545, 3551, 1, 3558, 3567, 1, 3570, 3572, 1, 70113, 70132, 1]));
    static Sogdian = new C(new Uint32Array([69424, 69465, 1]));
    static Sora_Sompeng = new C(new Uint32Array([69840, 69864, 1, 69872, 69881, 1]));
    static Soyombo = new C(new Uint32Array([72272, 72354, 1]));
    static Sundanese = new C(new Uint32Array([7040, 7103, 1, 7360, 7367, 1]));
    static Sunuwar = new C(new Uint32Array([72640, 72673, 1, 72688, 72697, 1]));
    static Syloti_Nagri = new C(new Uint32Array([43008, 43052, 1]));
    static Syriac = new C(new Uint32Array([1792, 1805, 1, 1807, 1866, 1, 1869, 1871, 1, 2144, 2154, 1]));
    static Tagalog = new C(new Uint32Array([5888, 5909, 1, 5919, 5919, 1]));
    static Tagbanwa = new C(new Uint32Array([5984, 5996, 1, 5998, 6e3, 1, 6002, 6003, 1]));
    static Tai_Le = new C(new Uint32Array([6480, 6509, 1, 6512, 6516, 1]));
    static Tai_Tham = new C(new Uint32Array([6688, 6750, 1, 6752, 6780, 1, 6783, 6793, 1, 6800, 6809, 1, 6816, 6829, 1]));
    static Tai_Viet = new C(new Uint32Array([43648, 43714, 1, 43739, 43743, 1]));
    static Takri = new C(new Uint32Array([71296, 71353, 1, 71360, 71369, 1]));
    static Tamil = new C(new Uint32Array([2946, 2947, 1, 2949, 2954, 1, 2958, 2960, 1, 2962, 2965, 1, 2969, 2970, 1, 2972, 2974, 2, 2975, 2979, 4, 2980, 2984, 4, 2985, 2986, 1, 2990, 3001, 1, 3006, 3010, 1, 3014, 3016, 1, 3018, 3021, 1, 3024, 3031, 7, 3046, 3066, 1, 73664, 73713, 1, 73727, 73727, 1]));
    static Tangsa = new C(new Uint32Array([92784, 92862, 1, 92864, 92873, 1]));
    static Tangut = new C(new Uint32Array([94176, 94208, 32, 94209, 100343, 1, 100352, 101119, 1, 101632, 101640, 1]));
    static Telugu = new C(new Uint32Array([3072, 3084, 1, 3086, 3088, 1, 3090, 3112, 1, 3114, 3129, 1, 3132, 3140, 1, 3142, 3144, 1, 3146, 3149, 1, 3157, 3158, 1, 3160, 3162, 1, 3165, 3168, 3, 3169, 3171, 1, 3174, 3183, 1, 3191, 3199, 1]));
    static Thaana = new C(new Uint32Array([1920, 1969, 1]));
    static Thai = new C(new Uint32Array([3585, 3642, 1, 3648, 3675, 1]));
    static Tibetan = new C(new Uint32Array([3840, 3911, 1, 3913, 3948, 1, 3953, 3991, 1, 3993, 4028, 1, 4030, 4044, 1, 4046, 4052, 1, 4057, 4058, 1]));
    static Tifinagh = new C(new Uint32Array([11568, 11623, 1, 11631, 11632, 1, 11647, 11647, 1]));
    static Tirhuta = new C(new Uint32Array([70784, 70855, 1, 70864, 70873, 1]));
    static Todhri = new C(new Uint32Array([67008, 67059, 1]));
    static Toto = new C(new Uint32Array([123536, 123566, 1]));
    static Tulu_Tigalari = new C(new Uint32Array([70528, 70537, 1, 70539, 70542, 3, 70544, 70581, 1, 70583, 70592, 1, 70594, 70597, 3, 70599, 70602, 1, 70604, 70613, 1, 70615, 70616, 1, 70625, 70626, 1]));
    static Ugaritic = new C(new Uint32Array([66432, 66461, 1, 66463, 66463, 1]));
    static Vai = new C(new Uint32Array([42240, 42539, 1]));
    static Vithkuqi = new C(new Uint32Array([66928, 66938, 1, 66940, 66954, 1, 66956, 66962, 1, 66964, 66965, 1, 66967, 66977, 1, 66979, 66993, 1, 66995, 67001, 1, 67003, 67004, 1]));
    static Wancho = new C(new Uint32Array([123584, 123641, 1, 123647, 123647, 1]));
    static Warang_Citi = new C(new Uint32Array([71840, 71922, 1, 71935, 71935, 1]));
    static Yezidi = new C(new Uint32Array([69248, 69289, 1, 69291, 69293, 1, 69296, 69297, 1]));
    static Yi = new C(new Uint32Array([40960, 42124, 1, 42128, 42182, 1]));
    static Zanabazar_Square = new C(new Uint32Array([72192, 72263, 1]));
    static CATEGORIES = /* @__PURE__ */ new Map([["C", e11.C], ["Cc", e11.Cc], ["Cf", e11.Cf], ["Co", e11.Co], ["Cs", e11.Cs], ["L", e11.L], ["Ll", e11.Ll], ["Lm", e11.Lm], ["Lo", e11.Lo], ["Lt", e11.Lt], ["Lu", e11.Lu], ["M", e11.M], ["Mc", e11.Mc], ["Me", e11.Me], ["Mn", e11.Mn], ["N", e11.N], ["Nd", e11.Nd], ["Nl", e11.Nl], ["No", e11.No], ["P", e11.P], ["Pc", e11.Pc], ["Pd", e11.Pd], ["Pe", e11.Pe], ["Pf", e11.Pf], ["Pi", e11.Pi], ["Po", e11.Po], ["Ps", e11.Ps], ["S", e11.S], ["Sc", e11.Sc], ["Sk", e11.Sk], ["Sm", e11.Sm], ["So", e11.So], ["Z", e11.Z], ["Zl", e11.Zl], ["Zp", e11.Zp], ["Zs", e11.Zs]]);
    static SCRIPTS = /* @__PURE__ */ new Map([["Adlam", e11.Adlam], ["Ahom", e11.Ahom], ["Anatolian_Hieroglyphs", e11.Anatolian_Hieroglyphs], ["Arabic", e11.Arabic], ["Armenian", e11.Armenian], ["Avestan", e11.Avestan], ["Balinese", e11.Balinese], ["Bamum", e11.Bamum], ["Bassa_Vah", e11.Bassa_Vah], ["Batak", e11.Batak], ["Bengali", e11.Bengali], ["Bhaiksuki", e11.Bhaiksuki], ["Bopomofo", e11.Bopomofo], ["Brahmi", e11.Brahmi], ["Braille", e11.Braille], ["Buginese", e11.Buginese], ["Buhid", e11.Buhid], ["Canadian_Aboriginal", e11.Canadian_Aboriginal], ["Carian", e11.Carian], ["Caucasian_Albanian", e11.Caucasian_Albanian], ["Chakma", e11.Chakma], ["Cham", e11.Cham], ["Cherokee", e11.Cherokee], ["Chorasmian", e11.Chorasmian], ["Common", e11.Common], ["Coptic", e11.Coptic], ["Cuneiform", e11.Cuneiform], ["Cypriot", e11.Cypriot], ["Cypro_Minoan", e11.Cypro_Minoan], ["Cyrillic", e11.Cyrillic], ["Deseret", e11.Deseret], ["Devanagari", e11.Devanagari], ["Dives_Akuru", e11.Dives_Akuru], ["Dogra", e11.Dogra], ["Duployan", e11.Duployan], ["Egyptian_Hieroglyphs", e11.Egyptian_Hieroglyphs], ["Elbasan", e11.Elbasan], ["Elymaic", e11.Elymaic], ["Ethiopic", e11.Ethiopic], ["Garay", e11.Garay], ["Georgian", e11.Georgian], ["Glagolitic", e11.Glagolitic], ["Gothic", e11.Gothic], ["Grantha", e11.Grantha], ["Greek", e11.Greek], ["Gujarati", e11.Gujarati], ["Gunjala_Gondi", e11.Gunjala_Gondi], ["Gurmukhi", e11.Gurmukhi], ["Gurung_Khema", e11.Gurung_Khema], ["Han", e11.Han], ["Hangul", e11.Hangul], ["Hanifi_Rohingya", e11.Hanifi_Rohingya], ["Hanunoo", e11.Hanunoo], ["Hatran", e11.Hatran], ["Hebrew", e11.Hebrew], ["Hiragana", e11.Hiragana], ["Imperial_Aramaic", e11.Imperial_Aramaic], ["Inherited", e11.Inherited], ["Inscriptional_Pahlavi", e11.Inscriptional_Pahlavi], ["Inscriptional_Parthian", e11.Inscriptional_Parthian], ["Javanese", e11.Javanese], ["Kaithi", e11.Kaithi], ["Kannada", e11.Kannada], ["Katakana", e11.Katakana], ["Kawi", e11.Kawi], ["Kayah_Li", e11.Kayah_Li], ["Kharoshthi", e11.Kharoshthi], ["Khitan_Small_Script", e11.Khitan_Small_Script], ["Khmer", e11.Khmer], ["Khojki", e11.Khojki], ["Khudawadi", e11.Khudawadi], ["Kirat_Rai", e11.Kirat_Rai], ["Lao", e11.Lao], ["Latin", e11.Latin], ["Lepcha", e11.Lepcha], ["Limbu", e11.Limbu], ["Linear_A", e11.Linear_A], ["Linear_B", e11.Linear_B], ["Lisu", e11.Lisu], ["Lycian", e11.Lycian], ["Lydian", e11.Lydian], ["Mahajani", e11.Mahajani], ["Makasar", e11.Makasar], ["Malayalam", e11.Malayalam], ["Mandaic", e11.Mandaic], ["Manichaean", e11.Manichaean], ["Marchen", e11.Marchen], ["Masaram_Gondi", e11.Masaram_Gondi], ["Medefaidrin", e11.Medefaidrin], ["Meetei_Mayek", e11.Meetei_Mayek], ["Mende_Kikakui", e11.Mende_Kikakui], ["Meroitic_Cursive", e11.Meroitic_Cursive], ["Meroitic_Hieroglyphs", e11.Meroitic_Hieroglyphs], ["Miao", e11.Miao], ["Modi", e11.Modi], ["Mongolian", e11.Mongolian], ["Mro", e11.Mro], ["Multani", e11.Multani], ["Myanmar", e11.Myanmar], ["Nabataean", e11.Nabataean], ["Nag_Mundari", e11.Nag_Mundari], ["Nandinagari", e11.Nandinagari], ["New_Tai_Lue", e11.New_Tai_Lue], ["Newa", e11.Newa], ["Nko", e11.Nko], ["Nushu", e11.Nushu], ["Nyiakeng_Puachue_Hmong", e11.Nyiakeng_Puachue_Hmong], ["Ogham", e11.Ogham], ["Ol_Chiki", e11.Ol_Chiki], ["Ol_Onal", e11.Ol_Onal], ["Old_Hungarian", e11.Old_Hungarian], ["Old_Italic", e11.Old_Italic], ["Old_North_Arabian", e11.Old_North_Arabian], ["Old_Permic", e11.Old_Permic], ["Old_Persian", e11.Old_Persian], ["Old_Sogdian", e11.Old_Sogdian], ["Old_South_Arabian", e11.Old_South_Arabian], ["Old_Turkic", e11.Old_Turkic], ["Old_Uyghur", e11.Old_Uyghur], ["Oriya", e11.Oriya], ["Osage", e11.Osage], ["Osmanya", e11.Osmanya], ["Pahawh_Hmong", e11.Pahawh_Hmong], ["Palmyrene", e11.Palmyrene], ["Pau_Cin_Hau", e11.Pau_Cin_Hau], ["Phags_Pa", e11.Phags_Pa], ["Phoenician", e11.Phoenician], ["Psalter_Pahlavi", e11.Psalter_Pahlavi], ["Rejang", e11.Rejang], ["Runic", e11.Runic], ["Samaritan", e11.Samaritan], ["Saurashtra", e11.Saurashtra], ["Sharada", e11.Sharada], ["Shavian", e11.Shavian], ["Siddham", e11.Siddham], ["SignWriting", e11.SignWriting], ["Sinhala", e11.Sinhala], ["Sogdian", e11.Sogdian], ["Sora_Sompeng", e11.Sora_Sompeng], ["Soyombo", e11.Soyombo], ["Sundanese", e11.Sundanese], ["Sunuwar", e11.Sunuwar], ["Syloti_Nagri", e11.Syloti_Nagri], ["Syriac", e11.Syriac], ["Tagalog", e11.Tagalog], ["Tagbanwa", e11.Tagbanwa], ["Tai_Le", e11.Tai_Le], ["Tai_Tham", e11.Tai_Tham], ["Tai_Viet", e11.Tai_Viet], ["Takri", e11.Takri], ["Tamil", e11.Tamil], ["Tangsa", e11.Tangsa], ["Tangut", e11.Tangut], ["Telugu", e11.Telugu], ["Thaana", e11.Thaana], ["Thai", e11.Thai], ["Tibetan", e11.Tibetan], ["Tifinagh", e11.Tifinagh], ["Tirhuta", e11.Tirhuta], ["Todhri", e11.Todhri], ["Toto", e11.Toto], ["Tulu_Tigalari", e11.Tulu_Tigalari], ["Ugaritic", e11.Ugaritic], ["Vai", e11.Vai], ["Vithkuqi", e11.Vithkuqi], ["Wancho", e11.Wancho], ["Warang_Citi", e11.Warang_Citi], ["Yezidi", e11.Yezidi], ["Yi", e11.Yi], ["Zanabazar_Square", e11.Zanabazar_Square]]);
    static FOLD_CATEGORIES = /* @__PURE__ */ new Map([["L", e11.foldL], ["Ll", e11.foldLl], ["Lt", e11.foldLt], ["Lu", e11.foldLu], ["M", e11.foldM], ["Mn", e11.foldMn]]);
    static FOLD_SCRIPT = /* @__PURE__ */ new Map([["Common", e11.foldCommon], ["Greek", e11.foldGreek], ["Inherited", e11.foldInherited]]);
    static Print = new C(new Uint32Array([33, 126, 1, 161, 172, 1, 174, 887, 1, 890, 895, 1, 900, 906, 1, 908, 910, 2, 911, 929, 1, 931, 1327, 1, 1329, 1366, 1, 1369, 1418, 1, 1421, 1423, 1, 1425, 1479, 1, 1488, 1514, 1, 1519, 1524, 1, 1542, 1563, 1, 1565, 1756, 1, 1758, 1805, 1, 1808, 1866, 1, 1869, 1969, 1, 1984, 2042, 1, 2045, 2093, 1, 2096, 2110, 1, 2112, 2139, 1, 2142, 2144, 2, 2145, 2154, 1, 2160, 2190, 1, 2199, 2273, 1, 2275, 2435, 1, 2437, 2444, 1, 2447, 2448, 1, 2451, 2472, 1, 2474, 2480, 1, 2482, 2486, 4, 2487, 2489, 1, 2492, 2500, 1, 2503, 2504, 1, 2507, 2510, 1, 2519, 2524, 5, 2525, 2527, 2, 2528, 2531, 1, 2534, 2558, 1, 2561, 2563, 1, 2565, 2570, 1, 2575, 2576, 1, 2579, 2600, 1, 2602, 2608, 1, 2610, 2611, 1, 2613, 2614, 1, 2616, 2617, 1, 2620, 2622, 2, 2623, 2626, 1, 2631, 2632, 1, 2635, 2637, 1, 2641, 2649, 8, 2650, 2652, 1, 2654, 2662, 8, 2663, 2678, 1, 2689, 2691, 1, 2693, 2701, 1, 2703, 2705, 1, 2707, 2728, 1, 2730, 2736, 1, 2738, 2739, 1, 2741, 2745, 1, 2748, 2757, 1, 2759, 2761, 1, 2763, 2765, 1, 2768, 2784, 16, 2785, 2787, 1, 2790, 2801, 1, 2809, 2815, 1, 2817, 2819, 1, 2821, 2828, 1, 2831, 2832, 1, 2835, 2856, 1, 2858, 2864, 1, 2866, 2867, 1, 2869, 2873, 1, 2876, 2884, 1, 2887, 2888, 1, 2891, 2893, 1, 2901, 2903, 1, 2908, 2909, 1, 2911, 2915, 1, 2918, 2935, 1, 2946, 2947, 1, 2949, 2954, 1, 2958, 2960, 1, 2962, 2965, 1, 2969, 2970, 1, 2972, 2974, 2, 2975, 2979, 4, 2980, 2984, 4, 2985, 2986, 1, 2990, 3001, 1, 3006, 3010, 1, 3014, 3016, 1, 3018, 3021, 1, 3024, 3031, 7, 3046, 3066, 1, 3072, 3084, 1, 3086, 3088, 1, 3090, 3112, 1, 3114, 3129, 1, 3132, 3140, 1, 3142, 3144, 1, 3146, 3149, 1, 3157, 3158, 1, 3160, 3162, 1, 3165, 3168, 3, 3169, 3171, 1, 3174, 3183, 1, 3191, 3212, 1, 3214, 3216, 1, 3218, 3240, 1, 3242, 3251, 1, 3253, 3257, 1, 3260, 3268, 1, 3270, 3272, 1, 3274, 3277, 1, 3285, 3286, 1, 3293, 3294, 1, 3296, 3299, 1, 3302, 3311, 1, 3313, 3315, 1, 3328, 3340, 1, 3342, 3344, 1, 3346, 3396, 1, 3398, 3400, 1, 3402, 3407, 1, 3412, 3427, 1, 3430, 3455, 1, 3457, 3459, 1, 3461, 3478, 1, 3482, 3505, 1, 3507, 3515, 1, 3517, 3520, 3, 3521, 3526, 1, 3530, 3535, 5, 3536, 3540, 1, 3542, 3544, 2, 3545, 3551, 1, 3558, 3567, 1, 3570, 3572, 1, 3585, 3642, 1, 3647, 3675, 1, 3713, 3714, 1, 3716, 3718, 2, 3719, 3722, 1, 3724, 3747, 1, 3749, 3751, 2, 3752, 3773, 1, 3776, 3780, 1, 3782, 3784, 2, 3785, 3790, 1, 3792, 3801, 1, 3804, 3807, 1, 3840, 3911, 1, 3913, 3948, 1, 3953, 3991, 1, 3993, 4028, 1, 4030, 4044, 1, 4046, 4058, 1, 4096, 4293, 1, 4295, 4301, 6, 4304, 4680, 1, 4682, 4685, 1, 4688, 4694, 1, 4696, 4698, 2, 4699, 4701, 1, 4704, 4744, 1, 4746, 4749, 1, 4752, 4784, 1, 4786, 4789, 1, 4792, 4798, 1, 4800, 4802, 2, 4803, 4805, 1, 4808, 4822, 1, 4824, 4880, 1, 4882, 4885, 1, 4888, 4954, 1, 4957, 4988, 1, 4992, 5017, 1, 5024, 5109, 1, 5112, 5117, 1, 5120, 5759, 1, 5761, 5788, 1, 5792, 5880, 1, 5888, 5909, 1, 5919, 5942, 1, 5952, 5971, 1, 5984, 5996, 1, 5998, 6e3, 1, 6002, 6003, 1, 6016, 6109, 1, 6112, 6121, 1, 6128, 6137, 1, 6144, 6157, 1, 6159, 6169, 1, 6176, 6264, 1, 6272, 6314, 1, 6320, 6389, 1, 6400, 6430, 1, 6432, 6443, 1, 6448, 6459, 1, 6464, 6468, 4, 6469, 6509, 1, 6512, 6516, 1, 6528, 6571, 1, 6576, 6601, 1, 6608, 6618, 1, 6622, 6683, 1, 6686, 6750, 1, 6752, 6780, 1, 6783, 6793, 1, 6800, 6809, 1, 6816, 6829, 1, 6832, 6862, 1, 6912, 6988, 1, 6990, 7155, 1, 7164, 7223, 1, 7227, 7241, 1, 7245, 7306, 1, 7312, 7354, 1, 7357, 7367, 1, 7376, 7418, 1, 7424, 7957, 1, 7960, 7965, 1, 7968, 8005, 1, 8008, 8013, 1, 8016, 8023, 1, 8025, 8031, 2, 8032, 8061, 1, 8064, 8116, 1, 8118, 8132, 1, 8134, 8147, 1, 8150, 8155, 1, 8157, 8175, 1, 8178, 8180, 1, 8182, 8190, 1, 8208, 8231, 1, 8240, 8286, 1, 8304, 8305, 1, 8308, 8334, 1, 8336, 8348, 1, 8352, 8384, 1, 8400, 8432, 1, 8448, 8587, 1, 8592, 9257, 1, 9280, 9290, 1, 9312, 11123, 1, 11126, 11157, 1, 11159, 11507, 1, 11513, 11557, 1, 11559, 11565, 6, 11568, 11623, 1, 11631, 11632, 1, 11647, 11670, 1, 11680, 11686, 1, 11688, 11694, 1, 11696, 11702, 1, 11704, 11710, 1, 11712, 11718, 1, 11720, 11726, 1, 11728, 11734, 1, 11736, 11742, 1, 11744, 11869, 1, 11904, 11929, 1, 11931, 12019, 1, 12032, 12245, 1, 12272, 12287, 1, 12289, 12351, 1, 12353, 12438, 1, 12441, 12543, 1, 12549, 12591, 1, 12593, 12686, 1, 12688, 12773, 1, 12783, 12830, 1, 12832, 42124, 1, 42128, 42182, 1, 42192, 42539, 1, 42560, 42743, 1, 42752, 42957, 1, 42960, 42961, 1, 42963, 42965, 2, 42966, 42972, 1, 42994, 43052, 1, 43056, 43065, 1, 43072, 43127, 1, 43136, 43205, 1, 43214, 43225, 1, 43232, 43347, 1, 43359, 43388, 1, 43392, 43469, 1, 43471, 43481, 1, 43486, 43518, 1, 43520, 43574, 1, 43584, 43597, 1, 43600, 43609, 1, 43612, 43714, 1, 43739, 43766, 1, 43777, 43782, 1, 43785, 43790, 1, 43793, 43798, 1, 43808, 43814, 1, 43816, 43822, 1, 43824, 43883, 1, 43888, 44013, 1, 44016, 44025, 1, 44032, 55203, 1, 55216, 55238, 1, 55243, 55291, 1, 63744, 64109, 1, 64112, 64217, 1, 64256, 64262, 1, 64275, 64279, 1, 64285, 64310, 1, 64312, 64316, 1, 64318, 64320, 2, 64321, 64323, 2, 64324, 64326, 2, 64327, 64450, 1, 64467, 64911, 1, 64914, 64967, 1, 64975, 65008, 33, 65009, 65049, 1, 65056, 65106, 1, 65108, 65126, 1, 65128, 65131, 1, 65136, 65140, 1, 65142, 65276, 1, 65281, 65470, 1, 65474, 65479, 1, 65482, 65487, 1, 65490, 65495, 1, 65498, 65500, 1, 65504, 65510, 1, 65512, 65518, 1, 65532, 65533, 1, 65536, 65547, 1, 65549, 65574, 1, 65576, 65594, 1, 65596, 65597, 1, 65599, 65613, 1, 65616, 65629, 1, 65664, 65786, 1, 65792, 65794, 1, 65799, 65843, 1, 65847, 65934, 1, 65936, 65948, 1, 65952, 66e3, 48, 66001, 66045, 1, 66176, 66204, 1, 66208, 66256, 1, 66272, 66299, 1, 66304, 66339, 1, 66349, 66378, 1, 66384, 66426, 1, 66432, 66461, 1, 66463, 66499, 1, 66504, 66517, 1, 66560, 66717, 1, 66720, 66729, 1, 66736, 66771, 1, 66776, 66811, 1, 66816, 66855, 1, 66864, 66915, 1, 66927, 66938, 1, 66940, 66954, 1, 66956, 66962, 1, 66964, 66965, 1, 66967, 66977, 1, 66979, 66993, 1, 66995, 67001, 1, 67003, 67004, 1, 67008, 67059, 1, 67072, 67382, 1, 67392, 67413, 1, 67424, 67431, 1, 67456, 67461, 1, 67463, 67504, 1, 67506, 67514, 1, 67584, 67589, 1, 67592, 67594, 2, 67595, 67637, 1, 67639, 67640, 1, 67644, 67647, 3, 67648, 67669, 1, 67671, 67742, 1, 67751, 67759, 1, 67808, 67826, 1, 67828, 67829, 1, 67835, 67867, 1, 67871, 67897, 1, 67903, 67968, 65, 67969, 68023, 1, 68028, 68047, 1, 68050, 68099, 1, 68101, 68102, 1, 68108, 68115, 1, 68117, 68119, 1, 68121, 68149, 1, 68152, 68154, 1, 68159, 68168, 1, 68176, 68184, 1, 68192, 68255, 1, 68288, 68326, 1, 68331, 68342, 1, 68352, 68405, 1, 68409, 68437, 1, 68440, 68466, 1, 68472, 68497, 1, 68505, 68508, 1, 68521, 68527, 1, 68608, 68680, 1, 68736, 68786, 1, 68800, 68850, 1, 68858, 68903, 1, 68912, 68921, 1, 68928, 68965, 1, 68969, 68997, 1, 69006, 69007, 1, 69216, 69246, 1, 69248, 69289, 1, 69291, 69293, 1, 69296, 69297, 1, 69314, 69316, 1, 69372, 69415, 1, 69424, 69465, 1, 69488, 69513, 1, 69552, 69579, 1, 69600, 69622, 1, 69632, 69709, 1, 69714, 69749, 1, 69759, 69820, 1, 69822, 69826, 1, 69840, 69864, 1, 69872, 69881, 1, 69888, 69940, 1, 69942, 69959, 1, 69968, 70006, 1, 70016, 70111, 1, 70113, 70132, 1, 70144, 70161, 1, 70163, 70209, 1, 70272, 70278, 1, 70280, 70282, 2, 70283, 70285, 1, 70287, 70301, 1, 70303, 70313, 1, 70320, 70378, 1, 70384, 70393, 1, 70400, 70403, 1, 70405, 70412, 1, 70415, 70416, 1, 70419, 70440, 1, 70442, 70448, 1, 70450, 70451, 1, 70453, 70457, 1, 70459, 70468, 1, 70471, 70472, 1, 70475, 70477, 1, 70480, 70487, 7, 70493, 70499, 1, 70502, 70508, 1, 70512, 70516, 1, 70528, 70537, 1, 70539, 70542, 3, 70544, 70581, 1, 70583, 70592, 1, 70594, 70597, 3, 70599, 70602, 1, 70604, 70613, 1, 70615, 70616, 1, 70625, 70626, 1, 70656, 70747, 1, 70749, 70753, 1, 70784, 70855, 1, 70864, 70873, 1, 71040, 71093, 1, 71096, 71133, 1, 71168, 71236, 1, 71248, 71257, 1, 71264, 71276, 1, 71296, 71353, 1, 71360, 71369, 1, 71376, 71395, 1, 71424, 71450, 1, 71453, 71467, 1, 71472, 71494, 1, 71680, 71739, 1, 71840, 71922, 1, 71935, 71942, 1, 71945, 71948, 3, 71949, 71955, 1, 71957, 71958, 1, 71960, 71989, 1, 71991, 71992, 1, 71995, 72006, 1, 72016, 72025, 1, 72096, 72103, 1, 72106, 72151, 1, 72154, 72164, 1, 72192, 72263, 1, 72272, 72354, 1, 72368, 72440, 1, 72448, 72457, 1, 72640, 72673, 1, 72688, 72697, 1, 72704, 72712, 1, 72714, 72758, 1, 72760, 72773, 1, 72784, 72812, 1, 72816, 72847, 1, 72850, 72871, 1, 72873, 72886, 1, 72960, 72966, 1, 72968, 72969, 1, 72971, 73014, 1, 73018, 73020, 2, 73021, 73023, 2, 73024, 73031, 1, 73040, 73049, 1, 73056, 73061, 1, 73063, 73064, 1, 73066, 73102, 1, 73104, 73105, 1, 73107, 73112, 1, 73120, 73129, 1, 73440, 73464, 1, 73472, 73488, 1, 73490, 73530, 1, 73534, 73562, 1, 73648, 73664, 16, 73665, 73713, 1, 73727, 74649, 1, 74752, 74862, 1, 74864, 74868, 1, 74880, 75075, 1, 77712, 77810, 1, 77824, 78895, 1, 78912, 78933, 1, 78944, 82938, 1, 82944, 83526, 1, 90368, 90425, 1, 92160, 92728, 1, 92736, 92766, 1, 92768, 92777, 1, 92782, 92862, 1, 92864, 92873, 1, 92880, 92909, 1, 92912, 92917, 1, 92928, 92997, 1, 93008, 93017, 1, 93019, 93025, 1, 93027, 93047, 1, 93053, 93071, 1, 93504, 93561, 1, 93760, 93850, 1, 93952, 94026, 1, 94031, 94087, 1, 94095, 94111, 1, 94176, 94180, 1, 94192, 94193, 1, 94208, 100343, 1, 100352, 101589, 1, 101631, 101640, 1, 110576, 110579, 1, 110581, 110587, 1, 110589, 110590, 1, 110592, 110882, 1, 110898, 110928, 30, 110929, 110930, 1, 110933, 110948, 15, 110949, 110951, 1, 110960, 111355, 1, 113664, 113770, 1, 113776, 113788, 1, 113792, 113800, 1, 113808, 113817, 1, 113820, 113823, 1, 117760, 118009, 1, 118016, 118451, 1, 118528, 118573, 1, 118576, 118598, 1, 118608, 118723, 1, 118784, 119029, 1, 119040, 119078, 1, 119081, 119154, 1, 119163, 119274, 1, 119296, 119365, 1, 119488, 119507, 1, 119520, 119539, 1, 119552, 119638, 1, 119648, 119672, 1, 119808, 119892, 1, 119894, 119964, 1, 119966, 119967, 1, 119970, 119973, 3, 119974, 119977, 3, 119978, 119980, 1, 119982, 119993, 1, 119995, 119997, 2, 119998, 120003, 1, 120005, 120069, 1, 120071, 120074, 1, 120077, 120084, 1, 120086, 120092, 1, 120094, 120121, 1, 120123, 120126, 1, 120128, 120132, 1, 120134, 120138, 4, 120139, 120144, 1, 120146, 120485, 1, 120488, 120779, 1, 120782, 121483, 1, 121499, 121503, 1, 121505, 121519, 1, 122624, 122654, 1, 122661, 122666, 1, 122880, 122886, 1, 122888, 122904, 1, 122907, 122913, 1, 122915, 122916, 1, 122918, 122922, 1, 122928, 122989, 1, 123023, 123136, 113, 123137, 123180, 1, 123184, 123197, 1, 123200, 123209, 1, 123214, 123215, 1, 123536, 123566, 1, 123584, 123641, 1, 123647, 124112, 465, 124113, 124153, 1, 124368, 124410, 1, 124415, 124896, 481, 124897, 124902, 1, 124904, 124907, 1, 124909, 124910, 1, 124912, 124926, 1, 124928, 125124, 1, 125127, 125142, 1, 125184, 125259, 1, 125264, 125273, 1, 125278, 125279, 1, 126065, 126132, 1, 126209, 126269, 1, 126464, 126467, 1, 126469, 126495, 1, 126497, 126498, 1, 126500, 126503, 3, 126505, 126514, 1, 126516, 126519, 1, 126521, 126523, 2, 126530, 126535, 5, 126537, 126541, 2, 126542, 126543, 1, 126545, 126546, 1, 126548, 126551, 3, 126553, 126561, 2, 126562, 126564, 2, 126567, 126570, 1, 126572, 126578, 1, 126580, 126583, 1, 126585, 126588, 1, 126590, 126592, 2, 126593, 126601, 1, 126603, 126619, 1, 126625, 126627, 1, 126629, 126633, 1, 126635, 126651, 1, 126704, 126705, 1, 126976, 127019, 1, 127024, 127123, 1, 127136, 127150, 1, 127153, 127167, 1, 127169, 127183, 1, 127185, 127221, 1, 127232, 127405, 1, 127462, 127490, 1, 127504, 127547, 1, 127552, 127560, 1, 127568, 127569, 1, 127584, 127589, 1, 127744, 128727, 1, 128732, 128748, 1, 128752, 128764, 1, 128768, 128886, 1, 128891, 128985, 1, 128992, 129003, 1, 129008, 129024, 16, 129025, 129035, 1, 129040, 129095, 1, 129104, 129113, 1, 129120, 129159, 1, 129168, 129197, 1, 129200, 129211, 1, 129216, 129217, 1, 129280, 129619, 1, 129632, 129645, 1, 129648, 129660, 1, 129664, 129673, 1, 129679, 129734, 1, 129742, 129756, 1, 129759, 129769, 1, 129776, 129784, 1, 129792, 129938, 1, 129940, 130041, 1, 131072, 173791, 1, 173824, 177977, 1, 177984, 178205, 1, 178208, 183969, 1, 183984, 191456, 1, 191472, 192093, 1, 194560, 195101, 1, 196608, 201546, 1, 201552, 205743, 1, 917760, 917999, 1]));
  }, he = class {
    static MAX_RUNE = 1114111;
    static MAX_ASCII = 127;
    static MAX_LATIN1 = 255;
    static MAX_BMP = 65535;
    static MIN_FOLD = 65;
    static MAX_FOLD = 125251;
    static is32(t10, n10) {
      let r10 = 0, s10 = t10.length;
      for (; r10 < s10; ) {
        let i10 = r10 + Math.floor((s10 - r10) / 2), o10 = t10.getLo(i10), a = t10.getHi(i10);
        if (o10 <= n10 && n10 <= a) {
          let l = t10.getStride(i10);
          return (n10 - o10) % l === 0;
        }
        n10 < o10 ? s10 = i10 : r10 = i10 + 1;
      }
      return false;
    }
    static is(t10, n10) {
      if (n10 <= this.MAX_LATIN1) {
        for (let r10 = 0; r10 < t10.length; r10++) {
          let s10 = t10.getHi(r10);
          if (n10 > s10)
            continue;
          let i10 = t10.getLo(r10);
          if (n10 < i10)
            return false;
          let o10 = t10.getStride(r10);
          return (n10 - i10) % o10 === 0;
        }
        return false;
      }
      return t10.length > 0 && n10 >= t10.getLo(0) && this.is32(t10, n10);
    }
    static isUpper(t10) {
      if (t10 <= this.MAX_LATIN1) {
        let n10 = String.fromCodePoint(t10);
        return n10.toUpperCase() === n10 && n10.toLowerCase() !== n10;
      }
      return this.is(Gt.Upper, t10);
    }
    static isPrint(t10) {
      return t10 <= this.MAX_LATIN1 ? t10 >= 32 && t10 < this.MAX_ASCII || t10 >= 161 && t10 !== 173 : this.is(Gt.Print, t10);
    }
    static simpleFold(t10) {
      if (Gt.CASE_ORBIT.has(t10))
        return Gt.CASE_ORBIT.get(t10);
      let n10 = D.toLowerCase(t10);
      return n10 !== t10 ? n10 : D.toUpperCase(t10);
    }
    static equalsIgnoreCase(t10, n10) {
      if (t10 < 0 || n10 < 0 || t10 === n10)
        return true;
      if (t10 <= this.MAX_ASCII && n10 <= this.MAX_ASCII)
        return D.CODES.get("A") <= t10 && t10 <= D.CODES.get("Z") && (t10 |= 32), D.CODES.get("A") <= n10 && n10 <= D.CODES.get("Z") && (n10 |= 32), t10 === n10;
      for (let r10 = this.simpleFold(t10); r10 !== t10; r10 = this.simpleFold(r10))
        if (r10 === n10)
          return true;
      return false;
    }
  }, Ne = class {
    static METACHARACTERS = "\\.+*?()|[]{}^$";
    static EMPTY_BEGIN_LINE = 1;
    static EMPTY_END_LINE = 2;
    static EMPTY_BEGIN_TEXT = 4;
    static EMPTY_END_TEXT = 8;
    static EMPTY_WORD_BOUNDARY = 16;
    static EMPTY_NO_WORD_BOUNDARY = 32;
    static EMPTY_ALL = -1;
    static emptyInts() {
      return [];
    }
    static isalnum(t10) {
      return D.CODES.get("0") <= t10 && t10 <= D.CODES.get("9") || D.CODES.get("a") <= t10 && t10 <= D.CODES.get("z") || D.CODES.get("A") <= t10 && t10 <= D.CODES.get("Z");
    }
    static unhex(t10) {
      return D.CODES.get("0") <= t10 && t10 <= D.CODES.get("9") ? t10 - D.CODES.get("0") : D.CODES.get("a") <= t10 && t10 <= D.CODES.get("f") ? t10 - D.CODES.get("a") + 10 : D.CODES.get("A") <= t10 && t10 <= D.CODES.get("F") ? t10 - D.CODES.get("A") + 10 : -1;
    }
    static escapeRune(t10) {
      let n10 = "";
      if (he.isPrint(t10))
        this.METACHARACTERS.indexOf(String.fromCodePoint(t10)) >= 0 && (n10 += "\\"), n10 += String.fromCodePoint(t10);
      else
        switch (t10) {
          case D.CODES.get('"'):
            n10 += '\\"';
            break;
          case D.CODES.get("\\"):
            n10 += "\\\\";
            break;
          case D.CODES.get("	"):
            n10 += "\\t";
            break;
          case D.CODES.get(`
`):
            n10 += "\\n";
            break;
          case D.CODES.get("\r"):
            n10 += "\\r";
            break;
          case D.CODES.get("\b"):
            n10 += "\\b";
            break;
          case D.CODES.get("\f"):
            n10 += "\\f";
            break;
          default: {
            let r10 = t10.toString(16);
            t10 < 256 ? (n10 += "\\x", r10.length === 1 && (n10 += "0"), n10 += r10) : n10 += `\\x{${r10}}`;
            break;
          }
        }
      return n10;
    }
    static stringToRunes(t10) {
      return String(t10).split("").map((n10) => n10.codePointAt(0));
    }
    static runeToString(t10) {
      return String.fromCodePoint(t10);
    }
    static isWordRune(t10) {
      return D.CODES.get("a") <= t10 && t10 <= D.CODES.get("z") || D.CODES.get("A") <= t10 && t10 <= D.CODES.get("Z") || D.CODES.get("0") <= t10 && t10 <= D.CODES.get("9") || t10 === D.CODES.get("_");
    }
    static emptyOpContext(t10, n10) {
      let r10 = 0;
      return t10 < 0 && (r10 |= this.EMPTY_BEGIN_TEXT | this.EMPTY_BEGIN_LINE), t10 === D.CODES.get(`
`) && (r10 |= this.EMPTY_BEGIN_LINE), n10 < 0 && (r10 |= this.EMPTY_END_TEXT | this.EMPTY_END_LINE), n10 === D.CODES.get(`
`) && (r10 |= this.EMPTY_END_LINE), this.isWordRune(t10) !== this.isWordRune(n10) ? r10 |= this.EMPTY_WORD_BOUNDARY : r10 |= this.EMPTY_NO_WORD_BOUNDARY, r10;
    }
    static quoteMeta(t10) {
      return t10.split("").map((n10) => this.METACHARACTERS.indexOf(n10) >= 0 ? `\\${n10}` : n10).join("");
    }
    static charCount(t10) {
      return t10 > he.MAX_BMP ? 2 : 1;
    }
    static stringToUtf8ByteArray(t10) {
      if (globalThis.TextEncoder)
        return Array.from(new TextEncoder().encode(t10));
      {
        let n10 = [], r10 = 0;
        for (let s10 = 0; s10 < t10.length; s10++) {
          let i10 = t10.charCodeAt(s10);
          i10 < 128 ? n10[r10++] = i10 : i10 < 2048 ? (n10[r10++] = i10 >> 6 | 192, n10[r10++] = i10 & 63 | 128) : (i10 & 64512) === 55296 && s10 + 1 < t10.length && (t10.charCodeAt(s10 + 1) & 64512) === 56320 ? (i10 = 65536 + ((i10 & 1023) << 10) + (t10.charCodeAt(++s10) & 1023), n10[r10++] = i10 >> 18 | 240, n10[r10++] = i10 >> 12 & 63 | 128, n10[r10++] = i10 >> 6 & 63 | 128, n10[r10++] = i10 & 63 | 128) : (n10[r10++] = i10 >> 12 | 224, n10[r10++] = i10 >> 6 & 63 | 128, n10[r10++] = i10 & 63 | 128);
        }
        return n10;
      }
    }
    static utf8ByteArrayToString(t10) {
      if (globalThis.TextDecoder)
        return new TextDecoder("utf-8").decode(new Uint8Array(t10));
      {
        let n10 = [], r10 = 0, s10 = 0;
        for (; r10 < t10.length; ) {
          let i10 = t10[r10++];
          if (i10 < 128)
            n10[s10++] = String.fromCharCode(i10);
          else if (i10 > 191 && i10 < 224) {
            let o10 = t10[r10++];
            n10[s10++] = String.fromCharCode((i10 & 31) << 6 | o10 & 63);
          } else if (i10 > 239 && i10 < 365) {
            let o10 = t10[r10++], a = t10[r10++], l = t10[r10++], c = ((i10 & 7) << 18 | (o10 & 63) << 12 | (a & 63) << 6 | l & 63) - 65536;
            n10[s10++] = String.fromCharCode(55296 + (c >> 10)), n10[s10++] = String.fromCharCode(56320 + (c & 1023));
          } else {
            let o10 = t10[r10++], a = t10[r10++];
            n10[s10++] = String.fromCharCode((i10 & 15) << 12 | (o10 & 63) << 6 | a & 63);
          }
        }
        return n10.join("");
      }
    }
  }, vf = (e11 = [], t10 = 0) => {
    let n10 = {};
    for (let r10 = 0; r10 < e11.length; r10++) {
      let s10 = e11[r10], i10 = t10 + r10;
      n10[s10] = i10, n10[i10] = s10;
    }
    return Object.freeze(n10);
  }, vn = class e11 {
    static Encoding = vf(["UTF_16", "UTF_8"]);
    getEncoding() {
      throw Error("not implemented");
    }
    isUTF8Encoding() {
      return this.getEncoding() === e11.Encoding.UTF_8;
    }
    isUTF16Encoding() {
      return this.getEncoding() === e11.Encoding.UTF_16;
    }
  }, Gs = class extends vn {
    constructor(t10 = null) {
      super(), this.bytes = t10;
    }
    getEncoding() {
      return vn.Encoding.UTF_8;
    }
    asCharSequence() {
      return Ne.utf8ByteArrayToString(this.bytes);
    }
    asBytes() {
      return this.bytes;
    }
    length() {
      return this.bytes.length;
    }
  }, Lo = class extends vn {
    constructor(t10 = null) {
      super(), this.charSequence = t10;
    }
    getEncoding() {
      return vn.Encoding.UTF_16;
    }
    asCharSequence() {
      return this.charSequence;
    }
    asBytes() {
      return this.charSequence.toString().split("").map((t10) => t10.codePointAt(0));
    }
    length() {
      return this.charSequence.length;
    }
  }, hr = class {
    static utf16(t10) {
      return new Lo(t10);
    }
    static utf8(t10) {
      return Array.isArray(t10) ? new Gs(t10) : new Gs(Ne.stringToUtf8ByteArray(t10));
    }
  }, dr = class extends Error {
    constructor(t10) {
      super(t10), this.name = "RE2JSException";
    }
  }, De = class extends dr {
    constructor(t10, n10 = null) {
      let r10 = `error parsing regexp: ${t10}`;
      n10 && (r10 += `: \`${n10}\``), super(r10), this.name = "RE2JSSyntaxException", this.message = r10, this.error = t10, this.input = n10;
    }
    getDescription() {
      return this.error;
    }
    getPattern() {
      return this.input;
    }
  }, Fo = class extends dr {
    constructor(t10) {
      super(t10), this.name = "RE2JSCompileException";
    }
  }, Xt = class extends dr {
    constructor(t10) {
      super(t10), this.name = "RE2JSGroupException";
    }
  }, Mo = class extends dr {
    constructor(t10) {
      super(t10), this.name = "RE2JSFlagsException";
    }
  }, Uo = class {
    static quoteReplacement(t10) {
      return t10.indexOf("\\") < 0 && t10.indexOf("$") < 0 ? t10 : t10.split("").map((n10) => {
        let r10 = n10.codePointAt(0);
        return r10 === D.CODES["\\"] || r10 === D.CODES.$ ? `\\${n10}` : n10;
      }).join("");
    }
    constructor(t10, n10) {
      if (t10 === null)
        throw new Error("pattern is null");
      this.patternInput = t10;
      let r10 = this.patternInput.re2();
      this.patternGroupCount = r10.numberOfCapturingGroups(), this.groups = [], this.namedGroups = r10.namedGroups, this.numberOfInstructions = r10.numberOfInstructions(), n10 instanceof vn ? this.resetMatcherInput(n10) : Array.isArray(n10) ? this.resetMatcherInput(hr.utf8(n10)) : this.resetMatcherInput(hr.utf16(n10));
    }
    pattern() {
      return this.patternInput;
    }
    reset() {
      return this.matcherInputLength = this.matcherInput.length(), this.appendPos = 0, this.hasMatch = false, this.hasGroups = false, this.anchorFlag = 0, this;
    }
    resetMatcherInput(t10) {
      if (t10 === null)
        throw new Error("input is null");
      return this.matcherInput = t10, this.reset(), this;
    }
    start(t10 = 0) {
      if (typeof t10 == "string") {
        let n10 = this.namedGroups[t10];
        if (!Number.isFinite(n10))
          throw new Xt(`group '${t10}' not found`);
        t10 = n10;
      }
      return this.loadGroup(t10), this.groups[2 * t10];
    }
    end(t10 = 0) {
      if (typeof t10 == "string") {
        let n10 = this.namedGroups[t10];
        if (!Number.isFinite(n10))
          throw new Xt(`group '${t10}' not found`);
        t10 = n10;
      }
      return this.loadGroup(t10), this.groups[2 * t10 + 1];
    }
    programSize() {
      return this.numberOfInstructions;
    }
    group(t10 = 0) {
      if (typeof t10 == "string") {
        let s10 = this.namedGroups[t10];
        if (!Number.isFinite(s10))
          throw new Xt(`group '${t10}' not found`);
        t10 = s10;
      }
      let n10 = this.start(t10), r10 = this.end(t10);
      return n10 < 0 && r10 < 0 ? null : this.substring(n10, r10);
    }
    groupCount() {
      return this.patternGroupCount;
    }
    loadGroup(t10) {
      if (t10 < 0 || t10 > this.patternGroupCount)
        throw new Xt(`Group index out of bounds: ${t10}`);
      if (!this.hasMatch)
        throw new Xt("perhaps no match attempted");
      if (t10 === 0 || this.hasGroups)
        return;
      let n10 = this.groups[1] + 1;
      n10 > this.matcherInputLength && (n10 = this.matcherInputLength);
      let r10 = this.patternInput.re2().matchMachineInput(this.matcherInput, this.groups[0], n10, this.anchorFlag, 1 + this.patternGroupCount);
      if (!r10[0])
        throw new Xt("inconsistency in matching group data");
      this.groups = r10[1], this.hasGroups = true;
    }
    matches() {
      return this.genMatch(0, K.ANCHOR_BOTH);
    }
    lookingAt() {
      return this.genMatch(0, K.ANCHOR_START);
    }
    find(t10 = null) {
      if (t10 !== null) {
        if (t10 < 0 || t10 > this.matcherInputLength)
          throw new Xt(`start index out of bounds: ${t10}`);
        return this.reset(), this.genMatch(t10, 0);
      }
      return t10 = 0, this.hasMatch && (t10 = this.groups[1], this.groups[0] === this.groups[1] && t10++), this.genMatch(t10, K.UNANCHORED);
    }
    genMatch(t10, n10) {
      let r10 = this.patternInput.re2().matchMachineInput(this.matcherInput, t10, this.matcherInputLength, n10, 1);
      return r10[0] ? (this.groups = r10[1], this.hasMatch = true, this.hasGroups = false, this.anchorFlag = n10, true) : false;
    }
    substring(t10, n10) {
      return this.matcherInput.isUTF8Encoding() ? Ne.utf8ByteArrayToString(this.matcherInput.asBytes().slice(t10, n10)) : this.matcherInput.asCharSequence().substring(t10, n10).toString();
    }
    inputLength() {
      return this.matcherInputLength;
    }
    appendReplacement(t10, n10 = false) {
      let r10 = "", s10 = this.start(), i10 = this.end();
      return this.appendPos < s10 && (r10 += this.substring(this.appendPos, s10)), this.appendPos = i10, r10 += n10 ? this.appendReplacementInternalPerl(t10) : this.appendReplacementInternal(t10), r10;
    }
    appendReplacementInternal(t10) {
      let n10 = "", r10 = 0, s10 = t10.length;
      for (let i10 = 0; i10 < s10 - 1; i10++) {
        if (t10.codePointAt(i10) === D.CODES.get("\\")) {
          r10 < i10 && (n10 += t10.substring(r10, i10)), i10++, r10 = i10;
          continue;
        }
        if (t10.codePointAt(i10) === D.CODES.get("$")) {
          let o10 = t10.codePointAt(i10 + 1);
          if (D.CODES.get("0") <= o10 && o10 <= D.CODES.get("9")) {
            let a = o10 - D.CODES.get("0");
            for (r10 < i10 && (n10 += t10.substring(r10, i10)), i10 += 2; i10 < s10 && (o10 = t10.codePointAt(i10), !(o10 < D.CODES.get("0") || o10 > D.CODES.get("9") || a * 10 + o10 - D.CODES.get("0") > this.patternGroupCount)); i10++)
              a = a * 10 + o10 - D.CODES.get("0");
            if (a > this.patternGroupCount)
              throw new Xt(`n > number of groups: ${a}`);
            let l = this.group(a);
            l !== null && (n10 += l), r10 = i10, i10--;
            continue;
          } else if (o10 === D.CODES.get("{")) {
            r10 < i10 && (n10 += t10.substring(r10, i10)), i10++;
            let a = i10 + 1;
            for (; a < t10.length && t10.codePointAt(a) !== D.CODES.get("}") && t10.codePointAt(a) !== D.CODES.get(" "); )
              a++;
            if (a === t10.length || t10.codePointAt(a) !== D.CODES.get("}"))
              throw new Xt("named capture group is missing trailing '}'");
            let l = t10.substring(i10 + 1, a);
            n10 += this.group(l), r10 = a + 1;
          }
        }
      }
      return r10 < s10 && (n10 += t10.substring(r10, s10)), n10;
    }
    appendReplacementInternalPerl(t10) {
      let n10 = "", r10 = 0, s10 = t10.length;
      for (let i10 = 0; i10 < s10 - 1; i10++)
        if (t10.codePointAt(i10) === D.CODES.get("$")) {
          let o10 = t10.codePointAt(i10 + 1);
          if (D.CODES.get("$") === o10) {
            r10 < i10 && (n10 += t10.substring(r10, i10)), n10 += "$", i10++, r10 = i10 + 1;
            continue;
          } else if (D.CODES.get("&") === o10) {
            r10 < i10 && (n10 += t10.substring(r10, i10));
            let a = this.group(0);
            a !== null ? n10 += a : n10 += "$&", i10++, r10 = i10 + 1;
            continue;
          } else if (D.CODES.get("1") <= o10 && o10 <= D.CODES.get("9")) {
            let a = o10 - D.CODES.get("0");
            for (r10 < i10 && (n10 += t10.substring(r10, i10)), i10 += 2; i10 < s10 && (o10 = t10.codePointAt(i10), !(o10 < D.CODES.get("0") || o10 > D.CODES.get("9") || a * 10 + o10 - D.CODES.get("0") > this.patternGroupCount)); i10++)
              a = a * 10 + o10 - D.CODES.get("0");
            if (a > this.patternGroupCount) {
              n10 += `$${a}`, r10 = i10, i10--;
              continue;
            }
            let l = this.group(a);
            l !== null && (n10 += l), r10 = i10, i10--;
            continue;
          } else if (o10 === D.CODES.get("<")) {
            r10 < i10 && (n10 += t10.substring(r10, i10)), i10++;
            let a = i10 + 1;
            for (; a < t10.length && t10.codePointAt(a) !== D.CODES.get(">") && t10.codePointAt(a) !== D.CODES.get(" "); )
              a++;
            if (a === t10.length || t10.codePointAt(a) !== D.CODES.get(">")) {
              n10 += t10.substring(i10 - 1, a + 1), r10 = a + 1;
              continue;
            }
            let l = t10.substring(i10 + 1, a);
            Object.prototype.hasOwnProperty.call(this.namedGroups, l) ? n10 += this.group(l) : n10 += `$<${l}>`, r10 = a + 1;
          }
        }
      return r10 < s10 && (n10 += t10.substring(r10, s10)), n10;
    }
    appendTail() {
      return this.substring(this.appendPos, this.matcherInputLength);
    }
    replaceAll(t10, n10 = false) {
      return this.replace(t10, true, n10);
    }
    replaceFirst(t10, n10 = false) {
      return this.replace(t10, false, n10);
    }
    replace(t10, n10 = true, r10 = false) {
      let s10 = "";
      for (this.reset(); this.find() && (s10 += this.appendReplacement(t10, r10), !!n10); )
        ;
      return s10 += this.appendTail(), s10;
    }
  }, cn = class {
    static EOF() {
      return -8;
    }
    canCheckPrefix() {
      return true;
    }
    endPos() {
      return this.end;
    }
  }, Wo = class extends cn {
    constructor(t10, n10 = 0, r10 = t10.length) {
      super(), this.bytes = t10, this.start = n10, this.end = r10;
    }
    step(t10) {
      if (t10 += this.start, t10 >= this.end)
        return cn.EOF();
      let n10 = this.bytes[t10++] & 255;
      return (n10 & 128) === 0 ? n10 << 3 | 1 : (n10 & 224) === 192 ? (n10 = n10 & 31, t10 >= this.end ? cn.EOF() : (n10 = n10 << 6 | this.bytes[t10++] & 63, n10 << 3 | 2)) : (n10 & 240) === 224 ? (n10 = n10 & 15, t10 + 1 >= this.end ? cn.EOF() : (n10 = n10 << 6 | this.bytes[t10++] & 63, n10 = n10 << 6 | this.bytes[t10++] & 63, n10 << 3 | 3)) : (n10 = n10 & 7, t10 + 2 >= this.end ? cn.EOF() : (n10 = n10 << 6 | this.bytes[t10++] & 63, n10 = n10 << 6 | this.bytes[t10++] & 63, n10 = n10 << 6 | this.bytes[t10++] & 63, n10 << 3 | 4));
    }
    index(t10, n10) {
      n10 += this.start;
      let r10 = this.indexOf(this.bytes, t10.prefixUTF8, n10);
      return r10 < 0 ? r10 : r10 - n10;
    }
    context(t10) {
      t10 += this.start;
      let n10 = -1;
      if (t10 > this.start && t10 <= this.end) {
        let s10 = t10 - 1;
        if (n10 = this.bytes[s10--], n10 >= 128) {
          let i10 = t10 - 4;
          for (i10 < this.start && (i10 = this.start); s10 >= i10 && (this.bytes[s10] & 192) === 128; )
            s10--;
          s10 < this.start && (s10 = this.start), n10 = this.step(s10) >> 3;
        }
      }
      let r10 = t10 < this.end ? this.step(t10) >> 3 : -1;
      return Ne.emptyOpContext(n10, r10);
    }
    indexOf(t10, n10, r10 = 0) {
      let s10 = n10.length;
      if (s10 === 0)
        return -1;
      let i10 = t10.length;
      for (let o10 = r10; o10 <= i10 - s10; o10++)
        for (let a = 0; a < s10 && t10[o10 + a] === n10[a]; a++)
          if (a === s10 - 1)
            return o10;
      return -1;
    }
  }, Bo = class extends cn {
    constructor(t10, n10 = 0, r10 = t10.length) {
      super(), this.charSequence = t10, this.start = n10, this.end = r10;
    }
    step(t10) {
      if (t10 += this.start, t10 < this.end) {
        let n10 = this.charSequence.codePointAt(t10);
        return n10 << 3 | Ne.charCount(n10);
      } else
        return cn.EOF();
    }
    index(t10, n10) {
      n10 += this.start;
      let r10 = this.charSequence.indexOf(t10.prefix, n10);
      return r10 < 0 ? r10 : r10 - n10;
    }
    context(t10) {
      t10 += this.start;
      let n10 = t10 > 0 && t10 <= this.charSequence.length ? this.charSequence.codePointAt(t10 - 1) : -1, r10 = t10 < this.charSequence.length ? this.charSequence.codePointAt(t10) : -1;
      return Ne.emptyOpContext(n10, r10);
    }
  }, je = class {
    static fromUTF8(t10, n10 = 0, r10 = t10.length) {
      return new Wo(t10, n10, r10);
    }
    static fromUTF16(t10, n10 = 0, r10 = t10.length) {
      return new Bo(t10, n10, r10);
    }
  }, we = class e11 {
    static ALT = 1;
    static ALT_MATCH = 2;
    static CAPTURE = 3;
    static EMPTY_WIDTH = 4;
    static FAIL = 5;
    static MATCH = 6;
    static NOP = 7;
    static RUNE = 8;
    static RUNE1 = 9;
    static RUNE_ANY = 10;
    static RUNE_ANY_NOT_NL = 11;
    static isRuneOp(t10) {
      return e11.RUNE <= t10 && t10 <= e11.RUNE_ANY_NOT_NL;
    }
    static escapeRunes(t10) {
      let n10 = '"';
      for (let r10 of t10)
        n10 += Ne.escapeRune(r10);
      return n10 += '"', n10;
    }
    constructor(t10) {
      this.op = t10, this.out = 0, this.arg = 0, this.runes = [];
    }
    matchRune(t10) {
      if (this.runes.length === 1) {
        let s10 = this.runes[0];
        return (this.arg & K.FOLD_CASE) !== 0 ? he.equalsIgnoreCase(s10, t10) : t10 === s10;
      }
      for (let s10 = 0; s10 < this.runes.length && s10 <= 8; s10 += 2) {
        if (t10 < this.runes[s10])
          return false;
        if (t10 <= this.runes[s10 + 1])
          return true;
      }
      let n10 = 0, r10 = this.runes.length / 2 | 0;
      for (; n10 < r10; ) {
        let s10 = n10 + ((r10 - n10) / 2 | 0);
        if (this.runes[2 * s10] <= t10) {
          if (t10 <= this.runes[2 * s10 + 1])
            return true;
          n10 = s10 + 1;
        } else
          r10 = s10;
      }
      return false;
    }
    toString() {
      switch (this.op) {
        case e11.ALT:
          return `alt -> ${this.out}, ${this.arg}`;
        case e11.ALT_MATCH:
          return `altmatch -> ${this.out}, ${this.arg}`;
        case e11.CAPTURE:
          return `cap ${this.arg} -> ${this.out}`;
        case e11.EMPTY_WIDTH:
          return `empty ${this.arg} -> ${this.out}`;
        case e11.MATCH:
          return "match";
        case e11.FAIL:
          return "fail";
        case e11.NOP:
          return `nop -> ${this.out}`;
        case e11.RUNE:
          return this.runes === null ? "rune <null>" : ["rune ", e11.escapeRunes(this.runes), (this.arg & K.FOLD_CASE) !== 0 ? "/i" : "", " -> ", this.out].join("");
        case e11.RUNE1:
          return `rune1 ${e11.escapeRunes(this.runes)} -> ${this.out}`;
        case e11.RUNE_ANY:
          return `any -> ${this.out}`;
        case e11.RUNE_ANY_NOT_NL:
          return `anynotnl -> ${this.out}`;
        default:
          throw new Error("unhandled case in Inst.toString");
      }
    }
  }, zo = class {
    constructor() {
      this.inst = null, this.cap = [];
    }
  }, Vs = class {
    constructor() {
      this.sparse = [], this.densePcs = [], this.denseThreads = [], this.size = 0;
    }
    contains(t10) {
      let n10 = this.sparse[t10];
      return n10 < this.size && this.densePcs[n10] === t10;
    }
    isEmpty() {
      return this.size === 0;
    }
    add(t10) {
      let n10 = this.size++;
      return this.sparse[t10] = n10, this.denseThreads[n10] = null, this.densePcs[n10] = t10, n10;
    }
    clear() {
      this.sparse = [], this.densePcs = [], this.denseThreads = [], this.size = 0;
    }
    toString() {
      let t10 = "{";
      for (let n10 = 0; n10 < this.size; n10++)
        n10 !== 0 && (t10 += ", "), t10 += this.densePcs[n10];
      return t10 += "}", t10;
    }
  }, Qr = class e11 {
    static fromRE2(t10) {
      let n10 = new e11();
      return n10.prog = t10.prog, n10.re2 = t10, n10.q0 = new Vs(n10.prog.numInst()), n10.q1 = new Vs(n10.prog.numInst()), n10.pool = [], n10.poolSize = 0, n10.matched = false, n10.matchcap = Array(n10.prog.numCap < 2 ? 2 : n10.prog.numCap).fill(0), n10.ncap = 0, n10;
    }
    static fromMachine(t10) {
      let n10 = new e11();
      return n10.re2 = t10.re2, n10.prog = t10.prog, n10.q0 = t10.q0, n10.q1 = t10.q1, n10.pool = t10.pool, n10.poolSize = t10.poolSize, n10.matched = t10.matched, n10.matchcap = t10.matchcap, n10.ncap = t10.ncap, n10;
    }
    init(t10) {
      this.ncap = t10, t10 > this.matchcap.length ? this.initNewCap(t10) : this.resetCap(t10);
    }
    resetCap(t10) {
      for (let n10 = 0; n10 < this.poolSize; n10++) {
        let r10 = this.pool[n10];
        r10.cap = Array(t10).fill(0);
      }
    }
    initNewCap(t10) {
      for (let n10 = 0; n10 < this.poolSize; n10++) {
        let r10 = this.pool[n10];
        r10.cap = Array(t10).fill(0);
      }
      this.matchcap = Array(t10).fill(0);
    }
    submatches() {
      return this.ncap === 0 ? Ne.emptyInts() : this.matchcap.slice(0, this.ncap);
    }
    alloc(t10) {
      let n10;
      return this.poolSize > 0 ? (this.poolSize--, n10 = this.pool[this.poolSize]) : n10 = new zo(), n10.inst = t10, n10;
    }
    freeQueue(t10, n10 = 0) {
      let r10 = t10.size - n10, s10 = this.poolSize + r10;
      this.pool.length < s10 && (this.pool = this.pool.slice(0, Math.max(this.pool.length * 2, s10)));
      for (let i10 = n10; i10 < t10.size; i10++) {
        let o10 = t10.denseThreads[i10];
        o10 !== null && (this.pool[this.poolSize] = o10, this.poolSize++);
      }
      t10.clear();
    }
    freeThread(t10) {
      this.pool.length <= this.poolSize && (this.pool = this.pool.slice(0, this.pool.length * 2)), this.pool[this.poolSize] = t10, this.poolSize++;
    }
    match(t10, n10, r10) {
      let s10 = this.re2.cond;
      if (s10 === Ne.EMPTY_ALL || (r10 === K.ANCHOR_START || r10 === K.ANCHOR_BOTH) && n10 !== 0)
        return false;
      this.matched = false, this.matchcap = Array(this.prog.numCap).fill(-1);
      let i10 = this.q0, o10 = this.q1, a = t10.step(n10), l = a >> 3, c = a & 7, u = -1, f10 = 0;
      a !== cn.EOF() && (a = t10.step(n10 + c), u = a >> 3, f10 = a & 7);
      let p;
      for (n10 === 0 ? p = Ne.emptyOpContext(-1, l) : p = t10.context(n10); ; ) {
        if (i10.isEmpty()) {
          if ((s10 & Ne.EMPTY_BEGIN_TEXT) !== 0 && n10 !== 0 || this.matched)
            break;
          if (this.re2.prefix.length !== 0 && u !== this.re2.prefixRune && t10.canCheckPrefix()) {
            let d = t10.index(this.re2, n10);
            if (d < 0)
              break;
            n10 += d, a = t10.step(n10), l = a >> 3, c = a & 7, a = t10.step(n10 + c), u = a >> 3, f10 = a & 7;
          }
        }
        !this.matched && (n10 === 0 || r10 === K.UNANCHORED) && (this.ncap > 0 && (this.matchcap[0] = n10), this.add(i10, this.prog.start, n10, this.matchcap, p, null));
        let h = n10 + c;
        if (p = t10.context(h), this.step(i10, o10, n10, h, l, p, r10, n10 === t10.endPos()), c === 0 || this.ncap === 0 && this.matched)
          break;
        n10 += c, l = u, c = f10, l !== -1 && (a = t10.step(n10 + c), u = a >> 3, f10 = a & 7);
        let m = i10;
        i10 = o10, o10 = m;
      }
      return this.freeQueue(o10), this.matched;
    }
    step(t10, n10, r10, s10, i10, o10, a, l) {
      let c = this.re2.longest;
      for (let u = 0; u < t10.size; u++) {
        let f10 = t10.denseThreads[u];
        if (f10 === null)
          continue;
        if (c && this.matched && this.ncap > 0 && this.matchcap[0] < f10.cap[0]) {
          this.freeThread(f10);
          continue;
        }
        let p = f10.inst, h = false;
        switch (p.op) {
          case we.MATCH:
            if (a === K.ANCHOR_BOTH && !l)
              break;
            this.ncap > 0 && (!c || !this.matched || this.matchcap[1] < r10) && (f10.cap[1] = r10, this.matchcap = f10.cap.slice(0, this.ncap)), c || this.freeQueue(t10, u + 1), this.matched = true;
            break;
          case we.RUNE:
            h = p.matchRune(i10);
            break;
          case we.RUNE1:
            h = i10 === p.runes[0];
            break;
          case we.RUNE_ANY:
            h = true;
            break;
          case we.RUNE_ANY_NOT_NL:
            h = i10 !== D.CODES.get(`
`);
            break;
          default:
            throw new Error("bad inst");
        }
        h && (f10 = this.add(n10, p.out, s10, f10.cap, o10, f10)), f10 !== null && (this.freeThread(f10), t10.denseThreads[u] = null);
      }
      t10.clear();
    }
    add(t10, n10, r10, s10, i10, o10) {
      if (n10 === 0 || t10.contains(n10))
        return o10;
      let a = t10.add(n10), l = this.prog.inst[n10];
      switch (l.op) {
        case we.FAIL:
          break;
        case we.ALT:
        case we.ALT_MATCH:
          o10 = this.add(t10, l.out, r10, s10, i10, o10), o10 = this.add(t10, l.arg, r10, s10, i10, o10);
          break;
        case we.EMPTY_WIDTH:
          (l.arg & ~i10) === 0 && (o10 = this.add(t10, l.out, r10, s10, i10, o10));
          break;
        case we.NOP:
          o10 = this.add(t10, l.out, r10, s10, i10, o10);
          break;
        case we.CAPTURE:
          if (l.arg < this.ncap) {
            let c = s10[l.arg];
            s10[l.arg] = r10, this.add(t10, l.out, r10, s10, i10, null), s10[l.arg] = c;
          } else
            o10 = this.add(t10, l.out, r10, s10, i10, o10);
          break;
        case we.MATCH:
        case we.RUNE:
        case we.RUNE1:
        case we.RUNE_ANY:
        case we.RUNE_ANY_NOT_NL:
          o10 === null ? o10 = this.alloc(l) : o10.inst = l, this.ncap > 0 && o10.cap !== s10 && (o10.cap = s10.slice(0, this.ncap)), t10.denseThreads[a] = o10, o10 = null;
          break;
        default:
          throw new Error("unhandled");
      }
      return o10;
    }
  }, _ = class e11 {
    static Op = vf(["NO_MATCH", "EMPTY_MATCH", "LITERAL", "CHAR_CLASS", "ANY_CHAR_NOT_NL", "ANY_CHAR", "BEGIN_LINE", "END_LINE", "BEGIN_TEXT", "END_TEXT", "WORD_BOUNDARY", "NO_WORD_BOUNDARY", "CAPTURE", "STAR", "PLUS", "QUEST", "REPEAT", "CONCAT", "ALTERNATE", "LEFT_PAREN", "VERTICAL_BAR"]);
    static isPseudoOp(t10) {
      return t10 >= e11.Op.LEFT_PAREN;
    }
    static emptySubs() {
      return [];
    }
    static quoteIfHyphen(t10) {
      return t10 === D.CODES.get("-") ? "\\" : "";
    }
    static fromRegexp(t10) {
      let n10 = new e11(t10.op);
      return n10.flags = t10.flags, n10.subs = t10.subs, n10.runes = t10.runes, n10.cap = t10.cap, n10.min = t10.min, n10.max = t10.max, n10.name = t10.name, n10.namedGroups = t10.namedGroups, n10;
    }
    constructor(t10) {
      this.op = t10, this.flags = 0, this.subs = e11.emptySubs(), this.runes = [], this.min = 0, this.max = 0, this.cap = 0, this.name = null, this.namedGroups = {};
    }
    reinit() {
      this.flags = 0, this.subs = e11.emptySubs(), this.runes = [], this.cap = 0, this.min = 0, this.max = 0, this.name = null, this.namedGroups = {};
    }
    toString() {
      return this.appendTo();
    }
    appendTo() {
      let t10 = "";
      switch (this.op) {
        case e11.Op.NO_MATCH:
          t10 += "[^\\x00-\\x{10FFFF}]";
          break;
        case e11.Op.EMPTY_MATCH:
          t10 += "(?:)";
          break;
        case e11.Op.STAR:
        case e11.Op.PLUS:
        case e11.Op.QUEST:
        case e11.Op.REPEAT: {
          let n10 = this.subs[0];
          switch (n10.op > e11.Op.CAPTURE || n10.op === e11.Op.LITERAL && n10.runes.length > 1 ? t10 += `(?:${n10.appendTo()})` : t10 += n10.appendTo(), this.op) {
            case e11.Op.STAR:
              t10 += "*";
              break;
            case e11.Op.PLUS:
              t10 += "+";
              break;
            case e11.Op.QUEST:
              t10 += "?";
              break;
            case e11.Op.REPEAT:
              t10 += `{${this.min}`, this.min !== this.max && (t10 += ",", this.max >= 0 && (t10 += this.max)), t10 += "}";
              break;
          }
          (this.flags & K.NON_GREEDY) !== 0 && (t10 += "?");
          break;
        }
        case e11.Op.CONCAT: {
          for (let n10 of this.subs)
            n10.op === e11.Op.ALTERNATE ? t10 += `(?:${n10.appendTo()})` : t10 += n10.appendTo();
          break;
        }
        case e11.Op.ALTERNATE: {
          let n10 = "";
          for (let r10 of this.subs)
            t10 += n10, n10 = "|", t10 += r10.appendTo();
          break;
        }
        case e11.Op.LITERAL:
          (this.flags & K.FOLD_CASE) !== 0 && (t10 += "(?i:");
          for (let n10 of this.runes)
            t10 += Ne.escapeRune(n10);
          (this.flags & K.FOLD_CASE) !== 0 && (t10 += ")");
          break;
        case e11.Op.ANY_CHAR_NOT_NL:
          t10 += "(?-s:.)";
          break;
        case e11.Op.ANY_CHAR:
          t10 += "(?s:.)";
          break;
        case e11.Op.CAPTURE:
          this.name === null || this.name.length === 0 ? t10 += "(" : t10 += `(?P<${this.name}>`, this.subs[0].op !== e11.Op.EMPTY_MATCH && (t10 += this.subs[0].appendTo()), t10 += ")";
          break;
        case e11.Op.BEGIN_TEXT:
          t10 += "\\A";
          break;
        case e11.Op.END_TEXT:
          (this.flags & K.WAS_DOLLAR) !== 0 ? t10 += "(?-m:$)" : t10 += "\\z";
          break;
        case e11.Op.BEGIN_LINE:
          t10 += "^";
          break;
        case e11.Op.END_LINE:
          t10 += "$";
          break;
        case e11.Op.WORD_BOUNDARY:
          t10 += "\\b";
          break;
        case e11.Op.NO_WORD_BOUNDARY:
          t10 += "\\B";
          break;
        case e11.Op.CHAR_CLASS:
          if (this.runes.length % 2 !== 0) {
            t10 += "[invalid char class]";
            break;
          }
          if (t10 += "[", this.runes.length === 0)
            t10 += "^\\x00-\\x{10FFFF}";
          else if (this.runes[0] === 0 && this.runes[this.runes.length - 1] === he.MAX_RUNE) {
            t10 += "^";
            for (let n10 = 1; n10 < this.runes.length - 1; n10 += 2) {
              let r10 = this.runes[n10] + 1, s10 = this.runes[n10 + 1] - 1;
              t10 += e11.quoteIfHyphen(r10), t10 += Ne.escapeRune(r10), r10 !== s10 && (t10 += "-", t10 += e11.quoteIfHyphen(s10), t10 += Ne.escapeRune(s10));
            }
          } else
            for (let n10 = 0; n10 < this.runes.length; n10 += 2) {
              let r10 = this.runes[n10], s10 = this.runes[n10 + 1];
              t10 += e11.quoteIfHyphen(r10), t10 += Ne.escapeRune(r10), r10 !== s10 && (t10 += "-", t10 += e11.quoteIfHyphen(s10), t10 += Ne.escapeRune(s10));
            }
          t10 += "]";
          break;
        default:
          t10 += this.op;
          break;
      }
      return t10;
    }
    maxCap() {
      let t10 = 0;
      if (this.op === e11.Op.CAPTURE && (t10 = this.cap), this.subs !== null)
        for (let n10 of this.subs) {
          let r10 = n10.maxCap();
          t10 < r10 && (t10 = r10);
        }
      return t10;
    }
    equals(t10) {
      if (!(t10 !== null && t10 instanceof e11) || this.op !== t10.op)
        return false;
      switch (this.op) {
        case e11.Op.END_TEXT: {
          if ((this.flags & K.WAS_DOLLAR) !== (t10.flags & K.WAS_DOLLAR))
            return false;
          break;
        }
        case e11.Op.LITERAL:
        case e11.Op.CHAR_CLASS: {
          if (this.runes === null && t10.runes === null)
            break;
          if (this.runes === null || t10.runes === null || this.runes.length !== t10.runes.length)
            return false;
          for (let n10 = 0; n10 < this.runes.length; n10++)
            if (this.runes[n10] !== t10.runes[n10])
              return false;
          break;
        }
        case e11.Op.ALTERNATE:
        case e11.Op.CONCAT: {
          if (this.subs.length !== t10.subs.length)
            return false;
          for (let n10 = 0; n10 < this.subs.length; ++n10)
            if (!this.subs[n10].equals(t10.subs[n10]))
              return false;
          break;
        }
        case e11.Op.STAR:
        case e11.Op.PLUS:
        case e11.Op.QUEST: {
          if ((this.flags & K.NON_GREEDY) !== (t10.flags & K.NON_GREEDY) || !this.subs[0].equals(t10.subs[0]))
            return false;
          break;
        }
        case e11.Op.REPEAT: {
          if ((this.flags & K.NON_GREEDY) !== (t10.flags & K.NON_GREEDY) || this.min !== t10.min || this.max !== t10.max || !this.subs[0].equals(t10.subs[0]))
            return false;
          break;
        }
        case e11.Op.CAPTURE: {
          if (this.cap !== t10.cap || (this.name === null ? t10.name !== null : this.name !== t10.name) || !this.subs[0].equals(t10.subs[0]))
            return false;
          break;
        }
      }
      return true;
    }
  }, Ho = class {
    constructor() {
      this.inst = [], this.start = 0, this.numCap = 2;
    }
    getInst(t10) {
      return this.inst[t10];
    }
    numInst() {
      return this.inst.length;
    }
    addInst(t10) {
      this.inst.push(new we(t10));
    }
    skipNop(t10) {
      let n10 = this.inst[t10];
      for (; n10.op === we.NOP || n10.op === we.CAPTURE; )
        n10 = this.inst[t10], t10 = n10.out;
      return n10;
    }
    prefix() {
      let t10 = "", n10 = this.skipNop(this.start);
      if (!we.isRuneOp(n10.op) || n10.runes.length !== 1)
        return [n10.op === we.MATCH, t10];
      for (; we.isRuneOp(n10.op) && n10.runes.length === 1 && (n10.arg & K.FOLD_CASE) === 0; )
        t10 += String.fromCodePoint(n10.runes[0]), n10 = this.skipNop(n10.out);
      return [n10.op === we.MATCH, t10];
    }
    startCond() {
      let t10 = 0, n10 = this.start;
      e:
        for (; ; ) {
          let r10 = this.inst[n10];
          switch (r10.op) {
            case we.EMPTY_WIDTH:
              t10 |= r10.arg;
              break;
            case we.FAIL:
              return -1;
            case we.CAPTURE:
            case we.NOP:
              break;
            default:
              break e;
          }
          n10 = r10.out;
        }
      return t10;
    }
    next(t10) {
      let n10 = this.inst[t10 >> 1];
      return (t10 & 1) === 0 ? n10.out : n10.arg;
    }
    patch(t10, n10) {
      for (; t10 !== 0; ) {
        let r10 = this.inst[t10 >> 1];
        (t10 & 1) === 0 ? (t10 = r10.out, r10.out = n10) : (t10 = r10.arg, r10.arg = n10);
      }
    }
    append(t10, n10) {
      if (t10 === 0)
        return n10;
      if (n10 === 0)
        return t10;
      let r10 = t10;
      for (; ; ) {
        let i10 = this.next(r10);
        if (i10 === 0)
          break;
        r10 = i10;
      }
      let s10 = this.inst[r10 >> 1];
      return (r10 & 1) === 0 ? s10.out = n10 : s10.arg = n10, t10;
    }
    toString() {
      let t10 = "";
      for (let n10 = 0; n10 < this.inst.length; n10++) {
        let r10 = t10.length;
        t10 += n10, n10 === this.start && (t10 += "*"), t10 += "        ".substring(t10.length - r10), t10 += this.inst[n10], t10 += `
`;
      }
      return t10;
    }
  }, pr = class {
    constructor(t10 = 0, n10 = 0, r10 = false) {
      this.i = t10, this.out = n10, this.nullable = r10;
    }
  }, jo = class e11 {
    static ANY_RUNE_NOT_NL() {
      return [0, D.CODES.get(`
`) - 1, D.CODES.get(`
`) + 1, he.MAX_RUNE];
    }
    static ANY_RUNE() {
      return [0, he.MAX_RUNE];
    }
    static compileRegexp(t10) {
      let n10 = new e11(), r10 = n10.compile(t10);
      return n10.prog.patch(r10.out, n10.newInst(we.MATCH).i), n10.prog.start = r10.i, n10.prog;
    }
    constructor() {
      this.prog = new Ho(), this.newInst(we.FAIL);
    }
    newInst(t10) {
      return this.prog.addInst(t10), new pr(this.prog.numInst() - 1, 0, true);
    }
    nop() {
      let t10 = this.newInst(we.NOP);
      return t10.out = t10.i << 1, t10;
    }
    fail() {
      return new pr();
    }
    cap(t10) {
      let n10 = this.newInst(we.CAPTURE);
      return n10.out = n10.i << 1, this.prog.getInst(n10.i).arg = t10, this.prog.numCap < t10 + 1 && (this.prog.numCap = t10 + 1), n10;
    }
    cat(t10, n10) {
      return t10.i === 0 || n10.i === 0 ? this.fail() : (this.prog.patch(t10.out, n10.i), new pr(t10.i, n10.out, t10.nullable && n10.nullable));
    }
    alt(t10, n10) {
      if (t10.i === 0)
        return n10;
      if (n10.i === 0)
        return t10;
      let r10 = this.newInst(we.ALT), s10 = this.prog.getInst(r10.i);
      return s10.out = t10.i, s10.arg = n10.i, r10.out = this.prog.append(t10.out, n10.out), r10.nullable = t10.nullable || n10.nullable, r10;
    }
    loop(t10, n10) {
      let r10 = this.newInst(we.ALT), s10 = this.prog.getInst(r10.i);
      return n10 ? (s10.arg = t10.i, r10.out = r10.i << 1) : (s10.out = t10.i, r10.out = r10.i << 1 | 1), this.prog.patch(t10.out, r10.i), r10;
    }
    quest(t10, n10) {
      let r10 = this.newInst(we.ALT), s10 = this.prog.getInst(r10.i);
      return n10 ? (s10.arg = t10.i, r10.out = r10.i << 1) : (s10.out = t10.i, r10.out = r10.i << 1 | 1), r10.out = this.prog.append(r10.out, t10.out), r10;
    }
    star(t10, n10) {
      return t10.nullable ? this.quest(this.plus(t10, n10), n10) : this.loop(t10, n10);
    }
    plus(t10, n10) {
      return new pr(t10.i, this.loop(t10, n10).out, t10.nullable);
    }
    empty(t10) {
      let n10 = this.newInst(we.EMPTY_WIDTH);
      return this.prog.getInst(n10.i).arg = t10, n10.out = n10.i << 1, n10;
    }
    rune(t10, n10) {
      let r10 = this.newInst(we.RUNE);
      r10.nullable = false;
      let s10 = this.prog.getInst(r10.i);
      return s10.runes = t10, n10 &= K.FOLD_CASE, (t10.length !== 1 || he.simpleFold(t10[0]) === t10[0]) && (n10 &= -2), s10.arg = n10, r10.out = r10.i << 1, (n10 & K.FOLD_CASE) === 0 && t10.length === 1 || t10.length === 2 && t10[0] === t10[1] ? s10.op = we.RUNE1 : t10.length === 2 && t10[0] === 0 && t10[1] === he.MAX_RUNE ? s10.op = we.RUNE_ANY : t10.length === 4 && t10[0] === 0 && t10[1] === D.CODES.get(`
`) - 1 && t10[2] === D.CODES.get(`
`) + 1 && t10[3] === he.MAX_RUNE && (s10.op = we.RUNE_ANY_NOT_NL), r10;
    }
    compile(t10) {
      switch (t10.op) {
        case _.Op.NO_MATCH:
          return this.fail();
        case _.Op.EMPTY_MATCH:
          return this.nop();
        case _.Op.LITERAL:
          if (t10.runes.length === 0)
            return this.nop();
          {
            let n10 = null;
            for (let r10 of t10.runes) {
              let s10 = this.rune([r10], t10.flags);
              n10 = n10 === null ? s10 : this.cat(n10, s10);
            }
            return n10;
          }
        case _.Op.CHAR_CLASS:
          return this.rune(t10.runes, t10.flags);
        case _.Op.ANY_CHAR_NOT_NL:
          return this.rune(e11.ANY_RUNE_NOT_NL(), 0);
        case _.Op.ANY_CHAR:
          return this.rune(e11.ANY_RUNE(), 0);
        case _.Op.BEGIN_LINE:
          return this.empty(Ne.EMPTY_BEGIN_LINE);
        case _.Op.END_LINE:
          return this.empty(Ne.EMPTY_END_LINE);
        case _.Op.BEGIN_TEXT:
          return this.empty(Ne.EMPTY_BEGIN_TEXT);
        case _.Op.END_TEXT:
          return this.empty(Ne.EMPTY_END_TEXT);
        case _.Op.WORD_BOUNDARY:
          return this.empty(Ne.EMPTY_WORD_BOUNDARY);
        case _.Op.NO_WORD_BOUNDARY:
          return this.empty(Ne.EMPTY_NO_WORD_BOUNDARY);
        case _.Op.CAPTURE: {
          let n10 = this.cap(t10.cap << 1), r10 = this.compile(t10.subs[0]), s10 = this.cap(t10.cap << 1 | 1);
          return this.cat(this.cat(n10, r10), s10);
        }
        case _.Op.STAR:
          return this.star(this.compile(t10.subs[0]), (t10.flags & K.NON_GREEDY) !== 0);
        case _.Op.PLUS:
          return this.plus(this.compile(t10.subs[0]), (t10.flags & K.NON_GREEDY) !== 0);
        case _.Op.QUEST:
          return this.quest(this.compile(t10.subs[0]), (t10.flags & K.NON_GREEDY) !== 0);
        case _.Op.CONCAT: {
          if (t10.subs.length === 0)
            return this.nop();
          {
            let n10 = null;
            for (let r10 of t10.subs) {
              let s10 = this.compile(r10);
              n10 = n10 === null ? s10 : this.cat(n10, s10);
            }
            return n10;
          }
        }
        case _.Op.ALTERNATE: {
          if (t10.subs.length === 0)
            return this.nop();
          {
            let n10 = null;
            for (let r10 of t10.subs) {
              let s10 = this.compile(r10);
              n10 = n10 === null ? s10 : this.alt(n10, s10);
            }
            return n10;
          }
        }
        default:
          throw new Fo("regexp: unhandled case in compile");
      }
    }
  }, Go = class e11 {
    static simplify(t10) {
      if (t10 === null)
        return null;
      switch (t10.op) {
        case _.Op.CAPTURE:
        case _.Op.CONCAT:
        case _.Op.ALTERNATE: {
          let n10 = t10;
          for (let r10 = 0; r10 < t10.subs.length; r10++) {
            let s10 = t10.subs[r10], i10 = e11.simplify(s10);
            n10 === t10 && i10 !== s10 && (n10 = _.fromRegexp(t10), n10.runes = [], n10.subs = t10.subs.slice(0, t10.subs.length)), n10 !== t10 && (n10.subs[r10] = i10);
          }
          return n10;
        }
        case _.Op.STAR:
        case _.Op.PLUS:
        case _.Op.QUEST: {
          let n10 = e11.simplify(t10.subs[0]);
          return e11.simplify1(t10.op, t10.flags, n10, t10);
        }
        case _.Op.REPEAT: {
          if (t10.min === 0 && t10.max === 0)
            return new _(_.Op.EMPTY_MATCH);
          let n10 = e11.simplify(t10.subs[0]);
          if (t10.max === -1) {
            if (t10.min === 0)
              return e11.simplify1(_.Op.STAR, t10.flags, n10, null);
            if (t10.min === 1)
              return e11.simplify1(_.Op.PLUS, t10.flags, n10, null);
            let s10 = new _(_.Op.CONCAT), i10 = [];
            for (let o10 = 0; o10 < t10.min - 1; o10++)
              i10.push(n10);
            return i10.push(e11.simplify1(_.Op.PLUS, t10.flags, n10, null)), s10.subs = i10.slice(0), s10;
          }
          if (t10.min === 1 && t10.max === 1)
            return n10;
          let r10 = null;
          if (t10.min > 0) {
            r10 = [];
            for (let s10 = 0; s10 < t10.min; s10++)
              r10.push(n10);
          }
          if (t10.max > t10.min) {
            let s10 = e11.simplify1(_.Op.QUEST, t10.flags, n10, null);
            for (let i10 = t10.min + 1; i10 < t10.max; i10++) {
              let o10 = new _(_.Op.CONCAT);
              o10.subs = [n10, s10], s10 = e11.simplify1(_.Op.QUEST, t10.flags, o10, null);
            }
            if (r10 === null)
              return s10;
            r10.push(s10);
          }
          if (r10 !== null) {
            let s10 = new _(_.Op.CONCAT);
            return s10.subs = r10.slice(0), s10;
          }
          return new _(_.Op.NO_MATCH);
        }
      }
      return t10;
    }
    static simplify1(t10, n10, r10, s10) {
      return r10.op === _.Op.EMPTY_MATCH || t10 === r10.op && (n10 & K.NON_GREEDY) === (r10.flags & K.NON_GREEDY) ? r10 : (s10 !== null && s10.op === t10 && (s10.flags & K.NON_GREEDY) === (n10 & K.NON_GREEDY) && r10 === s10.subs[0] || (s10 = new _(t10), s10.flags = n10, s10.subs = [r10]), s10);
    }
  }, Ce = class {
    constructor(t10, n10) {
      this.sign = t10, this.cls = n10;
    }
  }, lf = [48, 57], cf = [9, 10, 12, 13, 32, 32], uf = [48, 57, 65, 90, 95, 95, 97, 122], ff = /* @__PURE__ */ new Map([["\\d", new Ce(1, lf)], ["\\D", new Ce(-1, lf)], ["\\s", new Ce(1, cf)], ["\\S", new Ce(-1, cf)], ["\\w", new Ce(1, uf)], ["\\W", new Ce(-1, uf)]]), pf = [48, 57, 65, 90, 97, 122], hf = [65, 90, 97, 122], df = [0, 127], mf = [9, 9, 32, 32], gf = [0, 31, 127, 127], yf = [48, 57], wf = [33, 126], bf = [97, 122], xf = [32, 126], Ef = [33, 47, 58, 64, 91, 96, 123, 126], Af = [9, 13, 32, 32], Sf = [65, 90], Cf = [48, 57, 65, 90, 95, 95, 97, 122], Nf = [48, 57, 65, 70, 97, 102], kf = /* @__PURE__ */ new Map([["[:alnum:]", new Ce(1, pf)], ["[:^alnum:]", new Ce(-1, pf)], ["[:alpha:]", new Ce(1, hf)], ["[:^alpha:]", new Ce(-1, hf)], ["[:ascii:]", new Ce(1, df)], ["[:^ascii:]", new Ce(-1, df)], ["[:blank:]", new Ce(1, mf)], ["[:^blank:]", new Ce(-1, mf)], ["[:cntrl:]", new Ce(1, gf)], ["[:^cntrl:]", new Ce(-1, gf)], ["[:digit:]", new Ce(1, yf)], ["[:^digit:]", new Ce(-1, yf)], ["[:graph:]", new Ce(1, wf)], ["[:^graph:]", new Ce(-1, wf)], ["[:lower:]", new Ce(1, bf)], ["[:^lower:]", new Ce(-1, bf)], ["[:print:]", new Ce(1, xf)], ["[:^print:]", new Ce(-1, xf)], ["[:punct:]", new Ce(1, Ef)], ["[:^punct:]", new Ce(-1, Ef)], ["[:space:]", new Ce(1, Af)], ["[:^space:]", new Ce(-1, Af)], ["[:upper:]", new Ce(1, Sf)], ["[:^upper:]", new Ce(-1, Sf)], ["[:word:]", new Ce(1, Cf)], ["[:^word:]", new Ce(-1, Cf)], ["[:xdigit:]", new Ce(1, Nf)], ["[:^xdigit:]", new Ce(-1, Nf)]]), ln = class e11 {
    static charClassToString(t10, n10) {
      let r10 = "[";
      for (let s10 = 0; s10 < n10; s10 += 2) {
        s10 > 0 && (r10 += " ");
        let i10 = t10[s10], o10 = t10[s10 + 1];
        i10 === o10 ? r10 += `0x${i10.toString(16)}` : r10 += `0x${i10.toString(16)}-0x${o10.toString(16)}`;
      }
      return r10 += "]", r10;
    }
    static cmp(t10, n10, r10, s10) {
      let i10 = t10[n10] - r10;
      return i10 !== 0 ? i10 : s10 - t10[n10 + 1];
    }
    static qsortIntPair(t10, n10, r10) {
      let s10 = ((n10 + r10) / 2 | 0) & -2, i10 = t10[s10], o10 = t10[s10 + 1], a = n10, l = r10;
      for (; a <= l; ) {
        for (; a < r10 && e11.cmp(t10, a, i10, o10) < 0; )
          a += 2;
        for (; l > n10 && e11.cmp(t10, l, i10, o10) > 0; )
          l -= 2;
        if (a <= l) {
          if (a !== l) {
            let c = t10[a];
            t10[a] = t10[l], t10[l] = c, c = t10[a + 1], t10[a + 1] = t10[l + 1], t10[l + 1] = c;
          }
          a += 2, l -= 2;
        }
      }
      n10 < l && e11.qsortIntPair(t10, n10, l), a < r10 && e11.qsortIntPair(t10, a, r10);
    }
    constructor(t10 = Ne.emptyInts()) {
      this.r = t10, this.len = t10.length;
    }
    toArray() {
      return this.len === this.r.length ? this.r : this.r.slice(0, this.len);
    }
    cleanClass() {
      if (this.len < 4)
        return this;
      e11.qsortIntPair(this.r, 0, this.len - 2);
      let t10 = 2;
      for (let n10 = 2; n10 < this.len; n10 += 2) {
        let r10 = this.r[n10], s10 = this.r[n10 + 1];
        if (r10 <= this.r[t10 - 1] + 1) {
          s10 > this.r[t10 - 1] && (this.r[t10 - 1] = s10);
          continue;
        }
        this.r[t10] = r10, this.r[t10 + 1] = s10, t10 += 2;
      }
      return this.len = t10, this;
    }
    appendLiteral(t10, n10) {
      return (n10 & K.FOLD_CASE) !== 0 ? this.appendFoldedRange(t10, t10) : this.appendRange(t10, t10);
    }
    appendRange(t10, n10) {
      if (this.len > 0) {
        for (let r10 = 2; r10 <= 4; r10 += 2)
          if (this.len >= r10) {
            let s10 = this.r[this.len - r10], i10 = this.r[this.len - r10 + 1];
            if (t10 <= i10 + 1 && s10 <= n10 + 1)
              return t10 < s10 && (this.r[this.len - r10] = t10), n10 > i10 && (this.r[this.len - r10 + 1] = n10), this;
          }
      }
      return this.r[this.len++] = t10, this.r[this.len++] = n10, this;
    }
    appendFoldedRange(t10, n10) {
      if (t10 <= he.MIN_FOLD && n10 >= he.MAX_FOLD)
        return this.appendRange(t10, n10);
      if (n10 < he.MIN_FOLD || t10 > he.MAX_FOLD)
        return this.appendRange(t10, n10);
      t10 < he.MIN_FOLD && (this.appendRange(t10, he.MIN_FOLD - 1), t10 = he.MIN_FOLD), n10 > he.MAX_FOLD && (this.appendRange(he.MAX_FOLD + 1, n10), n10 = he.MAX_FOLD);
      for (let r10 = t10; r10 <= n10; r10++) {
        this.appendRange(r10, r10);
        for (let s10 = he.simpleFold(r10); s10 !== r10; s10 = he.simpleFold(s10))
          this.appendRange(s10, s10);
      }
      return this;
    }
    appendClass(t10) {
      for (let n10 = 0; n10 < t10.length; n10 += 2)
        this.appendRange(t10[n10], t10[n10 + 1]);
      return this;
    }
    appendFoldedClass(t10) {
      for (let n10 = 0; n10 < t10.length; n10 += 2)
        this.appendFoldedRange(t10[n10], t10[n10 + 1]);
      return this;
    }
    appendNegatedClass(t10) {
      let n10 = 0;
      for (let r10 = 0; r10 < t10.length; r10 += 2) {
        let s10 = t10[r10], i10 = t10[r10 + 1];
        n10 <= s10 - 1 && this.appendRange(n10, s10 - 1), n10 = i10 + 1;
      }
      return n10 <= he.MAX_RUNE && this.appendRange(n10, he.MAX_RUNE), this;
    }
    appendTable(t10) {
      for (let n10 = 0; n10 < t10.length; ++n10) {
        let r10 = t10.getLo(n10), s10 = t10.getHi(n10), i10 = t10.getStride(n10);
        if (i10 === 1) {
          this.appendRange(r10, s10);
          continue;
        }
        for (let o10 = r10; o10 <= s10; o10 += i10)
          this.appendRange(o10, o10);
      }
      return this;
    }
    appendNegatedTable(t10) {
      let n10 = 0;
      for (let r10 = 0; r10 < t10.length; ++r10) {
        let s10 = t10.getLo(r10), i10 = t10.getHi(r10), o10 = t10.getStride(r10);
        if (o10 === 1) {
          n10 <= s10 - 1 && this.appendRange(n10, s10 - 1), n10 = i10 + 1;
          continue;
        }
        for (let a = s10; a <= i10; a += o10)
          n10 <= a - 1 && this.appendRange(n10, a - 1), n10 = a + 1;
      }
      return n10 <= he.MAX_RUNE && this.appendRange(n10, he.MAX_RUNE), this;
    }
    appendTableWithSign(t10, n10) {
      return n10 < 0 ? this.appendNegatedTable(t10) : this.appendTable(t10);
    }
    negateClass() {
      let t10 = 0, n10 = 0;
      for (let r10 = 0; r10 < this.len; r10 += 2) {
        let s10 = this.r[r10], i10 = this.r[r10 + 1];
        t10 <= s10 - 1 && (this.r[n10] = t10, this.r[n10 + 1] = s10 - 1, n10 += 2), t10 = i10 + 1;
      }
      return this.len = n10, t10 <= he.MAX_RUNE && (this.r[this.len++] = t10, this.r[this.len++] = he.MAX_RUNE), this;
    }
    appendClassWithSign(t10, n10) {
      return n10 < 0 ? this.appendNegatedClass(t10) : this.appendClass(t10);
    }
    appendGroup(t10, n10) {
      let r10 = t10.cls;
      return n10 && (r10 = new e11().appendFoldedClass(r10).cleanClass().toArray()), this.appendClassWithSign(r10, t10.sign);
    }
    toString() {
      return e11.charClassToString(this.r, this.len);
    }
  }, Kr = class e11 {
    static of(t10, n10) {
      return new e11(t10, n10);
    }
    constructor(t10, n10) {
      this.first = t10, this.second = n10;
    }
  }, Vo = class {
    constructor(t10) {
      this.str = t10, this.position = 0;
    }
    pos() {
      return this.position;
    }
    rewindTo(t10) {
      this.position = t10;
    }
    more() {
      return this.position < this.str.length;
    }
    peek() {
      return this.str.codePointAt(this.position);
    }
    skip(t10) {
      this.position += t10;
    }
    skipString(t10) {
      this.position += t10.length;
    }
    pop() {
      let t10 = this.str.codePointAt(this.position);
      return this.position += Ne.charCount(t10), t10;
    }
    lookingAt(t10) {
      return this.rest().startsWith(t10);
    }
    rest() {
      return this.str.substring(this.position);
    }
    from(t10) {
      return this.str.substring(t10, this.position);
    }
    toString() {
      return this.rest();
    }
  }, qo = class e11 {
    static ERR_INTERNAL_ERROR = "regexp/syntax: internal error";
    static ERR_INVALID_CHAR_RANGE = "invalid character class range";
    static ERR_INVALID_ESCAPE = "invalid escape sequence";
    static ERR_INVALID_NAMED_CAPTURE = "invalid named capture";
    static ERR_INVALID_PERL_OP = "invalid or unsupported Perl syntax";
    static ERR_INVALID_REPEAT_OP = "invalid nested repetition operator";
    static ERR_INVALID_REPEAT_SIZE = "invalid repeat count";
    static ERR_MISSING_BRACKET = "missing closing ]";
    static ERR_MISSING_PAREN = "missing closing )";
    static ERR_MISSING_REPEAT_ARGUMENT = "missing argument to repetition operator";
    static ERR_TRAILING_BACKSLASH = "trailing backslash at end of expression";
    static ERR_DUPLICATE_NAMED_CAPTURE = "duplicate capture group name";
    static ERR_UNEXPECTED_PAREN = "unexpected )";
    static ERR_NESTING_DEPTH = "expression nests too deeply";
    static ERR_LARGE = "expression too large";
    static MAX_HEIGHT = 1e3;
    static MAX_SIZE = 3355443;
    static MAX_RUNES = 33554432;
    static ANY_TABLE = new C(new Uint32Array([0, he.MAX_RUNE, 1]));
    static unicodeTable(t10) {
      return t10 === "Any" ? Kr.of(e11.ANY_TABLE, e11.ANY_TABLE) : Gt.CATEGORIES.has(t10) ? Kr.of(Gt.CATEGORIES.get(t10), Gt.FOLD_CATEGORIES.get(t10)) : Gt.SCRIPTS.has(t10) ? Kr.of(Gt.SCRIPTS.get(t10), Gt.FOLD_SCRIPT.get(t10)) : null;
    }
    static minFoldRune(t10) {
      if (t10 < he.MIN_FOLD || t10 > he.MAX_FOLD)
        return t10;
      let n10 = t10, r10 = t10;
      for (t10 = he.simpleFold(t10); t10 !== r10; t10 = he.simpleFold(t10))
        n10 > t10 && (n10 = t10);
      return n10;
    }
    static leadingRegexp(t10) {
      if (t10.op === _.Op.EMPTY_MATCH)
        return null;
      if (t10.op === _.Op.CONCAT && t10.subs.length > 0) {
        let n10 = t10.subs[0];
        return n10.op === _.Op.EMPTY_MATCH ? null : n10;
      }
      return t10;
    }
    static literalRegexp(t10, n10) {
      let r10 = new _(_.Op.LITERAL);
      return r10.flags = n10, r10.runes = Ne.stringToRunes(t10), r10;
    }
    static parse(t10, n10) {
      return new e11(t10, n10).parseInternal();
    }
    static parseRepeat(t10) {
      let n10 = t10.pos();
      if (!t10.more() || !t10.lookingAt("{"))
        return -1;
      t10.skip(1);
      let r10 = e11.parseInt(t10);
      if (r10 === -1 || !t10.more())
        return -1;
      let s10;
      if (!t10.lookingAt(","))
        s10 = r10;
      else {
        if (t10.skip(1), !t10.more())
          return -1;
        if (t10.lookingAt("}"))
          s10 = -1;
        else if ((s10 = e11.parseInt(t10)) === -1)
          return -1;
      }
      if (!t10.more() || !t10.lookingAt("}"))
        return -1;
      if (t10.skip(1), r10 < 0 || r10 > 1e3 || s10 === -2 || s10 > 1e3 || s10 >= 0 && r10 > s10)
        throw new De(e11.ERR_INVALID_REPEAT_SIZE, t10.from(n10));
      return r10 << 16 | s10 & he.MAX_BMP;
    }
    static isValidCaptureName(t10) {
      if (t10.length === 0)
        return false;
      for (let n10 = 0; n10 < t10.length; n10++) {
        let r10 = t10.codePointAt(n10);
        if (r10 !== D.CODES.get("_") && !Ne.isalnum(r10))
          return false;
      }
      return true;
    }
    static parseInt(t10) {
      let n10 = t10.pos();
      for (; t10.more() && t10.peek() >= D.CODES.get("0") && t10.peek() <= D.CODES.get("9"); )
        t10.skip(1);
      let r10 = t10.from(n10);
      return r10.length === 0 || r10.length > 1 && r10.codePointAt(0) === D.CODES.get("0") ? -1 : r10.length > 8 ? -2 : parseFloat(r10, 10);
    }
    static isCharClass(t10) {
      return t10.op === _.Op.LITERAL && t10.runes.length === 1 || t10.op === _.Op.CHAR_CLASS || t10.op === _.Op.ANY_CHAR_NOT_NL || t10.op === _.Op.ANY_CHAR;
    }
    static matchRune(t10, n10) {
      switch (t10.op) {
        case _.Op.LITERAL:
          return t10.runes.length === 1 && t10.runes[0] === n10;
        case _.Op.CHAR_CLASS:
          for (let r10 = 0; r10 < t10.runes.length; r10 += 2)
            if (t10.runes[r10] <= n10 && n10 <= t10.runes[r10 + 1])
              return true;
          return false;
        case _.Op.ANY_CHAR_NOT_NL:
          return n10 !== D.CODES.get(`
`);
        case _.Op.ANY_CHAR:
          return true;
      }
      return false;
    }
    static mergeCharClass(t10, n10) {
      switch (t10.op) {
        case _.Op.ANY_CHAR:
          break;
        case _.Op.ANY_CHAR_NOT_NL:
          e11.matchRune(n10, D.CODES.get(`
`)) && (t10.op = _.Op.ANY_CHAR);
          break;
        case _.Op.CHAR_CLASS:
          n10.op === _.Op.LITERAL ? t10.runes = new ln(t10.runes).appendLiteral(n10.runes[0], n10.flags).toArray() : t10.runes = new ln(t10.runes).appendClass(n10.runes).toArray();
          break;
        case _.Op.LITERAL:
          if (n10.runes[0] === t10.runes[0] && n10.flags === t10.flags)
            break;
          t10.op = _.Op.CHAR_CLASS, t10.runes = new ln().appendLiteral(t10.runes[0], t10.flags).appendLiteral(n10.runes[0], n10.flags).toArray();
          break;
      }
    }
    static parseEscape(t10) {
      let n10 = t10.pos();
      if (t10.skip(1), !t10.more())
        throw new De(e11.ERR_TRAILING_BACKSLASH);
      let r10 = t10.pop();
      e:
        switch (r10) {
          case D.CODES.get("1"):
          case D.CODES.get("2"):
          case D.CODES.get("3"):
          case D.CODES.get("4"):
          case D.CODES.get("5"):
          case D.CODES.get("6"):
          case D.CODES.get("7"):
            if (!t10.more() || t10.peek() < D.CODES.get("0") || t10.peek() > D.CODES.get("7"))
              break;
          case D.CODES.get("0"): {
            let s10 = r10 - D.CODES.get("0");
            for (let i10 = 1; i10 < 3 && !(!t10.more() || t10.peek() < D.CODES.get("0") || t10.peek() > D.CODES.get("7")); i10++)
              s10 = s10 * 8 + t10.peek() - D.CODES.get("0"), t10.skip(1);
            return s10;
          }
          case D.CODES.get("x"): {
            if (!t10.more())
              break;
            if (r10 = t10.pop(), r10 === D.CODES.get("{")) {
              let o10 = 0, a = 0;
              for (; ; ) {
                if (!t10.more())
                  break e;
                if (r10 = t10.pop(), r10 === D.CODES.get("}"))
                  break;
                let l = Ne.unhex(r10);
                if (l < 0 || (a = a * 16 + l, a > he.MAX_RUNE))
                  break e;
                o10++;
              }
              if (o10 === 0)
                break e;
              return a;
            }
            let s10 = Ne.unhex(r10);
            if (!t10.more())
              break;
            r10 = t10.pop();
            let i10 = Ne.unhex(r10);
            if (s10 < 0 || i10 < 0)
              break;
            return s10 * 16 + i10;
          }
          case D.CODES.get("a"):
            return D.CODES.get("\x07");
          case D.CODES.get("f"):
            return D.CODES.get("\f");
          case D.CODES.get("n"):
            return D.CODES.get(`
`);
          case D.CODES.get("r"):
            return D.CODES.get("\r");
          case D.CODES.get("t"):
            return D.CODES.get("	");
          case D.CODES.get("v"):
            return D.CODES.get("\v");
          default:
            if (r10 <= he.MAX_ASCII && !Ne.isalnum(r10))
              return r10;
            break;
        }
      throw new De(e11.ERR_INVALID_ESCAPE, t10.from(n10));
    }
    static parseClassChar(t10, n10) {
      if (!t10.more())
        throw new De(e11.ERR_MISSING_BRACKET, t10.from(n10));
      return t10.lookingAt("\\") ? e11.parseEscape(t10) : t10.pop();
    }
    static concatRunes(t10, n10) {
      return [...t10, ...n10];
    }
    constructor(t10, n10 = 0) {
      this.wholeRegexp = t10, this.flags = n10, this.numCap = 0, this.namedGroups = {}, this.stack = [], this.free = null, this.numRegexp = 0, this.numRunes = 0, this.repeats = 0, this.height = null, this.size = null;
    }
    newRegexp(t10) {
      let n10 = this.free;
      return n10 !== null && n10.subs !== null && n10.subs.length > 0 ? (this.free = n10.subs[0], n10.reinit(), n10.op = t10) : (n10 = new _(t10), this.numRegexp += 1), n10;
    }
    reuse(t10) {
      this.height !== null && Object.prototype.hasOwnProperty.call(this.height, t10) && delete this.height[t10], t10.subs !== null && t10.subs.length > 0 && (t10.subs[0] = this.free), this.free = t10;
    }
    checkLimits(t10) {
      if (this.numRunes > e11.MAX_RUNES)
        throw new De(e11.ERR_LARGE);
      this.checkSize(t10), this.checkHeight(t10);
    }
    checkSize(t10) {
      if (this.size === null) {
        if (this.repeats === 0 && (this.repeats = 1), t10.op === _.Op.REPEAT) {
          let n10 = t10.max;
          n10 === -1 && (n10 = t10.min), n10 <= 0 && (n10 = 1), n10 > e11.MAX_SIZE / this.repeats ? this.repeats = e11.MAX_SIZE : this.repeats *= n10;
        }
        if (this.numRegexp < e11.MAX_SIZE / this.repeats)
          return;
        this.size = {};
        for (let n10 of this.stack)
          this.checkSize(n10);
      }
      if (this.calcSize(t10, true) > e11.MAX_SIZE)
        throw new De(e11.ERR_LARGE);
    }
    calcSize(t10, n10 = false) {
      if (!n10 && Object.prototype.hasOwnProperty.call(this.size, t10))
        return this.size[t10];
      let r10 = 0;
      switch (t10.op) {
        case _.Op.LITERAL: {
          r10 = t10.runes.length;
          break;
        }
        case _.Op.CAPTURE:
        case _.Op.STAR: {
          r10 = 2 + this.calcSize(t10.subs[0]);
          break;
        }
        case _.Op.PLUS:
        case _.Op.QUEST: {
          r10 = 1 + this.calcSize(t10.subs[0]);
          break;
        }
        case _.Op.CONCAT: {
          for (let s10 of t10.subs)
            r10 = r10 + this.calcSize(s10);
          break;
        }
        case _.Op.ALTERNATE: {
          for (let s10 of t10.subs)
            r10 = r10 + this.calcSize(s10);
          t10.subs.length > 1 && (r10 = r10 + t10.subs.length - 1);
          break;
        }
        case _.Op.REPEAT: {
          let s10 = this.calcSize(t10.subs[0]);
          if (t10.max === -1) {
            t10.min === 0 ? r10 = 2 + s10 : r10 = 1 + t10.min * s10;
            break;
          }
          r10 = t10.max * s10 + (t10.max - t10.min);
          break;
        }
      }
      return r10 = Math.max(1, r10), this.size[t10] = r10, r10;
    }
    checkHeight(t10) {
      if (!(this.numRegexp < e11.MAX_HEIGHT)) {
        if (this.height === null) {
          this.height = {};
          for (let n10 of this.stack)
            this.checkHeight(n10);
        }
        if (this.calcHeight(t10, true) > e11.MAX_HEIGHT)
          throw new De(e11.ERR_NESTING_DEPTH);
      }
    }
    calcHeight(t10, n10 = false) {
      if (!n10 && Object.prototype.hasOwnProperty.call(this.height, t10))
        return this.height[t10];
      let r10 = 1;
      for (let s10 of t10.subs) {
        let i10 = this.calcHeight(s10);
        r10 < 1 + i10 && (r10 = 1 + i10);
      }
      return this.height[t10] = r10, r10;
    }
    pop() {
      return this.stack.pop();
    }
    popToPseudo() {
      let t10 = this.stack.length, n10 = t10;
      for (; n10 > 0 && !_.isPseudoOp(this.stack[n10 - 1].op); )
        n10--;
      let r10 = this.stack.slice(n10, t10);
      return this.stack = this.stack.slice(0, n10), r10;
    }
    push(t10) {
      if (this.numRunes += t10.runes.length, t10.op === _.Op.CHAR_CLASS && t10.runes.length === 2 && t10.runes[0] === t10.runes[1]) {
        if (this.maybeConcat(t10.runes[0], this.flags & -2))
          return null;
        t10.op = _.Op.LITERAL, t10.runes = [t10.runes[0]], t10.flags = this.flags & -2;
      } else if (t10.op === _.Op.CHAR_CLASS && t10.runes.length === 4 && t10.runes[0] === t10.runes[1] && t10.runes[2] === t10.runes[3] && he.simpleFold(t10.runes[0]) === t10.runes[2] && he.simpleFold(t10.runes[2]) === t10.runes[0] || t10.op === _.Op.CHAR_CLASS && t10.runes.length === 2 && t10.runes[0] + 1 === t10.runes[1] && he.simpleFold(t10.runes[0]) === t10.runes[1] && he.simpleFold(t10.runes[1]) === t10.runes[0]) {
        if (this.maybeConcat(t10.runes[0], this.flags | K.FOLD_CASE))
          return null;
        t10.op = _.Op.LITERAL, t10.runes = [t10.runes[0]], t10.flags = this.flags | K.FOLD_CASE;
      } else
        this.maybeConcat(-1, 0);
      return this.stack.push(t10), this.checkLimits(t10), t10;
    }
    maybeConcat(t10, n10) {
      let r10 = this.stack.length;
      if (r10 < 2)
        return false;
      let s10 = this.stack[r10 - 1], i10 = this.stack[r10 - 2];
      return s10.op !== _.Op.LITERAL || i10.op !== _.Op.LITERAL || (s10.flags & K.FOLD_CASE) !== (i10.flags & K.FOLD_CASE) ? false : (i10.runes = e11.concatRunes(i10.runes, s10.runes), t10 >= 0 ? (s10.runes = [t10], s10.flags = n10, true) : (this.pop(), this.reuse(s10), false));
    }
    newLiteral(t10, n10) {
      let r10 = this.newRegexp(_.Op.LITERAL);
      return r10.flags = n10, (n10 & K.FOLD_CASE) !== 0 && (t10 = e11.minFoldRune(t10)), r10.runes = [t10], r10;
    }
    literal(t10) {
      this.push(this.newLiteral(t10, this.flags));
    }
    op(t10) {
      let n10 = this.newRegexp(t10);
      return n10.flags = this.flags, this.push(n10);
    }
    repeat(t10, n10, r10, s10, i10, o10) {
      let a = this.flags;
      if ((a & K.PERL_X) !== 0 && (i10.more() && i10.lookingAt("?") && (i10.skip(1), a ^= K.NON_GREEDY), o10 !== -1))
        throw new De(e11.ERR_INVALID_REPEAT_OP, i10.from(o10));
      let l = this.stack.length;
      if (l === 0)
        throw new De(e11.ERR_MISSING_REPEAT_ARGUMENT, i10.from(s10));
      let c = this.stack[l - 1];
      if (_.isPseudoOp(c.op))
        throw new De(e11.ERR_MISSING_REPEAT_ARGUMENT, i10.from(s10));
      let u = this.newRegexp(t10);
      if (u.min = n10, u.max = r10, u.flags = a, u.subs = [c], this.stack[l - 1] = u, this.checkLimits(u), t10 === _.Op.REPEAT && (n10 >= 2 || r10 >= 2) && !this.repeatIsValid(u, 1e3))
        throw new De(e11.ERR_INVALID_REPEAT_SIZE, i10.from(s10));
    }
    repeatIsValid(t10, n10) {
      if (t10.op === _.Op.REPEAT) {
        let r10 = t10.max;
        if (r10 === 0)
          return true;
        if (r10 < 0 && (r10 = t10.min), r10 > n10)
          return false;
        r10 > 0 && (n10 = Math.trunc(n10 / r10));
      }
      for (let r10 of t10.subs)
        if (!this.repeatIsValid(r10, n10))
          return false;
      return true;
    }
    concat() {
      this.maybeConcat(-1, 0);
      let t10 = this.popToPseudo();
      return t10.length === 0 ? this.push(this.newRegexp(_.Op.EMPTY_MATCH)) : this.push(this.collapse(t10, _.Op.CONCAT));
    }
    alternate() {
      let t10 = this.popToPseudo();
      return t10.length > 0 && this.cleanAlt(t10[t10.length - 1]), t10.length === 0 ? this.push(this.newRegexp(_.Op.NO_MATCH)) : this.push(this.collapse(t10, _.Op.ALTERNATE));
    }
    cleanAlt(t10) {
      t10.op === _.Op.CHAR_CLASS && (t10.runes = new ln(t10.runes).cleanClass().toArray(), t10.runes.length === 2 && t10.runes[0] === 0 && t10.runes[1] === he.MAX_RUNE ? (t10.runes = [], t10.op = _.Op.ANY_CHAR) : t10.runes.length === 4 && t10.runes[0] === 0 && t10.runes[1] === D.CODES.get(`
`) - 1 && t10.runes[2] === D.CODES.get(`
`) + 1 && t10.runes[3] === he.MAX_RUNE && (t10.runes = [], t10.op = _.Op.ANY_CHAR_NOT_NL));
    }
    collapse(t10, n10) {
      if (t10.length === 1)
        return t10[0];
      let r10 = 0;
      for (let a of t10)
        r10 += a.op === n10 ? a.subs.length : 1;
      let s10 = new Array(r10).fill(null), i10 = 0;
      for (let a of t10)
        a.op === n10 ? (s10.splice(i10, a.subs.length, ...a.subs), i10 += a.subs.length, this.reuse(a)) : s10[i10++] = a;
      let o10 = this.newRegexp(n10);
      if (o10.subs = s10, n10 === _.Op.ALTERNATE && (o10.subs = this.factor(o10.subs), o10.subs.length === 1)) {
        let a = o10;
        o10 = o10.subs[0], this.reuse(a);
      }
      return o10;
    }
    factor(t10) {
      if (t10.length < 2)
        return t10;
      let n10 = 0, r10 = t10.length, s10 = 0, i10 = null, o10 = 0, a = 0, l = 0;
      for (let u = 0; u <= r10; u++) {
        let f10 = null, p = 0, h = 0;
        if (u < r10) {
          let m = t10[n10 + u];
          if (m.op === _.Op.CONCAT && m.subs.length > 0 && (m = m.subs[0]), m.op === _.Op.LITERAL && (f10 = m.runes, p = m.runes.length, h = m.flags & K.FOLD_CASE), h === a) {
            let d = 0;
            for (; d < o10 && d < p && i10[d] === f10[d]; )
              d++;
            if (d > 0) {
              o10 = d;
              continue;
            }
          }
        }
        if (u !== l)
          if (u === l + 1)
            t10[s10++] = t10[n10 + l];
          else {
            let m = this.newRegexp(_.Op.LITERAL);
            m.flags = a, m.runes = i10.slice(0, o10);
            for (let y = l; y < u; y++)
              t10[n10 + y] = this.removeLeadingString(t10[n10 + y], o10), this.checkLimits(t10[n10 + y]);
            let d = this.collapse(t10.slice(n10 + l, n10 + u), _.Op.ALTERNATE), g = this.newRegexp(_.Op.CONCAT);
            g.subs = [m, d], t10[s10++] = g;
          }
        l = u, i10 = f10, o10 = p, a = h;
      }
      r10 = s10, n10 = 0, l = 0, s10 = 0;
      let c = null;
      for (let u = 0; u <= r10; u++) {
        let f10 = null;
        if (!(u < r10 && (f10 = e11.leadingRegexp(t10[n10 + u]), c !== null && c.equals(f10) && (e11.isCharClass(c) || c.op === _.Op.REPEAT && c.min === c.max && e11.isCharClass(c.subs[0]))))) {
          if (u !== l)
            if (u === l + 1)
              t10[s10++] = t10[n10 + l];
            else {
              let p = c;
              for (let d = l; d < u; d++) {
                let g = d !== l;
                t10[n10 + d] = this.removeLeadingRegexp(t10[n10 + d], g), this.checkLimits(t10[n10 + d]);
              }
              let h = this.collapse(t10.slice(n10 + l, n10 + u), _.Op.ALTERNATE), m = this.newRegexp(_.Op.CONCAT);
              m.subs = [p, h], t10[s10++] = m;
            }
          l = u, c = f10;
        }
      }
      r10 = s10, n10 = 0, l = 0, s10 = 0;
      for (let u = 0; u <= r10; u++)
        if (!(u < r10 && e11.isCharClass(t10[n10 + u]))) {
          if (u !== l)
            if (u === l + 1)
              t10[s10++] = t10[n10 + l];
            else {
              let f10 = l;
              for (let h = l + 1; h < u; h++) {
                let m = t10[n10 + f10], d = t10[n10 + h];
                (m.op < d.op || m.op === d.op && (m.runes !== null ? m.runes.length : 0) < (d.runes !== null ? d.runes.length : 0)) && (f10 = h);
              }
              let p = t10[n10 + l];
              t10[n10 + l] = t10[n10 + f10], t10[n10 + f10] = p;
              for (let h = l + 1; h < u; h++)
                e11.mergeCharClass(t10[n10 + l], t10[n10 + h]), this.reuse(t10[n10 + h]);
              this.cleanAlt(t10[n10 + l]), t10[s10++] = t10[n10 + l];
            }
          u < r10 && (t10[s10++] = t10[n10 + u]), l = u + 1;
        }
      r10 = s10, n10 = 0, l = 0, s10 = 0;
      for (let u = 0; u < r10; ++u)
        u + 1 < r10 && t10[n10 + u].op === _.Op.EMPTY_MATCH && t10[n10 + u + 1].op === _.Op.EMPTY_MATCH || (t10[s10++] = t10[n10 + u]);
      return r10 = s10, n10 = 0, t10.slice(n10, r10);
    }
    removeLeadingString(t10, n10) {
      if (t10.op === _.Op.CONCAT && t10.subs.length > 0) {
        let r10 = this.removeLeadingString(t10.subs[0], n10);
        if (t10.subs[0] = r10, r10.op === _.Op.EMPTY_MATCH)
          switch (this.reuse(r10), t10.subs.length) {
            case 0:
            case 1:
              t10.op = _.Op.EMPTY_MATCH, t10.subs = null;
              break;
            case 2: {
              let s10 = t10;
              t10 = t10.subs[1], this.reuse(s10);
              break;
            }
            default:
              t10.subs = t10.subs.slice(1, t10.subs.length);
              break;
          }
        return t10;
      }
      return t10.op === _.Op.LITERAL && (t10.runes = t10.runes.slice(n10, t10.runes.length), t10.runes.length === 0 && (t10.op = _.Op.EMPTY_MATCH)), t10;
    }
    removeLeadingRegexp(t10, n10) {
      if (t10.op === _.Op.CONCAT && t10.subs.length > 0) {
        switch (n10 && this.reuse(t10.subs[0]), t10.subs = t10.subs.slice(1, t10.subs.length), t10.subs.length) {
          case 0: {
            t10.op = _.Op.EMPTY_MATCH, t10.subs = _.emptySubs();
            break;
          }
          case 1: {
            let r10 = t10;
            t10 = t10.subs[0], this.reuse(r10);
            break;
          }
        }
        return t10;
      }
      return n10 && this.reuse(t10), this.newRegexp(_.Op.EMPTY_MATCH);
    }
    parseInternal() {
      if ((this.flags & K.LITERAL) !== 0)
        return e11.literalRegexp(this.wholeRegexp, this.flags);
      let t10 = -1, n10 = -1, r10 = -1, s10 = new Vo(this.wholeRegexp);
      for (; s10.more(); ) {
        let o10 = -1;
        e:
          switch (s10.peek()) {
            case D.CODES.get("("):
              if ((this.flags & K.PERL_X) !== 0 && s10.lookingAt("(?")) {
                this.parsePerlFlags(s10);
                break;
              }
              this.op(_.Op.LEFT_PAREN).cap = ++this.numCap, s10.skip(1);
              break;
            case D.CODES.get("|"):
              this.parseVerticalBar(), s10.skip(1);
              break;
            case D.CODES.get(")"):
              this.parseRightParen(), s10.skip(1);
              break;
            case D.CODES.get("^"):
              (this.flags & K.ONE_LINE) !== 0 ? this.op(_.Op.BEGIN_TEXT) : this.op(_.Op.BEGIN_LINE), s10.skip(1);
              break;
            case D.CODES.get("$"):
              (this.flags & K.ONE_LINE) !== 0 ? this.op(_.Op.END_TEXT).flags |= K.WAS_DOLLAR : this.op(_.Op.END_LINE), s10.skip(1);
              break;
            case D.CODES.get("."):
              (this.flags & K.DOT_NL) !== 0 ? this.op(_.Op.ANY_CHAR) : this.op(_.Op.ANY_CHAR_NOT_NL), s10.skip(1);
              break;
            case D.CODES.get("["):
              this.parseClass(s10);
              break;
            case D.CODES.get("*"):
            case D.CODES.get("+"):
            case D.CODES.get("?"): {
              o10 = s10.pos();
              let a = null;
              switch (s10.pop()) {
                case D.CODES.get("*"):
                  a = _.Op.STAR;
                  break;
                case D.CODES.get("+"):
                  a = _.Op.PLUS;
                  break;
                case D.CODES.get("?"):
                  a = _.Op.QUEST;
                  break;
              }
              this.repeat(a, n10, r10, o10, s10, t10);
              break;
            }
            case D.CODES.get("{"): {
              o10 = s10.pos();
              let a = e11.parseRepeat(s10);
              if (a < 0) {
                s10.rewindTo(o10), this.literal(s10.pop());
                break;
              }
              n10 = a >> 16, r10 = (a & he.MAX_BMP) << 16 >> 16, this.repeat(_.Op.REPEAT, n10, r10, o10, s10, t10);
              break;
            }
            case D.CODES.get("\\"): {
              let a = s10.pos();
              if (s10.skip(1), (this.flags & K.PERL_X) !== 0 && s10.more())
                switch (s10.pop()) {
                  case D.CODES.get("A"):
                    this.op(_.Op.BEGIN_TEXT);
                    break e;
                  case D.CODES.get("b"):
                    this.op(_.Op.WORD_BOUNDARY);
                    break e;
                  case D.CODES.get("B"):
                    this.op(_.Op.NO_WORD_BOUNDARY);
                    break e;
                  case D.CODES.get("C"):
                    throw new De(e11.ERR_INVALID_ESCAPE, "\\C");
                  case D.CODES.get("Q"): {
                    let f10 = s10.rest(), p = f10.indexOf("\\E");
                    p >= 0 && (f10 = f10.substring(0, p)), s10.skipString(f10), s10.skipString("\\E");
                    let h = 0;
                    for (; h < f10.length; ) {
                      let m = f10.codePointAt(h);
                      this.literal(m), h += Ne.charCount(m);
                    }
                    break e;
                  }
                  case D.CODES.get("z"):
                    this.op(_.Op.END_TEXT);
                    break e;
                  default:
                    s10.rewindTo(a);
                    break;
                }
              let l = this.newRegexp(_.Op.CHAR_CLASS);
              if (l.flags = this.flags, s10.lookingAt("\\p") || s10.lookingAt("\\P")) {
                let u = new ln();
                if (this.parseUnicodeClass(s10, u)) {
                  l.runes = u.toArray(), this.push(l);
                  break e;
                }
              }
              let c = new ln();
              if (this.parsePerlClassEscape(s10, c)) {
                l.runes = c.toArray(), this.push(l);
                break e;
              }
              s10.rewindTo(a), this.reuse(l), this.literal(e11.parseEscape(s10));
              break;
            }
            default:
              this.literal(s10.pop());
              break;
          }
        t10 = o10;
      }
      if (this.concat(), this.swapVerticalBar() && this.pop(), this.alternate(), this.stack.length !== 1)
        throw new De(e11.ERR_MISSING_PAREN, this.wholeRegexp);
      return this.stack[0].namedGroups = this.namedGroups, this.stack[0];
    }
    parsePerlFlags(t10) {
      let n10 = t10.pos(), r10 = t10.rest();
      if (r10.startsWith("(?P<") || r10.startsWith("(?<")) {
        let a = r10.charAt(2) === "P" ? 4 : 3, l = r10.indexOf(">");
        if (l < 0)
          throw new De(e11.ERR_INVALID_NAMED_CAPTURE, r10);
        let c = r10.substring(a, l);
        if (t10.skipString(c), t10.skip(a + 1), !e11.isValidCaptureName(c))
          throw new De(e11.ERR_INVALID_NAMED_CAPTURE, r10.substring(0, l + 1));
        let u = this.op(_.Op.LEFT_PAREN);
        if (u.cap = ++this.numCap, this.namedGroups[c])
          throw new De(e11.ERR_DUPLICATE_NAMED_CAPTURE, c);
        this.namedGroups[c] = this.numCap, u.name = c;
        return;
      }
      t10.skip(2);
      let s10 = this.flags, i10 = 1, o10 = false;
      e:
        for (; t10.more(); ) {
          let a = t10.pop();
          switch (a) {
            case D.CODES.get("i"):
              s10 |= K.FOLD_CASE, o10 = true;
              break;
            case D.CODES.get("m"):
              s10 &= -17, o10 = true;
              break;
            case D.CODES.get("s"):
              s10 |= K.DOT_NL, o10 = true;
              break;
            case D.CODES.get("U"):
              s10 |= K.NON_GREEDY, o10 = true;
              break;
            case D.CODES.get("-"):
              if (i10 < 0)
                break e;
              i10 = -1, s10 = ~s10, o10 = false;
              break;
            case D.CODES.get(":"):
            case D.CODES.get(")"):
              if (i10 < 0) {
                if (!o10)
                  break e;
                s10 = ~s10;
              }
              a === D.CODES.get(":") && this.op(_.Op.LEFT_PAREN), this.flags = s10;
              return;
            default:
              break e;
          }
        }
      throw new De(e11.ERR_INVALID_PERL_OP, t10.from(n10));
    }
    parseVerticalBar() {
      this.concat(), this.swapVerticalBar() || this.op(_.Op.VERTICAL_BAR);
    }
    swapVerticalBar() {
      let t10 = this.stack.length;
      if (t10 >= 3 && this.stack[t10 - 2].op === _.Op.VERTICAL_BAR && e11.isCharClass(this.stack[t10 - 1]) && e11.isCharClass(this.stack[t10 - 3])) {
        let n10 = this.stack[t10 - 1], r10 = this.stack[t10 - 3];
        if (n10.op > r10.op) {
          let s10 = r10;
          r10 = n10, n10 = s10, this.stack[t10 - 3] = r10;
        }
        return e11.mergeCharClass(r10, n10), this.reuse(n10), this.pop(), true;
      }
      if (t10 >= 2) {
        let n10 = this.stack[t10 - 1], r10 = this.stack[t10 - 2];
        if (r10.op === _.Op.VERTICAL_BAR)
          return t10 >= 3 && this.cleanAlt(this.stack[t10 - 3]), this.stack[t10 - 2] = n10, this.stack[t10 - 1] = r10, true;
      }
      return false;
    }
    parseRightParen() {
      if (this.concat(), this.swapVerticalBar() && this.pop(), this.alternate(), this.stack.length < 2)
        throw new De(e11.ERR_UNEXPECTED_PAREN, this.wholeRegexp);
      let n10 = this.pop(), r10 = this.pop();
      if (r10.op !== _.Op.LEFT_PAREN)
        throw new De(e11.ERR_UNEXPECTED_PAREN, this.wholeRegexp);
      this.flags = r10.flags, r10.cap === 0 ? this.push(n10) : (r10.op = _.Op.CAPTURE, r10.subs = [n10], this.push(r10));
    }
    parsePerlClassEscape(t10, n10) {
      let r10 = t10.pos();
      if ((this.flags & K.PERL_X) === 0 || !t10.more() || t10.pop() !== D.CODES.get("\\") || !t10.more())
        return false;
      t10.pop();
      let s10 = t10.from(r10), i10 = ff.has(s10) ? ff.get(s10) : null;
      return i10 === null ? false : (n10.appendGroup(i10, (this.flags & K.FOLD_CASE) !== 0), true);
    }
    parseNamedClass(t10, n10) {
      let r10 = t10.rest(), s10 = r10.indexOf(":]");
      if (s10 < 0)
        return false;
      let i10 = r10.substring(0, s10 + 2);
      t10.skipString(i10);
      let o10 = kf.has(i10) ? kf.get(i10) : null;
      if (o10 === null)
        throw new De(e11.ERR_INVALID_CHAR_RANGE, i10);
      return n10.appendGroup(o10, (this.flags & K.FOLD_CASE) !== 0), true;
    }
    parseUnicodeClass(t10, n10) {
      let r10 = t10.pos();
      if ((this.flags & K.UNICODE_GROUPS) === 0 || !t10.lookingAt("\\p") && !t10.lookingAt("\\P"))
        return false;
      t10.skip(1);
      let s10 = 1, i10 = t10.pop();
      if (i10 === D.CODES.get("P") && (s10 = -1), !t10.more())
        throw t10.rewindTo(r10), new De(e11.ERR_INVALID_CHAR_RANGE, t10.rest());
      i10 = t10.pop();
      let o10;
      if (i10 !== D.CODES.get("{"))
        o10 = Ne.runeToString(i10);
      else {
        let u = t10.rest(), f10 = u.indexOf("}");
        if (f10 < 0)
          throw t10.rewindTo(r10), new De(e11.ERR_INVALID_CHAR_RANGE, t10.rest());
        o10 = u.substring(0, f10), t10.skipString(o10), t10.skip(1);
      }
      o10.length !== 0 && o10.codePointAt(0) === D.CODES.get("^") && (s10 = 0 - s10, o10 = o10.substring(1));
      let a = e11.unicodeTable(o10);
      if (a === null)
        throw new De(e11.ERR_INVALID_CHAR_RANGE, t10.from(r10));
      let l = a.first, c = a.second;
      if ((this.flags & K.FOLD_CASE) === 0 || c === null)
        n10.appendTableWithSign(l, s10);
      else {
        let u = new ln().appendTable(l).appendTable(c).cleanClass().toArray();
        n10.appendClassWithSign(u, s10);
      }
      return true;
    }
    parseClass(t10) {
      let n10 = t10.pos();
      t10.skip(1);
      let r10 = this.newRegexp(_.Op.CHAR_CLASS);
      r10.flags = this.flags;
      let s10 = new ln(), i10 = 1;
      t10.more() && t10.lookingAt("^") && (i10 = -1, t10.skip(1), (this.flags & K.CLASS_NL) === 0 && s10.appendRange(D.CODES.get(`
`), D.CODES.get(`
`)));
      let o10 = true;
      for (; !t10.more() || t10.peek() !== D.CODES.get("]") || o10; ) {
        if (t10.more() && t10.lookingAt("-") && (this.flags & K.PERL_X) === 0 && !o10) {
          let u = t10.rest();
          if (u === "-" || !u.startsWith("-]"))
            throw t10.rewindTo(n10), new De(e11.ERR_INVALID_CHAR_RANGE, t10.rest());
        }
        o10 = false;
        let a = t10.pos();
        if (t10.lookingAt("[:")) {
          if (this.parseNamedClass(t10, s10))
            continue;
          t10.rewindTo(a);
        }
        if (this.parseUnicodeClass(t10, s10) || this.parsePerlClassEscape(t10, s10))
          continue;
        t10.rewindTo(a);
        let l = e11.parseClassChar(t10, n10), c = l;
        if (t10.more() && t10.lookingAt("-")) {
          if (t10.skip(1), t10.more() && t10.lookingAt("]"))
            t10.skip(-1);
          else if (c = e11.parseClassChar(t10, n10), c < l)
            throw new De(e11.ERR_INVALID_CHAR_RANGE, t10.from(a));
        }
        (this.flags & K.FOLD_CASE) === 0 ? s10.appendRange(l, c) : s10.appendFoldedRange(l, c);
      }
      t10.skip(1), s10.cleanClass(), i10 < 0 && s10.negateClass(), r10.runes = s10.toArray(), this.push(r10);
    }
  }, Zo = class {
    constructor(t10) {
      this.value = t10;
    }
    get() {
      return this.value;
    }
    set(t10) {
      this.value = t10;
    }
    compareAndSet(t10, n10) {
      return this.value === t10 ? (this.value = n10, true) : false;
    }
  }, Qo = class e11 {
    static initTest(t10) {
      let n10 = e11.compile(t10), r10 = new e11(n10.expr, n10.prog, n10.numSubexp, n10.longest);
      return r10.cond = n10.cond, r10.prefix = n10.prefix, r10.prefixUTF8 = n10.prefixUTF8, r10.prefixComplete = n10.prefixComplete, r10.prefixRune = n10.prefixRune, r10;
    }
    static compile(t10) {
      return e11.compileImpl(t10, K.PERL, false);
    }
    static compilePOSIX(t10) {
      return e11.compileImpl(t10, K.POSIX, true);
    }
    static compileImpl(t10, n10, r10) {
      let s10 = qo.parse(t10, n10), i10 = s10.maxCap();
      s10 = Go.simplify(s10);
      let o10 = jo.compileRegexp(s10), a = new e11(t10, o10, i10, r10), [l, c] = o10.prefix();
      return a.prefixComplete = l, a.prefix = c, a.prefixUTF8 = Ne.stringToUtf8ByteArray(a.prefix), a.prefix.length > 0 && (a.prefixRune = a.prefix.codePointAt(0)), a.namedGroups = s10.namedGroups, a;
    }
    static match(t10, n10) {
      return e11.compile(t10).match(n10);
    }
    constructor(t10, n10, r10 = 0, s10 = 0) {
      this.expr = t10, this.prog = n10, this.numSubexp = r10, this.longest = s10, this.cond = n10.startCond(), this.prefix = null, this.prefixUTF8 = null, this.prefixComplete = false, this.prefixRune = 0, this.pooled = new Zo();
    }
    numberOfCapturingGroups() {
      return this.numSubexp;
    }
    numberOfInstructions() {
      return this.prog.numInst();
    }
    get() {
      let t10;
      do
        t10 = this.pooled.get();
      while (t10 && !this.pooled.compareAndSet(t10, t10.next));
      return t10;
    }
    reset() {
      this.pooled.set(null);
    }
    put(t10, n10) {
      let r10 = this.pooled.get();
      do
        r10 = this.pooled.get(), !n10 && r10 && (t10 = Qr.fromMachine(t10), n10 = true), t10.next !== r10 && (t10.next = r10);
      while (!this.pooled.compareAndSet(r10, t10));
    }
    toString() {
      return this.expr;
    }
    doExecute(t10, n10, r10, s10) {
      let i10 = this.get(), o10 = false;
      i10 ? i10.next !== null && (i10 = Qr.fromMachine(i10), o10 = true) : (i10 = Qr.fromRE2(this), o10 = true), i10.init(s10);
      let a = i10.match(t10, n10, r10) ? i10.submatches() : null;
      return this.put(i10, o10), a;
    }
    match(t10) {
      return this.doExecute(je.fromUTF16(t10), 0, K.UNANCHORED, 0) !== null;
    }
    matchWithGroup(t10, n10, r10, s10, i10) {
      return t10 instanceof vn || (t10 = hr.utf16(t10)), this.matchMachineInput(t10, n10, r10, s10, i10);
    }
    matchMachineInput(t10, n10, r10, s10, i10) {
      if (n10 > r10)
        return [false, null];
      let o10 = t10.isUTF16Encoding() ? je.fromUTF16(t10.asCharSequence(), 0, r10) : je.fromUTF8(t10.asBytes(), 0, r10), a = this.doExecute(o10, n10, s10, 2 * i10);
      return a === null ? [false, null] : [true, a];
    }
    matchUTF8(t10) {
      return this.doExecute(je.fromUTF8(t10), 0, K.UNANCHORED, 0) !== null;
    }
    replaceAll(t10, n10) {
      return this.replaceAllFunc(t10, () => n10, 2 * t10.length + 1);
    }
    replaceFirst(t10, n10) {
      return this.replaceAllFunc(t10, () => n10, 1);
    }
    replaceAllFunc(t10, n10, r10) {
      let s10 = 0, i10 = 0, o10 = "", a = je.fromUTF16(t10), l = 0;
      for (; i10 <= t10.length; ) {
        let c = this.doExecute(a, i10, K.UNANCHORED, 2);
        if (c === null || c.length === 0)
          break;
        o10 += t10.substring(s10, c[0]), (c[1] > s10 || c[0] === 0) && (o10 += n10(t10.substring(c[0], c[1])), l++), s10 = c[1];
        let u = a.step(i10) & 7;
        if (i10 + u > c[1] ? i10 += u : i10 + 1 > c[1] ? i10++ : i10 = c[1], l >= r10)
          break;
      }
      return o10 += t10.substring(s10), o10;
    }
    pad(t10) {
      if (t10 === null)
        return null;
      let n10 = (1 + this.numSubexp) * 2;
      if (t10.length < n10) {
        let r10 = new Array(n10).fill(-1);
        for (let s10 = 0; s10 < t10.length; s10++)
          r10[s10] = t10[s10];
        t10 = r10;
      }
      return t10;
    }
    allMatches(t10, n10, r10 = (s10) => s10) {
      let s10 = [], i10 = t10.endPos();
      n10 < 0 && (n10 = i10 + 1);
      let o10 = 0, a = 0, l = -1;
      for (; a < n10 && o10 <= i10; ) {
        let c = this.doExecute(t10, o10, K.UNANCHORED, this.prog.numCap);
        if (c === null || c.length === 0)
          break;
        let u = true;
        if (c[1] === o10) {
          c[0] === l && (u = false);
          let f10 = t10.step(o10);
          f10 < 0 ? o10 = i10 + 1 : o10 += f10 & 7;
        } else
          o10 = c[1];
        l = c[1], u && (s10.push(r10(this.pad(c))), a++);
      }
      return s10;
    }
    findUTF8(t10) {
      let n10 = this.doExecute(je.fromUTF8(t10), 0, K.UNANCHORED, 2);
      return n10 === null ? null : t10.slice(n10[0], n10[1]);
    }
    findUTF8Index(t10) {
      let n10 = this.doExecute(je.fromUTF8(t10), 0, K.UNANCHORED, 2);
      return n10 === null ? null : n10.slice(0, 2);
    }
    find(t10) {
      let n10 = this.doExecute(je.fromUTF16(t10), 0, K.UNANCHORED, 2);
      return n10 === null ? "" : t10.substring(n10[0], n10[1]);
    }
    findIndex(t10) {
      return this.doExecute(je.fromUTF16(t10), 0, K.UNANCHORED, 2);
    }
    findUTF8Submatch(t10) {
      let n10 = this.doExecute(je.fromUTF8(t10), 0, K.UNANCHORED, this.prog.numCap);
      if (n10 === null)
        return null;
      let r10 = new Array(1 + this.numSubexp).fill(null);
      for (let s10 = 0; s10 < r10.length; s10++)
        2 * s10 < n10.length && n10[2 * s10] >= 0 && (r10[s10] = t10.slice(n10[2 * s10], n10[2 * s10 + 1]));
      return r10;
    }
    findUTF8SubmatchIndex(t10) {
      return this.pad(this.doExecute(je.fromUTF8(t10), 0, K.UNANCHORED, this.prog.numCap));
    }
    findSubmatch(t10) {
      let n10 = this.doExecute(je.fromUTF16(t10), 0, K.UNANCHORED, this.prog.numCap);
      if (n10 === null)
        return null;
      let r10 = new Array(1 + this.numSubexp).fill(null);
      for (let s10 = 0; s10 < r10.length; s10++)
        2 * s10 < n10.length && n10[2 * s10] >= 0 && (r10[s10] = t10.substring(n10[2 * s10], n10[2 * s10 + 1]));
      return r10;
    }
    findSubmatchIndex(t10) {
      return this.pad(this.doExecute(je.fromUTF16(t10), 0, K.UNANCHORED, this.prog.numCap));
    }
    findAllUTF8(t10, n10) {
      let r10 = this.allMatches(je.fromUTF8(t10), n10, (s10) => t10.slice(s10[0], s10[1]));
      return r10.length === 0 ? null : r10;
    }
    findAllUTF8Index(t10, n10) {
      let r10 = this.allMatches(je.fromUTF8(t10), n10, (s10) => s10.slice(0, 2));
      return r10.length === 0 ? null : r10;
    }
    findAll(t10, n10) {
      let r10 = this.allMatches(je.fromUTF16(t10), n10, (s10) => t10.substring(s10[0], s10[1]));
      return r10.length === 0 ? null : r10;
    }
    findAllIndex(t10, n10) {
      let r10 = this.allMatches(je.fromUTF16(t10), n10, (s10) => s10.slice(0, 2));
      return r10.length === 0 ? null : r10;
    }
    findAllUTF8Submatch(t10, n10) {
      let r10 = this.allMatches(je.fromUTF8(t10), n10, (s10) => {
        let i10 = new Array(s10.length / 2 | 0).fill(null);
        for (let o10 = 0; o10 < i10.length; o10++)
          s10[2 * o10] >= 0 && (i10[o10] = t10.slice(s10[2 * o10], s10[2 * o10 + 1]));
        return i10;
      });
      return r10.length === 0 ? null : r10;
    }
    findAllUTF8SubmatchIndex(t10, n10) {
      let r10 = this.allMatches(je.fromUTF8(t10), n10);
      return r10.length === 0 ? null : r10;
    }
    findAllSubmatch(t10, n10) {
      let r10 = this.allMatches(je.fromUTF16(t10), n10, (s10) => {
        let i10 = new Array(s10.length / 2 | 0).fill(null);
        for (let o10 = 0; o10 < i10.length; o10++)
          s10[2 * o10] >= 0 && (i10[o10] = t10.substring(s10[2 * o10], s10[2 * o10 + 1]));
        return i10;
      });
      return r10.length === 0 ? null : r10;
    }
    findAllSubmatchIndex(t10, n10) {
      let r10 = this.allMatches(je.fromUTF16(t10), n10);
      return r10.length === 0 ? null : r10;
    }
  }, Ko = class e11 {
    static isUpperCaseAlpha(t10) {
      return "A" <= t10 && t10 <= "Z";
    }
    static isHexadecimal(t10) {
      return "0" <= t10 && t10 <= "9" || "A" <= t10 && t10 <= "F" || "a" <= t10 && t10 <= "f";
    }
    static getUtf8CharSize(t10) {
      let n10 = t10.charCodeAt(0);
      return n10 < 128 ? 1 : n10 < 2048 ? 2 : n10 < 65536 ? 3 : 4;
    }
    static translate(t10) {
      if (typeof t10 != "string")
        return t10;
      let n10 = "", r10 = false, s10 = t10.length;
      s10 === 0 && (n10 = "(?:)", r10 = true);
      let i10 = 0;
      for (; i10 < s10; ) {
        let o10 = t10[i10];
        if (o10 === "\\") {
          if (i10 + 1 < s10)
            switch (o10 = t10[i10 + 1], o10) {
              case "\\": {
                n10 += "\\\\", i10 += 2;
                continue;
              }
              case "c": {
                if (i10 + 2 < s10) {
                  let l = t10[i10 + 2];
                  if (e11.isUpperCaseAlpha(l)) {
                    n10 += "\\x", n10 += (l.charCodeAt(0) - 64 >> 4).toString(16).toUpperCase(), n10 += (l.charCodeAt(0) - 64 & 15).toString(16).toUpperCase(), i10 += 3, r10 = true;
                    continue;
                  }
                }
                n10 += "\\c", i10 += 2;
                continue;
              }
              case "u": {
                if (i10 + 2 < s10) {
                  let l = t10[i10 + 2];
                  if (e11.isHexadecimal(l)) {
                    n10 += "\\x{" + l, i10 += 3;
                    for (let c = 0; c < 3 && i10 < s10 && (l = t10[i10], !!e11.isHexadecimal(l)); ++i10, ++c)
                      n10 += l;
                    n10 += "}", r10 = true;
                    continue;
                  } else if (l === "{") {
                    n10 += "\\x", i10 += 2, r10 = true;
                    continue;
                  }
                }
                n10 += "\\u", i10 += 2;
                continue;
              }
              default: {
                n10 += "\\";
                let l = e11.getUtf8CharSize(o10);
                n10 += t10.substring(i10 + 1, i10 + 1 + l), i10 += l + 1;
                continue;
              }
            }
        } else if (o10 === "/") {
          n10 += "\\/", i10 += 1, r10 = true;
          continue;
        } else if (o10 === "(" && i10 + 2 < s10 && t10[i10 + 1] === "?" && t10[i10 + 2] === "<" && (i10 + 3 >= s10 || t10[i10 + 3] !== "=" && t10[i10 + 3] !== "!")) {
          n10 += "(?P<", i10 += 3, r10 = true;
          continue;
        }
        let a = e11.getUtf8CharSize(o10);
        n10 += t10.substring(i10, i10 + a), i10 += a;
      }
      return r10 ? n10 : t10;
    }
  }, In = class e11 {
    static CASE_INSENSITIVE = 1;
    static DOTALL = 2;
    static MULTILINE = 4;
    static DISABLE_UNICODE_GROUPS = 8;
    static LONGEST_MATCH = 16;
    static quote(t10) {
      return Ne.quoteMeta(t10);
    }
    static translateRegExp(t10) {
      return Ko.translate(t10);
    }
    static compile(t10, n10 = 0) {
      let r10 = t10;
      if ((n10 & e11.CASE_INSENSITIVE) !== 0 && (r10 = `(?i)${r10}`), (n10 & e11.DOTALL) !== 0 && (r10 = `(?s)${r10}`), (n10 & e11.MULTILINE) !== 0 && (r10 = `(?m)${r10}`), (n10 & ~(e11.MULTILINE | e11.DOTALL | e11.CASE_INSENSITIVE | e11.DISABLE_UNICODE_GROUPS | e11.LONGEST_MATCH)) !== 0)
        throw new Mo("Flags should only be a combination of MULTILINE, DOTALL, CASE_INSENSITIVE, DISABLE_UNICODE_GROUPS, LONGEST_MATCH");
      let s10 = K.PERL;
      (n10 & e11.DISABLE_UNICODE_GROUPS) !== 0 && (s10 &= -129);
      let i10 = new e11(t10, n10);
      return i10.re2Input = Qo.compileImpl(r10, s10, (n10 & e11.LONGEST_MATCH) !== 0), i10;
    }
    static matches(t10, n10) {
      return e11.compile(t10).matcher(n10).matches();
    }
    static initTest(t10, n10, r10) {
      if (t10 == null)
        throw new Error("pattern is null");
      if (r10 == null)
        throw new Error("re2 is null");
      let s10 = new e11(t10, n10);
      return s10.re2Input = r10, s10;
    }
    constructor(t10, n10) {
      this.patternInput = t10, this.flagsInput = n10;
    }
    reset() {
      this.re2Input.reset();
    }
    flags() {
      return this.flagsInput;
    }
    pattern() {
      return this.patternInput;
    }
    re2() {
      return this.re2Input;
    }
    matches(t10) {
      return this.matcher(t10).matches();
    }
    matcher(t10) {
      return Array.isArray(t10) && (t10 = hr.utf8(t10)), new Uo(this, t10);
    }
    split(t10, n10 = 0) {
      let r10 = this.matcher(t10), s10 = [], i10 = 0, o10 = 0;
      for (; r10.find(); ) {
        if (o10 === 0 && r10.end() === 0) {
          o10 = r10.end();
          continue;
        }
        if (n10 > 0 && s10.length === n10 - 1)
          break;
        if (o10 === r10.start()) {
          if (n10 === 0) {
            i10 += 1, o10 = r10.end();
            continue;
          }
        } else
          for (; i10 > 0; )
            s10.push(""), i10 -= 1;
        s10.push(r10.substring(o10, r10.start())), o10 = r10.end();
      }
      if (n10 === 0 && o10 !== r10.inputLength()) {
        for (; i10 > 0; )
          s10.push(""), i10 -= 1;
        s10.push(r10.substring(o10, r10.inputLength()));
      }
      return (n10 !== 0 || s10.length === 0) && s10.push(r10.substring(o10, r10.inputLength())), s10;
    }
    toString() {
      return this.patternInput;
    }
    programSize() {
      return this.re2Input.numberOfInstructions();
    }
    groupCount() {
      return this.re2Input.numberOfCapturingGroups();
    }
    namedGroups() {
      return this.re2Input.namedGroups;
    }
    equals(t10) {
      return this === t10 ? true : t10 === null || this.constructor !== t10.constructor ? false : this.flagsInput === t10.flagsInput && this.patternInput === t10.patternInput;
    }
  };
});
function i4(e11) {
  let t10 = 0;
  return e11.includes("i") && (t10 |= In.CASE_INSENSITIVE), e11.includes("m") && (t10 |= In.MULTILINE), e11.includes("s") && (t10 |= In.DOTALL), t10;
}
function o4(e11) {
  return In.translateRegExp(e11);
}
function V(e11, t10 = "") {
  return new qs(e11, t10);
}
var qs;
var xn;
var Of = I(() => {
  "use strict";
  If();
  qs = class {
    _re2;
    _pattern;
    _flags;
    _global;
    _ignoreCase;
    _multiline;
    _lastIndex = 0;
    _nativeRegex = null;
    constructor(t10, n10 = "") {
      this._pattern = t10, this._flags = n10, this._global = n10.includes("g"), this._ignoreCase = n10.includes("i"), this._multiline = n10.includes("m");
      try {
        let r10 = o4(t10), s10 = i4(n10);
        this._re2 = In.compile(r10, s10);
      } catch (r10) {
        if (r10 instanceof De) {
          let s10 = r10.message || "", i10 = "";
          throw s10.includes("(?=") || s10.includes("(?!") || s10.includes("(?<") || s10.includes("(?<!") || t10.includes("(?=") || t10.includes("(?!") || t10.includes("(?<=") || t10.includes("(?<!") ? i10 = " Lookahead (?=, ?!) and lookbehind (?<=, ?<!) assertions are not supported in this environment because the regex engine uses RE2 for ReDoS protection. RE2 guarantees linear-time matching but cannot support these features." : (s10.includes("backreference") || /\\[1-9]/.test(t10)) && (i10 = " Backreferences (\\1, \\2, etc.) are not supported in this environment because the regex engine uses RE2 for ReDoS protection. RE2 guarantees linear-time matching but cannot support backreferences."), new SyntaxError(`Invalid regular expression: /${t10}/: ${s10}${i10}`);
        }
        throw r10;
      }
    }
    test(t10) {
      return this._global && (this._lastIndex = 0), this._re2.matcher(t10).find();
    }
    exec(t10) {
      let n10 = this._re2.matcher(t10), r10 = this._global ? this._lastIndex : 0;
      if (!n10.find(r10))
        return this._global && (this._lastIndex = 0), null;
      let s10 = this._re2.groupCount(), i10 = [];
      i10.push(n10.group(0) ?? "");
      for (let l = 1; l <= s10; l++) {
        let c = n10.group(l);
        i10.push(c);
      }
      let o10 = i10;
      o10.index = n10.start(0), o10.input = t10;
      let a = this._re2.namedGroups();
      if (a && Object.keys(a).length > 0) {
        let l = /* @__PURE__ */ Object.create(null);
        for (let [c, u] of Object.entries(a)) {
          let f10 = n10.group(u);
          f10 !== null && (l[c] = f10);
        }
        o10.groups = l;
      }
      return this._global && (this._lastIndex = n10.end(0), n10.start(0) === n10.end(0) && this._lastIndex++), o10;
    }
    match(t10) {
      if (this._global && (this._lastIndex = 0), !this._global)
        return this.exec(t10);
      let n10 = [], r10 = this._re2.matcher(t10), s10 = 0;
      for (; r10.find(s10); ) {
        let i10 = r10.group(0) ?? "";
        if (n10.push(i10), s10 = r10.end(0), r10.start(0) === r10.end(0) && s10++, s10 > t10.length)
          break;
      }
      return n10.length > 0 ? n10 : null;
    }
    replace(t10, n10) {
      if (this._global && (this._lastIndex = 0), typeof n10 == "string") {
        let c = this._re2.matcher(t10);
        return this._global ? c.replaceAll(n10, true) : c.replaceFirst(n10, true);
      }
      let r10 = [], s10 = this._re2.matcher(t10), i10 = 0, o10 = 0, a = this._re2.groupCount(), l = this._re2.namedGroups();
      for (; s10.find(o10); ) {
        r10.push(t10.slice(i10, s10.start(0)));
        let c = [], u = s10.group(0) ?? "";
        for (let f10 = 1; f10 <= a; f10++)
          c.push(s10.group(f10));
        if (c.push(s10.start(0)), c.push(t10), l && Object.keys(l).length > 0) {
          let f10 = /* @__PURE__ */ Object.create(null);
          for (let [p, h] of Object.entries(l))
            f10[p] = s10.group(h) ?? "";
          c.push(f10);
        }
        if (r10.push(n10(u, ...c)), i10 = s10.end(0), o10 = i10, s10.start(0) === s10.end(0) && o10++, !this._global || o10 > t10.length)
          break;
      }
      return r10.push(t10.slice(i10)), r10.join("");
    }
    split(t10, n10) {
      return n10 === void 0 || n10 < 0 ? this._re2.split(t10, -1) : n10 === 0 ? [] : this._re2.split(t10, -1).slice(0, n10);
    }
    search(t10) {
      let n10 = this._re2.matcher(t10);
      return n10.find() ? n10.start(0) : -1;
    }
    *matchAll(t10) {
      if (!this._global)
        throw new Error("matchAll requires global flag");
      this._lastIndex = 0;
      let n10 = this._re2.matcher(t10), r10 = this._re2.groupCount(), s10 = this._re2.namedGroups(), i10 = 0;
      for (; n10.find(i10); ) {
        let o10 = [];
        o10.push(n10.group(0) ?? "");
        for (let l = 1; l <= r10; l++)
          o10.push(n10.group(l));
        let a = o10;
        if (a.index = n10.start(0), a.input = t10, s10 && Object.keys(s10).length > 0) {
          let l = /* @__PURE__ */ Object.create(null);
          for (let [c, u] of Object.entries(s10)) {
            let f10 = n10.group(u);
            f10 !== null && (l[c] = f10);
          }
          a.groups = l;
        }
        if (yield a, i10 = n10.end(0), n10.start(0) === n10.end(0) && i10++, i10 > t10.length)
          break;
      }
    }
    get native() {
      if (!this._nativeRegex)
        try {
          this._nativeRegex = new RegExp(this._pattern, this._flags);
        } catch {
          this._nativeRegex = new RegExp("", this._flags), Object.defineProperty(this._nativeRegex, "source", { value: this._pattern, writable: false });
        }
      return this._nativeRegex;
    }
    get source() {
      return this._pattern;
    }
    get flags() {
      return this._flags;
    }
    get global() {
      return this._global;
    }
    get ignoreCase() {
      return this._ignoreCase;
    }
    get multiline() {
      return this._multiline;
    }
    get lastIndex() {
      return this._lastIndex;
    }
    set lastIndex(t10) {
      this._lastIndex = t10;
    }
  };
  xn = class {
    _regex;
    constructor(t10) {
      this._regex = t10;
    }
    test(t10) {
      return this._regex.global && (this._regex.lastIndex = 0), this._regex.test(t10);
    }
    exec(t10) {
      return this._regex.exec(t10);
    }
    match(t10) {
      return this._regex.global && (this._regex.lastIndex = 0), t10.match(this._regex);
    }
    replace(t10, n10) {
      return this._regex.global && (this._regex.lastIndex = 0), t10.replace(this._regex, n10);
    }
    split(t10, n10) {
      return t10.split(this._regex, n10);
    }
    search(t10) {
      return t10.search(this._regex);
    }
    *matchAll(t10) {
      if (!this._regex.global)
        throw new Error("matchAll requires global flag");
      this._regex.lastIndex = 0;
      let n10 = this._regex.exec(t10);
      for (; n10 !== null; )
        yield n10, n10[0].length === 0 && this._regex.lastIndex++, n10 = this._regex.exec(t10);
    }
    get native() {
      return this._regex;
    }
    get source() {
      return this._regex.source;
    }
    get flags() {
      return this._regex.flags;
    }
    get global() {
      return this._regex.global;
    }
    get ignoreCase() {
      return this._regex.ignoreCase;
    }
    get multiline() {
      return this._regex.multiline;
    }
    get lastIndex() {
      return this._regex.lastIndex;
    }
    set lastIndex(t10) {
      this._regex.lastIndex = t10;
    }
  };
});
var Fe = I(() => {
  "use strict";
  Of();
});
function bt(e11, t10, n10) {
  let r10 = typeof n10 == "boolean" ? { ignoreCase: n10 } : n10 ?? {}, s10 = t10;
  r10.stripQuotes && (s10.startsWith('"') && s10.endsWith('"') || s10.startsWith("'") && s10.endsWith("'")) && (s10 = s10.slice(1, -1));
  let i10 = r10.ignoreCase ? `i:${s10}` : s10, o10 = Rf.get(i10);
  return o10 || (o10 = a4(s10, r10.ignoreCase), Rf.set(i10, o10)), o10.test(e11);
}
function a4(e11, t10) {
  let n10 = "^";
  for (let r10 = 0; r10 < e11.length; r10++) {
    let s10 = e11[r10];
    if (s10 === "*")
      n10 += ".*";
    else if (s10 === "?")
      n10 += ".";
    else if (s10 === "[") {
      let i10 = r10 + 1;
      for (; i10 < e11.length && e11[i10] !== "]"; )
        i10++;
      n10 += e11.slice(r10, i10 + 1), r10 = i10;
    } else
      s10 === "." || s10 === "+" || s10 === "^" || s10 === "$" || s10 === "{" || s10 === "}" || s10 === "(" || s10 === ")" || s10 === "|" || s10 === "\\" ? n10 += `\\${s10}` : n10 += s10;
  }
  return n10 += "$", V(n10, t10 ? "i" : "");
}
var Rf;
var Xo = I(() => {
  "use strict";
  Fe();
  Rf = /* @__PURE__ */ new Map();
});
function $f(e11, t10) {
  return e11.replace(/\$(&|\d+|<([^>]+)>)/g, (n10, r10, s10) => {
    if (r10 === "&")
      return t10[0];
    if (s10 !== void 0)
      return t10.groups?.[s10] ?? "";
    let i10 = parseInt(r10, 10);
    return t10[i10] ?? "";
  });
}
function mr(e11, t10, n10 = {}) {
  let { invertMatch: r10 = false, showLineNumbers: s10 = false, countOnly: i10 = false, countMatches: o10 = false, filename: a = "", onlyMatching: l = false, beforeContext: c = 0, afterContext: u = 0, maxCount: f10 = 0, contextSeparator: p = "--", showColumn: h = false, vimgrep: m = false, showByteOffset: d = false, replace: g = null, passthru: y = false, multiline: w = false, kResetGroup: b } = n10;
  if (w)
    return l4(e11, t10, { invertMatch: r10, showLineNumbers: s10, countOnly: i10, countMatches: o10, filename: a, onlyMatching: l, beforeContext: c, afterContext: u, maxCount: f10, contextSeparator: p, showColumn: h, showByteOffset: d, replace: g, kResetGroup: b });
  let x = e11.split(`
`), S = x.length, O = S > 0 && x[S - 1] === "" ? S - 1 : S;
  if (i10 || o10) {
    let N10 = 0, P = (o10 || l) && !r10;
    for (let T = 0; T < O; T++)
      if (t10.lastIndex = 0, P)
        for (let L = t10.exec(x[T]); L !== null; L = t10.exec(x[T]))
          N10++, L[0].length === 0 && t10.lastIndex++;
      else
        t10.test(x[T]) !== r10 && N10++;
    return { output: `${a ? `${a}:${N10}` : String(N10)}
`, matched: N10 > 0, matchCount: N10 };
  }
  if (c === 0 && u === 0 && !y) {
    let N10 = [], P = false, v = 0, T = 0;
    for (let L = 0; L < O && !(f10 > 0 && v >= f10); L++) {
      let ue = x[L];
      if (t10.lastIndex = 0, t10.test(ue) !== r10)
        if (P = true, v++, l) {
          t10.lastIndex = 0;
          for (let J = t10.exec(ue); J !== null; J = t10.exec(ue)) {
            let H = b !== void 0 ? J[b] ?? "" : J[0], X = g !== null ? $f(g, J) : H, Ee = a ? `${a}:` : "";
            d && (Ee += `${T + J.index}:`), s10 && (Ee += `${L + 1}:`), h && (Ee += `${J.index + 1}:`), N10.push(Ee + X), J[0].length === 0 && t10.lastIndex++;
          }
        } else if (m) {
          t10.lastIndex = 0;
          for (let J = t10.exec(ue); J !== null; J = t10.exec(ue)) {
            let H = a ? `${a}:` : "";
            d && (H += `${T + J.index}:`), s10 && (H += `${L + 1}:`), h && (H += `${J.index + 1}:`), N10.push(H + ue), J[0].length === 0 && t10.lastIndex++;
          }
        } else {
          t10.lastIndex = 0;
          let J = t10.exec(ue), H = J ? J.index + 1 : 1, X = ue;
          g !== null && (t10.lastIndex = 0, X = t10.replace(ue, (...oe) => {
            if (oe[0].length === 0)
              return "";
            let j = oe, ve = oe[oe.length - 1];
            return typeof ve == "object" && ve !== null ? (j.groups = ve, j.input = oe[oe.length - 2], j.index = oe[oe.length - 3]) : (j.input = oe[oe.length - 1], j.index = oe[oe.length - 2]), $f(g, j);
          }));
          let Ee = a ? `${a}:` : "";
          d && (Ee += `${T + (J ? J.index : 0)}:`), s10 && (Ee += `${L + 1}:`), h && (Ee += `${H}:`), N10.push(Ee + X);
        }
      T += ue.length + 1;
    }
    return { output: N10.length > 0 ? `${N10.join(`
`)}
` : "", matched: P, matchCount: v };
  }
  if (y) {
    let N10 = [], P = false, v = 0;
    for (let T = 0; T < O; T++) {
      let L = x[T];
      t10.lastIndex = 0;
      let re = t10.test(L) !== r10;
      re && (P = true, v++);
      let J = re ? ":" : "-", H = a ? `${a}${J}` : "";
      s10 && (H += `${T + 1}${J}`), N10.push(H + L);
    }
    return { output: N10.length > 0 ? `${N10.join(`
`)}
` : "", matched: P, matchCount: v };
  }
  let R10 = [], F4 = 0, $ = /* @__PURE__ */ new Set(), z = -1, k = [];
  for (let N10 = 0; N10 < O && !(f10 > 0 && F4 >= f10); N10++)
    t10.lastIndex = 0, t10.test(x[N10]) !== r10 && (k.push(N10), F4++);
  for (let N10 of k) {
    let P = Math.max(0, N10 - c);
    z >= 0 && P > z + 1 && R10.push(p);
    for (let T = P; T < N10; T++)
      if (!$.has(T)) {
        $.add(T), z = T;
        let L = x[T];
        s10 && (L = `${T + 1}-${L}`), a && (L = `${a}-${L}`), R10.push(L);
      }
    if (!$.has(N10)) {
      $.add(N10), z = N10;
      let T = x[N10];
      if (l) {
        t10.lastIndex = 0;
        for (let L = t10.exec(T); L !== null; L = t10.exec(T)) {
          let ue = b !== void 0 ? L[b] ?? "" : L[0], re = g !== null ? g : ue, J = a ? `${a}:` : "";
          s10 && (J += `${N10 + 1}:`), h && (J += `${L.index + 1}:`), R10.push(J + re), L[0].length === 0 && t10.lastIndex++;
        }
      } else {
        let L = T;
        s10 && (L = `${N10 + 1}:${L}`), a && (L = `${a}:${L}`), R10.push(L);
      }
    }
    let v = Math.min(O - 1, N10 + u);
    for (let T = N10 + 1; T <= v; T++)
      if (!$.has(T)) {
        $.add(T), z = T;
        let L = x[T];
        s10 && (L = `${T + 1}-${L}`), a && (L = `${a}-${L}`), R10.push(L);
      }
  }
  return { output: R10.length > 0 ? `${R10.join(`
`)}
` : "", matched: F4 > 0, matchCount: F4 };
}
function l4(e11, t10, n10) {
  let { invertMatch: r10, showLineNumbers: s10, countOnly: i10, countMatches: o10, filename: a, onlyMatching: l, beforeContext: c, afterContext: u, maxCount: f10, contextSeparator: p, showColumn: h, showByteOffset: m, replace: d, kResetGroup: g } = n10, y = e11.split(`
`), w = y.length, b = w > 0 && y[w - 1] === "" ? w - 1 : w, x = [0];
  for (let k = 0; k < e11.length; k++)
    e11[k] === `
` && x.push(k + 1);
  let S = (k) => {
    let N10 = 0;
    for (let P = 0; P < x.length && !(x[P] > k); P++)
      N10 = P;
    return N10;
  }, O = (k) => {
    let N10 = S(k);
    return k - x[N10] + 1;
  }, R10 = [];
  t10.lastIndex = 0;
  for (let k = t10.exec(e11); k !== null && !(f10 > 0 && R10.length >= f10); k = t10.exec(e11)) {
    let N10 = S(k.index), P = S(k.index + Math.max(0, k[0].length - 1)), v = g !== void 0 ? k[g] ?? "" : k[0];
    R10.push({ startLine: N10, endLine: P, byteOffset: k.index, column: O(k.index), matchText: v }), k[0].length === 0 && t10.lastIndex++;
  }
  if (i10 || o10) {
    let k;
    if (o10)
      k = r10 ? 0 : R10.length;
    else {
      let P = /* @__PURE__ */ new Set();
      for (let v of R10)
        for (let T = v.startLine; T <= v.endLine; T++)
          P.add(T);
      k = r10 ? b - P.size : P.size;
    }
    return { output: `${a ? `${a}:${k}` : String(k)}
`, matched: k > 0, matchCount: k };
  }
  if (r10) {
    let k = /* @__PURE__ */ new Set();
    for (let P of R10)
      for (let v = P.startLine; v <= P.endLine; v++)
        k.add(v);
    let N10 = [];
    for (let P = 0; P < b; P++)
      if (!k.has(P)) {
        let v = y[P];
        s10 && (v = `${P + 1}:${v}`), a && (v = `${a}:${v}`), N10.push(v);
      }
    return { output: N10.length > 0 ? `${N10.join(`
`)}
` : "", matched: N10.length > 0, matchCount: N10.length };
  }
  if (R10.length === 0)
    return { output: "", matched: false, matchCount: 0 };
  let F4 = /* @__PURE__ */ new Set(), $ = -1, z = [];
  for (let k of R10) {
    let N10 = Math.max(0, k.startLine - c), P = Math.min(b - 1, k.endLine + u);
    $ >= 0 && N10 > $ + 1 && z.push(p);
    for (let v = N10; v < k.startLine; v++)
      if (!F4.has(v)) {
        F4.add(v), $ = v;
        let T = y[v];
        s10 && (T = `${v + 1}-${T}`), a && (T = `${a}-${T}`), z.push(T);
      }
    if (l) {
      let v = d !== null ? d : k.matchText, T = a ? `${a}:` : "";
      m && (T += `${k.byteOffset}:`), s10 && (T += `${k.startLine + 1}:`), h && (T += `${k.column}:`), z.push(T + v);
      for (let L = k.startLine; L <= k.endLine; L++)
        F4.add(L), $ = L;
    } else
      for (let v = k.startLine; v <= k.endLine && v < b; v++)
        if (!F4.has(v)) {
          F4.add(v), $ = v;
          let T = y[v];
          d !== null && v === k.startLine && (t10.lastIndex = 0, T = t10.replace(T, d));
          let L = a ? `${a}:` : "";
          m && v === k.startLine && (L += `${k.byteOffset}:`), s10 && (L += `${v + 1}:`), h && v === k.startLine && (L += `${k.column}:`), z.push(L + T);
        }
    for (let v = k.endLine + 1; v <= P; v++)
      if (!F4.has(v)) {
        F4.add(v), $ = v;
        let T = y[v];
        s10 && (T = `${v + 1}-${T}`), a && (T = `${a}-${T}`), z.push(T);
      }
  }
  return { output: z.length > 0 ? `${z.join(`
`)}
` : "", matched: true, matchCount: R10.length };
}
var Tf = I(() => {
  "use strict";
});
function Pf(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; ) {
    if (e11.slice(n10, n10 + 7) === "[[:<:]]") {
      t10 += "\\b", n10 += 7;
      continue;
    }
    if (e11.slice(n10, n10 + 7) === "[[:>:]]") {
      t10 += "\\b", n10 += 7;
      continue;
    }
    if (e11[n10] === "[") {
      let r10 = "[";
      for (n10++, n10 < e11.length && (e11[n10] === "^" || e11[n10] === "!") && (r10 += "^", n10++), n10 < e11.length && e11[n10] === "]" && (r10 += "\\]", n10++); n10 < e11.length && e11[n10] !== "]"; ) {
        if (e11[n10] === "[" && n10 + 1 < e11.length && e11[n10 + 1] === ":") {
          let s10 = e11.indexOf(":]", n10 + 2);
          if (s10 !== -1) {
            let i10 = e11.slice(n10 + 2, s10), o10 = c4.get(i10);
            if (o10) {
              r10 += o10, n10 = s10 + 2;
              continue;
            }
          }
        }
        if (e11[n10] === "\\" && n10 + 1 < e11.length) {
          r10 += e11[n10] + e11[n10 + 1], n10 += 2;
          continue;
        }
        r10 += e11[n10], n10++;
      }
      n10 < e11.length && e11[n10] === "]" && (r10 += "]", n10++), t10 += r10;
      continue;
    }
    if (e11[n10] === "\\" && n10 + 1 < e11.length) {
      t10 += e11[n10] + e11[n10 + 1], n10 += 2;
      continue;
    }
    t10 += e11[n10], n10++;
  }
  return t10;
}
function Xr(e11, t10) {
  let n10, r10;
  switch (t10.mode) {
    case "fixed":
      n10 = e11.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      break;
    case "extended":
    case "perl": {
      if (n10 = Pf(e11), n10 = n10.replace(/\(\?P<([^>]+)>/g, "(?<$1>"), t10.mode === "perl") {
        n10 = u4(n10), n10 = f4(n10), n10 = p4(n10);
        let o10 = g4(n10);
        n10 = o10.pattern, r10 = o10.kResetGroup;
      }
      break;
    }
    default:
      n10 = Pf(e11), n10 = b4(n10);
      break;
  }
  t10.wholeWord && (n10 = `\\b(?:${n10})\\b`), t10.lineRegexp && (n10 = `^${n10}$`);
  let s10 = /\\u\{[0-9A-Fa-f]+\}/.test(n10), i10 = "g" + (t10.ignoreCase ? "i" : "") + (t10.multiline ? "m" : "") + (t10.multilineDotall ? "s" : "") + (s10 ? "u" : "");
  return { regex: V(n10, i10), kResetGroup: r10 };
}
function u4(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; )
    if (e11[n10] === "\\" && n10 + 1 < e11.length && e11[n10 + 1] === "Q") {
      n10 += 2;
      let r10 = "";
      for (; n10 < e11.length; ) {
        if (e11[n10] === "\\" && n10 + 1 < e11.length && e11[n10 + 1] === "E") {
          n10 += 2;
          break;
        }
        r10 += e11[n10], n10++;
      }
      t10 += r10.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    } else
      t10 += e11[n10], n10++;
  return t10;
}
function f4(e11) {
  return e11.replace(/\\x\{([0-9A-Fa-f]+)\}/g, "\\u{$1}");
}
function p4(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; ) {
    if (e11[n10] === "(" && n10 + 1 < e11.length && e11[n10 + 1] === "?") {
      let r10 = e11.slice(n10).match(/^\(\?([imsx]*)(-[imsx]*)?(:|$|\))/);
      if (r10) {
        let s10 = r10[1] || "", i10 = r10[2] || "", o10 = r10[3];
        if (o10 === ":") {
          let a = n10 + r10[0].length - 1, l = h4(e11, n10);
          if (l !== -1) {
            let c = e11.slice(a + 1, l), u = d4(c, s10, i10);
            t10 += `(?:${u})`, n10 = l + 1;
            continue;
          }
        } else if (o10 === ")" || o10 === "") {
          n10 += r10[0].length;
          continue;
        }
      }
    }
    t10 += e11[n10], n10++;
  }
  return t10;
}
function h4(e11, t10) {
  let n10 = 0, r10 = t10;
  for (; r10 < e11.length; ) {
    if (e11[r10] === "\\") {
      r10 += 2;
      continue;
    }
    if (e11[r10] === "[") {
      for (r10++; r10 < e11.length && e11[r10] !== "]"; )
        e11[r10] === "\\" && r10++, r10++;
      r10++;
      continue;
    }
    if (e11[r10] === "(")
      n10++;
    else if (e11[r10] === ")" && (n10--, n10 === 0))
      return r10;
    r10++;
  }
  return -1;
}
function d4(e11, t10, n10) {
  let r10 = e11;
  return t10.includes("i") && (r10 = m4(r10)), r10;
}
function m4(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; ) {
    let r10 = e11[n10];
    if (r10 === "\\") {
      n10 + 1 < e11.length ? (t10 += r10 + e11[n10 + 1], n10 += 2) : (t10 += r10, n10++);
      continue;
    }
    if (r10 === "[") {
      t10 += r10, n10++, n10 < e11.length && e11[n10] === "^" && (t10 += e11[n10], n10++);
      let s10 = [];
      for (; n10 < e11.length && e11[n10] !== "]"; )
        if (e11[n10] === "\\")
          s10.push(e11[n10]), n10++, n10 < e11.length && (s10.push(e11[n10]), n10++);
        else if (e11[n10] === "-" && s10.length > 0 && n10 + 1 < e11.length && e11[n10 + 1] !== "]") {
          let i10 = s10[s10.length - 1], o10 = e11[n10 + 1];
          s10.push("-"), s10.push(o10), /[a-z]/.test(i10) && /[a-z]/.test(o10) ? (s10.push(i10.toUpperCase()), s10.push("-"), s10.push(o10.toUpperCase())) : /[A-Z]/.test(i10) && /[A-Z]/.test(o10) && (s10.push(i10.toLowerCase()), s10.push("-"), s10.push(o10.toLowerCase())), n10 += 2;
        } else {
          let i10 = e11[n10];
          if (s10.push(i10), /[a-zA-Z]/.test(i10)) {
            let o10 = i10 === i10.toLowerCase() ? i10.toUpperCase() : i10.toLowerCase();
            s10.includes(o10) || s10.push(o10);
          }
          n10++;
        }
      t10 += s10.join(""), n10 < e11.length && (t10 += e11[n10], n10++);
      continue;
    }
    if (/[a-zA-Z]/.test(r10)) {
      let s10 = r10.toLowerCase(), i10 = r10.toUpperCase();
      t10 += `[${i10}${s10}]`;
    } else
      t10 += r10;
    n10++;
  }
  return t10;
}
function g4(e11) {
  let t10 = y4(e11);
  if (t10 === -1)
    return { pattern: e11 };
  let n10 = e11.slice(0, t10), r10 = e11.slice(t10 + 2), s10 = w4(n10);
  return { pattern: `(?:${n10})(${r10})`, kResetGroup: s10 + 1 };
}
function y4(e11) {
  let t10 = 0;
  for (; t10 < e11.length - 1; )
    if (e11[t10] === "\\") {
      if (e11[t10 + 1] === "K") {
        let n10 = 0, r10 = t10 - 1;
        for (; r10 >= 0 && e11[r10] === "\\"; )
          n10++, r10--;
        if (n10 % 2 === 0)
          return t10;
      }
      t10 += 2;
    } else
      t10++;
  return -1;
}
function w4(e11) {
  let t10 = 0, n10 = 0;
  for (; n10 < e11.length; ) {
    if (e11[n10] === "\\") {
      n10 += 2;
      continue;
    }
    if (e11[n10] === "[") {
      for (n10++; n10 < e11.length && e11[n10] !== "]"; )
        e11[n10] === "\\" && n10++, n10++;
      n10++;
      continue;
    }
    if (e11[n10] === "(")
      if (n10 + 1 < e11.length && e11[n10 + 1] === "?") {
        if (n10 + 2 < e11.length) {
          let r10 = e11[n10 + 2];
          if (r10 === ":" || r10 === "=" || r10 === "!") {
            n10++;
            continue;
          }
          if (r10 === "<" && n10 + 3 < e11.length) {
            let s10 = e11[n10 + 3];
            if (s10 === "=" || s10 === "!") {
              n10++;
              continue;
            }
            t10++, n10++;
            continue;
          }
        }
      } else
        t10++;
    n10++;
  }
  return t10;
}
function Yo(e11) {
  let t10 = e11.replace(/\$\{0\}|\$0(?![0-9])/g, "$$&");
  return t10 = t10.replace(/\$\{([^0-9}][^}]*)\}/g, "$$<$1>"), t10 = t10.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)(?![>0-9])/g, "$$<$1>"), t10;
}
function b4(e11) {
  let t10 = "", n10 = 0, r10 = true, s10 = 0;
  for (; n10 < e11.length; ) {
    let i10 = e11[n10];
    if (i10 === "[") {
      for (t10 += i10, n10++, n10 < e11.length && (e11[n10] === "^" || e11[n10] === "!") && (t10 += e11[n10], n10++), n10 < e11.length && e11[n10] === "]" && (t10 += e11[n10], n10++); n10 < e11.length && e11[n10] !== "]"; )
        e11[n10] === "\\" && n10 + 1 < e11.length ? (t10 += e11[n10] + e11[n10 + 1], n10 += 2) : (t10 += e11[n10], n10++);
      n10 < e11.length && e11[n10] === "]" && (t10 += e11[n10], n10++), r10 = false;
      continue;
    }
    if (i10 === "\\" && n10 + 1 < e11.length) {
      let o10 = e11[n10 + 1];
      if (o10 === "|") {
        t10 += "|", n10 += 2, r10 = true;
        continue;
      }
      if (o10 === "(") {
        t10 += "(", n10 += 2, s10++, r10 = true;
        continue;
      }
      if (o10 === ")") {
        t10 += ")", n10 += 2, s10 = Math.max(0, s10 - 1), r10 = false;
        continue;
      }
      if (o10 === "{") {
        let l = e11.slice(n10).match(/^\\{(\d+)(,(\d*)?)?\\}/);
        if (l) {
          let c = l[1], u = l[2] !== void 0, f10 = l[3] || "";
          u ? t10 += `{${c},${f10}}` : t10 += `{${c}}`, n10 += l[0].length, r10 = false;
          continue;
        }
        t10 += "\\{", n10 += 2, r10 = false;
        continue;
      }
      if (o10 === "}") {
        t10 += "\\}", n10 += 2, r10 = false;
        continue;
      }
      t10 += i10 + o10, n10 += 2, r10 = false;
      continue;
    }
    if (i10 === "*" && r10) {
      t10 += "\\*", n10++;
      continue;
    }
    if (i10 === "^") {
      if (r10) {
        t10 += "^", n10++;
        continue;
      }
      t10 += "\\^", n10++;
      continue;
    }
    if (i10 === "$") {
      let o10 = n10 === e11.length - 1, a = n10 + 2 < e11.length && e11[n10 + 1] === "\\" && e11[n10 + 2] === ")";
      o10 || a ? t10 += "$" : t10 += "\\$", n10++, r10 = false;
      continue;
    }
    i10 === "+" || i10 === "?" || i10 === "|" || i10 === "(" || i10 === ")" || i10 === "{" || i10 === "}" ? t10 += `\\${i10}` : t10 += i10, n10++, r10 = false;
  }
  return t10;
}
var c4;
var Df = I(() => {
  "use strict";
  Fe();
  c4 = /* @__PURE__ */ new Map([["alpha", "a-zA-Z"], ["digit", "0-9"], ["alnum", "a-zA-Z0-9"], ["lower", "a-z"], ["upper", "A-Z"], ["xdigit", "0-9A-Fa-f"], ["space", " \\t\\n\\r\\f\\v"], ["blank", " \\t"], ["punct", "!-/:-@\\[-`{-~"], ["graph", "!-~"], ["print", " -~"], ["cntrl", "\\x00-\\x1F\\x7F"], ["ascii", "\\x00-\\x7F"], ["word", "a-zA-Z0-9_"]]);
});
var Jo = I(() => {
  "use strict";
  Tf();
  Df();
});
var Qs = {};
Q(Qs, { egrepCommand: () => S4, egrepFlagsForFuzzing: () => k4, fgrepCommand: () => A4, fgrepFlagsForFuzzing: () => N4, flagsForFuzzing: () => C4, grepCommand: () => ea });
async function _f(e11, t10, n10, r10) {
  let s10 = n10.fs.resolvePath(n10.cwd, e11);
  try {
    if (!(await n10.fs.stat(s10)).isDirectory) {
      let a = e11.split("/").pop() || "";
      if (t10) {
        let l = t10.replace(/^\//, "");
        bt(a, l, { stripQuotes: true }) && r10.push(e11);
      }
      return;
    }
    let o10 = await n10.fs.readdir(s10);
    for (let a of o10) {
      let l = e11 === "." ? a : `${e11}/${a}`, c = n10.fs.resolvePath(n10.cwd, l);
      if ((await n10.fs.stat(c)).isDirectory)
        await _f(l, t10, n10, r10);
      else if (t10) {
        let f10 = t10.replace(/^\//, "");
        bt(a, f10, { stripQuotes: true }) && r10.push(l);
      }
    }
  } catch {
  }
}
async function E4(e11, t10) {
  let n10 = [], r10 = e11.lastIndexOf("/"), s10, i10;
  if (r10 === -1 ? (s10 = t10.cwd, i10 = e11) : (s10 = e11.slice(0, r10) || "/", i10 = e11.slice(r10 + 1)), e11.includes("**")) {
    let a = [], l = e11.split("**"), c = l[0].replace(/\/$/, "") || ".", u = l[1] || "";
    return await _f(c, u, t10, a), a.map((f10) => ({ path: f10 }));
  }
  let o10 = t10.fs.resolvePath(t10.cwd, s10);
  try {
    if (t10.fs.readdirWithFileTypes) {
      let a = await t10.fs.readdirWithFileTypes(o10);
      for (let l of a)
        if (bt(l.name, i10, { stripQuotes: true })) {
          let c = r10 === -1 ? l.name : `${s10}/${l.name}`;
          n10.push({ path: c, isFile: l.isFile });
        }
    } else {
      let a = await t10.fs.readdir(o10);
      for (let l of a)
        if (bt(l, i10, { stripQuotes: true })) {
          let c = r10 === -1 ? l : `${s10}/${l}`;
          n10.push({ path: c });
        }
    }
  } catch {
  }
  return n10.sort((a, l) => a.path.localeCompare(l.path));
}
async function Zs(e11, t10, n10 = [], r10 = [], s10 = [], i10) {
  let o10 = t10.fs.resolvePath(t10.cwd, e11), a = [];
  try {
    let l, c;
    if (i10 !== void 0)
      l = i10, c = !i10;
    else {
      let f10 = await t10.fs.stat(o10);
      l = f10.isFile, c = f10.isDirectory;
    }
    if (l) {
      let f10 = e11.split("/").pop() || e11;
      return r10.length > 0 && r10.some((p) => bt(f10, p, { stripQuotes: true })) ? [] : n10.length > 0 && !n10.some((p) => bt(f10, p, { stripQuotes: true })) ? [] : [{ path: e11, isFile: true }];
    }
    if (!c)
      return [];
    let u = e11.split("/").pop() || e11;
    if (s10.length > 0 && s10.some((f10) => bt(u, f10, { stripQuotes: true })))
      return [];
    if (t10.fs.readdirWithFileTypes) {
      let f10 = await t10.fs.readdirWithFileTypes(o10);
      for (let p of f10) {
        if (p.name.startsWith("."))
          continue;
        let h = e11 === "." ? p.name : `${e11}/${p.name}`, m = await Zs(h, t10, n10, r10, s10, p.isFile);
        a.push(...m);
      }
    } else {
      let f10 = await t10.fs.readdir(o10);
      for (let p of f10) {
        if (p.startsWith("."))
          continue;
        let h = e11 === "." ? p : `${e11}/${p}`, m = await Zs(h, t10, n10, r10, s10);
        a.push(...m);
      }
    }
  } catch {
  }
  return a;
}
var x4;
var ea;
var A4;
var S4;
var C4;
var N4;
var k4;
var Ks = I(() => {
  "use strict";
  Xo();
  se();
  Jo();
  x4 = { name: "grep", summary: "print lines that match patterns", usage: "grep [OPTION]... PATTERN [FILE]...", options: ["-E, --extended-regexp    PATTERN is an extended regular expression", "-P, --perl-regexp        PATTERN is a Perl regular expression", "-F, --fixed-strings      PATTERN is a set of newline-separated strings", "-i, --ignore-case        ignore case distinctions", "-v, --invert-match       select non-matching lines", "-w, --word-regexp        match only whole words", "-x, --line-regexp        match only whole lines", "-c, --count              print only a count of matching lines", "-l, --files-with-matches print only names of files with matches", "-L, --files-without-match print names of files with no matches", "-m NUM, --max-count=NUM  stop after NUM matches", "-n, --line-number        print line number with output lines", "-h, --no-filename        suppress the file name prefix on output", "-o, --only-matching      show only nonempty parts of lines that match", "-q, --quiet, --silent    suppress all normal output", "-r, -R, --recursive      search directories recursively", "-A NUM                   print NUM lines of trailing context", "-B NUM                   print NUM lines of leading context", "-C NUM                   print NUM lines of context", "-e PATTERN               use PATTERN for matching", "    --include=GLOB       search only files matching GLOB", "    --exclude=GLOB       skip files matching GLOB", "    --exclude-dir=DIR    skip directories matching DIR", "    --help               display this help and exit"] }, ea = { name: "grep", async execute(e11, t10) {
    if (U2(e11))
      return M(x4);
    let n10 = false, r10 = false, s10 = false, i10 = false, o10 = false, a = false, l = false, c = false, u = false, f10 = false, p = false, h = false, m = false, d = false, g = false, y = 0, w = 0, b = 0, x = [], S = [], O = [], R10 = null, F4 = [];
    for (let H = 0; H < e11.length; H++) {
      let X = e11[H];
      if (X.startsWith("-") && X !== "-") {
        if (X === "-e" && H + 1 < e11.length) {
          R10 = e11[++H];
          continue;
        }
        if (X.startsWith("--include=")) {
          x.push(X.slice(10));
          continue;
        }
        if (X.startsWith("--exclude=")) {
          S.push(X.slice(10));
          continue;
        }
        if (X.startsWith("--exclude-dir=")) {
          O.push(X.slice(14));
          continue;
        }
        if (X.startsWith("--max-count=")) {
          y = parseInt(X.slice(12), 10);
          continue;
        }
        let Ee = X.match(/^-m(\d+)$/);
        if (Ee) {
          y = parseInt(Ee[1], 10);
          continue;
        }
        if (X === "-m" && H + 1 < e11.length) {
          y = parseInt(e11[++H], 10);
          continue;
        }
        let oe = X.match(/^-([ABC])(\d+)$/);
        if (oe) {
          let j = parseInt(oe[2], 10);
          oe[1] === "A" ? b = j : oe[1] === "B" ? w = j : oe[1] === "C" && (w = j, b = j);
          continue;
        }
        if ((X === "-A" || X === "-B" || X === "-C") && H + 1 < e11.length) {
          let j = parseInt(e11[++H], 10);
          X === "-A" ? b = j : X === "-B" ? w = j : (w = j, b = j);
          continue;
        }
        let ke = X.startsWith("--") ? [X] : X.slice(1).split("");
        for (let j of ke)
          if (j === "i" || j === "--ignore-case")
            n10 = true;
          else if (j === "n" || j === "--line-number")
            r10 = true;
          else if (j === "v" || j === "--invert-match")
            s10 = true;
          else if (j === "c" || j === "--count")
            i10 = true;
          else if (j === "l" || j === "--files-with-matches")
            o10 = true;
          else if (j === "L" || j === "--files-without-match")
            a = true;
          else if (j === "r" || j === "R" || j === "--recursive")
            l = true;
          else if (j === "w" || j === "--word-regexp")
            c = true;
          else if (j === "x" || j === "--line-regexp")
            u = true;
          else if (j === "E" || j === "--extended-regexp")
            f10 = true;
          else if (j === "P" || j === "--perl-regexp")
            p = true;
          else if (j === "F" || j === "--fixed-strings")
            h = true;
          else if (j === "o" || j === "--only-matching")
            m = true;
          else if (j === "h" || j === "--no-filename")
            d = true;
          else if (j === "q" || j === "--quiet" || j === "--silent")
            g = true;
          else {
            if (j.startsWith("--"))
              return Y("grep", j);
            if (j.length === 1)
              return Y("grep", `-${j}`);
          }
      } else
        R10 === null ? R10 = X : F4.push(X);
    }
    if (R10 === null)
      return { stdout: "", stderr: `grep: missing pattern
`, exitCode: 2 };
    let $ = h ? "fixed" : f10 ? "extended" : p ? "perl" : "basic", z, k;
    try {
      let H = Xr(R10, { mode: $, ignoreCase: n10, wholeWord: c, lineRegexp: u });
      z = H.regex, k = H.kResetGroup;
    } catch {
      return { stdout: "", stderr: `grep: invalid regular expression: ${R10}
`, exitCode: 2 };
    }
    if (F4.length === 0 && t10.stdin !== void 0) {
      let H = mr(t10.stdin, z, { invertMatch: s10, showLineNumbers: r10, countOnly: i10, filename: "", onlyMatching: m, beforeContext: w, afterContext: b, maxCount: y, kResetGroup: k });
      return g ? { stdout: "", stderr: "", exitCode: H.matched ? 0 : 1 } : { stdout: H.output, stderr: "", exitCode: H.matched ? 0 : 1 };
    }
    if (F4.length === 0)
      return { stdout: "", stderr: `grep: no input files
`, exitCode: 2 };
    let N10 = "", P = "", v = false, T = false, L = [];
    for (let H of F4)
      if (H.includes("*") || H.includes("?") || H.includes("[")) {
        let X = await E4(H, t10);
        if (l)
          for (let Ee of X) {
            let oe = await Zs(Ee.path, t10, x, S, O, Ee.isFile);
            L.push(...oe);
          }
        else
          L.push(...X);
      } else if (l) {
        let X = await Zs(H, t10, x, S, O);
        L.push(...X);
      } else
        L.push({ path: H });
    let ue = (L.length > 1 || l) && !d, re = 50;
    for (let H = 0; H < L.length; H += re) {
      let X = L.slice(H, H + re), Ee = await Promise.all(X.map(async (oe) => {
        let ke = oe.path, j = ke.split("/").pop() || ke;
        if (S.length > 0 && !l && S.some((ve) => bt(j, ve, { stripQuotes: true })) || x.length > 0 && !l && !x.some((ve) => bt(j, ve, { stripQuotes: true })))
          return null;
        try {
          let ve = t10.fs.resolvePath(t10.cwd, ke), Le = false;
          if (oe.isFile === void 0 ? Le = (await t10.fs.stat(ve)).isDirectory : Le = !oe.isFile, Le)
            return l ? null : { error: `grep: ${ke}: Is a directory
` };
          let He = await t10.fs.readFile(ve), Je = mr(He, z, { invertMatch: s10, showLineNumbers: r10, countOnly: i10, filename: ue ? ke : "", onlyMatching: m, beforeContext: w, afterContext: b, maxCount: y, kResetGroup: k });
          return { file: ke, result: Je };
        } catch {
          return { error: `grep: ${ke}: No such file or directory
` };
        }
      }));
      for (let oe of Ee) {
        if (oe === null)
          continue;
        if ("error" in oe && oe.error) {
          P += oe.error, oe.error.includes("Is a directory") || (T = true);
          continue;
        }
        if (!("file" in oe) || !oe.result)
          continue;
        let { file: ke, result: j } = oe;
        if (j.matched) {
          if (v = true, g)
            return { stdout: "", stderr: "", exitCode: 0 };
          o10 ? N10 += `${ke}
` : a || (N10 += j.output);
        } else
          a ? N10 += `${ke}
` : i10 && !o10 && (N10 += j.output);
      }
    }
    let J;
    return T ? J = 2 : a ? J = N10.length > 0 ? 0 : 1 : J = v ? 0 : 1, g ? { stdout: "", stderr: "", exitCode: J } : { stdout: N10, stderr: P, exitCode: J };
  } };
  A4 = { name: "fgrep", async execute(e11, t10) {
    return ea.execute(["-F", ...e11], t10);
  } }, S4 = { name: "egrep", async execute(e11, t10) {
    return ea.execute(["-E", ...e11], t10);
  } }, C4 = { name: "grep", flags: [{ flag: "-E", type: "boolean" }, { flag: "-F", type: "boolean" }, { flag: "-P", type: "boolean" }, { flag: "-i", type: "boolean" }, { flag: "-v", type: "boolean" }, { flag: "-w", type: "boolean" }, { flag: "-x", type: "boolean" }, { flag: "-c", type: "boolean" }, { flag: "-l", type: "boolean" }, { flag: "-L", type: "boolean" }, { flag: "-n", type: "boolean" }, { flag: "-h", type: "boolean" }, { flag: "-o", type: "boolean" }, { flag: "-q", type: "boolean" }, { flag: "-r", type: "boolean" }, { flag: "-m", type: "value", valueHint: "number" }, { flag: "-A", type: "value", valueHint: "number" }, { flag: "-B", type: "value", valueHint: "number" }, { flag: "-C", type: "value", valueHint: "number" }, { flag: "-e", type: "value", valueHint: "pattern" }], stdinType: "text", needsArgs: true }, N4 = { name: "fgrep", flags: [], stdinType: "text", needsArgs: true }, k4 = { name: "egrep", flags: [], stdinType: "text", needsArgs: true };
});
function Ff() {
  let e11 = [];
  for (let [t10, n10] of Object.entries(Lf).sort()) {
    let r10 = [];
    for (let s10 of n10.extensions)
      r10.push(`*${s10}`);
    for (let s10 of n10.globs)
      r10.push(s10);
    e11.push(`${t10}: ${r10.join(", ")}`);
  }
  return `${e11.join(`
`)}
`;
}
var Lf;
var Yr;
var ta = I(() => {
  "use strict";
  Fe();
  Lf = { js: { extensions: [".js", ".mjs", ".cjs", ".jsx"], globs: [] }, ts: { extensions: [".ts", ".tsx", ".mts", ".cts"], globs: [] }, html: { extensions: [".html", ".htm", ".xhtml"], globs: [] }, css: { extensions: [".css", ".scss", ".sass", ".less"], globs: [] }, json: { extensions: [".json", ".jsonc", ".json5"], globs: [] }, xml: { extensions: [".xml", ".xsl", ".xslt"], globs: [] }, c: { extensions: [".c", ".h"], globs: [] }, cpp: { extensions: [".cpp", ".cc", ".cxx", ".hpp", ".hh", ".hxx", ".h"], globs: [] }, rust: { extensions: [".rs"], globs: [] }, go: { extensions: [".go"], globs: [] }, zig: { extensions: [".zig"], globs: [] }, java: { extensions: [".java"], globs: [] }, kotlin: { extensions: [".kt", ".kts"], globs: [] }, scala: { extensions: [".scala", ".sc"], globs: [] }, clojure: { extensions: [".clj", ".cljc", ".cljs", ".edn"], globs: [] }, py: { extensions: [".py", ".pyi", ".pyw"], globs: [] }, rb: { extensions: [".rb", ".rake", ".gemspec"], globs: ["Rakefile", "Gemfile"] }, php: { extensions: [".php", ".phtml", ".php3", ".php4", ".php5"], globs: [] }, perl: { extensions: [".pl", ".pm", ".pod", ".t"], globs: [] }, lua: { extensions: [".lua"], globs: [] }, sh: { extensions: [".sh", ".bash", ".zsh", ".fish"], globs: [".bashrc", ".zshrc", ".profile"] }, bat: { extensions: [".bat", ".cmd"], globs: [] }, ps: { extensions: [".ps1", ".psm1", ".psd1"], globs: [] }, yaml: { extensions: [".yaml", ".yml"], globs: [] }, toml: { extensions: [".toml"], globs: ["Cargo.toml", "pyproject.toml"] }, ini: { extensions: [".ini", ".cfg", ".conf"], globs: [] }, csv: { extensions: [".csv", ".tsv"], globs: [] }, md: { extensions: [".md", ".mdx", ".markdown", ".mdown", ".mkd"], globs: [] }, markdown: { extensions: [".md", ".mdx", ".markdown", ".mdown", ".mkd"], globs: [] }, rst: { extensions: [".rst"], globs: [] }, txt: { extensions: [".txt", ".text"], globs: [] }, tex: { extensions: [".tex", ".ltx", ".sty", ".cls"], globs: [] }, sql: { extensions: [".sql"], globs: [] }, graphql: { extensions: [".graphql", ".gql"], globs: [] }, proto: { extensions: [".proto"], globs: [] }, make: { extensions: [".mk", ".mak"], globs: ["Makefile", "GNUmakefile", "makefile"] }, docker: { extensions: [], globs: ["Dockerfile", "Dockerfile.*", "*.dockerfile"] }, tf: { extensions: [".tf", ".tfvars"], globs: [] } }, Yr = class {
    types;
    constructor() {
      this.types = new Map(Object.entries(Lf).map(([t10, n10]) => [t10, { extensions: [...n10.extensions], globs: [...n10.globs] }]));
    }
    addType(t10) {
      let n10 = t10.indexOf(":");
      if (n10 === -1)
        return;
      let r10 = t10.slice(0, n10), s10 = t10.slice(n10 + 1);
      if (s10.startsWith("include:")) {
        let i10 = s10.slice(8), o10 = this.types.get(i10);
        if (o10) {
          let a = this.types.get(r10) || { extensions: [], globs: [] };
          a.extensions.push(...o10.extensions), a.globs.push(...o10.globs), this.types.set(r10, a);
        }
      } else {
        let i10 = this.types.get(r10) || { extensions: [], globs: [] };
        if (s10.startsWith("*.") && !s10.slice(2).includes("*")) {
          let o10 = s10.slice(1);
          i10.extensions.includes(o10) || i10.extensions.push(o10);
        } else
          i10.globs.includes(s10) || i10.globs.push(s10);
        this.types.set(r10, i10);
      }
    }
    clearType(t10) {
      let n10 = this.types.get(t10);
      n10 && (n10.extensions = [], n10.globs = []);
    }
    getType(t10) {
      return this.types.get(t10);
    }
    getAllTypes() {
      return this.types;
    }
    matchesType(t10, n10) {
      let r10 = t10.toLowerCase();
      for (let s10 of n10) {
        if (s10 === "all") {
          if (this.matchesAnyType(t10))
            return true;
          continue;
        }
        let i10 = this.types.get(s10);
        if (i10) {
          for (let o10 of i10.extensions)
            if (r10.endsWith(o10))
              return true;
          for (let o10 of i10.globs)
            if (o10.includes("*")) {
              let a = o10.replace(/\./g, "\\.").replace(/\*/g, ".*");
              if (V(`^${a}$`, "i").test(t10))
                return true;
            } else if (r10 === o10.toLowerCase())
              return true;
        }
      }
      return false;
    }
    matchesAnyType(t10) {
      let n10 = t10.toLowerCase();
      for (let r10 of this.types.values()) {
        for (let s10 of r10.extensions)
          if (n10.endsWith(s10))
            return true;
        for (let s10 of r10.globs)
          if (s10.includes("*")) {
            let i10 = s10.replace(/\./g, "\\.").replace(/\*/g, ".*");
            if (V(`^${i10}$`, "i").test(t10))
              return true;
          } else if (n10 === s10.toLowerCase())
            return true;
      }
      return false;
    }
  };
});
function Mf() {
  return { ignoreCase: false, caseSensitive: false, smartCase: true, fixedStrings: false, wordRegexp: false, lineRegexp: false, invertMatch: false, multiline: false, multilineDotall: false, patterns: [], patternFiles: [], count: false, countMatches: false, files: false, filesWithMatches: false, filesWithoutMatch: false, stats: false, onlyMatching: false, maxCount: 0, lineNumber: true, noFilename: false, withFilename: false, nullSeparator: false, byteOffset: false, column: false, vimgrep: false, replace: null, afterContext: 0, beforeContext: 0, contextSeparator: "--", quiet: false, heading: false, passthru: false, includeZero: false, sort: "path", json: false, globs: [], iglobs: [], globCaseInsensitive: false, types: [], typesNot: [], typeAdd: [], typeClear: [], hidden: false, noIgnore: false, noIgnoreDot: false, noIgnoreVcs: false, ignoreFiles: [], maxDepth: 1 / 0, maxFilesize: 0, followSymlinks: false, searchZip: false, searchBinary: false, preprocessor: null, preprocessorGlobs: [] };
}
var Uf = I(() => {
  "use strict";
});
function v4(e11) {
  let t10 = e11.match(/^(\d+)([KMG])?$/i);
  if (!t10)
    return 0;
  let n10 = parseInt(t10[1], 10);
  switch ((t10[2] || "").toUpperCase()) {
    case "K":
      return n10 * 1024;
    case "M":
      return n10 * 1024 * 1024;
    case "G":
      return n10 * 1024 * 1024 * 1024;
    default:
      return n10;
  }
}
function I4(e11) {
  return /^\d+[KMG]?$/i.test(e11) ? null : { stdout: "", stderr: `rg: invalid --max-filesize value: ${e11}
`, exitCode: 1 };
}
function Wf(e11) {
  return null;
}
function $4(e11) {
  e11.hidden ? e11.searchBinary = true : e11.noIgnore ? e11.hidden = true : e11.noIgnore = true;
}
function T4(e11, t10, n10) {
  let r10 = e11[t10];
  for (let s10 of Bf) {
    if (r10.startsWith(`--${s10.long}=`)) {
      let i10 = r10.slice(`--${s10.long}=`.length), o10 = Xs(n10, s10, i10);
      return o10 ? { newIndex: t10, error: o10 } : { newIndex: t10 };
    }
    if (s10.short && r10.startsWith(`-${s10.short}`) && r10.length > 2) {
      let i10 = r10.slice(2), o10 = Xs(n10, s10, i10);
      return o10 ? { newIndex: t10, error: o10 } : { newIndex: t10 };
    }
    if (s10.short && r10 === `-${s10.short}` || r10 === `--${s10.long}`) {
      if (t10 + 1 >= e11.length)
        return null;
      let i10 = e11[t10 + 1], o10 = Xs(n10, s10, i10);
      return o10 ? { newIndex: t10 + 1, error: o10 } : { newIndex: t10 + 1 };
    }
  }
  return null;
}
function P4(e11) {
  return Bf.find((t10) => t10.short === e11);
}
function Xs(e11, t10, n10) {
  if (t10.validate) {
    let s10 = t10.validate(n10);
    if (s10)
      return s10;
  }
  let r10 = t10.parse ? t10.parse(n10) : n10;
  t10.multi ? e11[t10.target].push(r10) : e11[t10.target] = r10;
}
function D4(e11, t10) {
  let n10 = e11[t10];
  if (n10 === "--sort" && t10 + 1 < e11.length) {
    let r10 = e11[t10 + 1];
    if (r10 === "path" || r10 === "none")
      return { value: r10, newIndex: t10 + 1 };
  }
  if (n10.startsWith("--sort=")) {
    let r10 = n10.slice(7);
    if (r10 === "path" || r10 === "none")
      return { value: r10, newIndex: t10 };
  }
  return null;
}
function _4(e11, t10) {
  let n10 = e11[t10], r10 = n10.match(/^-([ABC])(\d+)$/);
  return r10 ? { flag: r10[1], value: parseInt(r10[2], 10), newIndex: t10 } : (n10 === "-A" || n10 === "-B" || n10 === "-C") && t10 + 1 < e11.length ? { flag: n10[1], value: parseInt(e11[t10 + 1], 10), newIndex: t10 + 1 } : null;
}
function L4(e11) {
  let t10 = e11.match(/^-m(\d+)$/);
  return t10 ? parseInt(t10[1], 10) : null;
}
function zf(e11) {
  let t10 = Mf(), n10 = null, r10 = [], s10 = -1, i10 = -1, o10 = -1, a = false;
  for (let l = 0; l < e11.length; l++) {
    let c = e11[l];
    if (c.startsWith("-") && c !== "-") {
      let u = _4(e11, l);
      if (u) {
        let { flag: g, value: y, newIndex: w } = u;
        g === "A" ? s10 = Math.max(s10, y) : g === "B" ? i10 = Math.max(i10, y) : o10 = y, l = w;
        continue;
      }
      let f10 = L4(c);
      if (f10 !== null) {
        t10.maxCount = f10;
        continue;
      }
      let p = T4(e11, l, t10);
      if (p) {
        if (p.error)
          return { success: false, error: p.error };
        l = p.newIndex;
        continue;
      }
      let h = D4(e11, l);
      if (h) {
        t10.sort = h.value, l = h.newIndex;
        continue;
      }
      let m = c.startsWith("--") ? [c] : c.slice(1).split(""), d = false;
      for (let g of m) {
        if (R4.has(g)) {
          t10.lineNumber = true, a = true;
          continue;
        }
        if (g === "u" || g === "--unrestricted") {
          $4(t10);
          continue;
        }
        if (g === "P" || g === "--pcre2")
          return { success: false, error: { stdout: "", stderr: `rg: PCRE2 is not supported. Use standard regex syntax instead.
`, exitCode: 1 } };
        if (g.length === 1) {
          let w = P4(g);
          if (w) {
            if (l + 1 >= e11.length)
              return { success: false, error: Y("rg", `-${g}`) };
            let b = Xs(t10, w, e11[l + 1]);
            if (b)
              return { success: false, error: b };
            l++, d = true;
            continue;
          }
        }
        let y = O4.get(g);
        if (y) {
          y(t10);
          continue;
        }
        if (g.startsWith("--"))
          return { success: false, error: Y("rg", g) };
        if (g.length === 1)
          return { success: false, error: Y("rg", `-${g}`) };
      }
    } else
      n10 === null && t10.patterns.length === 0 && t10.patternFiles.length === 0 ? n10 = c : r10.push(c);
  }
  return (s10 >= 0 || o10 >= 0) && (t10.afterContext = Math.max(s10 >= 0 ? s10 : 0, o10 >= 0 ? o10 : 0)), (i10 >= 0 || o10 >= 0) && (t10.beforeContext = Math.max(i10 >= 0 ? i10 : 0, o10 >= 0 ? o10 : 0)), n10 !== null && t10.patterns.push(n10), (t10.column || t10.vimgrep) && (a = true), { success: true, options: t10, paths: r10, explicitLineNumbers: a };
}
var Bf;
var O4;
var R4;
var Hf = I(() => {
  "use strict";
  se();
  Uf();
  Bf = [{ short: "g", long: "glob", target: "globs", multi: true }, { long: "iglob", target: "iglobs", multi: true }, { short: "t", long: "type", target: "types", multi: true, validate: Wf }, { short: "T", long: "type-not", target: "typesNot", multi: true, validate: Wf }, { long: "type-add", target: "typeAdd", multi: true }, { long: "type-clear", target: "typeClear", multi: true }, { short: "m", long: "max-count", target: "maxCount", parse: parseInt }, { short: "e", long: "regexp", target: "patterns", multi: true }, { short: "f", long: "file", target: "patternFiles", multi: true }, { short: "r", long: "replace", target: "replace" }, { short: "d", long: "max-depth", target: "maxDepth", parse: parseInt }, { long: "max-filesize", target: "maxFilesize", parse: v4, validate: I4 }, { long: "context-separator", target: "contextSeparator" }, { short: "j", long: "threads", target: "maxDepth", parse: () => 1 / 0 }, { long: "ignore-file", target: "ignoreFiles", multi: true }, { long: "pre", target: "preprocessor" }, { long: "pre-glob", target: "preprocessorGlobs", multi: true }], O4 = /* @__PURE__ */ new Map([["i", (e11) => {
    e11.ignoreCase = true, e11.caseSensitive = false, e11.smartCase = false;
  }], ["--ignore-case", (e11) => {
    e11.ignoreCase = true, e11.caseSensitive = false, e11.smartCase = false;
  }], ["s", (e11) => {
    e11.caseSensitive = true, e11.ignoreCase = false, e11.smartCase = false;
  }], ["--case-sensitive", (e11) => {
    e11.caseSensitive = true, e11.ignoreCase = false, e11.smartCase = false;
  }], ["S", (e11) => {
    e11.smartCase = true, e11.ignoreCase = false, e11.caseSensitive = false;
  }], ["--smart-case", (e11) => {
    e11.smartCase = true, e11.ignoreCase = false, e11.caseSensitive = false;
  }], ["F", (e11) => {
    e11.fixedStrings = true;
  }], ["--fixed-strings", (e11) => {
    e11.fixedStrings = true;
  }], ["w", (e11) => {
    e11.wordRegexp = true;
  }], ["--word-regexp", (e11) => {
    e11.wordRegexp = true;
  }], ["x", (e11) => {
    e11.lineRegexp = true;
  }], ["--line-regexp", (e11) => {
    e11.lineRegexp = true;
  }], ["v", (e11) => {
    e11.invertMatch = true;
  }], ["--invert-match", (e11) => {
    e11.invertMatch = true;
  }], ["U", (e11) => {
    e11.multiline = true;
  }], ["--multiline", (e11) => {
    e11.multiline = true;
  }], ["--multiline-dotall", (e11) => {
    e11.multilineDotall = true, e11.multiline = true;
  }], ["c", (e11) => {
    e11.count = true;
  }], ["--count", (e11) => {
    e11.count = true;
  }], ["--count-matches", (e11) => {
    e11.countMatches = true;
  }], ["l", (e11) => {
    e11.filesWithMatches = true;
  }], ["--files", (e11) => {
    e11.files = true;
  }], ["--files-with-matches", (e11) => {
    e11.filesWithMatches = true;
  }], ["--files-without-match", (e11) => {
    e11.filesWithoutMatch = true;
  }], ["--stats", (e11) => {
    e11.stats = true;
  }], ["o", (e11) => {
    e11.onlyMatching = true;
  }], ["--only-matching", (e11) => {
    e11.onlyMatching = true;
  }], ["q", (e11) => {
    e11.quiet = true;
  }], ["--quiet", (e11) => {
    e11.quiet = true;
  }], ["N", (e11) => {
    e11.lineNumber = false;
  }], ["--no-line-number", (e11) => {
    e11.lineNumber = false;
  }], ["H", (e11) => {
    e11.withFilename = true;
  }], ["--with-filename", (e11) => {
    e11.withFilename = true;
  }], ["I", (e11) => {
    e11.noFilename = true;
  }], ["--no-filename", (e11) => {
    e11.noFilename = true;
  }], ["0", (e11) => {
    e11.nullSeparator = true;
  }], ["--null", (e11) => {
    e11.nullSeparator = true;
  }], ["b", (e11) => {
    e11.byteOffset = true;
  }], ["--byte-offset", (e11) => {
    e11.byteOffset = true;
  }], ["--column", (e11) => {
    e11.column = true, e11.lineNumber = true;
  }], ["--no-column", (e11) => {
    e11.column = false;
  }], ["--vimgrep", (e11) => {
    e11.vimgrep = true, e11.column = true, e11.lineNumber = true;
  }], ["--json", (e11) => {
    e11.json = true;
  }], ["--hidden", (e11) => {
    e11.hidden = true;
  }], ["--no-ignore", (e11) => {
    e11.noIgnore = true;
  }], ["--no-ignore-dot", (e11) => {
    e11.noIgnoreDot = true;
  }], ["--no-ignore-vcs", (e11) => {
    e11.noIgnoreVcs = true;
  }], ["L", (e11) => {
    e11.followSymlinks = true;
  }], ["--follow", (e11) => {
    e11.followSymlinks = true;
  }], ["z", (e11) => {
    e11.searchZip = true;
  }], ["--search-zip", (e11) => {
    e11.searchZip = true;
  }], ["a", (e11) => {
    e11.searchBinary = true;
  }], ["--text", (e11) => {
    e11.searchBinary = true;
  }], ["--heading", (e11) => {
    e11.heading = true;
  }], ["--passthru", (e11) => {
    e11.passthru = true;
  }], ["--include-zero", (e11) => {
    e11.includeZero = true;
  }], ["--glob-case-insensitive", (e11) => {
    e11.globCaseInsensitive = true;
  }]]), R4 = /* @__PURE__ */ new Set(["n", "--line-number"]);
});
async function na(e11, t10, n10 = false, r10 = false, s10 = []) {
  let i10 = new es(e11, t10, n10, r10);
  await i10.load(t10);
  for (let o10 of s10)
    try {
      let a = e11.resolvePath(t10, o10), l = await e11.readFile(a);
      i10.addPatternsFromContent(l, t10);
    } catch {
    }
  return i10;
}
var Jr;
var es;
var jf = I(() => {
  "use strict";
  Fe();
  Jr = class {
    patterns = [];
    basePath;
    constructor(t10 = "/") {
      this.basePath = t10;
    }
    parse(t10) {
      let n10 = t10.split(`
`);
      for (let r10 of n10) {
        let s10 = r10.replace(/\s+$/, "");
        if (!s10 || s10.startsWith("#"))
          continue;
        let i10 = false;
        s10.startsWith("!") && (i10 = true, s10 = s10.slice(1));
        let o10 = false;
        s10.endsWith("/") && (o10 = true, s10 = s10.slice(0, -1));
        let a = false;
        s10.startsWith("/") ? (a = true, s10 = s10.slice(1)) : s10.includes("/") && !s10.startsWith("**/") && (a = true);
        let l = this.patternToRegex(s10, a);
        this.patterns.push({ pattern: r10, regex: l, negated: i10, directoryOnly: o10, rooted: a });
      }
    }
    patternToRegex(t10, n10) {
      let r10 = "";
      n10 ? r10 = "^" : r10 = "(?:^|/)";
      let s10 = 0;
      for (; s10 < t10.length; ) {
        let i10 = t10[s10];
        if (i10 === "*")
          t10[s10 + 1] === "*" ? t10[s10 + 2] === "/" ? (r10 += "(?:.*/)?", s10 += 3) : (s10 + 2 >= t10.length, r10 += ".*", s10 += 2) : (r10 += "[^/]*", s10++);
        else if (i10 === "?")
          r10 += "[^/]", s10++;
        else if (i10 === "[") {
          let o10 = s10 + 1;
          for (o10 < t10.length && t10[o10] === "!" && o10++, o10 < t10.length && t10[o10] === "]" && o10++; o10 < t10.length && t10[o10] !== "]"; )
            o10++;
          if (o10 < t10.length) {
            let a = t10.slice(s10, o10 + 1);
            a.startsWith("[!") && (a = `[^${a.slice(2)}`), r10 += a, s10 = o10 + 1;
          } else
            r10 += "\\[", s10++;
        } else
          i10 === "/" ? (r10 += "/", s10++) : (r10 += i10.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), s10++);
      }
      return r10 += "(?:/.*)?$", V(r10);
    }
    matches(t10, n10) {
      let r10 = t10.replace(/^\.\//, "");
      r10 = r10.replace(/^\//, "");
      let s10 = false;
      for (let i10 of this.patterns)
        i10.directoryOnly && !n10 || i10.regex.test(r10) && (s10 = !i10.negated);
      return s10;
    }
    isWhitelisted(t10, n10) {
      let r10 = t10.replace(/^\.\//, "");
      r10 = r10.replace(/^\//, "");
      for (let s10 of this.patterns)
        if (!(s10.directoryOnly && !n10) && s10.negated && s10.regex.test(r10))
          return true;
      return false;
    }
    getBasePath() {
      return this.basePath;
    }
  }, es = class {
    parsers = [];
    fs;
    skipDotIgnore;
    skipVcsIgnore;
    loadedDirs = /* @__PURE__ */ new Set();
    constructor(t10, n10, r10 = false, s10 = false) {
      this.fs = t10, this.skipDotIgnore = r10, this.skipVcsIgnore = s10;
    }
    async load(t10) {
      let n10 = [], r10 = t10;
      for (; ; ) {
        n10.unshift(r10);
        let i10 = this.fs.resolvePath(r10, "..");
        if (i10 === r10)
          break;
        r10 = i10;
      }
      let s10 = [];
      this.skipVcsIgnore || s10.push(".gitignore"), this.skipDotIgnore || s10.push(".rgignore", ".ignore");
      for (let i10 of n10) {
        this.loadedDirs.add(i10);
        for (let o10 of s10) {
          let a = this.fs.resolvePath(i10, o10);
          try {
            let l = await this.fs.readFile(a), c = new Jr(i10);
            c.parse(l), this.parsers.push(c);
          } catch {
          }
        }
      }
    }
    async loadForDirectory(t10) {
      if (this.loadedDirs.has(t10))
        return;
      this.loadedDirs.add(t10);
      let n10 = [];
      this.skipVcsIgnore || n10.push(".gitignore"), this.skipDotIgnore || n10.push(".rgignore", ".ignore");
      for (let r10 of n10) {
        let s10 = this.fs.resolvePath(t10, r10);
        try {
          let i10 = await this.fs.readFile(s10), o10 = new Jr(t10);
          o10.parse(i10), this.parsers.push(o10);
        } catch {
        }
      }
    }
    addPatternsFromContent(t10, n10) {
      let r10 = new Jr(n10);
      r10.parse(t10), this.parsers.push(r10);
    }
    matches(t10, n10) {
      for (let r10 of this.parsers) {
        let s10 = r10.getBasePath();
        if (!t10.startsWith(s10))
          continue;
        let i10 = t10.slice(s10.length).replace(/^\//, "");
        if (r10.matches(i10, n10))
          return true;
      }
      return false;
    }
    isWhitelisted(t10, n10) {
      for (let r10 of this.parsers) {
        let s10 = r10.getBasePath();
        if (!t10.startsWith(s10))
          continue;
        let i10 = t10.slice(s10.length).replace(/^\//, "");
        if (r10.isWhitelisted(i10, n10))
          return true;
      }
      return false;
    }
    static isCommonIgnored(t10) {
      return (/* @__PURE__ */ new Set(["node_modules", ".git", ".svn", ".hg", "__pycache__", ".pytest_cache", ".mypy_cache", "venv", ".venv", ".next", ".nuxt", ".cargo"])).has(t10);
    }
  };
});
function M4(e11) {
  return e11.length >= 2 && e11[0] === 31 && e11[1] === 139;
}
function U4(e11) {
  let t10 = false;
  for (let n10 = 0; n10 < e11.length; n10++) {
    let r10 = e11[n10];
    r10 === "[" && !t10 ? t10 = true : r10 === "]" && t10 && (t10 = false);
  }
  return t10 ? `rg: glob '${e11}' has an unclosed character class` : null;
}
async function Gf(e11) {
  let { ctx: t10, options: n10, paths: r10, explicitLineNumbers: s10 } = e11;
  for (let g of n10.globs) {
    let y = g.startsWith("!") ? g.slice(1) : g, w = U4(y);
    if (w)
      return { stdout: "", stderr: `${w}
`, exitCode: 1 };
  }
  if (n10.files) {
    let g = [...n10.patterns, ...r10];
    return z4(t10, g, n10);
  }
  let i10 = [...n10.patterns];
  for (let g of n10.patternFiles)
    try {
      let y;
      if (g === "-")
        y = t10.stdin;
      else {
        let b = t10.fs.resolvePath(t10.cwd, g);
        y = await t10.fs.readFile(b);
      }
      let w = y.split(`
`).filter((b) => b.length > 0);
      i10.push(...w);
    } catch {
      return { stdout: "", stderr: `rg: ${g}: No such file or directory
`, exitCode: 2 };
    }
  if (i10.length === 0)
    return n10.patternFiles.length > 0 ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `rg: no pattern given
`, exitCode: 2 };
  let o10 = r10.length === 0 ? ["."] : r10, a = W4(n10, i10), l, c;
  try {
    let g = B4(i10, n10, a);
    l = g.regex, c = g.kResetGroup;
  } catch {
    return { stdout: "", stderr: `rg: invalid regex: ${i10.join(", ")}
`, exitCode: 2 };
  }
  let u = null;
  n10.noIgnore || (u = await na(t10.fs, t10.cwd, n10.noIgnoreDot, n10.noIgnoreVcs, n10.ignoreFiles));
  let f10 = new Yr();
  for (let g of n10.typeClear)
    f10.clearType(g);
  for (let g of n10.typeAdd)
    f10.addType(g);
  let { files: p, singleExplicitFile: h } = await Vf(t10, o10, n10, u, f10);
  if (p.length === 0)
    return { stdout: "", stderr: "", exitCode: 1 };
  let m = !n10.noFilename && (n10.withFilename || !h || p.length > 1), d = n10.lineNumber;
  return s10 || (h && p.length === 1 && (d = false), n10.onlyMatching && (d = false)), G4(t10, p, l, n10, m, d, c);
}
function W4(e11, t10) {
  return e11.caseSensitive ? false : e11.ignoreCase ? true : e11.smartCase ? !t10.some((n10) => /[A-Z]/.test(n10)) : false;
}
function B4(e11, t10, n10) {
  let r10;
  return e11.length === 1 ? r10 = e11[0] : r10 = e11.map((s10) => t10.fixedStrings ? s10.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") : `(?:${s10})`).join("|"), Xr(r10, { mode: t10.fixedStrings && e11.length === 1 ? "fixed" : "perl", ignoreCase: n10, wholeWord: t10.wordRegexp, lineRegexp: t10.lineRegexp, multiline: t10.multiline, multilineDotall: t10.multilineDotall });
}
async function Vf(e11, t10, n10, r10, s10) {
  let i10 = [], o10 = 0, a = 0;
  for (let c of t10) {
    let u = e11.fs.resolvePath(e11.cwd, c);
    try {
      let f10 = await e11.fs.stat(u);
      if (f10.isFile) {
        if (o10++, n10.maxFilesize > 0 && f10.size > n10.maxFilesize)
          continue;
        Zf(c, n10, r10, u, s10) && i10.push(c);
      } else
        f10.isDirectory && (a++, await qf(e11, c, u, 0, n10, r10, s10, i10));
    } catch {
    }
  }
  return { files: n10.sort === "path" ? i10.sort() : i10, singleExplicitFile: o10 === 1 && a === 0 };
}
async function qf(e11, t10, n10, r10, s10, i10, o10, a) {
  if (!(r10 >= s10.maxDepth)) {
    i10 && await i10.loadForDirectory(n10);
    try {
      let l = e11.fs.readdirWithFileTypes ? await e11.fs.readdirWithFileTypes(n10) : (await e11.fs.readdir(n10)).map((c) => ({ name: c, isFile: void 0 }));
      for (let c of l) {
        let u = c.name;
        if (!s10.noIgnore && es.isCommonIgnored(u))
          continue;
        let f10 = u.startsWith("."), p = t10 === "." ? u : t10 === "./" ? `./${u}` : t10.endsWith("/") ? `${t10}${u}` : `${t10}/${u}`, h = e11.fs.resolvePath(n10, u), m, d, g = false;
        if (c.isFile !== void 0 && "isDirectory" in c) {
          let b = c;
          if (g = b.isSymbolicLink === true, g && !s10.followSymlinks)
            continue;
          if (g && s10.followSymlinks)
            try {
              let x = await e11.fs.stat(h);
              m = x.isFile, d = x.isDirectory;
            } catch {
              continue;
            }
          else
            m = b.isFile, d = b.isDirectory;
        } else
          try {
            let b = e11.fs.lstat ? await e11.fs.lstat(h) : await e11.fs.stat(h);
            if (g = b.isSymbolicLink === true, g && !s10.followSymlinks)
              continue;
            let x = g && s10.followSymlinks ? await e11.fs.stat(h) : b;
            m = x.isFile, d = x.isDirectory;
          } catch {
            continue;
          }
        if (!i10?.matches(h, d) && !(f10 && !s10.hidden && !i10?.isWhitelisted(h, d))) {
          if (d)
            await qf(e11, p, h, r10 + 1, s10, i10, o10, a);
          else if (m) {
            if (s10.maxFilesize > 0)
              try {
                if ((await e11.fs.stat(h)).size > s10.maxFilesize)
                  continue;
              } catch {
                continue;
              }
            Zf(p, s10, i10, h, o10) && a.push(p);
          }
        }
      }
    } catch {
    }
  }
}
function Zf(e11, t10, n10, r10, s10) {
  let i10 = e11.split("/").pop() || e11;
  if (n10?.matches(r10, false) || t10.types.length > 0 && !s10.matchesType(i10, t10.types) || t10.typesNot.length > 0 && s10.matchesType(i10, t10.typesNot))
    return false;
  if (t10.globs.length > 0) {
    let o10 = t10.globCaseInsensitive, a = t10.globs.filter((c) => !c.startsWith("!")), l = t10.globs.filter((c) => c.startsWith("!")).map((c) => c.slice(1));
    if (a.length > 0) {
      let c = false;
      for (let u of a)
        if (Yt(i10, u, o10) || Yt(e11, u, o10)) {
          c = true;
          break;
        }
      if (!c)
        return false;
    }
    for (let c of l)
      if (c.startsWith("/")) {
        let u = c.slice(1);
        if (Yt(e11, u, o10))
          return false;
      } else if (Yt(i10, c, o10) || Yt(e11, c, o10))
        return false;
  }
  if (t10.iglobs.length > 0) {
    let o10 = t10.iglobs.filter((l) => !l.startsWith("!")), a = t10.iglobs.filter((l) => l.startsWith("!")).map((l) => l.slice(1));
    if (o10.length > 0) {
      let l = false;
      for (let c of o10)
        if (Yt(i10, c, true) || Yt(e11, c, true)) {
          l = true;
          break;
        }
      if (!l)
        return false;
    }
    for (let l of a)
      if (l.startsWith("/")) {
        let c = l.slice(1);
        if (Yt(e11, c, true))
          return false;
      } else if (Yt(i10, l, true) || Yt(e11, l, true))
        return false;
  }
  return true;
}
function Yt(e11, t10, n10 = false) {
  let r10 = "^";
  for (let s10 = 0; s10 < t10.length; s10++) {
    let i10 = t10[s10];
    if (i10 === "*")
      t10[s10 + 1] === "*" ? (r10 += ".*", s10++) : r10 += "[^/]*";
    else if (i10 === "?")
      r10 += "[^/]";
    else if (i10 === "[") {
      let o10 = s10 + 1;
      for (o10 < t10.length && t10[o10] === "!" && o10++, o10 < t10.length && t10[o10] === "]" && o10++; o10 < t10.length && t10[o10] !== "]"; )
        o10++;
      if (o10 < t10.length) {
        let a = t10.slice(s10, o10 + 1);
        a.startsWith("[!") && (a = `[^${a.slice(2)}`), r10 += a, s10 = o10;
      } else
        r10 += "\\[";
    } else
      r10 += i10.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  return r10 += "$", V(r10, n10 ? "i" : "").test(e11);
}
async function z4(e11, t10, n10) {
  let r10 = null;
  n10.noIgnore || (r10 = await na(e11.fs, e11.cwd, n10.noIgnoreDot, n10.noIgnoreVcs, n10.ignoreFiles));
  let s10 = new Yr();
  for (let c of n10.typeClear)
    s10.clearType(c);
  for (let c of n10.typeAdd)
    s10.addType(c);
  let i10 = t10.length === 0 ? ["."] : t10, { files: o10 } = await Vf(e11, i10, n10, r10, s10);
  if (o10.length === 0)
    return { stdout: "", stderr: "", exitCode: 1 };
  if (n10.quiet)
    return { stdout: "", stderr: "", exitCode: 0 };
  let a = n10.nullSeparator ? "\0" : `
`;
  return { stdout: o10.map((c) => c + a).join(""), stderr: "", exitCode: 0 };
}
function H4(e11, t10) {
  if (t10.length === 0)
    return true;
  for (let n10 of t10)
    if (Yt(e11, n10, false))
      return true;
  return false;
}
async function j4(e11, t10, n10, r10) {
  try {
    if (r10.preprocessor && e11.exec) {
      let o10 = n10.split("/").pop() || n10;
      if (H4(o10, r10.preprocessorGlobs)) {
        let a = await e11.exec(`${r10.preprocessor} "${t10}"`, { cwd: e11.cwd });
        if (a.exitCode === 0 && a.stdout) {
          let l = a.stdout.slice(0, 8192);
          return { content: a.stdout, isBinary: l.includes("\0") };
        }
      }
    }
    if (r10.searchZip && n10.endsWith(".gz")) {
      let o10 = await e11.fs.readFileBuffer(t10);
      if (M4(o10))
        try {
          let a = gunzipSync2(o10), l = new TextDecoder().decode(a), c = l.slice(0, 8192);
          return { content: l, isBinary: c.includes("\0") };
        } catch {
          return null;
        }
    }
    let s10 = await e11.fs.readFile(t10), i10 = s10.slice(0, 8192);
    return { content: s10, isBinary: i10.includes("\0") };
  } catch {
    return null;
  }
}
async function G4(e11, t10, n10, r10, s10, i10, o10) {
  let a = "", l = false, c = [], u = 0, f10 = 0, p = 0, h = 50;
  e:
    for (let g = 0; g < t10.length; g += h) {
      let y = t10.slice(g, g + h), w = await Promise.all(y.map(async (b) => {
        let x = e11.fs.resolvePath(e11.cwd, b), S = await j4(e11, x, b, r10);
        if (!S)
          return null;
        let { content: O, isBinary: R10 } = S;
        if (p += O.length, R10 && !r10.searchBinary)
          return null;
        let F4 = s10 && !r10.heading ? b : "", $ = mr(O, n10, { invertMatch: r10.invertMatch, showLineNumbers: i10, countOnly: r10.count, countMatches: r10.countMatches, filename: F4, onlyMatching: r10.onlyMatching, beforeContext: r10.beforeContext, afterContext: r10.afterContext, maxCount: r10.maxCount, contextSeparator: r10.contextSeparator, showColumn: r10.column, vimgrep: r10.vimgrep, showByteOffset: r10.byteOffset, replace: r10.replace !== null ? Yo(r10.replace) : null, passthru: r10.passthru, multiline: r10.multiline, kResetGroup: o10 });
        return r10.json && $.matched ? { file: b, result: $, content: O, isBinary: false } : { file: b, result: $ };
      }));
      for (let b of w) {
        if (!b)
          continue;
        let { file: x, result: S } = b;
        if (S.matched) {
          if (l = true, f10++, u += S.matchCount, r10.quiet && !r10.json)
            break e;
          if (r10.json && !r10.quiet) {
            let O = b.content || "";
            c.push(JSON.stringify({ type: "begin", data: { path: { text: x } } }));
            let R10 = O.split(`
`);
            n10.lastIndex = 0;
            let F4 = 0;
            for (let $ = 0; $ < R10.length; $++) {
              let z = R10[$];
              n10.lastIndex = 0;
              let k = [];
              for (let N10 = n10.exec(z); N10 !== null; N10 = n10.exec(z)) {
                let P = { match: { text: N10[0] }, start: N10.index, end: N10.index + N10[0].length };
                r10.replace !== null && (P.replacement = { text: r10.replace }), k.push(P), N10[0].length === 0 && n10.lastIndex++;
              }
              if (k.length > 0) {
                let N10 = { type: "match", data: { path: { text: x }, lines: { text: `${z}
` }, line_number: $ + 1, absolute_offset: F4, submatches: k } };
                c.push(JSON.stringify(N10));
              }
              F4 += z.length + 1;
            }
            c.push(JSON.stringify({ type: "end", data: { path: { text: x }, binary_offset: null, stats: { elapsed: { secs: 0, nanos: 0, human: "0s" }, searches: 1, searches_with_match: 1, bytes_searched: O.length, bytes_printed: 0, matched_lines: S.matchCount, matches: S.matchCount } } }));
          } else if (r10.filesWithMatches) {
            let O = r10.nullSeparator ? "\0" : `
`;
            a += `${x}${O}`;
          } else
            r10.filesWithoutMatch || (r10.heading && !r10.noFilename && (a += `${x}
`), a += S.output);
        } else if (r10.filesWithoutMatch) {
          let O = r10.nullSeparator ? "\0" : `
`;
          a += `${x}${O}`;
        } else
          r10.includeZero && (r10.count || r10.countMatches) && (a += S.output);
      }
    }
  r10.json && (c.push(JSON.stringify({ type: "summary", data: { elapsed_total: { secs: 0, nanos: 0, human: "0s" }, stats: { elapsed: { secs: 0, nanos: 0, human: "0s" }, searches: t10.length, searches_with_match: f10, bytes_searched: p, bytes_printed: 0, matched_lines: u, matches: u } } })), a = `${c.join(`
`)}
`);
  let m = r10.quiet && !r10.json ? "" : a;
  if (r10.stats && !r10.json) {
    let g = ["", `${u} matches`, `${u} matched lines`, `${f10} files contained matches`, `${t10.length} files searched`, `${p} bytes searched`].join(`
`);
    m += `${g}
`;
  }
  let d;
  return r10.filesWithoutMatch ? d = a.length > 0 ? 0 : 1 : d = l ? 0 : 1, { stdout: m, stderr: "", exitCode: d };
}
var Qf = I(() => {
  "use strict";
  Fe();
  Jo();
  ta();
  jf();
});
var Kf = {};
Q(Kf, { flagsForFuzzing: () => Z4, rgCommand: () => q4 });
var V4;
var q4;
var Z4;
var Xf = I(() => {
  "use strict";
  se();
  ta();
  Hf();
  Qf();
  V4 = { name: "rg", summary: "recursively search for a pattern", usage: "rg [OPTIONS] PATTERN [PATH ...]", description: `rg (ripgrep) recursively searches directories for a regex pattern.
Unlike grep, rg is recursive by default and respects .gitignore files.

EXAMPLES:
  rg foo                    Search for 'foo' in current directory
  rg foo src/               Search in src/ directory
  rg -i foo                 Case-insensitive search
  rg -w foo                 Match whole words only
  rg -t js foo              Search only JavaScript files
  rg -g '*.ts' foo          Search files matching glob
  rg --hidden foo           Include hidden files
  rg -l foo                 List files with matches only`, options: ["-e, --regexp PATTERN    search for PATTERN (can be used multiple times)", "-f, --file FILE         read patterns from FILE, one per line", "-i, --ignore-case       case-insensitive search", "-s, --case-sensitive    case-sensitive search (overrides smart-case)", "-S, --smart-case        smart case (default: case-insensitive unless pattern has uppercase)", "-F, --fixed-strings     treat pattern as literal string", "-w, --word-regexp       match whole words only", "-x, --line-regexp       match whole lines only", "-v, --invert-match      select non-matching lines", "-r, --replace TEXT      replace matches with TEXT", "-c, --count             print count of matching lines per file", "    --count-matches     print count of individual matches per file", "-l, --files-with-matches print only file names with matches", "    --files-without-match print file names without matches", "    --files             list files that would be searched", "-o, --only-matching     print only matching parts", "-m, --max-count NUM     stop after NUM matches per file", "-q, --quiet             suppress output, exit 0 on match", "    --stats             print search statistics", "-n, --line-number       print line numbers (default: on)", "-N, --no-line-number    do not print line numbers", "-I, --no-filename       suppress the prefixing of file names", "-0, --null              use NUL as filename separator", "-b, --byte-offset       show byte offset of each match", "    --column            show column number of first match", "    --vimgrep           show results in vimgrep format", "    --json              show results in JSON Lines format", "-A NUM                  print NUM lines after each match", "-B NUM                  print NUM lines before each match", "-C NUM                  print NUM lines before and after each match", "    --context-separator SEP  separator for context groups (default: --)", "-U, --multiline         match patterns across lines", "-z, --search-zip        search in compressed files (gzip only)", "-g, --glob GLOB         include files matching GLOB", "-t, --type TYPE         only search files of TYPE (e.g., js, py, ts)", "-T, --type-not TYPE     exclude files of TYPE", "-L, --follow            follow symbolic links", "-u, --unrestricted      reduce filtering (-u: no ignore, -uu: +hidden, -uuu: +binary)", "-a, --text              search binary files as text", "    --hidden            search hidden files and directories", "    --no-ignore         don't respect .gitignore/.ignore files", "-d, --max-depth NUM     maximum search depth", "    --sort TYPE         sort files (path, none)", "    --heading           show file path above matches", "    --passthru          print all lines (non-matches use - separator)", "    --include-zero      include files with 0 matches in count output", "    --type-list         list all available file types", "    --help              display this help and exit"] }, q4 = { name: "rg", async execute(e11, t10) {
    if (U2(e11))
      return M(V4);
    if (e11.includes("--type-list"))
      return { stdout: Ff(), stderr: "", exitCode: 0 };
    let n10 = zf(e11);
    return n10.success ? Gf({ ctx: t10, options: n10.options, paths: n10.paths, explicitLineNumbers: n10.explicitLineNumbers }) : n10.error;
  } }, Z4 = { name: "rg", flags: [{ flag: "-i", type: "boolean" }, { flag: "-s", type: "boolean" }, { flag: "-S", type: "boolean" }, { flag: "-F", type: "boolean" }, { flag: "-w", type: "boolean" }, { flag: "-x", type: "boolean" }, { flag: "-v", type: "boolean" }, { flag: "-c", type: "boolean" }, { flag: "-l", type: "boolean" }, { flag: "-o", type: "boolean" }, { flag: "-n", type: "boolean" }, { flag: "-N", type: "boolean" }, { flag: "--hidden", type: "boolean" }, { flag: "--no-ignore", type: "boolean" }, { flag: "-m", type: "value", valueHint: "number" }, { flag: "-A", type: "value", valueHint: "number" }, { flag: "-B", type: "value", valueHint: "number" }, { flag: "-C", type: "value", valueHint: "number" }, { flag: "-g", type: "value", valueHint: "pattern" }, { flag: "-t", type: "value", valueHint: "string" }, { flag: "-T", type: "value", valueHint: "string" }], needsArgs: true };
});
function sa(e11) {
  let t10 = "", n10 = 0, r10 = false;
  for (; n10 < e11.length; ) {
    if (e11[n10] === "[" && !r10) {
      if (e11[n10 + 1] === "[" && e11[n10 + 2] === ":") {
        let s10 = e11.indexOf(":]]", n10 + 3);
        if (s10 !== -1) {
          let i10 = e11.slice(n10 + 3, s10), o10 = ra.get(i10);
          if (o10) {
            t10 += `[${o10}]`, n10 = s10 + 3;
            continue;
          }
        }
      }
      if (e11[n10 + 1] === "^" && e11[n10 + 2] === "[" && e11[n10 + 3] === ":") {
        let s10 = e11.indexOf(":]]", n10 + 4);
        if (s10 !== -1) {
          let i10 = e11.slice(n10 + 4, s10), o10 = ra.get(i10);
          if (o10) {
            t10 += `[^${o10}]`, n10 = s10 + 3;
            continue;
          }
        }
      }
      t10 += "[", n10++, r10 = true, n10 < e11.length && e11[n10] === "^" && (t10 += "^", n10++), n10 < e11.length && e11[n10] === "]" && (t10 += "\\]", n10++);
      continue;
    }
    if (r10) {
      if (e11[n10] === "]") {
        t10 += "]", n10++, r10 = false;
        continue;
      }
      if (e11[n10] === "[" && e11[n10 + 1] === ":") {
        let s10 = e11.indexOf(":]", n10 + 2);
        if (s10 !== -1) {
          let i10 = e11.slice(n10 + 2, s10), o10 = ra.get(i10);
          if (o10) {
            t10 += o10, n10 = s10 + 2;
            continue;
          }
        }
      }
      if (e11[n10] === "\\" && n10 + 1 < e11.length) {
        t10 += e11[n10] + e11[n10 + 1], n10 += 2;
        continue;
      }
      t10 += e11[n10], n10++;
      continue;
    }
    if (e11[n10] === "\\" && n10 + 1 < e11.length) {
      let s10 = e11[n10 + 1];
      if (s10 === "+" || s10 === "?" || s10 === "|") {
        t10 += s10, n10 += 2;
        continue;
      }
      if (s10 === "(" || s10 === ")") {
        t10 += s10, n10 += 2;
        continue;
      }
      if (s10 === "{" || s10 === "}") {
        t10 += s10, n10 += 2;
        continue;
      }
      if (s10 === "t") {
        t10 += "	", n10 += 2;
        continue;
      }
      if (s10 === "n") {
        t10 += `
`, n10 += 2;
        continue;
      }
      if (s10 === "r") {
        t10 += "\r", n10 += 2;
        continue;
      }
      t10 += e11[n10] + s10, n10 += 2;
      continue;
    }
    if (e11[n10] === "+" || e11[n10] === "?" || e11[n10] === "|" || e11[n10] === "(" || e11[n10] === ")") {
      t10 += `\\${e11[n10]}`, n10++;
      continue;
    }
    if (e11[n10] === "^" && !(t10 === "" || t10.endsWith("("))) {
      t10 += "\\^", n10++;
      continue;
    }
    if (e11[n10] === "$") {
      let s10 = n10 === e11.length - 1, i10 = n10 + 2 < e11.length && e11[n10 + 1] === "\\" && e11[n10 + 2] === ")";
      if (!s10 && !i10) {
        t10 += "\\$", n10++;
        continue;
      }
    }
    t10 += e11[n10], n10++;
  }
  return t10;
}
function ia(e11) {
  let t10 = "", n10 = false;
  for (let r10 = 0; r10 < e11.length; r10++)
    e11[r10] === "[" && !n10 ? (n10 = true, t10 += "[", r10++, r10 < e11.length && e11[r10] === "^" && (t10 += "^", r10++), r10 < e11.length && e11[r10] === "]" && (t10 += "]", r10++), r10--) : e11[r10] === "]" && n10 ? (n10 = false, t10 += "]") : !n10 && e11[r10] === "{" && e11[r10 + 1] === "," ? (t10 += "{0,", r10++) : t10 += e11[r10];
  return t10;
}
function Yf(e11) {
  let t10 = "";
  for (let n10 = 0; n10 < e11.length; n10++) {
    let r10 = e11[n10], s10 = r10.charCodeAt(0);
    r10 === "\\" ? t10 += "\\\\" : r10 === "	" ? t10 += "\\t" : r10 === `
` ? t10 += `$
` : r10 === "\r" ? t10 += "\\r" : r10 === "\x07" ? t10 += "\\a" : r10 === "\b" ? t10 += "\\b" : r10 === "\f" ? t10 += "\\f" : r10 === "\v" ? t10 += "\\v" : s10 < 32 || s10 >= 127 ? t10 += `\\${s10.toString(8).padStart(3, "0")}` : t10 += r10;
  }
  return `${t10}$`;
}
var ra;
var Jf = I(() => {
  "use strict";
  ra = /* @__PURE__ */ new Map([["alnum", "a-zA-Z0-9"], ["alpha", "a-zA-Z"], ["ascii", "\\x00-\\x7F"], ["blank", " \\t"], ["cntrl", "\\x00-\\x1F\\x7F"], ["digit", "0-9"], ["graph", "!-~"], ["lower", "a-z"], ["print", " -~"], ["punct", "!-/:-@\\[-`{-~"], ["space", " \\t\\n\\r\\f\\v"], ["upper", "A-Z"], ["word", "a-zA-Z0-9_"], ["xdigit", "0-9A-Fa-f"]]);
});
function e1(e11, t10, n10) {
  return { patternSpace: "", holdSpace: "", lineNumber: 0, totalLines: e11, deleted: false, printed: false, quit: false, quitSilent: false, exitCode: void 0, errorMessage: void 0, appendBuffer: [], substitutionMade: false, lineNumberOutput: [], nCommandOutput: [], restartCycle: false, inDRestartedCycle: false, currentFilename: t10, pendingFileReads: [], pendingFileWrites: [], pendingExecute: void 0, rangeStates: n10 || /* @__PURE__ */ new Map(), linesConsumedInCycle: 0 };
}
function K4(e11) {
  return typeof e11 == "object" && "first" in e11 && "step" in e11;
}
function X4(e11) {
  return typeof e11 == "object" && "offset" in e11;
}
function gr(e11, t10, n10, r10, s10) {
  if (e11 === "$")
    return t10 === n10;
  if (typeof e11 == "number")
    return t10 === e11;
  if (K4(e11)) {
    let { first: i10, step: o10 } = e11;
    return o10 === 0 ? t10 === i10 : (t10 - i10) % o10 === 0 && t10 >= i10;
  }
  if (typeof e11 == "object" && "pattern" in e11)
    try {
      let i10 = e11.pattern;
      i10 === "" && s10?.lastPattern ? i10 = s10.lastPattern : i10 !== "" && s10 && (s10.lastPattern = i10);
      let o10 = ia(sa(i10));
      return V(o10).test(r10);
    } catch {
      return false;
    }
  return false;
}
function oa(e11) {
  let t10 = (n10) => n10 === void 0 ? "undefined" : n10 === "$" ? "$" : typeof n10 == "number" ? String(n10) : "pattern" in n10 ? `/${n10.pattern}/` : "first" in n10 ? `${n10.first}~${n10.step}` : "unknown";
  return `${t10(e11.start)},${t10(e11.end)}`;
}
function Y4(e11, t10, n10, r10, s10, i10) {
  if (!e11 || !e11.start && !e11.end)
    return true;
  let o10 = e11.start, a = e11.end;
  if (o10 !== void 0 && a === void 0)
    return gr(o10, t10, n10, r10, i10);
  if (o10 !== void 0 && a !== void 0) {
    let l = typeof o10 == "object" && "pattern" in o10, c = typeof a == "object" && "pattern" in a, u = X4(a);
    if (u && s10) {
      let p = oa(e11), h = s10.get(p);
      if (h || (h = { active: false }, s10.set(p, h)), h.active) {
        let m = h.startLine || t10;
        return t10 >= m + a.offset && (h.active = false, s10.set(p, h)), true;
      } else
        return gr(o10, t10, n10, r10, i10) ? (h.active = true, h.startLine = t10, s10.set(p, h), a.offset === 0 && (h.active = false, s10.set(p, h)), true) : false;
    }
    if (!l && !c && !u) {
      let p = typeof o10 == "number" ? o10 : o10 === "$" ? n10 : 1, h = typeof a == "number" ? a : n10;
      if (p <= h)
        return t10 >= p && t10 <= h;
      if (s10) {
        let m = oa(e11), d = s10.get(m);
        return d || (d = { active: false }, s10.set(m, d)), !d.completed && t10 >= p ? (d.completed = true, s10.set(m, d), true) : false;
      }
      return false;
    }
    if (s10) {
      let p = oa(e11), h = s10.get(p);
      if (h || (h = { active: false }, s10.set(p, h)), h.active)
        return gr(a, t10, n10, r10, i10) && (h.active = false, typeof o10 == "number" && (h.completed = true), s10.set(p, h)), true;
      {
        if (h.completed)
          return false;
        let m = false;
        return typeof o10 == "number" ? m = t10 >= o10 : m = gr(o10, t10, n10, r10, i10), m ? (h.active = true, h.startLine = t10, s10.set(p, h), gr(a, t10, n10, r10, i10) && (h.active = false, typeof o10 == "number" && (h.completed = true), s10.set(p, h)), true) : false;
      }
    }
    return gr(o10, t10, n10, r10, i10);
  }
  return true;
}
function jn(e11, t10, n10, r10, s10, i10) {
  let o10 = Y4(e11, t10, n10, r10, s10, i10);
  return e11?.negated ? !o10 : o10;
}
function J4(e11, t10, n10, r10) {
  let s10 = "", i10 = 0, o10 = false;
  for (; i10 <= e11.length; ) {
    t10.lastIndex = i10;
    let a = t10.exec(e11);
    if (!a) {
      s10 += e11.slice(i10);
      break;
    }
    if (a.index !== i10) {
      s10 += e11.slice(i10, a.index), i10 = a.index, o10 = false;
      continue;
    }
    let l = a[0], c = a.slice(1);
    if (o10 && l.length === 0) {
      if (i10 < e11.length)
        s10 += e11[i10], i10++;
      else
        break;
      o10 = false;
      continue;
    }
    if (s10 += r10(l, c), o10 = false, l.length === 0)
      if (i10 < e11.length)
        s10 += e11[i10], i10++;
      else
        break;
    else
      i10 += l.length, o10 = true;
  }
  return s10;
}
function aa(e11, t10, n10) {
  let r10 = "", s10 = 0;
  for (; s10 < e11.length; ) {
    if (e11[s10] === "\\" && s10 + 1 < e11.length) {
      let i10 = e11[s10 + 1];
      if (i10 === "&") {
        r10 += "&", s10 += 2;
        continue;
      }
      if (i10 === "n") {
        r10 += `
`, s10 += 2;
        continue;
      }
      if (i10 === "t") {
        r10 += "	", s10 += 2;
        continue;
      }
      if (i10 === "r") {
        r10 += "\r", s10 += 2;
        continue;
      }
      let o10 = parseInt(i10, 10);
      if (o10 === 0) {
        r10 += t10, s10 += 2;
        continue;
      }
      if (o10 >= 1 && o10 <= 9) {
        r10 += n10[o10 - 1] || "", s10 += 2;
        continue;
      }
      r10 += i10, s10 += 2;
      continue;
    }
    if (e11[s10] === "&") {
      r10 += t10, s10++;
      continue;
    }
    r10 += e11[s10], s10++;
  }
  return r10;
}
function e3(e11, t10) {
  let { lineNumber: n10, totalLines: r10, patternSpace: s10 } = t10;
  if (e11.type === "label") {
    t10.coverage?.hit(`sed:cmd:${e11.type}`);
    return;
  }
  if (jn(e11.address, n10, r10, s10, t10.rangeStates, t10))
    switch (t10.coverage?.hit(`sed:cmd:${e11.type}`), e11.type) {
      case "substitute": {
        let i10 = e11, o10 = "";
        i10.global && (o10 += "g"), i10.ignoreCase && (o10 += "i");
        let a = i10.pattern;
        a === "" && t10.lastPattern ? a = t10.lastPattern : a !== "" && (t10.lastPattern = a);
        let l = ia(i10.extendedRegex ? a : sa(a));
        try {
          let c = V(l, o10), u = c.test(t10.patternSpace);
          if (c.lastIndex = 0, u) {
            if (t10.substitutionMade = true, i10.nthOccurrence && i10.nthOccurrence > 0 && !i10.global) {
              let f10 = 0, p = i10.nthOccurrence, h = V(l, `g${i10.ignoreCase ? "i" : ""}`);
              t10.patternSpace = h.replace(t10.patternSpace, (m, ...d) => {
                if (f10++, f10 === p) {
                  let g = d.slice(0, -2);
                  return aa(i10.replacement, m, g);
                }
                return m;
              });
            } else if (i10.global) {
              let f10 = V(l, `g${i10.ignoreCase ? "i" : ""}`);
              t10.patternSpace = J4(t10.patternSpace, f10, i10.replacement, (p, h) => aa(i10.replacement, p, h));
            } else
              t10.patternSpace = c.replace(t10.patternSpace, (f10, ...p) => {
                let h = p.slice(0, -2);
                return aa(i10.replacement, f10, h);
              });
            i10.printOnMatch && t10.lineNumberOutput.push(t10.patternSpace);
          }
        } catch {
        }
        break;
      }
      case "print":
        t10.lineNumberOutput.push(t10.patternSpace);
        break;
      case "printFirstLine": {
        let i10 = t10.patternSpace.indexOf(`
`);
        i10 !== -1 ? t10.lineNumberOutput.push(t10.patternSpace.slice(0, i10)) : t10.lineNumberOutput.push(t10.patternSpace);
        break;
      }
      case "delete":
        t10.deleted = true;
        break;
      case "deleteFirstLine": {
        let i10 = t10.patternSpace.indexOf(`
`);
        i10 !== -1 ? (t10.patternSpace = t10.patternSpace.slice(i10 + 1), t10.restartCycle = true, t10.inDRestartedCycle = true) : t10.deleted = true;
        break;
      }
      case "zap":
        t10.patternSpace = "";
        break;
      case "append":
        t10.appendBuffer.push(e11.text);
        break;
      case "insert":
        t10.appendBuffer.unshift(`__INSERT__${e11.text}`);
        break;
      case "change":
        t10.deleted = true, t10.changedText = e11.text;
        break;
      case "hold":
        t10.holdSpace = t10.patternSpace;
        break;
      case "holdAppend":
        t10.holdSpace ? t10.holdSpace += `
${t10.patternSpace}` : t10.holdSpace = t10.patternSpace;
        break;
      case "get":
        t10.patternSpace = t10.holdSpace;
        break;
      case "getAppend":
        t10.patternSpace += `
${t10.holdSpace}`;
        break;
      case "exchange": {
        let i10 = t10.patternSpace;
        t10.patternSpace = t10.holdSpace, t10.holdSpace = i10;
        break;
      }
      case "next":
        t10.printed = true;
        break;
      case "quit":
        t10.quit = true, e11.exitCode !== void 0 && (t10.exitCode = e11.exitCode);
        break;
      case "quitSilent":
        t10.quit = true, t10.quitSilent = true, e11.exitCode !== void 0 && (t10.exitCode = e11.exitCode);
        break;
      case "list": {
        let i10 = Yf(t10.patternSpace);
        t10.lineNumberOutput.push(i10);
        break;
      }
      case "printFilename":
        t10.currentFilename && t10.lineNumberOutput.push(t10.currentFilename);
        break;
      case "version": {
        let i10 = [4, 8, 0];
        if (e11.minVersion) {
          let o10 = e11.minVersion.split("."), a = [], l = false;
          for (let c of o10) {
            let u = parseInt(c, 10);
            if (Number.isNaN(u) || u < 0) {
              t10.quit = true, t10.exitCode = 1, t10.errorMessage = `sed: invalid version string: ${e11.minVersion}`, l = true;
              break;
            }
            a.push(u);
          }
          if (!l) {
            for (; a.length < 3; )
              a.push(0);
            for (let c = 0; c < 3; c++) {
              if (a[c] > i10[c]) {
                t10.quit = true, t10.exitCode = 1, t10.errorMessage = `sed: this is not GNU sed version ${e11.minVersion}`;
                break;
              }
              if (a[c] < i10[c])
                break;
            }
          }
        }
        break;
      }
      case "readFile":
        t10.pendingFileReads.push({ filename: e11.filename, wholeFile: true });
        break;
      case "readFileLine":
        t10.pendingFileReads.push({ filename: e11.filename, wholeFile: false });
        break;
      case "writeFile":
        t10.pendingFileWrites.push({ filename: e11.filename, content: `${t10.patternSpace}
` });
        break;
      case "writeFirstLine": {
        let i10 = t10.patternSpace.indexOf(`
`), o10 = i10 !== -1 ? t10.patternSpace.slice(0, i10) : t10.patternSpace;
        t10.pendingFileWrites.push({ filename: e11.filename, content: `${o10}
` });
        break;
      }
      case "execute":
        e11.command ? t10.pendingExecute = { command: e11.command, replacePattern: false } : t10.pendingExecute = { command: t10.patternSpace, replacePattern: true };
        break;
      case "transliterate":
        t10.patternSpace = t3(t10.patternSpace, e11);
        break;
      case "lineNumber":
        t10.lineNumberOutput.push(String(t10.lineNumber));
        break;
      case "branch":
        break;
      case "branchOnSubst":
        break;
      case "branchOnNoSubst":
        break;
      case "group":
        break;
    }
}
function t3(e11, t10) {
  let n10 = "";
  for (let r10 of e11) {
    let s10 = t10.source.indexOf(r10);
    s10 !== -1 ? n10 += t10.dest[s10] : n10 += r10;
  }
  return n10;
}
function la(e11, t10, n10, r10) {
  let s10 = /* @__PURE__ */ new Map();
  for (let l = 0; l < e11.length; l++) {
    let c = e11[l];
    c.type === "label" && s10.set(c.name, l);
  }
  let i10 = r10?.maxIterations ?? Q4, o10 = 0, a = 0;
  for (; a < e11.length; ) {
    if (o10++, o10 > i10)
      throw new te(`sed: command execution exceeded maximum iterations (${i10})`, "iterations");
    if (t10.deleted || t10.quit || t10.quitSilent || t10.restartCycle)
      break;
    let l = e11[a];
    if (l.type === "next") {
      if (jn(l.address, t10.lineNumber, t10.totalLines, t10.patternSpace, t10.rangeStates, t10))
        if (t10.coverage?.hit("sed:cmd:next"), t10.nCommandOutput.push(t10.patternSpace), n10 && n10.currentLineIndex + t10.linesConsumedInCycle + 1 < n10.lines.length) {
          t10.linesConsumedInCycle++;
          let c = n10.lines[n10.currentLineIndex + t10.linesConsumedInCycle];
          t10.patternSpace = c, t10.lineNumber = n10.currentLineIndex + t10.linesConsumedInCycle + 1, t10.substitutionMade = false;
        } else {
          t10.quit = true, t10.deleted = true;
          break;
        }
      a++;
      continue;
    }
    if (l.type === "nextAppend") {
      if (jn(l.address, t10.lineNumber, t10.totalLines, t10.patternSpace, t10.rangeStates, t10))
        if (t10.coverage?.hit("sed:cmd:nextAppend"), n10 && n10.currentLineIndex + t10.linesConsumedInCycle + 1 < n10.lines.length) {
          t10.linesConsumedInCycle++;
          let c = n10.lines[n10.currentLineIndex + t10.linesConsumedInCycle];
          t10.patternSpace += `
${c}`, t10.lineNumber = n10.currentLineIndex + t10.linesConsumedInCycle + 1;
        } else {
          t10.quit = true;
          break;
        }
      a++;
      continue;
    }
    if (l.type === "branch") {
      let c = l;
      if (jn(c.address, t10.lineNumber, t10.totalLines, t10.patternSpace, t10.rangeStates, t10)) {
        if (t10.coverage?.hit("sed:cmd:branch"), c.label) {
          let u = s10.get(c.label);
          if (u !== void 0) {
            a = u;
            continue;
          }
          t10.branchRequest = c.label;
          break;
        }
        break;
      }
      a++;
      continue;
    }
    if (l.type === "branchOnSubst") {
      let c = l;
      if (jn(c.address, t10.lineNumber, t10.totalLines, t10.patternSpace, t10.rangeStates, t10) && (t10.coverage?.hit("sed:cmd:branchOnSubst"), t10.substitutionMade)) {
        if (t10.substitutionMade = false, c.label) {
          let u = s10.get(c.label);
          if (u !== void 0) {
            a = u;
            continue;
          }
          t10.branchRequest = c.label;
          break;
        }
        break;
      }
      a++;
      continue;
    }
    if (l.type === "branchOnNoSubst") {
      let c = l;
      if (jn(c.address, t10.lineNumber, t10.totalLines, t10.patternSpace, t10.rangeStates, t10) && (t10.coverage?.hit("sed:cmd:branchOnNoSubst"), !t10.substitutionMade)) {
        if (c.label) {
          let u = s10.get(c.label);
          if (u !== void 0) {
            a = u;
            continue;
          }
          t10.branchRequest = c.label;
          break;
        }
        break;
      }
      a++;
      continue;
    }
    if (l.type === "group") {
      let c = l;
      if (jn(c.address, t10.lineNumber, t10.totalLines, t10.patternSpace, t10.rangeStates, t10) && (t10.coverage?.hit("sed:cmd:group"), la(c.commands, t10, n10, r10), t10.branchRequest)) {
        let u = s10.get(t10.branchRequest);
        if (u !== void 0) {
          t10.branchRequest = void 0, a = u;
          continue;
        }
        break;
      }
      a++;
      continue;
    }
    e3(l, t10), a++;
  }
  return t10.linesConsumedInCycle;
}
var Q4;
var t1 = I(() => {
  "use strict";
  ye();
  Fe();
  Jf();
  Q4 = 1e4;
});
var ee;
var Ys;
var n1 = I(() => {
  "use strict";
  (function(e11) {
    e11.NUMBER = "NUMBER", e11.DOLLAR = "DOLLAR", e11.PATTERN = "PATTERN", e11.STEP = "STEP", e11.RELATIVE_OFFSET = "RELATIVE_OFFSET", e11.LBRACE = "LBRACE", e11.RBRACE = "RBRACE", e11.SEMICOLON = "SEMICOLON", e11.NEWLINE = "NEWLINE", e11.COMMA = "COMMA", e11.NEGATION = "NEGATION", e11.COMMAND = "COMMAND", e11.SUBSTITUTE = "SUBSTITUTE", e11.TRANSLITERATE = "TRANSLITERATE", e11.LABEL_DEF = "LABEL_DEF", e11.BRANCH = "BRANCH", e11.BRANCH_ON_SUBST = "BRANCH_ON_SUBST", e11.BRANCH_ON_NO_SUBST = "BRANCH_ON_NO_SUBST", e11.TEXT_CMD = "TEXT_CMD", e11.FILE_READ = "FILE_READ", e11.FILE_READ_LINE = "FILE_READ_LINE", e11.FILE_WRITE = "FILE_WRITE", e11.FILE_WRITE_LINE = "FILE_WRITE_LINE", e11.EXECUTE = "EXECUTE", e11.VERSION = "VERSION", e11.EOF = "EOF", e11.ERROR = "ERROR";
  })(ee || (ee = {}));
  Ys = class {
    input;
    pos = 0;
    line = 1;
    column = 1;
    constructor(t10) {
      this.input = t10;
    }
    tokenize() {
      let t10 = [];
      for (; this.pos < this.input.length; ) {
        let n10 = this.nextToken();
        n10 && t10.push(n10);
      }
      return t10.push(this.makeToken(ee.EOF, "")), t10;
    }
    makeToken(t10, n10, r10) {
      return { type: t10, value: n10, line: this.line, column: this.column, ...r10 };
    }
    peek(t10 = 0) {
      return this.input[this.pos + t10] || "";
    }
    advance() {
      let t10 = this.input[this.pos++] || "";
      return t10 === `
` ? (this.line++, this.column = 1) : this.column++, t10;
    }
    readEscapedString(t10) {
      let n10 = "";
      for (; this.pos < this.input.length && this.peek() !== t10; )
        if (this.peek() === "\\") {
          this.advance();
          let r10 = this.advance();
          r10 === "n" ? n10 += `
` : r10 === "t" ? n10 += "	" : n10 += r10;
        } else {
          if (this.peek() === `
`)
            return null;
          n10 += this.advance();
        }
      return n10;
    }
    skipWhitespace() {
      for (; this.pos < this.input.length; ) {
        let t10 = this.peek();
        if (t10 === " " || t10 === "	" || t10 === "\r")
          this.advance();
        else if (t10 === "#")
          for (; this.pos < this.input.length && this.peek() !== `
`; )
            this.advance();
        else
          break;
      }
    }
    nextToken() {
      if (this.skipWhitespace(), this.pos >= this.input.length)
        return null;
      let t10 = this.line, n10 = this.column, r10 = this.peek();
      return r10 === `
` ? (this.advance(), { type: ee.NEWLINE, value: `
`, line: t10, column: n10 }) : r10 === ";" ? (this.advance(), { type: ee.SEMICOLON, value: ";", line: t10, column: n10 }) : r10 === "{" ? (this.advance(), { type: ee.LBRACE, value: "{", line: t10, column: n10 }) : r10 === "}" ? (this.advance(), { type: ee.RBRACE, value: "}", line: t10, column: n10 }) : r10 === "," ? (this.advance(), { type: ee.COMMA, value: ",", line: t10, column: n10 }) : r10 === "!" ? (this.advance(), { type: ee.NEGATION, value: "!", line: t10, column: n10 }) : r10 === "$" ? (this.advance(), { type: ee.DOLLAR, value: "$", line: t10, column: n10 }) : this.isDigit(r10) ? this.readNumber() : r10 === "+" && this.isDigit(this.input[this.pos + 1] || "") ? this.readRelativeOffset() : r10 === "/" ? this.readPattern() : r10 === ":" ? this.readLabelDef() : this.readCommand();
    }
    readNumber() {
      let t10 = this.line, n10 = this.column, r10 = "";
      for (; this.isDigit(this.peek()); )
        r10 += this.advance();
      if (this.peek() === "~") {
        this.advance();
        let s10 = "";
        for (; this.isDigit(this.peek()); )
          s10 += this.advance();
        let i10 = parseInt(r10, 10), o10 = parseInt(s10, 10) || 0;
        return { type: ee.STEP, value: `${i10}~${o10}`, first: i10, step: o10, line: t10, column: n10 };
      }
      return { type: ee.NUMBER, value: parseInt(r10, 10), line: t10, column: n10 };
    }
    readRelativeOffset() {
      let t10 = this.line, n10 = this.column;
      this.advance();
      let r10 = "";
      for (; this.isDigit(this.peek()); )
        r10 += this.advance();
      let s10 = parseInt(r10, 10) || 0;
      return { type: ee.RELATIVE_OFFSET, value: `+${s10}`, offset: s10, line: t10, column: n10 };
    }
    readPattern() {
      let t10 = this.line, n10 = this.column;
      this.advance();
      let r10 = "", s10 = false;
      for (; this.pos < this.input.length; ) {
        let i10 = this.peek();
        if (i10 === "/" && !s10)
          break;
        if (i10 === "\\")
          r10 += this.advance(), this.pos < this.input.length && this.peek() !== `
` && (r10 += this.advance());
        else {
          if (i10 === `
`)
            break;
          i10 === "[" && !s10 ? (s10 = true, r10 += this.advance(), this.peek() === "^" && (r10 += this.advance()), this.peek() === "]" && (r10 += this.advance())) : i10 === "]" && s10 ? (s10 = false, r10 += this.advance()) : r10 += this.advance();
        }
      }
      return this.peek() === "/" && this.advance(), { type: ee.PATTERN, value: r10, pattern: r10, line: t10, column: n10 };
    }
    readLabelDef() {
      let t10 = this.line, n10 = this.column;
      for (this.advance(); this.peek() === " " || this.peek() === "	"; )
        this.advance();
      let r10 = "";
      for (; this.pos < this.input.length; ) {
        let s10 = this.peek();
        if (s10 === " " || s10 === "	" || s10 === `
` || s10 === ";" || s10 === "}" || s10 === "{")
          break;
        r10 += this.advance();
      }
      return { type: ee.LABEL_DEF, value: r10, label: r10, line: t10, column: n10 };
    }
    readCommand() {
      let t10 = this.line, n10 = this.column, r10 = this.advance();
      switch (r10) {
        case "s":
          return this.readSubstitute(t10, n10);
        case "y":
          return this.readTransliterate(t10, n10);
        case "a":
        case "i":
        case "c":
          return this.readTextCommand(r10, t10, n10);
        case "b":
          return this.readBranch(ee.BRANCH, "b", t10, n10);
        case "t":
          return this.readBranch(ee.BRANCH_ON_SUBST, "t", t10, n10);
        case "T":
          return this.readBranch(ee.BRANCH_ON_NO_SUBST, "T", t10, n10);
        case "r":
          return this.readFileCommand(ee.FILE_READ, "r", t10, n10);
        case "R":
          return this.readFileCommand(ee.FILE_READ_LINE, "R", t10, n10);
        case "w":
          return this.readFileCommand(ee.FILE_WRITE, "w", t10, n10);
        case "W":
          return this.readFileCommand(ee.FILE_WRITE_LINE, "W", t10, n10);
        case "e":
          return this.readExecute(t10, n10);
        case "p":
        case "P":
        case "d":
        case "D":
        case "h":
        case "H":
        case "g":
        case "G":
        case "x":
        case "n":
        case "N":
        case "q":
        case "Q":
        case "z":
        case "=":
        case "l":
        case "F":
          return { type: ee.COMMAND, value: r10, line: t10, column: n10 };
        case "v":
          return this.readVersion(t10, n10);
        default:
          return { type: ee.ERROR, value: r10, line: t10, column: n10 };
      }
    }
    readSubstitute(t10, n10) {
      let r10 = this.advance();
      if (!r10 || r10 === `
`)
        return { type: ee.ERROR, value: "s", line: t10, column: n10 };
      let s10 = "", i10 = false;
      for (; this.pos < this.input.length; ) {
        let l = this.peek();
        if (l === r10 && !i10)
          break;
        if (l === "\\")
          this.advance(), this.pos < this.input.length && this.peek() !== `
` ? this.peek() === r10 && !i10 ? s10 += this.advance() : (s10 += "\\", s10 += this.advance()) : s10 += "\\";
        else {
          if (l === `
`)
            break;
          l === "[" && !i10 ? (i10 = true, s10 += this.advance(), this.peek() === "^" && (s10 += this.advance()), this.peek() === "]" && (s10 += this.advance())) : l === "]" && i10 ? (i10 = false, s10 += this.advance()) : s10 += this.advance();
        }
      }
      if (this.peek() !== r10)
        return { type: ee.ERROR, value: "unterminated substitution pattern", line: t10, column: n10 };
      this.advance();
      let o10 = "";
      for (; this.pos < this.input.length && this.peek() !== r10; )
        if (this.peek() === "\\")
          if (this.advance(), this.pos < this.input.length) {
            let l = this.peek();
            l === "\\" ? (this.advance(), this.pos < this.input.length && this.peek() === `
` ? (o10 += `
`, this.advance()) : o10 += "\\") : l === `
` ? (o10 += `
`, this.advance()) : o10 += `\\${this.advance()}`;
          } else
            o10 += "\\";
        else {
          if (this.peek() === `
`)
            break;
          o10 += this.advance();
        }
      this.peek() === r10 && this.advance();
      let a = "";
      for (; this.pos < this.input.length; ) {
        let l = this.peek();
        if (l === "g" || l === "i" || l === "p" || l === "I" || this.isDigit(l))
          a += this.advance();
        else
          break;
      }
      return { type: ee.SUBSTITUTE, value: `s${r10}${s10}${r10}${o10}${r10}${a}`, pattern: s10, replacement: o10, flags: a, line: t10, column: n10 };
    }
    readTransliterate(t10, n10) {
      let r10 = this.advance();
      if (!r10 || r10 === `
`)
        return { type: ee.ERROR, value: "y", line: t10, column: n10 };
      let s10 = this.readEscapedString(r10);
      if (s10 === null || this.peek() !== r10)
        return { type: ee.ERROR, value: "unterminated transliteration source", line: t10, column: n10 };
      this.advance();
      let i10 = this.readEscapedString(r10);
      if (i10 === null || this.peek() !== r10)
        return { type: ee.ERROR, value: "unterminated transliteration dest", line: t10, column: n10 };
      this.advance();
      let o10 = this.peek();
      for (; o10 === " " || o10 === "	"; )
        this.advance(), o10 = this.peek();
      return o10 !== "" && o10 !== ";" && o10 !== `
` && o10 !== "}" ? { type: ee.ERROR, value: "extra text at the end of a transform command", line: t10, column: n10 } : { type: ee.TRANSLITERATE, value: `y${r10}${s10}${r10}${i10}${r10}`, source: s10, dest: i10, line: t10, column: n10 };
    }
    readTextCommand(t10, n10, r10) {
      let s10 = false;
      this.peek() === "\\" && this.pos + 1 < this.input.length && (this.input[this.pos + 1] === `
` || this.input[this.pos + 1] === " " || this.input[this.pos + 1] === "	") && (s10 = true, this.advance()), (this.peek() === " " || this.peek() === "	") && this.advance(), this.peek() === "\\" && this.pos + 1 < this.input.length && (this.input[this.pos + 1] === " " || this.input[this.pos + 1] === "	") && this.advance(), s10 && this.peek() === `
` && this.advance();
      let i10 = "";
      for (; this.pos < this.input.length; ) {
        let o10 = this.peek();
        if (o10 === `
`) {
          if (i10.endsWith("\\")) {
            i10 = `${i10.slice(0, -1)}
`, this.advance();
            continue;
          }
          break;
        }
        if (o10 === "\\" && this.pos + 1 < this.input.length) {
          let a = this.input[this.pos + 1];
          if (a === "n") {
            i10 += `
`, this.advance(), this.advance();
            continue;
          }
          if (a === "t") {
            i10 += "	", this.advance(), this.advance();
            continue;
          }
          if (a === "r") {
            i10 += "\r", this.advance(), this.advance();
            continue;
          }
        }
        i10 += this.advance();
      }
      return { type: ee.TEXT_CMD, value: t10, text: i10, line: n10, column: r10 };
    }
    readBranch(t10, n10, r10, s10) {
      for (; this.peek() === " " || this.peek() === "	"; )
        this.advance();
      let i10 = "";
      for (; this.pos < this.input.length; ) {
        let o10 = this.peek();
        if (o10 === " " || o10 === "	" || o10 === `
` || o10 === ";" || o10 === "}" || o10 === "{")
          break;
        i10 += this.advance();
      }
      return { type: t10, value: n10, label: i10 || void 0, line: r10, column: s10 };
    }
    readVersion(t10, n10) {
      for (; this.peek() === " " || this.peek() === "	"; )
        this.advance();
      let r10 = "";
      for (; this.pos < this.input.length; ) {
        let s10 = this.peek();
        if (s10 === " " || s10 === "	" || s10 === `
` || s10 === ";" || s10 === "}" || s10 === "{")
          break;
        r10 += this.advance();
      }
      return { type: ee.VERSION, value: "v", label: r10 || void 0, line: t10, column: n10 };
    }
    readFileCommand(t10, n10, r10, s10) {
      for (; this.peek() === " " || this.peek() === "	"; )
        this.advance();
      let i10 = "";
      for (; this.pos < this.input.length; ) {
        let o10 = this.peek();
        if (o10 === `
` || o10 === ";")
          break;
        i10 += this.advance();
      }
      return { type: t10, value: n10, filename: i10.trim(), line: r10, column: s10 };
    }
    readExecute(t10, n10) {
      for (; this.peek() === " " || this.peek() === "	"; )
        this.advance();
      let r10 = "";
      for (; this.pos < this.input.length; ) {
        let s10 = this.peek();
        if (s10 === `
` || s10 === ";")
          break;
        r10 += this.advance();
      }
      return { type: ee.EXECUTE, value: "e", command: r10.trim() || void 0, line: t10, column: n10 };
    }
    isDigit(t10) {
      return t10 >= "0" && t10 <= "9";
    }
  };
});
function r1(e11, t10 = false) {
  let n10 = false, r10 = false, s10 = [];
  for (let l = 0; l < e11.length; l++) {
    let c = e11[l];
    if (s10.length === 0 && l === 0) {
      let u = c.match(/^#([nr]+)\s*(?:\n|$)/i);
      if (u) {
        let f10 = u[1].toLowerCase();
        f10.includes("n") && (n10 = true), f10.includes("r") && (r10 = true), c = c.slice(u[0].length);
      }
    }
    if (s10.length > 0 && s10[s10.length - 1].endsWith("\\")) {
      let u = s10[s10.length - 1];
      s10[s10.length - 1] = `${u}
${c}`;
    } else
      s10.push(c);
  }
  let i10 = s10.join(`
`), a = new ca([i10], t10 || r10).parse();
  if (!a.error && a.commands.length > 0) {
    let l = n3(a.commands);
    if (l)
      return { commands: [], error: l, silentMode: n10, extendedRegexMode: r10 };
  }
  return { ...a, silentMode: n10, extendedRegexMode: r10 };
}
function n3(e11) {
  let t10 = /* @__PURE__ */ new Set();
  s1(e11, t10);
  let n10 = i1(e11, t10);
  if (n10)
    return `undefined label '${n10}'`;
}
function s1(e11, t10) {
  for (let n10 of e11)
    n10.type === "label" ? t10.add(n10.name) : n10.type === "group" && s1(n10.commands, t10);
}
function i1(e11, t10) {
  for (let n10 of e11) {
    if ((n10.type === "branch" || n10.type === "branchOnSubst" || n10.type === "branchOnNoSubst") && n10.label && !t10.has(n10.label))
      return n10.label;
    if (n10.type === "group") {
      let r10 = i1(n10.commands, t10);
      if (r10)
        return r10;
    }
  }
}
var ca;
var o1 = I(() => {
  "use strict";
  n1();
  ca = class {
    scripts;
    tokens = [];
    pos = 0;
    extendedRegex = false;
    constructor(t10, n10 = false) {
      this.scripts = t10, this.extendedRegex = n10;
    }
    parse() {
      let t10 = [];
      for (let n10 of this.scripts) {
        let r10 = new Ys(n10);
        for (this.tokens = r10.tokenize(), this.pos = 0; !this.isAtEnd(); ) {
          if (this.check(ee.NEWLINE) || this.check(ee.SEMICOLON)) {
            this.advance();
            continue;
          }
          let s10 = this.parseCommand();
          if (s10.error)
            return { commands: [], error: s10.error };
          s10.command && t10.push(s10.command);
        }
      }
      return { commands: t10 };
    }
    parseCommand() {
      let t10 = this.parseAddressRange();
      if (t10?.error)
        return { command: null, error: t10.error };
      let n10 = t10?.address;
      for (this.check(ee.NEGATION) && (this.advance(), n10 && (n10.negated = true)); this.check(ee.NEWLINE) || this.check(ee.SEMICOLON); )
        this.advance();
      if (this.isAtEnd())
        return n10 && (n10.start !== void 0 || n10.end !== void 0) ? { command: null, error: "command expected" } : { command: null };
      let r10 = this.peek();
      switch (r10.type) {
        case ee.COMMAND:
          return this.parseSimpleCommand(r10, n10);
        case ee.SUBSTITUTE:
          return this.parseSubstituteFromToken(r10, n10);
        case ee.TRANSLITERATE:
          return this.parseTransliterateFromToken(r10, n10);
        case ee.LABEL_DEF:
          return this.advance(), { command: { type: "label", name: r10.label || "" } };
        case ee.BRANCH:
          return this.advance(), { command: { type: "branch", address: n10, label: r10.label } };
        case ee.BRANCH_ON_SUBST:
          return this.advance(), { command: { type: "branchOnSubst", address: n10, label: r10.label } };
        case ee.BRANCH_ON_NO_SUBST:
          return this.advance(), { command: { type: "branchOnNoSubst", address: n10, label: r10.label } };
        case ee.TEXT_CMD:
          return this.advance(), this.parseTextCommand(r10, n10);
        case ee.FILE_READ:
          return this.advance(), { command: { type: "readFile", address: n10, filename: r10.filename || "" } };
        case ee.FILE_READ_LINE:
          return this.advance(), { command: { type: "readFileLine", address: n10, filename: r10.filename || "" } };
        case ee.FILE_WRITE:
          return this.advance(), { command: { type: "writeFile", address: n10, filename: r10.filename || "" } };
        case ee.FILE_WRITE_LINE:
          return this.advance(), { command: { type: "writeFirstLine", address: n10, filename: r10.filename || "" } };
        case ee.EXECUTE:
          return this.advance(), { command: { type: "execute", address: n10, command: r10.command } };
        case ee.VERSION:
          return this.advance(), { command: { type: "version", address: n10, minVersion: r10.label } };
        case ee.LBRACE:
          return this.parseGroup(n10);
        case ee.RBRACE:
          return { command: null };
        case ee.ERROR:
          return { command: null, error: `invalid command: ${r10.value}` };
        default:
          return n10 && (n10.start !== void 0 || n10.end !== void 0) ? { command: null, error: "command expected" } : { command: null };
      }
    }
    parseSimpleCommand(t10, n10) {
      this.advance();
      let r10 = t10.value;
      switch (r10) {
        case "p":
          return { command: { type: "print", address: n10 } };
        case "P":
          return { command: { type: "printFirstLine", address: n10 } };
        case "d":
          return { command: { type: "delete", address: n10 } };
        case "D":
          return { command: { type: "deleteFirstLine", address: n10 } };
        case "h":
          return { command: { type: "hold", address: n10 } };
        case "H":
          return { command: { type: "holdAppend", address: n10 } };
        case "g":
          return { command: { type: "get", address: n10 } };
        case "G":
          return { command: { type: "getAppend", address: n10 } };
        case "x":
          return { command: { type: "exchange", address: n10 } };
        case "n":
          return { command: { type: "next", address: n10 } };
        case "N":
          return { command: { type: "nextAppend", address: n10 } };
        case "q":
          return { command: { type: "quit", address: n10 } };
        case "Q":
          return { command: { type: "quitSilent", address: n10 } };
        case "z":
          return { command: { type: "zap", address: n10 } };
        case "=":
          return { command: { type: "lineNumber", address: n10 } };
        case "l":
          return { command: { type: "list", address: n10 } };
        case "F":
          return { command: { type: "printFilename", address: n10 } };
        default:
          return { command: null, error: `unknown command: ${r10}` };
      }
    }
    parseSubstituteFromToken(t10, n10) {
      this.advance();
      let r10 = t10.flags || "", s10, i10 = r10.match(/(\d+)/);
      return i10 && (s10 = parseInt(i10[1], 10)), { command: { type: "substitute", address: n10, pattern: t10.pattern || "", replacement: t10.replacement || "", global: r10.includes("g"), ignoreCase: r10.includes("i") || r10.includes("I"), printOnMatch: r10.includes("p"), nthOccurrence: s10, extendedRegex: this.extendedRegex } };
    }
    parseTransliterateFromToken(t10, n10) {
      this.advance();
      let r10 = t10.source || "", s10 = t10.dest || "";
      return r10.length !== s10.length ? { command: null, error: "transliteration sets must have same length" } : { command: { type: "transliterate", address: n10, source: r10, dest: s10 } };
    }
    parseTextCommand(t10, n10) {
      let r10 = t10.value, s10 = t10.text || "";
      switch (r10) {
        case "a":
          return { command: { type: "append", address: n10, text: s10 } };
        case "i":
          return { command: { type: "insert", address: n10, text: s10 } };
        case "c":
          return { command: { type: "change", address: n10, text: s10 } };
        default:
          return { command: null, error: `unknown text command: ${r10}` };
      }
    }
    parseGroup(t10) {
      this.advance();
      let n10 = [];
      for (; !this.isAtEnd() && !this.check(ee.RBRACE); ) {
        if (this.check(ee.NEWLINE) || this.check(ee.SEMICOLON)) {
          this.advance();
          continue;
        }
        let r10 = this.parseCommand();
        if (r10.error)
          return { command: null, error: r10.error };
        r10.command && n10.push(r10.command);
      }
      return this.check(ee.RBRACE) ? (this.advance(), { command: { type: "group", address: t10, commands: n10 } }) : { command: null, error: "unmatched brace in grouped commands" };
    }
    parseAddressRange() {
      let t10 = this.parseAddress();
      if (t10 === void 0)
        return;
      let n10;
      if (this.check(ee.RELATIVE_OFFSET))
        n10 = { offset: this.advance().offset || 0 };
      else if (this.check(ee.COMMA) && (this.advance(), n10 = this.parseAddress(), n10 === void 0))
        return { error: "expected context address" };
      return { address: { start: t10, end: n10 } };
    }
    parseAddress() {
      let t10 = this.peek();
      switch (t10.type) {
        case ee.NUMBER:
          return this.advance(), t10.value;
        case ee.DOLLAR:
          return this.advance(), "$";
        case ee.PATTERN:
          return this.advance(), { pattern: t10.pattern || t10.value };
        case ee.STEP:
          return this.advance(), { first: t10.first || 0, step: t10.step || 0 };
        case ee.RELATIVE_OFFSET:
          return this.advance(), { offset: t10.offset || 0 };
        default:
          return;
      }
    }
    peek() {
      return this.tokens[this.pos] || { type: ee.EOF, value: "", line: 0, column: 0 };
    }
    advance() {
      return this.isAtEnd() || this.pos++, this.tokens[this.pos - 1];
    }
    check(t10) {
      return this.peek().type === t10;
    }
    isAtEnd() {
      return this.peek().type === ee.EOF;
    }
  };
});
var a1 = {};
Q(a1, { flagsForFuzzing: () => i3, sedCommand: () => s3 });
async function ua(e11, t10, n10, r10 = {}) {
  let { limits: s10, filename: i10, fs: o10, cwd: a, coverage: l } = r10, c = e11.endsWith(`
`), u = e11.split(`
`);
  u.length > 0 && u[u.length - 1] === "" && u.pop();
  let f10 = u.length, p = "", h, m = false, d = s10?.maxStringLength ?? 0, g = (F4) => {
    if (p += F4, d > 0 && p.length > d)
      throw new te(`sed: output size limit exceeded (${d} bytes)`, "string_length");
  }, y = "", w, b = /* @__PURE__ */ new Map(), x = /* @__PURE__ */ new Map(), S = /* @__PURE__ */ new Map(), O = /* @__PURE__ */ new Map(), R10 = s10 ? { maxIterations: s10.maxSedIterations } : void 0;
  for (let F4 = 0; F4 < u.length; F4++) {
    let $ = { ...e1(f10, i10, b), patternSpace: u[F4], holdSpace: y, lastPattern: w, lineNumber: F4 + 1, totalLines: f10, substitutionMade: false, coverage: l }, z = { lines: u, currentLineIndex: F4 }, k = 0, N10 = 1e4;
    $.linesConsumedInCycle = 0;
    do {
      if (k++, k > N10)
        break;
      if ($.restartCycle = false, $.pendingFileReads = [], $.pendingFileWrites = [], la(t10, $, z, R10), o10 && a) {
        for (let re of $.pendingFileReads) {
          let J = o10.resolvePath(a, re.filename);
          try {
            if (re.wholeFile) {
              let H = await o10.readFile(J);
              $.appendBuffer.push(H.replace(/\n$/, ""));
            } else {
              if (!x.has(J)) {
                let Ee = await o10.readFile(J);
                x.set(J, Ee.split(`
`)), S.set(J, 0);
              }
              let H = x.get(J), X = S.get(J);
              H && X !== void 0 && X < H.length && ($.appendBuffer.push(H[X]), S.set(J, X + 1));
            }
          } catch {
          }
        }
        for (let re of $.pendingFileWrites) {
          let J = o10.resolvePath(a, re.filename), H = O.get(J) || "";
          O.set(J, H + re.content);
        }
      }
    } while ($.restartCycle && !$.deleted && !$.quit && !$.quitSilent);
    if (F4 += $.linesConsumedInCycle, y = $.holdSpace, w = $.lastPattern, !n10)
      for (let re of $.nCommandOutput)
        g(`${re}
`);
    let P = $.lineNumberOutput.length > 0;
    for (let re of $.lineNumberOutput)
      g(`${re}
`);
    let v = [], T = [];
    for (let re of $.appendBuffer)
      re.startsWith("__INSERT__") ? v.push(re.slice(10)) : T.push(re);
    for (let re of v)
      g(`${re}
`);
    let L = false;
    !$.deleted && !$.quitSilent ? n10 ? $.printed && (g(`${$.patternSpace}
`), L = true) : (g(`${$.patternSpace}
`), L = true) : $.changedText !== void 0 && (g(`${$.changedText}
`), L = true);
    for (let re of T)
      g(`${re}
`);
    if (m = (P || L) && T.length === 0, $.quit || $.quitSilent) {
      if ($.exitCode !== void 0 && (h = $.exitCode), $.errorMessage)
        return { output: "", exitCode: h || 1, errorMessage: $.errorMessage };
      break;
    }
  }
  if (o10 && a)
    for (let [F4, $] of O)
      try {
        await o10.writeFile(F4, $);
      } catch {
      }
  return !c && m && p.endsWith(`
`) && (p = p.slice(0, -1)), { output: p, exitCode: h };
}
var r3;
var s3;
var i3;
var l1 = I(() => {
  "use strict";
  ye();
  se();
  t1();
  o1();
  r3 = { name: "sed", summary: "stream editor for filtering and transforming text", usage: "sed [OPTION]... {script} [input-file]...", options: ["-n, --quiet, --silent  suppress automatic printing of pattern space", "-e script              add the script to commands to be executed", "-f script-file         read script from file", "-i, --in-place         edit files in place", "-E, -r, --regexp-extended  use extended regular expressions", "    --help             display this help and exit"], description: `Commands:
  s/regexp/replacement/[flags]  substitute
  d                             delete pattern space
  p                             print pattern space
  a\\ text                       append text after line
  i\\ text                       insert text before line
  c\\ text                       change (replace) line with text
  h                             copy pattern space to hold space
  H                             append pattern space to hold space
  g                             copy hold space to pattern space
  G                             append hold space to pattern space
  x                             exchange pattern and hold spaces
  n                             read next line into pattern space
  N                             append next line to pattern space
  y/source/dest/                transliterate characters
  =                             print line number
  l                             list pattern space (escape special chars)
  b [label]                     branch to label
  t [label]                     branch on substitution
  T [label]                     branch if no substitution
  :label                        define label
  q                             quit
  Q                             quit without printing

Addresses:
  N                             line number
  $                             last line
  /regexp/                      lines matching regexp
  N,M                           range from line N to M
  first~step                    every step-th line starting at first` };
  s3 = { name: "sed", async execute(e11, t10) {
    if (U2(e11))
      return M(r3);
    let n10 = [], r10 = [], s10 = false, i10 = false, o10 = false, a = [];
    for (let m = 0; m < e11.length; m++) {
      let d = e11[m];
      if (d === "-n" || d === "--quiet" || d === "--silent")
        s10 = true;
      else if (d === "-i" || d === "--in-place")
        i10 = true;
      else if (d.startsWith("-i"))
        i10 = true;
      else if (d === "-E" || d === "-r" || d === "--regexp-extended")
        o10 = true;
      else if (d === "-e")
        m + 1 < e11.length && n10.push(e11[++m]);
      else if (d === "-f")
        m + 1 < e11.length && r10.push(e11[++m]);
      else {
        if (d.startsWith("--"))
          return Y("sed", d);
        if (d === "-")
          a.push(d);
        else if (d.startsWith("-") && d.length > 1) {
          for (let g of d.slice(1))
            if (g !== "n" && g !== "e" && g !== "f" && g !== "i" && g !== "E" && g !== "r")
              return Y("sed", `-${g}`);
          d.includes("n") && (s10 = true), d.includes("i") && (i10 = true), (d.includes("E") || d.includes("r")) && (o10 = true), d.includes("e") && !d.includes("n") && !d.includes("i") && m + 1 < e11.length && n10.push(e11[++m]), d.includes("f") && !d.includes("e") && m + 1 < e11.length && r10.push(e11[++m]);
        } else
          !d.startsWith("-") && n10.length === 0 && r10.length === 0 ? n10.push(d) : d.startsWith("-") || a.push(d);
      }
    }
    for (let m of r10) {
      let d = t10.fs.resolvePath(t10.cwd, m);
      try {
        let g = await t10.fs.readFile(d);
        for (let y of g.split(`
`)) {
          let w = y.trim();
          w && !w.startsWith("#") && n10.push(w);
        }
      } catch {
        return { stdout: "", stderr: `sed: couldn't open file ${m}: No such file or directory
`, exitCode: 1 };
      }
    }
    if (n10.length === 0)
      return { stdout: "", stderr: `sed: no script specified
`, exitCode: 1 };
    let { commands: l, error: c, silentMode: u } = r1(n10, o10);
    if (c)
      return { stdout: "", stderr: `sed: ${c}
`, exitCode: 1 };
    let f10 = !!(s10 || u);
    if (i10) {
      if (a.length === 0)
        return { stdout: "", stderr: `sed: -i requires at least one file argument
`, exitCode: 1 };
      for (let m of a) {
        if (m === "-")
          continue;
        let d = t10.fs.resolvePath(t10.cwd, m);
        try {
          let g = await t10.fs.readFile(d), y = await ua(g, l, f10, { limits: t10.limits, filename: m, fs: t10.fs, cwd: t10.cwd, coverage: t10.coverage });
          if (y.errorMessage)
            return { stdout: "", stderr: `${y.errorMessage}
`, exitCode: y.exitCode ?? 1 };
          await t10.fs.writeFile(d, y.output);
        } catch (g) {
          return g instanceof te ? { stdout: "", stderr: `sed: ${g.message}
`, exitCode: te.EXIT_CODE } : { stdout: "", stderr: `sed: ${m}: No such file or directory
`, exitCode: 1 };
        }
      }
      return { stdout: "", stderr: "", exitCode: 0 };
    }
    let p = "";
    if (a.length === 0) {
      p = t10.stdin;
      try {
        let m = await ua(p, l, f10, { limits: t10.limits, fs: t10.fs, cwd: t10.cwd, coverage: t10.coverage });
        return { stdout: m.output, stderr: m.errorMessage ? `${m.errorMessage}
` : "", exitCode: m.exitCode ?? 0 };
      } catch (m) {
        if (m instanceof te)
          return { stdout: "", stderr: `sed: ${m.message}
`, exitCode: te.EXIT_CODE };
        throw m;
      }
    }
    let h = false;
    for (let m of a) {
      let d;
      if (m === "-")
        h ? d = "" : (d = t10.stdin, h = true);
      else {
        let g = t10.fs.resolvePath(t10.cwd, m);
        try {
          d = await t10.fs.readFile(g);
        } catch (y) {
          return y instanceof te ? { stdout: "", stderr: `sed: ${y.message}
`, exitCode: te.EXIT_CODE } : { stdout: "", stderr: `sed: ${m}: No such file or directory
`, exitCode: 1 };
        }
      }
      p.length > 0 && d.length > 0 && !p.endsWith(`
`) && (p += `
`), p += d;
    }
    try {
      let m = await ua(p, l, f10, { limits: t10.limits, filename: a.length === 1 ? a[0] : void 0, fs: t10.fs, cwd: t10.cwd, coverage: t10.coverage });
      return { stdout: m.output, stderr: m.errorMessage ? `${m.errorMessage}
` : "", exitCode: m.exitCode ?? 0 };
    } catch (m) {
      if (m instanceof te)
        return { stdout: "", stderr: `sed: ${m.message}
`, exitCode: te.EXIT_CODE };
      throw m;
    }
  } }, i3 = { name: "sed", flags: [{ flag: "-n", type: "boolean" }, { flag: "-i", type: "boolean" }, { flag: "-E", type: "boolean" }, { flag: "-r", type: "boolean" }, { flag: "-e", type: "value", valueHint: "string" }], stdinType: "text", needsArgs: true };
});
function xt(e11) {
  return Object.assign(/* @__PURE__ */ Object.create(null), Object.fromEntries(e11));
}
function Jt(e11, t10) {
  return Object.assign(/* @__PURE__ */ Object.create(null), Object.fromEntries(e11), t10);
}
function Js(...e11) {
  return Object.assign(/* @__PURE__ */ Object.create(null), ...e11);
}
var On = I(() => {
  "use strict";
});
function fa(e11 = {}) {
  let { fieldSep: t10 = l3, maxIterations: n10 = o3, maxRecursionDepth: r10 = a3, maxOutputSize: s10 = 0, fs: i10, cwd: o10, exec: a, coverage: l } = e11;
  return { FS: " ", OFS: " ", ORS: `
`, OFMT: "%.6g", NR: 0, NF: 0, FNR: 0, FILENAME: "", RSTART: 0, RLENGTH: -1, SUBSEP: "", fields: [], line: "", vars: /* @__PURE__ */ Object.create(null), arrays: /* @__PURE__ */ Object.create(null), arrayAliases: /* @__PURE__ */ new Map(), ARGC: 0, ARGV: /* @__PURE__ */ Object.create(null), ENVIRON: /* @__PURE__ */ Object.create(null), functions: /* @__PURE__ */ new Map(), fieldSep: t10, maxIterations: n10, maxRecursionDepth: r10, maxOutputSize: s10, currentRecursionDepth: 0, exitCode: 0, shouldExit: false, shouldNext: false, shouldNextFile: false, loopBreak: false, loopContinue: false, hasReturn: false, inEndBlock: false, output: "", openedFiles: /* @__PURE__ */ new Set(), fs: i10, cwd: o10, exec: a, coverage: l };
}
var o3;
var a3;
var l3;
var c1 = I(() => {
  "use strict";
  Fe();
  o3 = 1e4, a3 = 100, l3 = new xn(/\s+/);
});
function u1(e11, t10, n10) {
  switch (n10) {
    case "+":
      return e11 + t10;
    case "-":
      return e11 - t10;
    case "*":
      return e11 * t10;
    case "/":
      return t10 !== 0 ? e11 / t10 : 0;
    case "%":
      return t10 !== 0 ? e11 % t10 : 0;
    case "^":
    case "**":
      return e11 ** t10;
    default:
      return 0;
  }
}
var f1 = I(() => {
  "use strict";
});
function Vt(e11) {
  if (typeof e11 == "number")
    return e11;
  let t10 = parseFloat(e11);
  return Number.isNaN(t10) ? 0 : t10;
}
function lt(e11) {
  return typeof e11 == "string" ? e11 : (Number.isInteger(e11), String(e11));
}
async function ei(e11, t10) {
  if (e11.type === "regex")
    return e11.pattern;
  let n10 = lt(await t10.evalExpr(e11));
  return n10.startsWith("/") && n10.endsWith("/") && (n10 = n10.slice(1, -1)), n10;
}
async function h1(e11, t10) {
  return e11 ? e11.type === "variable" ? e11.name : e11.type === "field" ? `$${Math.floor(Vt(await t10.evalExpr(e11.index)))}` : "$0" : "$0";
}
function d1(e11, t10) {
  if (e11 === "$0")
    return t10.line;
  if (e11.startsWith("$")) {
    let n10 = parseInt(e11.slice(1), 10) - 1;
    return t10.fields[n10] || "";
  }
  return lt(t10.vars[e11] ?? "");
}
function m1(e11, t10, n10) {
  if (e11 === "$0")
    n10.line = t10, n10.fields = n10.FS === " " ? t10.trim().split(/\s+/).filter(Boolean) : n10.fieldSep.split(t10), n10.NF = n10.fields.length;
  else if (e11.startsWith("$")) {
    let r10 = parseInt(e11.slice(1), 10) - 1;
    for (; n10.fields.length <= r10; )
      n10.fields.push("");
    n10.fields[r10] = t10, n10.NF = n10.fields.length, n10.line = n10.fields.join(n10.OFS);
  } else
    n10.vars[e11] = t10;
}
async function c3(e11, t10, n10) {
  return e11.length === 0 ? t10.line.length : lt(await n10.evalExpr(e11[0])).length;
}
async function u3(e11, t10, n10) {
  if (e11.length < 2)
    return "";
  let r10 = lt(await n10.evalExpr(e11[0])), s10 = Math.floor(Vt(await n10.evalExpr(e11[1]))) - 1;
  if (e11.length >= 3) {
    let i10 = Math.floor(Vt(await n10.evalExpr(e11[2])));
    return r10.substr(Math.max(0, s10), i10);
  }
  return r10.substr(Math.max(0, s10));
}
async function f3(e11, t10, n10) {
  if (e11.length < 2)
    return 0;
  let r10 = lt(await n10.evalExpr(e11[0])), s10 = lt(await n10.evalExpr(e11[1])), i10 = r10.indexOf(s10);
  return i10 === -1 ? 0 : i10 + 1;
}
async function p3(e11, t10, n10) {
  if (e11.length < 2)
    return 0;
  let r10 = lt(await n10.evalExpr(e11[0])), s10 = e11[1];
  if (s10.type !== "variable")
    return 0;
  let i10 = s10.name, o10 = t10.FS;
  if (e11.length >= 3) {
    let l = e11[2];
    if (l.type === "regex")
      o10 = V(l.pattern);
    else {
      let c = lt(await n10.evalExpr(l));
      o10 = c === " " ? V("\\s+") : c;
    }
  } else
    t10.FS === " " && (o10 = V("\\s+"));
  let a = typeof o10 == "string" ? r10.split(o10) : o10.split(r10);
  t10.arrays[i10] = /* @__PURE__ */ Object.create(null);
  for (let l = 0; l < a.length; l++)
    t10.arrays[i10][String(l + 1)] = a[l];
  return a.length;
}
async function h3(e11, t10, n10) {
  if (e11.length < 2)
    return 0;
  let r10 = await ei(e11[0], n10), s10 = lt(await n10.evalExpr(e11[1])), i10 = await h1(e11[2], n10), o10 = d1(i10, t10);
  try {
    let l = V(r10).replace(o10, g1(s10)), c = l !== o10 ? 1 : 0;
    return m1(i10, l, t10), c;
  } catch {
    return 0;
  }
}
async function d3(e11, t10, n10) {
  if (e11.length < 2)
    return 0;
  let r10 = await ei(e11[0], n10), s10 = lt(await n10.evalExpr(e11[1])), i10 = await h1(e11[2], n10), o10 = d1(i10, t10);
  try {
    let a = V(r10, "g"), l = a.match(o10), c = l ? l.length : 0, u = a.replace(o10, g1(s10));
    return m1(i10, u, t10), c;
  } catch {
    return 0;
  }
}
function g1(e11) {
  return (t10) => {
    let n10 = "", r10 = 0;
    for (; r10 < e11.length; )
      if (e11[r10] === "\\" && r10 + 1 < e11.length) {
        let s10 = e11[r10 + 1];
        s10 === "&" ? (n10 += "&", r10 += 2) : s10 === "\\" ? (n10 += "\\", r10 += 2) : (n10 += e11[r10 + 1], r10 += 2);
      } else
        e11[r10] === "&" ? (n10 += t10, r10++) : (n10 += e11[r10], r10++);
    return n10;
  };
}
async function m3(e11, t10, n10) {
  if (e11.length < 2)
    return t10.RSTART = 0, t10.RLENGTH = -1, 0;
  let r10 = lt(await n10.evalExpr(e11[0])), s10 = await ei(e11[1], n10);
  try {
    let o10 = V(s10).exec(r10);
    if (o10)
      return t10.RSTART = o10.index + 1, t10.RLENGTH = o10[0].length, t10.RSTART;
  } catch {
  }
  return t10.RSTART = 0, t10.RLENGTH = -1, 0;
}
async function g3(e11, t10, n10) {
  if (e11.length < 3)
    return "";
  let r10 = await ei(e11[0], n10), s10 = lt(await n10.evalExpr(e11[1])), i10 = lt(await n10.evalExpr(e11[2])), o10 = e11.length >= 4 ? lt(await n10.evalExpr(e11[3])) : t10.line;
  try {
    let a = i10.toLowerCase() === "g", l = a ? 0 : parseInt(i10, 10) || 1;
    if (a)
      return V(r10, "g").replace(o10, (u, ...f10) => p1(s10, u, f10.slice(0, -2)));
    {
      let c = 0;
      return V(r10, "g").replace(o10, (f10, ...p) => (c++, c === l ? p1(s10, f10, p.slice(0, -2)) : f10));
    }
  } catch {
    return o10;
  }
}
function p1(e11, t10, n10) {
  let r10 = "", s10 = 0;
  for (; s10 < e11.length; )
    if (e11[s10] === "\\" && s10 + 1 < e11.length) {
      let i10 = e11[s10 + 1];
      if (i10 === "&")
        r10 += "&", s10 += 2;
      else if (i10 === "0")
        r10 += t10, s10 += 2;
      else if (i10 >= "1" && i10 <= "9") {
        let o10 = parseInt(i10, 10) - 1;
        r10 += n10[o10] || "", s10 += 2;
      } else
        i10 === "n" ? (r10 += `
`, s10 += 2) : i10 === "t" ? (r10 += "	", s10 += 2) : (r10 += i10, s10 += 2);
    } else
      e11[s10] === "&" ? (r10 += t10, s10++) : (r10 += e11[s10], s10++);
  return r10;
}
async function y3(e11, t10, n10) {
  return e11.length === 0 ? "" : lt(await n10.evalExpr(e11[0])).toLowerCase();
}
async function w3(e11, t10, n10) {
  return e11.length === 0 ? "" : lt(await n10.evalExpr(e11[0])).toUpperCase();
}
async function b3(e11, t10, n10) {
  if (e11.length === 0)
    return "";
  let r10 = lt(await n10.evalExpr(e11[0])), s10 = [];
  for (let i10 = 1; i10 < e11.length; i10++)
    s10.push(await n10.evalExpr(e11[i10]));
  return ti(r10, s10);
}
async function x3(e11, t10, n10) {
  return e11.length === 0 ? 0 : Math.floor(Vt(await n10.evalExpr(e11[0])));
}
async function E3(e11, t10, n10) {
  return e11.length === 0 ? 0 : Math.sqrt(Vt(await n10.evalExpr(e11[0])));
}
async function A3(e11, t10, n10) {
  return e11.length === 0 ? 0 : Math.sin(Vt(await n10.evalExpr(e11[0])));
}
async function S3(e11, t10, n10) {
  return e11.length === 0 ? 0 : Math.cos(Vt(await n10.evalExpr(e11[0])));
}
async function C3(e11, t10, n10) {
  let r10 = e11.length > 0 ? Vt(await n10.evalExpr(e11[0])) : 0, s10 = e11.length > 1 ? Vt(await n10.evalExpr(e11[1])) : 0;
  return Math.atan2(r10, s10);
}
async function N3(e11, t10, n10) {
  return e11.length === 0 ? 0 : Math.log(Vt(await n10.evalExpr(e11[0])));
}
async function k3(e11, t10, n10) {
  return e11.length === 0 ? 1 : Math.exp(Vt(await n10.evalExpr(e11[0])));
}
function v3(e11, t10, n10) {
  return t10.random ? t10.random() : Math.random();
}
async function I3(e11, t10, n10) {
  let r10 = e11.length > 0 ? Vt(await n10.evalExpr(e11[0])) : Date.now();
  return t10.vars._srand_seed = r10, r10;
}
function O3(e11, t10) {
  return () => {
    throw new Error(`${e11}() is not supported - ${t10}`);
  };
}
function pa(e11) {
  return () => {
    throw new Error(`function '${e11}()' is not implemented`);
  };
}
function ti(e11, t10) {
  let n10 = 0, r10 = "", s10 = 0;
  for (; s10 < e11.length; )
    if (e11[s10] === "%" && s10 + 1 < e11.length) {
      let i10 = s10 + 1, o10 = "", a = "", l = "", c, u = i10;
      for (; i10 < e11.length && /\d/.test(e11[i10]); )
        i10++;
      i10 > u && e11[i10] === "$" ? (c = parseInt(e11.substring(u, i10), 10) - 1, i10++) : i10 = u;
      let f10 = () => {
        if (i10 < e11.length) {
          if (i10 + 1 < e11.length && (e11[i10] === "h" && e11[i10 + 1] === "h" || e11[i10] === "l" && e11[i10 + 1] === "l")) {
            i10 += 2;
            return;
          }
          /[lzjh]/.test(e11[i10]) && i10++;
        }
      };
      for (; i10 < e11.length && /[-+ #0]/.test(e11[i10]); )
        o10 += e11[i10++];
      if (e11[i10] === "*") {
        let d = t10[n10++], g = d !== void 0 ? Math.floor(Number(d)) : 0;
        g < 0 ? (o10 += "-", a = String(Math.min(-g, Gn))) : a = String(Math.min(g, Gn)), i10++;
      } else
        for (; i10 < e11.length && /\d/.test(e11[i10]); )
          a += e11[i10++];
      if (a && parseInt(a, 10) > Gn && (a = String(Gn)), e11[i10] === ".") {
        if (i10++, e11[i10] === "*") {
          let d = t10[n10++];
          l = String(Math.min(d !== void 0 ? Math.floor(Number(d)) : 0, Gn)), i10++;
        } else
          for (; i10 < e11.length && /\d/.test(e11[i10]); )
            l += e11[i10++];
        l && parseInt(l, 10) > Gn && (l = String(Gn));
      }
      f10();
      let p = e11[i10], m = t10[c !== void 0 ? c : n10];
      switch (p) {
        case "s": {
          let d = m !== void 0 ? String(m) : "";
          if (l && (d = d.substring(0, parseInt(l, 10))), a) {
            let g = parseInt(a, 10);
            o10.includes("-") ? d = d.padEnd(g) : d = d.padStart(g);
          }
          r10 += d, c === void 0 && n10++;
          break;
        }
        case "d":
        case "i": {
          let d = m !== void 0 ? Math.floor(Number(m)) : 0;
          Number.isNaN(d) && (d = 0);
          let g = d < 0, y = Math.abs(d).toString();
          if (l) {
            let x = parseInt(l, 10);
            y = y.padStart(x, "0");
          }
          let w = "";
          g ? w = "-" : o10.includes("+") ? w = "+" : o10.includes(" ") && (w = " ");
          let b = w + y;
          if (a) {
            let x = parseInt(a, 10);
            o10.includes("-") ? b = b.padEnd(x) : o10.includes("0") && !l ? b = w + y.padStart(x - w.length, "0") : b = b.padStart(x);
          }
          r10 += b, c === void 0 && n10++;
          break;
        }
        case "f": {
          let d = m !== void 0 ? Number(m) : 0;
          Number.isNaN(d) && (d = 0);
          let g = l ? parseInt(l, 10) : 6, y = d.toFixed(g);
          if (a) {
            let w = parseInt(a, 10);
            o10.includes("-") ? y = y.padEnd(w) : y = y.padStart(w);
          }
          r10 += y, c === void 0 && n10++;
          break;
        }
        case "e":
        case "E": {
          let d = m !== void 0 ? Number(m) : 0;
          Number.isNaN(d) && (d = 0);
          let g = l ? parseInt(l, 10) : 6, y = d.toExponential(g);
          if (p === "E" && (y = y.toUpperCase()), a) {
            let w = parseInt(a, 10);
            o10.includes("-") ? y = y.padEnd(w) : y = y.padStart(w);
          }
          r10 += y, c === void 0 && n10++;
          break;
        }
        case "g":
        case "G": {
          let d = m !== void 0 ? Number(m) : 0;
          Number.isNaN(d) && (d = 0);
          let g = l ? parseInt(l, 10) : 6, y = d !== 0 ? Math.floor(Math.log10(Math.abs(d))) : 0, w;
          if (d === 0 ? w = "0" : y < -4 || y >= g ? (w = d.toExponential(g - 1), p === "G" && (w = w.toUpperCase())) : w = d.toPrecision(g), w.includes(".") && (w = w.replace(/\.?0+$/, "").replace(/\.?0+e/, "e")), w.includes("e") && (w = w.replace(/\.?0+e/, "e")), a) {
            let b = parseInt(a, 10);
            o10.includes("-") ? w = w.padEnd(b) : w = w.padStart(b);
          }
          r10 += w, c === void 0 && n10++;
          break;
        }
        case "x":
        case "X": {
          let d = m !== void 0 ? Math.floor(Number(m)) : 0;
          Number.isNaN(d) && (d = 0);
          let g = Math.abs(d).toString(16);
          if (p === "X" && (g = g.toUpperCase()), l) {
            let b = parseInt(l, 10);
            g = g.padStart(b, "0");
          }
          let y = d < 0 ? "-" : "", w = y + g;
          if (a) {
            let b = parseInt(a, 10);
            o10.includes("-") ? w = w.padEnd(b) : o10.includes("0") && !l ? w = y + g.padStart(b - y.length, "0") : w = w.padStart(b);
          }
          r10 += w, c === void 0 && n10++;
          break;
        }
        case "o": {
          let d = m !== void 0 ? Math.floor(Number(m)) : 0;
          Number.isNaN(d) && (d = 0);
          let g = Math.abs(d).toString(8);
          if (l) {
            let b = parseInt(l, 10);
            g = g.padStart(b, "0");
          }
          let y = d < 0 ? "-" : "", w = y + g;
          if (a) {
            let b = parseInt(a, 10);
            o10.includes("-") ? w = w.padEnd(b) : o10.includes("0") && !l ? w = y + g.padStart(b - y.length, "0") : w = w.padStart(b);
          }
          r10 += w, c === void 0 && n10++;
          break;
        }
        case "c": {
          typeof m == "number" ? r10 += String.fromCharCode(m) : r10 += String(m ?? "").charAt(0) || "", c === void 0 && n10++;
          break;
        }
        case "%":
          r10 += "%";
          break;
        default:
          r10 += e11.substring(s10, i10 + 1);
      }
      s10 = i10 + 1;
    } else if (e11[s10] === "\\" && s10 + 1 < e11.length) {
      let i10 = e11[s10 + 1];
      switch (i10) {
        case "n":
          r10 += `
`;
          break;
        case "t":
          r10 += "	";
          break;
        case "r":
          r10 += "\r";
          break;
        case "\\":
          r10 += "\\";
          break;
        default:
          r10 += i10;
      }
      s10 += 2;
    } else
      r10 += e11[s10++];
  return r10;
}
var Gn;
var y1;
var ha = I(() => {
  "use strict";
  Fe();
  Gn = 1e4;
  y1 = /* @__PURE__ */ new Map([["length", c3], ["substr", u3], ["index", f3], ["split", p3], ["sub", h3], ["gsub", d3], ["match", m3], ["gensub", g3], ["tolower", y3], ["toupper", w3], ["sprintf", b3], ["int", x3], ["sqrt", E3], ["sin", A3], ["cos", S3], ["atan2", C3], ["log", N3], ["exp", k3], ["rand", v3], ["srand", I3], ["system", O3("system", "shell execution not allowed in sandboxed environment")], ["close", () => 0], ["fflush", () => 0], ["systime", pa("systime")], ["mktime", pa("mktime")], ["strftime", pa("strftime")]]);
});
function Et(e11) {
  return typeof e11 == "number" ? e11 !== 0 : !(e11 === "" || e11 === "0");
}
function ze(e11) {
  if (typeof e11 == "number")
    return e11;
  let t10 = parseFloat(e11);
  return Number.isNaN(t10) ? 0 : t10;
}
function Oe(e11) {
  return typeof e11 == "string" ? e11 : (Number.isInteger(e11), String(e11));
}
function da(e11) {
  if (typeof e11 == "number")
    return true;
  let t10 = String(e11).trim();
  return t10 === "" ? false : !Number.isNaN(Number(t10));
}
function ts(e11, t10) {
  try {
    return V(e11).test(t10);
  } catch {
    return false;
  }
}
var yr = I(() => {
  "use strict";
  Fe();
});
function w1(e11, t10) {
  return t10 === "" ? [] : e11.FS === " " ? t10.trim().split(/\s+/).filter(Boolean) : e11.fieldSep.split(t10);
}
function ni(e11, t10) {
  return t10 === 0 ? e11.line : t10 < 0 || t10 > e11.fields.length ? "" : e11.fields[t10 - 1] ?? "";
}
function ma(e11, t10, n10) {
  if (t10 === 0)
    e11.line = Oe(n10), e11.fields = w1(e11, e11.line), e11.NF = e11.fields.length;
  else if (t10 > 0) {
    for (; e11.fields.length < t10; )
      e11.fields.push("");
    e11.fields[t10 - 1] = Oe(n10), e11.NF = e11.fields.length, e11.line = e11.fields.join(e11.OFS);
  }
}
function wr(e11, t10) {
  e11.line = t10, e11.fields = w1(e11, t10), e11.NF = e11.fields.length;
}
function b1(e11, t10) {
  if (e11.FS = t10, t10 === " ")
    e11.fieldSep = new xn(/\s+/);
  else
    try {
      e11.fieldSep = V(t10);
    } catch {
      e11.fieldSep = V(t10.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
    }
}
var ri = I(() => {
  "use strict";
  Fe();
  yr();
});
function si(e11, t10) {
  switch (t10) {
    case "FS":
      return e11.FS;
    case "OFS":
      return e11.OFS;
    case "ORS":
      return e11.ORS;
    case "OFMT":
      return e11.OFMT;
    case "NR":
      return e11.NR;
    case "NF":
      return e11.NF;
    case "FNR":
      return e11.FNR;
    case "FILENAME":
      return e11.FILENAME;
    case "RSTART":
      return e11.RSTART;
    case "RLENGTH":
      return e11.RLENGTH;
    case "SUBSEP":
      return e11.SUBSEP;
    case "ARGC":
      return e11.ARGC;
  }
  return e11.vars[t10] ?? "";
}
function br(e11, t10, n10) {
  switch (t10) {
    case "FS":
      b1(e11, Oe(n10));
      return;
    case "OFS":
      e11.OFS = Oe(n10);
      return;
    case "ORS":
      e11.ORS = Oe(n10);
      return;
    case "OFMT":
      e11.OFMT = Oe(n10);
      return;
    case "NR":
      e11.NR = Math.floor(ze(n10));
      return;
    case "NF": {
      let r10 = Math.floor(ze(n10));
      if (r10 < e11.NF)
        e11.fields = e11.fields.slice(0, r10), e11.line = e11.fields.join(e11.OFS);
      else if (r10 > e11.NF) {
        for (; e11.fields.length < r10; )
          e11.fields.push("");
        e11.line = e11.fields.join(e11.OFS);
      }
      e11.NF = r10;
      return;
    }
    case "FNR":
      e11.FNR = Math.floor(ze(n10));
      return;
    case "FILENAME":
      e11.FILENAME = Oe(n10);
      return;
    case "RSTART":
      e11.RSTART = Math.floor(ze(n10));
      return;
    case "RLENGTH":
      e11.RLENGTH = Math.floor(ze(n10));
      return;
    case "SUBSEP":
      e11.SUBSEP = Oe(n10);
      return;
  }
  e11.vars[t10] = n10;
}
function ns(e11, t10) {
  let n10 = t10, r10 = /* @__PURE__ */ new Set(), s10 = e11.arrayAliases.get(n10);
  for (; s10 !== void 0 && !r10.has(n10); )
    r10.add(n10), n10 = s10, s10 = e11.arrayAliases.get(n10);
  return n10;
}
function ii(e11, t10, n10) {
  if (t10 === "ARGV")
    return e11.ARGV[n10] ?? "";
  if (t10 === "ENVIRON")
    return e11.ENVIRON[n10] ?? "";
  let r10 = ns(e11, t10);
  return e11.arrays[r10]?.[n10] ?? "";
}
function ga(e11, t10, n10, r10) {
  let s10 = ns(e11, t10);
  e11.arrays[s10] || (e11.arrays[s10] = /* @__PURE__ */ Object.create(null)), e11.arrays[s10][n10] = r10;
}
function x1(e11, t10, n10) {
  if (t10 === "ARGV")
    return e11.ARGV[n10] !== void 0;
  if (t10 === "ENVIRON")
    return e11.ENVIRON[n10] !== void 0;
  let r10 = ns(e11, t10);
  return e11.arrays[r10]?.[n10] !== void 0;
}
function E1(e11, t10, n10) {
  let r10 = ns(e11, t10);
  e11.arrays[r10] && delete e11.arrays[r10][n10];
}
function A1(e11, t10) {
  let n10 = ns(e11, t10);
  delete e11.arrays[n10];
}
var ya = I(() => {
  "use strict";
  ri();
  yr();
});
function S1(e11) {
  wa = e11;
}
async function le(e11, t10) {
  switch (e11.coverage?.hit(`awk:expr:${t10.type}`), t10.type) {
    case "number":
      return t10.value;
    case "string":
      return t10.value;
    case "regex":
      return ts(t10.pattern, e11.line) ? 1 : 0;
    case "field":
      return R3(e11, t10);
    case "variable":
      return si(e11, t10.name);
    case "array_access":
      return $3(e11, t10);
    case "binary":
      return T3(e11, t10);
    case "unary":
      return _3(e11, t10);
    case "ternary":
      return Et(await le(e11, t10.condition)) ? await le(e11, t10.consequent) : await le(e11, t10.alternate);
    case "call":
      return L3(e11, t10.name, t10.args);
    case "assignment":
      return M3(e11, t10);
    case "pre_increment":
      return U3(e11, t10.operand);
    case "pre_decrement":
      return W3(e11, t10.operand);
    case "post_increment":
      return B3(e11, t10.operand);
    case "post_decrement":
      return z3(e11, t10.operand);
    case "in":
      return H3(e11, t10.key, t10.array);
    case "getline":
      return j3(e11, t10.variable, t10.file, t10.command);
    case "tuple":
      return q3(e11, t10.elements);
    default:
      return "";
  }
}
async function R3(e11, t10) {
  let n10 = Math.floor(ze(await le(e11, t10.index)));
  return ni(e11, n10);
}
async function $3(e11, t10) {
  let n10 = Oe(await le(e11, t10.key));
  return ii(e11, t10.array, n10);
}
async function T3(e11, t10) {
  let n10 = t10.operator;
  if (n10 === "||")
    return Et(await le(e11, t10.left)) || Et(await le(e11, t10.right)) ? 1 : 0;
  if (n10 === "&&")
    return Et(await le(e11, t10.left)) && Et(await le(e11, t10.right)) ? 1 : 0;
  if (n10 === "~") {
    let a = await le(e11, t10.left);
    t10.right.type === "regex" && e11.coverage?.hit("awk:expr:regex");
    let l = t10.right.type === "regex" ? t10.right.pattern : Oe(await le(e11, t10.right));
    try {
      return V(l).test(Oe(a)) ? 1 : 0;
    } catch {
      return 0;
    }
  }
  if (n10 === "!~") {
    let a = await le(e11, t10.left);
    t10.right.type === "regex" && e11.coverage?.hit("awk:expr:regex");
    let l = t10.right.type === "regex" ? t10.right.pattern : Oe(await le(e11, t10.right));
    try {
      return V(l).test(Oe(a)) ? 0 : 1;
    } catch {
      return 1;
    }
  }
  let r10 = await le(e11, t10.left), s10 = await le(e11, t10.right);
  if (n10 === " ") {
    let a = Oe(r10) + Oe(s10);
    if (e11.maxOutputSize > 0 && a.length > e11.maxOutputSize)
      throw new te(`awk: string concatenation size limit exceeded (${e11.maxOutputSize} bytes)`, "string_length", e11.output);
    return a;
  }
  if (P3(n10))
    return D3(r10, s10, n10);
  let i10 = ze(r10), o10 = ze(s10);
  return u1(i10, o10, n10);
}
function P3(e11) {
  return ["<", "<=", ">", ">=", "==", "!="].includes(e11);
}
function D3(e11, t10, n10) {
  let r10 = da(e11), s10 = da(t10);
  if (r10 && s10) {
    let a = ze(e11), l = ze(t10);
    switch (n10) {
      case "<":
        return a < l ? 1 : 0;
      case "<=":
        return a <= l ? 1 : 0;
      case ">":
        return a > l ? 1 : 0;
      case ">=":
        return a >= l ? 1 : 0;
      case "==":
        return a === l ? 1 : 0;
      case "!=":
        return a !== l ? 1 : 0;
    }
  }
  let i10 = Oe(e11), o10 = Oe(t10);
  switch (n10) {
    case "<":
      return i10 < o10 ? 1 : 0;
    case "<=":
      return i10 <= o10 ? 1 : 0;
    case ">":
      return i10 > o10 ? 1 : 0;
    case ">=":
      return i10 >= o10 ? 1 : 0;
    case "==":
      return i10 === o10 ? 1 : 0;
    case "!=":
      return i10 !== o10 ? 1 : 0;
  }
  return 0;
}
async function _3(e11, t10) {
  let n10 = await le(e11, t10.operand);
  switch (t10.operator) {
    case "!":
      return Et(n10) ? 0 : 1;
    case "-":
      return -ze(n10);
    case "+":
      return +ze(n10);
    default:
      return n10;
  }
}
async function L3(e11, t10, n10) {
  let r10 = y1.get(t10);
  if (r10)
    return r10(n10, e11, { evalExpr: (i10) => le(e11, i10) });
  let s10 = e11.functions.get(t10);
  return s10 ? F3(e11, s10, n10) : "";
}
async function F3(e11, t10, n10) {
  if (e11.currentRecursionDepth++, e11.currentRecursionDepth > e11.maxRecursionDepth)
    throw e11.currentRecursionDepth--, new te(`awk: recursion depth exceeded maximum (${e11.maxRecursionDepth})`, "recursion", e11.output);
  let r10 = /* @__PURE__ */ Object.create(null);
  for (let o10 of t10.params)
    r10[o10] = e11.vars[o10];
  let s10 = [];
  for (let o10 = 0; o10 < t10.params.length; o10++) {
    let a = t10.params[o10];
    if (o10 < n10.length) {
      let l = n10[o10];
      l.type === "variable" && (e11.arrayAliases.set(a, l.name), s10.push(a));
      let c = await le(e11, l);
      e11.vars[a] = c;
    } else
      e11.vars[a] = "";
  }
  e11.hasReturn = false, e11.returnValue = void 0, wa && await wa(e11, t10.body.statements);
  let i10 = e11.returnValue ?? "";
  for (let o10 of t10.params)
    r10[o10] !== void 0 ? e11.vars[o10] = r10[o10] : delete e11.vars[o10];
  for (let o10 of s10)
    e11.arrayAliases.delete(o10);
  return e11.hasReturn = false, e11.returnValue = void 0, e11.currentRecursionDepth--, i10;
}
async function M3(e11, t10) {
  let n10 = await le(e11, t10.value), r10 = t10.target, s10 = t10.operator, i10;
  if (s10 === "=")
    i10 = n10;
  else {
    let o10;
    if (r10.type === "field") {
      let c = Math.floor(ze(await le(e11, r10.index)));
      o10 = ni(e11, c);
    } else if (r10.type === "variable")
      o10 = si(e11, r10.name);
    else {
      let c = Oe(await le(e11, r10.key));
      o10 = ii(e11, r10.array, c);
    }
    let a = ze(o10), l = ze(n10);
    switch (s10) {
      case "+=":
        i10 = a + l;
        break;
      case "-=":
        i10 = a - l;
        break;
      case "*=":
        i10 = a * l;
        break;
      case "/=":
        i10 = l !== 0 ? a / l : 0;
        break;
      case "%=":
        i10 = l !== 0 ? a % l : 0;
        break;
      case "^=":
        i10 = a ** l;
        break;
      default:
        i10 = n10;
    }
  }
  if (r10.type === "field") {
    let o10 = Math.floor(ze(await le(e11, r10.index)));
    ma(e11, o10, i10);
  } else if (r10.type === "variable")
    br(e11, r10.name, i10);
  else {
    let o10 = Oe(await le(e11, r10.key));
    ga(e11, r10.array, o10, i10);
  }
  return i10;
}
async function oi(e11, t10, n10, r10) {
  let s10;
  if (t10.type === "field") {
    let i10 = Math.floor(ze(await le(e11, t10.index)));
    s10 = ze(ni(e11, i10)), ma(e11, i10, s10 + n10);
  } else if (t10.type === "variable")
    s10 = ze(si(e11, t10.name)), br(e11, t10.name, s10 + n10);
  else {
    let i10 = Oe(await le(e11, t10.key));
    s10 = ze(ii(e11, t10.array, i10)), ga(e11, t10.array, i10, s10 + n10);
  }
  return r10 ? s10 + n10 : s10;
}
async function U3(e11, t10) {
  return oi(e11, t10, 1, true);
}
async function W3(e11, t10) {
  return oi(e11, t10, -1, true);
}
async function B3(e11, t10) {
  return oi(e11, t10, 1, false);
}
async function z3(e11, t10) {
  return oi(e11, t10, -1, false);
}
async function H3(e11, t10, n10) {
  let r10;
  if (t10.type === "tuple") {
    e11.coverage?.hit("awk:expr:tuple");
    let s10 = [];
    for (let i10 of t10.elements)
      s10.push(Oe(await le(e11, i10)));
    r10 = s10.join(e11.SUBSEP);
  } else
    r10 = Oe(await le(e11, t10));
  return x1(e11, n10, r10) ? 1 : 0;
}
async function j3(e11, t10, n10, r10) {
  if (r10)
    return G3(e11, t10, r10);
  if (n10)
    return V3(e11, t10, n10);
  if (!e11.lines || e11.lineIndex === void 0)
    return -1;
  let s10 = e11.lineIndex + 1;
  if (s10 >= e11.lines.length)
    return 0;
  let i10 = e11.lines[s10];
  return t10 ? br(e11, t10, i10) : wr(e11, i10), e11.NR++, e11.lineIndex = s10, 1;
}
async function G3(e11, t10, n10) {
  if (!e11.exec)
    return -1;
  let r10 = Oe(await le(e11, n10)), s10 = `__cmd_${r10}`, i10 = `__cmdi_${r10}`, o10, a;
  if (e11.vars[s10] === void 0)
    try {
      o10 = (await e11.exec(r10)).stdout.split(`
`), o10.length > 0 && o10[o10.length - 1] === "" && o10.pop(), e11.vars[s10] = JSON.stringify(o10), e11.vars[i10] = -1, a = -1;
    } catch {
      return -1;
    }
  else
    o10 = JSON.parse(e11.vars[s10]), a = e11.vars[i10];
  let l = a + 1;
  if (l >= o10.length)
    return 0;
  let c = o10[l];
  return e11.vars[i10] = l, t10 ? br(e11, t10, c) : wr(e11, c), 1;
}
async function V3(e11, t10, n10) {
  if (!e11.fs || !e11.cwd)
    return -1;
  let r10 = Oe(await le(e11, n10));
  if (r10 === "/dev/null")
    return 0;
  let s10 = e11.fs.resolvePath(e11.cwd, r10), i10 = `__fc_${s10}`, o10 = `__fi_${s10}`, a, l;
  if (e11.vars[i10] === void 0)
    try {
      a = (await e11.fs.readFile(s10)).split(`
`), a.length > 0 && a[a.length - 1] === "" && a.pop(), e11.vars[i10] = JSON.stringify(a), e11.vars[o10] = -1, l = -1;
    } catch {
      return -1;
    }
  else
    a = JSON.parse(e11.vars[i10]), l = e11.vars[o10];
  let c = l + 1;
  if (c >= a.length)
    return 0;
  let u = a[c];
  return e11.vars[o10] = c, t10 ? br(e11, t10, u) : wr(e11, u), 1;
}
async function q3(e11, t10) {
  if (t10.length === 0)
    return "";
  for (let n10 = 0; n10 < t10.length - 1; n10++)
    await le(e11, t10[n10]);
  return le(e11, t10[t10.length - 1]);
}
var wa;
var ba = I(() => {
  "use strict";
  ye();
  Fe();
  f1();
  ha();
  ri();
  yr();
  ya();
  wa = null;
});
function xa(e11) {
  if (e11.maxOutputSize > 0 && e11.output.length > e11.maxOutputSize)
    throw new te(`awk: output size limit exceeded (${e11.maxOutputSize} bytes)`, "string_length", e11.output);
}
async function xr(e11, t10) {
  for (let n10 of t10)
    if (await Vn(e11, n10), Z3(e11))
      break;
}
function Z3(e11) {
  return e11.shouldExit || e11.shouldNext || e11.shouldNextFile || e11.loopBreak || e11.loopContinue || e11.hasReturn;
}
async function Vn(e11, t10) {
  switch (e11.coverage?.hit(`awk:stmt:${t10.type}`), t10.type) {
    case "block":
      await xr(e11, t10.statements);
      break;
    case "expr_stmt":
      await le(e11, t10.expression);
      break;
    case "print":
      await Q3(e11, t10.args, t10.output);
      break;
    case "printf":
      await K3(e11, t10.format, t10.args, t10.output);
      break;
    case "if":
      await X3(e11, t10);
      break;
    case "while":
      await Y3(e11, t10);
      break;
    case "do_while":
      await J3(e11, t10);
      break;
    case "for":
      await ey(e11, t10);
      break;
    case "for_in":
      await ty(e11, t10);
      break;
    case "break":
      e11.loopBreak = true;
      break;
    case "continue":
      e11.loopContinue = true;
      break;
    case "next":
      e11.shouldNext = true;
      break;
    case "nextfile":
      e11.shouldNextFile = true;
      break;
    case "exit":
      e11.shouldExit = true, e11.exitCode = t10.code ? Math.floor(ze(await le(e11, t10.code))) : 0;
      break;
    case "return":
      e11.hasReturn = true, e11.returnValue = t10.value ? await le(e11, t10.value) : "";
      break;
    case "delete":
      await ny(e11, t10.target);
      break;
  }
}
async function Q3(e11, t10, n10) {
  let r10 = [];
  for (let i10 of t10) {
    let o10 = await le(e11, i10);
    typeof o10 == "number" ? Number.isInteger(o10) && Math.abs(o10) < Number.MAX_SAFE_INTEGER ? r10.push(String(o10)) : r10.push(ti(e11.OFMT, [o10])) : r10.push(Oe(o10));
  }
  let s10 = r10.join(e11.OFS) + e11.ORS;
  n10 ? await C1(e11, n10.redirect, n10.file, s10) : (e11.output += s10, xa(e11));
}
async function K3(e11, t10, n10, r10) {
  let s10 = Oe(await le(e11, t10)), i10 = [];
  for (let a of n10)
    i10.push(await le(e11, a));
  let o10 = ti(s10, i10);
  r10 ? await C1(e11, r10.redirect, r10.file, o10) : (e11.output += o10, xa(e11));
}
async function C1(e11, t10, n10, r10) {
  if (!e11.fs || !e11.cwd) {
    e11.output += r10, xa(e11);
    return;
  }
  let s10 = Oe(await le(e11, n10)), i10 = e11.fs.resolvePath(e11.cwd, s10);
  t10 === ">" ? e11.openedFiles.has(i10) ? await e11.fs.appendFile(i10, r10) : (await e11.fs.writeFile(i10, r10), e11.openedFiles.add(i10)) : (e11.openedFiles.has(i10) || e11.openedFiles.add(i10), await e11.fs.appendFile(i10, r10));
}
async function X3(e11, t10) {
  Et(await le(e11, t10.condition)) ? await Vn(e11, t10.consequent) : t10.alternate && await Vn(e11, t10.alternate);
}
async function Y3(e11, t10) {
  let n10 = 0;
  for (; Et(await le(e11, t10.condition)); ) {
    if (n10++, n10 > e11.maxIterations)
      throw new te(`awk: while loop exceeded maximum iterations (${e11.maxIterations})`, "iterations", e11.output);
    if (e11.loopContinue = false, await Vn(e11, t10.body), e11.loopBreak) {
      e11.loopBreak = false;
      break;
    }
    if (e11.shouldExit || e11.shouldNext || e11.hasReturn)
      break;
  }
}
async function J3(e11, t10) {
  let n10 = 0;
  do {
    if (n10++, n10 > e11.maxIterations)
      throw new te(`awk: do-while loop exceeded maximum iterations (${e11.maxIterations})`, "iterations", e11.output);
    if (e11.loopContinue = false, await Vn(e11, t10.body), e11.loopBreak) {
      e11.loopBreak = false;
      break;
    }
    if (e11.shouldExit || e11.shouldNext || e11.hasReturn)
      break;
  } while (Et(await le(e11, t10.condition)));
}
async function ey(e11, t10) {
  t10.init && await le(e11, t10.init);
  let n10 = 0;
  for (; !t10.condition || Et(await le(e11, t10.condition)); ) {
    if (n10++, n10 > e11.maxIterations)
      throw new te(`awk: for loop exceeded maximum iterations (${e11.maxIterations})`, "iterations", e11.output);
    if (e11.loopContinue = false, await Vn(e11, t10.body), e11.loopBreak) {
      e11.loopBreak = false;
      break;
    }
    if (e11.shouldExit || e11.shouldNext || e11.hasReturn)
      break;
    t10.update && await le(e11, t10.update);
  }
}
async function ty(e11, t10) {
  let n10 = e11.arrays[t10.array];
  if (n10)
    for (let r10 of Object.keys(n10)) {
      if (e11.vars[t10.variable] = r10, e11.loopContinue = false, await Vn(e11, t10.body), e11.loopBreak) {
        e11.loopBreak = false;
        break;
      }
      if (e11.shouldExit || e11.shouldNext || e11.hasReturn)
        break;
    }
}
async function ny(e11, t10) {
  if (t10.type === "array_access") {
    let n10 = Oe(await le(e11, t10.key));
    E1(e11, t10.array, n10);
  } else
    t10.type === "variable" && A1(e11, t10.name);
}
var N1 = I(() => {
  "use strict";
  ye();
  ha();
  ba();
  yr();
  ya();
  S1(xr);
});
var rs;
var k1 = I(() => {
  "use strict";
  ba();
  ri();
  N1();
  yr();
  rs = class {
    ctx;
    program = null;
    rangeStates = [];
    constructor(t10) {
      this.ctx = t10;
    }
    execute(t10) {
      this.program = t10, this.ctx.output = "";
      for (let n10 of t10.functions)
        this.ctx.functions.set(n10.name, n10);
      this.rangeStates = t10.rules.map(() => false);
    }
    async executeBegin() {
      if (this.program) {
        for (let t10 of this.program.rules)
          if (t10.pattern?.type === "begin" && (await xr(this.ctx, t10.action.statements), this.ctx.shouldExit))
            break;
      }
    }
    async executeLine(t10) {
      if (!(!this.program || this.ctx.shouldExit)) {
        wr(this.ctx, t10), this.ctx.NR++, this.ctx.FNR++, this.ctx.shouldNext = false;
        for (let n10 = 0; n10 < this.program.rules.length && !(this.ctx.shouldExit || this.ctx.shouldNext || this.ctx.shouldNextFile); n10++) {
          let r10 = this.program.rules[n10];
          r10.pattern?.type === "begin" || r10.pattern?.type === "end" || await this.matchesRule(r10, n10) && await xr(this.ctx, r10.action.statements);
        }
      }
    }
    async executeEnd() {
      if (this.program && !this.ctx.inEndBlock) {
        this.ctx.inEndBlock = true, this.ctx.shouldExit = false;
        for (let t10 of this.program.rules)
          if (t10.pattern?.type === "end" && (await xr(this.ctx, t10.action.statements), this.ctx.shouldExit))
            break;
        this.ctx.inEndBlock = false;
      }
    }
    getOutput() {
      return this.ctx.output;
    }
    getExitCode() {
      return this.ctx.exitCode;
    }
    getContext() {
      return this.ctx;
    }
    async matchesRule(t10, n10) {
      let r10 = t10.pattern;
      if (!r10)
        return true;
      switch (r10.type) {
        case "begin":
        case "end":
          return false;
        case "regex_pattern":
          return ts(r10.pattern, this.ctx.line);
        case "expr_pattern":
          return Et(await le(this.ctx, r10.expression));
        case "range": {
          let s10 = await this.matchPattern(r10.start), i10 = await this.matchPattern(r10.end);
          return this.rangeStates[n10] ? (i10 && (this.rangeStates[n10] = false), true) : s10 ? (this.rangeStates[n10] = true, i10 && (this.rangeStates[n10] = false), true) : false;
        }
        default:
          return false;
      }
    }
    async matchPattern(t10) {
      switch (t10.type) {
        case "regex_pattern":
          return ts(t10.pattern, this.ctx.line);
        case "expr_pattern":
          return Et(await le(this.ctx, t10.expression));
        default:
          return false;
      }
    }
  };
});
var v1 = I(() => {
  "use strict";
  c1();
  k1();
});
function sy(e11) {
  return e11.replace(/\[\[:space:\]\]/g, "[ \\t\\n\\r\\f\\v]").replace(/\[\[:blank:\]\]/g, "[ \\t]").replace(/\[\[:alpha:\]\]/g, "[a-zA-Z]").replace(/\[\[:digit:\]\]/g, "[0-9]").replace(/\[\[:alnum:\]\]/g, "[a-zA-Z0-9]").replace(/\[\[:upper:\]\]/g, "[A-Z]").replace(/\[\[:lower:\]\]/g, "[a-z]").replace(/\[\[:punct:\]\]/g, "[!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~]").replace(/\[\[:xdigit:\]\]/g, "[0-9A-Fa-f]").replace(/\[\[:graph:\]\]/g, "[!-~]").replace(/\[\[:print:\]\]/g, "[ -~]").replace(/\[\[:cntrl:\]\]/g, "[\\x00-\\x1f\\x7f]");
}
var A;
var ry;
var ai;
var I1 = I(() => {
  "use strict";
  (function(e11) {
    e11.NUMBER = "NUMBER", e11.STRING = "STRING", e11.REGEX = "REGEX", e11.IDENT = "IDENT", e11.BEGIN = "BEGIN", e11.END = "END", e11.IF = "IF", e11.ELSE = "ELSE", e11.WHILE = "WHILE", e11.DO = "DO", e11.FOR = "FOR", e11.IN = "IN", e11.BREAK = "BREAK", e11.CONTINUE = "CONTINUE", e11.NEXT = "NEXT", e11.NEXTFILE = "NEXTFILE", e11.EXIT = "EXIT", e11.RETURN = "RETURN", e11.DELETE = "DELETE", e11.FUNCTION = "FUNCTION", e11.PRINT = "PRINT", e11.PRINTF = "PRINTF", e11.GETLINE = "GETLINE", e11.PLUS = "PLUS", e11.MINUS = "MINUS", e11.STAR = "STAR", e11.SLASH = "SLASH", e11.PERCENT = "PERCENT", e11.CARET = "CARET", e11.EQ = "EQ", e11.NE = "NE", e11.LT = "LT", e11.GT = "GT", e11.LE = "LE", e11.GE = "GE", e11.MATCH = "MATCH", e11.NOT_MATCH = "NOT_MATCH", e11.AND = "AND", e11.OR = "OR", e11.NOT = "NOT", e11.ASSIGN = "ASSIGN", e11.PLUS_ASSIGN = "PLUS_ASSIGN", e11.MINUS_ASSIGN = "MINUS_ASSIGN", e11.STAR_ASSIGN = "STAR_ASSIGN", e11.SLASH_ASSIGN = "SLASH_ASSIGN", e11.PERCENT_ASSIGN = "PERCENT_ASSIGN", e11.CARET_ASSIGN = "CARET_ASSIGN", e11.INCREMENT = "INCREMENT", e11.DECREMENT = "DECREMENT", e11.QUESTION = "QUESTION", e11.COLON = "COLON", e11.COMMA = "COMMA", e11.SEMICOLON = "SEMICOLON", e11.NEWLINE = "NEWLINE", e11.LPAREN = "LPAREN", e11.RPAREN = "RPAREN", e11.LBRACE = "LBRACE", e11.RBRACE = "RBRACE", e11.LBRACKET = "LBRACKET", e11.RBRACKET = "RBRACKET", e11.DOLLAR = "DOLLAR", e11.APPEND = "APPEND", e11.PIPE = "PIPE", e11.EOF = "EOF";
  })(A || (A = {}));
  ry = /* @__PURE__ */ new Map([["BEGIN", A.BEGIN], ["END", A.END], ["if", A.IF], ["else", A.ELSE], ["while", A.WHILE], ["do", A.DO], ["for", A.FOR], ["in", A.IN], ["break", A.BREAK], ["continue", A.CONTINUE], ["next", A.NEXT], ["nextfile", A.NEXTFILE], ["exit", A.EXIT], ["return", A.RETURN], ["delete", A.DELETE], ["function", A.FUNCTION], ["print", A.PRINT], ["printf", A.PRINTF], ["getline", A.GETLINE]]);
  ai = class {
    input;
    pos = 0;
    line = 1;
    column = 1;
    lastTokenType = null;
    constructor(t10) {
      this.input = t10;
    }
    tokenize() {
      let t10 = [];
      for (; this.pos < this.input.length; ) {
        let n10 = this.nextToken();
        n10 && (t10.push(n10), this.lastTokenType = n10.type);
      }
      return t10.push(this.makeToken(A.EOF, "")), t10;
    }
    makeToken(t10, n10) {
      return { type: t10, value: n10, line: this.line, column: this.column };
    }
    peek(t10 = 0) {
      return this.input[this.pos + t10] || "";
    }
    advance() {
      let t10 = this.input[this.pos++] || "";
      return t10 === `
` ? (this.line++, this.column = 1) : this.column++, t10;
    }
    skipWhitespace() {
      for (; this.pos < this.input.length; ) {
        let t10 = this.peek();
        if (t10 === " " || t10 === "	" || t10 === "\r")
          this.advance();
        else if (t10 === "\\")
          if (this.peek(1) === `
`)
            this.advance(), this.advance();
          else
            break;
        else if (t10 === "#")
          for (; this.pos < this.input.length && this.peek() !== `
`; )
            this.advance();
        else
          break;
      }
    }
    nextToken() {
      if (this.skipWhitespace(), this.pos >= this.input.length)
        return null;
      let t10 = this.line, n10 = this.column, r10 = this.peek();
      return r10 === `
` ? (this.advance(), { type: A.NEWLINE, value: `
`, line: t10, column: n10 }) : r10 === '"' ? this.readString() : r10 === "/" && this.canBeRegex() ? this.readRegex() : this.isDigit(r10) || r10 === "." && this.isDigit(this.peek(1)) ? this.readNumber() : this.isAlpha(r10) || r10 === "_" ? this.readIdentifier() : this.readOperator();
    }
    canBeRegex() {
      return (/* @__PURE__ */ new Set([null, A.NEWLINE, A.SEMICOLON, A.LBRACE, A.RBRACE, A.LPAREN, A.LBRACKET, A.COMMA, A.ASSIGN, A.PLUS_ASSIGN, A.MINUS_ASSIGN, A.STAR_ASSIGN, A.SLASH_ASSIGN, A.PERCENT_ASSIGN, A.CARET_ASSIGN, A.AND, A.OR, A.NOT, A.MATCH, A.NOT_MATCH, A.QUESTION, A.COLON, A.LT, A.GT, A.LE, A.GE, A.EQ, A.NE, A.PLUS, A.MINUS, A.STAR, A.PERCENT, A.CARET, A.PRINT, A.PRINTF, A.IF, A.WHILE, A.DO, A.FOR, A.RETURN])).has(this.lastTokenType);
    }
    readString() {
      let t10 = this.line, n10 = this.column;
      this.advance();
      let r10 = "";
      for (; this.pos < this.input.length && this.peek() !== '"'; )
        if (this.peek() === "\\") {
          this.advance();
          let s10 = this.advance();
          switch (s10) {
            case "n":
              r10 += `
`;
              break;
            case "t":
              r10 += "	";
              break;
            case "r":
              r10 += "\r";
              break;
            case "f":
              r10 += "\f";
              break;
            case "b":
              r10 += "\b";
              break;
            case "v":
              r10 += "\v";
              break;
            case "a":
              r10 += "\x07";
              break;
            case "\\":
              r10 += "\\";
              break;
            case '"':
              r10 += '"';
              break;
            case "/":
              r10 += "/";
              break;
            case "x": {
              let i10 = "";
              for (; i10.length < 2 && /[0-9a-fA-F]/.test(this.peek()); )
                i10 += this.advance();
              i10.length > 0 ? r10 += String.fromCharCode(parseInt(i10, 16)) : r10 += "x";
              break;
            }
            default:
              if (/[0-7]/.test(s10)) {
                let i10 = s10;
                for (; i10.length < 3 && /[0-7]/.test(this.peek()); )
                  i10 += this.advance();
                r10 += String.fromCharCode(parseInt(i10, 8));
              } else
                r10 += s10;
          }
        } else
          r10 += this.advance();
      return this.peek() === '"' && this.advance(), { type: A.STRING, value: r10, line: t10, column: n10 };
    }
    readRegex() {
      let t10 = this.line, n10 = this.column;
      this.advance();
      let r10 = "";
      for (; this.pos < this.input.length && this.peek() !== "/"; )
        if (this.peek() === "\\")
          r10 += this.advance(), this.pos < this.input.length && (r10 += this.advance());
        else {
          if (this.peek() === `
`)
            break;
          r10 += this.advance();
        }
      return this.peek() === "/" && this.advance(), r10 = sy(r10), { type: A.REGEX, value: r10, line: t10, column: n10 };
    }
    readNumber() {
      let t10 = this.line, n10 = this.column, r10 = "";
      for (; this.isDigit(this.peek()); )
        r10 += this.advance();
      if (this.peek() === "." && this.isDigit(this.peek(1)))
        for (r10 += this.advance(); this.isDigit(this.peek()); )
          r10 += this.advance();
      if (this.peek() === "e" || this.peek() === "E")
        for (r10 += this.advance(), (this.peek() === "+" || this.peek() === "-") && (r10 += this.advance()); this.isDigit(this.peek()); )
          r10 += this.advance();
      return { type: A.NUMBER, value: parseFloat(r10), line: t10, column: n10 };
    }
    readIdentifier() {
      let t10 = this.line, n10 = this.column, r10 = "";
      for (; this.isAlphaNumeric(this.peek()) || this.peek() === "_"; )
        r10 += this.advance();
      let s10 = ry.get(r10);
      return s10 !== void 0 ? { type: s10, value: r10, line: t10, column: n10 } : { type: A.IDENT, value: r10, line: t10, column: n10 };
    }
    readOperator() {
      let t10 = this.line, n10 = this.column, r10 = this.advance(), s10 = this.peek();
      switch (r10) {
        case "+":
          return s10 === "+" ? (this.advance(), { type: A.INCREMENT, value: "++", line: t10, column: n10 }) : s10 === "=" ? (this.advance(), { type: A.PLUS_ASSIGN, value: "+=", line: t10, column: n10 }) : { type: A.PLUS, value: "+", line: t10, column: n10 };
        case "-":
          return s10 === "-" ? (this.advance(), { type: A.DECREMENT, value: "--", line: t10, column: n10 }) : s10 === "=" ? (this.advance(), { type: A.MINUS_ASSIGN, value: "-=", line: t10, column: n10 }) : { type: A.MINUS, value: "-", line: t10, column: n10 };
        case "*":
          return s10 === "*" ? (this.advance(), { type: A.CARET, value: "**", line: t10, column: n10 }) : s10 === "=" ? (this.advance(), { type: A.STAR_ASSIGN, value: "*=", line: t10, column: n10 }) : { type: A.STAR, value: "*", line: t10, column: n10 };
        case "/":
          return s10 === "=" ? (this.advance(), { type: A.SLASH_ASSIGN, value: "/=", line: t10, column: n10 }) : { type: A.SLASH, value: "/", line: t10, column: n10 };
        case "%":
          return s10 === "=" ? (this.advance(), { type: A.PERCENT_ASSIGN, value: "%=", line: t10, column: n10 }) : { type: A.PERCENT, value: "%", line: t10, column: n10 };
        case "^":
          return s10 === "=" ? (this.advance(), { type: A.CARET_ASSIGN, value: "^=", line: t10, column: n10 }) : { type: A.CARET, value: "^", line: t10, column: n10 };
        case "=":
          return s10 === "=" ? (this.advance(), { type: A.EQ, value: "==", line: t10, column: n10 }) : { type: A.ASSIGN, value: "=", line: t10, column: n10 };
        case "!":
          return s10 === "=" ? (this.advance(), { type: A.NE, value: "!=", line: t10, column: n10 }) : s10 === "~" ? (this.advance(), { type: A.NOT_MATCH, value: "!~", line: t10, column: n10 }) : { type: A.NOT, value: "!", line: t10, column: n10 };
        case "<":
          return s10 === "=" ? (this.advance(), { type: A.LE, value: "<=", line: t10, column: n10 }) : { type: A.LT, value: "<", line: t10, column: n10 };
        case ">":
          return s10 === "=" ? (this.advance(), { type: A.GE, value: ">=", line: t10, column: n10 }) : s10 === ">" ? (this.advance(), { type: A.APPEND, value: ">>", line: t10, column: n10 }) : { type: A.GT, value: ">", line: t10, column: n10 };
        case "&":
          return s10 === "&" ? (this.advance(), { type: A.AND, value: "&&", line: t10, column: n10 }) : { type: A.IDENT, value: "&", line: t10, column: n10 };
        case "|":
          return s10 === "|" ? (this.advance(), { type: A.OR, value: "||", line: t10, column: n10 }) : { type: A.PIPE, value: "|", line: t10, column: n10 };
        case "~":
          return { type: A.MATCH, value: "~", line: t10, column: n10 };
        case "?":
          return { type: A.QUESTION, value: "?", line: t10, column: n10 };
        case ":":
          return { type: A.COLON, value: ":", line: t10, column: n10 };
        case ",":
          return { type: A.COMMA, value: ",", line: t10, column: n10 };
        case ";":
          return { type: A.SEMICOLON, value: ";", line: t10, column: n10 };
        case "(":
          return { type: A.LPAREN, value: "(", line: t10, column: n10 };
        case ")":
          return { type: A.RPAREN, value: ")", line: t10, column: n10 };
        case "{":
          return { type: A.LBRACE, value: "{", line: t10, column: n10 };
        case "}":
          return { type: A.RBRACE, value: "}", line: t10, column: n10 };
        case "[":
          return { type: A.LBRACKET, value: "[", line: t10, column: n10 };
        case "]":
          return { type: A.RBRACKET, value: "]", line: t10, column: n10 };
        case "$":
          return { type: A.DOLLAR, value: "$", line: t10, column: n10 };
        default:
          return { type: A.IDENT, value: r10, line: t10, column: n10 };
      }
    }
    isDigit(t10) {
      return t10 >= "0" && t10 <= "9";
    }
    isAlpha(t10) {
      return t10 >= "a" && t10 <= "z" || t10 >= "A" && t10 <= "Z";
    }
    isAlphaNumeric(t10) {
      return this.isDigit(t10) || this.isAlpha(t10);
    }
  };
});
function P1(e11) {
  e11.expect(Z.PRINT);
  let t10 = [];
  if (e11.check(Z.NEWLINE) || e11.check(Z.SEMICOLON) || e11.check(Z.RBRACE) || e11.check(Z.PIPE) || e11.check(Z.GT) || e11.check(Z.APPEND))
    t10.push({ type: "field", index: { type: "number", value: 0 } });
  else
    for (t10.push(li(e11)); e11.check(Z.COMMA); )
      e11.advance(), t10.push(li(e11));
  let n10;
  return e11.check(Z.GT) ? (e11.advance(), n10 = { redirect: ">", file: e11.parsePrimary() }) : e11.check(Z.APPEND) && (e11.advance(), n10 = { redirect: ">>", file: e11.parsePrimary() }), { type: "print", args: t10, output: n10 };
}
function li(e11) {
  return iy(e11) ? Ea(e11, true) : Ea(e11, false);
}
function Ea(e11, t10) {
  let n10 = t10 ? e11.parseTernary() : oy(e11);
  if (e11.match(Z.ASSIGN, Z.PLUS_ASSIGN, Z.MINUS_ASSIGN, Z.STAR_ASSIGN, Z.SLASH_ASSIGN, Z.PERCENT_ASSIGN, Z.CARET_ASSIGN)) {
    let r10 = e11.advance(), s10 = Ea(e11, t10);
    if (n10.type !== "variable" && n10.type !== "field" && n10.type !== "array_access")
      throw new Error("Invalid assignment target");
    return { type: "assignment", operator: (/* @__PURE__ */ new Map([["=", "="], ["+=", "+="], ["-=", "-="], ["*=", "*="], ["/=", "/="], ["%=", "%="], ["^=", "^="]])).get(r10.value) ?? "=", target: n10, value: s10 };
  }
  return n10;
}
function iy(e11) {
  let t10 = 0, n10 = e11.pos;
  for (; n10 < e11.tokens.length; ) {
    let r10 = e11.tokens[n10];
    if (r10.type === Z.LPAREN && t10++, r10.type === Z.RPAREN && t10--, r10.type === Z.QUESTION && t10 === 0)
      return true;
    if (r10.type === Z.NEWLINE || r10.type === Z.SEMICOLON || r10.type === Z.RBRACE || r10.type === Z.COMMA || r10.type === Z.PIPE)
      return false;
    n10++;
  }
  return false;
}
function oy(e11) {
  let t10 = O1(e11);
  for (; e11.check(Z.OR); ) {
    e11.advance();
    let n10 = O1(e11);
    t10 = { type: "binary", operator: "||", left: t10, right: n10 };
  }
  return t10;
}
function O1(e11) {
  let t10 = R1(e11);
  for (; e11.check(Z.AND); ) {
    e11.advance();
    let n10 = R1(e11);
    t10 = { type: "binary", operator: "&&", left: t10, right: n10 };
  }
  return t10;
}
function R1(e11) {
  let t10 = ay(e11);
  if (e11.check(Z.IN)) {
    e11.advance();
    let n10 = String(e11.expect(Z.IDENT).value);
    return { type: "in", key: t10, array: n10 };
  }
  return t10;
}
function ay(e11) {
  let t10 = $1(e11);
  for (; ly(e11) && !cy(e11); ) {
    let n10 = $1(e11);
    t10 = { type: "binary", operator: " ", left: t10, right: n10 };
  }
  return t10;
}
function $1(e11) {
  let t10 = T1(e11);
  for (; e11.match(Z.MATCH, Z.NOT_MATCH); ) {
    let n10 = e11.advance().type === Z.MATCH ? "~" : "!~", r10 = T1(e11);
    t10 = { type: "binary", operator: n10, left: t10, right: r10 };
  }
  return t10;
}
function T1(e11) {
  let t10 = e11.parseAddSub();
  for (; e11.match(Z.LT, Z.LE, Z.GE, Z.EQ, Z.NE); ) {
    let n10 = e11.advance(), r10 = e11.parseAddSub();
    t10 = { type: "binary", operator: (/* @__PURE__ */ new Map([["<", "<"], ["<=", "<="], [">=", ">="], ["==", "=="], ["!=", "!="]])).get(n10.value) ?? "==", left: t10, right: r10 };
  }
  return t10;
}
function ly(e11) {
  return e11.match(Z.NUMBER, Z.STRING, Z.IDENT, Z.DOLLAR, Z.LPAREN, Z.NOT, Z.MINUS, Z.PLUS, Z.INCREMENT, Z.DECREMENT);
}
function cy(e11) {
  return e11.match(Z.AND, Z.OR, Z.QUESTION, Z.ASSIGN, Z.PLUS_ASSIGN, Z.MINUS_ASSIGN, Z.STAR_ASSIGN, Z.SLASH_ASSIGN, Z.PERCENT_ASSIGN, Z.CARET_ASSIGN, Z.COMMA, Z.SEMICOLON, Z.NEWLINE, Z.RBRACE, Z.RPAREN, Z.RBRACKET, Z.COLON, Z.PIPE, Z.APPEND, Z.GT, Z.IN);
}
function D1(e11) {
  e11.expect(Z.PRINTF);
  let t10 = e11.check(Z.LPAREN);
  t10 && (e11.advance(), e11.skipNewlines());
  let n10 = t10 ? e11.parseExpression() : li(e11), r10 = [];
  for (; e11.check(Z.COMMA); )
    e11.advance(), t10 && e11.skipNewlines(), r10.push(t10 ? e11.parseExpression() : li(e11));
  t10 && (e11.skipNewlines(), e11.expect(Z.RPAREN));
  let s10;
  return e11.check(Z.GT) ? (e11.advance(), s10 = { redirect: ">", file: e11.parsePrimary() }) : e11.check(Z.APPEND) && (e11.advance(), s10 = { redirect: ">>", file: e11.parsePrimary() }), { type: "printf", format: n10, args: r10, output: s10 };
}
var Z;
var _1 = I(() => {
  "use strict";
  Z = { LPAREN: "LPAREN", RPAREN: "RPAREN", QUESTION: "QUESTION", NEWLINE: "NEWLINE", SEMICOLON: "SEMICOLON", RBRACE: "RBRACE", COMMA: "COMMA", PIPE: "PIPE", GT: "GT", APPEND: "APPEND", AND: "AND", OR: "OR", ASSIGN: "ASSIGN", PLUS_ASSIGN: "PLUS_ASSIGN", MINUS_ASSIGN: "MINUS_ASSIGN", STAR_ASSIGN: "STAR_ASSIGN", SLASH_ASSIGN: "SLASH_ASSIGN", PERCENT_ASSIGN: "PERCENT_ASSIGN", CARET_ASSIGN: "CARET_ASSIGN", RBRACKET: "RBRACKET", COLON: "COLON", IN: "IN", PRINT: "PRINT", PRINTF: "PRINTF", IDENT: "IDENT", LT: "LT", LE: "LE", GE: "GE", EQ: "EQ", NE: "NE", MATCH: "MATCH", NOT_MATCH: "NOT_MATCH", NUMBER: "NUMBER", STRING: "STRING", DOLLAR: "DOLLAR", NOT: "NOT", MINUS: "MINUS", PLUS: "PLUS", INCREMENT: "INCREMENT", DECREMENT: "DECREMENT" };
});
var ci;
var L1 = I(() => {
  "use strict";
  I1();
  _1();
  ci = class {
    tokens = [];
    pos = 0;
    parse(t10) {
      let n10 = new ai(t10);
      return this.tokens = n10.tokenize(), this.pos = 0, this.parseProgram();
    }
    setPos(t10) {
      this.pos = t10;
    }
    current() {
      return this.tokens[this.pos] || { type: A.EOF, value: "", line: 0, column: 0 };
    }
    advance() {
      let t10 = this.current();
      return this.pos < this.tokens.length && this.pos++, t10;
    }
    match(...t10) {
      return t10.includes(this.current().type);
    }
    check(t10) {
      return this.current().type === t10;
    }
    expect(t10, n10) {
      if (!this.check(t10)) {
        let r10 = this.current();
        throw new Error(n10 || `Expected ${t10}, got ${r10.type} at line ${r10.line}:${r10.column}`);
      }
      return this.advance();
    }
    skipNewlines() {
      for (; this.check(A.NEWLINE); )
        this.advance();
    }
    skipTerminators() {
      for (; this.check(A.NEWLINE) || this.check(A.SEMICOLON); )
        this.advance();
    }
    parseProgram() {
      let t10 = [], n10 = [];
      for (this.skipNewlines(); !this.check(A.EOF) && (this.skipNewlines(), !this.check(A.EOF)); )
        this.check(A.FUNCTION) ? t10.push(this.parseFunction()) : n10.push(this.parseRule()), this.skipTerminators();
      return { functions: t10, rules: n10 };
    }
    parseFunction() {
      this.expect(A.FUNCTION);
      let t10 = this.expect(A.IDENT).value;
      this.expect(A.LPAREN);
      let n10 = [];
      if (!this.check(A.RPAREN))
        for (n10.push(this.expect(A.IDENT).value); this.check(A.COMMA); )
          this.advance(), n10.push(this.expect(A.IDENT).value);
      this.expect(A.RPAREN), this.skipNewlines();
      let r10 = this.parseBlock();
      return { name: t10, params: n10, body: r10 };
    }
    parseRule() {
      let t10;
      if (this.check(A.BEGIN))
        this.advance(), t10 = { type: "begin" };
      else if (this.check(A.END))
        this.advance(), t10 = { type: "end" };
      else if (this.check(A.LBRACE))
        t10 = void 0;
      else if (this.check(A.REGEX)) {
        let r10 = this.advance();
        if (this.check(A.AND) || this.check(A.OR)) {
          let s10 = { type: "binary", operator: "~", left: { type: "field", index: { type: "number", value: 0 } }, right: { type: "regex", pattern: r10.value } };
          t10 = { type: "expr_pattern", expression: this.parseLogicalOrRest(s10) };
        } else {
          let s10 = { type: "regex_pattern", pattern: r10.value };
          if (this.check(A.COMMA)) {
            this.advance();
            let i10;
            this.check(A.REGEX) ? i10 = { type: "regex_pattern", pattern: this.advance().value } : i10 = { type: "expr_pattern", expression: this.parseExpression() }, t10 = { type: "range", start: s10, end: i10 };
          } else
            t10 = s10;
        }
      } else {
        let s10 = { type: "expr_pattern", expression: this.parseExpression() };
        if (this.check(A.COMMA)) {
          this.advance();
          let i10;
          this.check(A.REGEX) ? i10 = { type: "regex_pattern", pattern: this.advance().value } : i10 = { type: "expr_pattern", expression: this.parseExpression() }, t10 = { type: "range", start: s10, end: i10 };
        } else
          t10 = s10;
      }
      this.skipNewlines();
      let n10;
      return this.check(A.LBRACE) ? n10 = this.parseBlock() : n10 = { type: "block", statements: [{ type: "print", args: [{ type: "field", index: { type: "number", value: 0 } }] }] }, { pattern: t10, action: n10 };
    }
    parseBlock() {
      this.expect(A.LBRACE), this.skipNewlines();
      let t10 = [];
      for (; !this.check(A.RBRACE) && !this.check(A.EOF); )
        t10.push(this.parseStatement()), this.skipTerminators();
      return this.expect(A.RBRACE), { type: "block", statements: t10 };
    }
    parseStatement() {
      if (this.check(A.SEMICOLON) || this.check(A.NEWLINE))
        return this.advance(), { type: "block", statements: [] };
      if (this.check(A.LBRACE))
        return this.parseBlock();
      if (this.check(A.IF))
        return this.parseIf();
      if (this.check(A.WHILE))
        return this.parseWhile();
      if (this.check(A.DO))
        return this.parseDoWhile();
      if (this.check(A.FOR))
        return this.parseFor();
      if (this.check(A.BREAK))
        return this.advance(), { type: "break" };
      if (this.check(A.CONTINUE))
        return this.advance(), { type: "continue" };
      if (this.check(A.NEXT))
        return this.advance(), { type: "next" };
      if (this.check(A.NEXTFILE))
        return this.advance(), { type: "nextfile" };
      if (this.check(A.EXIT)) {
        this.advance();
        let n10;
        return !this.check(A.NEWLINE) && !this.check(A.SEMICOLON) && !this.check(A.RBRACE) && !this.check(A.EOF) && (n10 = this.parseExpression()), { type: "exit", code: n10 };
      }
      if (this.check(A.RETURN)) {
        this.advance();
        let n10;
        return !this.check(A.NEWLINE) && !this.check(A.SEMICOLON) && !this.check(A.RBRACE) && !this.check(A.EOF) && (n10 = this.parseExpression()), { type: "return", value: n10 };
      }
      if (this.check(A.DELETE)) {
        this.advance();
        let n10 = this.parsePrimary();
        if (n10.type !== "array_access" && n10.type !== "variable")
          throw new Error("delete requires array element or array");
        return { type: "delete", target: n10 };
      }
      return this.check(A.PRINT) ? P1(this) : this.check(A.PRINTF) ? D1(this) : { type: "expr_stmt", expression: this.parseExpression() };
    }
    parseIf() {
      this.expect(A.IF), this.expect(A.LPAREN);
      let t10 = this.parseExpression();
      this.expect(A.RPAREN), this.skipNewlines();
      let n10 = this.parseStatement();
      this.skipTerminators();
      let r10;
      return this.check(A.ELSE) && (this.advance(), this.skipNewlines(), r10 = this.parseStatement()), { type: "if", condition: t10, consequent: n10, alternate: r10 };
    }
    parseWhile() {
      this.expect(A.WHILE), this.expect(A.LPAREN);
      let t10 = this.parseExpression();
      this.expect(A.RPAREN), this.skipNewlines();
      let n10 = this.parseStatement();
      return { type: "while", condition: t10, body: n10 };
    }
    parseDoWhile() {
      this.expect(A.DO), this.skipNewlines();
      let t10 = this.parseStatement();
      this.skipNewlines(), this.expect(A.WHILE), this.expect(A.LPAREN);
      let n10 = this.parseExpression();
      return this.expect(A.RPAREN), { type: "do_while", body: t10, condition: n10 };
    }
    parseFor() {
      if (this.expect(A.FOR), this.expect(A.LPAREN), this.check(A.IDENT)) {
        let i10 = this.advance();
        if (this.check(A.IN)) {
          this.advance();
          let o10 = this.expect(A.IDENT).value;
          this.expect(A.RPAREN), this.skipNewlines();
          let a = this.parseStatement();
          return { type: "for_in", variable: i10.value, array: o10, body: a };
        }
        this.pos--;
      }
      let t10;
      this.check(A.SEMICOLON) || (t10 = this.parseExpression()), this.expect(A.SEMICOLON);
      let n10;
      this.check(A.SEMICOLON) || (n10 = this.parseExpression()), this.expect(A.SEMICOLON);
      let r10;
      this.check(A.RPAREN) || (r10 = this.parseExpression()), this.expect(A.RPAREN), this.skipNewlines();
      let s10 = this.parseStatement();
      return { type: "for", init: t10, condition: n10, update: r10, body: s10 };
    }
    parseExpression() {
      return this.parseAssignment();
    }
    parseAssignment() {
      let t10 = this.parseTernary();
      if (this.match(A.ASSIGN, A.PLUS_ASSIGN, A.MINUS_ASSIGN, A.STAR_ASSIGN, A.SLASH_ASSIGN, A.PERCENT_ASSIGN, A.CARET_ASSIGN)) {
        let n10 = this.advance(), r10 = this.parseAssignment();
        if (t10.type !== "variable" && t10.type !== "field" && t10.type !== "array_access")
          throw new Error("Invalid assignment target");
        return { type: "assignment", operator: { "=": "=", "+=": "+=", "-=": "-=", "*=": "*=", "/=": "/=", "%=": "%=", "^=": "^=" }[n10.value], target: t10, value: r10 };
      }
      return t10;
    }
    parseTernary() {
      let t10 = this.parsePipeGetline();
      if (this.check(A.QUESTION)) {
        this.advance();
        let n10 = this.parseExpression();
        this.expect(A.COLON);
        let r10 = this.parseExpression();
        t10 = { type: "ternary", condition: t10, consequent: n10, alternate: r10 };
      }
      return t10;
    }
    parsePipeGetline() {
      let t10 = this.parseOr();
      if (this.check(A.PIPE)) {
        if (this.advance(), !this.check(A.GETLINE))
          throw new Error("Expected 'getline' after '|' in expression context");
        this.advance();
        let n10;
        return this.check(A.IDENT) && (n10 = this.advance().value), { type: "getline", command: t10, variable: n10 };
      }
      return t10;
    }
    parseOr() {
      let t10 = this.parseAnd();
      for (; this.check(A.OR); ) {
        this.advance();
        let n10 = this.parseAnd();
        t10 = { type: "binary", operator: "||", left: t10, right: n10 };
      }
      return t10;
    }
    parseLogicalOrRest(t10) {
      for (t10 = this.parseLogicalAndRest(t10); this.check(A.OR); ) {
        this.advance();
        let n10 = this.parseAnd();
        t10 = { type: "binary", operator: "||", left: t10, right: n10 };
      }
      return t10;
    }
    parseLogicalAndRest(t10) {
      for (; this.check(A.AND); ) {
        this.advance();
        let n10 = this.parseIn();
        t10 = { type: "binary", operator: "&&", left: t10, right: n10 };
      }
      return t10;
    }
    parseAnd() {
      let t10 = this.parseIn();
      for (; this.check(A.AND); ) {
        this.advance();
        let n10 = this.parseIn();
        t10 = { type: "binary", operator: "&&", left: t10, right: n10 };
      }
      return t10;
    }
    parseIn() {
      let t10 = this.parseConcatenation();
      if (this.check(A.IN)) {
        this.advance();
        let n10 = this.expect(A.IDENT).value;
        return { type: "in", key: t10, array: n10 };
      }
      return t10;
    }
    parseConcatenation() {
      let t10 = this.parseMatch();
      for (; this.canStartExpression() && !this.isConcatTerminator(); ) {
        let n10 = this.parseMatch();
        t10 = { type: "binary", operator: " ", left: t10, right: n10 };
      }
      return t10;
    }
    parseMatch() {
      let t10 = this.parseComparison();
      for (; this.match(A.MATCH, A.NOT_MATCH); ) {
        let n10 = this.advance().type === A.MATCH ? "~" : "!~", r10 = this.parseComparison();
        t10 = { type: "binary", operator: n10, left: t10, right: r10 };
      }
      return t10;
    }
    parseComparison() {
      let t10 = this.parseAddSub();
      for (; this.match(A.LT, A.LE, A.GT, A.GE, A.EQ, A.NE); ) {
        let n10 = this.advance(), r10 = this.parseAddSub();
        t10 = { type: "binary", operator: (/* @__PURE__ */ new Map([["<", "<"], ["<=", "<="], [">", ">"], [">=", ">="], ["==", "=="], ["!=", "!="]])).get(n10.value) ?? "==", left: t10, right: r10 };
      }
      return t10;
    }
    canStartExpression() {
      return this.match(A.NUMBER, A.STRING, A.IDENT, A.DOLLAR, A.LPAREN, A.NOT, A.MINUS, A.PLUS, A.INCREMENT, A.DECREMENT);
    }
    isConcatTerminator() {
      return this.match(A.AND, A.OR, A.QUESTION, A.ASSIGN, A.PLUS_ASSIGN, A.MINUS_ASSIGN, A.STAR_ASSIGN, A.SLASH_ASSIGN, A.PERCENT_ASSIGN, A.CARET_ASSIGN, A.COMMA, A.SEMICOLON, A.NEWLINE, A.RBRACE, A.RPAREN, A.RBRACKET, A.COLON, A.PIPE, A.APPEND, A.IN);
    }
    parseAddSub() {
      let t10 = this.parseMulDiv();
      for (; this.match(A.PLUS, A.MINUS); ) {
        let n10 = this.advance().value, r10 = this.parseMulDiv();
        t10 = { type: "binary", operator: n10, left: t10, right: r10 };
      }
      return t10;
    }
    parseMulDiv() {
      let t10 = this.parseUnary();
      for (; this.match(A.STAR, A.SLASH, A.PERCENT); ) {
        let n10 = this.advance(), r10 = this.parseUnary();
        t10 = { type: "binary", operator: (/* @__PURE__ */ new Map([["*", "*"], ["/", "/"], ["%", "%"]])).get(n10.value) ?? "*", left: t10, right: r10 };
      }
      return t10;
    }
    parseUnary() {
      if (this.check(A.INCREMENT)) {
        this.advance();
        let t10 = this.parseUnary();
        return t10.type !== "variable" && t10.type !== "field" && t10.type !== "array_access" ? { type: "unary", operator: "+", operand: { type: "unary", operator: "+", operand: t10 } } : { type: "pre_increment", operand: t10 };
      }
      if (this.check(A.DECREMENT)) {
        this.advance();
        let t10 = this.parseUnary();
        return t10.type !== "variable" && t10.type !== "field" && t10.type !== "array_access" ? { type: "unary", operator: "-", operand: { type: "unary", operator: "-", operand: t10 } } : { type: "pre_decrement", operand: t10 };
      }
      if (this.match(A.NOT, A.MINUS, A.PLUS)) {
        let t10 = this.advance().value, n10 = this.parseUnary();
        return { type: "unary", operator: t10, operand: n10 };
      }
      return this.parsePower();
    }
    parsePower() {
      let t10 = this.parsePostfix();
      if (this.check(A.CARET)) {
        this.advance();
        let n10 = this.parsePower();
        t10 = { type: "binary", operator: "^", left: t10, right: n10 };
      }
      return t10;
    }
    parsePostfix() {
      let t10 = this.parsePrimary();
      if (this.check(A.INCREMENT)) {
        if (this.advance(), t10.type !== "variable" && t10.type !== "field" && t10.type !== "array_access")
          throw new Error("Invalid increment operand");
        return { type: "post_increment", operand: t10 };
      }
      if (this.check(A.DECREMENT)) {
        if (this.advance(), t10.type !== "variable" && t10.type !== "field" && t10.type !== "array_access")
          throw new Error("Invalid decrement operand");
        return { type: "post_decrement", operand: t10 };
      }
      return t10;
    }
    parseFieldIndex() {
      if (this.check(A.INCREMENT)) {
        this.advance();
        let t10 = this.parseFieldIndex();
        return t10.type !== "variable" && t10.type !== "field" && t10.type !== "array_access" ? { type: "unary", operator: "+", operand: { type: "unary", operator: "+", operand: t10 } } : { type: "pre_increment", operand: t10 };
      }
      if (this.check(A.DECREMENT)) {
        this.advance();
        let t10 = this.parseFieldIndex();
        return t10.type !== "variable" && t10.type !== "field" && t10.type !== "array_access" ? { type: "unary", operator: "-", operand: { type: "unary", operator: "-", operand: t10 } } : { type: "pre_decrement", operand: t10 };
      }
      if (this.match(A.NOT, A.MINUS, A.PLUS)) {
        let t10 = this.advance().value, n10 = this.parseFieldIndex();
        return { type: "unary", operator: t10, operand: n10 };
      }
      return this.parseFieldIndexPower();
    }
    parseFieldIndexPower() {
      let t10 = this.parseFieldIndexPrimary();
      if (this.check(A.CARET)) {
        this.advance();
        let n10 = this.parseFieldIndexPower();
        t10 = { type: "binary", operator: "^", left: t10, right: n10 };
      }
      return t10;
    }
    parseFieldIndexPrimary() {
      if (this.check(A.NUMBER))
        return { type: "number", value: this.advance().value };
      if (this.check(A.STRING))
        return { type: "string", value: this.advance().value };
      if (this.check(A.DOLLAR))
        return this.advance(), { type: "field", index: this.parseFieldIndex() };
      if (this.check(A.LPAREN)) {
        this.advance();
        let t10 = this.parseExpression();
        return this.expect(A.RPAREN), t10;
      }
      if (this.check(A.IDENT)) {
        let t10 = this.advance().value;
        if (this.check(A.LPAREN)) {
          this.advance();
          let n10 = [];
          if (!this.check(A.RPAREN))
            for (n10.push(this.parseExpression()); this.check(A.COMMA); )
              this.advance(), n10.push(this.parseExpression());
          return this.expect(A.RPAREN), { type: "call", name: t10, args: n10 };
        }
        if (this.check(A.LBRACKET)) {
          this.advance();
          let n10 = this.parseExpression();
          if (this.check(A.COMMA)) {
            let r10 = [n10];
            for (; this.check(A.COMMA); )
              this.advance(), r10.push(this.parseExpression());
            this.expect(A.RBRACKET);
            let s10 = r10.reduce((i10, o10) => ({ type: "binary", operator: " ", left: { type: "binary", operator: " ", left: i10, right: { type: "variable", name: "SUBSEP" } }, right: o10 }));
            return { type: "array_access", array: t10, key: s10 };
          }
          return this.expect(A.RBRACKET), { type: "array_access", array: t10, key: n10 };
        }
        return { type: "variable", name: t10 };
      }
      throw new Error(`Unexpected token in field index: ${this.current().type} at line ${this.current().line}:${this.current().column}`);
    }
    parsePrimary() {
      if (this.check(A.NUMBER))
        return { type: "number", value: this.advance().value };
      if (this.check(A.STRING))
        return { type: "string", value: this.advance().value };
      if (this.check(A.REGEX))
        return { type: "regex", pattern: this.advance().value };
      if (this.check(A.DOLLAR))
        return this.advance(), { type: "field", index: this.parseFieldIndex() };
      if (this.check(A.LPAREN)) {
        this.advance();
        let t10 = this.parseExpression();
        if (this.check(A.COMMA)) {
          let n10 = [t10];
          for (; this.check(A.COMMA); )
            this.advance(), n10.push(this.parseExpression());
          return this.expect(A.RPAREN), { type: "tuple", elements: n10 };
        }
        return this.expect(A.RPAREN), t10;
      }
      if (this.check(A.GETLINE)) {
        this.advance();
        let t10, n10;
        return this.check(A.IDENT) && (t10 = this.advance().value), this.check(A.LT) && (this.advance(), n10 = this.parsePrimary()), { type: "getline", variable: t10, file: n10 };
      }
      if (this.check(A.IDENT)) {
        let t10 = this.advance().value;
        if (this.check(A.LPAREN)) {
          this.advance();
          let n10 = [];
          if (this.skipNewlines(), !this.check(A.RPAREN))
            for (n10.push(this.parseExpression()); this.check(A.COMMA); )
              this.advance(), this.skipNewlines(), n10.push(this.parseExpression());
          return this.skipNewlines(), this.expect(A.RPAREN), { type: "call", name: t10, args: n10 };
        }
        if (this.check(A.LBRACKET)) {
          this.advance();
          let n10 = [this.parseExpression()];
          for (; this.check(A.COMMA); )
            this.advance(), n10.push(this.parseExpression());
          this.expect(A.RBRACKET);
          let r10;
          if (n10.length === 1)
            r10 = n10[0];
          else {
            r10 = n10[0];
            for (let s10 = 1; s10 < n10.length; s10++)
              r10 = { type: "binary", operator: " ", left: { type: "binary", operator: " ", left: r10, right: { type: "variable", name: "SUBSEP" } }, right: n10[s10] };
          }
          return { type: "array_access", array: t10, key: r10 };
        }
        return { type: "variable", name: t10 };
      }
      throw new Error(`Unexpected token: ${this.current().type} at line ${this.current().line}:${this.current().column}`);
    }
  };
});
var U1 = {};
Q(U1, { awkCommand2: () => fy, flagsForFuzzing: () => py });
function Aa(e11) {
  return e11.replace(/\\t/g, "	").replace(/\\n/g, `
`).replace(/\\r/g, "\r").replace(/\\b/g, "\b").replace(/\\f/g, "\f").replace(/\\a/g, "\x07").replace(/\\v/g, "\v").replace(/\\\\/g, "\\");
}
function F1(e11) {
  if (e11 === " ")
    return V("\\s+");
  if (/[[\](){}.*+?^$|\\]/.test(e11))
    try {
      return V(e11);
    } catch {
      return V(M1(e11));
    }
  return V(M1(e11));
}
function M1(e11) {
  return e11.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var uy;
var fy;
var py;
var W1 = I(() => {
  "use strict";
  On();
  ye();
  Fe();
  se();
  v1();
  L1();
  uy = { name: "awk", summary: "pattern scanning and text processing language", usage: "awk [OPTIONS] 'PROGRAM' [FILE...]", options: ["-F FS      use FS as field separator", "-v VAR=VAL assign VAL to variable VAR", "    --help display this help and exit"] }, fy = { name: "awk", async execute(e11, t10) {
    if (U2(e11))
      return M(uy);
    let n10 = new xn(/\s+/), r10 = " ", s10 = /* @__PURE__ */ Object.create(null), i10 = 0;
    for (let d = 0; d < e11.length; d++) {
      let g = e11[d];
      if (g === "-F" && d + 1 < e11.length)
        r10 = Aa(e11[++d]), n10 = F1(r10), i10 = d + 1;
      else if (g.startsWith("-F"))
        r10 = Aa(g.slice(2)), n10 = F1(r10), i10 = d + 1;
      else if (g === "-v" && d + 1 < e11.length) {
        let y = e11[++d], w = y.indexOf("=");
        if (w > 0) {
          let b = y.slice(0, w), x = Aa(y.slice(w + 1));
          s10[b] = x;
        }
        i10 = d + 1;
      } else {
        if (g.startsWith("--"))
          return Y("awk", g);
        if (g.startsWith("-") && g.length > 1) {
          let y = g[1];
          if (y !== "F" && y !== "v")
            return Y("awk", `-${y}`);
          i10 = d + 1;
        } else if (!g.startsWith("-")) {
          i10 = d;
          break;
        }
      }
    }
    if (i10 >= e11.length)
      return { stdout: "", stderr: `awk: missing program
`, exitCode: 1 };
    let o10 = e11[i10], a = e11.slice(i10 + 1), l = new ci(), c;
    try {
      c = l.parse(o10);
    } catch (d) {
      return { stdout: "", stderr: `awk: ${d instanceof Error ? d.message : String(d)}
`, exitCode: 1 };
    }
    let u = { readFile: t10.fs.readFile.bind(t10.fs), writeFile: t10.fs.writeFile.bind(t10.fs), appendFile: async (d, g) => {
      try {
        let y = await t10.fs.readFile(d);
        await t10.fs.writeFile(d, y + g);
      } catch {
        await t10.fs.writeFile(d, g);
      }
    }, resolvePath: t10.fs.resolvePath.bind(t10.fs) }, f10 = fa({ fieldSep: n10, maxIterations: t10.limits?.maxAwkIterations, maxOutputSize: t10.limits?.maxStringLength, fs: u, cwd: t10.cwd, exec: t10.exec ? (d) => t10.exec(d, { cwd: t10.cwd }) : void 0, coverage: t10.coverage });
    f10.FS = r10, f10.vars = Object.assign(/* @__PURE__ */ Object.create(null), s10), f10.ARGC = a.length + 1, f10.ARGV = /* @__PURE__ */ Object.create(null), f10.ARGV[0] = "awk";
    for (let d = 0; d < a.length; d++)
      f10.ARGV[String(d + 1)] = a[d];
    f10.ENVIRON = xt(t10.env);
    let p = new rs(f10);
    p.execute(c);
    let h = c.rules.some((d) => d.pattern?.type !== "begin" && d.pattern?.type !== "end"), m = c.rules.some((d) => d.pattern?.type === "end");
    try {
      if (await p.executeBegin(), f10.shouldExit)
        return await p.executeEnd(), { stdout: p.getOutput(), stderr: "", exitCode: p.getExitCode() };
      if (!h && !m)
        return { stdout: p.getOutput(), stderr: "", exitCode: p.getExitCode() };
      let d = [];
      if (a.length > 0)
        for (let g of a)
          try {
            let y = t10.fs.resolvePath(t10.cwd, g), b = (await t10.fs.readFile(y)).split(`
`);
            b.length > 0 && b[b.length - 1] === "" && b.pop(), d.push({ filename: g, lines: b });
          } catch {
            return { stdout: "", stderr: `awk: ${g}: No such file or directory
`, exitCode: 1 };
          }
      else {
        let g = t10.stdin.split(`
`);
        g.length > 0 && g[g.length - 1] === "" && g.pop(), d.push({ filename: "", lines: g });
      }
      for (let g of d) {
        for (f10.FILENAME = g.filename, f10.FNR = 0, f10.lines = g.lines, f10.lineIndex = -1, f10.shouldNextFile = false; f10.lineIndex < g.lines.length - 1 && (f10.lineIndex++, await p.executeLine(g.lines[f10.lineIndex]), !(f10.shouldExit || f10.shouldNextFile)); )
          ;
        if (f10.shouldExit)
          break;
      }
      return await p.executeEnd(), { stdout: p.getOutput(), stderr: "", exitCode: p.getExitCode() };
    } catch (d) {
      let g = d instanceof Error ? d.message : String(d), y = d instanceof te ? te.EXIT_CODE : 2;
      return { stdout: p.getOutput(), stderr: `awk: ${g}
`, exitCode: y };
    }
  } };
  py = { name: "awk", flags: [{ flag: "-F", type: "value", valueHint: "delimiter" }, { flag: "-v", type: "value", valueHint: "string" }], stdinType: "text", needsArgs: true };
});
function B1(e11) {
  let t10 = e11.trim(), n10 = t10.match(/^([+-]?\d*\.?\d+)\s*([kmgtpeKMGTPE])?[iI]?[bB]?$/);
  if (!n10) {
    let o10 = parseFloat(t10);
    return Number.isNaN(o10) ? 0 : o10;
  }
  let r10 = parseFloat(n10[1]), s10 = (n10[2] || "").toLowerCase(), i10 = hy.get(s10) ?? 1;
  return r10 * i10;
}
function z1(e11) {
  let t10 = e11.trim().toLowerCase().slice(0, 3);
  return dy.get(t10) ?? 0;
}
function my(e11, t10) {
  let n10 = e11.split(/(\d+)/), r10 = t10.split(/(\d+)/), s10 = Math.max(n10.length, r10.length);
  for (let i10 = 0; i10 < s10; i10++) {
    let o10 = n10[i10] || "", a = r10[i10] || "", l = /^\d+$/.test(o10) ? parseInt(o10, 10) : null, c = /^\d+$/.test(a) ? parseInt(a, 10) : null;
    if (l !== null && c !== null) {
      if (l !== c)
        return l - c;
    } else if (o10 !== a)
      return o10.localeCompare(a);
  }
  return 0;
}
function H1(e11) {
  return e11.replace(/[^a-zA-Z0-9\s]/g, "");
}
function Sa(e11, t10, n10) {
  let r10 = n10 !== null ? n10 : /\s+/, s10 = e11.split(r10), i10 = t10.startField - 1;
  if (i10 >= s10.length)
    return "";
  if (t10.endField === void 0) {
    let l = s10[i10] || "";
    return t10.startChar !== void 0 && (l = l.slice(t10.startChar - 1)), t10.ignoreLeading && (l = l.trimStart()), l;
  }
  let o10 = Math.min(t10.endField - 1, s10.length - 1), a = "";
  for (let l = i10; l <= o10 && l < s10.length; l++) {
    let c = s10[l] || "";
    if (l === i10 && t10.startChar !== void 0 && (c = c.slice(t10.startChar - 1)), l === o10 && t10.endChar !== void 0) {
      let u = l === i10 && t10.startChar !== void 0 ? t10.endChar - t10.startChar + 1 : t10.endChar;
      c = c.slice(0, u);
    }
    l > i10 && (a += n10 || " "), a += c;
  }
  return t10.ignoreLeading && (a = a.trimStart()), a;
}
function j1(e11, t10, n10) {
  let r10 = e11, s10 = t10;
  if (n10.dictionaryOrder && (r10 = H1(r10), s10 = H1(s10)), n10.ignoreCase && (r10 = r10.toLowerCase(), s10 = s10.toLowerCase()), n10.monthSort) {
    let i10 = z1(r10), o10 = z1(s10);
    return i10 - o10;
  }
  if (n10.humanNumeric) {
    let i10 = B1(r10), o10 = B1(s10);
    return i10 - o10;
  }
  if (n10.versionSort)
    return my(r10, s10);
  if (n10.numeric) {
    let i10 = parseFloat(r10) || 0, o10 = parseFloat(s10) || 0;
    return i10 - o10;
  }
  return r10.localeCompare(s10);
}
function G1(e11) {
  let { keys: t10, fieldDelimiter: n10, numeric: r10, ignoreCase: s10, reverse: i10, humanNumeric: o10, versionSort: a, dictionaryOrder: l, monthSort: c, ignoreLeadingBlanks: u, stable: f10 } = e11;
  return (p, h) => {
    let m = p, d = h;
    if (u && (m = m.trimStart(), d = d.trimStart()), t10.length === 0) {
      let y = j1(m, d, { numeric: r10, ignoreCase: s10, humanNumeric: o10, versionSort: a, dictionaryOrder: l, monthSort: c });
      if (y !== 0)
        return i10 ? -y : y;
      if (!f10) {
        let w = p.localeCompare(h);
        return i10 ? -w : w;
      }
      return 0;
    }
    for (let g of t10) {
      let y = Sa(m, g, n10), w = Sa(d, g, n10);
      g.ignoreLeading && (y = y.trimStart(), w = w.trimStart());
      let b = { numeric: g.numeric ?? r10, ignoreCase: g.ignoreCase ?? s10, humanNumeric: g.humanNumeric ?? o10, versionSort: g.versionSort ?? a, dictionaryOrder: g.dictionaryOrder ?? l, monthSort: g.monthSort ?? c }, x = g.reverse ?? i10, S = j1(y, w, b);
      if (S !== 0)
        return x ? -S : S;
    }
    if (!f10) {
      let g = p.localeCompare(h);
      return i10 ? -g : g;
    }
    return 0;
  };
}
function V1(e11, t10) {
  if (t10.keys.length === 0) {
    if (t10.ignoreCase) {
      let s10 = /* @__PURE__ */ new Set();
      return e11.filter((i10) => {
        let o10 = i10.toLowerCase();
        return s10.has(o10) ? false : (s10.add(o10), true);
      });
    }
    return [...new Set(e11)];
  }
  let n10 = t10.keys[0], r10 = /* @__PURE__ */ new Set();
  return e11.filter((s10) => {
    let i10 = Sa(s10, n10, t10.fieldDelimiter);
    return (n10.ignoreCase ?? t10.ignoreCase) && (i10 = i10.toLowerCase()), r10.has(i10) ? false : (r10.add(i10), true);
  });
}
var hy;
var dy;
var q1 = I(() => {
  "use strict";
  hy = /* @__PURE__ */ new Map([["", 1], ["k", 1024], ["m", 1048576], ["g", 1073741824], ["t", 1099511627776], ["p", 1125899906842624], ["e", 1152921504606847e3]]), dy = /* @__PURE__ */ new Map([["jan", 1], ["feb", 2], ["mar", 3], ["apr", 4], ["may", 5], ["jun", 6], ["jul", 7], ["aug", 8], ["sep", 9], ["oct", 10], ["nov", 11], ["dec", 12]]);
});
function ui(e11) {
  let t10 = { startField: 1 }, n10 = "", r10 = e11, s10 = r10.match(/([bdfhMnrV]+)$/);
  s10 && (n10 = s10[1], r10 = r10.slice(0, -n10.length)), n10.includes("n") && (t10.numeric = true), n10.includes("r") && (t10.reverse = true), n10.includes("f") && (t10.ignoreCase = true), n10.includes("b") && (t10.ignoreLeading = true), n10.includes("h") && (t10.humanNumeric = true), n10.includes("V") && (t10.versionSort = true), n10.includes("d") && (t10.dictionaryOrder = true), n10.includes("M") && (t10.monthSort = true);
  let i10 = r10.split(",");
  if (i10.length === 0 || i10[0] === "")
    return null;
  let o10 = i10[0].split("."), a = parseInt(o10[0], 10);
  if (Number.isNaN(a) || a < 1)
    return null;
  if (t10.startField = a, o10.length > 1 && o10[1]) {
    let l = parseInt(o10[1], 10);
    !Number.isNaN(l) && l >= 1 && (t10.startChar = l);
  }
  if (i10.length > 1 && i10[1]) {
    let l = i10[1], c = l.match(/([bdfhMnrV]+)$/);
    if (c) {
      let f10 = c[1];
      f10.includes("n") && (t10.numeric = true), f10.includes("r") && (t10.reverse = true), f10.includes("f") && (t10.ignoreCase = true), f10.includes("b") && (t10.ignoreLeading = true), f10.includes("h") && (t10.humanNumeric = true), f10.includes("V") && (t10.versionSort = true), f10.includes("d") && (t10.dictionaryOrder = true), f10.includes("M") && (t10.monthSort = true), l = l.slice(0, -f10.length);
    }
    let u = l.split(".");
    if (u[0]) {
      let f10 = parseInt(u[0], 10);
      if (!Number.isNaN(f10) && f10 >= 1 && (t10.endField = f10), u.length > 1 && u[1]) {
        let p = parseInt(u[1], 10);
        !Number.isNaN(p) && p >= 1 && (t10.endChar = p);
      }
    }
  }
  return t10;
}
var Z1 = I(() => {
  "use strict";
});
var Q1 = {};
Q(Q1, { flagsForFuzzing: () => wy, sortCommand: () => yy });
var gy;
var yy;
var wy;
var K1 = I(() => {
  "use strict";
  Hn();
  se();
  q1();
  Z1();
  gy = { name: "sort", summary: "sort lines of text files", usage: "sort [OPTION]... [FILE]...", options: ["-b, --ignore-leading-blanks  ignore leading blanks", "-d, --dictionary-order  consider only blanks and alphanumeric characters", "-f, --ignore-case    fold lower case to upper case characters", "-h, --human-numeric-sort  compare human readable numbers (e.g., 2K 1G)", "-M, --month-sort     compare (unknown) < 'JAN' < ... < 'DEC'", "-n, --numeric-sort   compare according to string numerical value", "-r, --reverse        reverse the result of comparisons", "-V, --version-sort   natural sort of (version) numbers within text", "-c, --check          check for sorted input; do not sort", "-o, --output=FILE    write result to FILE instead of stdout", "-s, --stable         stabilize sort by disabling last-resort comparison", "-u, --unique         output only unique lines", "-k, --key=KEYDEF     sort via a key; KEYDEF gives location and type", "-t, --field-separator=SEP  use SEP as field separator", "    --help           display this help and exit"], description: `KEYDEF is F[.C][OPTS][,F[.C][OPTS]]
  F is a field number (1-indexed)
  C is a character position within the field (1-indexed)
  OPTS can be: b d f h M n r V (per-key modifiers)

Examples:
  -k1        sort by first field
  -k2,2      sort by second field only
  -k1.3      sort by first field starting at 3rd character
  -k1,2n     sort by fields 1-2 numerically
  -k2 -k1    sort by field 2, then by field 1` }, yy = { name: "sort", async execute(e11, t10) {
    if (U2(e11))
      return M(gy);
    let n10 = { reverse: false, numeric: false, unique: false, ignoreCase: false, humanNumeric: false, versionSort: false, dictionaryOrder: false, monthSort: false, ignoreLeadingBlanks: false, stable: false, checkOnly: false, outputFile: null, keys: [], fieldDelimiter: null }, r10 = [];
    for (let c = 0; c < e11.length; c++) {
      let u = e11[c];
      if (u === "-r" || u === "--reverse")
        n10.reverse = true;
      else if (u === "-n" || u === "--numeric-sort")
        n10.numeric = true;
      else if (u === "-u" || u === "--unique")
        n10.unique = true;
      else if (u === "-f" || u === "--ignore-case")
        n10.ignoreCase = true;
      else if (u === "-h" || u === "--human-numeric-sort")
        n10.humanNumeric = true;
      else if (u === "-V" || u === "--version-sort")
        n10.versionSort = true;
      else if (u === "-d" || u === "--dictionary-order")
        n10.dictionaryOrder = true;
      else if (u === "-M" || u === "--month-sort")
        n10.monthSort = true;
      else if (u === "-b" || u === "--ignore-leading-blanks")
        n10.ignoreLeadingBlanks = true;
      else if (u === "-s" || u === "--stable")
        n10.stable = true;
      else if (u === "-c" || u === "--check")
        n10.checkOnly = true;
      else if (u === "-o" || u === "--output")
        n10.outputFile = e11[++c] || null;
      else if (u.startsWith("-o"))
        n10.outputFile = u.slice(2) || null;
      else if (u.startsWith("--output="))
        n10.outputFile = u.slice(9) || null;
      else if (u === "-t" || u === "--field-separator")
        n10.fieldDelimiter = e11[++c] || null;
      else if (u.startsWith("-t"))
        n10.fieldDelimiter = u.slice(2) || null;
      else if (u.startsWith("--field-separator="))
        n10.fieldDelimiter = u.slice(18) || null;
      else if (u === "-k" || u === "--key") {
        let f10 = e11[++c];
        if (f10) {
          let p = ui(f10);
          p && n10.keys.push(p);
        }
      } else if (u.startsWith("-k")) {
        let f10 = ui(u.slice(2));
        f10 && n10.keys.push(f10);
      } else if (u.startsWith("--key=")) {
        let f10 = ui(u.slice(6));
        f10 && n10.keys.push(f10);
      } else {
        if (u.startsWith("--"))
          return Y("sort", u);
        if (u.startsWith("-") && !u.startsWith("--")) {
          let f10 = false;
          for (let p of u.slice(1))
            if (p === "r")
              n10.reverse = true;
            else if (p === "n")
              n10.numeric = true;
            else if (p === "u")
              n10.unique = true;
            else if (p === "f")
              n10.ignoreCase = true;
            else if (p === "h")
              n10.humanNumeric = true;
            else if (p === "V")
              n10.versionSort = true;
            else if (p === "d")
              n10.dictionaryOrder = true;
            else if (p === "M")
              n10.monthSort = true;
            else if (p === "b")
              n10.ignoreLeadingBlanks = true;
            else if (p === "s")
              n10.stable = true;
            else if (p === "c")
              n10.checkOnly = true;
            else {
              f10 = true;
              break;
            }
          if (f10)
            return Y("sort", u);
        } else
          r10.push(u);
      }
    }
    let s10 = await cr(t10, r10, { cmdName: "sort" });
    if (!s10.ok)
      return s10.error;
    let o10 = s10.content.split(`
`);
    o10.length > 0 && o10[o10.length - 1] === "" && o10.pop();
    let a = G1(n10);
    if (n10.checkOnly) {
      let c = r10.length > 0 ? r10[0] : "-";
      for (let u = 1; u < o10.length; u++)
        if (a(o10[u - 1], o10[u]) > 0)
          return { stdout: "", stderr: `sort: ${c}:${u + 1}: disorder: ${o10[u]}
`, exitCode: 1 };
      return { stdout: "", stderr: "", exitCode: 0 };
    }
    o10.sort(a), n10.unique && (o10 = V1(o10, n10));
    let l = o10.length > 0 ? `${o10.join(`
`)}
` : "";
    if (n10.outputFile) {
      let c = t10.fs.resolvePath(t10.cwd, n10.outputFile);
      return await t10.fs.writeFile(c, l), { stdout: "", stderr: "", exitCode: 0 };
    }
    return { stdout: l, stderr: "", exitCode: 0 };
  } }, wy = { name: "sort", flags: [{ flag: "-r", type: "boolean" }, { flag: "-n", type: "boolean" }, { flag: "-u", type: "boolean" }, { flag: "-f", type: "boolean" }, { flag: "-h", type: "boolean" }, { flag: "-V", type: "boolean" }, { flag: "-d", type: "boolean" }, { flag: "-M", type: "boolean" }, { flag: "-b", type: "boolean" }, { flag: "-s", type: "boolean" }, { flag: "-c", type: "boolean" }, { flag: "-k", type: "value", valueHint: "string" }, { flag: "-t", type: "value", valueHint: "delimiter" }, { flag: "-o", type: "value", valueHint: "path" }], stdinType: "text", needsFiles: true };
});
var X1 = {};
Q(X1, { flagsForFuzzing: () => Ay, uniqCommand: () => Ey });
var by;
var xy;
var Ey;
var Ay;
var Y1 = I(() => {
  "use strict";
  qe();
  Hn();
  se();
  by = { name: "uniq", summary: "report or omit repeated lines", usage: "uniq [OPTION]... [INPUT [OUTPUT]]", options: ["-c, --count        prefix lines by the number of occurrences", "-d, --repeated     only print duplicate lines", "-i, --ignore-case  ignore case when comparing", "-u, --unique       only print unique lines", "    --help         display this help and exit"] }, xy = { count: { short: "c", long: "count", type: "boolean" }, duplicatesOnly: { short: "d", long: "repeated", type: "boolean" }, uniqueOnly: { short: "u", long: "unique", type: "boolean" }, ignoreCase: { short: "i", long: "ignore-case", type: "boolean" } }, Ey = { name: "uniq", async execute(e11, t10) {
    if (U2(e11))
      return M(by);
    let n10 = be("uniq", e11, xy);
    if (!n10.ok)
      return n10.error;
    let { count: r10, duplicatesOnly: s10, uniqueOnly: i10, ignoreCase: o10 } = n10.result.flags, a = n10.result.positional, l = await cr(t10, a, { cmdName: "uniq" });
    if (!l.ok)
      return l.error;
    let u = l.content.split(`
`);
    if (u.length > 0 && u[u.length - 1] === "" && u.pop(), u.length === 0)
      return { stdout: "", stderr: "", exitCode: 0 };
    let f10 = [], p = u[0], h = 1, m = (y, w) => o10 ? y.toLowerCase() === w.toLowerCase() : y === w;
    for (let y = 1; y < u.length; y++)
      m(u[y], p) ? h++ : (f10.push({ line: p, count: h }), p = u[y], h = 1);
    f10.push({ line: p, count: h });
    let d = f10;
    s10 ? d = f10.filter((y) => y.count > 1) : i10 && (d = f10.filter((y) => y.count === 1));
    let g = "";
    for (let { line: y, count: w } of d)
      r10 ? g += `${String(w).padStart(4)} ${y}
` : g += `${y}
`;
    return { stdout: g, stderr: "", exitCode: 0 };
  } }, Ay = { name: "uniq", flags: [{ flag: "-c", type: "boolean" }, { flag: "-d", type: "boolean" }, { flag: "-u", type: "boolean" }, { flag: "-i", type: "boolean" }], stdinType: "text", needsFiles: true };
});
var J1 = {};
Q(J1, { commCommand: () => Cy, flagsForFuzzing: () => Ny });
var Sy;
var Cy;
var Ny;
var ep = I(() => {
  "use strict";
  se();
  Sy = { name: "comm", summary: "compare two sorted files line by line", usage: "comm [OPTION]... FILE1 FILE2", options: ["-1             suppress column 1 (lines unique to FILE1)", "-2             suppress column 2 (lines unique to FILE2)", "-3             suppress column 3 (lines that appear in both files)", "    --help     display this help and exit"] }, Cy = { name: "comm", async execute(e11, t10) {
    if (U2(e11))
      return M(Sy);
    let n10 = false, r10 = false, s10 = false, i10 = [];
    for (let g of e11)
      if (g === "-1")
        n10 = true;
      else if (g === "-2")
        r10 = true;
      else if (g === "-3")
        s10 = true;
      else if (g === "-12" || g === "-21")
        n10 = true, r10 = true;
      else if (g === "-13" || g === "-31")
        n10 = true, s10 = true;
      else if (g === "-23" || g === "-32")
        r10 = true, s10 = true;
      else if (g === "-123" || g === "-132" || g === "-213" || g === "-231" || g === "-312" || g === "-321")
        n10 = true, r10 = true, s10 = true;
      else {
        if (g.startsWith("-") && g !== "-")
          return Y("comm", g);
        i10.push(g);
      }
    if (i10.length !== 2)
      return { stdout: "", stderr: `comm: missing operand
Try 'comm --help' for more information.
`, exitCode: 1 };
    let o10 = async (g) => {
      if (g === "-")
        return t10.stdin;
      try {
        let y = t10.fs.resolvePath(t10.cwd, g);
        return await t10.fs.readFile(y);
      } catch {
        return null;
      }
    }, a = await o10(i10[0]);
    if (a === null)
      return { stdout: "", stderr: `comm: ${i10[0]}: No such file or directory
`, exitCode: 1 };
    let l = await o10(i10[1]);
    if (l === null)
      return { stdout: "", stderr: `comm: ${i10[1]}: No such file or directory
`, exitCode: 1 };
    let c = a.split(`
`), u = l.split(`
`);
    c.length > 0 && c[c.length - 1] === "" && c.pop(), u.length > 0 && u[u.length - 1] === "" && u.pop();
    let f10 = 0, p = 0, h = "", m = n10 ? "" : "	", d = (n10 ? "" : "	") + (r10 ? "" : "	");
    for (; f10 < c.length || p < u.length; )
      f10 >= c.length ? (r10 || (h += `${m}${u[p]}
`), p++) : p >= u.length ? (n10 || (h += `${c[f10]}
`), f10++) : c[f10] < u[p] ? (n10 || (h += `${c[f10]}
`), f10++) : c[f10] > u[p] ? (r10 || (h += `${m}${u[p]}
`), p++) : (s10 || (h += `${d}${c[f10]}
`), f10++, p++);
    return { stdout: h, stderr: "", exitCode: 0 };
  } }, Ny = { name: "comm", flags: [{ flag: "-1", type: "boolean" }, { flag: "-2", type: "boolean" }, { flag: "-3", type: "boolean" }], needsArgs: true, minArgs: 2 };
});
var tp = {};
Q(tp, { cutCommand: () => Oy, flagsForFuzzing: () => Ry });
function vy(e11) {
  let t10 = [], n10 = e11.split(",");
  for (let r10 of n10)
    if (r10.includes("-")) {
      let [s10, i10] = r10.split("-");
      t10.push({ start: s10 ? parseInt(s10, 10) : 1, end: i10 ? parseInt(i10, 10) : null });
    } else {
      let s10 = parseInt(r10, 10);
      t10.push({ start: s10, end: s10 });
    }
  return t10;
}
function Iy(e11, t10) {
  let n10 = [];
  for (let r10 of t10) {
    let s10 = r10.start - 1, i10 = r10.end === null ? e11.length : r10.end;
    for (let o10 = s10; o10 < i10 && o10 < e11.length; o10++)
      o10 >= 0 && !n10.includes(e11[o10]) && n10.push(e11[o10]);
  }
  return n10;
}
var ky;
var Oy;
var Ry;
var np = I(() => {
  "use strict";
  Hn();
  se();
  ky = { name: "cut", summary: "remove sections from each line of files", usage: "cut [OPTION]... [FILE]...", options: ["-c LIST              select only these characters", "-d DELIM             use DELIM instead of TAB for field delimiter", "-f LIST              select only these fields", "-s, --only-delimited  do not print lines without delimiters", "    --help           display this help and exit"] };
  Oy = { name: "cut", async execute(e11, t10) {
    if (U2(e11))
      return M(ky);
    let n10 = "	", r10 = null, s10 = null, i10 = false, o10 = [];
    for (let p = 0; p < e11.length; p++) {
      let h = e11[p];
      if (h === "-d")
        n10 = e11[++p] || "	";
      else if (h.startsWith("-d"))
        n10 = h.slice(2);
      else if (h === "-f")
        r10 = e11[++p];
      else if (h.startsWith("-f"))
        r10 = h.slice(2);
      else if (h === "-c")
        s10 = e11[++p];
      else if (h.startsWith("-c"))
        s10 = h.slice(2);
      else if (h === "-s" || h === "--only-delimited")
        i10 = true;
      else {
        if (h.startsWith("--"))
          return Y("cut", h);
        if (h.startsWith("-")) {
          let m = false;
          for (let d of h.slice(1))
            if (d === "s")
              i10 = true;
            else if (!"dfc".includes(d)) {
              m = true;
              break;
            }
          if (m)
            return Y("cut", h);
        } else
          o10.push(h);
      }
    }
    if (!r10 && !s10)
      return { stdout: "", stderr: `cut: you must specify a list of bytes, characters, or fields
`, exitCode: 1 };
    let a = await cr(t10, o10, { cmdName: "cut" });
    if (!a.ok)
      return a.error;
    let c = a.content.split(`
`);
    c.length > 0 && c[c.length - 1] === "" && c.pop();
    let u = vy(r10 || s10 || "1"), f10 = "";
    for (let p of c)
      if (s10) {
        let h = p.split(""), m = [];
        for (let d of u) {
          let g = d.start - 1, y = d.end === null ? h.length : d.end;
          for (let w = g; w < y && w < h.length; w++)
            w >= 0 && m.push(h[w]);
        }
        f10 += `${m.join("")}
`;
      } else {
        if (i10 && !p.includes(n10))
          continue;
        let h = p.split(n10), m = Iy(h, u);
        f10 += `${m.join(n10)}
`;
      }
    return { stdout: f10, stderr: "", exitCode: 0 };
  } }, Ry = { name: "cut", flags: [{ flag: "-d", type: "value", valueHint: "delimiter" }, { flag: "-f", type: "value", valueHint: "string" }, { flag: "-c", type: "value", valueHint: "string" }, { flag: "-s", type: "boolean" }], stdinType: "text", needsFiles: true };
});
var sp = {};
Q(sp, { flagsForFuzzing: () => Dy, pasteCommand: () => Py });
function rp(e11, t10) {
  if (e11.length === 0)
    return "";
  if (e11.length === 1)
    return e11[0];
  let n10 = e11[0];
  for (let r10 = 1; r10 < e11.length; r10++) {
    let s10 = (r10 - 1) % t10.length;
    n10 += t10[s10] + e11[r10];
  }
  return n10;
}
var $y;
var Ty;
var Py;
var Dy;
var ip = I(() => {
  "use strict";
  qe();
  se();
  $y = { name: "paste", summary: "merge lines of files", usage: "paste [OPTION]... [FILE]...", description: ["Write lines consisting of the sequentially corresponding lines from", "each FILE, separated by TABs, to standard output.", "", "With no FILE, or when FILE is -, read standard input."], options: ["-d, --delimiters=LIST   reuse characters from LIST instead of TABs", "-s, --serial            paste one file at a time instead of in parallel", "    --help              display this help and exit"], examples: ["paste file1 file2       Merge file1 and file2 side by side", "paste -d, file1 file2   Use comma as delimiter", "paste -s file1          Paste all lines of file1 on one line", "paste - - < file        Paste pairs of lines from file"] }, Ty = { delimiter: { short: "d", long: "delimiters", type: "string", default: "	" }, serial: { short: "s", long: "serial", type: "boolean" } }, Py = { name: "paste", async execute(e11, t10) {
    if (U2(e11))
      return M($y);
    let n10 = be("paste", e11, Ty);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.delimiter, s10 = n10.result.flags.serial, i10 = n10.result.positional;
    if (i10.length === 0)
      return { stdout: "", stderr: `usage: paste [-s] [-d delimiters] file ...
`, exitCode: 1 };
    let o10 = t10.stdin ? t10.stdin.split(`
`) : [""];
    o10.length > 0 && o10[o10.length - 1] === "" && o10.pop();
    let a = i10.filter((f10) => f10 === "-").length, l = [], c = 0;
    for (let f10 of i10)
      if (f10 === "-") {
        let p = [];
        for (let h = c; h < o10.length; h += a)
          p.push(o10[h]);
        l.push(p), c++;
      } else {
        let p = t10.fs.resolvePath(t10.cwd, f10);
        try {
          let m = (await t10.fs.readFile(p)).split(`
`);
          m.length > 0 && m[m.length - 1] === "" && m.pop(), l.push(m);
        } catch {
          return { stdout: "", stderr: `paste: ${f10}: No such file or directory
`, exitCode: 1 };
        }
      }
    let u = "";
    if (s10)
      for (let f10 of l)
        f10 && (u += `${rp(f10, r10)}
`);
    else {
      let f10 = Math.max(...l.map((p) => p?.length ?? 0));
      for (let p = 0; p < f10; p++) {
        let h = [];
        for (let m of l)
          h.push(m?.[p] ?? "");
        u += `${rp(h, r10)}
`;
      }
    }
    return { stdout: u, stderr: "", exitCode: 0 };
  } };
  Dy = { name: "paste", flags: [{ flag: "-d", type: "value", valueHint: "delimiter" }, { flag: "-s", type: "boolean" }], stdinType: "text", needsFiles: true };
});
var ap = {};
Q(ap, { flagsForFuzzing: () => Uy, trCommand: () => My });
function op(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; ) {
    if (e11[n10] === "[" && e11[n10 + 1] === ":") {
      let r10 = false;
      for (let [s10, i10] of Ly)
        if (e11.slice(n10).startsWith(s10)) {
          t10 += i10, n10 += s10.length, r10 = true;
          break;
        }
      if (r10)
        continue;
    }
    if (e11[n10] === "\\" && n10 + 1 < e11.length) {
      let r10 = e11[n10 + 1];
      r10 === "n" ? t10 += `
` : r10 === "t" ? t10 += "	" : r10 === "r" ? t10 += "\r" : t10 += r10, n10 += 2;
      continue;
    }
    if (n10 + 2 < e11.length && e11[n10 + 1] === "-") {
      let r10 = e11.charCodeAt(n10), s10 = e11.charCodeAt(n10 + 2);
      for (let i10 = r10; i10 <= s10; i10++)
        t10 += String.fromCharCode(i10);
      n10 += 3;
      continue;
    }
    t10 += e11[n10], n10++;
  }
  return t10;
}
var _y;
var Ly;
var Fy;
var My;
var Uy;
var lp = I(() => {
  "use strict";
  qe();
  se();
  _y = { name: "tr", summary: "translate or delete characters", usage: "tr [OPTION]... SET1 [SET2]", options: ["-c, -C, --complement   use the complement of SET1", "-d, --delete           delete characters in SET1", "-s, --squeeze-repeats  squeeze repeated characters", "    --help             display this help and exit"], description: `SET syntax:
  a-z         character range
  [:alnum:]   all letters and digits
  [:alpha:]   all letters
  [:digit:]   all digits
  [:lower:]   all lowercase letters
  [:upper:]   all uppercase letters
  [:space:]   all whitespace
  [:blank:]   horizontal whitespace
  [:punct:]   all punctuation
  [:print:]   all printable characters
  [:graph:]   all printable characters except space
  [:cntrl:]   all control characters
  [:xdigit:]  all hexadecimal digits
  \\n, \\t, \\r  escape sequences` }, Ly = /* @__PURE__ */ new Map([["[:alnum:]", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"], ["[:alpha:]", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"], ["[:blank:]", " 	"], ["[:cntrl:]", Array.from({ length: 32 }, (e11, t10) => String.fromCharCode(t10)).join("").concat("\x7F")], ["[:digit:]", "0123456789"], ["[:graph:]", Array.from({ length: 94 }, (e11, t10) => String.fromCharCode(33 + t10)).join("")], ["[:lower:]", "abcdefghijklmnopqrstuvwxyz"], ["[:print:]", Array.from({ length: 95 }, (e11, t10) => String.fromCharCode(32 + t10)).join("")], ["[:punct:]", "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"], ["[:space:]", ` 	
\r\f\v`], ["[:upper:]", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"], ["[:xdigit:]", "0123456789ABCDEFabcdef"]]);
  Fy = { complement: { short: "c", long: "complement", type: "boolean" }, complementUpper: { short: "C", type: "boolean" }, delete: { short: "d", long: "delete", type: "boolean" }, squeeze: { short: "s", long: "squeeze-repeats", type: "boolean" } }, My = { name: "tr", async execute(e11, t10) {
    if (U2(e11))
      return M(_y);
    let n10 = be("tr", e11, Fy);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.complement || n10.result.flags.complementUpper, s10 = n10.result.flags.delete, i10 = n10.result.flags.squeeze, o10 = n10.result.positional;
    if (o10.length < 1)
      return { stdout: "", stderr: `tr: missing operand
`, exitCode: 1 };
    if (!s10 && !i10 && o10.length < 2)
      return { stdout: "", stderr: `tr: missing operand after SET1
`, exitCode: 1 };
    let a = op(o10[0]), l = o10.length > 1 ? op(o10[1]) : "", c = t10.stdin, u = (p) => {
      let h = a.includes(p);
      return r10 ? !h : h;
    }, f10 = "";
    if (s10)
      for (let p of c)
        u(p) || (f10 += p);
    else if (i10 && o10.length === 1) {
      let p = "";
      for (let h of c)
        u(h) && h === p || (f10 += h, p = h);
    } else {
      if (r10) {
        let p = l.length > 0 ? l[l.length - 1] : "";
        for (let h of c)
          a.includes(h) ? f10 += h : f10 += p;
      } else {
        let p = /* @__PURE__ */ new Map();
        for (let h = 0; h < a.length; h++) {
          let m = h < l.length ? l[h] : l[l.length - 1];
          p.set(a[h], m);
        }
        for (let h of c)
          f10 += p.get(h) ?? h;
      }
      if (i10) {
        let p = "", h = "";
        for (let m of f10)
          l.includes(m) && m === h || (p += m, h = m);
        f10 = p;
      }
    }
    return { stdout: f10, stderr: "", exitCode: 0 };
  } }, Uy = { name: "tr", flags: [{ flag: "-c", type: "boolean" }, { flag: "-C", type: "boolean" }, { flag: "-d", type: "boolean" }, { flag: "-s", type: "boolean" }], stdinType: "text", needsArgs: true };
});
var cp = {};
Q(cp, { flagsForFuzzing: () => Hy, rev: () => zy });
function By(e11) {
  return Array.from(e11).reverse().join("");
}
var Wy;
var zy;
var Hy;
var up = I(() => {
  "use strict";
  se();
  Wy = { name: "rev", summary: "reverse lines characterwise", usage: "rev [file ...]", description: "Copies the specified files to standard output, reversing the order of characters in every line. If no files are specified, standard input is read.", examples: ["echo 'hello' | rev     # Output: olleh", "rev file.txt           # Reverse each line in file"] };
  zy = { name: "rev", execute: async (e11, t10) => {
    if (U2(e11))
      return M(Wy);
    let n10 = [];
    for (let i10 of e11)
      if (i10 === "--") {
        let o10 = e11.indexOf(i10);
        n10.push(...e11.slice(o10 + 1));
        break;
      } else {
        if (i10.startsWith("-") && i10 !== "-")
          return Y("rev", i10);
        n10.push(i10);
      }
    let r10 = "", s10 = (i10) => {
      let o10 = i10.split(`
`), a = i10.endsWith(`
`) && o10[o10.length - 1] === "";
      return a && o10.pop(), o10.map(By).join(`
`) + (a ? `
` : "");
    };
    if (n10.length === 0) {
      let i10 = t10.stdin ?? "";
      r10 = s10(i10);
    } else
      for (let i10 of n10)
        if (i10 === "-") {
          let o10 = t10.stdin ?? "";
          r10 += s10(o10);
        } else {
          let o10 = t10.fs.resolvePath(t10.cwd, i10), a = await t10.fs.readFile(o10);
          if (a === null)
            return { exitCode: 1, stdout: r10, stderr: `rev: ${i10}: No such file or directory
` };
          r10 += s10(a);
        }
    return { exitCode: 0, stdout: r10, stderr: "" };
  } }, Hy = { name: "rev", flags: [], stdinType: "text", needsFiles: true };
});
var pp2 = {};
Q(pp2, { flagsForFuzzing: () => Zy, nl: () => qy });
function Gy(e11, t10, n10) {
  let r10 = String(e11);
  switch (t10) {
    case "ln":
      return r10.padEnd(n10);
    case "rn":
      return r10.padStart(n10);
    case "rz":
      return r10.padStart(n10, "0");
    default:
      return t10;
  }
}
function Vy(e11, t10) {
  switch (t10) {
    case "a":
      return true;
    case "t":
      return e11.trim().length > 0;
    case "n":
      return false;
    default:
      return t10;
  }
}
function fp(e11, t10, n10) {
  if (e11 === "")
    return { output: "", nextNumber: n10 };
  let r10 = e11.split(`
`), s10 = [], i10 = n10, o10 = e11.endsWith(`
`) && r10[r10.length - 1] === "";
  o10 && r10.pop();
  for (let a of r10)
    if (Vy(a, t10.bodyStyle)) {
      let l = Gy(i10, t10.numberFormat, t10.width);
      s10.push(`${l}${t10.separator}${a}`), i10 += t10.increment;
    } else {
      let l = " ".repeat(t10.width);
      s10.push(`${l}${t10.separator}${a}`);
    }
  return { output: s10.join(`
`) + (o10 ? `
` : ""), nextNumber: i10 };
}
var jy;
var qy;
var Zy;
var hp = I(() => {
  "use strict";
  se();
  jy = { name: "nl", summary: "number lines of files", usage: "nl [OPTION]... [FILE]...", description: "Write each FILE to standard output, with line numbers added. If no FILE is specified, standard input is read.", options: ["-b STYLE     Body numbering style: a (all), t (non-empty), n (none)", "-n FORMAT    Number format: ln (left), rn (right), rz (right zeros)", "-w WIDTH     Number width (default: 6)", "-s SEP       Separator after number (default: TAB)", "-v START     Starting line number (default: 1)", "-i INCR      Line number increment (default: 1)"], examples: ["nl file.txt              # Number non-empty lines", "nl -ba file.txt          # Number all lines", "nl -n rz -w 3 file.txt   # Right-justified with zeros", "nl -s ': ' file.txt      # Use ': ' as separator"] };
  qy = { name: "nl", execute: async (e11, t10) => {
    if (U2(e11))
      return M(jy);
    let n10 = { bodyStyle: "t", numberFormat: "rn", width: 6, separator: "	", startNumber: 1, increment: 1 }, r10 = [], s10 = 0;
    for (; s10 < e11.length; ) {
      let a = e11[s10];
      if (a === "-b" && s10 + 1 < e11.length) {
        let l = e11[s10 + 1];
        if (l !== "a" && l !== "t" && l !== "n")
          return { exitCode: 1, stdout: "", stderr: `nl: invalid body numbering style: '${l}'
` };
        n10.bodyStyle = l, s10 += 2;
      } else if (a.startsWith("-b")) {
        let l = a.slice(2);
        if (l !== "a" && l !== "t" && l !== "n")
          return { exitCode: 1, stdout: "", stderr: `nl: invalid body numbering style: '${l}'
` };
        n10.bodyStyle = l, s10++;
      } else if (a === "-n" && s10 + 1 < e11.length) {
        let l = e11[s10 + 1];
        if (l !== "ln" && l !== "rn" && l !== "rz")
          return { exitCode: 1, stdout: "", stderr: `nl: invalid line numbering format: '${l}'
` };
        n10.numberFormat = l, s10 += 2;
      } else if (a.startsWith("-n")) {
        let l = a.slice(2);
        if (l !== "ln" && l !== "rn" && l !== "rz")
          return { exitCode: 1, stdout: "", stderr: `nl: invalid line numbering format: '${l}'
` };
        n10.numberFormat = l, s10++;
      } else if (a === "-w" && s10 + 1 < e11.length) {
        let l = parseInt(e11[s10 + 1], 10);
        if (Number.isNaN(l) || l < 1)
          return { exitCode: 1, stdout: "", stderr: `nl: invalid line number field width: '${e11[s10 + 1]}'
` };
        n10.width = l, s10 += 2;
      } else if (a.startsWith("-w")) {
        let l = parseInt(a.slice(2), 10);
        if (Number.isNaN(l) || l < 1)
          return { exitCode: 1, stdout: "", stderr: `nl: invalid line number field width: '${a.slice(2)}'
` };
        n10.width = l, s10++;
      } else if (a === "-s" && s10 + 1 < e11.length)
        n10.separator = e11[s10 + 1], s10 += 2;
      else if (a.startsWith("-s"))
        n10.separator = a.slice(2), s10++;
      else if (a === "-v" && s10 + 1 < e11.length) {
        let l = parseInt(e11[s10 + 1], 10);
        if (Number.isNaN(l))
          return { exitCode: 1, stdout: "", stderr: `nl: invalid starting line number: '${e11[s10 + 1]}'
` };
        n10.startNumber = l, s10 += 2;
      } else if (a.startsWith("-v")) {
        let l = parseInt(a.slice(2), 10);
        if (Number.isNaN(l))
          return { exitCode: 1, stdout: "", stderr: `nl: invalid starting line number: '${a.slice(2)}'
` };
        n10.startNumber = l, s10++;
      } else if (a === "-i" && s10 + 1 < e11.length) {
        let l = parseInt(e11[s10 + 1], 10);
        if (Number.isNaN(l))
          return { exitCode: 1, stdout: "", stderr: `nl: invalid line number increment: '${e11[s10 + 1]}'
` };
        n10.increment = l, s10 += 2;
      } else if (a.startsWith("-i")) {
        let l = parseInt(a.slice(2), 10);
        if (Number.isNaN(l))
          return { exitCode: 1, stdout: "", stderr: `nl: invalid line number increment: '${a.slice(2)}'
` };
        n10.increment = l, s10++;
      } else if (a === "--") {
        r10.push(...e11.slice(s10 + 1));
        break;
      } else {
        if (a.startsWith("-") && a !== "-")
          return Y("nl", a);
        r10.push(a), s10++;
      }
    }
    let i10 = "", o10 = n10.startNumber;
    if (r10.length === 0) {
      let a = t10.stdin ?? "";
      i10 = fp(a, n10, o10).output;
    } else
      for (let a of r10) {
        let l = t10.fs.resolvePath(t10.cwd, a), c = await t10.fs.readFile(l);
        if (c === null)
          return { exitCode: 1, stdout: i10, stderr: `nl: ${a}: No such file or directory
` };
        let u = fp(c, n10, o10);
        i10 += u.output, o10 = u.nextNumber;
      }
    return { exitCode: 0, stdout: i10, stderr: "" };
  } }, Zy = { name: "nl", flags: [{ flag: "-b", type: "value", valueHint: "string" }, { flag: "-n", type: "value", valueHint: "string" }, { flag: "-w", type: "value", valueHint: "number" }, { flag: "-s", type: "value", valueHint: "string" }, { flag: "-v", type: "value", valueHint: "number" }, { flag: "-i", type: "value", valueHint: "number" }], stdinType: "text", needsFiles: true };
});
var mp = {};
Q(mp, { flagsForFuzzing: () => Jy, fold: () => Yy });
function Ky(e11, t10, n10) {
  return n10 ? new TextEncoder().encode(e11).length : e11 === "	" ? 8 - t10 % 8 : e11 === "\b" ? -1 : 1;
}
function Xy(e11, t10) {
  if (e11.length === 0)
    return e11;
  let { width: n10, breakAtSpaces: r10, countBytes: s10 } = t10, i10 = [], o10 = "", a = 0, l = -1, c = 0;
  for (let u = 0; u < e11.length; u++) {
    let f10 = e11[u], p = Ky(f10, a, s10);
    a + p > n10 && o10.length > 0 ? r10 && l >= 0 ? (i10.push(o10.slice(0, l + 1)), o10 = o10.slice(l + 1) + f10, a = a - c - 1 + p, l = -1, c = 0) : (i10.push(o10), o10 = f10, a = p, l = -1, c = 0) : (o10 += f10, a += p, (f10 === " " || f10 === "	") && (l = o10.length - 1, c = a - p));
  }
  return o10.length > 0 && i10.push(o10), i10.join(`
`);
}
function dp(e11, t10) {
  if (e11 === "")
    return "";
  let n10 = e11.split(`
`), r10 = e11.endsWith(`
`) && n10[n10.length - 1] === "";
  return r10 && n10.pop(), n10.map((i10) => Xy(i10, t10)).join(`
`) + (r10 ? `
` : "");
}
var Qy;
var Yy;
var Jy;
var gp = I(() => {
  "use strict";
  se();
  Qy = { name: "fold", summary: "wrap each input line to fit in specified width", usage: "fold [OPTION]... [FILE]...", description: "Wrap input lines in each FILE, writing to standard output. If no FILE is specified, standard input is read.", options: ["-w WIDTH    Use WIDTH columns instead of 80", "-s          Break at spaces", "-b          Count bytes rather than columns"], examples: ["fold -w 40 file.txt           # Wrap at 40 columns", "fold -sw 40 file.txt          # Word wrap at 40 columns", "echo 'long line' | fold -w 5  # Force wrap at 5"] };
  Yy = { name: "fold", execute: async (e11, t10) => {
    if (U2(e11))
      return M(Qy);
    let n10 = { width: 80, breakAtSpaces: false, countBytes: false }, r10 = [], s10 = 0;
    for (; s10 < e11.length; ) {
      let o10 = e11[s10];
      if (o10 === "-w" && s10 + 1 < e11.length) {
        let a = parseInt(e11[s10 + 1], 10);
        if (Number.isNaN(a) || a < 1)
          return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${e11[s10 + 1]}'
` };
        n10.width = a, s10 += 2;
      } else if (o10.startsWith("-w") && o10.length > 2) {
        let a = parseInt(o10.slice(2), 10);
        if (Number.isNaN(a) || a < 1)
          return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${o10.slice(2)}'
` };
        n10.width = a, s10++;
      } else if (o10 === "-s")
        n10.breakAtSpaces = true, s10++;
      else if (o10 === "-b")
        n10.countBytes = true, s10++;
      else if (o10 === "-bs" || o10 === "-sb")
        n10.breakAtSpaces = true, n10.countBytes = true, s10++;
      else if (o10.match(/^-[sb]+w\d+$/)) {
        o10.includes("s") && (n10.breakAtSpaces = true), o10.includes("b") && (n10.countBytes = true);
        let a = o10.replace(/^-[sb]+w/, ""), l = parseInt(a, 10);
        if (Number.isNaN(l) || l < 1)
          return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${a}'
` };
        n10.width = l, s10++;
      } else if (o10.match(/^-[sb]+w$/) && s10 + 1 < e11.length) {
        o10.includes("s") && (n10.breakAtSpaces = true), o10.includes("b") && (n10.countBytes = true);
        let a = parseInt(e11[s10 + 1], 10);
        if (Number.isNaN(a) || a < 1)
          return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${e11[s10 + 1]}'
` };
        n10.width = a, s10 += 2;
      } else if (o10 === "--") {
        r10.push(...e11.slice(s10 + 1));
        break;
      } else if (o10.startsWith("-") && o10 !== "-") {
        let a = o10.slice(1), l = false;
        for (let c of a)
          if (c === "s")
            n10.breakAtSpaces = true;
          else if (c === "b")
            n10.countBytes = true;
          else {
            l = true;
            break;
          }
        if (l)
          return Y("fold", o10);
        s10++;
      } else
        r10.push(o10), s10++;
    }
    let i10 = "";
    if (r10.length === 0) {
      let o10 = t10.stdin ?? "";
      i10 = dp(o10, n10);
    } else
      for (let o10 of r10) {
        let a = t10.fs.resolvePath(t10.cwd, o10), l = await t10.fs.readFile(a);
        if (l === null)
          return { exitCode: 1, stdout: i10, stderr: `fold: ${o10}: No such file or directory
` };
        i10 += dp(l, n10);
      }
    return { exitCode: 0, stdout: i10, stderr: "" };
  } }, Jy = { name: "fold", flags: [{ flag: "-w", type: "value", valueHint: "number" }, { flag: "-s", type: "boolean" }, { flag: "-b", type: "boolean" }], stdinType: "text", needsFiles: true };
});
var wp = {};
Q(wp, { expand: () => r8, flagsForFuzzing: () => s8 });
function fi(e11) {
  let t10 = e11.split(",").map((r10) => r10.trim()), n10 = [];
  for (let r10 of t10) {
    let s10 = parseInt(r10, 10);
    if (Number.isNaN(s10) || s10 < 1)
      return null;
    n10.push(s10);
  }
  for (let r10 = 1; r10 < n10.length; r10++)
    if (n10[r10] <= n10[r10 - 1])
      return null;
  return n10;
}
function t8(e11, t10) {
  if (t10.length === 1) {
    let n10 = t10[0];
    return n10 - e11 % n10;
  }
  for (let n10 of t10)
    if (n10 > e11)
      return n10 - e11;
  if (t10.length >= 2) {
    let n10 = t10[t10.length - 1] - t10[t10.length - 2], r10 = t10[t10.length - 1], s10 = Math.floor((e11 - r10) / n10) + 1;
    return r10 + s10 * n10 - e11;
  }
  return 1;
}
function n8(e11, t10) {
  let { tabStops: n10, leadingOnly: r10 } = t10, s10 = "", i10 = 0, o10 = true;
  for (let a of e11)
    if (a === "	")
      if (r10 && !o10)
        s10 += a, i10++;
      else {
        let l = t8(i10, n10);
        s10 += " ".repeat(l), i10 += l;
      }
    else
      a !== " " && a !== "	" && (o10 = false), s10 += a, i10++;
  return s10;
}
function yp(e11, t10) {
  if (e11 === "")
    return "";
  let n10 = e11.split(`
`), r10 = e11.endsWith(`
`) && n10[n10.length - 1] === "";
  return r10 && n10.pop(), n10.map((i10) => n8(i10, t10)).join(`
`) + (r10 ? `
` : "");
}
var e8;
var r8;
var s8;
var bp = I(() => {
  "use strict";
  se();
  e8 = { name: "expand", summary: "convert tabs to spaces", usage: "expand [OPTION]... [FILE]...", description: "Convert TABs in each FILE to spaces, writing to standard output. If no FILE is specified, standard input is read.", options: ["-t N        Use N spaces per tab (default: 8)", "-t LIST     Use comma-separated list of tab stops", "-i          Only convert leading tabs on each line"], examples: ["expand file.txt             # Convert all tabs to 8 spaces", "expand -t 4 file.txt        # Use 4-space tabs", "expand -t 4,8,12 file.txt   # Custom tab stops"] };
  r8 = { name: "expand", execute: async (e11, t10) => {
    if (U2(e11))
      return M(e8);
    let n10 = { tabStops: [8], leadingOnly: false }, r10 = [], s10 = 0;
    for (; s10 < e11.length; ) {
      let o10 = e11[s10];
      if (o10 === "-t" && s10 + 1 < e11.length) {
        let a = fi(e11[s10 + 1]);
        if (!a)
          return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${e11[s10 + 1]}'
` };
        n10.tabStops = a, s10 += 2;
      } else if (o10.startsWith("-t") && o10.length > 2) {
        let a = fi(o10.slice(2));
        if (!a)
          return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${o10.slice(2)}'
` };
        n10.tabStops = a, s10++;
      } else if (o10 === "--tabs" && s10 + 1 < e11.length) {
        let a = fi(e11[s10 + 1]);
        if (!a)
          return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${e11[s10 + 1]}'
` };
        n10.tabStops = a, s10 += 2;
      } else if (o10.startsWith("--tabs=")) {
        let a = fi(o10.slice(7));
        if (!a)
          return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${o10.slice(7)}'
` };
        n10.tabStops = a, s10++;
      } else if (o10 === "-i" || o10 === "--initial")
        n10.leadingOnly = true, s10++;
      else if (o10 === "--") {
        r10.push(...e11.slice(s10 + 1));
        break;
      } else {
        if (o10.startsWith("-") && o10 !== "-")
          return Y("expand", o10);
        r10.push(o10), s10++;
      }
    }
    let i10 = "";
    if (r10.length === 0) {
      let o10 = t10.stdin ?? "";
      i10 = yp(o10, n10);
    } else
      for (let o10 of r10) {
        let a = t10.fs.resolvePath(t10.cwd, o10), l = await t10.fs.readFile(a);
        if (l === null)
          return { exitCode: 1, stdout: i10, stderr: `expand: ${o10}: No such file or directory
` };
        i10 += yp(l, n10);
      }
    return { exitCode: 0, stdout: i10, stderr: "" };
  } }, s8 = { name: "expand", flags: [{ flag: "-t", type: "value", valueHint: "number" }, { flag: "-i", type: "boolean" }], stdinType: "text", needsFiles: true };
});
var Ap = {};
Q(Ap, { flagsForFuzzing: () => l8, unexpand: () => a8 });
function pi(e11) {
  let t10 = e11.split(",").map((r10) => r10.trim()), n10 = [];
  for (let r10 of t10) {
    let s10 = parseInt(r10, 10);
    if (Number.isNaN(s10) || s10 < 1)
      return null;
    n10.push(s10);
  }
  for (let r10 = 1; r10 < n10.length; r10++)
    if (n10[r10] <= n10[r10 - 1])
      return null;
  return n10;
}
function xp(e11, t10) {
  if (t10.length === 1) {
    let n10 = t10[0];
    return e11 + (n10 - e11 % n10);
  }
  for (let n10 of t10)
    if (n10 > e11)
      return n10;
  if (t10.length >= 2) {
    let n10 = t10[t10.length - 1] - t10[t10.length - 2], r10 = t10[t10.length - 1], s10 = Math.floor((e11 - r10) / n10) + 1;
    return r10 + s10 * n10;
  }
  return -1;
}
function o8(e11, t10) {
  let { tabStops: n10, allBlanks: r10 } = t10, s10 = "", i10 = 0, o10 = "", a = 0, l = true, c = () => {
    if (o10.length === 0)
      return;
    let u = a + o10.length;
    if (!r10 && !l) {
      s10 += o10, o10 = "";
      return;
    }
    let f10 = a, p = "";
    for (; f10 < u; ) {
      let m = xp(f10, n10);
      if (m <= u && m > f10)
        p += "	", f10 = m;
      else
        break;
    }
    let h = u - f10;
    h > 0 && (p += " ".repeat(h)), s10 += p, o10 = "";
  };
  for (let u of e11)
    u === " " ? (o10.length === 0 && (a = i10), o10 += u, i10++) : u === "	" ? (c(), s10 += u, i10 = xp(i10, n10)) : (c(), s10 += u, i10++, l = false);
  return c(), s10;
}
function Ep(e11, t10) {
  if (e11 === "")
    return "";
  let n10 = e11.split(`
`), r10 = e11.endsWith(`
`) && n10[n10.length - 1] === "";
  return r10 && n10.pop(), n10.map((i10) => o8(i10, t10)).join(`
`) + (r10 ? `
` : "");
}
var i8;
var a8;
var l8;
var Sp = I(() => {
  "use strict";
  se();
  i8 = { name: "unexpand", summary: "convert spaces to tabs", usage: "unexpand [OPTION]... [FILE]...", description: "Convert blanks in each FILE to TABs, writing to standard output. If no FILE is specified, standard input is read.", options: ["-t N        Use N spaces per tab (default: 8)", "-t LIST     Use comma-separated list of tab stops", "-a          Convert all sequences of blanks (not just leading)"], examples: ["unexpand file.txt           # Convert leading spaces to tabs", "unexpand -a file.txt        # Convert all space sequences", "unexpand -t 4 file.txt      # Use 4-space tabs"] };
  a8 = { name: "unexpand", execute: async (e11, t10) => {
    if (U2(e11))
      return M(i8);
    let n10 = { tabStops: [8], allBlanks: false }, r10 = [], s10 = 0;
    for (; s10 < e11.length; ) {
      let o10 = e11[s10];
      if (o10 === "-t" && s10 + 1 < e11.length) {
        let a = pi(e11[s10 + 1]);
        if (!a)
          return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${e11[s10 + 1]}'
` };
        n10.tabStops = a, s10 += 2;
      } else if (o10.startsWith("-t") && o10.length > 2) {
        let a = pi(o10.slice(2));
        if (!a)
          return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${o10.slice(2)}'
` };
        n10.tabStops = a, s10++;
      } else if (o10 === "--tabs" && s10 + 1 < e11.length) {
        let a = pi(e11[s10 + 1]);
        if (!a)
          return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${e11[s10 + 1]}'
` };
        n10.tabStops = a, s10 += 2;
      } else if (o10.startsWith("--tabs=")) {
        let a = pi(o10.slice(7));
        if (!a)
          return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${o10.slice(7)}'
` };
        n10.tabStops = a, s10++;
      } else if (o10 === "-a" || o10 === "--all")
        n10.allBlanks = true, s10++;
      else if (o10 === "--") {
        r10.push(...e11.slice(s10 + 1));
        break;
      } else {
        if (o10.startsWith("-") && o10 !== "-")
          return Y("unexpand", o10);
        r10.push(o10), s10++;
      }
    }
    let i10 = "";
    if (r10.length === 0) {
      let o10 = t10.stdin ?? "";
      i10 = Ep(o10, n10);
    } else
      for (let o10 of r10) {
        let a = t10.fs.resolvePath(t10.cwd, o10), l = await t10.fs.readFile(a);
        if (l === null)
          return { exitCode: 1, stdout: i10, stderr: `unexpand: ${o10}: No such file or directory
` };
        i10 += Ep(l, n10);
      }
    return { exitCode: 0, stdout: i10, stderr: "" };
  } }, l8 = { name: "unexpand", flags: [{ flag: "-t", type: "value", valueHint: "number" }, { flag: "-a", type: "boolean" }], stdinType: "text", needsFiles: true };
});
var kp = {};
Q(kp, { flagsForFuzzing: () => p8, strings: () => f8 });
function u8(e11) {
  return e11 >= 32 && e11 <= 126 || e11 === 9;
}
function Cp(e11, t10) {
  if (t10 === null)
    return "";
  switch (t10) {
    case "o":
      return `${e11.toString(8).padStart(7, " ")} `;
    case "x":
      return `${e11.toString(16).padStart(7, " ")} `;
    case "d":
      return `${e11.toString(10).padStart(7, " ")} `;
    default:
      return t10;
  }
}
function Np(e11, t10) {
  let n10 = [], r10 = "", s10 = 0, i10 = typeof e11 == "string" ? new TextEncoder().encode(e11) : e11;
  for (let o10 = 0; o10 < i10.length; o10++) {
    let a = i10[o10];
    if (u8(a))
      r10.length === 0 && (s10 = o10), r10 += String.fromCharCode(a);
    else {
      if (r10.length >= t10.minLength) {
        let l = Cp(s10, t10.offsetFormat);
        n10.push(`${l}${r10}`);
      }
      r10 = "";
    }
  }
  if (r10.length >= t10.minLength) {
    let o10 = Cp(s10, t10.offsetFormat);
    n10.push(`${o10}${r10}`);
  }
  return n10;
}
var c8;
var f8;
var p8;
var vp = I(() => {
  "use strict";
  se();
  c8 = { name: "strings", summary: "print the sequences of printable characters in files", usage: "strings [OPTION]... [FILE]...", description: "For each FILE, print the printable character sequences that are at least MIN characters long. If no FILE is specified, standard input is read.", options: ["-n MIN       Print sequences of at least MIN characters (default: 4)", "-t FORMAT    Print offset before each string (o=octal, x=hex, d=decimal)", "-a           Scan the entire file (default behavior)", "-e ENCODING  Select character encoding (s=7-bit, S=8-bit)"], examples: ["strings file.bin          # Extract strings (min 4 chars)", "strings -n 8 file.bin     # Extract strings (min 8 chars)", "strings -t x file.bin     # Show hex offset", "echo 'hello' | strings    # Read from stdin"] };
  f8 = { name: "strings", execute: async (e11, t10) => {
    if (U2(e11))
      return M(c8);
    let n10 = { minLength: 4, offsetFormat: null }, r10 = [], s10 = 0;
    for (; s10 < e11.length; ) {
      let o10 = e11[s10];
      if (o10 === "-n" && s10 + 1 < e11.length) {
        let a = Number.parseInt(e11[s10 + 1], 10);
        if (Number.isNaN(a) || a < 1)
          return { exitCode: 1, stdout: "", stderr: `strings: invalid minimum string length: '${e11[s10 + 1]}'
` };
        n10.minLength = a, s10 += 2;
      } else if (o10.match(/^-n\d+$/)) {
        let a = Number.parseInt(o10.slice(2), 10);
        if (Number.isNaN(a) || a < 1)
          return { exitCode: 1, stdout: "", stderr: `strings: invalid minimum string length: '${o10.slice(2)}'
` };
        n10.minLength = a, s10++;
      } else if (o10.match(/^-\d+$/)) {
        let a = Number.parseInt(o10.slice(1), 10);
        if (Number.isNaN(a) || a < 1)
          return { exitCode: 1, stdout: "", stderr: `strings: invalid minimum string length: '${o10.slice(1)}'
` };
        n10.minLength = a, s10++;
      } else if (o10 === "-t" && s10 + 1 < e11.length) {
        let a = e11[s10 + 1];
        if (a !== "o" && a !== "x" && a !== "d")
          return { exitCode: 1, stdout: "", stderr: `strings: invalid radix: '${a}'
` };
        n10.offsetFormat = a, s10 += 2;
      } else if (o10.startsWith("-t") && o10.length === 3) {
        let a = o10[2];
        if (a !== "o" && a !== "x" && a !== "d")
          return { exitCode: 1, stdout: "", stderr: `strings: invalid radix: '${a}'
` };
        n10.offsetFormat = a, s10++;
      } else if (o10 === "-a" || o10 === "--all" || o10 === "-")
        o10 === "-" && r10.push(o10), s10++;
      else if (o10 === "-e" && s10 + 1 < e11.length) {
        let a = e11[s10 + 1];
        if (a !== "s" && a !== "S")
          return { exitCode: 1, stdout: "", stderr: `strings: invalid encoding: '${a}'
` };
        s10 += 2;
      } else if (o10.startsWith("-e") && o10.length === 3) {
        let a = o10[2];
        if (a !== "s" && a !== "S")
          return { exitCode: 1, stdout: "", stderr: `strings: invalid encoding: '${a}'
` };
        s10++;
      } else if (o10 === "--") {
        r10.push(...e11.slice(s10 + 1));
        break;
      } else {
        if (o10.startsWith("-") && o10 !== "-")
          return Y("strings", o10);
        r10.push(o10), s10++;
      }
    }
    let i10 = "";
    if (r10.length === 0) {
      let o10 = t10.stdin ?? "", a = Np(o10, n10);
      i10 = a.length > 0 ? `${a.join(`
`)}
` : "";
    } else
      for (let o10 of r10) {
        let a;
        if (o10 === "-")
          a = t10.stdin ?? "";
        else {
          let c = t10.fs.resolvePath(t10.cwd, o10);
          if (a = await t10.fs.readFile(c), a === null)
            return { exitCode: 1, stdout: i10, stderr: `strings: ${o10}: No such file or directory
` };
        }
        let l = Np(a, n10);
        l.length > 0 && (i10 += `${l.join(`
`)}
`);
      }
    return { exitCode: 0, stdout: i10, stderr: "" };
  } }, p8 = { name: "strings", flags: [{ flag: "-n", type: "value", valueHint: "number" }, { flag: "-t", type: "value", valueHint: "string" }, { flag: "-a", type: "boolean" }, { flag: "-e", type: "value", valueHint: "string" }], stdinType: "text", needsFiles: true };
});
var Op = {};
Q(Op, { flagsForFuzzing: () => b8, split: () => w8 });
function Ip(e11) {
  let t10 = e11.match(/^(\d+)([KMGTPEZY]?)([B]?)$/i);
  if (!t10)
    return null;
  let n10 = Number.parseInt(t10[1], 10);
  if (Number.isNaN(n10) || n10 < 1)
    return null;
  let r10 = (t10[2] || "").toUpperCase(), i10 = (/* @__PURE__ */ new Map([["", 1], ["K", 1024], ["M", 1024 * 1024], ["G", 1024 * 1024 * 1024], ["T", 1024 * 1024 * 1024 * 1024], ["P", 1024 * 1024 * 1024 * 1024 * 1024]])).get(r10);
  return i10 === void 0 ? null : n10 * i10;
}
function d8(e11, t10, n10) {
  if (t10)
    return e11.toString().padStart(n10, "0");
  let r10 = "abcdefghijklmnopqrstuvwxyz", s10 = "", i10 = e11;
  for (let o10 = 0; o10 < n10; o10++)
    s10 = r10[i10 % 26] + s10, i10 = Math.floor(i10 / 26);
  return s10;
}
function m8(e11, t10) {
  let n10 = e11.split(`
`), r10 = e11.endsWith(`
`) && n10[n10.length - 1] === "";
  r10 && n10.pop();
  let s10 = [];
  for (let i10 = 0; i10 < n10.length; i10 += t10) {
    let o10 = n10.slice(i10, i10 + t10), l = i10 + t10 >= n10.length && !r10 ? o10.join(`
`) : `${o10.join(`
`)}
`;
    s10.push({ content: l, hasContent: true });
  }
  return s10;
}
function g8(e11, t10) {
  let r10 = new TextEncoder().encode(e11), s10 = new TextDecoder(), i10 = [];
  for (let o10 = 0; o10 < r10.length; o10 += t10) {
    let a = r10.slice(o10, o10 + t10);
    i10.push({ content: s10.decode(a), hasContent: a.length > 0 });
  }
  return i10;
}
function y8(e11, t10) {
  let r10 = new TextEncoder().encode(e11), s10 = new TextDecoder(), i10 = [], o10 = Math.ceil(r10.length / t10);
  for (let a = 0; a < t10; a++) {
    let l = a * o10, c = Math.min(l + o10, r10.length), u = r10.slice(l, c);
    i10.push({ content: s10.decode(u), hasContent: u.length > 0 });
  }
  return i10;
}
var h8;
var w8;
var b8;
var Rp = I(() => {
  "use strict";
  se();
  h8 = { name: "split", summary: "split a file into pieces", usage: "split [OPTION]... [FILE [PREFIX]]", description: "Output pieces of FILE to PREFIXaa, PREFIXab, ...; default size is 1000 lines, and default PREFIX is 'x'.", options: ["-l N         Put N lines per output file", "-b SIZE      Put SIZE bytes per output file (K, M, G suffixes)", "-n CHUNKS    Split into CHUNKS equal-sized files", "-d           Use numeric suffixes (00, 01, ...) instead of alphabetic", "-a LENGTH    Use suffixes of length LENGTH (default: 2)", "--additional-suffix=SUFFIX  Append SUFFIX to file names"], examples: ["split -l 100 file.txt        # Split into 100-line chunks", "split -b 1M file.bin         # Split into 1MB chunks", "split -n 5 file.txt          # Split into 5 equal parts", "split -d file.txt part_      # part_00, part_01, ...", "split -a 3 -d file.txt x     # x000, x001, ..."] };
  w8 = { name: "split", execute: async (e11, t10) => {
    if (U2(e11))
      return M(h8);
    let n10 = { mode: "lines", lines: 1e3, bytes: 0, chunks: 0, useNumericSuffix: false, suffixLength: 2, additionalSuffix: "" }, r10 = [], s10 = 0;
    for (; s10 < e11.length; ) {
      let c = e11[s10];
      if (c === "-l" && s10 + 1 < e11.length) {
        let u = Number.parseInt(e11[s10 + 1], 10);
        if (Number.isNaN(u) || u < 1)
          return { exitCode: 1, stdout: "", stderr: `split: invalid number of lines: '${e11[s10 + 1]}'
` };
        n10.mode = "lines", n10.lines = u, s10 += 2;
      } else if (c.match(/^-l\d+$/)) {
        let u = Number.parseInt(c.slice(2), 10);
        if (Number.isNaN(u) || u < 1)
          return { exitCode: 1, stdout: "", stderr: `split: invalid number of lines: '${c.slice(2)}'
` };
        n10.mode = "lines", n10.lines = u, s10++;
      } else if (c === "-b" && s10 + 1 < e11.length) {
        let u = Ip(e11[s10 + 1]);
        if (u === null)
          return { exitCode: 1, stdout: "", stderr: `split: invalid number of bytes: '${e11[s10 + 1]}'
` };
        n10.mode = "bytes", n10.bytes = u, s10 += 2;
      } else if (c.match(/^-b.+$/)) {
        let u = Ip(c.slice(2));
        if (u === null)
          return { exitCode: 1, stdout: "", stderr: `split: invalid number of bytes: '${c.slice(2)}'
` };
        n10.mode = "bytes", n10.bytes = u, s10++;
      } else if (c === "-n" && s10 + 1 < e11.length) {
        let u = Number.parseInt(e11[s10 + 1], 10);
        if (Number.isNaN(u) || u < 1)
          return { exitCode: 1, stdout: "", stderr: `split: invalid number of chunks: '${e11[s10 + 1]}'
` };
        n10.mode = "chunks", n10.chunks = u, s10 += 2;
      } else if (c.match(/^-n\d+$/)) {
        let u = Number.parseInt(c.slice(2), 10);
        if (Number.isNaN(u) || u < 1)
          return { exitCode: 1, stdout: "", stderr: `split: invalid number of chunks: '${c.slice(2)}'
` };
        n10.mode = "chunks", n10.chunks = u, s10++;
      } else if (c === "-a" && s10 + 1 < e11.length) {
        let u = Number.parseInt(e11[s10 + 1], 10);
        if (Number.isNaN(u) || u < 1)
          return { exitCode: 1, stdout: "", stderr: `split: invalid suffix length: '${e11[s10 + 1]}'
` };
        n10.suffixLength = u, s10 += 2;
      } else if (c.match(/^-a\d+$/)) {
        let u = Number.parseInt(c.slice(2), 10);
        if (Number.isNaN(u) || u < 1)
          return { exitCode: 1, stdout: "", stderr: `split: invalid suffix length: '${c.slice(2)}'
` };
        n10.suffixLength = u, s10++;
      } else if (c === "-d" || c === "--numeric-suffixes")
        n10.useNumericSuffix = true, s10++;
      else if (c.startsWith("--additional-suffix="))
        n10.additionalSuffix = c.slice(20), s10++;
      else if (c === "--additional-suffix" && s10 + 1 < e11.length)
        n10.additionalSuffix = e11[s10 + 1], s10 += 2;
      else if (c === "--") {
        r10.push(...e11.slice(s10 + 1));
        break;
      } else {
        if (c.startsWith("-") && c !== "-")
          return Y("split", c);
        r10.push(c), s10++;
      }
    }
    let i10 = "-", o10 = "x";
    r10.length >= 1 && (i10 = r10[0]), r10.length >= 2 && (o10 = r10[1]);
    let a;
    if (i10 === "-")
      a = t10.stdin ?? "";
    else {
      let c = t10.fs.resolvePath(t10.cwd, i10), u = await t10.fs.readFile(c);
      if (u === null)
        return { exitCode: 1, stdout: "", stderr: `split: ${i10}: No such file or directory
` };
      a = u;
    }
    if (a === "")
      return { exitCode: 0, stdout: "", stderr: "" };
    let l;
    switch (n10.mode) {
      case "lines":
        l = m8(a, n10.lines);
        break;
      case "bytes":
        l = g8(a, n10.bytes);
        break;
      case "chunks":
        l = y8(a, n10.chunks);
        break;
      default:
        return n10.mode;
    }
    for (let c = 0; c < l.length; c++) {
      let u = l[c];
      if (!u.hasContent)
        continue;
      let f10 = d8(c, n10.useNumericSuffix, n10.suffixLength), p = `${o10}${f10}${n10.additionalSuffix}`, h = t10.fs.resolvePath(t10.cwd, p);
      await t10.fs.writeFile(h, u.content);
    }
    return { exitCode: 0, stdout: "", stderr: "" };
  } }, b8 = { name: "split", flags: [{ flag: "-l", type: "value", valueHint: "number" }, { flag: "-b", type: "value", valueHint: "string" }, { flag: "-n", type: "value", valueHint: "number" }, { flag: "-d", type: "boolean" }, { flag: "-a", type: "value", valueHint: "number" }], needsFiles: true };
});
var Tp = {};
Q(Tp, { column: () => N8, flagsForFuzzing: () => k8 });
function $p(e11, t10, n10) {
  return t10 ? n10 ? e11.split(t10) : e11.split(t10).filter((r10) => r10.length > 0) : n10 ? e11.split(/[ \t]/) : e11.split(/[ \t]+/).filter((r10) => r10.length > 0);
}
function A8(e11) {
  let t10 = [];
  for (let n10 of e11)
    for (let r10 = 0; r10 < n10.length; r10++) {
      let s10 = n10[r10].length;
      (t10[r10] === void 0 || s10 > t10[r10]) && (t10[r10] = s10);
    }
  return t10;
}
function S8(e11, t10) {
  if (e11.length === 0)
    return "";
  let n10 = A8(e11), r10 = [];
  for (let s10 of e11) {
    let i10 = [];
    for (let o10 = 0; o10 < s10.length; o10++)
      o10 === s10.length - 1 ? i10.push(s10[o10]) : i10.push(s10[o10].padEnd(n10[o10]));
    r10.push(i10.join(t10));
  }
  return r10.join(`
`);
}
function C8(e11, t10, n10) {
  if (e11.length === 0)
    return "";
  let r10 = Math.max(...e11.map((c) => c.length)), s10 = n10.length, i10 = r10 + s10, o10 = Math.max(1, Math.floor((t10 + s10) / i10)), a = Math.ceil(e11.length / o10), l = [];
  for (let c = 0; c < a; c++) {
    let u = [];
    for (let f10 = 0; f10 < o10; f10++) {
      let p = f10 * a + c;
      p < e11.length && (f10 === o10 - 1 || (f10 + 1) * a + c >= e11.length ? u.push(e11[p]) : u.push(e11[p].padEnd(r10)));
    }
    l.push(u.join(n10));
  }
  return l.join(`
`);
}
var x8;
var E8;
var N8;
var k8;
var Pp = I(() => {
  "use strict";
  qe();
  se();
  x8 = { name: "column", summary: "columnate lists", usage: "column [OPTION]... [FILE]...", description: "Format input into multiple columns. By default, fills rows first. Use -t to create a table based on whitespace-delimited input.", options: ["-t           Create a table (determine columns from input)", "-s SEP       Input field delimiter (default: whitespace)", "-o SEP       Output field delimiter (default: two spaces)", "-c WIDTH     Output width for fill mode (default: 80)", "-n           Don't merge multiple adjacent delimiters"], examples: ["ls | column              # Fill columns with ls output", "cat data | column -t     # Format as table", "column -t -s ',' file    # Format CSV as table", "column -c 40 file        # Fill 40-char wide columns"] }, E8 = { table: { short: "t", long: "table", type: "boolean" }, separator: { short: "s", type: "string" }, outputSep: { short: "o", type: "string" }, width: { short: "c", type: "number", default: 80 }, noMerge: { short: "n", type: "boolean" } };
  N8 = { name: "column", execute: async (e11, t10) => {
    if (U2(e11))
      return M(x8);
    let n10 = be("column", e11, E8);
    if (!n10.ok)
      return n10.error;
    let { table: r10, separator: s10, outputSep: i10, width: o10, noMerge: a } = n10.result.flags, l = n10.result.positional, c = i10 ?? "  ", u;
    if (l.length === 0)
      u = t10.stdin ?? "";
    else {
      let d = [];
      for (let g of l)
        if (g === "-")
          d.push(t10.stdin ?? "");
        else {
          let y = t10.fs.resolvePath(t10.cwd, g), w = await t10.fs.readFile(y);
          if (w === null)
            return { exitCode: 1, stdout: "", stderr: `column: ${g}: No such file or directory
` };
          d.push(w);
        }
      u = d.join("");
    }
    if (u === "" || u.trim() === "")
      return { exitCode: 0, stdout: "", stderr: "" };
    let f10 = u.split(`
`);
    u.endsWith(`
`) && f10[f10.length - 1] === "" && f10.pop();
    let h = f10.filter((d) => d.trim().length > 0), m;
    if (r10) {
      let d = h.map((g) => $p(g, s10, a));
      m = S8(d, c);
    } else {
      let d = [];
      for (let g of h) {
        let y = $p(g, s10, a);
        d.push(...y);
      }
      m = C8(d, o10, c);
    }
    return m.length > 0 && (m += `
`), { exitCode: 0, stdout: m, stderr: "" };
  } }, k8 = { name: "column", flags: [{ flag: "-t", type: "boolean" }, { flag: "-s", type: "value", valueHint: "delimiter" }, { flag: "-o", type: "value", valueHint: "string" }, { flag: "-c", type: "value", valueHint: "number" }, { flag: "-n", type: "boolean" }], stdinType: "text", needsFiles: true };
});
var Dp = {};
Q(Dp, { flagsForFuzzing: () => T8, join: () => $8 });
function I8(e11, t10) {
  return t10 ? e11.split(t10) : e11.split(/[ \t]+/).filter((n10) => n10.length > 0);
}
function O8(e11, t10, n10, r10) {
  let s10 = I8(e11, t10), i10 = s10[n10 - 1] ?? "";
  return r10 && (i10 = i10.toLowerCase()), { fields: s10, joinKey: i10, original: e11 };
}
function Ca(e11, t10, n10) {
  let r10 = n10.separator ?? " ";
  if (n10.outputFormat) {
    let o10 = [];
    for (let { file: a, field: l } of n10.outputFormat) {
      let c = a === 1 ? e11 : t10;
      c && l === 0 ? o10.push(c.joinKey) : c && c.fields[l - 1] !== void 0 ? o10.push(c.fields[l - 1]) : o10.push(n10.emptyString);
    }
    return o10.join(r10);
  }
  let s10 = [], i10 = e11?.joinKey ?? t10?.joinKey ?? "";
  if (s10.push(i10), e11)
    for (let o10 = 0; o10 < e11.fields.length; o10++)
      o10 !== n10.field1 - 1 && s10.push(e11.fields[o10]);
  if (t10)
    for (let o10 = 0; o10 < t10.fields.length; o10++)
      o10 !== n10.field2 - 1 && s10.push(t10.fields[o10]);
  return s10.join(r10);
}
function R8(e11) {
  let t10 = e11.split(","), n10 = [];
  for (let r10 of t10) {
    let s10 = r10.trim().match(/^(\d+)\.(\d+)$/);
    if (!s10)
      return null;
    let i10 = Number.parseInt(s10[1], 10), o10 = Number.parseInt(s10[2], 10);
    if (i10 !== 1 && i10 !== 2)
      return null;
    n10.push({ file: i10, field: o10 });
  }
  return n10;
}
var v82;
var $8;
var T8;
var _p = I(() => {
  "use strict";
  se();
  v82 = { name: "join", summary: "join lines of two files on a common field", usage: "join [OPTION]... FILE1 FILE2", description: "For each pair of input lines with identical join fields, write a line to standard output. The default join field is the first, delimited by blanks.", options: ["-1 FIELD     Join on this FIELD of file 1 (default: 1)", "-2 FIELD     Join on this FIELD of file 2 (default: 1)", "-t CHAR      Use CHAR as input and output field separator", "-a FILENUM   Also print unpairable lines from file FILENUM (1 or 2)", "-v FILENUM   Like -a but only output unpairable lines", "-e STRING    Replace missing fields with STRING", "-o FORMAT    Output format (comma-separated list of FILENUM.FIELD)", "-i           Ignore case when comparing fields"], examples: ["join file1 file2               # Join on first field", "join -1 2 -2 1 file1 file2     # Join file1 col 2 with file2 col 1", "join -t ',' file1.csv file2.csv  # Join CSV files", "join -a 1 file1 file2          # Left outer join"] };
  $8 = { name: "join", execute: async (e11, t10) => {
    if (U2(e11))
      return M(v82);
    let n10 = { field1: 1, field2: 1, separator: null, printUnpairable: /* @__PURE__ */ new Set(), onlyUnpairable: /* @__PURE__ */ new Set(), emptyString: "", outputFormat: null, ignoreCase: false }, r10 = [], s10 = 0;
    for (; s10 < e11.length; ) {
      let p = e11[s10];
      if (p === "-1" && s10 + 1 < e11.length) {
        let h = Number.parseInt(e11[s10 + 1], 10);
        if (Number.isNaN(h) || h < 1)
          return { exitCode: 1, stdout: "", stderr: `join: invalid field number: '${e11[s10 + 1]}'
` };
        n10.field1 = h, s10 += 2;
      } else if (p === "-2" && s10 + 1 < e11.length) {
        let h = Number.parseInt(e11[s10 + 1], 10);
        if (Number.isNaN(h) || h < 1)
          return { exitCode: 1, stdout: "", stderr: `join: invalid field number: '${e11[s10 + 1]}'
` };
        n10.field2 = h, s10 += 2;
      } else if ((p === "-t" || p === "--field-separator") && s10 + 1 < e11.length)
        n10.separator = e11[s10 + 1], s10 += 2;
      else if (p.startsWith("-t") && p.length > 2)
        n10.separator = p.slice(2), s10++;
      else if (p === "-a" && s10 + 1 < e11.length) {
        let h = Number.parseInt(e11[s10 + 1], 10);
        if (h !== 1 && h !== 2)
          return { exitCode: 1, stdout: "", stderr: `join: invalid file number: '${e11[s10 + 1]}'
` };
        n10.printUnpairable.add(h), s10 += 2;
      } else if (p.match(/^-a[12]$/))
        n10.printUnpairable.add(Number.parseInt(p[2], 10)), s10++;
      else if (p === "-v" && s10 + 1 < e11.length) {
        let h = Number.parseInt(e11[s10 + 1], 10);
        if (h !== 1 && h !== 2)
          return { exitCode: 1, stdout: "", stderr: `join: invalid file number: '${e11[s10 + 1]}'
` };
        n10.onlyUnpairable.add(h), s10 += 2;
      } else if (p.match(/^-v[12]$/))
        n10.onlyUnpairable.add(Number.parseInt(p[2], 10)), s10++;
      else if (p === "-e" && s10 + 1 < e11.length)
        n10.emptyString = e11[s10 + 1], s10 += 2;
      else if (p === "-o" && s10 + 1 < e11.length) {
        let h = R8(e11[s10 + 1]);
        if (!h)
          return { exitCode: 1, stdout: "", stderr: `join: invalid field spec: '${e11[s10 + 1]}'
` };
        n10.outputFormat = h, s10 += 2;
      } else if (p === "-i" || p === "--ignore-case")
        n10.ignoreCase = true, s10++;
      else if (p === "--") {
        r10.push(...e11.slice(s10 + 1));
        break;
      } else {
        if (p.startsWith("-") && p !== "-")
          return Y("join", p);
        r10.push(p), s10++;
      }
    }
    if (r10.length !== 2)
      return { exitCode: 1, stdout: "", stderr: r10.length < 2 ? `join: missing file operand
` : `join: extra operand
` };
    let i10 = [];
    for (let p of r10)
      if (p === "-")
        i10.push(t10.stdin ?? "");
      else {
        let h = t10.fs.resolvePath(t10.cwd, p), m = await t10.fs.readFile(h);
        if (m === null)
          return { exitCode: 1, stdout: "", stderr: `join: ${p}: No such file or directory
` };
        i10.push(m);
      }
    let o10 = (p, h) => {
      let m = p.split(`
`);
      return p.endsWith(`
`) && m[m.length - 1] === "" && m.pop(), m.filter((d) => d.length > 0).map((d) => O8(d, n10.separator, h, n10.ignoreCase));
    }, a = o10(i10[0], n10.field1), l = o10(i10[1], n10.field2), c = /* @__PURE__ */ new Map();
    for (let p of l) {
      let h = c.get(p.joinKey);
      h ? h.push(p) : c.set(p.joinKey, [p]);
    }
    let u = [], f10 = /* @__PURE__ */ new Set();
    for (let p of a) {
      let h = c.get(p.joinKey);
      if (h && h.length > 0) {
        if (f10.add(p.joinKey), n10.onlyUnpairable.size === 0)
          for (let m of h)
            u.push(Ca(p, m, n10));
      } else
        (n10.printUnpairable.has(1) || n10.onlyUnpairable.has(1)) && u.push(Ca(p, null, n10));
    }
    if (n10.printUnpairable.has(2) || n10.onlyUnpairable.has(2))
      for (let p of l)
        f10.has(p.joinKey) || u.push(Ca(null, p, n10));
    return { exitCode: 0, stdout: u.length > 0 ? `${u.join(`
`)}
` : "", stderr: "" };
  } }, T8 = { name: "join", flags: [{ flag: "-1", type: "value", valueHint: "number" }, { flag: "-2", type: "value", valueHint: "number" }, { flag: "-t", type: "value", valueHint: "delimiter" }, { flag: "-a", type: "value", valueHint: "number" }, { flag: "-v", type: "value", valueHint: "number" }, { flag: "-e", type: "value", valueHint: "string" }, { flag: "-o", type: "value", valueHint: "format" }, { flag: "-i", type: "boolean" }], needsArgs: true, minArgs: 2 };
});
var Lp = {};
Q(Lp, { flagsForFuzzing: () => L8, teeCommand: () => _8 });
var P8;
var D8;
var _8;
var L8;
var Fp = I(() => {
  "use strict";
  qe();
  se();
  P8 = { name: "tee", summary: "read from stdin and write to stdout and files", usage: "tee [OPTION]... [FILE]...", options: ["-a, --append     append to the given FILEs, do not overwrite", "    --help       display this help and exit"] }, D8 = { append: { short: "a", long: "append", type: "boolean" } }, _8 = { name: "tee", async execute(e11, t10) {
    if (U2(e11))
      return M(P8);
    let n10 = be("tee", e11, D8);
    if (!n10.ok)
      return n10.error;
    let { append: r10 } = n10.result.flags, s10 = n10.result.positional, i10 = t10.stdin, o10 = "", a = 0;
    for (let l of s10)
      try {
        let c = t10.fs.resolvePath(t10.cwd, l);
        r10 ? await t10.fs.appendFile(c, i10) : await t10.fs.writeFile(c, i10);
      } catch {
        o10 += `tee: ${l}: No such file or directory
`, a = 1;
      }
    return { stdout: i10, stderr: o10, exitCode: a };
  } }, L8 = { name: "tee", flags: [{ flag: "-a", type: "boolean" }], stdinType: "text", needsArgs: true };
});
function qt(e11, t10) {
  switch (e11.type) {
    case "name": {
      let n10 = e11.pattern, r10 = n10.match(/^\*(\.[a-zA-Z0-9]+)$/);
      if (r10) {
        let s10 = r10[1], i10 = t10.name;
        if (e11.ignoreCase) {
          if (!i10.toLowerCase().endsWith(s10.toLowerCase()))
            return { matches: false, pruned: false, printed: false };
        } else if (!i10.endsWith(s10))
          return { matches: false, pruned: false, printed: false };
        return { matches: true, pruned: false, printed: false };
      }
      return { matches: bt(t10.name, n10, e11.ignoreCase), pruned: false, printed: false };
    }
    case "path": {
      let n10 = e11.pattern, r10 = t10.relativePath, s10 = n10.split("/");
      for (let o10 = 0; o10 < s10.length - 1; o10++) {
        let a = s10[o10];
        if (a && a !== "." && a !== ".." && !a.includes("*") && !a.includes("?") && !a.includes("[")) {
          let l = `/${a}/`;
          if (e11.ignoreCase) {
            if (!r10.toLowerCase().includes(l.toLowerCase()))
              return { matches: false, pruned: false, printed: false };
          } else if (!r10.includes(l))
            return { matches: false, pruned: false, printed: false };
        }
      }
      let i10 = n10.match(/\*(\.[a-zA-Z0-9]+)$/);
      if (i10) {
        let o10 = i10[1];
        if (e11.ignoreCase) {
          if (!r10.toLowerCase().endsWith(o10.toLowerCase()))
            return { matches: false, pruned: false, printed: false };
        } else if (!r10.endsWith(o10))
          return { matches: false, pruned: false, printed: false };
      }
      return { matches: bt(r10, n10, e11.ignoreCase), pruned: false, printed: false };
    }
    case "regex":
      try {
        let n10 = e11.ignoreCase ? "i" : "";
        return { matches: V(e11.pattern, n10).test(t10.relativePath), pruned: false, printed: false };
      } catch {
        return { matches: false, pruned: false, printed: false };
      }
    case "type":
      return e11.fileType === "f" ? { matches: t10.isFile, pruned: false, printed: false } : e11.fileType === "d" ? { matches: t10.isDirectory, pruned: false, printed: false } : { matches: false, pruned: false, printed: false };
    case "empty":
      return { matches: t10.isEmpty, pruned: false, printed: false };
    case "mtime": {
      let r10 = (Date.now() - t10.mtime) / (1e3 * 60 * 60 * 24), s10;
      return e11.comparison === "more" ? s10 = r10 > e11.days : e11.comparison === "less" ? s10 = r10 < e11.days : s10 = Math.floor(r10) === e11.days, { matches: s10, pruned: false, printed: false };
    }
    case "newer": {
      let n10 = t10.newerRefTimes.get(e11.refPath);
      return n10 === void 0 ? { matches: false, pruned: false, printed: false } : { matches: t10.mtime > n10, pruned: false, printed: false };
    }
    case "size": {
      let n10 = e11.value;
      switch (e11.unit) {
        case "c":
          n10 = e11.value;
          break;
        case "k":
          n10 = e11.value * 1024;
          break;
        case "M":
          n10 = e11.value * 1024 * 1024;
          break;
        case "G":
          n10 = e11.value * 1024 * 1024 * 1024;
          break;
        case "b":
          n10 = e11.value * 512;
          break;
      }
      let r10;
      return e11.comparison === "more" ? r10 = t10.size > n10 : e11.comparison === "less" ? r10 = t10.size < n10 : e11.unit === "b" ? r10 = Math.ceil(t10.size / 512) === e11.value : r10 = t10.size === n10, { matches: r10, pruned: false, printed: false };
    }
    case "perm": {
      let n10 = t10.mode & 511, r10 = e11.mode & 511, s10;
      return e11.matchType === "exact" ? s10 = n10 === r10 : e11.matchType === "all" ? s10 = (n10 & r10) === r10 : s10 = (n10 & r10) !== 0, { matches: s10, pruned: false, printed: false };
    }
    case "prune":
      return { matches: true, pruned: true, printed: false };
    case "print":
      return { matches: true, pruned: false, printed: true };
    case "not": {
      let n10 = qt(e11.expr, t10);
      return { matches: !n10.matches, pruned: n10.pruned, printed: false };
    }
    case "and": {
      let n10 = qt(e11.left, t10);
      if (!n10.matches)
        return { matches: false, pruned: n10.pruned, printed: false };
      let r10 = qt(e11.right, t10);
      return { matches: r10.matches, pruned: n10.pruned || r10.pruned, printed: n10.printed || r10.printed };
    }
    case "or": {
      let n10 = qt(e11.left, t10);
      if (n10.matches)
        return n10;
      let r10 = qt(e11.right, t10);
      return { matches: r10.matches, pruned: n10.pruned || r10.pruned, printed: r10.printed };
    }
  }
}
function ss(e11) {
  if (!e11)
    return false;
  switch (e11.type) {
    case "name":
    case "path":
    case "regex":
    case "type":
    case "prune":
    case "print":
      return false;
    case "empty":
    case "mtime":
    case "newer":
    case "size":
    case "perm":
      return true;
    case "not":
      return ss(e11.expr);
    case "and":
    case "or":
      return ss(e11.left) || ss(e11.right);
  }
}
function is2(e11) {
  if (!e11)
    return false;
  switch (e11.type) {
    case "empty":
      return true;
    case "not":
      return is2(e11.expr);
    case "and":
    case "or":
      return is2(e11.left) || is2(e11.right);
    default:
      return false;
  }
}
function Mp(e11) {
  let t10 = { terminalDirName: null, requiredExtension: null };
  if (!e11)
    return t10;
  let n10 = F8(e11);
  if (M8(e11) && n10.length === 1) {
    let i10 = n10[0].split("/").filter((o10) => o10.length > 0);
    if (i10.length >= 2)
      for (let o10 = i10.length - 2; o10 >= 0; o10--) {
        let a = i10[o10];
        if (!a.includes("*") && !a.includes("?") && !a.includes("[") && a !== "." && a !== "..") {
          let l = i10[o10 + 1];
          if (l && (l.includes("*") || l.includes("?"))) {
            t10.terminalDirName = a;
            let c = l.match(/^\*(\.[a-zA-Z0-9]+)$/);
            c && (t10.requiredExtension = c[1]);
          }
          break;
        }
      }
  }
  return t10;
}
function F8(e11) {
  let t10 = [], n10 = (r10) => {
    r10.type === "path" ? t10.push(r10.pattern) : r10.type === "not" ? n10(r10.expr) : (r10.type === "and" || r10.type === "or") && (n10(r10.left), n10(r10.right));
  };
  return n10(e11), t10;
}
function M8(e11) {
  let t10 = (n10) => n10.type === "type" && n10.fileType === "f" ? true : n10.type === "not" ? t10(n10.expr) : n10.type === "and" || n10.type === "or" ? t10(n10.left) || t10(n10.right) : false;
  return t10(e11);
}
function Up(e11) {
  let t10 = [], n10 = (r10) => {
    r10 && (r10.type === "newer" ? t10.push(r10.refPath) : r10.type === "not" ? n10(r10.expr) : (r10.type === "and" || r10.type === "or") && (n10(r10.left), n10(r10.right)));
  };
  return n10(e11), t10;
}
function os2(e11) {
  if (!e11)
    return true;
  switch (e11.type) {
    case "name":
    case "path":
    case "regex":
    case "type":
    case "prune":
    case "print":
      return true;
    case "empty":
    case "mtime":
    case "newer":
    case "size":
    case "perm":
      return false;
    case "not":
      return os2(e11.expr);
    case "and":
    case "or":
      return os2(e11.left) && os2(e11.right);
  }
}
function qn(e11, t10, n10, r10, s10) {
  switch (e11.type) {
    case "name": {
      let i10 = e11.pattern, o10 = i10.match(/^\*(\.[a-zA-Z0-9]+)$/);
      if (o10) {
        let a = o10[1];
        if (e11.ignoreCase) {
          if (!t10.toLowerCase().endsWith(a.toLowerCase()))
            return { matches: false, pruned: false, printed: false };
        } else if (!t10.endsWith(a))
          return { matches: false, pruned: false, printed: false };
        return { matches: true, pruned: false, printed: false };
      }
      return { matches: bt(t10, i10, e11.ignoreCase), pruned: false, printed: false };
    }
    case "path": {
      let i10 = e11.pattern, o10 = i10.split("/");
      for (let l = 0; l < o10.length - 1; l++) {
        let c = o10[l];
        if (c && c !== "." && c !== ".." && !c.includes("*") && !c.includes("?") && !c.includes("[")) {
          let u = `/${c}/`;
          if (e11.ignoreCase) {
            if (!n10.toLowerCase().includes(u.toLowerCase()))
              return { matches: false, pruned: false, printed: false };
          } else if (!n10.includes(u))
            return { matches: false, pruned: false, printed: false };
        }
      }
      let a = i10.match(/\*(\.[a-zA-Z0-9]+)$/);
      if (a) {
        let l = a[1];
        if (e11.ignoreCase) {
          if (!n10.toLowerCase().endsWith(l.toLowerCase()))
            return { matches: false, pruned: false, printed: false };
        } else if (!n10.endsWith(l))
          return { matches: false, pruned: false, printed: false };
      }
      return { matches: bt(n10, i10, e11.ignoreCase), pruned: false, printed: false };
    }
    case "regex":
      try {
        let i10 = e11.ignoreCase ? "i" : "";
        return { matches: V(e11.pattern, i10).test(n10), pruned: false, printed: false };
      } catch {
        return { matches: false, pruned: false, printed: false };
      }
    case "type":
      return e11.fileType === "f" ? { matches: r10, pruned: false, printed: false } : e11.fileType === "d" ? { matches: s10, pruned: false, printed: false } : { matches: false, pruned: false, printed: false };
    case "prune":
      return { matches: true, pruned: true, printed: false };
    case "print":
      return { matches: true, pruned: false, printed: true };
    case "not": {
      let i10 = qn(e11.expr, t10, n10, r10, s10);
      return { matches: !i10.matches, pruned: i10.pruned, printed: false };
    }
    case "and": {
      let i10 = qn(e11.left, t10, n10, r10, s10);
      if (!i10.matches)
        return { matches: false, pruned: i10.pruned, printed: false };
      let o10 = qn(e11.right, t10, n10, r10, s10);
      return { matches: o10.matches, pruned: i10.pruned || o10.pruned, printed: i10.printed || o10.printed };
    }
    case "or": {
      let i10 = qn(e11.left, t10, n10, r10, s10);
      if (i10.matches)
        return i10;
      let o10 = qn(e11.right, t10, n10, r10, s10);
      return { matches: o10.matches, pruned: i10.pruned || o10.pruned, printed: o10.printed };
    }
    default:
      return { matches: false, pruned: false, printed: false };
  }
}
function as(e11) {
  if (!e11)
    return false;
  switch (e11.type) {
    case "prune":
      return true;
    case "not":
      return as(e11.expr);
    case "and":
    case "or":
      return as(e11.left) || as(e11.right);
    default:
      return false;
  }
}
function Rn(e11) {
  switch (e11.type) {
    case "name":
    case "path":
    case "regex":
    case "type":
    case "prune":
    case "print":
      return true;
    case "empty":
    case "mtime":
    case "newer":
    case "size":
    case "perm":
      return false;
    case "not":
      return Rn(e11.expr);
    case "and":
    case "or":
      return Rn(e11.left) && Rn(e11.right);
  }
}
function Wp(e11, t10) {
  if (!e11 || !t10.isDirectory)
    return { shouldPrune: false };
  if (!Rn(e11))
    return Na(e11, t10);
  let n10 = { name: t10.name, relativePath: t10.relativePath, isFile: t10.isFile, isDirectory: t10.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
  return { shouldPrune: qt(e11, n10).pruned };
}
function Na(e11, t10) {
  switch (e11.type) {
    case "or": {
      if (Rn(e11.left)) {
        let n10 = { name: t10.name, relativePath: t10.relativePath, isFile: t10.isFile, isDirectory: t10.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
        if (qt(e11.left, n10).pruned)
          return { shouldPrune: true };
      }
      return Na(e11.right, t10);
    }
    case "and": {
      if (Rn(e11.left) && Rn(e11.right)) {
        let n10 = { name: t10.name, relativePath: t10.relativePath, isFile: t10.isFile, isDirectory: t10.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
        return { shouldPrune: qt(e11, n10).pruned };
      }
      if (Rn(e11.left)) {
        let n10 = { name: t10.name, relativePath: t10.relativePath, isFile: t10.isFile, isDirectory: t10.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
        return qt(e11.left, n10).matches ? Na(e11.right, t10) : { shouldPrune: false };
      }
      return { shouldPrune: false };
    }
    case "not":
      return { shouldPrune: false };
    default:
      return { shouldPrune: false };
  }
}
var Bp = I(() => {
  "use strict";
  Fe();
  Xo();
});
function zp(e11, t10) {
  let n10 = [], r10 = [], s10 = t10;
  for (; s10 < e11.length; ) {
    let o10 = e11[s10];
    if (o10 === "(" || o10 === "\\(") {
      n10.push({ type: "lparen" }), s10++;
      continue;
    }
    if (o10 === ")" || o10 === "\\)") {
      n10.push({ type: "rparen" }), s10++;
      continue;
    }
    if (o10 === "-name" && s10 + 1 < e11.length)
      n10.push({ type: "expr", expr: { type: "name", pattern: e11[++s10] } });
    else if (o10 === "-iname" && s10 + 1 < e11.length)
      n10.push({ type: "expr", expr: { type: "name", pattern: e11[++s10], ignoreCase: true } });
    else if (o10 === "-path" && s10 + 1 < e11.length)
      n10.push({ type: "expr", expr: { type: "path", pattern: e11[++s10] } });
    else if (o10 === "-ipath" && s10 + 1 < e11.length)
      n10.push({ type: "expr", expr: { type: "path", pattern: e11[++s10], ignoreCase: true } });
    else if (o10 === "-regex" && s10 + 1 < e11.length)
      n10.push({ type: "expr", expr: { type: "regex", pattern: e11[++s10] } });
    else if (o10 === "-iregex" && s10 + 1 < e11.length)
      n10.push({ type: "expr", expr: { type: "regex", pattern: e11[++s10], ignoreCase: true } });
    else if (o10 === "-type" && s10 + 1 < e11.length) {
      let a = e11[++s10];
      if (a === "f" || a === "d")
        n10.push({ type: "expr", expr: { type: "type", fileType: a } });
      else
        return { expr: null, pathIndex: s10, error: `find: Unknown argument to -type: ${a}
`, actions: [] };
    } else if (o10 === "-empty")
      n10.push({ type: "expr", expr: { type: "empty" } });
    else if (o10 === "-mtime" && s10 + 1 < e11.length) {
      let a = e11[++s10], l = "exact", c = a;
      a.startsWith("+") ? (l = "more", c = a.slice(1)) : a.startsWith("-") && (l = "less", c = a.slice(1));
      let u = parseInt(c, 10);
      Number.isNaN(u) || n10.push({ type: "expr", expr: { type: "mtime", days: u, comparison: l } });
    } else if (o10 === "-newer" && s10 + 1 < e11.length) {
      let a = e11[++s10];
      n10.push({ type: "expr", expr: { type: "newer", refPath: a } });
    } else if (o10 === "-size" && s10 + 1 < e11.length) {
      let a = e11[++s10], l = "exact", c = a;
      a.startsWith("+") ? (l = "more", c = a.slice(1)) : a.startsWith("-") && (l = "less", c = a.slice(1));
      let u = c.match(/^(\d+)([ckMGb])?$/);
      if (u) {
        let f10 = parseInt(u[1], 10), p = u[2] || "b";
        n10.push({ type: "expr", expr: { type: "size", value: f10, unit: p, comparison: l } });
      }
    } else if (o10 === "-perm" && s10 + 1 < e11.length) {
      let a = e11[++s10], l = "exact", c = a;
      a.startsWith("-") ? (l = "all", c = a.slice(1)) : a.startsWith("/") && (l = "any", c = a.slice(1));
      let u = parseInt(c, 8);
      Number.isNaN(u) || n10.push({ type: "expr", expr: { type: "perm", mode: u, matchType: l } });
    } else if (o10 === "-prune")
      n10.push({ type: "expr", expr: { type: "prune" } });
    else if (o10 === "-not" || o10 === "!")
      n10.push({ type: "not" });
    else if (o10 === "-o" || o10 === "-or")
      n10.push({ type: "op", op: "or" });
    else if (o10 === "-a" || o10 === "-and")
      n10.push({ type: "op", op: "and" });
    else if (o10 === "-maxdepth" || o10 === "-mindepth")
      s10++;
    else if (o10 !== "-depth")
      if (o10 === "-exec") {
        let a = [];
        for (s10++; s10 < e11.length && e11[s10] !== ";" && e11[s10] !== "+"; )
          a.push(e11[s10]), s10++;
        if (s10 >= e11.length)
          return { expr: null, pathIndex: s10, error: "find: missing argument to `-exec'\n", actions: [] };
        let l = e11[s10] === "+";
        r10.push({ type: "exec", command: a, batchMode: l });
      } else if (o10 === "-print")
        n10.push({ type: "expr", expr: { type: "print" } }), r10.push({ type: "print" });
      else if (o10 === "-print0")
        r10.push({ type: "print0" });
      else if (o10 === "-printf" && s10 + 1 < e11.length) {
        let a = e11[++s10];
        r10.push({ type: "printf", format: a });
      } else if (o10 === "-delete")
        r10.push({ type: "delete" });
      else {
        if (o10.startsWith("-"))
          return { expr: null, pathIndex: s10, error: `find: unknown predicate '${o10}'
`, actions: [] };
        if (n10.length === 0) {
          s10++;
          continue;
        }
        break;
      }
    s10++;
  }
  if (n10.length === 0)
    return { expr: null, pathIndex: s10, actions: r10 };
  let i10 = U8(n10);
  return i10.error ? { expr: null, pathIndex: s10, error: i10.error, actions: r10 } : { expr: i10.expr, pathIndex: s10, actions: r10 };
}
function U8(e11) {
  let t10 = 0;
  function n10() {
    let a = r10();
    if (!a)
      return null;
    for (; t10 < e11.length; ) {
      let l = e11[t10];
      if (l.type === "op" && l.op === "or") {
        t10++;
        let c = r10();
        if (!c)
          return a;
        a = { type: "or", left: a, right: c };
      } else
        break;
    }
    return a;
  }
  function r10() {
    let a = s10();
    if (!a)
      return null;
    for (; t10 < e11.length; ) {
      let l = e11[t10];
      if (l.type === "op" && l.op === "and") {
        t10++;
        let c = s10();
        if (!c)
          return a;
        a = { type: "and", left: a, right: c };
      } else if (l.type === "expr" || l.type === "not" || l.type === "lparen") {
        let c = s10();
        if (!c)
          return a;
        a = { type: "and", left: a, right: c };
      } else
        break;
    }
    return a;
  }
  function s10() {
    if (t10 < e11.length && e11[t10].type === "not") {
      t10++;
      let a = s10();
      return a ? { type: "not", expr: a } : null;
    }
    return i10();
  }
  function i10() {
    if (t10 >= e11.length)
      return null;
    let a = e11[t10];
    if (a.type === "lparen") {
      t10++;
      let l = n10();
      return t10 < e11.length && e11[t10].type === "rparen" && t10++, l;
    }
    return a.type === "expr" ? (t10++, a.expr) : (a.type === "rparen", null);
  }
  return { expr: n10() };
}
var Hp = I(() => {
  "use strict";
});
var Gp = {};
Q(Gp, { findCommand: () => j8, flagsForFuzzing: () => Q8 });
function W8() {
  return { readdirCalls: 0, readdirTime: 0, statCalls: 0, statTime: 0, evalCalls: 0, evalTime: 0, nodeCount: 0, batchCount: 0, batchTime: 0, earlyPrunes: 0 };
}
function B8(e11, t10, n10) {
  e11({ category: "find", name: "summary", durationMs: n10, details: { readdirCalls: t10.readdirCalls, readdirTimeMs: t10.readdirTime, statCalls: t10.statCalls, statTimeMs: t10.statTime, evalCalls: t10.evalCalls, evalTimeMs: t10.evalTime, nodeCount: t10.nodeCount, batchCount: t10.batchCount, batchTimeMs: t10.batchTime, earlyPrunes: t10.earlyPrunes, otherTimeMs: n10 - t10.readdirTime - t10.statTime - t10.evalTime - t10.batchTime } });
}
function G8(e11, t10) {
  let n10 = Us(e11), r10 = "", s10 = 0;
  for (; s10 < n10.length; )
    if (n10[s10] === "%" && s10 + 1 < n10.length) {
      if (s10++, n10[s10] === "%") {
        r10 += "%", s10++;
        continue;
      }
      let [i10, o10, a] = hu(n10, s10);
      if (s10 += a, s10 >= n10.length) {
        r10 += "%";
        break;
      }
      let l = n10[s10], c;
      switch (l) {
        case "f":
          c = t10.name, s10++;
          break;
        case "h": {
          let u = t10.path.lastIndexOf("/");
          c = u > 0 ? t10.path.slice(0, u) : ".", s10++;
          break;
        }
        case "p":
          c = t10.path, s10++;
          break;
        case "P": {
          let u = t10.startingPoint;
          t10.path === u ? c = "" : t10.path.startsWith(`${u}/`) ? c = t10.path.slice(u.length + 1) : u === "." && t10.path.startsWith("./") ? c = t10.path.slice(2) : c = t10.path, s10++;
          break;
        }
        case "s":
          c = String(t10.size), s10++;
          break;
        case "d":
          c = String(t10.depth), s10++;
          break;
        case "m":
          c = (t10.mode & 511).toString(8), s10++;
          break;
        case "M":
          c = V8(t10.mode, t10.isDirectory), s10++;
          break;
        case "t": {
          let u = new Date(t10.mtime);
          c = q8(u), s10++;
          break;
        }
        case "T": {
          if (s10 + 1 < n10.length) {
            let u = n10[s10 + 1], f10 = new Date(t10.mtime);
            c = Z8(f10, u), s10 += 2;
          } else
            c = "%T", s10++;
          break;
        }
        default:
          r10 += `%${i10 !== 0 || o10 !== -1 ? `${i10}.${o10}` : ""}${l}`, s10++;
          continue;
      }
      r10 += Ms(c, i10, o10);
    } else
      r10 += n10[s10], s10++;
  return r10;
}
function V8(e11, t10) {
  let n10 = e11 & 511, r10 = t10 ? "d" : "-";
  return r10 += n10 & 256 ? "r" : "-", r10 += n10 & 128 ? "w" : "-", r10 += n10 & 64 ? "x" : "-", r10 += n10 & 32 ? "r" : "-", r10 += n10 & 16 ? "w" : "-", r10 += n10 & 8 ? "x" : "-", r10 += n10 & 4 ? "r" : "-", r10 += n10 & 2 ? "w" : "-", r10 += n10 & 1 ? "x" : "-", r10;
}
function q8(e11) {
  let t10 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], n10 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], r10 = t10[e11.getDay()], s10 = n10[e11.getMonth()], i10 = String(e11.getDate()).padStart(2, " "), o10 = String(e11.getHours()).padStart(2, "0"), a = String(e11.getMinutes()).padStart(2, "0"), l = String(e11.getSeconds()).padStart(2, "0"), c = e11.getFullYear();
  return `${r10} ${s10} ${i10} ${o10}:${a}:${l} ${c}`;
}
function Z8(e11, t10) {
  switch (t10) {
    case "@":
      return String(e11.getTime() / 1e3);
    case "Y":
      return String(e11.getFullYear());
    case "m":
      return String(e11.getMonth() + 1).padStart(2, "0");
    case "d":
      return String(e11.getDate()).padStart(2, "0");
    case "H":
      return String(e11.getHours()).padStart(2, "0");
    case "M":
      return String(e11.getMinutes()).padStart(2, "0");
    case "S":
      return String(e11.getSeconds()).padStart(2, "0");
    case "T":
      return `${String(e11.getHours()).padStart(2, "0")}:${String(e11.getMinutes()).padStart(2, "0")}:${String(e11.getSeconds()).padStart(2, "0")}`;
    case "F":
      return `${e11.getFullYear()}-${String(e11.getMonth() + 1).padStart(2, "0")}-${String(e11.getDate()).padStart(2, "0")}`;
    default:
      return `%T${t10}`;
  }
}
var jp;
var z8;
var H8;
var j8;
var Q8;
var Vp = I(() => {
  "use strict";
  se();
  To();
  Bp();
  Hp();
  jp = 500;
  z8 = { name: "find", summary: "search for files in a directory hierarchy", usage: "find [path...] [expression]", options: ["-name PATTERN    file name matches shell pattern PATTERN", "-iname PATTERN   like -name but case insensitive", "-path PATTERN    file path matches shell pattern PATTERN", "-ipath PATTERN   like -path but case insensitive", "-regex PATTERN   file path matches regular expression PATTERN", "-iregex PATTERN  like -regex but case insensitive", "-type TYPE       file is of type: f (regular file), d (directory)", "-empty           file is empty or directory is empty", "-mtime N         file's data was modified N*24 hours ago", "-newer FILE      file was modified more recently than FILE", "-size N[ckMGb]   file uses N units of space (c=bytes, k=KB, M=MB, G=GB, b=512B blocks)", "-perm MODE       file's permission bits are exactly MODE (octal)", "-perm -MODE      all permission bits MODE are set", "-perm /MODE      any permission bits MODE are set", "-maxdepth LEVELS descend at most LEVELS directories", "-mindepth LEVELS do not apply tests at levels less than LEVELS", "-depth           process directory contents before directory itself", "-prune           do not descend into this directory", "-not, !          negate the following expression", "-a, -and         logical AND (default)", "-o, -or          logical OR", "-exec CMD {} ;   execute CMD on each file ({} is replaced by filename)", "-exec CMD {} +   execute CMD with multiple files at once", "-print           print the full file name (default action)", "-print0          print the full file name followed by a null character", "-printf FORMAT   print FORMAT with directives: %f %h %p %P %s %d %m %M %t", "-delete          delete found files/directories", "    --help       display this help and exit"] }, H8 = /* @__PURE__ */ new Set(["-name", "-iname", "-path", "-ipath", "-regex", "-iregex", "-type", "-maxdepth", "-mindepth", "-mtime", "-newer", "-size", "-perm"]), j8 = { name: "find", async execute(e11, t10) {
    if (U2(e11))
      return M(z8);
    let n10 = [], r10 = null, s10 = null, i10 = false, o10 = false;
    for (let N10 = 0; N10 < e11.length; N10++) {
      let P = e11[N10];
      if (P === "-maxdepth" && N10 + 1 < e11.length)
        o10 = true, r10 = parseInt(e11[++N10], 10);
      else if (P === "-mindepth" && N10 + 1 < e11.length)
        o10 = true, s10 = parseInt(e11[++N10], 10);
      else if (P === "-depth")
        o10 = true, i10 = true;
      else if (P === "-exec")
        for (o10 = true, N10++; N10 < e11.length && e11[N10] !== ";" && e11[N10] !== "+"; )
          N10++;
      else
        !P.startsWith("-") && P !== ";" && P !== "+" && P !== "(" && P !== ")" && P !== "\\(" && P !== "\\)" && P !== "!" ? o10 || n10.push(P) : H8.has(P) ? (o10 = true, N10++) : (P.startsWith("-") || P === "(" || P === "\\(" || P === "!") && (o10 = true);
    }
    n10.length === 0 && n10.push(".");
    let { expr: a, error: l, actions: c } = zp(e11, 0);
    if (l)
      return { stdout: "", stderr: l, exitCode: 1 };
    let u = c.some((N10) => N10.type === "print"), f10 = c.length === 0, p = [], h = c.some((N10) => N10.type === "printf"), m = [], d = "", g = 0, y = Up(a), w = /* @__PURE__ */ new Map();
    for (let N10 of y) {
      let P = t10.fs.resolvePath(t10.cwd, N10);
      try {
        let v = await t10.fs.stat(P);
        w.set(N10, v.mtime?.getTime() ?? Date.now());
      } catch {
      }
    }
    let b = c.some((N10) => {
      if (N10.type !== "printf")
        return false;
      let P = N10.format.replace(/%%/g, "");
      return /%[-+]?[0-9]*\.?[0-9]*(s|m|M|t|T)/.test(P);
    }), x = ss(a) || b, S = is2(a), O = Mp(a), R10 = as(a), F4 = os2(a), $ = typeof t10.fs.readdirWithFileTypes == "function";
    for (let N10 of n10) {
      let ue = function(H) {
        let Ee = s10 === null || H.depth >= s10, oe = false;
        if (Ee && a !== null) {
          let j = Date.now(), ve;
          if (F4)
            ve = qn(a, H.name, H.relativePath, H.isFile, H.isDirectory);
          else {
            let Le = { name: H.name, relativePath: H.relativePath, isFile: H.isFile, isDirectory: H.isDirectory, isEmpty: H.isEmpty, mtime: H.stat?.mtime?.getTime() ?? Date.now(), size: H.stat?.size ?? 0, mode: H.stat?.mode ?? 420, newerRefTimes: w };
            ve = qt(a, Le);
          }
          Ee = ve.matches, oe = u ? ve.printed : Ee, v.evalCalls++, v.evalTime += Date.now() - j;
        } else
          Ee && (oe = true);
        return oe ? { print: true, printfData: h ? { path: H.relativePath, name: H.name, size: H.stat?.size ?? 0, mtime: H.stat?.mtime?.getTime() ?? Date.now(), mode: H.stat?.mode ?? 420, isDirectory: H.isDirectory, depth: H.depth, startingPoint: N10 } : null } : { print: false, printfData: null };
      };
      var k = ue;
      N10.length > 1 && N10.endsWith("/") && (N10 = N10.slice(0, -1));
      let P = t10.fs.resolvePath(t10.cwd, N10);
      try {
        await t10.fs.stat(P);
      } catch {
        d += `find: ${N10}: No such file or directory
`, g = 1;
        continue;
      }
      let v = W8(), T = Date.now();
      async function L(H) {
        let { path: X, depth: Ee, typeInfo: oe } = H;
        if (v.nodeCount++, r10 !== null && Ee > r10)
          return null;
        let ke, j, ve;
        if (oe && !x)
          ke = oe.isFile, j = oe.isDirectory;
        else {
          try {
            let Bn = Date.now();
            ve = await t10.fs.stat(X), v.statCalls++, v.statTime += Date.now() - Bn;
          } catch {
            return null;
          }
          if (!ve)
            return null;
          ke = ve.isFile, j = ve.isDirectory;
        }
        let Le;
        X === P ? Le = N10.split("/").pop() || N10 : Le = X.split("/").pop() || "";
        let He = X === P ? N10 : N10 === "." ? `./${X.slice(P === "/" ? P.length : P.length + 1)}` : N10 + X.slice(P.length), Je = [], rt = null, et = null, tt = false;
        j && R10 && !i10 && (tt = Wp(a, { name: Le, relativePath: He, isFile: ke, isDirectory: j }).shouldPrune, tt && v.earlyPrunes++);
        let Ft = r10 !== null && Ee >= r10, Mt = O.terminalDirName !== null && Le === O.terminalDirName, Zr = !Ft && !Mt && !tt;
        if (j && ((Zr || S || Mt) && !tt)) {
          let Bn = Date.now();
          if ($ && t10.fs.readdirWithFileTypes) {
            if (rt = await t10.fs.readdirWithFileTypes(X), et = rt.map((Nt) => Nt.name), v.readdirCalls++, v.readdirTime += Date.now() - Bn, Zr)
              Je = rt.map((Nt, jt) => ({ path: X === "/" ? `/${Nt.name}` : `${X}/${Nt.name}`, depth: Ee + 1, typeInfo: { isFile: Nt.isFile, isDirectory: Nt.isDirectory }, resultIndex: jt }));
            else if (Mt) {
              let Nt = O.requiredExtension;
              Je = rt.filter((jt) => jt.isFile && (!Nt || jt.name.endsWith(Nt))).map((jt, Ig) => ({ path: X === "/" ? `/${jt.name}` : `${X}/${jt.name}`, depth: Ee + 1, typeInfo: { isFile: jt.isFile, isDirectory: jt.isDirectory }, resultIndex: Ig }));
            }
          } else
            et = await t10.fs.readdir(X), v.readdirCalls++, v.readdirTime += Date.now() - Bn, Zr && (Je = et.map((Nt, jt) => ({ path: X === "/" ? `/${Nt}` : `${X}/${Nt}`, depth: Ee + 1, resultIndex: jt })));
        }
        let Ds = ke ? (ve?.size ?? 0) === 0 : et !== null && et.length === 0, ar = tt;
        if (!i10 && a !== null && !tt && R10) {
          let Bn = Date.now(), Nt = { name: Le, relativePath: He, isFile: ke, isDirectory: j, isEmpty: Ds, mtime: ve?.mtime?.getTime() ?? Date.now(), size: ve?.size ?? 0, mode: ve?.mode ?? 420, newerRefTimes: w };
          ar = qt(a, Nt).pruned, v.evalCalls++, v.evalTime += Date.now() - Bn;
        }
        return { relativePath: He, name: Le, isFile: ke, isDirectory: j, isEmpty: Ds, stat: ve, depth: Ee, children: ar ? [] : Je, pruned: ar };
      }
      async function re() {
        let H = { paths: [], printfData: [] };
        if (i10) {
          let ve = function(Le) {
            let He = { paths: [], printfData: [] }, Je = oe[Le];
            if (!Je)
              return He;
            for (let tt of Je.childIndices) {
              let Ft = ve(tt);
              He.paths.push(...Ft.paths), He.printfData.push(...Ft.printfData);
            }
            let { print: rt, printfData: et } = ue(Je.node);
            return rt && (He.paths.push(Je.node.relativePath), et && He.printfData.push(et)), He;
          };
          var X = ve;
          let oe = [], ke = [{ item: { path: P, depth: 0, resultIndex: 0 }, parentIndex: -1, childOrderInParent: 0 }], j = /* @__PURE__ */ new Map();
          for (; ke.length > 0; ) {
            let Le = Date.now(), He = ke.splice(0, jp), Je = await Promise.all(He.map((rt) => L(rt.item)));
            v.batchCount++, v.batchTime += Date.now() - Le;
            for (let rt = 0; rt < He.length; rt++) {
              let et = Je[rt], tt = He[rt];
              if (!et)
                continue;
              let Ft = oe.length;
              if (tt.parentIndex >= 0) {
                let Mt = j.get(tt.parentIndex) || [];
                Mt.push(Ft), j.set(tt.parentIndex, Mt);
              }
              oe.push({ node: et, parentIndex: tt.parentIndex, childIndices: [] });
              for (let Mt = 0; Mt < et.children.length; Mt++)
                ke.push({ item: et.children[Mt], parentIndex: Ft, childOrderInParent: Mt });
            }
          }
          for (let [Le, He] of j)
            Le >= 0 && Le < oe.length && (oe[Le].childIndices = He);
          if (oe.length > 0) {
            let Le = ve(0);
            H.paths.push(...Le.paths), H.printfData.push(...Le.printfData);
          }
        } else {
          let Le = function(He) {
            let Je = oe.get(He);
            Je && (H.paths.push(Je.path), Je.printfData && H.printfData.push(Je.printfData));
            let rt = ve.get(He);
            if (rt)
              for (let et of rt)
                Le(et);
          };
          var Ee = Le;
          let oe = /* @__PURE__ */ new Map(), ke = 0, j = [{ item: { path: P, depth: 0, resultIndex: 0 }, orderIndex: ke++ }], ve = /* @__PURE__ */ new Map();
          for (; j.length > 0; ) {
            let He = Date.now(), Je = j.splice(0, jp), rt = await Promise.all(Je.map(async ({ item: et, orderIndex: tt }) => {
              let Ft = await L(et);
              return Ft ? { node: Ft, orderIndex: tt } : null;
            }));
            v.batchCount++, v.batchTime += Date.now() - He;
            for (let et of rt) {
              if (!et)
                continue;
              let { node: tt, orderIndex: Ft } = et, { print: Mt, printfData: Zr } = ue(tt);
              if (Mt && oe.set(Ft, { path: tt.relativePath, printfData: Zr }), tt.children.length > 0) {
                let Ro = [];
                for (let Ds of tt.children) {
                  let ar = ke++;
                  Ro.push(ar), j.push({ item: Ds, orderIndex: ar });
                }
                ve.set(Ft, Ro);
              }
            }
          }
          Le(0);
        }
        return H;
      }
      let J = await re();
      if (p.push(...J.paths), m.push(...J.printfData), t10.trace) {
        let H = Date.now() - T;
        B8(t10.trace, v, H), t10.trace({ category: "find", name: "searchPath", durationMs: H, details: { path: N10, resultsFound: J.paths.length } });
      }
    }
    let z = "";
    if (c.length > 0)
      for (let N10 of c)
        switch (N10.type) {
          case "print":
            z += p.length > 0 ? `${p.join(`
`)}
` : "";
            break;
          case "print0":
            z += p.length > 0 ? `${p.join("\0")}\0` : "";
            break;
          case "delete": {
            let P = [...p].sort((v, T) => T.length - v.length);
            for (let v of P) {
              let T = t10.fs.resolvePath(t10.cwd, v);
              try {
                await t10.fs.rm(T, { recursive: false });
              } catch (L) {
                let ue = L instanceof Error ? L.message : String(L);
                d += `find: cannot delete '${v}': ${ue}
`, g = 1;
              }
            }
            break;
          }
          case "printf":
            for (let P of m)
              z += G8(N10.format, P);
            break;
          case "exec":
            if (!t10.exec)
              return { stdout: "", stderr: `find: -exec not supported in this context
`, exitCode: 1 };
            if (N10.batchMode) {
              let P = [];
              for (let L of N10.command)
                L === "{}" ? P.push(...p) : P.push(L);
              let v = P.map((L) => `"${L}"`).join(" "), T = await t10.exec(v, { cwd: t10.cwd });
              z += T.stdout, d += T.stderr, T.exitCode !== 0 && (g = T.exitCode);
            } else
              for (let P of p) {
                let T = N10.command.map((ue) => ue === "{}" ? P : ue).map((ue) => `"${ue}"`).join(" "), L = await t10.exec(T, { cwd: t10.cwd });
                z += L.stdout, d += L.stderr, L.exitCode !== 0 && (g = L.exitCode);
              }
            break;
        }
    else
      f10 && (z = p.length > 0 ? `${p.join(`
`)}
` : "");
    return { stdout: z, stderr: d, exitCode: g };
  } };
  Q8 = { name: "find", flags: [{ flag: "-name", type: "value", valueHint: "pattern" }, { flag: "-iname", type: "value", valueHint: "pattern" }, { flag: "-type", type: "value", valueHint: "string" }, { flag: "-maxdepth", type: "value", valueHint: "number" }, { flag: "-mindepth", type: "value", valueHint: "number" }, { flag: "-empty", type: "boolean" }, { flag: "-print", type: "boolean" }, { flag: "-print0", type: "boolean" }], needsFiles: true };
});
var qp = {};
Q(qp, { basenameCommand: () => X8, flagsForFuzzing: () => Y8 });
var K8;
var X8;
var Y8;
var Zp = I(() => {
  "use strict";
  se();
  K8 = { name: "basename", summary: "strip directory and suffix from filenames", usage: `basename NAME [SUFFIX]
basename OPTION... NAME...`, options: ["-a, --multiple   support multiple arguments", "-s, --suffix=SUFFIX  remove a trailing SUFFIX", "    --help       display this help and exit"] }, X8 = { name: "basename", async execute(e11, t10) {
    if (U2(e11))
      return M(K8);
    let n10 = false, r10 = "", s10 = [];
    for (let o10 = 0; o10 < e11.length; o10++) {
      let a = e11[o10];
      a === "-a" || a === "--multiple" ? n10 = true : a === "-s" && o10 + 1 < e11.length ? (r10 = e11[++o10], n10 = true) : a.startsWith("--suffix=") ? (r10 = a.slice(9), n10 = true) : a.startsWith("-") || s10.push(a);
    }
    if (s10.length === 0)
      return { stdout: "", stderr: `basename: missing operand
`, exitCode: 1 };
    !n10 && s10.length >= 2 && (r10 = s10.pop() ?? "");
    let i10 = [];
    for (let o10 of s10) {
      let a = o10.replace(/\/+$/, ""), l = a.split("/").pop() || a;
      r10 && l.endsWith(r10) && (l = l.slice(0, -r10.length)), i10.push(l);
    }
    return { stdout: `${i10.join(`
`)}
`, stderr: "", exitCode: 0 };
  } }, Y8 = { name: "basename", flags: [{ flag: "-a", type: "boolean" }, { flag: "-s", type: "value", valueHint: "string" }], needsArgs: true };
});
var Qp = {};
Q(Qp, { dirnameCommand: () => e9, flagsForFuzzing: () => t9 });
var J8;
var e9;
var t9;
var Kp = I(() => {
  "use strict";
  se();
  J8 = { name: "dirname", summary: "strip last component from file name", usage: "dirname [OPTION] NAME...", options: ["    --help       display this help and exit"] }, e9 = { name: "dirname", async execute(e11, t10) {
    if (U2(e11))
      return M(J8);
    let n10 = e11.filter((s10) => !s10.startsWith("-"));
    if (n10.length === 0)
      return { stdout: "", stderr: `dirname: missing operand
`, exitCode: 1 };
    let r10 = [];
    for (let s10 of n10) {
      let i10 = s10.replace(/\/+$/, ""), o10 = i10.lastIndexOf("/");
      o10 === -1 ? r10.push(".") : o10 === 0 ? r10.push("/") : r10.push(i10.slice(0, o10));
    }
    return { stdout: `${r10.join(`
`)}
`, stderr: "", exitCode: 0 };
  } }, t9 = { name: "dirname", flags: [], needsArgs: true };
});
var Yp = {};
Q(Yp, { flagsForFuzzing: () => o9, treeCommand: () => s9 });
async function i9(e11, t10, n10, r10, s10) {
  let i10 = { output: "", stderr: "", dirCount: 0, fileCount: 0 }, o10 = e11.fs.resolvePath(e11.cwd, t10);
  try {
    if (!(await e11.fs.stat(o10)).isDirectory)
      return i10.output = `${t10}
`, i10.fileCount = 1, i10;
  } catch {
    return i10.stderr = `tree: ${t10}: No such file or directory
`, i10;
  }
  if (i10.output = `${t10}
`, n10.maxDepth !== null && s10 >= n10.maxDepth)
    return i10;
  try {
    let a = [];
    if (e11.fs.readdirWithFileTypes)
      a = (await e11.fs.readdirWithFileTypes(o10)).map((u) => ({ name: u.name, isDirectory: u.isDirectory }));
    else {
      let c = await e11.fs.readdir(o10);
      for (let u = 0; u < c.length; u += 100) {
        let f10 = c.slice(u, u + 100), p = await Promise.all(f10.map(async (h) => {
          let m = o10 === "/" ? `/${h}` : `${o10}/${h}`;
          try {
            let d = await e11.fs.stat(m);
            return { name: h, isDirectory: d.isDirectory };
          } catch {
            return null;
          }
        }));
        a.push(...p.filter((h) => h !== null));
      }
    }
    let l = a.filter((c) => !(!n10.showHidden && c.name.startsWith(".") || n10.directoriesOnly && !c.isDirectory));
    l.sort((c, u) => c.name.localeCompare(u.name));
    for (let c = 0; c < l.length; c++) {
      let u = l[c], f10 = o10 === "/" ? `/${u.name}` : `${o10}/${u.name}`, p = c === l.length - 1, h = p ? "`-- " : "|-- ", m = r10 + (p ? "    " : "|   ");
      if (u.isDirectory) {
        i10.dirCount++;
        let d = n10.fullPath ? f10 : u.name;
        if (i10.output += `${r10 + h + d}
`, n10.maxDepth === null || s10 + 1 < n10.maxDepth) {
          let g = await Xp(e11, f10, n10, m, s10 + 1);
          i10.output += g.output, i10.dirCount += g.dirCount, i10.fileCount += g.fileCount;
        }
      } else {
        i10.fileCount++;
        let d = n10.fullPath ? f10 : u.name;
        i10.output += `${r10 + h + d}
`;
      }
    }
  } catch {
    i10.stderr = `tree: ${t10}: Permission denied
`;
  }
  return i10;
}
async function Xp(e11, t10, n10, r10, s10) {
  let i10 = { output: "", stderr: "", dirCount: 0, fileCount: 0 };
  if (n10.maxDepth !== null && s10 >= n10.maxDepth)
    return i10;
  try {
    let o10 = [];
    if (e11.fs.readdirWithFileTypes)
      o10 = (await e11.fs.readdirWithFileTypes(t10)).map((c) => ({ name: c.name, isDirectory: c.isDirectory }));
    else {
      let l = await e11.fs.readdir(t10);
      for (let c = 0; c < l.length; c += 100) {
        let u = l.slice(c, c + 100), f10 = await Promise.all(u.map(async (p) => {
          let h = t10 === "/" ? `/${p}` : `${t10}/${p}`;
          try {
            let m = await e11.fs.stat(h);
            return { name: p, isDirectory: m.isDirectory };
          } catch {
            return null;
          }
        }));
        o10.push(...f10.filter((p) => p !== null));
      }
    }
    let a = o10.filter((l) => !(!n10.showHidden && l.name.startsWith(".") || n10.directoriesOnly && !l.isDirectory));
    a.sort((l, c) => l.name.localeCompare(c.name));
    for (let l = 0; l < a.length; l++) {
      let c = a[l], u = t10 === "/" ? `/${c.name}` : `${t10}/${c.name}`, f10 = l === a.length - 1, p = f10 ? "`-- " : "|-- ", h = r10 + (f10 ? "    " : "|   ");
      if (c.isDirectory) {
        i10.dirCount++;
        let m = n10.fullPath ? u : c.name;
        i10.output += `${r10 + p + m}
`;
        let d = await Xp(e11, u, n10, h, s10 + 1);
        i10.output += d.output, i10.dirCount += d.dirCount, i10.fileCount += d.fileCount;
      } else {
        i10.fileCount++;
        let m = n10.fullPath ? u : c.name;
        i10.output += `${r10 + p + m}
`;
      }
    }
  } catch {
  }
  return i10;
}
var n9;
var r9;
var s9;
var o9;
var Jp = I(() => {
  "use strict";
  qe();
  lr();
  se();
  n9 = { name: "tree", summary: "list contents of directories in a tree-like format", usage: "tree [OPTION]... [DIRECTORY]...", options: ["-a          include hidden files", "-d          list directories only", "-L LEVEL    limit depth of directory tree", "-f          print full path prefix for each file", "    --help  display this help and exit"] }, r9 = { showHidden: { short: "a", type: "boolean" }, directoriesOnly: { short: "d", type: "boolean" }, fullPath: { short: "f", type: "boolean" }, maxDepth: { short: "L", type: "number" } }, s9 = { name: "tree", async execute(e11, t10) {
    if (U2(e11))
      return M(n9);
    let n10 = be("tree", e11, r9);
    if (!n10.ok)
      return n10.error;
    let r10 = { showHidden: n10.result.flags.showHidden, directoriesOnly: n10.result.flags.directoriesOnly, maxDepth: n10.result.flags.maxDepth ?? null, fullPath: n10.result.flags.fullPath }, s10 = n10.result.positional;
    s10.length === 0 && s10.push(".");
    let i10 = "", o10 = "", a = 0, l = 0;
    for (let c of s10) {
      let u = await i9(t10, c, r10, "", 0);
      i10 += u.output, o10 += u.stderr, a += u.dirCount, l += u.fileCount;
    }
    return i10 += `
${a} director${a === 1 ? "y" : "ies"}`, r10.directoriesOnly || (i10 += `, ${l} file${l === 1 ? "" : "s"}`), i10 += `
`, { stdout: i10, stderr: o10, exitCode: o10 ? 1 : 0 };
  } };
  o9 = { name: "tree", flags: [{ flag: "-a", type: "boolean" }, { flag: "-d", type: "boolean" }, { flag: "-f", type: "boolean" }, { flag: "-L", type: "value", valueHint: "number" }], needsFiles: true };
});
var th = {};
Q(th, { duCommand: () => c9, flagsForFuzzing: () => u9 });
async function eh(e11, t10, n10, r10, s10) {
  let i10 = { output: "", totalSize: 0, stderr: "" };
  try {
    let o10 = await e11.fs.stat(t10);
    if (!o10.isDirectory)
      return i10.totalSize = o10.size, (r10.allFiles || s10 === 0) && (i10.output = hi(o10.size, r10.humanReadable) + "	" + n10 + `
`), i10;
    let a = 0, l = [];
    if (e11.fs.readdirWithFileTypes) {
      let f10 = await e11.fs.readdirWithFileTypes(t10), p = f10.filter((m) => m.isFile), h = f10.filter((m) => m.isDirectory);
      for (let m = 0; m < p.length; m += 100) {
        let d = p.slice(m, m + 100), g = await Promise.all(d.map(async (y) => {
          let w = t10 === "/" ? `/${y.name}` : `${t10}/${y.name}`;
          try {
            let b = await e11.fs.stat(w);
            return { name: y.name, isDirectory: false, size: b.size };
          } catch {
            return { name: y.name, isDirectory: false, size: 0 };
          }
        }));
        l.push(...g);
      }
      l.push(...h.map((m) => ({ name: m.name, isDirectory: true })));
    } else {
      let f10 = await e11.fs.readdir(t10);
      for (let p = 0; p < f10.length; p += 100) {
        let h = f10.slice(p, p + 100), m = await Promise.all(h.map(async (d) => {
          let g = t10 === "/" ? `/${d}` : `${t10}/${d}`;
          try {
            let y = await e11.fs.stat(g);
            return { name: d, isDirectory: y.isDirectory, size: y.isDirectory ? void 0 : y.size };
          } catch {
            return { name: d, isDirectory: false, size: 0 };
          }
        }));
        l.push(...m);
      }
    }
    l.sort((f10, p) => f10.name.localeCompare(p.name));
    let c = l.filter((f10) => !f10.isDirectory);
    for (let f10 of c) {
      let p = f10.size ?? 0;
      if (a += p, r10.allFiles && !r10.summarize) {
        let h = n10 === "." ? f10.name : `${n10}/${f10.name}`;
        i10.output += hi(p, r10.humanReadable) + "	" + h + `
`;
      }
    }
    let u = l.filter((f10) => f10.isDirectory);
    for (let f10 = 0; f10 < u.length; f10 += 100) {
      let p = u.slice(f10, f10 + 100), h = await Promise.all(p.map(async (m) => {
        let d = t10 === "/" ? `/${m.name}` : `${t10}/${m.name}`, g = n10 === "." ? m.name : `${n10}/${m.name}`;
        return { name: m.name, result: await eh(e11, d, g, r10, s10 + 1) };
      }));
      h.sort((m, d) => m.name.localeCompare(d.name));
      for (let { result: m } of h)
        a += m.totalSize, r10.summarize || (r10.maxDepth === null || s10 + 1 <= r10.maxDepth) && (i10.output += m.output);
    }
    i10.totalSize = a, (r10.summarize || r10.maxDepth === null || s10 <= r10.maxDepth) && (i10.output += `${hi(a, r10.humanReadable)}	${n10}
`);
  } catch {
    i10.stderr = `du: cannot read directory '${n10}': Permission denied
`;
  }
  return i10;
}
function hi(e11, t10) {
  return t10 ? e11 < 1024 ? `${e11}` : e11 < 1024 * 1024 ? `${(e11 / 1024).toFixed(1)}K` : e11 < 1024 * 1024 * 1024 ? `${(e11 / (1024 * 1024)).toFixed(1)}M` : `${(e11 / (1024 * 1024 * 1024)).toFixed(1)}G` : String(Math.ceil(e11 / 1024) || 1);
}
var a9;
var l9;
var c9;
var u9;
var nh = I(() => {
  "use strict";
  qe();
  lr();
  se();
  a9 = { name: "du", summary: "estimate file space usage", usage: "du [OPTION]... [FILE]...", options: ["-a          write counts for all files, not just directories", "-h          print sizes in human readable format", "-s          display only a total for each argument", "-c          produce a grand total", "--max-depth=N  print total for directory only if N or fewer levels deep", "    --help  display this help and exit"] }, l9 = { allFiles: { short: "a", type: "boolean" }, humanReadable: { short: "h", type: "boolean" }, summarize: { short: "s", type: "boolean" }, grandTotal: { short: "c", type: "boolean" }, maxDepth: { long: "max-depth", type: "number" } }, c9 = { name: "du", async execute(e11, t10) {
    if (U2(e11))
      return M(a9);
    let n10 = be("du", e11, l9);
    if (!n10.ok)
      return n10.error;
    let r10 = { allFiles: n10.result.flags.allFiles, humanReadable: n10.result.flags.humanReadable, summarize: n10.result.flags.summarize, grandTotal: n10.result.flags.grandTotal, maxDepth: n10.result.flags.maxDepth ?? null }, s10 = n10.result.positional;
    s10.length === 0 && s10.push(".");
    let i10 = "", o10 = "", a = 0;
    for (let l of s10) {
      let c = t10.fs.resolvePath(t10.cwd, l);
      try {
        await t10.fs.stat(c);
        let u = await eh(t10, c, l, r10, 0);
        i10 += u.output, a += u.totalSize, o10 += u.stderr;
      } catch {
        o10 += `du: cannot access '${l}': No such file or directory
`;
      }
    }
    return r10.grandTotal && s10.length > 0 && (i10 += `${hi(a, r10.humanReadable)}	total
`), { stdout: i10, stderr: o10, exitCode: o10 ? 1 : 0 };
  } };
  u9 = { name: "du", flags: [{ flag: "-a", type: "boolean" }, { flag: "-h", type: "boolean" }, { flag: "-s", type: "boolean" }, { flag: "-c", type: "boolean" }, { flag: "--max-depth", type: "value", valueHint: "number" }], needsFiles: true };
});
var ka = {};
Q(ka, { envCommand: () => p9, flagsForFuzzing: () => m9, printenvCommand: () => d9, printenvFlagsForFuzzing: () => g9 });
var f9;
var p9;
var h9;
var d9;
var m9;
var g9;
var va = I(() => {
  "use strict";
  se();
  f9 = { name: "env", summary: "run a program in a modified environment", usage: "env [OPTION]... [NAME=VALUE]... [COMMAND [ARG]...]", options: ["-i, --ignore-environment  start with an empty environment", "-u NAME, --unset=NAME     remove NAME from the environment", "    --help                display this help and exit"] }, p9 = { name: "env", async execute(e11, t10) {
    if (U2(e11))
      return M(f9);
    let n10 = false, r10 = [], s10 = /* @__PURE__ */ new Map(), i10 = -1;
    for (let m = 0; m < e11.length; m++) {
      let d = e11[m];
      if (d === "-i" || d === "--ignore-environment")
        n10 = true;
      else if (d === "-u" && m + 1 < e11.length)
        r10.push(e11[++m]);
      else if (d.startsWith("-u"))
        r10.push(d.slice(2));
      else if (d.startsWith("--unset="))
        r10.push(d.slice(8));
      else {
        if (d.startsWith("--") && d !== "--")
          return Y("env", d);
        if (d.startsWith("-") && d !== "-") {
          for (let g of d.slice(1))
            if (g !== "i" && g !== "u")
              return Y("env", `-${g}`);
          d.includes("i") && (n10 = true);
        } else if (d.includes("=") && i10 === -1) {
          let g = d.indexOf("="), y = d.slice(0, g), w = d.slice(g + 1);
          s10.set(y, w);
        } else {
          i10 = m;
          break;
        }
      }
    }
    let o10;
    if (n10)
      o10 = new Map(s10);
    else {
      o10 = new Map(t10.env);
      for (let m of r10)
        o10.delete(m);
      for (let [m, d] of s10)
        o10.set(m, d);
    }
    if (i10 === -1) {
      let m = [];
      for (let [d, g] of o10)
        m.push(`${d}=${g}`);
      return { stdout: m.join(`
`) + (m.length > 0 ? `
` : ""), stderr: "", exitCode: 0 };
    }
    if (!t10.exec)
      return { stdout: "", stderr: `env: command execution not supported in this context
`, exitCode: 1 };
    let a = e11.slice(i10), l = a[0], u = a.slice(1).map((m) => /[\s"'\\$`!*?[\]{}|&;<>()]/.test(m) ? `'${m.replace(/'/g, "'\\''")}'` : m), f10 = ["command", l, ...u].join(" "), p = Object.entries(s10).map(([m, d]) => `${m}="${d}"`).join(" "), h = p ? `${p} ${f10}` : f10;
    return t10.exec(h, { cwd: t10.cwd });
  } }, h9 = { name: "printenv", summary: "print all or part of environment", usage: "printenv [OPTION]... [VARIABLE]...", options: ["    --help       display this help and exit"] }, d9 = { name: "printenv", async execute(e11, t10) {
    if (U2(e11))
      return M(h9);
    let n10 = e11.filter((i10) => !i10.startsWith("-"));
    if (n10.length === 0) {
      let i10 = [];
      for (let [o10, a] of t10.env)
        i10.push(`${o10}=${a}`);
      return { stdout: i10.join(`
`) + (i10.length > 0 ? `
` : ""), stderr: "", exitCode: 0 };
    }
    let r10 = [], s10 = 0;
    for (let i10 of n10) {
      let o10 = t10.env.get(i10);
      o10 !== void 0 ? r10.push(o10) : s10 = 1;
    }
    return { stdout: r10.join(`
`) + (r10.length > 0 ? `
` : ""), stderr: "", exitCode: s10 };
  } }, m9 = { name: "env", flags: [{ flag: "-i", type: "boolean" }, { flag: "-u", type: "value", valueHint: "string" }] }, g9 = { name: "printenv", flags: [] };
});
var Ia = {};
Q(Ia, { aliasCommand: () => w9, flagsForFuzzing: () => x9, unaliasCommand: () => b9, unaliasFlagsForFuzzing: () => E9 });
var y9;
var Er;
var w9;
var b9;
var x9;
var E9;
var Oa = I(() => {
  "use strict";
  se();
  y9 = { name: "alias", summary: "define or display aliases", usage: "alias [name[=value] ...]", options: ["    --help display this help and exit"] }, Er = "BASH_ALIAS_", w9 = { name: "alias", async execute(e11, t10) {
    if (U2(e11))
      return M(y9);
    if (e11.length === 0) {
      let r10 = "";
      for (let [s10, i10] of t10.env)
        if (s10.startsWith(Er)) {
          let o10 = s10.slice(Er.length);
          r10 += `alias ${o10}='${i10}'
`;
        }
      return { stdout: r10, stderr: "", exitCode: 0 };
    }
    let n10 = e11[0] === "--" ? e11.slice(1) : e11;
    for (let r10 of n10) {
      let s10 = r10.indexOf("=");
      if (s10 === -1) {
        let i10 = Er + r10;
        return t10.env.get(i10) ? { stdout: `alias ${r10}='${t10.env.get(i10)}'
`, stderr: "", exitCode: 0 } : { stdout: "", stderr: `alias: ${r10}: not found
`, exitCode: 1 };
      } else {
        let i10 = r10.slice(0, s10), o10 = r10.slice(s10 + 1);
        (o10.startsWith("'") && o10.endsWith("'") || o10.startsWith('"') && o10.endsWith('"')) && (o10 = o10.slice(1, -1)), t10.env.set(Er + i10, o10);
      }
    }
    return { stdout: "", stderr: "", exitCode: 0 };
  } }, b9 = { name: "unalias", async execute(e11, t10) {
    if (U2(e11))
      return M({ name: "unalias", summary: "remove alias definitions", usage: "unalias name [name ...]", options: ["-a      remove all aliases", "    --help display this help and exit"] });
    if (e11.length === 0)
      return { stdout: "", stderr: `unalias: usage: unalias [-a] name [name ...]
`, exitCode: 1 };
    if (e11[0] === "-a") {
      for (let i10 of t10.env.keys())
        i10.startsWith(Er) && t10.env.delete(i10);
      return { stdout: "", stderr: "", exitCode: 0 };
    }
    let n10 = e11[0] === "--" ? e11.slice(1) : e11, r10 = false, s10 = "";
    for (let i10 of n10) {
      let o10 = Er + i10;
      t10.env.get(o10) ? t10.env.delete(o10) : (s10 += `unalias: ${i10}: not found
`, r10 = true);
    }
    return { stdout: "", stderr: s10, exitCode: r10 ? 1 : 0 };
  } }, x9 = { name: "alias", flags: [] }, E9 = { name: "unalias", flags: [{ flag: "-a", type: "boolean" }] };
});
var sh = {};
Q(sh, { flagsForFuzzing: () => C9, historyCommand: () => S9 });
var A9;
var rh;
var S9;
var C9;
var ih = I(() => {
  "use strict";
  se();
  A9 = { name: "history", summary: "display command history", usage: "history [n]", options: ["-c      clear the history list", "    --help display this help and exit"] }, rh = "BASH_HISTORY", S9 = { name: "history", async execute(e11, t10) {
    if (U2(e11))
      return M(A9);
    let n10 = t10.env.get(rh) || "[]", r10;
    try {
      r10 = JSON.parse(n10);
    } catch {
      r10 = [];
    }
    if (e11[0] === "-c")
      return t10.env.set(rh, "[]"), { stdout: "", stderr: "", exitCode: 0 };
    let s10 = r10.length;
    e11[0] && /^\d+$/.test(e11[0]) && (s10 = Math.min(parseInt(e11[0], 10), r10.length));
    let i10 = r10.length - s10, o10 = "";
    for (let a = i10; a < r10.length; a++) {
      let l = (a + 1).toString().padStart(5, " ");
      o10 += `${l}  ${r10[a]}
`;
    }
    return { stdout: o10, stderr: "", exitCode: 0 };
  } }, C9 = { name: "history", flags: [{ flag: "-c", type: "boolean" }] };
});
var oh = {};
Q(oh, { flagsForFuzzing: () => v9, xargsCommand: () => k9 });
var N9;
var k9;
var v9;
var ah = I(() => {
  "use strict";
  se();
  N9 = { name: "xargs", summary: "build and execute command lines from standard input", usage: "xargs [OPTION]... [COMMAND [INITIAL-ARGS]]", options: ["-I REPLACE   replace occurrences of REPLACE with input", "-d DELIM     use DELIM as input delimiter (e.g., -d '\\n' for newline)", "-n NUM       use at most NUM arguments per command line", "-P NUM       run at most NUM processes at a time", "-0, --null   items are separated by null, not whitespace", "-t, --verbose  print commands before executing", "-r, --no-run-if-empty  do not run command if input is empty", "    --help   display this help and exit"] }, k9 = { name: "xargs", async execute(e11, t10) {
    if (U2(e11))
      return M(N9);
    let n10 = null, r10 = null, s10 = null, i10 = null, o10 = false, a = false, l = false, c = 0;
    for (let w = 0; w < e11.length; w++) {
      let b = e11[w];
      if (b === "-I" && w + 1 < e11.length)
        n10 = e11[++w], c = w + 1;
      else if (b === "-d" && w + 1 < e11.length)
        r10 = e11[++w].replace(/\\n/g, `
`).replace(/\\t/g, "	").replace(/\\r/g, "\r").replace(/\\0/g, "\0").replace(/\\\\/g, "\\"), c = w + 1;
      else if (b === "-n" && w + 1 < e11.length)
        s10 = parseInt(e11[++w], 10), c = w + 1;
      else if (b === "-P" && w + 1 < e11.length)
        i10 = parseInt(e11[++w], 10), c = w + 1;
      else if (b === "-0" || b === "--null")
        o10 = true, c = w + 1;
      else if (b === "-t" || b === "--verbose")
        a = true, c = w + 1;
      else if (b === "-r" || b === "--no-run-if-empty")
        l = true, c = w + 1;
      else {
        if (b.startsWith("--"))
          return Y("xargs", b);
        if (b.startsWith("-") && b.length > 1) {
          for (let x of b.slice(1))
            if (!"0tr".includes(x))
              return Y("xargs", `-${x}`);
          b.includes("0") && (o10 = true), b.includes("t") && (a = true), b.includes("r") && (l = true), c = w + 1;
        } else if (!b.startsWith("-")) {
          c = w;
          break;
        }
      }
    }
    let u = e11.slice(c);
    u.length === 0 && u.push("echo");
    let f10;
    if (o10 ? f10 = t10.stdin.split("\0").filter((w) => w.length > 0) : r10 !== null ? f10 = t10.stdin.replace(/\n$/, "").split(r10).filter((b) => b.length > 0) : f10 = t10.stdin.split(/\s+/).map((w) => w.trim()).filter((w) => w.length > 0), f10.length === 0)
      return l ? { stdout: "", stderr: "", exitCode: 0 } : { stdout: "", stderr: "", exitCode: 0 };
    let p = "", h = "", m = 0, d = (w) => /[\s"'\\$`!*?[\]{}();&|<>#]/.test(w) ? `"${w.replace(/([\\"`$])/g, "\\$1")}"` : w, g = async (w) => {
      let b = w.map(d).join(" ");
      return a && (h += `${b}
`), t10.exec ? t10.exec(b, { cwd: t10.cwd }) : { stdout: `${b}
`, stderr: "", exitCode: 0 };
    }, y = async (w) => {
      if (i10 !== null && i10 > 1)
        for (let b = 0; b < w.length; b += i10) {
          let x = w.slice(b, b + i10), S = await Promise.all(x.map(g));
          for (let O of S)
            p += O.stdout, h += O.stderr, O.exitCode !== 0 && (m = O.exitCode);
        }
      else
        for (let b of w) {
          let x = await g(b);
          p += x.stdout, h += x.stderr, x.exitCode !== 0 && (m = x.exitCode);
        }
    };
    if (n10 !== null) {
      let w = f10.map((b) => u.map((x) => x.replaceAll(n10, b)));
      await y(w);
    } else if (s10 !== null) {
      let w = [];
      for (let b = 0; b < f10.length; b += s10) {
        let x = f10.slice(b, b + s10);
        w.push([...u, ...x]);
      }
      await y(w);
    } else {
      let w = [...u, ...f10], b = await g(w);
      p += b.stdout, h += b.stderr, m = b.exitCode;
    }
    return { stdout: p, stderr: h, exitCode: m };
  } }, v9 = { name: "xargs", flags: [{ flag: "-I", type: "value", valueHint: "string" }, { flag: "-d", type: "value", valueHint: "delimiter" }, { flag: "-n", type: "value", valueHint: "number" }, { flag: "-0", type: "boolean" }, { flag: "-t", type: "boolean" }, { flag: "-r", type: "boolean" }], stdinType: "text" };
});
var Ra = {};
Q(Ra, { falseCommand: () => O9, falseFlagsForFuzzing: () => $9, flagsForFuzzing: () => R9, trueCommand: () => I9 });
var I9;
var O9;
var R9;
var $9;
var $a = I(() => {
  "use strict";
  I9 = { name: "true", async execute() {
    return { stdout: "", stderr: "", exitCode: 0 };
  } }, O9 = { name: "false", async execute() {
    return { stdout: "", stderr: "", exitCode: 1 };
  } }, R9 = { name: "true", flags: [] }, $9 = { name: "false", flags: [] };
});
var lh = {};
Q(lh, { clearCommand: () => P9, flagsForFuzzing: () => D9 });
var T9;
var P9;
var D9;
var ch = I(() => {
  "use strict";
  se();
  T9 = { name: "clear", summary: "clear the terminal screen", usage: "clear [OPTIONS]", options: ["    --help display this help and exit"] }, P9 = { name: "clear", async execute(e11, t10) {
    return U2(e11) ? M(T9) : { stdout: "\x1B[2J\x1B[H", stderr: "", exitCode: 0 };
  } }, D9 = { name: "clear", flags: [] };
});
var Ta = {};
Q(Ta, { bashCommand: () => _9, flagsForFuzzing: () => F9, shCommand: () => L9, shFlagsForFuzzing: () => M9 });
async function Ar(e11, t10, n10, r10) {
  if (!r10.exec)
    return { stdout: "", stderr: `bash: internal error: exec function not available
`, exitCode: 1 };
  let s10 = Js(r10.exportedEnv || {}, { 0: t10, "#": String(n10.length), "@": n10.join(" "), "*": n10.join(" ") });
  n10.forEach((a, l) => {
    s10[String(l + 1)] = a;
  });
  let i10 = e11;
  if (i10.startsWith("#!")) {
    let a = i10.indexOf(`
`);
    a !== -1 && (i10 = i10.slice(a + 1));
  }
  return await r10.exec(i10, { env: s10, cwd: r10.cwd });
}
var uh;
var _9;
var L9;
var F9;
var M9;
var Pa = I(() => {
  "use strict";
  On();
  se();
  uh = { name: "bash", summary: "execute shell commands or scripts", usage: "bash [OPTIONS] [SCRIPT_FILE] [ARGUMENTS...]", options: ["-c COMMAND  execute COMMAND string", "    --help  display this help and exit"], notes: ["Without -c, reads and executes commands from SCRIPT_FILE.", "Arguments are passed as $1, $2, etc. to the script.", '$0 is set to the script name (or "bash" with -c).'] }, _9 = { name: "bash", async execute(e11, t10) {
    if (U2(e11))
      return M(uh);
    if (e11[0] === "-c" && e11.length >= 2) {
      let s10 = e11[1], i10 = e11[2] || "bash", o10 = e11.slice(3);
      return Ar(s10, i10, o10, t10);
    }
    if (e11.length === 0)
      return t10.stdin?.trim() ? Ar(t10.stdin, "bash", [], t10) : { stdout: "", stderr: "", exitCode: 0 };
    let n10 = e11[0], r10 = e11.slice(1);
    try {
      let s10 = t10.fs.resolvePath(t10.cwd, n10), i10 = await t10.fs.readFile(s10);
      return Ar(i10, n10, r10, t10);
    } catch {
      return { stdout: "", stderr: `bash: ${n10}: No such file or directory
`, exitCode: 127 };
    }
  } }, L9 = { name: "sh", async execute(e11, t10) {
    if (U2(e11))
      return M({ ...uh, name: "sh", summary: "execute shell commands or scripts (POSIX shell)" });
    if (e11[0] === "-c" && e11.length >= 2) {
      let s10 = e11[1], i10 = e11[2] || "sh", o10 = e11.slice(3);
      return Ar(s10, i10, o10, t10);
    }
    if (e11.length === 0)
      return t10.stdin?.trim() ? Ar(t10.stdin, "sh", [], t10) : { stdout: "", stderr: "", exitCode: 0 };
    let n10 = e11[0], r10 = e11.slice(1);
    try {
      let s10 = t10.fs.resolvePath(t10.cwd, n10), i10 = await t10.fs.readFile(s10);
      return Ar(i10, n10, r10, t10);
    } catch {
      return { stdout: "", stderr: `sh: ${n10}: No such file or directory
`, exitCode: 127 };
    }
  } };
  F9 = { name: "bash", flags: [{ flag: "-c", type: "value", valueHint: "string" }], stdinType: "text" }, M9 = { name: "sh", flags: [{ flag: "-c", type: "value", valueHint: "string" }], stdinType: "text" };
});
function Ie(e11) {
  return !fh.has(e11);
}
function Pe(e11, t10, n10) {
  Ie(t10) && (e11[t10] = n10);
}
function un(e11, t10) {
  return Object.hasOwn(e11, t10);
}
function Ze(e11) {
  return Object.assign(/* @__PURE__ */ Object.create(null), e11);
}
function Da(...e11) {
  return Object.assign(/* @__PURE__ */ Object.create(null), ...e11);
}
var fh;
var WN;
var En = I(() => {
  "use strict";
  fh = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]), WN = /* @__PURE__ */ new Set([...fh, "__defineGetter__", "__defineSetter__", "__lookupGetter__", "__lookupSetter__", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]);
});
function _a2(e11, t10, n10, r10, s10, i10, o10, a, l, c) {
  switch (t10) {
    case "sort":
      return Array.isArray(e11) ? [[...e11].sort(o10)] : [null];
    case "sort_by":
      return !Array.isArray(e11) || n10.length === 0 ? [null] : [[...e11].sort((f10, p) => {
        let h = s10(f10, n10[0], r10)[0], m = s10(p, n10[0], r10)[0];
        return o10(h, m);
      })];
    case "bsearch": {
      if (!Array.isArray(e11)) {
        let f10 = e11 === null ? "null" : typeof e11 == "object" ? "object" : typeof e11;
        throw new Error(`${f10} (${JSON.stringify(e11)}) cannot be searched from`);
      }
      return n10.length === 0 ? [null] : s10(e11, n10[0], r10).map((f10) => {
        let p = 0, h = e11.length;
        for (; p < h; ) {
          let m = p + h >>> 1;
          o10(e11[m], f10) < 0 ? p = m + 1 : h = m;
        }
        return p < e11.length && o10(e11[p], f10) === 0 ? p : -p - 1;
      });
    }
    case "unique_by": {
      if (!Array.isArray(e11) || n10.length === 0)
        return [null];
      let u = /* @__PURE__ */ new Map();
      for (let p of e11) {
        let h = s10(p, n10[0], r10)[0], m = JSON.stringify(h);
        u.has(m) || u.set(m, { item: p, key: h });
      }
      let f10 = [...u.values()];
      return f10.sort((p, h) => o10(p.key, h.key)), [f10.map((p) => p.item)];
    }
    case "group_by": {
      if (!Array.isArray(e11) || n10.length === 0)
        return [null];
      let u = /* @__PURE__ */ new Map();
      for (let f10 of e11) {
        let p = JSON.stringify(s10(f10, n10[0], r10)[0]);
        u.has(p) || u.set(p, []), u.get(p)?.push(f10);
      }
      return [[...u.values()]];
    }
    case "max":
      return Array.isArray(e11) && e11.length > 0 ? [e11.reduce((u, f10) => o10(u, f10) > 0 ? u : f10)] : [null];
    case "max_by":
      return !Array.isArray(e11) || e11.length === 0 || n10.length === 0 ? [null] : [e11.reduce((u, f10) => {
        let p = s10(u, n10[0], r10)[0], h = s10(f10, n10[0], r10)[0];
        return o10(p, h) > 0 ? u : f10;
      })];
    case "min":
      return Array.isArray(e11) && e11.length > 0 ? [e11.reduce((u, f10) => o10(u, f10) < 0 ? u : f10)] : [null];
    case "min_by":
      return !Array.isArray(e11) || e11.length === 0 || n10.length === 0 ? [null] : [e11.reduce((u, f10) => {
        let p = s10(u, n10[0], r10)[0], h = s10(f10, n10[0], r10)[0];
        return o10(p, h) < 0 ? u : f10;
      })];
    case "add": {
      let u = (f10) => {
        let p = f10.filter((h) => h !== null);
        return p.length === 0 ? null : p.every((h) => typeof h == "number") ? p.reduce((h, m) => h + m, 0) : p.every((h) => typeof h == "string") ? p.join("") : p.every((h) => Array.isArray(h)) ? p.flat() : p.every((h) => h && typeof h == "object" && !Array.isArray(h)) ? Js(...p) : null;
      };
      if (n10.length >= 1) {
        let f10 = s10(e11, n10[0], r10);
        return [u(f10)];
      }
      return Array.isArray(e11) ? [u(e11)] : [null];
    }
    case "any": {
      if (n10.length >= 2) {
        try {
          let u = i10(e11, n10[0], r10);
          for (let f10 of u)
            if (s10(f10, n10[1], r10).some(a))
              return [true];
        } catch (u) {
          if (u instanceof c)
            throw u;
        }
        return [false];
      }
      return n10.length === 1 ? Array.isArray(e11) ? [e11.some((u) => a(s10(u, n10[0], r10)[0]))] : [false] : Array.isArray(e11) ? [e11.some(a)] : [false];
    }
    case "all": {
      if (n10.length >= 2) {
        try {
          let u = i10(e11, n10[0], r10);
          for (let f10 of u)
            if (!s10(f10, n10[1], r10).some(a))
              return [false];
        } catch (u) {
          if (u instanceof c)
            throw u;
        }
        return [true];
      }
      return n10.length === 1 ? Array.isArray(e11) ? [e11.every((u) => a(s10(u, n10[0], r10)[0]))] : [true] : Array.isArray(e11) ? [e11.every(a)] : [true];
    }
    case "select":
      return n10.length === 0 ? [e11] : s10(e11, n10[0], r10).some(a) ? [e11] : [];
    case "map":
      return n10.length === 0 || !Array.isArray(e11) ? [null] : [e11.flatMap((f10) => s10(f10, n10[0], r10))];
    case "map_values": {
      if (n10.length === 0)
        return [null];
      if (Array.isArray(e11))
        return [e11.flatMap((u) => s10(u, n10[0], r10))];
      if (e11 && typeof e11 == "object") {
        let u = /* @__PURE__ */ Object.create(null);
        for (let [f10, p] of Object.entries(e11)) {
          if (!Ie(f10))
            continue;
          let h = s10(p, n10[0], r10);
          h.length > 0 && Pe(u, f10, h[0]);
        }
        return [u];
      }
      return [null];
    }
    case "has": {
      if (n10.length === 0)
        return [false];
      let f10 = s10(e11, n10[0], r10)[0];
      return Array.isArray(e11) && typeof f10 == "number" ? [f10 >= 0 && f10 < e11.length] : e11 && typeof e11 == "object" && typeof f10 == "string" ? [un(e11, f10)] : [false];
    }
    case "in": {
      if (n10.length === 0)
        return [false];
      let f10 = s10(e11, n10[0], r10)[0];
      return Array.isArray(f10) && typeof e11 == "number" ? [e11 >= 0 && e11 < f10.length] : f10 && typeof f10 == "object" && typeof e11 == "string" ? [un(f10, e11)] : [false];
    }
    case "contains": {
      if (n10.length === 0)
        return [false];
      let u = s10(e11, n10[0], r10);
      return [l(e11, u[0])];
    }
    case "inside": {
      if (n10.length === 0)
        return [false];
      let u = s10(e11, n10[0], r10);
      return [l(u[0], e11)];
    }
    default:
      return null;
  }
}
var ph = I(() => {
  "use strict";
  On();
  En();
});
function La(e11, t10, n10, r10, s10, i10, o10, a) {
  switch (t10) {
    case "first":
      if (n10.length > 0)
        try {
          let l = i10(e11, n10[0], r10);
          return l.length > 0 ? [l[0]] : [];
        } catch (l) {
          if (l instanceof a)
            throw l;
          return [];
        }
      return Array.isArray(e11) && e11.length > 0 ? [e11[0]] : [null];
    case "last":
      if (n10.length > 0) {
        let l = s10(e11, n10[0], r10);
        return l.length > 0 ? [l[l.length - 1]] : [];
      }
      return Array.isArray(e11) && e11.length > 0 ? [e11[e11.length - 1]] : [null];
    case "nth": {
      if (n10.length < 1)
        return [null];
      let l = s10(e11, n10[0], r10);
      if (n10.length > 1) {
        for (let u of l)
          if (u < 0)
            throw new Error("nth doesn't support negative indices");
        let c;
        try {
          c = i10(e11, n10[1], r10);
        } catch (u) {
          if (u instanceof a)
            throw u;
          c = [];
        }
        return l.flatMap((u) => {
          let f10 = u;
          return f10 < c.length ? [c[f10]] : [];
        });
      }
      return Array.isArray(e11) ? l.flatMap((c) => {
        let u = c;
        if (u < 0)
          throw new Error("nth doesn't support negative indices");
        return u < e11.length ? [e11[u]] : [null];
      }) : [null];
    }
    case "range": {
      if (n10.length === 0)
        return [];
      let l = s10(e11, n10[0], r10);
      if (n10.length === 1) {
        let p = [];
        for (let h of l) {
          let m = h;
          for (let d = 0; d < m; d++)
            p.push(d);
        }
        return p;
      }
      let c = s10(e11, n10[1], r10);
      if (n10.length === 2) {
        let p = [];
        for (let h of l)
          for (let m of c) {
            let d = h, g = m;
            for (let y = d; y < g; y++)
              p.push(y);
          }
        return p;
      }
      let u = s10(e11, n10[2], r10), f10 = [];
      for (let p of l)
        for (let h of c)
          for (let m of u) {
            let d = p, g = h, y = m;
            if (y !== 0)
              if (y > 0)
                for (let w = d; w < g; w += y)
                  f10.push(w);
              else
                for (let w = d; w > g; w += y)
                  f10.push(w);
          }
      return f10;
    }
    case "limit":
      return n10.length < 2 ? [] : s10(e11, n10[0], r10).flatMap((c) => {
        let u = c;
        if (u < 0)
          throw new Error("limit doesn't support negative count");
        if (u === 0)
          return [];
        let f10;
        try {
          f10 = i10(e11, n10[1], r10);
        } catch (p) {
          if (p instanceof a)
            throw p;
          f10 = [];
        }
        return f10.slice(0, u);
      });
    case "isempty": {
      if (n10.length < 1)
        return [true];
      try {
        return [i10(e11, n10[0], r10).length === 0];
      } catch (l) {
        if (l instanceof a)
          throw l;
        return [true];
      }
    }
    case "isvalid": {
      if (n10.length < 1)
        return [true];
      try {
        return [s10(e11, n10[0], r10).length > 0];
      } catch (l) {
        if (l instanceof a)
          throw l;
        return [false];
      }
    }
    case "skip":
      return n10.length < 2 ? [] : s10(e11, n10[0], r10).flatMap((c) => {
        let u = c;
        if (u < 0)
          throw new Error("skip doesn't support negative count");
        return s10(e11, n10[1], r10).slice(u);
      });
    case "until": {
      if (n10.length < 2)
        return [e11];
      let l = e11, c = r10.limits.maxIterations;
      for (let u = 0; u < c; u++) {
        if (s10(l, n10[0], r10).some(o10))
          return [l];
        let p = s10(l, n10[1], r10);
        if (p.length === 0)
          return [l];
        l = p[0];
      }
      throw new a(`jq until: too many iterations (${c}), increase executionLimits.maxJqIterations`, "iterations");
    }
    case "while": {
      if (n10.length < 2)
        return [e11];
      let l = [], c = e11, u = r10.limits.maxIterations;
      for (let f10 = 0; f10 < u && s10(c, n10[0], r10).some(o10); f10++) {
        l.push(c);
        let h = s10(c, n10[1], r10);
        if (h.length === 0)
          break;
        c = h[0];
      }
      if (l.length >= u)
        throw new a(`jq while: too many iterations (${u}), increase executionLimits.maxJqIterations`, "iterations");
      return l;
    }
    case "repeat": {
      if (n10.length === 0)
        return [e11];
      let l = [], c = e11, u = r10.limits.maxIterations;
      for (let f10 = 0; f10 < u; f10++) {
        l.push(c);
        let p = s10(c, n10[0], r10);
        if (p.length === 0)
          break;
        c = p[0];
      }
      if (l.length >= u)
        throw new a(`jq repeat: too many iterations (${u}), increase executionLimits.maxJqIterations`, "iterations");
      return l;
    }
    default:
      return null;
  }
}
var hh = I(() => {
  "use strict";
});
function Fa(e11, t10, n10, r10, s10) {
  switch (t10) {
    case "now":
      return [Date.now() / 1e3];
    case "gmtime": {
      if (typeof e11 != "number")
        return [null];
      let i10 = new Date(e11 * 1e3), o10 = i10.getUTCFullYear(), a = i10.getUTCMonth(), l = i10.getUTCDate(), c = i10.getUTCHours(), u = i10.getUTCMinutes(), f10 = i10.getUTCSeconds(), p = i10.getUTCDay(), h = Date.UTC(o10, 0, 1), m = Math.floor((i10.getTime() - h) / (1440 * 60 * 1e3));
      return [[o10, a, l, c, u, f10, p, m]];
    }
    case "mktime": {
      if (!Array.isArray(e11))
        throw new Error("mktime requires parsed datetime inputs");
      let [i10, o10, a, l = 0, c = 0, u = 0] = e11;
      if (typeof i10 != "number" || typeof o10 != "number")
        throw new Error("mktime requires parsed datetime inputs");
      let f10 = Date.UTC(i10, o10, a ?? 1, l ?? 0, c ?? 0, u ?? 0);
      return [Math.floor(f10 / 1e3)];
    }
    case "strftime": {
      if (n10.length === 0)
        return [null];
      let o10 = s10(e11, n10[0], r10)[0];
      if (typeof o10 != "string")
        throw new Error("strftime/1 requires a string format");
      let a;
      if (typeof e11 == "number")
        a = new Date(e11 * 1e3);
      else if (Array.isArray(e11)) {
        let [p, h, m, d = 0, g = 0, y = 0] = e11;
        if (typeof p != "number" || typeof h != "number")
          throw new Error("strftime/1 requires parsed datetime inputs");
        a = new Date(Date.UTC(p, h, m ?? 1, d ?? 0, g ?? 0, y ?? 0));
      } else
        throw new Error("strftime/1 requires parsed datetime inputs");
      let l = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], c = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], u = (p, h = 2) => String(p).padStart(h, "0");
      return [o10.replace(/%Y/g, String(a.getUTCFullYear())).replace(/%m/g, u(a.getUTCMonth() + 1)).replace(/%d/g, u(a.getUTCDate())).replace(/%H/g, u(a.getUTCHours())).replace(/%M/g, u(a.getUTCMinutes())).replace(/%S/g, u(a.getUTCSeconds())).replace(/%A/g, l[a.getUTCDay()]).replace(/%B/g, c[a.getUTCMonth()]).replace(/%Z/g, "UTC").replace(/%%/g, "%")];
    }
    case "strptime": {
      if (n10.length === 0)
        return [null];
      if (typeof e11 != "string")
        throw new Error("strptime/1 requires a string input");
      let o10 = s10(e11, n10[0], r10)[0];
      if (typeof o10 != "string")
        throw new Error("strptime/1 requires a string format");
      if (o10 === "%Y-%m-%dT%H:%M:%SZ") {
        let l = e11.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})Z$/);
        if (l) {
          let [, c, u, f10, p, h, m] = l.map(Number), d = new Date(Date.UTC(c, u - 1, f10, p, h, m)), g = d.getUTCDay(), y = Date.UTC(c, 0, 1), w = Math.floor((d.getTime() - y) / (1440 * 60 * 1e3));
          return [[c, u - 1, f10, p, h, m, g, w]];
        }
      }
      let a = new Date(e11);
      if (!Number.isNaN(a.getTime())) {
        let l = a.getUTCFullYear(), c = a.getUTCMonth(), u = a.getUTCDate(), f10 = a.getUTCHours(), p = a.getUTCMinutes(), h = a.getUTCSeconds(), m = a.getUTCDay(), d = Date.UTC(l, 0, 1), g = Math.floor((a.getTime() - d) / (1440 * 60 * 1e3));
        return [[l, c, u, f10, p, h, m, g]];
      }
      throw new Error(`Cannot parse date: ${e11}`);
    }
    case "fromdate": {
      if (typeof e11 != "string")
        throw new Error("fromdate requires a string input");
      let i10 = new Date(e11);
      if (Number.isNaN(i10.getTime()))
        throw new Error(`date "${e11}" does not match format "%Y-%m-%dT%H:%M:%SZ"`);
      return [Math.floor(i10.getTime() / 1e3)];
    }
    case "todate": {
      if (typeof e11 != "number")
        throw new Error("todate requires a number input");
      return [new Date(e11 * 1e3).toISOString().replace(/\.\d{3}Z$/, "Z")];
    }
    default:
      return null;
  }
}
var dh = I(() => {
  "use strict";
});
function Zt(e11) {
  return e11 !== false && e11 !== null;
}
function Sr(e11, t10) {
  return JSON.stringify(e11) === JSON.stringify(t10);
}
function ls(e11, t10) {
  return typeof e11 == "number" && typeof t10 == "number" ? e11 - t10 : typeof e11 == "string" && typeof t10 == "string" ? e11.localeCompare(t10) : 0;
}
function Ma(e11, t10) {
  let n10 = Ze(e11);
  for (let r10 of Object.keys(t10))
    Ie(r10) && (un(n10, r10) && n10[r10] && typeof n10[r10] == "object" && !Array.isArray(n10[r10]) && t10[r10] && typeof t10[r10] == "object" && !Array.isArray(t10[r10]) ? Pe(n10, r10, Ma(n10[r10], t10[r10])) : Pe(n10, r10, t10[r10]));
  return n10;
}
function Cr(e11, t10 = 3e3) {
  let n10 = 0, r10 = e11;
  for (; n10 < t10; )
    if (Array.isArray(r10)) {
      if (r10.length === 0)
        return n10 + 1;
      r10 = r10[0], n10++;
    } else if (r10 !== null && typeof r10 == "object") {
      let s10 = Object.keys(r10);
      if (s10.length === 0)
        return n10 + 1;
      r10 = r10[s10[0]], n10++;
    } else
      return n10;
  return n10;
}
function di(e11, t10) {
  let n10 = (i10) => i10 === null ? 0 : typeof i10 == "boolean" ? 1 : typeof i10 == "number" ? 2 : typeof i10 == "string" ? 3 : Array.isArray(i10) ? 4 : typeof i10 == "object" ? 5 : 6, r10 = n10(e11), s10 = n10(t10);
  if (r10 !== s10)
    return r10 - s10;
  if (typeof e11 == "number" && typeof t10 == "number")
    return e11 - t10;
  if (typeof e11 == "string" && typeof t10 == "string")
    return e11.localeCompare(t10);
  if (typeof e11 == "boolean" && typeof t10 == "boolean")
    return (e11 ? 1 : 0) - (t10 ? 1 : 0);
  if (Array.isArray(e11) && Array.isArray(t10)) {
    for (let i10 = 0; i10 < Math.min(e11.length, t10.length); i10++) {
      let o10 = di(e11[i10], t10[i10]);
      if (o10 !== 0)
        return o10;
    }
    return e11.length - t10.length;
  }
  if (e11 && t10 && typeof e11 == "object" && typeof t10 == "object") {
    let i10 = e11, o10 = t10, a = Object.keys(i10).sort(), l = Object.keys(o10).sort();
    for (let c = 0; c < Math.min(a.length, l.length); c++) {
      let u = a[c].localeCompare(l[c]);
      if (u !== 0)
        return u;
    }
    if (a.length !== l.length)
      return a.length - l.length;
    for (let c of a) {
      let u = di(i10[c], o10[c]);
      if (u !== 0)
        return u;
    }
  }
  return 0;
}
function mi(e11, t10) {
  if (Sr(e11, t10))
    return true;
  if (typeof e11 == "string" && typeof t10 == "string")
    return e11.includes(t10);
  if (Array.isArray(e11) && Array.isArray(t10))
    return t10.every((n10) => e11.some((r10) => mi(r10, n10)));
  if (e11 && t10 && typeof e11 == "object" && typeof t10 == "object" && !Array.isArray(e11) && !Array.isArray(t10)) {
    let n10 = e11, r10 = t10;
    return Object.keys(r10).every((s10) => un(n10, s10) && mi(n10[s10], r10[s10]));
  }
  return false;
}
var gi = I(() => {
  "use strict";
  En();
});
function Ua(e11, t10, n10) {
  switch (t10) {
    case "@base64":
      return typeof e11 == "string" ? typeof Buffer < "u" ? [Buffer.from(e11, "utf-8").toString("base64")] : [btoa(e11)] : [null];
    case "@base64d":
      return typeof e11 == "string" ? typeof Buffer < "u" ? [Buffer.from(e11, "base64").toString("utf-8")] : [atob(e11)] : [null];
    case "@uri":
      return typeof e11 == "string" ? [encodeURIComponent(e11).replace(/!/g, "%21").replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A")] : [null];
    case "@urid":
      return typeof e11 == "string" ? [decodeURIComponent(e11)] : [null];
    case "@csv":
      return Array.isArray(e11) ? [e11.map((s10) => {
        if (s10 === null)
          return "";
        if (typeof s10 == "boolean")
          return s10 ? "true" : "false";
        if (typeof s10 == "number")
          return String(s10);
        let i10 = String(s10);
        return i10.includes(",") || i10.includes('"') || i10.includes(`
`) || i10.includes("\r") ? `"${i10.replace(/"/g, '""')}"` : i10;
      }).join(",")] : [null];
    case "@tsv":
      return Array.isArray(e11) ? [e11.map((r10) => String(r10 ?? "").replace(/\t/g, "\\t").replace(/\n/g, "\\n")).join("	")] : [null];
    case "@json": {
      let r10 = n10 ?? U9;
      return Cr(e11, r10 + 1) > r10 ? [null] : [JSON.stringify(e11)];
    }
    case "@html":
      return typeof e11 == "string" ? [e11.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;")] : [null];
    case "@sh":
      return typeof e11 == "string" ? [`'${e11.replace(/'/g, "'\\''")}'`] : [null];
    case "@text":
      return typeof e11 == "string" ? [e11] : e11 == null ? [""] : [String(e11)];
    default:
      return null;
  }
}
var U9;
var mh = I(() => {
  "use strict";
  gi();
  U9 = 2e3;
});
function Wa(e11, t10, n10, r10, s10, i10) {
  switch (t10) {
    case "index":
      return n10.length === 0 ? [null] : s10(e11, n10[0], r10).map((a) => {
        if (typeof e11 == "string" && typeof a == "string") {
          if (a === "" && e11 === "")
            return null;
          let l = e11.indexOf(a);
          return l >= 0 ? l : null;
        }
        if (Array.isArray(e11)) {
          if (Array.isArray(a)) {
            for (let c = 0; c <= e11.length - a.length; c++) {
              let u = true;
              for (let f10 = 0; f10 < a.length; f10++)
                if (!i10(e11[c + f10], a[f10])) {
                  u = false;
                  break;
                }
              if (u)
                return c;
            }
            return null;
          }
          let l = e11.findIndex((c) => i10(c, a));
          return l >= 0 ? l : null;
        }
        return null;
      });
    case "rindex":
      return n10.length === 0 ? [null] : s10(e11, n10[0], r10).map((a) => {
        if (typeof e11 == "string" && typeof a == "string") {
          let l = e11.lastIndexOf(a);
          return l >= 0 ? l : null;
        }
        if (Array.isArray(e11)) {
          if (Array.isArray(a)) {
            for (let l = e11.length - a.length; l >= 0; l--) {
              let c = true;
              for (let u = 0; u < a.length; u++)
                if (!i10(e11[l + u], a[u])) {
                  c = false;
                  break;
                }
              if (c)
                return l;
            }
            return null;
          }
          for (let l = e11.length - 1; l >= 0; l--)
            if (i10(e11[l], a))
              return l;
          return null;
        }
        return null;
      });
    case "indices":
      return n10.length === 0 ? [[]] : s10(e11, n10[0], r10).map((a) => {
        let l = [];
        if (typeof e11 == "string" && typeof a == "string") {
          let c = e11.indexOf(a);
          for (; c !== -1; )
            l.push(c), c = e11.indexOf(a, c + 1);
        } else if (Array.isArray(e11))
          if (Array.isArray(a)) {
            let c = a.length;
            if (c === 0)
              for (let u = 0; u <= e11.length; u++)
                l.push(u);
            else
              for (let u = 0; u <= e11.length - c; u++) {
                let f10 = true;
                for (let p = 0; p < c; p++)
                  if (!i10(e11[u + p], a[p])) {
                    f10 = false;
                    break;
                  }
                f10 && l.push(u);
              }
          } else
            for (let c = 0; c < e11.length; c++)
              i10(e11[c], a) && l.push(c);
        return l;
      });
    default:
      return null;
  }
}
var gh = I(() => {
  "use strict";
});
function Ba(e11, t10, n10, r10, s10) {
  switch (t10) {
    case "fabs":
    case "abs":
      return typeof e11 == "number" ? [Math.abs(e11)] : typeof e11 == "string" ? [e11] : [null];
    case "exp10":
      return typeof e11 == "number" ? [10 ** e11] : [null];
    case "exp2":
      return typeof e11 == "number" ? [2 ** e11] : [null];
    case "pow": {
      if (n10.length < 2)
        return [null];
      let i10 = s10(e11, n10[0], r10), o10 = s10(e11, n10[1], r10), a = i10[0], l = o10[0];
      return typeof a != "number" || typeof l != "number" ? [null] : [a ** l];
    }
    case "atan2": {
      if (n10.length < 2)
        return [null];
      let i10 = s10(e11, n10[0], r10), o10 = s10(e11, n10[1], r10), a = i10[0], l = o10[0];
      return typeof a != "number" || typeof l != "number" ? [null] : [Math.atan2(a, l)];
    }
    case "hypot": {
      if (typeof e11 != "number" || n10.length === 0)
        return [null];
      let i10 = s10(e11, n10[0], r10)[0];
      return [Math.hypot(e11, i10)];
    }
    case "fma": {
      if (typeof e11 != "number" || n10.length < 2)
        return [null];
      let i10 = s10(e11, n10[0], r10)[0], o10 = s10(e11, n10[1], r10)[0];
      return [e11 * i10 + o10];
    }
    case "copysign": {
      if (typeof e11 != "number" || n10.length === 0)
        return [null];
      let i10 = s10(e11, n10[0], r10)[0];
      return [Math.sign(i10) * Math.abs(e11)];
    }
    case "drem":
    case "remainder": {
      if (typeof e11 != "number" || n10.length === 0)
        return [null];
      let i10 = s10(e11, n10[0], r10)[0];
      return [e11 - Math.round(e11 / i10) * i10];
    }
    case "fdim": {
      if (typeof e11 != "number" || n10.length === 0)
        return [null];
      let i10 = s10(e11, n10[0], r10)[0];
      return [Math.max(0, e11 - i10)];
    }
    case "fmax": {
      if (typeof e11 != "number" || n10.length === 0)
        return [null];
      let i10 = s10(e11, n10[0], r10)[0];
      return [Math.max(e11, i10)];
    }
    case "fmin": {
      if (typeof e11 != "number" || n10.length === 0)
        return [null];
      let i10 = s10(e11, n10[0], r10)[0];
      return [Math.min(e11, i10)];
    }
    case "ldexp": {
      if (typeof e11 != "number" || n10.length === 0)
        return [null];
      let i10 = s10(e11, n10[0], r10)[0];
      return [e11 * 2 ** i10];
    }
    case "scalbn":
    case "scalbln": {
      if (typeof e11 != "number" || n10.length === 0)
        return [null];
      let i10 = s10(e11, n10[0], r10)[0];
      return [e11 * 2 ** i10];
    }
    case "nearbyint":
      return typeof e11 == "number" ? [Math.round(e11)] : [null];
    case "logb":
      return typeof e11 == "number" ? [Math.floor(Math.log2(Math.abs(e11)))] : [null];
    case "significand":
      if (typeof e11 == "number") {
        let i10 = Math.floor(Math.log2(Math.abs(e11)));
        return [e11 / 2 ** i10];
      }
      return [null];
    case "frexp":
      if (typeof e11 == "number") {
        if (e11 === 0)
          return [[0, 0]];
        let i10 = Math.floor(Math.log2(Math.abs(e11))) + 1;
        return [[e11 / 2 ** i10, i10]];
      }
      return [null];
    case "modf":
      if (typeof e11 == "number") {
        let i10 = Math.trunc(e11);
        return [[e11 - i10, i10]];
      }
      return [null];
    default:
      return null;
  }
}
var yh = I(() => {
  "use strict";
});
function za(e11, t10, n10, r10, s10, i10, o10, a) {
  switch (t10) {
    case "recurse": {
      if (n10.length === 0) {
        let h = [], m = (d) => {
          if (h.push(d), Array.isArray(d))
            for (let g of d)
              m(g);
          else if (d && typeof d == "object")
            for (let g of Object.keys(d))
              m(d[g]);
        };
        return m(e11), h;
      }
      let l = [], c = n10.length >= 2 ? n10[1] : null, u = 1e4, f10 = 0, p = (h) => {
        if (f10++ > u || c && !s10(h, c, r10).some(i10))
          return;
        l.push(h);
        let m = s10(h, n10[0], r10);
        for (let d of m)
          d != null && p(d);
      };
      return p(e11), l;
    }
    case "recurse_down":
      return a(e11, "recurse", n10, r10);
    case "walk": {
      if (n10.length === 0)
        return [e11];
      let l = /* @__PURE__ */ new WeakSet(), c = (u) => {
        if (u && typeof u == "object") {
          if (l.has(u))
            return u;
          l.add(u);
        }
        let f10;
        if (Array.isArray(u))
          f10 = u.map(c);
        else if (u && typeof u == "object") {
          let h = /* @__PURE__ */ Object.create(null);
          for (let [m, d] of Object.entries(u))
            Ie(m) && Pe(h, m, c(d));
          f10 = h;
        } else
          f10 = u;
        return s10(f10, n10[0], r10)[0];
      };
      return [c(e11)];
    }
    case "transpose": {
      if (!Array.isArray(e11))
        return [null];
      if (e11.length === 0)
        return [[]];
      let l = Math.max(...e11.map((u) => Array.isArray(u) ? u.length : 0)), c = [];
      for (let u = 0; u < l; u++)
        c.push(e11.map((f10) => Array.isArray(f10) ? f10[u] : null));
      return [c];
    }
    case "combinations": {
      if (n10.length > 0) {
        let f10 = s10(e11, n10[0], r10)[0];
        if (!Array.isArray(e11) || f10 < 0)
          return [];
        if (f10 === 0)
          return [[]];
        let p = [], h = (m, d) => {
          if (d === f10) {
            p.push([...m]);
            return;
          }
          for (let g of e11)
            m.push(g), h(m, d + 1), m.pop();
        };
        return h([], 0), p;
      }
      if (!Array.isArray(e11))
        return [];
      if (e11.length === 0)
        return [[]];
      for (let u of e11)
        if (!Array.isArray(u))
          return [];
      let l = [], c = (u, f10) => {
        if (u === e11.length) {
          l.push([...f10]);
          return;
        }
        let p = e11[u];
        for (let h of p)
          f10.push(h), c(u + 1, f10), f10.pop();
      };
      return c(0, []), l;
    }
    case "parent": {
      if (r10.root === void 0 || r10.currentPath === void 0)
        return [];
      let l = r10.currentPath;
      if (l.length === 0)
        return [];
      let c = n10.length > 0 ? s10(e11, n10[0], r10)[0] : 1;
      if (c >= 0) {
        if (c > l.length)
          return [];
        let u = l.slice(0, l.length - c);
        return [o10(r10.root, u)];
      } else {
        let u = -c - 1;
        if (u >= l.length)
          return [e11];
        let f10 = l.slice(0, u);
        return [o10(r10.root, f10)];
      }
    }
    case "parents": {
      if (r10.root === void 0 || r10.currentPath === void 0)
        return [[]];
      let l = r10.currentPath, c = [];
      for (let u = l.length - 1; u >= 0; u--)
        c.push(o10(r10.root, l.slice(0, u)));
      return [c];
    }
    case "root":
      return r10.root !== void 0 ? [r10.root] : [];
    default:
      return null;
  }
}
var wh = I(() => {
  "use strict";
  En();
});
function Ha(e11, t10, n10, r10, s10) {
  switch (t10) {
    case "keys":
      return Array.isArray(e11) ? [e11.map((i10, o10) => o10)] : e11 && typeof e11 == "object" ? [Object.keys(e11).sort()] : [null];
    case "keys_unsorted":
      return Array.isArray(e11) ? [e11.map((i10, o10) => o10)] : e11 && typeof e11 == "object" ? [Object.keys(e11)] : [null];
    case "length":
      return typeof e11 == "string" ? [e11.length] : Array.isArray(e11) ? [e11.length] : e11 && typeof e11 == "object" ? [Object.keys(e11).length] : e11 === null ? [0] : typeof e11 == "number" ? [Math.abs(e11)] : [null];
    case "utf8bytelength": {
      if (typeof e11 == "string")
        return [new TextEncoder().encode(e11).length];
      let i10 = e11 === null ? "null" : Array.isArray(e11) ? "array" : typeof e11, o10 = i10 === "array" || i10 === "object" ? JSON.stringify(e11) : String(e11);
      throw new Error(`${i10} (${o10}) only strings have UTF-8 byte length`);
    }
    case "to_entries":
      return e11 && typeof e11 == "object" && !Array.isArray(e11) ? [Object.entries(e11).map(([i10, o10]) => ({ key: i10, value: o10 }))] : [null];
    case "from_entries":
      if (Array.isArray(e11)) {
        let i10 = /* @__PURE__ */ Object.create(null);
        for (let o10 of e11)
          if (o10 && typeof o10 == "object") {
            let a = o10, l = a.key ?? a.Key ?? a.name ?? a.Name ?? a.k, c = a.value ?? a.Value ?? a.v;
            if (l !== void 0) {
              let u = String(l);
              Ie(u) && Pe(i10, u, c);
            }
          }
        return [i10];
      }
      return [null];
    case "with_entries": {
      if (n10.length === 0)
        return [e11];
      if (e11 && typeof e11 == "object" && !Array.isArray(e11)) {
        let o10 = Object.entries(e11).map(([l, c]) => ({ key: l, value: c })).flatMap((l) => s10(l, n10[0], r10)), a = /* @__PURE__ */ Object.create(null);
        for (let l of o10)
          if (l && typeof l == "object") {
            let c = l, u = c.key ?? c.name ?? c.k, f10 = c.value ?? c.v;
            if (u !== void 0) {
              let p = String(u);
              Ie(p) && Pe(a, p, f10);
            }
          }
        return [a];
      }
      return [null];
    }
    case "reverse":
      return Array.isArray(e11) ? [[...e11].reverse()] : typeof e11 == "string" ? [e11.split("").reverse().join("")] : [null];
    case "flatten":
      return Array.isArray(e11) ? (n10.length > 0 ? s10(e11, n10[0], r10) : [Number.POSITIVE_INFINITY]).map((o10) => {
        let a = o10;
        if (a < 0)
          throw new Error("flatten depth must not be negative");
        return e11.flat(a);
      }) : [null];
    case "unique":
      if (Array.isArray(e11)) {
        let i10 = /* @__PURE__ */ new Set(), o10 = [];
        for (let a of e11) {
          let l = JSON.stringify(a);
          i10.has(l) || (i10.add(l), o10.push(a));
        }
        return [o10];
      }
      return [null];
    case "tojson":
    case "tojsonstream": {
      let i10 = r10.limits.maxDepth ?? W9;
      return Cr(e11, i10 + 1) > i10 ? [null] : [JSON.stringify(e11)];
    }
    case "fromjson": {
      if (typeof e11 == "string") {
        let i10 = e11.trim().toLowerCase();
        if (i10 === "nan")
          return [Number.NaN];
        if (i10 === "inf" || i10 === "infinity")
          return [Number.POSITIVE_INFINITY];
        if (i10 === "-inf" || i10 === "-infinity")
          return [Number.NEGATIVE_INFINITY];
        try {
          return [JSON.parse(e11)];
        } catch {
          throw new Error(`Invalid JSON: ${e11}`);
        }
      }
      return [e11];
    }
    case "tostring":
      return typeof e11 == "string" ? [e11] : [JSON.stringify(e11)];
    case "tonumber":
      if (typeof e11 == "number")
        return [e11];
      if (typeof e11 == "string") {
        let i10 = Number(e11);
        if (Number.isNaN(i10))
          throw new Error(`${JSON.stringify(e11)} cannot be parsed as a number`);
        return [i10];
      }
      throw new Error(`${typeof e11} cannot be parsed as a number`);
    case "toboolean": {
      if (typeof e11 == "boolean")
        return [e11];
      if (typeof e11 == "string") {
        if (e11 === "true")
          return [true];
        if (e11 === "false")
          return [false];
        throw new Error(`string (${JSON.stringify(e11)}) cannot be parsed as a boolean`);
      }
      let i10 = e11 === null ? "null" : Array.isArray(e11) ? "array" : typeof e11, o10 = i10 === "array" || i10 === "object" ? JSON.stringify(e11) : String(e11);
      throw new Error(`${i10} (${o10}) cannot be parsed as a boolean`);
    }
    case "tostream": {
      let i10 = [], o10 = (a, l) => {
        if (a === null || typeof a != "object")
          i10.push([l, a]);
        else if (Array.isArray(a))
          if (a.length === 0)
            i10.push([l, []]);
          else
            for (let c = 0; c < a.length; c++)
              o10(a[c], [...l, c]);
        else {
          let c = Object.keys(a);
          if (c.length === 0)
            i10.push([l, /* @__PURE__ */ Object.create(null)]);
          else
            for (let u of c)
              o10(a[u], [...l, u]);
        }
      };
      return o10(e11, []), i10.push([[]]), i10;
    }
    case "fromstream": {
      if (n10.length === 0)
        return [e11];
      let i10 = s10(e11, n10[0], r10), o10 = null;
      for (let a of i10) {
        if (!Array.isArray(a) || a.length === 1 && Array.isArray(a[0]) && a[0].length === 0 || a.length !== 2)
          continue;
        let [l, c] = a;
        if (!Array.isArray(l))
          continue;
        if (l.length === 0) {
          o10 = c;
          continue;
        }
        o10 === null && (o10 = typeof l[0] == "number" ? [] : {});
        let u = o10;
        for (let p = 0; p < l.length - 1; p++) {
          let h = l[p], m = l[p + 1];
          if (Array.isArray(u) && typeof h == "number") {
            for (; u.length <= h; )
              u.push(null);
            u[h] === null && (u[h] = typeof m == "number" ? [] : {}), u = u[h];
          } else if (u && typeof u == "object" && !Array.isArray(u)) {
            let d = String(h);
            if (!Ie(d))
              continue;
            let g = u;
            (g[d] === null || g[d] === void 0) && Pe(g, d, typeof m == "number" ? [] : {}), u = g[d];
          }
        }
        let f10 = l[l.length - 1];
        if (Array.isArray(u) && typeof f10 == "number") {
          for (; u.length <= f10; )
            u.push(null);
          u[f10] = c;
        } else if (u && typeof u == "object" && !Array.isArray(u)) {
          let p = String(f10);
          Ie(p) && Pe(u, p, c);
        }
      }
      return [o10];
    }
    case "truncate_stream": {
      let i10 = typeof e11 == "number" ? Math.floor(e11) : 0;
      if (n10.length === 0)
        return [];
      let o10 = [], a = s10(e11, n10[0], r10);
      for (let l of a)
        if (Array.isArray(l)) {
          if (l.length === 1 && Array.isArray(l[0])) {
            let c = l[0];
            c.length > i10 && o10.push([c.slice(i10)]);
            continue;
          }
          if (l.length === 2 && Array.isArray(l[0])) {
            let c = l[0], u = l[1];
            c.length > i10 && o10.push([c.slice(i10), u]);
          }
        }
      return o10;
    }
    default:
      return null;
  }
}
var W9;
var bh = I(() => {
  "use strict";
  En();
  gi();
  W9 = 2e3;
});
function ja(e11, t10, n10, r10, s10, i10, o10, a, l, c) {
  switch (t10) {
    case "getpath": {
      if (n10.length === 0)
        return [null];
      let u = s10(e11, n10[0], r10), f10 = [];
      for (let p of u) {
        let h = p, m = e11;
        for (let d of h) {
          if (m == null) {
            m = null;
            break;
          }
          if (Array.isArray(m) && typeof d == "number")
            m = m[d];
          else if (typeof m == "object" && typeof d == "string") {
            let g = m;
            if (!Object.hasOwn(g, d)) {
              m = null;
              break;
            }
            m = g[d];
          } else {
            m = null;
            break;
          }
        }
        f10.push(m);
      }
      return f10;
    }
    case "setpath": {
      if (n10.length < 2)
        return [null];
      let f10 = s10(e11, n10[0], r10)[0], h = s10(e11, n10[1], r10)[0];
      return [o10(e11, f10, h)];
    }
    case "delpaths": {
      if (n10.length === 0)
        return [e11];
      let f10 = s10(e11, n10[0], r10)[0], p = e11;
      for (let h of f10.sort((m, d) => d.length - m.length))
        p = a(p, h);
      return [p];
    }
    case "path": {
      if (n10.length === 0)
        return [[]];
      let u = [];
      return c(e11, n10[0], r10, [], u), u;
    }
    case "del":
      return n10.length === 0 ? [e11] : [l(e11, n10[0], r10)];
    case "pick": {
      if (n10.length === 0)
        return [null];
      let u = [];
      for (let p of n10)
        c(e11, p, r10, [], u);
      let f10 = null;
      for (let p of u) {
        for (let m of p)
          if (typeof m == "number" && m < 0)
            throw new Error("Out of bounds negative array index");
        let h = e11;
        for (let m of p) {
          if (h == null)
            break;
          if (Array.isArray(h) && typeof m == "number")
            h = h[m];
          else if (typeof h == "object" && typeof m == "string") {
            let d = h;
            if (!Object.hasOwn(d, m)) {
              h = null;
              break;
            }
            h = d[m];
          } else {
            h = null;
            break;
          }
        }
        f10 = o10(f10, p, h);
      }
      return [f10];
    }
    case "paths": {
      let u = [], f10 = (p, h) => {
        if (p && typeof p == "object")
          if (Array.isArray(p))
            for (let m = 0; m < p.length; m++)
              u.push([...h, m]), f10(p[m], [...h, m]);
          else
            for (let m of Object.keys(p))
              u.push([...h, m]), f10(p[m], [...h, m]);
      };
      return f10(e11, []), n10.length > 0 ? u.filter((p) => {
        let h = e11;
        for (let d of p)
          if (Array.isArray(h) && typeof d == "number")
            h = h[d];
          else if (h && typeof h == "object" && typeof d == "string") {
            let g = h;
            if (!Object.hasOwn(g, d))
              return false;
            h = g[d];
          } else
            return false;
        return s10(h, n10[0], r10).some(i10);
      }) : u;
    }
    case "leaf_paths": {
      let u = [], f10 = (p, h) => {
        if (p === null || typeof p != "object")
          u.push(h);
        else if (Array.isArray(p))
          for (let m = 0; m < p.length; m++)
            f10(p[m], [...h, m]);
        else
          for (let m of Object.keys(p))
            f10(p[m], [...h, m]);
      };
      return f10(e11, []), u;
    }
    default:
      return null;
  }
}
var xh = I(() => {
  "use strict";
});
function Ga(e11, t10, n10, r10, s10, i10) {
  switch (t10) {
    case "IN": {
      if (n10.length === 0)
        return [false];
      if (n10.length === 1) {
        let c = s10(e11, n10[0], r10);
        for (let u of c)
          if (i10(e11, u))
            return [true];
        return [false];
      }
      let o10 = s10(e11, n10[0], r10), a = s10(e11, n10[1], r10), l = new Set(a.map((c) => JSON.stringify(c)));
      for (let c of o10)
        if (l.has(JSON.stringify(c)))
          return [true];
      return [false];
    }
    case "INDEX": {
      if (n10.length === 0)
        return [{}];
      if (n10.length === 1) {
        let l = s10(e11, n10[0], r10), c = /* @__PURE__ */ Object.create(null);
        for (let u of l) {
          let f10 = String(u);
          Ie(f10) && Pe(c, f10, u);
        }
        return [c];
      }
      if (n10.length === 2) {
        let l = s10(e11, n10[0], r10), c = /* @__PURE__ */ Object.create(null);
        for (let u of l) {
          let f10 = s10(u, n10[1], r10);
          if (f10.length > 0) {
            let p = String(f10[0]);
            Ie(p) && Pe(c, p, u);
          }
        }
        return [c];
      }
      let o10 = s10(e11, n10[0], r10), a = /* @__PURE__ */ Object.create(null);
      for (let l of o10) {
        let c = s10(l, n10[1], r10), u = s10(l, n10[2], r10);
        if (c.length > 0 && u.length > 0) {
          let f10 = String(c[0]);
          Ie(f10) && Pe(a, f10, u[0]);
        }
      }
      return [a];
    }
    case "JOIN": {
      if (n10.length < 2)
        return [null];
      let o10 = s10(e11, n10[0], r10)[0];
      if (!o10 || typeof o10 != "object" || Array.isArray(o10))
        return [null];
      let a = o10;
      if (!Array.isArray(e11))
        return [null];
      let l = [];
      for (let c of e11) {
        let u = s10(c, n10[1], r10), f10 = u.length > 0 ? String(u[0]) : "", p = un(a, f10) ? a[f10] : null;
        l.push([c, p]);
      }
      return [l];
    }
    default:
      return null;
  }
}
var Eh = I(() => {
  "use strict";
  En();
});
function Va(e11, t10, n10, r10, s10) {
  switch (t10) {
    case "join": {
      if (!Array.isArray(e11))
        return [null];
      let i10 = n10.length > 0 ? s10(e11, n10[0], r10) : [""];
      for (let o10 of e11)
        if (Array.isArray(o10) || o10 !== null && typeof o10 == "object")
          throw new Error("cannot join: contains arrays or objects");
      return i10.map((o10) => e11.map((a) => a === null ? "" : typeof a == "string" ? a : String(a)).join(String(o10)));
    }
    case "split": {
      if (typeof e11 != "string" || n10.length === 0)
        return [null];
      let i10 = s10(e11, n10[0], r10), o10 = String(i10[0]);
      return [e11.split(o10)];
    }
    case "splits": {
      if (typeof e11 != "string" || n10.length === 0)
        return [];
      let i10 = s10(e11, n10[0], r10), o10 = String(i10[0]);
      try {
        let a = n10.length > 1 ? String(s10(e11, n10[1], r10)[0]) : "g";
        return V(o10, a.includes("g") ? a : `${a}g`).split(e11);
      } catch {
        return [];
      }
    }
    case "scan": {
      if (typeof e11 != "string" || n10.length === 0)
        return [];
      let i10 = s10(e11, n10[0], r10), o10 = String(i10[0]);
      try {
        let a = n10.length > 1 ? String(s10(e11, n10[1], r10)[0]) : "";
        return [...V(o10, a.includes("g") ? a : `${a}g`).matchAll(e11)].map((u) => u.length > 1 ? u.slice(1) : u[0]);
      } catch {
        return [];
      }
    }
    case "test": {
      if (typeof e11 != "string" || n10.length === 0)
        return [false];
      let i10 = s10(e11, n10[0], r10), o10 = String(i10[0]);
      try {
        let a = n10.length > 1 ? String(s10(e11, n10[1], r10)[0]) : "";
        return [V(o10, a).test(e11)];
      } catch {
        return [false];
      }
    }
    case "match": {
      if (typeof e11 != "string" || n10.length === 0)
        return [null];
      let i10 = s10(e11, n10[0], r10), o10 = String(i10[0]);
      try {
        let a = n10.length > 1 ? String(s10(e11, n10[1], r10)[0]) : "", c = V(o10, `${a}d`).exec(e11);
        if (!c)
          return [];
        let u = c.indices;
        return [{ offset: c.index, length: c[0].length, string: c[0], captures: c.slice(1).map((f10, p) => ({ offset: u?.[p + 1]?.[0] ?? null, length: f10?.length ?? 0, string: f10 ?? "", name: null })) }];
      } catch {
        return [null];
      }
    }
    case "capture": {
      if (typeof e11 != "string" || n10.length === 0)
        return [null];
      let i10 = s10(e11, n10[0], r10), o10 = String(i10[0]);
      try {
        let a = n10.length > 1 ? String(s10(e11, n10[1], r10)[0]) : "", c = V(o10, a).match(e11);
        return !c || !c.groups ? [{}] : [c.groups];
      } catch {
        return [null];
      }
    }
    case "sub": {
      if (typeof e11 != "string" || n10.length < 2)
        return [null];
      let i10 = s10(e11, n10[0], r10), o10 = s10(e11, n10[1], r10), a = String(i10[0]), l = String(o10[0]);
      try {
        let c = n10.length > 2 ? String(s10(e11, n10[2], r10)[0]) : "";
        return [V(a, c).replace(e11, l)];
      } catch {
        return [e11];
      }
    }
    case "gsub": {
      if (typeof e11 != "string" || n10.length < 2)
        return [null];
      let i10 = s10(e11, n10[0], r10), o10 = s10(e11, n10[1], r10), a = String(i10[0]), l = String(o10[0]);
      try {
        let c = n10.length > 2 ? String(s10(e11, n10[2], r10)[0]) : "g", u = c.includes("g") ? c : `${c}g`;
        return [V(a, u).replace(e11, l)];
      } catch {
        return [e11];
      }
    }
    case "ascii_downcase":
      return typeof e11 == "string" ? [e11.replace(/[A-Z]/g, (i10) => String.fromCharCode(i10.charCodeAt(0) + 32))] : [null];
    case "ascii_upcase":
      return typeof e11 == "string" ? [e11.replace(/[a-z]/g, (i10) => String.fromCharCode(i10.charCodeAt(0) - 32))] : [null];
    case "ltrimstr": {
      if (typeof e11 != "string" || n10.length === 0)
        return [e11];
      let i10 = s10(e11, n10[0], r10), o10 = String(i10[0]);
      return [e11.startsWith(o10) ? e11.slice(o10.length) : e11];
    }
    case "rtrimstr": {
      if (typeof e11 != "string" || n10.length === 0)
        return [e11];
      let i10 = s10(e11, n10[0], r10), o10 = String(i10[0]);
      return o10 === "" ? [e11] : [e11.endsWith(o10) ? e11.slice(0, -o10.length) : e11];
    }
    case "trimstr": {
      if (typeof e11 != "string" || n10.length === 0)
        return [e11];
      let i10 = s10(e11, n10[0], r10), o10 = String(i10[0]);
      if (o10 === "")
        return [e11];
      let a = e11;
      return a.startsWith(o10) && (a = a.slice(o10.length)), a.endsWith(o10) && (a = a.slice(0, -o10.length)), [a];
    }
    case "trim":
      if (typeof e11 == "string")
        return [e11.trim()];
      throw new Error("trim input must be a string");
    case "ltrim":
      if (typeof e11 == "string")
        return [e11.trimStart()];
      throw new Error("trim input must be a string");
    case "rtrim":
      if (typeof e11 == "string")
        return [e11.trimEnd()];
      throw new Error("trim input must be a string");
    case "startswith": {
      if (typeof e11 != "string" || n10.length === 0)
        return [false];
      let i10 = s10(e11, n10[0], r10);
      return [e11.startsWith(String(i10[0]))];
    }
    case "endswith": {
      if (typeof e11 != "string" || n10.length === 0)
        return [false];
      let i10 = s10(e11, n10[0], r10);
      return [e11.endsWith(String(i10[0]))];
    }
    case "ascii":
      return typeof e11 == "string" && e11.length > 0 ? [e11.charCodeAt(0)] : [null];
    case "explode":
      return typeof e11 == "string" ? [Array.from(e11).map((i10) => i10.codePointAt(0))] : [null];
    case "implode":
      if (!Array.isArray(e11))
        throw new Error("implode input must be an array");
      return [e11.map((a) => {
        if (typeof a == "string")
          throw new Error(`string (${JSON.stringify(a)}) can't be imploded, unicode codepoint needs to be numeric`);
        if (typeof a != "number" || Number.isNaN(a))
          throw new Error("number (null) can't be imploded, unicode codepoint needs to be numeric");
        let l = Math.trunc(a);
        return l < 0 || l > 1114111 || l >= 55296 && l <= 57343 ? String.fromCodePoint(65533) : String.fromCodePoint(l);
      }).join("")];
    default:
      return null;
  }
}
var Ah = I(() => {
  "use strict";
  Fe();
});
function qa(e11, t10) {
  switch (t10) {
    case "type":
      return e11 === null ? ["null"] : Array.isArray(e11) ? ["array"] : typeof e11 == "boolean" ? ["boolean"] : typeof e11 == "number" ? ["number"] : typeof e11 == "string" ? ["string"] : typeof e11 == "object" ? ["object"] : ["null"];
    case "infinite":
      return [Number.POSITIVE_INFINITY];
    case "nan":
      return [Number.NaN];
    case "isinfinite":
      return [typeof e11 == "number" && !Number.isFinite(e11)];
    case "isnan":
      return [typeof e11 == "number" && Number.isNaN(e11)];
    case "isnormal":
      return [typeof e11 == "number" && Number.isFinite(e11) && e11 !== 0];
    case "isfinite":
      return [typeof e11 == "number" && Number.isFinite(e11)];
    case "numbers":
      return typeof e11 == "number" ? [e11] : [];
    case "strings":
      return typeof e11 == "string" ? [e11] : [];
    case "booleans":
      return typeof e11 == "boolean" ? [e11] : [];
    case "nulls":
      return e11 === null ? [e11] : [];
    case "arrays":
      return Array.isArray(e11) ? [e11] : [];
    case "objects":
      return e11 && typeof e11 == "object" && !Array.isArray(e11) ? [e11] : [];
    case "iterables":
      return Array.isArray(e11) || e11 && typeof e11 == "object" && !Array.isArray(e11) ? [e11] : [];
    case "scalars":
      return !Array.isArray(e11) && !(e11 && typeof e11 == "object") ? [e11] : [];
    case "values":
      return e11 === null ? [] : [e11];
    case "not":
      return e11 === false || e11 === null ? [true] : [false];
    case "null":
      return [null];
    case "true":
      return [true];
    case "false":
      return [false];
    case "empty":
      return [];
    default:
      return null;
  }
}
var Sh = I(() => {
  "use strict";
});
var Ch = I(() => {
  "use strict";
  ph();
  hh();
  dh();
  mh();
  gh();
  yh();
  wh();
  bh();
  xh();
  Eh();
  Ah();
  Sh();
});
function yi(e11, t10, n10) {
  if (t10.length === 0)
    return n10;
  let [r10, ...s10] = t10;
  if (typeof r10 == "number") {
    if (e11 && typeof e11 == "object" && !Array.isArray(e11))
      throw new Error("Cannot index object with number");
    if (r10 > 536870911)
      throw new Error("Array index too large");
    if (r10 < 0)
      throw new Error("Out of bounds negative array index");
    let l = Array.isArray(e11) ? [...e11] : [];
    for (; l.length <= r10; )
      l.push(null);
    return l[r10] = yi(l[r10], s10, n10), l;
  }
  if (Array.isArray(e11))
    throw new Error("Cannot index array with string");
  if (!Ie(r10))
    return e11 ?? /* @__PURE__ */ Object.create(null);
  let i10 = e11 && typeof e11 == "object" && !Array.isArray(e11) ? Ze(e11) : /* @__PURE__ */ Object.create(null), o10 = Object.hasOwn(i10, r10) ? i10[r10] : void 0;
  return Pe(i10, r10, yi(o10, s10, n10)), i10;
}
function wi(e11, t10) {
  if (t10.length === 0)
    return null;
  if (t10.length === 1) {
    let s10 = t10[0];
    if (Array.isArray(e11) && typeof s10 == "number") {
      let i10 = [...e11];
      return i10.splice(s10, 1), i10;
    }
    if (e11 && typeof e11 == "object" && !Array.isArray(e11)) {
      let i10 = String(s10);
      if (!Ie(i10))
        return e11;
      let o10 = Ze(e11);
      return delete o10[i10], o10;
    }
    return e11;
  }
  let [n10, ...r10] = t10;
  if (Array.isArray(e11) && typeof n10 == "number") {
    let s10 = [...e11];
    return s10[n10] = wi(s10[n10], r10), s10;
  }
  if (e11 && typeof e11 == "object" && !Array.isArray(e11)) {
    let s10 = String(n10);
    if (!Ie(s10))
      return e11;
    let i10 = Ze(e11);
    return Object.hasOwn(i10, s10) && Pe(i10, s10, wi(i10[s10], r10)), i10;
  }
  return e11;
}
var Nh = I(() => {
  "use strict";
  En();
});
function H9(e11) {
  return { vars: /* @__PURE__ */ new Map(), limits: { maxIterations: e11?.limits?.maxIterations ?? B9, maxDepth: e11?.limits?.maxDepth ?? Ih }, env: e11?.env, coverage: e11?.coverage };
}
function Ei(e11, t10, n10) {
  let r10 = new Map(e11.vars);
  return r10.set(t10, n10), { vars: r10, limits: e11.limits, env: e11.env, root: e11.root, currentPath: e11.currentPath, funcs: e11.funcs, labels: e11.labels, coverage: e11.coverage };
}
function cs(e11, t10, n10) {
  switch (t10.type) {
    case "var":
      return Ei(e11, t10.name, n10);
    case "array": {
      if (!Array.isArray(n10))
        return null;
      let r10 = e11;
      for (let s10 = 0; s10 < t10.elements.length; s10++) {
        let i10 = t10.elements[s10], o10 = s10 < n10.length ? n10[s10] : null, a = cs(r10, i10, o10);
        if (a === null)
          return null;
        r10 = a;
      }
      return r10;
    }
    case "object": {
      if (n10 === null || typeof n10 != "object" || Array.isArray(n10))
        return null;
      let r10 = n10, s10 = e11;
      for (let i10 of t10.fields) {
        let o10;
        if (typeof i10.key == "string")
          o10 = i10.key;
        else {
          let c = G(n10, i10.key, e11);
          if (c.length === 0)
            return null;
          o10 = String(c[0]);
        }
        let a = un(r10, o10) ? r10[o10] : null;
        i10.keyVar && (s10 = Ei(s10, i10.keyVar, a));
        let l = cs(s10, i10.pattern, a);
        if (l === null)
          return null;
        s10 = l;
      }
      return s10;
    }
  }
}
function j9(e11, t10) {
  let n10 = e11;
  for (let r10 of t10)
    if (n10 && typeof n10 == "object")
      if (Array.isArray(n10))
        if (typeof r10 == "number")
          n10 = n10[r10];
        else
          return;
      else {
        let s10 = n10;
        if (typeof r10 == "string" && Object.hasOwn(s10, r10))
          n10 = s10[r10];
        else
          return;
      }
    else
      return;
  return n10;
}
function $n(e11) {
  if (e11.type === "Identity")
    return [];
  if (e11.type === "Field") {
    let t10 = e11.base ? $n(e11.base) : [];
    return t10 === null ? null : [...t10, e11.name];
  }
  if (e11.type === "Index" && e11.index.type === "Literal") {
    let t10 = e11.base ? $n(e11.base) : [];
    if (t10 === null)
      return null;
    let n10 = e11.index.value;
    return typeof n10 == "number" || typeof n10 == "string" ? [...t10, n10] : null;
  }
  if (e11.type === "Pipe") {
    let t10 = $n(e11.left);
    return t10 === null ? null : Za(t10, e11.right);
  }
  if (e11.type === "Call") {
    if (e11.name === "parent" || e11.name === "root")
      return null;
    if (e11.name === "first" && e11.args.length === 0)
      return [0];
    if (e11.name === "last" && e11.args.length === 0)
      return [-1];
  }
  return null;
}
function Za(e11, t10) {
  if (t10.type === "Call") {
    if (t10.name === "parent") {
      let n10 = 1;
      if (t10.args.length > 0 && t10.args[0].type === "Literal") {
        let r10 = t10.args[0].value;
        typeof r10 == "number" && (n10 = r10);
      }
      if (n10 >= 0)
        return e11.slice(0, Math.max(0, e11.length - n10));
      {
        let r10 = -n10 - 1;
        return e11.slice(0, Math.min(r10, e11.length));
      }
    }
    if (t10.name === "root")
      return [];
  }
  if (t10.type === "Field") {
    let n10 = $n(t10);
    if (n10 !== null)
      return [...e11, ...n10];
  }
  if (t10.type === "Index" && t10.index.type === "Literal") {
    let n10 = $n(t10);
    if (n10 !== null)
      return [...e11, ...n10];
  }
  if (t10.type === "Pipe") {
    let n10 = Za(e11, t10.left);
    return n10 === null ? null : Za(n10, t10.right);
  }
  return t10.type === "Identity" ? e11 : null;
}
function kh(e11, t10, n10) {
  if (t10.type === "Comma") {
    let r10 = [];
    try {
      r10.push(...G(e11, t10.left, n10));
    } catch (s10) {
      if (s10 instanceof te)
        throw s10;
      if (r10.length > 0)
        return r10;
      throw new Error("evaluation failed");
    }
    try {
      r10.push(...G(e11, t10.right, n10));
    } catch (s10) {
      if (s10 instanceof te)
        throw s10;
      return r10;
    }
    return r10;
  }
  return G(e11, t10, n10);
}
function G(e11, t10, n10) {
  let r10 = n10 && "vars" in n10 ? n10 : H9(n10);
  switch (r10.root === void 0 && (r10 = { ...r10, root: e11, currentPath: [] }), r10.coverage?.hit(`jq:node:${t10.type}`), t10.type) {
    case "Identity":
      return [e11];
    case "Field":
      return (t10.base ? G(e11, t10.base, r10) : [e11]).flatMap((i10) => {
        if (i10 && typeof i10 == "object" && !Array.isArray(i10)) {
          let a = i10;
          if (!Object.hasOwn(a, t10.name))
            return [null];
          let l = a[t10.name];
          return [l === void 0 ? null : l];
        }
        if (i10 === null)
          return [null];
        let o10 = Array.isArray(i10) ? "array" : typeof i10;
        throw new Error(`Cannot index ${o10} with string "${t10.name}"`);
      });
    case "Index":
      return (t10.base ? G(e11, t10.base, r10) : [e11]).flatMap((i10) => G(i10, t10.index, r10).flatMap((a) => {
        if (typeof a == "number" && Array.isArray(i10)) {
          if (Number.isNaN(a))
            return [null];
          let l = Math.trunc(a), c = l < 0 ? i10.length + l : l;
          return c >= 0 && c < i10.length ? [i10[c]] : [null];
        }
        if (typeof a == "string" && i10 && typeof i10 == "object" && !Array.isArray(i10)) {
          let l = i10;
          return Object.hasOwn(l, a) ? [l[a]] : [null];
        }
        return [null];
      }));
    case "Slice":
      return (t10.base ? G(e11, t10.base, r10) : [e11]).flatMap((i10) => {
        if (i10 === null)
          return [null];
        if (!Array.isArray(i10) && typeof i10 != "string")
          throw new Error(`Cannot slice ${typeof i10} (${JSON.stringify(i10)})`);
        let o10 = i10.length, a = t10.start ? G(e11, t10.start, r10) : [0], l = t10.end ? G(e11, t10.end, r10) : [o10];
        return a.flatMap((c) => l.map((u) => {
          let f10 = c, p = u, h = Number.isNaN(f10) ? 0 : Number.isInteger(f10) ? f10 : Math.floor(f10), m = Number.isNaN(p) ? o10 : Number.isInteger(p) ? p : Math.ceil(p), d = vh(h, o10), g = vh(m, o10);
          return Array.isArray(i10), i10.slice(d, g);
        }));
      });
    case "Iterate":
      return (t10.base ? G(e11, t10.base, r10) : [e11]).flatMap((i10) => Array.isArray(i10) ? i10 : i10 && typeof i10 == "object" ? Object.values(i10) : []);
    case "Pipe": {
      let s10 = G(e11, t10.left, r10), i10 = $n(t10.left), o10 = [];
      for (let a of s10)
        try {
          if (i10 !== null) {
            let l = { ...r10, currentPath: [...r10.currentPath ?? [], ...i10] };
            o10.push(...G(a, t10.right, l));
          } else
            o10.push(...G(a, t10.right, r10));
        } catch (l) {
          throw l instanceof Nr ? l.withPrependedResults(o10) : l;
        }
      return o10;
    }
    case "Comma": {
      let s10 = G(e11, t10.left, r10), i10 = G(e11, t10.right, r10);
      return [...s10, ...i10];
    }
    case "Literal":
      return [t10.value];
    case "Array":
      return t10.elements ? [G(e11, t10.elements, r10)] : [[]];
    case "Object": {
      let s10 = [/* @__PURE__ */ Object.create(null)];
      for (let i10 of t10.entries) {
        let o10 = typeof i10.key == "string" ? [i10.key] : G(e11, i10.key, r10), a = G(e11, i10.value, r10), l = [];
        for (let c of s10)
          for (let u of o10) {
            if (typeof u != "string") {
              let f10 = u === null ? "null" : Array.isArray(u) ? "array" : typeof u;
              throw new Error(`Cannot use ${f10} (${JSON.stringify(u)}) as object key`);
            }
            if (!Ie(u)) {
              for (let f10 of a)
                l.push(Ze(c));
              continue;
            }
            for (let f10 of a) {
              let p = Ze(c);
              Pe(p, u, f10), l.push(p);
            }
          }
        s10.length = 0, s10.push(...l);
      }
      return s10;
    }
    case "Paren":
      return G(e11, t10.expr, r10);
    case "BinaryOp":
      return q9(e11, t10.op, t10.left, t10.right, r10);
    case "UnaryOp":
      return G(e11, t10.operand, r10).map((i10) => {
        if (t10.op === "-") {
          if (typeof i10 == "number")
            return -i10;
          if (typeof i10 == "string") {
            let o10 = (a) => a.length > 5 ? `"${a.slice(0, 3)}...` : JSON.stringify(a);
            throw new Error(`string (${o10(i10)}) cannot be negated`);
          }
          return null;
        }
        return t10.op === "not" ? !Zt(i10) : null;
      });
    case "Cond":
      return G(e11, t10.cond, r10).flatMap((i10) => {
        if (Zt(i10))
          return G(e11, t10.then, r10);
        for (let o10 of t10.elifs)
          if (G(e11, o10.cond, r10).some(Zt))
            return G(e11, o10.then, r10);
        return t10.else ? G(e11, t10.else, r10) : [e11];
      });
    case "Try":
      try {
        return G(e11, t10.body, r10);
      } catch (s10) {
        if (t10.catch) {
          let i10 = s10 instanceof xi ? s10.value : s10 instanceof Error ? s10.message : String(s10);
          return G(i10, t10.catch, r10);
        }
        return [];
      }
    case "Call":
      return Oh(e11, t10.name, t10.args, r10);
    case "VarBind":
      return G(e11, t10.value, r10).flatMap((i10) => {
        let o10 = null, a = [];
        t10.pattern ? a.push(t10.pattern) : t10.name && a.push({ type: "var", name: t10.name }), t10.alternatives && a.push(...t10.alternatives);
        for (let l of a)
          if (o10 = cs(r10, l, i10), o10 !== null)
            break;
        return o10 === null ? [] : G(e11, t10.body, o10);
      });
    case "VarRef": {
      if (t10.name === "$ENV")
        return [r10.env ? xt(r10.env) : /* @__PURE__ */ Object.create(null)];
      let s10 = r10.vars.get(t10.name);
      return s10 !== void 0 ? [s10] : [null];
    }
    case "Recurse": {
      let s10 = [], i10 = /* @__PURE__ */ new WeakSet(), o10 = (a) => {
        if (a && typeof a == "object") {
          if (i10.has(a))
            return;
          i10.add(a);
        }
        if (s10.push(a), Array.isArray(a))
          for (let l of a)
            o10(l);
        else if (a && typeof a == "object")
          for (let l of Object.keys(a))
            o10(a[l]);
      };
      return o10(e11), s10;
    }
    case "Optional":
      try {
        return G(e11, t10.expr, r10);
      } catch {
        return [];
      }
    case "StringInterp":
      return [t10.parts.map((i10) => typeof i10 == "string" ? i10 : G(e11, i10, r10).map((a) => typeof a == "string" ? a : JSON.stringify(a)).join("")).join("")];
    case "UpdateOp":
      return [G9(e11, t10.path, t10.op, t10.value, r10)];
    case "Reduce": {
      let s10 = G(e11, t10.expr, r10), i10 = G(e11, t10.init, r10)[0], o10 = r10.limits.maxDepth ?? Ih;
      for (let a of s10) {
        let l;
        if (t10.pattern) {
          if (l = cs(r10, t10.pattern, a), l === null)
            continue;
        } else
          l = Ei(r10, t10.varName, a);
        if (i10 = G(i10, t10.update, l)[0], Cr(i10, o10 + 1) > o10)
          return [null];
      }
      return [i10];
    }
    case "Foreach": {
      let s10 = G(e11, t10.expr, r10), i10 = G(e11, t10.init, r10)[0], o10 = [];
      for (let a of s10)
        try {
          let l;
          if (t10.pattern) {
            if (l = cs(r10, t10.pattern, a), l === null)
              continue;
          } else
            l = Ei(r10, t10.varName, a);
          if (i10 = G(i10, t10.update, l)[0], t10.extract) {
            let c = G(i10, t10.extract, l);
            o10.push(...c);
          } else
            o10.push(i10);
        } catch (l) {
          throw l instanceof Nr ? l.withPrependedResults(o10) : l;
        }
      return o10;
    }
    case "Label":
      try {
        return G(e11, t10.body, { ...r10, labels: /* @__PURE__ */ new Set([...r10.labels ?? [], t10.name]) });
      } catch (s10) {
        if (s10 instanceof Nr && s10.label === t10.name)
          return s10.partialResults;
        throw s10;
      }
    case "Break":
      throw new Nr(t10.name);
    case "Def": {
      let s10 = new Map(r10.funcs ?? []), i10 = `${t10.name}/${t10.params.length}`;
      s10.set(i10, { params: t10.params, body: t10.funcBody, closure: new Map(r10.funcs ?? []) });
      let o10 = { ...r10, funcs: s10 };
      return G(e11, t10.body, o10);
    }
    default: {
      let s10 = t10;
      throw new Error(`Unknown AST node type: ${s10.type}`);
    }
  }
}
function vh(e11, t10) {
  return e11 < 0 ? Math.max(0, t10 + e11) : Math.min(e11, t10);
}
function G9(e11, t10, n10, r10, s10) {
  function i10(l, c) {
    switch (n10) {
      case "=":
        return c;
      case "|=":
        return G(l, r10, s10)[0] ?? null;
      case "+=":
        return typeof l == "number" && typeof c == "number" || typeof l == "string" && typeof c == "string" ? l + c : Array.isArray(l) && Array.isArray(c) ? [...l, ...c] : l && c && typeof l == "object" && typeof c == "object" ? Da(l, c) : c;
      case "-=":
        return typeof l == "number" && typeof c == "number" ? l - c : l;
      case "*=":
        return typeof l == "number" && typeof c == "number" ? l * c : l;
      case "/=":
        return typeof l == "number" && typeof c == "number" ? l / c : l;
      case "%=":
        return typeof l == "number" && typeof c == "number" ? l % c : l;
      case "//=":
        return l === null || l === false ? c : l;
      default:
        return c;
    }
  }
  function o10(l, c, u) {
    switch (c.type) {
      case "Identity":
        return u(l);
      case "Field": {
        if (!Ie(c.name))
          return l;
        if (c.base)
          return o10(l, c.base, (f10) => {
            if (f10 && typeof f10 == "object" && !Array.isArray(f10)) {
              let p = Ze(f10), h = Object.hasOwn(p, c.name) ? p[c.name] : void 0;
              return Pe(p, c.name, u(h)), p;
            }
            return f10;
          });
        if (l && typeof l == "object" && !Array.isArray(l)) {
          let f10 = Ze(l), p = Object.hasOwn(f10, c.name) ? f10[c.name] : void 0;
          return Pe(f10, c.name, u(p)), f10;
        }
        return l;
      }
      case "Index": {
        let p = G(e11, c.index, s10)[0];
        if (typeof p == "number" && Number.isNaN(p))
          throw new Error("Cannot set array element at NaN index");
        if (typeof p == "number" && !Number.isInteger(p) && (p = Math.trunc(p)), c.base)
          return o10(l, c.base, (h) => {
            if (typeof p == "number" && Array.isArray(h)) {
              let m = [...h], d = p < 0 ? m.length + p : p;
              if (d >= 0) {
                for (; m.length <= d; )
                  m.push(null);
                m[d] = u(m[d]);
              }
              return m;
            }
            if (typeof p == "string" && h && typeof h == "object" && !Array.isArray(h)) {
              if (!Ie(p))
                return h;
              let m = Ze(h), d = Object.hasOwn(m, p) ? m[p] : void 0;
              return Pe(m, p, u(d)), m;
            }
            return h;
          });
        if (typeof p == "number") {
          if (p > 536870911)
            throw new Error("Array index too large");
          if (p < 0 && (!l || !Array.isArray(l)))
            throw new Error("Out of bounds negative array index");
          if (Array.isArray(l)) {
            let m = [...l], d = p < 0 ? m.length + p : p;
            if (d >= 0) {
              for (; m.length <= d; )
                m.push(null);
              m[d] = u(m[d]);
            }
            return m;
          }
          if (l == null) {
            let m = [];
            for (; m.length <= p; )
              m.push(null);
            return m[p] = u(null), m;
          }
          return l;
        }
        if (typeof p == "string" && l && typeof l == "object" && !Array.isArray(l)) {
          if (!Ie(p))
            return l;
          let h = Ze(l), m = Object.hasOwn(h, p) ? h[p] : void 0;
          return Pe(h, p, u(m)), h;
        }
        return l;
      }
      case "Iterate": {
        let f10 = (p) => {
          if (Array.isArray(p))
            return p.map((h) => u(h));
          if (p && typeof p == "object") {
            let h = /* @__PURE__ */ Object.create(null);
            for (let [m, d] of Object.entries(p))
              Ie(m) && Pe(h, m, u(d));
            return h;
          }
          return p;
        };
        return c.base ? o10(l, c.base, f10) : f10(l);
      }
      case "Pipe": {
        let f10 = o10(l, c.left, (p) => p);
        return o10(f10, c.right, u);
      }
      default:
        return u(l);
    }
  }
  return o10(e11, t10, (l) => {
    if (n10 === "|=")
      return i10(l, l);
    let c = G(e11, r10, s10);
    return i10(l, c[0] ?? null);
  });
}
function V9(e11, t10, n10) {
  function r10(i10, o10, a) {
    switch (o10.type) {
      case "Identity":
        return a;
      case "Field": {
        if (!Ie(o10.name))
          return i10;
        if (o10.base) {
          let l = G(i10, o10.base, n10)[0], c = r10(l, { type: "Field", name: o10.name }, a);
          return r10(i10, o10.base, c);
        }
        if (i10 && typeof i10 == "object" && !Array.isArray(i10)) {
          let l = Ze(i10);
          return Pe(l, o10.name, a), l;
        }
        return i10;
      }
      case "Index": {
        if (o10.base) {
          let u = G(i10, o10.base, n10)[0], f10 = r10(u, { type: "Index", index: o10.index }, a);
          return r10(i10, o10.base, f10);
        }
        let c = G(e11, o10.index, n10)[0];
        if (typeof c == "number" && Array.isArray(i10)) {
          let u = [...i10], f10 = c < 0 ? u.length + c : c;
          return f10 >= 0 && f10 < u.length && (u[f10] = a), u;
        }
        if (typeof c == "string" && i10 && typeof i10 == "object" && !Array.isArray(i10)) {
          if (!Ie(c))
            return i10;
          let u = Ze(i10);
          return Pe(u, c, a), u;
        }
        return i10;
      }
      default:
        return i10;
    }
  }
  function s10(i10, o10) {
    switch (o10.type) {
      case "Identity":
        return null;
      case "Field": {
        if (!Ie(o10.name))
          return i10;
        if (o10.base) {
          let l = G(i10, o10.base, n10)[0];
          if (l == null)
            return i10;
          let c = s10(l, { type: "Field", name: o10.name });
          return r10(i10, o10.base, c);
        }
        if (i10 && typeof i10 == "object" && !Array.isArray(i10)) {
          if (!Ie(o10.name))
            return i10;
          let l = Ze(i10);
          return delete l[o10.name], l;
        }
        return i10;
      }
      case "Index": {
        if (o10.base) {
          let u = G(i10, o10.base, n10)[0];
          if (u == null)
            return i10;
          let f10 = s10(u, { type: "Index", index: o10.index });
          return r10(i10, o10.base, f10);
        }
        let c = G(e11, o10.index, n10)[0];
        if (typeof c == "number" && Array.isArray(i10)) {
          let u = [...i10], f10 = c < 0 ? u.length + c : c;
          return f10 >= 0 && f10 < u.length && u.splice(f10, 1), u;
        }
        if (typeof c == "string" && i10 && typeof i10 == "object" && !Array.isArray(i10)) {
          if (!Ie(c))
            return i10;
          let u = Ze(i10);
          return delete u[c], u;
        }
        return i10;
      }
      case "Iterate":
        return Array.isArray(i10) ? [] : i10 && typeof i10 == "object" ? /* @__PURE__ */ Object.create(null) : i10;
      case "Pipe": {
        let u = function(h, m, d) {
          switch (m.type) {
            case "Identity":
              return d;
            case "Field": {
              if (!Ie(m.name))
                return h;
              if (h && typeof h == "object" && !Array.isArray(h)) {
                let g = Ze(h);
                return Pe(g, m.name, d), g;
              }
              return h;
            }
            case "Index": {
              let y = G(e11, m.index, n10)[0];
              if (typeof y == "number" && Array.isArray(h)) {
                let w = [...h], b = y < 0 ? w.length + y : y;
                return b >= 0 && b < w.length && (w[b] = d), w;
              }
              if (typeof y == "string" && h && typeof h == "object" && !Array.isArray(h)) {
                if (!Ie(y))
                  return h;
                let w = Ze(h);
                return Pe(w, y, d), w;
              }
              return h;
            }
            case "Pipe": {
              let g = G(h, m.left, n10)[0], y = u(g, m.right, d);
              return u(h, m.left, y);
            }
            default:
              return h;
          }
        };
        var a = u;
        let l = o10.left, c = o10.right, f10 = G(i10, l, n10)[0];
        if (f10 == null)
          return i10;
        let p = s10(f10, c);
        return u(i10, l, p);
      }
      default:
        return i10;
    }
  }
  return s10(e11, t10);
}
function q9(e11, t10, n10, r10, s10) {
  if (t10 === "and")
    return G(e11, n10, s10).flatMap((l) => Zt(l) ? G(e11, r10, s10).map((u) => Zt(u)) : [false]);
  if (t10 === "or")
    return G(e11, n10, s10).flatMap((l) => Zt(l) ? [true] : G(e11, r10, s10).map((u) => Zt(u)));
  if (t10 === "//") {
    let l = G(e11, n10, s10).filter((c) => c != null && c !== false);
    return l.length > 0 ? l : G(e11, r10, s10);
  }
  let i10 = G(e11, n10, s10), o10 = G(e11, r10, s10);
  return i10.flatMap((a) => o10.map((l) => {
    switch (t10) {
      case "+":
        return a === null ? l : l === null ? a : typeof a == "number" && typeof l == "number" || typeof a == "string" && typeof l == "string" ? a + l : Array.isArray(a) && Array.isArray(l) ? [...a, ...l] : a && l && typeof a == "object" && typeof l == "object" && !Array.isArray(a) && !Array.isArray(l) ? Da(a, l) : null;
      case "-":
        if (typeof a == "number" && typeof l == "number")
          return a - l;
        if (Array.isArray(a) && Array.isArray(l)) {
          let c = new Set(l.map((u) => JSON.stringify(u)));
          return a.filter((u) => !c.has(JSON.stringify(u)));
        }
        if (typeof a == "string" && typeof l == "string") {
          let c = (u) => u.length > 10 ? `"${u.slice(0, 10)}...` : JSON.stringify(u);
          throw new Error(`string (${c(a)}) and string (${c(l)}) cannot be subtracted`);
        }
        return null;
      case "*":
        return typeof a == "number" && typeof l == "number" ? a * l : typeof a == "string" && typeof l == "number" ? a.repeat(l) : a && l && typeof a == "object" && typeof l == "object" && !Array.isArray(a) && !Array.isArray(l) ? Ma(a, l) : null;
      case "/":
        if (typeof a == "number" && typeof l == "number") {
          if (l === 0)
            throw new Error(`number (${a}) and number (${l}) cannot be divided because the divisor is zero`);
          return a / l;
        }
        return typeof a == "string" && typeof l == "string" ? a.split(l) : null;
      case "%":
        if (typeof a == "number" && typeof l == "number") {
          if (l === 0)
            throw new Error(`number (${a}) and number (${l}) cannot be divided (remainder) because the divisor is zero`);
          return !Number.isFinite(a) && !Number.isNaN(a) ? !Number.isFinite(l) && !Number.isNaN(l) && a < 0 && l > 0 ? -1 : 0 : a % l;
        }
        return null;
      case "==":
        return Sr(a, l);
      case "!=":
        return !Sr(a, l);
      case "<":
        return ls(a, l) < 0;
      case "<=":
        return ls(a, l) <= 0;
      case ">":
        return ls(a, l) > 0;
      case ">=":
        return ls(a, l) >= 0;
      default:
        return null;
    }
  }));
}
function Oh(e11, t10, n10, r10) {
  let s10 = z9.get(t10);
  if (s10)
    return typeof e11 == "number" ? [s10(e11)] : [null];
  let i10 = Ba(e11, t10, n10, r10, G);
  if (i10 !== null)
    return i10;
  let o10 = Va(e11, t10, n10, r10, G);
  if (o10 !== null)
    return o10;
  let a = Fa(e11, t10, n10, r10, G);
  if (a !== null)
    return a;
  let l = Ua(e11, t10, r10.limits.maxDepth);
  if (l !== null)
    return l;
  let c = qa(e11, t10);
  if (c !== null)
    return c;
  let u = Ha(e11, t10, n10, r10, G);
  if (u !== null)
    return u;
  let f10 = _a2(e11, t10, n10, r10, G, kh, di, Zt, mi, te);
  if (f10 !== null)
    return f10;
  let p = ja(e11, t10, n10, r10, G, Zt, yi, wi, V9, bi);
  if (p !== null)
    return p;
  let h = Wa(e11, t10, n10, r10, G, Sr);
  if (h !== null)
    return h;
  let m = La(e11, t10, n10, r10, G, kh, Zt, te);
  if (m !== null)
    return m;
  let d = za(e11, t10, n10, r10, G, Zt, j9, Oh);
  if (d !== null)
    return d;
  let g = Ga(e11, t10, n10, r10, G, Sr);
  if (g !== null)
    return g;
  switch (t10) {
    case "builtins":
      return [["add/0", "all/0", "all/1", "all/2", "any/0", "any/1", "any/2", "arrays/0", "ascii/0", "ascii_downcase/0", "ascii_upcase/0", "booleans/0", "bsearch/1", "builtins/0", "combinations/0", "combinations/1", "contains/1", "debug/0", "del/1", "delpaths/1", "empty/0", "env/0", "error/0", "error/1", "explode/0", "first/0", "first/1", "flatten/0", "flatten/1", "floor/0", "from_entries/0", "fromdate/0", "fromjson/0", "getpath/1", "gmtime/0", "group_by/1", "gsub/2", "gsub/3", "has/1", "implode/0", "IN/1", "IN/2", "INDEX/1", "INDEX/2", "index/1", "indices/1", "infinite/0", "inside/1", "isempty/1", "isnan/0", "isnormal/0", "isvalid/1", "iterables/0", "join/1", "keys/0", "keys_unsorted/0", "last/0", "last/1", "length/0", "limit/2", "ltrimstr/1", "map/1", "map_values/1", "match/1", "match/2", "max/0", "max_by/1", "min/0", "min_by/1", "mktime/0", "modulemeta/1", "nan/0", "not/0", "nth/1", "nth/2", "null/0", "nulls/0", "numbers/0", "objects/0", "path/1", "paths/0", "paths/1", "pick/1", "range/1", "range/2", "range/3", "recurse/0", "recurse/1", "recurse_down/0", "repeat/1", "reverse/0", "rindex/1", "rtrimstr/1", "scalars/0", "scan/1", "scan/2", "select/1", "setpath/2", "skip/2", "sort/0", "sort_by/1", "split/1", "splits/1", "splits/2", "sqrt/0", "startswith/1", "strftime/1", "strings/0", "strptime/1", "sub/2", "sub/3", "test/1", "test/2", "to_entries/0", "toboolean/0", "todate/0", "tojson/0", "tostream/0", "fromstream/1", "truncate_stream/1", "tonumber/0", "tostring/0", "transpose/0", "trim/0", "ltrim/0", "rtrim/0", "type/0", "unique/0", "unique_by/1", "until/2", "utf8bytelength/0", "values/0", "walk/1", "while/2", "with_entries/1"]];
    case "error": {
      let y = n10.length > 0 ? G(e11, n10[0], r10)[0] : e11;
      throw new xi(y);
    }
    case "env":
      return [r10.env ? xt(r10.env) : /* @__PURE__ */ Object.create(null)];
    case "debug":
      return [e11];
    case "input_line_number":
      return [1];
    default: {
      let y = `${t10}/${n10.length}`, w = r10.funcs?.get(y);
      if (w) {
        let b = w.closure ?? r10.funcs ?? /* @__PURE__ */ new Map(), x = new Map(b);
        x.set(y, w);
        for (let O = 0; O < w.params.length; O++) {
          let R10 = w.params[O], F4 = n10[O];
          if (F4) {
            let $ = G(e11, F4, r10), z;
            if ($.length === 0)
              z = { type: "Call", name: "empty", args: [] };
            else if ($.length === 1)
              z = { type: "Literal", value: $[0] };
            else {
              z = { type: "Literal", value: $[$.length - 1] };
              for (let k = $.length - 2; k >= 0; k--)
                z = { type: "Comma", left: { type: "Literal", value: $[k] }, right: z };
            }
            x.set(`${R10}/0`, { params: [], body: z });
          }
        }
        let S = { ...r10, funcs: x };
        return G(e11, w.body, S);
      }
      throw new Error(`Unknown function: ${t10}`);
    }
  }
}
function bi(e11, t10, n10, r10, s10) {
  if (t10.type === "Comma") {
    let a = t10;
    bi(e11, a.left, n10, r10, s10), bi(e11, a.right, n10, r10, s10);
    return;
  }
  let i10 = $n(t10);
  if (i10 !== null) {
    s10.push([...r10, ...i10]);
    return;
  }
  if (t10.type === "Iterate") {
    if (Array.isArray(e11))
      for (let a = 0; a < e11.length; a++)
        s10.push([...r10, a]);
    else if (e11 && typeof e11 == "object")
      for (let a of Object.keys(e11))
        s10.push([...r10, a]);
    return;
  }
  if (t10.type === "Recurse") {
    let a = (l, c) => {
      if (s10.push([...r10, ...c]), l && typeof l == "object")
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++)
            a(l[u], [...c, u]);
        else
          for (let u of Object.keys(l))
            a(l[u], [...c, u]);
    };
    a(e11, []);
    return;
  }
  if (t10.type === "Pipe") {
    let a = $n(t10.left);
    if (a !== null) {
      let l = G(e11, t10.left, n10);
      for (let c of l)
        bi(c, t10.right, n10, [...r10, ...a], s10);
      return;
    }
  }
  G(e11, t10, n10).length > 0 && s10.push(r10);
}
var Nr;
var xi;
var B9;
var Ih;
var z9;
var Rh = I(() => {
  "use strict";
  On();
  ye();
  Ch();
  Nh();
  En();
  gi();
  Nr = class e11 extends Error {
    label;
    partialResults;
    constructor(t10, n10 = []) {
      super(`break ${t10}`), this.label = t10, this.partialResults = n10, this.name = "BreakError";
    }
    withPrependedResults(t10) {
      return new e11(this.label, [...t10, ...this.partialResults]);
    }
  }, xi = class extends Error {
    value;
    constructor(t10) {
      super(typeof t10 == "string" ? t10 : JSON.stringify(t10)), this.value = t10, this.name = "JqError";
    }
  }, B9 = 1e4, Ih = 2e3, z9 = /* @__PURE__ */ new Map([["floor", Math.floor], ["ceil", Math.ceil], ["round", Math.round], ["sqrt", Math.sqrt], ["log", Math.log], ["log10", Math.log10], ["log2", Math.log2], ["exp", Math.exp], ["sin", Math.sin], ["cos", Math.cos], ["tan", Math.tan], ["asin", Math.asin], ["acos", Math.acos], ["atan", Math.atan], ["sinh", Math.sinh], ["cosh", Math.cosh], ["tanh", Math.tanh], ["asinh", Math.asinh], ["acosh", Math.acosh], ["atanh", Math.atanh], ["cbrt", Math.cbrt], ["expm1", Math.expm1], ["log1p", Math.log1p], ["trunc", Math.trunc]]);
});
function Th(e11) {
  let t10 = [], n10 = 0, r10 = (c = 0) => e11[n10 + c], s10 = () => e11[n10++], i10 = () => n10 >= e11.length, o10 = (c) => c >= "0" && c <= "9", a = (c) => c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "_", l = (c) => a(c) || o10(c);
  for (; !i10(); ) {
    let c = n10, u = s10();
    if (!(u === " " || u === "	" || u === `
` || u === "\r")) {
      if (u === "#") {
        for (; !i10() && r10() !== `
`; )
          s10();
        continue;
      }
      if (u === "." && r10() === ".") {
        s10(), t10.push({ type: "DOTDOT", pos: c });
        continue;
      }
      if (u === "=" && r10() === "=") {
        s10(), t10.push({ type: "EQ", pos: c });
        continue;
      }
      if (u === "!" && r10() === "=") {
        s10(), t10.push({ type: "NE", pos: c });
        continue;
      }
      if (u === "<" && r10() === "=") {
        s10(), t10.push({ type: "LE", pos: c });
        continue;
      }
      if (u === ">" && r10() === "=") {
        s10(), t10.push({ type: "GE", pos: c });
        continue;
      }
      if (u === "/" && r10() === "/") {
        s10(), r10() === "=" ? (s10(), t10.push({ type: "UPDATE_ALT", pos: c })) : t10.push({ type: "ALT", pos: c });
        continue;
      }
      if (u === "+" && r10() === "=") {
        s10(), t10.push({ type: "UPDATE_ADD", pos: c });
        continue;
      }
      if (u === "-" && r10() === "=") {
        s10(), t10.push({ type: "UPDATE_SUB", pos: c });
        continue;
      }
      if (u === "*" && r10() === "=") {
        s10(), t10.push({ type: "UPDATE_MUL", pos: c });
        continue;
      }
      if (u === "/" && r10() === "=") {
        s10(), t10.push({ type: "UPDATE_DIV", pos: c });
        continue;
      }
      if (u === "%" && r10() === "=") {
        s10(), t10.push({ type: "UPDATE_MOD", pos: c });
        continue;
      }
      if (u === "=" && r10() !== "=") {
        t10.push({ type: "ASSIGN", pos: c });
        continue;
      }
      if (u === ".") {
        t10.push({ type: "DOT", pos: c });
        continue;
      }
      if (u === "|") {
        r10() === "=" ? (s10(), t10.push({ type: "UPDATE_PIPE", pos: c })) : t10.push({ type: "PIPE", pos: c });
        continue;
      }
      if (u === ",") {
        t10.push({ type: "COMMA", pos: c });
        continue;
      }
      if (u === ":") {
        t10.push({ type: "COLON", pos: c });
        continue;
      }
      if (u === ";") {
        t10.push({ type: "SEMICOLON", pos: c });
        continue;
      }
      if (u === "(") {
        t10.push({ type: "LPAREN", pos: c });
        continue;
      }
      if (u === ")") {
        t10.push({ type: "RPAREN", pos: c });
        continue;
      }
      if (u === "[") {
        t10.push({ type: "LBRACKET", pos: c });
        continue;
      }
      if (u === "]") {
        t10.push({ type: "RBRACKET", pos: c });
        continue;
      }
      if (u === "{") {
        t10.push({ type: "LBRACE", pos: c });
        continue;
      }
      if (u === "}") {
        t10.push({ type: "RBRACE", pos: c });
        continue;
      }
      if (u === "?") {
        t10.push({ type: "QUESTION", pos: c });
        continue;
      }
      if (u === "+") {
        t10.push({ type: "PLUS", pos: c });
        continue;
      }
      if (u === "-") {
        t10.push({ type: "MINUS", pos: c });
        continue;
      }
      if (u === "*") {
        t10.push({ type: "STAR", pos: c });
        continue;
      }
      if (u === "/") {
        t10.push({ type: "SLASH", pos: c });
        continue;
      }
      if (u === "%") {
        t10.push({ type: "PERCENT", pos: c });
        continue;
      }
      if (u === "<") {
        t10.push({ type: "LT", pos: c });
        continue;
      }
      if (u === ">") {
        t10.push({ type: "GT", pos: c });
        continue;
      }
      if (o10(u)) {
        let f10 = u;
        for (; !i10() && (o10(r10()) || r10() === "." || r10() === "e" || r10() === "E"); )
          (r10() === "e" || r10() === "E") && (e11[n10 + 1] === "+" || e11[n10 + 1] === "-") && (f10 += s10()), f10 += s10();
        t10.push({ type: "NUMBER", value: Number(f10), pos: c });
        continue;
      }
      if (u === '"') {
        let f10 = "";
        for (; !i10() && r10() !== '"'; )
          if (r10() === "\\") {
            if (s10(), i10())
              break;
            let p = s10();
            switch (p) {
              case "n":
                f10 += `
`;
                break;
              case "r":
                f10 += "\r";
                break;
              case "t":
                f10 += "	";
                break;
              case "\\":
                f10 += "\\";
                break;
              case '"':
                f10 += '"';
                break;
              case "(":
                f10 += "\\(";
                break;
              default:
                f10 += p;
            }
          } else
            f10 += s10();
        i10() || s10(), t10.push({ type: "STRING", value: f10, pos: c });
        continue;
      }
      if (a(u) || u === "$" || u === "@") {
        let f10 = u;
        for (; !i10() && l(r10()); )
          f10 += s10();
        let p = $h.get(f10);
        p ? t10.push({ type: p, value: f10, pos: c }) : t10.push({ type: "IDENT", value: f10, pos: c });
        continue;
      }
      throw new Error(`Unexpected character '${u}' at position ${c}`);
    }
  }
  return t10.push({ type: "EOF", pos: n10 }), t10;
}
function Ph(e11) {
  let t10 = Th(e11);
  return new Qa(t10).parse();
}
var $h;
var Ai;
var Qa;
var Dh = I(() => {
  "use strict";
  $h = /* @__PURE__ */ new Map([["and", "AND"], ["or", "OR"], ["not", "NOT"], ["if", "IF"], ["then", "THEN"], ["elif", "ELIF"], ["else", "ELSE"], ["end", "END"], ["as", "AS"], ["try", "TRY"], ["catch", "CATCH"], ["true", "TRUE"], ["false", "FALSE"], ["null", "NULL"], ["reduce", "REDUCE"], ["foreach", "FOREACH"], ["label", "LABEL"], ["break", "BREAK"], ["def", "DEF"]]), Ai = new Set($h.values());
  Qa = class e11 {
    tokens;
    pos = 0;
    constructor(t10) {
      this.tokens = t10;
    }
    peek(t10 = 0) {
      return this.tokens[this.pos + t10] ?? { type: "EOF", pos: -1 };
    }
    advance() {
      return this.tokens[this.pos++];
    }
    check(t10) {
      return this.peek().type === t10;
    }
    match(...t10) {
      for (let n10 of t10)
        if (this.check(n10))
          return this.advance();
      return null;
    }
    expect(t10, n10) {
      if (!this.check(t10))
        throw new Error(`${n10} at position ${this.peek().pos}, got ${this.peek().type}`);
      return this.advance();
    }
    isFieldNameAfterDot(t10 = 0) {
      let n10 = this.peek(t10), r10 = this.peek(t10 + 1);
      return r10.type === "STRING" ? true : r10.type === "IDENT" || Ai.has(r10.type) ? r10.pos === n10.pos + 1 : false;
    }
    isIdentLike() {
      let t10 = this.peek().type;
      return t10 === "IDENT" || Ai.has(t10);
    }
    consumeFieldNameAfterDot(t10) {
      let n10 = this.peek();
      return n10.type === "STRING" ? this.advance().value : (n10.type === "IDENT" || Ai.has(n10.type)) && n10.pos === t10.pos + 1 ? this.advance().value : null;
    }
    parse() {
      let t10 = this.parseExpr();
      if (!this.check("EOF"))
        throw new Error(`Unexpected token ${this.peek().type} at position ${this.peek().pos}`);
      return t10;
    }
    parseExpr() {
      return this.parsePipe();
    }
    parsePattern() {
      if (this.match("LBRACKET")) {
        let r10 = [];
        if (!this.check("RBRACKET"))
          for (r10.push(this.parsePattern()); this.match("COMMA") && !this.check("RBRACKET"); )
            r10.push(this.parsePattern());
        return this.expect("RBRACKET", "Expected ']' after array pattern"), { type: "array", elements: r10 };
      }
      if (this.match("LBRACE")) {
        let r10 = [];
        if (!this.check("RBRACE"))
          for (r10.push(this.parsePatternField()); this.match("COMMA") && !this.check("RBRACE"); )
            r10.push(this.parsePatternField());
        return this.expect("RBRACE", "Expected '}' after object pattern"), { type: "object", fields: r10 };
      }
      let t10 = this.expect("IDENT", "Expected variable name in pattern"), n10 = t10.value;
      if (!n10.startsWith("$"))
        throw new Error(`Variable name must start with $ at position ${t10.pos}`);
      return { type: "var", name: n10 };
    }
    parsePatternField() {
      if (this.match("LPAREN")) {
        let n10 = this.parseExpr();
        this.expect("RPAREN", "Expected ')' after computed key"), this.expect("COLON", "Expected ':' after computed key");
        let r10 = this.parsePattern();
        return { key: n10, pattern: r10 };
      }
      let t10 = this.peek();
      if (t10.type === "IDENT" || Ai.has(t10.type)) {
        let n10 = t10.value;
        if (n10.startsWith("$")) {
          if (this.advance(), this.match("COLON")) {
            let r10 = this.parsePattern();
            return { key: n10.slice(1), pattern: r10, keyVar: n10 };
          }
          return { key: n10.slice(1), pattern: { type: "var", name: n10 } };
        }
        if (this.advance(), this.match("COLON")) {
          let r10 = this.parsePattern();
          return { key: n10, pattern: r10 };
        }
        return { key: n10, pattern: { type: "var", name: `$${n10}` } };
      }
      throw new Error(`Expected field name in object pattern at position ${t10.pos}`);
    }
    parsePipe() {
      let t10 = this.parseComma();
      for (; this.match("PIPE"); ) {
        let n10 = this.parseComma();
        t10 = { type: "Pipe", left: t10, right: n10 };
      }
      return t10;
    }
    parseComma() {
      let t10 = this.parseVarBind();
      for (; this.match("COMMA"); ) {
        let n10 = this.parseVarBind();
        t10 = { type: "Comma", left: t10, right: n10 };
      }
      return t10;
    }
    parseVarBind() {
      let t10 = this.parseUpdate();
      if (this.match("AS")) {
        let n10 = this.parsePattern(), r10 = [];
        for (; this.check("QUESTION") && this.peekAhead(1)?.type === "ALT"; )
          this.advance(), this.advance(), r10.push(this.parsePattern());
        this.expect("PIPE", "Expected '|' after variable binding");
        let s10 = this.parseExpr();
        return n10.type === "var" && r10.length === 0 ? { type: "VarBind", name: n10.name, value: t10, body: s10 } : { type: "VarBind", name: n10.type === "var" ? n10.name : "", value: t10, body: s10, pattern: n10.type !== "var" ? n10 : void 0, alternatives: r10.length > 0 ? r10 : void 0 };
      }
      return t10;
    }
    peekAhead(t10) {
      let n10 = this.pos + t10;
      return n10 < this.tokens.length ? this.tokens[n10] : void 0;
    }
    parseUpdate() {
      let t10 = this.parseAlt(), n10 = /* @__PURE__ */ new Map([["ASSIGN", "="], ["UPDATE_ADD", "+="], ["UPDATE_SUB", "-="], ["UPDATE_MUL", "*="], ["UPDATE_DIV", "/="], ["UPDATE_MOD", "%="], ["UPDATE_ALT", "//="], ["UPDATE_PIPE", "|="]]), r10 = this.match("ASSIGN", "UPDATE_ADD", "UPDATE_SUB", "UPDATE_MUL", "UPDATE_DIV", "UPDATE_MOD", "UPDATE_ALT", "UPDATE_PIPE");
      if (r10) {
        let s10 = this.parseVarBind(), i10 = n10.get(r10.type);
        if (i10)
          return { type: "UpdateOp", op: i10, path: t10, value: s10 };
      }
      return t10;
    }
    parseAlt() {
      let t10 = this.parseOr();
      for (; this.match("ALT"); ) {
        let n10 = this.parseOr();
        t10 = { type: "BinaryOp", op: "//", left: t10, right: n10 };
      }
      return t10;
    }
    parseOr() {
      let t10 = this.parseAnd();
      for (; this.match("OR"); ) {
        let n10 = this.parseAnd();
        t10 = { type: "BinaryOp", op: "or", left: t10, right: n10 };
      }
      return t10;
    }
    parseAnd() {
      let t10 = this.parseNot();
      for (; this.match("AND"); ) {
        let n10 = this.parseNot();
        t10 = { type: "BinaryOp", op: "and", left: t10, right: n10 };
      }
      return t10;
    }
    parseNot() {
      return this.parseComparison();
    }
    parseComparison() {
      let t10 = this.parseAddSub(), n10 = /* @__PURE__ */ new Map([["EQ", "=="], ["NE", "!="], ["LT", "<"], ["LE", "<="], ["GT", ">"], ["GE", ">="]]), r10 = this.match("EQ", "NE", "LT", "LE", "GT", "GE");
      if (r10) {
        let s10 = n10.get(r10.type);
        if (s10) {
          let i10 = this.parseAddSub();
          t10 = { type: "BinaryOp", op: s10, left: t10, right: i10 };
        }
      }
      return t10;
    }
    parseAddSub() {
      let t10 = this.parseMulDiv();
      for (; ; )
        if (this.match("PLUS")) {
          let n10 = this.parseMulDiv();
          t10 = { type: "BinaryOp", op: "+", left: t10, right: n10 };
        } else if (this.match("MINUS")) {
          let n10 = this.parseMulDiv();
          t10 = { type: "BinaryOp", op: "-", left: t10, right: n10 };
        } else
          break;
      return t10;
    }
    parseMulDiv() {
      let t10 = this.parseUnary();
      for (; ; )
        if (this.match("STAR")) {
          let n10 = this.parseUnary();
          t10 = { type: "BinaryOp", op: "*", left: t10, right: n10 };
        } else if (this.match("SLASH")) {
          let n10 = this.parseUnary();
          t10 = { type: "BinaryOp", op: "/", left: t10, right: n10 };
        } else if (this.match("PERCENT")) {
          let n10 = this.parseUnary();
          t10 = { type: "BinaryOp", op: "%", left: t10, right: n10 };
        } else
          break;
      return t10;
    }
    parseUnary() {
      return this.match("MINUS") ? { type: "UnaryOp", op: "-", operand: this.parseUnary() } : this.parsePostfix();
    }
    parsePostfix() {
      let t10 = this.parsePrimary();
      for (; ; )
        if (this.match("QUESTION"))
          t10 = { type: "Optional", expr: t10 };
        else if (this.check("DOT") && this.isFieldNameAfterDot())
          this.advance(), t10 = { type: "Field", name: this.advance().value, base: t10 };
        else if (this.check("LBRACKET"))
          if (this.advance(), this.match("RBRACKET"))
            t10 = { type: "Iterate", base: t10 };
          else if (this.check("COLON")) {
            this.advance();
            let n10 = this.check("RBRACKET") ? void 0 : this.parseExpr();
            this.expect("RBRACKET", "Expected ']'"), t10 = { type: "Slice", end: n10, base: t10 };
          } else {
            let n10 = this.parseExpr();
            if (this.match("COLON")) {
              let r10 = this.check("RBRACKET") ? void 0 : this.parseExpr();
              this.expect("RBRACKET", "Expected ']'"), t10 = { type: "Slice", start: n10, end: r10, base: t10 };
            } else
              this.expect("RBRACKET", "Expected ']'"), t10 = { type: "Index", index: n10, base: t10 };
          }
        else
          break;
      return t10;
    }
    parsePrimary() {
      if (this.match("DOTDOT"))
        return { type: "Recurse" };
      if (this.check("DOT")) {
        let t10 = this.advance();
        if (this.check("LBRACKET")) {
          if (this.advance(), this.match("RBRACKET"))
            return { type: "Iterate" };
          if (this.check("COLON")) {
            this.advance();
            let s10 = this.check("RBRACKET") ? void 0 : this.parseExpr();
            return this.expect("RBRACKET", "Expected ']'"), { type: "Slice", end: s10 };
          }
          let r10 = this.parseExpr();
          if (this.match("COLON")) {
            let s10 = this.check("RBRACKET") ? void 0 : this.parseExpr();
            return this.expect("RBRACKET", "Expected ']'"), { type: "Slice", start: r10, end: s10 };
          }
          return this.expect("RBRACKET", "Expected ']'"), { type: "Index", index: r10 };
        }
        let n10 = this.consumeFieldNameAfterDot(t10);
        return n10 !== null ? { type: "Field", name: n10 } : { type: "Identity" };
      }
      if (this.match("TRUE"))
        return { type: "Literal", value: true };
      if (this.match("FALSE"))
        return { type: "Literal", value: false };
      if (this.match("NULL"))
        return { type: "Literal", value: null };
      if (this.check("NUMBER"))
        return { type: "Literal", value: this.advance().value };
      if (this.check("STRING")) {
        let n10 = this.advance().value;
        return n10.includes("\\(") ? this.parseStringInterpolation(n10) : { type: "Literal", value: n10 };
      }
      if (this.match("LBRACKET")) {
        if (this.match("RBRACKET"))
          return { type: "Array" };
        let t10 = this.parseExpr();
        return this.expect("RBRACKET", "Expected ']'"), { type: "Array", elements: t10 };
      }
      if (this.match("LBRACE"))
        return this.parseObjectConstruction();
      if (this.match("LPAREN")) {
        let t10 = this.parseExpr();
        return this.expect("RPAREN", "Expected ')'"), { type: "Paren", expr: t10 };
      }
      if (this.match("IF"))
        return this.parseIf();
      if (this.match("TRY")) {
        let t10 = this.parsePostfix(), n10;
        return this.match("CATCH") && (n10 = this.parsePostfix()), { type: "Try", body: t10, catch: n10 };
      }
      if (this.match("REDUCE")) {
        let t10 = this.parseAddSub();
        this.expect("AS", "Expected 'as' after reduce expression");
        let n10 = this.parsePattern();
        this.expect("LPAREN", "Expected '(' after variable");
        let r10 = this.parseExpr();
        this.expect("SEMICOLON", "Expected ';' after init expression");
        let s10 = this.parseExpr();
        this.expect("RPAREN", "Expected ')' after update expression");
        let i10 = n10.type === "var" ? n10.name : "";
        return { type: "Reduce", expr: t10, varName: i10, init: r10, update: s10, pattern: n10.type !== "var" ? n10 : void 0 };
      }
      if (this.match("FOREACH")) {
        let t10 = this.parseAddSub();
        this.expect("AS", "Expected 'as' after foreach expression");
        let n10 = this.parsePattern();
        this.expect("LPAREN", "Expected '(' after variable");
        let r10 = this.parseExpr();
        this.expect("SEMICOLON", "Expected ';' after init expression");
        let s10 = this.parseExpr(), i10;
        this.match("SEMICOLON") && (i10 = this.parseExpr()), this.expect("RPAREN", "Expected ')' after expressions");
        let o10 = n10.type === "var" ? n10.name : "";
        return { type: "Foreach", expr: t10, varName: o10, init: r10, update: s10, extract: i10, pattern: n10.type !== "var" ? n10 : void 0 };
      }
      if (this.match("LABEL")) {
        let t10 = this.expect("IDENT", "Expected label name (e.g., $out)"), n10 = t10.value;
        if (!n10.startsWith("$"))
          throw new Error(`Label name must start with $ at position ${t10.pos}`);
        this.expect("PIPE", "Expected '|' after label name");
        let r10 = this.parseExpr();
        return { type: "Label", name: n10, body: r10 };
      }
      if (this.match("BREAK")) {
        let t10 = this.expect("IDENT", "Expected label name to break to"), n10 = t10.value;
        if (!n10.startsWith("$"))
          throw new Error(`Break label must start with $ at position ${t10.pos}`);
        return { type: "Break", name: n10 };
      }
      if (this.match("DEF")) {
        let n10 = this.expect("IDENT", "Expected function name after def").value, r10 = [];
        if (this.match("LPAREN")) {
          if (!this.check("RPAREN")) {
            let o10 = this.expect("IDENT", "Expected parameter name");
            for (r10.push(o10.value); this.match("SEMICOLON"); ) {
              let a = this.expect("IDENT", "Expected parameter name");
              r10.push(a.value);
            }
          }
          this.expect("RPAREN", "Expected ')' after parameters");
        }
        this.expect("COLON", "Expected ':' after function name");
        let s10 = this.parseExpr();
        this.expect("SEMICOLON", "Expected ';' after function body");
        let i10 = this.parseExpr();
        return { type: "Def", name: n10, params: r10, funcBody: s10, body: i10 };
      }
      if (this.match("NOT"))
        return { type: "Call", name: "not", args: [] };
      if (this.check("IDENT")) {
        let n10 = this.advance().value;
        if (n10.startsWith("$"))
          return { type: "VarRef", name: n10 };
        if (this.match("LPAREN")) {
          let r10 = [];
          if (!this.check("RPAREN"))
            for (r10.push(this.parseExpr()); this.match("SEMICOLON"); )
              r10.push(this.parseExpr());
          return this.expect("RPAREN", "Expected ')'"), { type: "Call", name: n10, args: r10 };
        }
        return { type: "Call", name: n10, args: [] };
      }
      throw new Error(`Unexpected token ${this.peek().type} at position ${this.peek().pos}`);
    }
    parseObjectConstruction() {
      let t10 = [];
      if (!this.check("RBRACE"))
        do {
          let n10, r10;
          if (this.match("LPAREN"))
            n10 = this.parseExpr(), this.expect("RPAREN", "Expected ')'"), this.expect("COLON", "Expected ':'"), r10 = this.parseObjectValue();
          else if (this.isIdentLike()) {
            let s10 = this.advance().value;
            this.match("COLON") ? (n10 = s10, r10 = this.parseObjectValue()) : (n10 = s10, r10 = { type: "Field", name: s10 });
          } else if (this.check("STRING"))
            n10 = this.advance().value, this.expect("COLON", "Expected ':'"), r10 = this.parseObjectValue();
          else
            throw new Error(`Expected object key at position ${this.peek().pos}`);
          t10.push({ key: n10, value: r10 });
        } while (this.match("COMMA"));
      return this.expect("RBRACE", "Expected '}'"), { type: "Object", entries: t10 };
    }
    parseObjectValue() {
      let t10 = this.parseVarBind();
      for (; this.match("PIPE"); ) {
        let n10 = this.parseVarBind();
        t10 = { type: "Pipe", left: t10, right: n10 };
      }
      return t10;
    }
    parseIf() {
      let t10 = this.parseExpr();
      this.expect("THEN", "Expected 'then'");
      let n10 = this.parseExpr(), r10 = [];
      for (; this.match("ELIF"); ) {
        let i10 = this.parseExpr();
        this.expect("THEN", "Expected 'then' after elif");
        let o10 = this.parseExpr();
        r10.push({ cond: i10, then: o10 });
      }
      let s10;
      return this.match("ELSE") && (s10 = this.parseExpr()), this.expect("END", "Expected 'end'"), { type: "Cond", cond: t10, then: n10, elifs: r10, else: s10 };
    }
    parseStringInterpolation(t10) {
      let n10 = [], r10 = "", s10 = 0;
      for (; s10 < t10.length; )
        if (t10[s10] === "\\" && t10[s10 + 1] === "(") {
          r10 && (n10.push(r10), r10 = ""), s10 += 2;
          let i10 = 1, o10 = "";
          for (; s10 < t10.length && i10 > 0; )
            t10[s10] === "(" ? i10++ : t10[s10] === ")" && i10--, i10 > 0 && (o10 += t10[s10]), s10++;
          let a = Th(o10), l = new e11(a);
          n10.push(l.parse());
        } else
          r10 += t10[s10], s10++;
      return r10 && n10.push(r10), { type: "StringInterp", parts: n10 };
    }
  };
});
var _h = I(() => {
  "use strict";
  Rh();
  Dh();
});
var Fh = {};
Q(Fh, { flagsForFuzzing: () => K9, jqCommand: () => Q9 });
function Lh(e11) {
  let t10 = [], n10 = 0, r10 = e11.length;
  for (; n10 < r10; ) {
    for (; n10 < r10 && /\s/.test(e11[n10]); )
      n10++;
    if (n10 >= r10)
      break;
    let s10 = n10, i10 = e11[n10];
    if (i10 === "{" || i10 === "[") {
      let o10 = i10, a = i10 === "{" ? "}" : "]", l = 1, c = false, u = false;
      for (n10++; n10 < r10 && l > 0; ) {
        let f10 = e11[n10];
        u ? u = false : f10 === "\\" ? u = true : f10 === '"' ? c = !c : c || (f10 === o10 ? l++ : f10 === a && l--), n10++;
      }
      if (l !== 0)
        throw new Error(`Unexpected end of JSON input at position ${n10} (unclosed ${o10})`);
      t10.push(JSON.parse(e11.slice(s10, n10)));
    } else if (i10 === '"') {
      let o10 = false;
      for (n10++; n10 < r10; ) {
        let a = e11[n10];
        if (o10)
          o10 = false;
        else if (a === "\\")
          o10 = true;
        else if (a === '"') {
          n10++;
          break;
        }
        n10++;
      }
      t10.push(JSON.parse(e11.slice(s10, n10)));
    } else if (i10 === "-" || i10 >= "0" && i10 <= "9") {
      for (; n10 < r10 && /[\d.eE+-]/.test(e11[n10]); )
        n10++;
      t10.push(JSON.parse(e11.slice(s10, n10)));
    } else if (e11.slice(n10, n10 + 4) === "true")
      t10.push(true), n10 += 4;
    else if (e11.slice(n10, n10 + 5) === "false")
      t10.push(false), n10 += 5;
    else if (e11.slice(n10, n10 + 4) === "null")
      t10.push(null), n10 += 4;
    else {
      let o10 = e11.slice(n10, n10 + 10);
      throw new Error(`Invalid JSON at position ${s10}: unexpected '${o10.split(/\s/)[0]}'`);
    }
  }
  return t10;
}
function us(e11, t10, n10, r10, s10, i10 = 0) {
  if (e11 === null || e11 === void 0)
    return "null";
  if (typeof e11 == "boolean")
    return String(e11);
  if (typeof e11 == "number")
    return Number.isFinite(e11) ? String(e11) : "null";
  if (typeof e11 == "string")
    return n10 ? e11 : JSON.stringify(e11);
  let o10 = s10 ? "	" : "  ";
  if (Array.isArray(e11))
    return e11.length === 0 ? "[]" : t10 ? `[${e11.map((l) => us(l, true, false, r10, s10)).join(",")}]` : `[
${e11.map((l) => o10.repeat(i10 + 1) + us(l, false, false, r10, s10, i10 + 1)).join(`,
`)}
${o10.repeat(i10)}]`;
  if (typeof e11 == "object") {
    let a = Object.keys(e11);
    return r10 && (a = a.sort()), a.length === 0 ? "{}" : t10 ? `{${a.map((c) => `${JSON.stringify(c)}:${us(e11[c], true, false, r10, s10)}`).join(",")}}` : `{
${a.map((c) => {
      let u = us(e11[c], false, false, r10, s10, i10 + 1);
      return `${o10.repeat(i10 + 1)}${JSON.stringify(c)}: ${u}`;
    }).join(`,
`)}
${o10.repeat(i10)}}`;
  }
  return String(e11);
}
var Z9;
var Q9;
var K9;
var Mh = I(() => {
  "use strict";
  ye();
  Hn();
  se();
  _h();
  Z9 = { name: "jq", summary: "command-line JSON processor", usage: "jq [OPTIONS] FILTER [FILE]", options: ["-r, --raw-output  output strings without quotes", "-c, --compact     compact output (no pretty printing)", "-e, --exit-status set exit status based on output", "-s, --slurp       read entire input into array", "-n, --null-input  don't read any input", "-j, --join-output don't print newlines after each output", "-a, --ascii       force ASCII output", "-S, --sort-keys   sort object keys", "-C, --color       colorize output (ignored)", "-M, --monochrome  monochrome output (ignored)", "    --tab         use tabs for indentation", "    --help        display this help and exit"] };
  Q9 = { name: "jq", async execute(e11, t10) {
    if (U2(e11))
      return M(Z9);
    let n10 = false, r10 = false, s10 = false, i10 = false, o10 = false, a = false, l = false, c = false, u = ".", f10 = false, p = [];
    for (let m = 0; m < e11.length; m++) {
      let d = e11[m];
      if (d === "-r" || d === "--raw-output")
        n10 = true;
      else if (d === "-c" || d === "--compact-output")
        r10 = true;
      else if (d === "-e" || d === "--exit-status")
        s10 = true;
      else if (d === "-s" || d === "--slurp")
        i10 = true;
      else if (d === "-n" || d === "--null-input")
        o10 = true;
      else if (d === "-j" || d === "--join-output")
        a = true;
      else if (!(d === "-a" || d === "--ascii")) {
        if (d === "-S" || d === "--sort-keys")
          l = true;
        else if (!(d === "-C" || d === "--color")) {
          if (!(d === "-M" || d === "--monochrome"))
            if (d === "--tab")
              c = true;
            else if (d === "-")
              p.push("-");
            else {
              if (d.startsWith("--"))
                return Y("jq", d);
              if (d.startsWith("-")) {
                for (let g of d.slice(1))
                  if (g === "r")
                    n10 = true;
                  else if (g === "c")
                    r10 = true;
                  else if (g === "e")
                    s10 = true;
                  else if (g === "s")
                    i10 = true;
                  else if (g === "n")
                    o10 = true;
                  else if (g === "j")
                    a = true;
                  else if (g !== "a") {
                    if (g === "S")
                      l = true;
                    else if (g !== "C") {
                      if (g !== "M")
                        return Y("jq", `-${g}`);
                    }
                  }
              } else
                f10 ? p.push(d) : (u = d, f10 = true);
            }
        }
      }
    }
    let h = [];
    if (!o10)
      if (p.length === 0 || p.length === 1 && p[0] === "-")
        h.push({ source: "stdin", content: t10.stdin });
      else {
        let m = await zn(t10, p, { cmdName: "jq", stopOnError: true });
        if (m.exitCode !== 0)
          return { stdout: "", stderr: m.stderr, exitCode: 2 };
        h = m.files.map((d) => ({ source: d.filename || "stdin", content: d.content }));
      }
    try {
      let m = Ph(u), d = [], g = { limits: t10.limits ? { maxIterations: t10.limits.maxJqIterations } : void 0, env: t10.env, coverage: t10.coverage };
      if (o10)
        d = G(null, m, g);
      else if (i10) {
        let O = [];
        for (let { content: R10 } of h) {
          let F4 = R10.trim();
          F4 && O.push(...Lh(F4));
        }
        d = G(O, m, g);
      } else
        for (let { content: O } of h) {
          let R10 = O.trim();
          if (!R10)
            continue;
          let F4 = Lh(R10);
          for (let $ of F4)
            d.push(...G($, m, g));
        }
      let y = d.map((O) => us(O, r10, n10, l, c)), w = a ? "" : `
`, b = y.join(w), x = t10.limits?.maxStringLength;
      if (x !== void 0 && x > 0 && b.length > x)
        throw new te(`jq: output size limit exceeded (${x} bytes)`, "string_length");
      let S = s10 && (d.length === 0 || d.every((O) => O == null || O === false)) ? 1 : 0;
      return { stdout: b ? a ? b : `${b}
` : "", stderr: "", exitCode: S };
    } catch (m) {
      if (m instanceof te)
        return { stdout: "", stderr: `jq: ${m.message}
`, exitCode: te.EXIT_CODE };
      let d = m.message;
      return d.includes("Unknown function") ? { stdout: "", stderr: `jq: error: ${d}
`, exitCode: 3 } : { stdout: "", stderr: `jq: parse error: ${d}
`, exitCode: 5 };
    }
  } }, K9 = { name: "jq", flags: [{ flag: "-r", type: "boolean" }, { flag: "-c", type: "boolean" }, { flag: "-e", type: "boolean" }, { flag: "-s", type: "boolean" }, { flag: "-n", type: "boolean" }, { flag: "-j", type: "boolean" }, { flag: "-S", type: "boolean" }, { flag: "--tab", type: "boolean" }], stdinType: "json", needsArgs: true };
});
var Wh = {};
Q(Wh, { base64Command: () => J9, flagsForFuzzing: () => e5 });
async function Uh(e11, t10, n10) {
  if (t10.length === 0 || t10.length === 1 && t10[0] === "-")
    return { ok: true, data: Uint8Array.from(e11.stdin, (a) => a.charCodeAt(0)) };
  let r10 = [];
  for (let a of t10) {
    if (a === "-") {
      r10.push(Uint8Array.from(e11.stdin, (l) => l.charCodeAt(0)));
      continue;
    }
    try {
      let l = e11.fs.resolvePath(e11.cwd, a), c = await e11.fs.readFileBuffer(l);
      r10.push(c);
    } catch {
      return { ok: false, error: { stdout: "", stderr: `${n10}: ${a}: No such file or directory
`, exitCode: 1 } };
    }
  }
  let s10 = r10.reduce((a, l) => a + l.length, 0), i10 = new Uint8Array(s10), o10 = 0;
  for (let a of r10)
    i10.set(a, o10), o10 += a.length;
  return { ok: true, data: i10 };
}
var X9;
var Y9;
var J9;
var e5;
var Bh = I(() => {
  "use strict";
  qe();
  se();
  X9 = { name: "base64", summary: "base64 encode/decode data and print to standard output", usage: "base64 [OPTION]... [FILE]", options: ["-d, --decode    decode data", "-w, --wrap=COLS wrap encoded lines after COLS character (default 76, 0 to disable)", "    --help      display this help and exit"] }, Y9 = { decode: { short: "d", long: "decode", type: "boolean" }, wrap: { short: "w", long: "wrap", type: "number", default: 76 } };
  J9 = { name: "base64", async execute(e11, t10) {
    if (U2(e11))
      return M(X9);
    let n10 = be("base64", e11, Y9);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.decode, s10 = n10.result.flags.wrap, i10 = n10.result.positional;
    try {
      if (r10) {
        let l = await Uh(t10, i10, "base64");
        if (!l.ok)
          return l.error;
        if (typeof Buffer < "u") {
          let h = Buffer.from(l.data).toString("utf8").replace(/\s/g, "");
          return { stdout: Buffer.from(h, "base64").toString("latin1"), stderr: "", exitCode: 0 };
        }
        let u = String.fromCharCode(...l.data).replace(/\s/g, "");
        return { stdout: atob(u), stderr: "", exitCode: 0 };
      }
      let o10 = await Uh(t10, i10, "base64");
      if (!o10.ok)
        return o10.error;
      let a;
      if (typeof Buffer < "u" ? a = Buffer.from(o10.data).toString("base64") : a = btoa(String.fromCharCode(...o10.data)), s10 > 0) {
        let l = [];
        for (let c = 0; c < a.length; c += s10)
          l.push(a.slice(c, c + s10));
        a = l.join(`
`) + (a.length > 0 ? `
` : "");
      }
      return { stdout: a, stderr: "", exitCode: 0 };
    } catch {
      return { stdout: "", stderr: `base64: invalid input
`, exitCode: 1 };
    }
  } }, e5 = { name: "base64", flags: [{ flag: "-d", type: "boolean" }, { flag: "-w", type: "value", valueHint: "number" }], stdinType: "text", needsFiles: true };
});
var Hh = {};
Q(Hh, { diffCommand: () => r5, flagsForFuzzing: () => s5 });
var t5;
var n5;
var r5;
var s5;
var jh = I(() => {
  "use strict";
  qe();
  se();
  t5 = { name: "diff", summary: "compare files line by line", usage: "diff [OPTION]... FILE1 FILE2", options: ["-u, --unified     output unified diff format (default)", "-q, --brief       report only whether files differ", "-s, --report-identical-files  report when files are the same", "-i, --ignore-case  ignore case differences", "    --help        display this help and exit"] }, n5 = { unified: { short: "u", long: "unified", type: "boolean" }, brief: { short: "q", long: "brief", type: "boolean" }, reportSame: { short: "s", long: "report-identical-files", type: "boolean" }, ignoreCase: { short: "i", long: "ignore-case", type: "boolean" } }, r5 = { name: "diff", async execute(e11, t10) {
    if (U2(e11))
      return M(t5);
    let n10 = be("diff", e11, n5);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.brief, s10 = n10.result.flags.reportSame, i10 = n10.result.flags.ignoreCase, o10 = n10.result.positional;
    if (n10.result.flags.unified, o10.length < 2)
      return { stdout: "", stderr: `diff: missing operand
`, exitCode: 2 };
    let a, l, [c, u] = o10;
    try {
      a = c === "-" ? t10.stdin : await t10.fs.readFile(t10.fs.resolvePath(t10.cwd, c));
    } catch {
      return { stdout: "", stderr: `diff: ${c}: No such file or directory
`, exitCode: 2 };
    }
    try {
      l = u === "-" ? t10.stdin : await t10.fs.readFile(t10.fs.resolvePath(t10.cwd, u));
    } catch {
      return { stdout: "", stderr: `diff: ${u}: No such file or directory
`, exitCode: 2 };
    }
    let f10 = a, p = l;
    return i10 && (f10 = f10.toLowerCase(), p = p.toLowerCase()), f10 === p ? s10 ? { stdout: `Files ${c} and ${u} are identical
`, stderr: "", exitCode: 0 } : { stdout: "", stderr: "", exitCode: 0 } : r10 ? { stdout: `Files ${c} and ${u} differ
`, stderr: "", exitCode: 1 } : { stdout: createTwoFilesPatch(c, u, a, l, "", "", { context: 3 }), stderr: "", exitCode: 1 };
  } }, s5 = { name: "diff", flags: [{ flag: "-u", type: "boolean" }, { flag: "-q", type: "boolean" }, { flag: "-s", type: "boolean" }, { flag: "-i", type: "boolean" }], needsArgs: true, minArgs: 2 };
});
var Gh = {};
Q(Gh, { dateCommand: () => u5, flagsForFuzzing: () => f5 });
function ht(e11, t10 = 2) {
  return String(e11).padStart(t10, "0");
}
function l5(e11) {
  let t10 = -e11.getTimezoneOffset();
  return `${t10 >= 0 ? "+" : "-"}${ht(Math.floor(Math.abs(t10) / 60))}${ht(Math.abs(t10) % 60)}`;
}
function Si(e11, t10, n10) {
  let r10 = n10 ? { Y: e11.getUTCFullYear(), m: e11.getUTCMonth(), D: e11.getUTCDate(), H: e11.getUTCHours(), M: e11.getUTCMinutes(), S: e11.getUTCSeconds(), w: e11.getUTCDay() } : { Y: e11.getFullYear(), m: e11.getMonth(), D: e11.getDate(), H: e11.getHours(), M: e11.getMinutes(), S: e11.getSeconds(), w: e11.getDay() }, s10 = "", i10 = 0;
  for (; i10 < t10.length; ) {
    if (t10[i10] === "%" && i10 + 1 < t10.length) {
      let o10 = t10[++i10];
      switch (o10) {
        case "%":
          s10 += "%";
          break;
        case "a":
          s10 += o5[r10.w];
          break;
        case "b":
        case "h":
          s10 += a5[r10.m];
          break;
        case "d":
          s10 += ht(r10.D);
          break;
        case "e":
          s10 += String(r10.D).padStart(2, " ");
          break;
        case "F":
          s10 += `${r10.Y}-${ht(r10.m + 1)}-${ht(r10.D)}`;
          break;
        case "H":
          s10 += ht(r10.H);
          break;
        case "I":
          s10 += ht(r10.H % 12 || 12);
          break;
        case "m":
          s10 += ht(r10.m + 1);
          break;
        case "M":
          s10 += ht(r10.M);
          break;
        case "n":
          s10 += `
`;
          break;
        case "p":
          s10 += r10.H < 12 ? "AM" : "PM";
          break;
        case "P":
          s10 += r10.H < 12 ? "am" : "pm";
          break;
        case "R":
          s10 += `${ht(r10.H)}:${ht(r10.M)}`;
          break;
        case "s":
          s10 += Math.floor(e11.getTime() / 1e3);
          break;
        case "S":
          s10 += ht(r10.S);
          break;
        case "t":
          s10 += "	";
          break;
        case "T":
          s10 += `${ht(r10.H)}:${ht(r10.M)}:${ht(r10.S)}`;
          break;
        case "u":
          s10 += r10.w || 7;
          break;
        case "w":
          s10 += r10.w;
          break;
        case "y":
          s10 += ht(r10.Y % 100);
          break;
        case "Y":
          s10 += r10.Y;
          break;
        case "z":
          s10 += n10 ? "+0000" : l5(e11);
          break;
        case "Z":
          s10 += n10 ? "UTC" : Intl.DateTimeFormat().resolvedOptions().timeZone;
          break;
        default:
          s10 += `%${o10}`;
      }
    } else
      s10 += t10[i10];
    i10++;
  }
  return s10;
}
function c5(e11) {
  let t10 = new Date(e11);
  if (!Number.isNaN(t10.getTime()))
    return t10;
  if (/^\d+$/.test(e11))
    return new Date(Number.parseInt(e11, 10) * 1e3);
  let n10 = e11.toLowerCase();
  return n10 === "now" || n10 === "today" ? /* @__PURE__ */ new Date() : n10 === "yesterday" ? new Date(Date.now() - 864e5) : n10 === "tomorrow" ? new Date(Date.now() + 864e5) : null;
}
var i5;
var o5;
var a5;
var u5;
var f5;
var Vh = I(() => {
  "use strict";
  se();
  i5 = { name: "date", summary: "display the current time in the given FORMAT", usage: "date [OPTION]... [+FORMAT]", options: ["-d, --date=STRING   display time described by STRING", "-u, --utc           print Coordinated Universal Time (UTC)", "-I, --iso-8601      output date/time in ISO 8601 format", "-R, --rfc-email     output RFC 5322 date format", "    --help          display this help and exit"] }, o5 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], a5 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  u5 = { name: "date", async execute(e11, t10) {
    if (U2(e11))
      return M(i5);
    let n10 = false, r10 = null, s10 = null, i10 = false, o10 = false;
    for (let c = 0; c < e11.length; c++) {
      let u = e11[c];
      if (u === "-u" || u === "--utc")
        n10 = true;
      else if (u === "-d" || u === "--date")
        r10 = e11[++c] ?? "";
      else if (u.startsWith("--date="))
        r10 = u.slice(7);
      else if (u === "-I" || u === "--iso-8601")
        i10 = true;
      else if (u === "-R" || u === "--rfc-email")
        o10 = true;
      else if (u.startsWith("+"))
        s10 = u.slice(1);
      else {
        if (u.startsWith("--"))
          return Y("date", u);
        if (u.startsWith("-"))
          for (let f10 of u.slice(1))
            if (f10 === "u")
              n10 = true;
            else if (f10 === "I")
              i10 = true;
            else if (f10 === "R")
              o10 = true;
            else
              return Y("date", `-${f10}`);
      }
    }
    let a = r10 !== null ? c5(r10) : /* @__PURE__ */ new Date();
    if (!a)
      return { stdout: "", stderr: `date: invalid date '${r10}'
`, exitCode: 1 };
    let l;
    return s10 ? l = Si(a, s10, n10) : i10 ? l = Si(a, "%Y-%m-%dT%H:%M:%S%z", n10) : o10 ? l = Si(a, "%a, %d %b %Y %H:%M:%S %z", n10) : l = Si(a, "%a %b %e %H:%M:%S %Z %Y", n10), { stdout: `${l}
`, stderr: "", exitCode: 0 };
  } }, f5 = { name: "date", flags: [{ flag: "-d", type: "value", valueHint: "string" }, { flag: "-u", type: "boolean" }, { flag: "-I", type: "boolean" }, { flag: "-R", type: "boolean" }] };
});
var qh = {};
Q(qh, { flagsForFuzzing: () => m5, sleepCommand: () => d5 });
function h5(e11) {
  let t10 = e11.match(/^(\d+\.?\d*)(s|m|h|d)?$/);
  if (!t10)
    return null;
  let n10 = parseFloat(t10[1]);
  switch (t10[2] || "s") {
    case "s":
      return n10 * 1e3;
    case "m":
      return n10 * 60 * 1e3;
    case "h":
      return n10 * 60 * 60 * 1e3;
    case "d":
      return n10 * 24 * 60 * 60 * 1e3;
    default:
      return null;
  }
}
var p5;
var d5;
var m5;
var Zh = I(() => {
  "use strict";
  se();
  p5 = { name: "sleep", summary: "delay for a specified amount of time", usage: "sleep NUMBER[SUFFIX]", description: `Pause for NUMBER seconds. SUFFIX may be:
  s - seconds (default)
  m - minutes
  h - hours
  d - days

NUMBER may be a decimal number.`, options: ["    --help display this help and exit"] };
  d5 = { name: "sleep", async execute(e11, t10) {
    if (U2(e11))
      return M(p5);
    if (e11.length === 0)
      return { stdout: "", stderr: `sleep: missing operand
`, exitCode: 1 };
    let n10 = 0;
    for (let r10 of e11) {
      let s10 = h5(r10);
      if (s10 === null)
        return { stdout: "", stderr: `sleep: invalid time interval '${r10}'
`, exitCode: 1 };
      n10 += s10;
    }
    return t10.sleep ? await t10.sleep(n10) : await new Promise((r10) => setTimeout(r10, n10)), { stdout: "", stderr: "", exitCode: 0 };
  } }, m5 = { name: "sleep", flags: [], needsArgs: true };
});
var Qh = {};
Q(Qh, { flagsForFuzzing: () => b5, timeoutCommand: () => w5 });
function y5(e11) {
  let t10 = e11.match(/^(\d+\.?\d*)(s|m|h|d)?$/);
  if (!t10)
    return null;
  let n10 = parseFloat(t10[1]);
  switch (t10[2] || "s") {
    case "s":
      return n10 * 1e3;
    case "m":
      return n10 * 60 * 1e3;
    case "h":
      return n10 * 60 * 60 * 1e3;
    case "d":
      return n10 * 24 * 60 * 60 * 1e3;
    default:
      return null;
  }
}
var g5;
var w5;
var b5;
var Kh = I(() => {
  "use strict";
  se();
  g5 = { name: "timeout", summary: "run a command with a time limit", usage: "timeout [OPTION] DURATION COMMAND [ARG]...", description: `Start COMMAND, and kill it if still running after DURATION.

DURATION is a number with optional suffix:
  s - seconds (default)
  m - minutes
  h - hours
  d - days`, options: ["-k, --kill-after=DURATION  send KILL signal after DURATION if still running", "-s, --signal=SIGNAL        specify signal to send (default: TERM)", "    --preserve-status      exit with same status as COMMAND, even on timeout", "    --foreground           run command in foreground", "    --help                 display this help and exit"] };
  w5 = { name: "timeout", async execute(e11, t10) {
    if (U2(e11))
      return M(g5);
    let n10 = false, r10 = 0;
    for (let p = 0; p < e11.length; p++) {
      let h = e11[p];
      if (h === "--preserve-status")
        n10 = true, r10 = p + 1;
      else if (h === "--foreground")
        r10 = p + 1;
      else if (h === "-k" || h === "--kill-after")
        p++, r10 = p + 1;
      else if (h.startsWith("--kill-after="))
        r10 = p + 1;
      else if (h === "-s" || h === "--signal")
        p++, r10 = p + 1;
      else if (h.startsWith("--signal="))
        r10 = p + 1;
      else {
        if (h.startsWith("--") && h !== "--")
          return Y("timeout", h);
        if (h.startsWith("-") && h.length > 1 && h !== "--")
          if (h.startsWith("-k"))
            r10 = p + 1;
          else if (h.startsWith("-s"))
            r10 = p + 1;
          else
            return Y("timeout", h);
        else {
          r10 = p;
          break;
        }
      }
    }
    let s10 = e11.slice(r10);
    if (s10.length === 0)
      return { stdout: "", stderr: `timeout: missing operand
`, exitCode: 1 };
    let i10 = s10[0], o10 = y5(i10);
    if (o10 === null)
      return { stdout: "", stderr: `timeout: invalid time interval '${i10}'
`, exitCode: 1 };
    let a = s10.slice(1);
    if (a.length === 0)
      return { stdout: "", stderr: `timeout: missing operand
`, exitCode: 1 };
    if (!t10.exec)
      return { stdout: "", stderr: `timeout: exec not available
`, exitCode: 1 };
    let l = a.map((p) => p.includes(" ") || p.includes("	") ? `'${p.replace(/'/g, "'\\''")}'` : p).join(" "), c = new Promise((p) => {
      setTimeout(() => p({ timedOut: true }), o10);
    }), u = t10.exec(l, { cwd: t10.cwd }).then((p) => ({ timedOut: false, result: p })), f10 = await Promise.race([c, u]);
    return f10.timedOut ? { stdout: "", stderr: "", exitCode: 124 } : f10.result;
  } }, b5 = { name: "timeout", flags: [{ flag: "-k", type: "value", valueHint: "string" }, { flag: "-s", type: "value", valueHint: "string" }, { flag: "--preserve-status", type: "boolean" }, { flag: "--foreground", type: "boolean" }], needsArgs: true, minArgs: 2 };
});
var Xh = {};
Q(Xh, { flagsForFuzzing: () => A5, timeCommand: () => x5 });
function E5(e11) {
  let t10 = Math.floor(e11 / 3600), n10 = Math.floor(e11 % 3600 / 60), r10 = e11 % 60;
  return t10 > 0 ? `${t10}:${n10.toString().padStart(2, "0")}:${r10.toFixed(2).padStart(5, "0")}` : `${n10}:${r10.toFixed(2).padStart(5, "0")}`;
}
var x5;
var A5;
var Yh = I(() => {
  "use strict";
  On();
  x5 = { name: "time", async execute(e11, t10) {
    let n10 = "%e %M", r10 = null, s10 = false, i10 = false, o10 = 0;
    for (; o10 < e11.length; ) {
      let m = e11[o10];
      if (m === "-f" || m === "--format") {
        if (o10++, o10 >= e11.length)
          return { stdout: "", stderr: `time: missing argument to '-f'
`, exitCode: 1 };
        n10 = e11[o10], o10++;
      } else if (m === "-o" || m === "--output") {
        if (o10++, o10 >= e11.length)
          return { stdout: "", stderr: `time: missing argument to '-o'
`, exitCode: 1 };
        r10 = e11[o10], o10++;
      } else if (m === "-a" || m === "--append")
        s10 = true, o10++;
      else if (m === "-v" || m === "--verbose")
        n10 = `Command being timed: %C
Elapsed (wall clock) time: %e seconds
Maximum resident set size (kbytes): %M`, o10++;
      else if (m === "-p" || m === "--portability")
        i10 = true, o10++;
      else if (m === "--") {
        o10++;
        break;
      } else if (m.startsWith("-"))
        o10++;
      else
        break;
    }
    let a = e11.slice(o10);
    if (a.length === 0)
      return { stdout: "", stderr: "", exitCode: 0 };
    let l = performance.now(), c = a.join(" "), u;
    try {
      if (!t10.exec)
        return { stdout: "", stderr: `time: exec not available
`, exitCode: 1 };
      u = await t10.exec(c, { env: xt(t10.env), cwd: t10.cwd });
    } catch (m) {
      u = { stdout: "", stderr: `time: ${m.message}
`, exitCode: 127 };
    }
    let p = (performance.now() - l) / 1e3, h;
    if (i10 ? h = `real ${p.toFixed(2)}
user 0.00
sys 0.00
` : (h = n10.replace(/%e/g, p.toFixed(2)).replace(/%E/g, E5(p)).replace(/%M/g, "0").replace(/%S/g, "0.00").replace(/%U/g, "0.00").replace(/%P/g, "0%").replace(/%C/g, c), h.endsWith(`
`) || (h += `
`)), r10)
      try {
        let m = t10.fs.resolvePath(t10.cwd, r10);
        if (s10 && await t10.fs.exists(m)) {
          let d = await t10.fs.readFile(m);
          await t10.fs.writeFile(m, d + h);
        } else
          await t10.fs.writeFile(m, h);
      } catch (m) {
        return { stdout: u.stdout, stderr: u.stderr + `time: cannot write to '${r10}': ${m.message}
`, exitCode: u.exitCode };
      }
    else
      u = { ...u, stderr: u.stderr + h };
    return u;
  } };
  A5 = { name: "time", flags: [{ flag: "-p", type: "boolean" }], needsArgs: true };
});
var Jh = {};
Q(Jh, { flagsForFuzzing: () => C5, seqCommand: () => S5 });
var S5;
var C5;
var ed = I(() => {
  "use strict";
  S5 = { name: "seq", async execute(e11) {
    let t10 = `
`, n10 = false, r10 = [], s10 = 0;
    for (; s10 < e11.length; ) {
      let m = e11[s10];
      if (m === "-s" && s10 + 1 < e11.length) {
        t10 = e11[s10 + 1], s10 += 2;
        continue;
      }
      if (m === "-w") {
        n10 = true, s10++;
        continue;
      }
      if (m === "--") {
        s10++;
        break;
      }
      if (m.startsWith("-") && m !== "-") {
        if (m.startsWith("-s") && m.length > 2) {
          t10 = m.slice(2), s10++;
          continue;
        }
        if ((m === "-ws" || m === "-sw") && (n10 = true, s10 + 1 < e11.length)) {
          t10 = e11[s10 + 1], s10 += 2;
          continue;
        }
      }
      r10.push(m), s10++;
    }
    for (; s10 < e11.length; )
      r10.push(e11[s10]), s10++;
    if (r10.length === 0)
      return { stdout: "", stderr: `seq: missing operand
`, exitCode: 1 };
    let i10 = 1, o10 = 1, a;
    if (r10.length === 1 ? a = parseFloat(r10[0]) : r10.length === 2 ? (i10 = parseFloat(r10[0]), a = parseFloat(r10[1])) : (i10 = parseFloat(r10[0]), o10 = parseFloat(r10[1]), a = parseFloat(r10[2])), Number.isNaN(i10) || Number.isNaN(o10) || Number.isNaN(a))
      return { stdout: "", stderr: `seq: invalid floating point argument: '${r10.find((d) => Number.isNaN(parseFloat(d)))}'
`, exitCode: 1 };
    if (o10 === 0)
      return { stdout: "", stderr: `seq: invalid Zero increment value: '0'
`, exitCode: 1 };
    let l = [], c = (m) => {
      let d = String(m), g = d.indexOf(".");
      return g === -1 ? 0 : d.length - g - 1;
    }, u = Math.max(c(i10), c(o10), c(a)), f10 = 1e5, p = 0;
    if (o10 > 0)
      for (let m = i10; m <= a + 1e-10 && !(p++ > f10); m += o10)
        l.push(u > 0 ? m.toFixed(u) : String(Math.round(m)));
    else
      for (let m = i10; m >= a - 1e-10 && !(p++ > f10); m += o10)
        l.push(u > 0 ? m.toFixed(u) : String(Math.round(m)));
    if (n10 && l.length > 0) {
      let m = Math.max(...l.map((d) => d.replace("-", "").length));
      for (let d = 0; d < l.length; d++) {
        let g = l[d].startsWith("-"), w = (g ? l[d].slice(1) : l[d]).padStart(m, "0");
        l[d] = g ? `-${w}` : w;
      }
    }
    let h = l.join(t10);
    return { stdout: h ? `${h}
` : "", stderr: "", exitCode: 0 };
  } }, C5 = { name: "seq", flags: [{ flag: "-s", type: "value", valueHint: "string" }, { flag: "-w", type: "boolean" }], needsArgs: true };
});
var td = {};
Q(td, { exprCommand: () => N5, flagsForFuzzing: () => v5 });
function k5(e11) {
  if (e11.length === 1)
    return e11[0];
  let t10 = 0;
  function n10() {
    let c = r10();
    for (; t10 < e11.length && e11[t10] === "|"; ) {
      t10++;
      let u = r10();
      if (c !== "0" && c !== "")
        return c;
      c = u;
    }
    return c;
  }
  function r10() {
    let c = s10();
    for (; t10 < e11.length && e11[t10] === "&"; ) {
      t10++;
      let u = s10();
      (c === "0" || c === "" || u === "0" || u === "") && (c = "0");
    }
    return c;
  }
  function s10() {
    let c = i10();
    for (; t10 < e11.length; ) {
      let u = e11[t10];
      if (["=", "!=", "<", ">", "<=", ">="].includes(u)) {
        t10++;
        let f10 = i10(), p = parseInt(c, 10), h = parseInt(f10, 10), m = !Number.isNaN(p) && !Number.isNaN(h), d;
        u === "=" ? d = m ? p === h : c === f10 : u === "!=" ? d = m ? p !== h : c !== f10 : u === "<" ? d = m ? p < h : c < f10 : u === ">" ? d = m ? p > h : c > f10 : u === "<=" ? d = m ? p <= h : c <= f10 : d = m ? p >= h : c >= f10, c = d ? "1" : "0";
      } else
        break;
    }
    return c;
  }
  function i10() {
    let c = o10();
    for (; t10 < e11.length; ) {
      let u = e11[t10];
      if (u === "+" || u === "-") {
        t10++;
        let f10 = o10(), p = parseInt(c, 10), h = parseInt(f10, 10);
        if (Number.isNaN(p) || Number.isNaN(h))
          throw new Error("non-integer argument");
        c = String(u === "+" ? p + h : p - h);
      } else
        break;
    }
    return c;
  }
  function o10() {
    let c = a();
    for (; t10 < e11.length; ) {
      let u = e11[t10];
      if (u === "*" || u === "/" || u === "%") {
        t10++;
        let f10 = a(), p = parseInt(c, 10), h = parseInt(f10, 10);
        if (Number.isNaN(p) || Number.isNaN(h))
          throw new Error("non-integer argument");
        if ((u === "/" || u === "%") && h === 0)
          throw new Error("division by zero");
        u === "*" ? c = String(p * h) : u === "/" ? c = String(Math.trunc(p / h)) : c = String(p % h);
      } else
        break;
    }
    return c;
  }
  function a() {
    let c = l();
    for (; t10 < e11.length && e11[t10] === ":"; ) {
      t10++;
      let u = l(), p = V(`^${u}`).match(c);
      p ? c = p[1] !== void 0 ? p[1] : String(p[0].length) : c = "0";
    }
    return c;
  }
  function l() {
    if (t10 >= e11.length)
      throw new Error("syntax error");
    let c = e11[t10];
    if (c === "match") {
      t10++;
      let u = l(), f10 = l(), h = V(f10).match(u);
      return h ? h[1] !== void 0 ? h[1] : String(h[0].length) : "0";
    }
    if (c === "substr") {
      t10++;
      let u = l(), f10 = parseInt(l(), 10), p = parseInt(l(), 10);
      if (Number.isNaN(f10) || Number.isNaN(p))
        throw new Error("non-integer argument");
      return u.substring(f10 - 1, f10 - 1 + p);
    }
    if (c === "index") {
      t10++;
      let u = l(), f10 = l();
      for (let p = 0; p < u.length; p++)
        if (f10.includes(u[p]))
          return String(p + 1);
      return "0";
    }
    if (c === "length") {
      t10++;
      let u = l();
      return String(u.length);
    }
    if (c === "(") {
      t10++;
      let u = n10();
      if (t10 >= e11.length || e11[t10] !== ")")
        throw new Error("syntax error");
      return t10++, u;
    }
    return t10++, c;
  }
  return n10();
}
var N5;
var v5;
var nd = I(() => {
  "use strict";
  Fe();
  N5 = { name: "expr", async execute(e11, t10) {
    if (e11.length === 0)
      return { stdout: "", stderr: `expr: missing operand
`, exitCode: 2 };
    try {
      let n10 = k5(e11), r10 = n10 === "0" || n10 === "" ? 1 : 0;
      return { stdout: `${n10}
`, stderr: "", exitCode: r10 };
    } catch (n10) {
      return { stdout: "", stderr: `expr: ${n10.message}
`, exitCode: 2 };
    }
  } };
  v5 = { name: "expr", flags: [], needsArgs: true };
});
function O5(e11) {
  function t10(h, m) {
    return h << m | h >>> 32 - m;
  }
  let n10 = new Uint32Array([3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745]), r10 = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21], s10 = e11.length * 8, i10 = (e11.length % 64 < 56 ? 56 : 120) - e11.length % 64, o10 = new Uint8Array(e11.length + i10 + 8);
  o10.set(e11), o10[e11.length] = 128;
  let a = new DataView(o10.buffer);
  a.setUint32(o10.length - 8, s10 >>> 0, true), a.setUint32(o10.length - 4, Math.floor(s10 / 4294967296), true);
  let l = 1732584193, c = 4023233417, u = 2562383102, f10 = 271733878;
  for (let h = 0; h < o10.length; h += 64) {
    let m = new Uint32Array(16);
    for (let b = 0; b < 16; b++)
      m[b] = a.getUint32(h + b * 4, true);
    let d = l, g = c, y = u, w = f10;
    for (let b = 0; b < 64; b++) {
      let x, S;
      b < 16 ? (x = g & y | ~g & w, S = b) : b < 32 ? (x = w & g | ~w & y, S = (5 * b + 1) % 16) : b < 48 ? (x = g ^ y ^ w, S = (3 * b + 5) % 16) : (x = y ^ (g | ~w), S = 7 * b % 16), x = x + d + n10[b] + m[S] >>> 0, d = w, w = y, y = g, g = g + t10(x, r10[b]) >>> 0;
    }
    l = l + d >>> 0, c = c + g >>> 0, u = u + y >>> 0, f10 = f10 + w >>> 0;
  }
  let p = new Uint8Array(16);
  return new DataView(p.buffer).setUint32(0, l, true), new DataView(p.buffer).setUint32(4, c, true), new DataView(p.buffer).setUint32(8, u, true), new DataView(p.buffer).setUint32(12, f10, true), Array.from(p).map((h) => h.toString(16).padStart(2, "0")).join("");
}
async function rd(e11, t10) {
  if (e11 === "md5")
    return O5(t10);
  let n10 = I5.get(e11);
  if (!n10)
    throw new Error(`Unknown algorithm: ${e11}`);
  let r10 = await globalThis.crypto.subtle.digest(n10, new Uint8Array(t10).buffer);
  return Array.from(new Uint8Array(r10)).map((s10) => s10.toString(16).padStart(2, "0")).join("");
}
function kr(e11, t10, n10) {
  let r10 = { name: e11, summary: n10, usage: `${e11} [OPTION]... [FILE]...`, options: ["-c, --check    read checksums from FILEs and check them", "    --help     display this help and exit"] };
  return { name: e11, async execute(s10, i10) {
    if (U2(s10))
      return M(r10);
    let o10 = false, a = [];
    for (let f10 of s10)
      if (f10 === "-c" || f10 === "--check")
        o10 = true;
      else if (!(f10 === "-b" || f10 === "-t" || f10 === "--binary" || f10 === "--text")) {
        if (f10.startsWith("-") && f10 !== "-")
          return Y(e11, f10);
        a.push(f10);
      }
    a.length === 0 && a.push("-");
    let l = async (f10) => {
      if (f10 === "-")
        return Uint8Array.from(i10.stdin, (p) => p.charCodeAt(0));
      try {
        return await i10.fs.readFileBuffer(i10.fs.resolvePath(i10.cwd, f10));
      } catch {
        return null;
      }
    };
    if (o10) {
      let f10 = 0, p = "";
      for (let h of a) {
        let m = h === "-" ? i10.stdin : await i10.fs.readFile(i10.fs.resolvePath(i10.cwd, h)).catch(() => null);
        if (m === null)
          return { stdout: "", stderr: `${e11}: ${h}: No such file or directory
`, exitCode: 1 };
        for (let d of m.split(`
`)) {
          let g = d.match(/^([a-fA-F0-9]+)\s+[* ]?(.+)$/);
          if (!g)
            continue;
          let [, y, w] = g, b = await l(w);
          if (b === null) {
            p += `${w}: FAILED open or read
`, f10++;
            continue;
          }
          let x = await rd(t10, b) === y.toLowerCase();
          p += `${w}: ${x ? "OK" : "FAILED"}
`, x || f10++;
        }
      }
      return f10 > 0 && (p += `${e11}: WARNING: ${f10} computed checksum${f10 > 1 ? "s" : ""} did NOT match
`), { stdout: p, stderr: "", exitCode: f10 > 0 ? 1 : 0 };
    }
    let c = "", u = 0;
    for (let f10 of a) {
      let p = await l(f10);
      if (p === null) {
        c += `${e11}: ${f10}: No such file or directory
`, u = 1;
        continue;
      }
      c += `${await rd(t10, p)}  ${f10}
`;
    }
    return { stdout: c, stderr: "", exitCode: u };
  } };
}
var I5;
var Ci = I(() => {
  "use strict";
  se();
  I5 = /* @__PURE__ */ new Map([["sha1", "SHA-1"], ["sha256", "SHA-256"]]);
});
var sd = {};
Q(sd, { flagsForFuzzing: () => $5, md5sumCommand: () => R5 });
var R5;
var $5;
var id = I(() => {
  "use strict";
  Ci();
  R5 = kr("md5sum", "md5", "compute MD5 message digest"), $5 = { name: "md5sum", flags: [{ flag: "-c", type: "boolean" }], needsFiles: true };
});
var od = {};
Q(od, { flagsForFuzzing: () => P5, sha1sumCommand: () => T5 });
var T5;
var P5;
var ad = I(() => {
  "use strict";
  Ci();
  T5 = kr("sha1sum", "sha1", "compute SHA1 message digest"), P5 = { name: "sha1sum", flags: [{ flag: "-c", type: "boolean" }], needsFiles: true };
});
var ld = {};
Q(ld, { flagsForFuzzing: () => _5, sha256sumCommand: () => D5 });
var D5;
var _5;
var cd = I(() => {
  "use strict";
  Ci();
  D5 = kr("sha256sum", "sha256", "compute SHA256 message digest"), _5 = { name: "sha256sum", flags: [{ flag: "-c", type: "boolean" }], needsFiles: true };
});
var ud = Ls((Ka) => {
  Ka.read = function(e11, t10, n10, r10, s10) {
    var i10, o10, a = s10 * 8 - r10 - 1, l = (1 << a) - 1, c = l >> 1, u = -7, f10 = n10 ? s10 - 1 : 0, p = n10 ? -1 : 1, h = e11[t10 + f10];
    for (f10 += p, i10 = h & (1 << -u) - 1, h >>= -u, u += a; u > 0; i10 = i10 * 256 + e11[t10 + f10], f10 += p, u -= 8)
      ;
    for (o10 = i10 & (1 << -u) - 1, i10 >>= -u, u += r10; u > 0; o10 = o10 * 256 + e11[t10 + f10], f10 += p, u -= 8)
      ;
    if (i10 === 0)
      i10 = 1 - c;
    else {
      if (i10 === l)
        return o10 ? NaN : (h ? -1 : 1) * (1 / 0);
      o10 = o10 + Math.pow(2, r10), i10 = i10 - c;
    }
    return (h ? -1 : 1) * o10 * Math.pow(2, i10 - r10);
  };
  Ka.write = function(e11, t10, n10, r10, s10, i10) {
    var o10, a, l, c = i10 * 8 - s10 - 1, u = (1 << c) - 1, f10 = u >> 1, p = s10 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = r10 ? 0 : i10 - 1, m = r10 ? 1 : -1, d = t10 < 0 || t10 === 0 && 1 / t10 < 0 ? 1 : 0;
    for (t10 = Math.abs(t10), isNaN(t10) || t10 === 1 / 0 ? (a = isNaN(t10) ? 1 : 0, o10 = u) : (o10 = Math.floor(Math.log(t10) / Math.LN2), t10 * (l = Math.pow(2, -o10)) < 1 && (o10--, l *= 2), o10 + f10 >= 1 ? t10 += p / l : t10 += p * Math.pow(2, 1 - f10), t10 * l >= 2 && (o10++, l /= 2), o10 + f10 >= u ? (a = 0, o10 = u) : o10 + f10 >= 1 ? (a = (t10 * l - 1) * Math.pow(2, s10), o10 = o10 + f10) : (a = t10 * Math.pow(2, f10 - 1) * Math.pow(2, s10), o10 = 0)); s10 >= 8; e11[n10 + h] = a & 255, h += m, a /= 256, s10 -= 8)
      ;
    for (o10 = o10 << s10 | a, c += s10; c > 0; e11[n10 + h] = o10 & 255, h += m, o10 /= 256, c -= 8)
      ;
    e11[n10 + h - m] |= d * 128;
  };
});
function fd(e11, t10 = "utf-8") {
  switch (t10.toLowerCase()) {
    case "utf-8":
    case "utf8":
      return typeof globalThis.TextDecoder < "u" ? new globalThis.TextDecoder("utf-8").decode(e11) : F5(e11);
    case "utf-16le":
      return M5(e11);
    case "ascii":
      return U5(e11);
    case "latin1":
    case "iso-8859-1":
      return W5(e11);
    case "windows-1252":
      return B5(e11);
    default:
      throw new RangeError(`Encoding '${t10}' not supported`);
  }
}
function F5(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; ) {
    let r10 = e11[n10++];
    if (r10 < 128)
      t10 += String.fromCharCode(r10);
    else if (r10 < 224) {
      let s10 = e11[n10++] & 63;
      t10 += String.fromCharCode((r10 & 31) << 6 | s10);
    } else if (r10 < 240) {
      let s10 = e11[n10++] & 63, i10 = e11[n10++] & 63;
      t10 += String.fromCharCode((r10 & 15) << 12 | s10 << 6 | i10);
    } else {
      let s10 = e11[n10++] & 63, i10 = e11[n10++] & 63, o10 = e11[n10++] & 63, a = (r10 & 7) << 18 | s10 << 12 | i10 << 6 | o10;
      a -= 65536, t10 += String.fromCharCode(55296 + (a >> 10 & 1023), 56320 + (a & 1023));
    }
  }
  return t10;
}
function M5(e11) {
  let t10 = "";
  for (let n10 = 0; n10 < e11.length; n10 += 2)
    t10 += String.fromCharCode(e11[n10] | e11[n10 + 1] << 8);
  return t10;
}
function U5(e11) {
  return String.fromCharCode(...e11.map((t10) => t10 & 127));
}
function W5(e11) {
  return String.fromCharCode(...e11);
}
function B5(e11) {
  let t10 = "";
  for (let n10 of e11)
    n10 >= 128 && n10 <= 159 && Xa[n10] ? t10 += Xa[n10] : t10 += String.fromCharCode(n10);
  return t10;
}
var Xa;
var L5;
var pd = I(() => {
  Xa = { 128: "\u20AC", 130: "\u201A", 131: "\u0192", 132: "\u201E", 133: "\u2026", 134: "\u2020", 135: "\u2021", 136: "\u02C6", 137: "\u2030", 138: "\u0160", 139: "\u2039", 140: "\u0152", 142: "\u017D", 145: "\u2018", 146: "\u2019", 147: "\u201C", 148: "\u201D", 149: "\u2022", 150: "\u2013", 151: "\u2014", 152: "\u02DC", 153: "\u2122", 154: "\u0161", 155: "\u203A", 156: "\u0153", 158: "\u017E", 159: "\u0178" }, L5 = {};
  for (let [e11, t10] of Object.entries(Xa))
    L5[t10] = Number.parseInt(e11);
});
function vt(e11) {
  return new DataView(e11.buffer, e11.byteOffset);
}
var hd;
var dd;
var Ge;
var vr;
var Qe;
var md;
var gd;
var yd;
var It;
var fs2 = I(() => {
  hd = lu(ud(), 1);
  pd();
  dd = { len: 1, get(e11, t10) {
    return vt(e11).getUint8(t10);
  }, put(e11, t10, n10) {
    return vt(e11).setUint8(t10, n10), t10 + 1;
  } }, Ge = { len: 2, get(e11, t10) {
    return vt(e11).getUint16(t10, true);
  }, put(e11, t10, n10) {
    return vt(e11).setUint16(t10, n10, true), t10 + 2;
  } }, vr = { len: 2, get(e11, t10) {
    return vt(e11).getUint16(t10);
  }, put(e11, t10, n10) {
    return vt(e11).setUint16(t10, n10), t10 + 2;
  } }, Qe = { len: 4, get(e11, t10) {
    return vt(e11).getUint32(t10, true);
  }, put(e11, t10, n10) {
    return vt(e11).setUint32(t10, n10, true), t10 + 4;
  } }, md = { len: 4, get(e11, t10) {
    return vt(e11).getUint32(t10);
  }, put(e11, t10, n10) {
    return vt(e11).setUint32(t10, n10), t10 + 4;
  } }, gd = { len: 4, get(e11, t10) {
    return vt(e11).getInt32(t10);
  }, put(e11, t10, n10) {
    return vt(e11).setInt32(t10, n10), t10 + 4;
  } }, yd = { len: 8, get(e11, t10) {
    return vt(e11).getBigUint64(t10, true);
  }, put(e11, t10, n10) {
    return vt(e11).setBigUint64(t10, n10, true), t10 + 8;
  } }, It = class {
    constructor(t10, n10) {
      this.len = t10, this.encoding = n10;
    }
    get(t10, n10 = 0) {
      let r10 = t10.subarray(n10, n10 + this.len);
      return fd(r10, this.encoding);
    }
  };
});
var H5;
var Ue;
var Zn;
var ps = I(() => {
  H5 = "End-Of-Stream", Ue = class extends Error {
    constructor() {
      super(H5), this.name = "EndOfStreamError";
    }
  }, Zn = class extends Error {
    constructor(t10 = "The operation was aborted") {
      super(t10), this.name = "AbortError";
    }
  };
});
var wd = I(() => {
});
var Qn;
var Ni = I(() => {
  ps();
  Qn = class {
    constructor() {
      this.endOfStream = false, this.interrupted = false, this.peekQueue = [];
    }
    async peek(t10, n10 = false) {
      let r10 = await this.read(t10, n10);
      return this.peekQueue.push(t10.subarray(0, r10)), r10;
    }
    async read(t10, n10 = false) {
      if (t10.length === 0)
        return 0;
      let r10 = this.readFromPeekBuffer(t10);
      if (this.endOfStream || (r10 += await this.readRemainderFromStream(t10.subarray(r10), n10)), r10 === 0 && !n10)
        throw new Ue();
      return r10;
    }
    readFromPeekBuffer(t10) {
      let n10 = t10.length, r10 = 0;
      for (; this.peekQueue.length > 0 && n10 > 0; ) {
        let s10 = this.peekQueue.pop();
        if (!s10)
          throw new Error("peekData should be defined");
        let i10 = Math.min(s10.length, n10);
        t10.set(s10.subarray(0, i10), r10), r10 += i10, n10 -= i10, i10 < s10.length && this.peekQueue.push(s10.subarray(i10));
      }
      return r10;
    }
    async readRemainderFromStream(t10, n10) {
      let r10 = 0;
      for (; r10 < t10.length && !this.endOfStream; ) {
        if (this.interrupted)
          throw new Zn();
        let s10 = await this.readFromStream(t10.subarray(r10), n10);
        if (s10 === 0)
          break;
        r10 += s10;
      }
      if (!n10 && r10 < t10.length)
        throw new Ue();
      return r10;
    }
  };
});
var bd = I(() => {
  ps();
  wd();
  Ni();
});
var ki;
var xd = I(() => {
  Ni();
  ki = class extends Qn {
    constructor(t10) {
      super(), this.reader = t10;
    }
    async abort() {
      return this.close();
    }
    async close() {
      this.reader.releaseLock();
    }
  };
});
var hs;
var Ya = I(() => {
  xd();
  hs = class extends ki {
    async readFromStream(t10, n10) {
      if (t10.length === 0)
        return 0;
      let r10 = await this.reader.read(new Uint8Array(t10.length), { min: n10 ? void 0 : t10.length });
      return r10.done && (this.endOfStream = r10.done), r10.value ? (t10.set(r10.value), r10.value.length) : 0;
    }
  };
});
var Ir;
var Ja = I(() => {
  ps();
  Ni();
  Ir = class extends Qn {
    constructor(t10) {
      super(), this.reader = t10, this.buffer = null;
    }
    writeChunk(t10, n10) {
      let r10 = Math.min(n10.length, t10.length);
      return t10.set(n10.subarray(0, r10)), r10 < n10.length ? this.buffer = n10.subarray(r10) : this.buffer = null, r10;
    }
    async readFromStream(t10, n10) {
      if (t10.length === 0)
        return 0;
      let r10 = 0;
      for (this.buffer && (r10 += this.writeChunk(t10, this.buffer)); r10 < t10.length && !this.endOfStream; ) {
        let s10 = await this.reader.read();
        if (s10.done) {
          this.endOfStream = true;
          break;
        }
        s10.value && (r10 += this.writeChunk(t10.subarray(r10), s10.value));
      }
      if (!n10 && r10 === 0 && this.endOfStream)
        throw new Ue();
      return r10;
    }
    abort() {
      return this.interrupted = true, this.reader.cancel();
    }
    async close() {
      await this.abort(), this.reader.releaseLock();
    }
  };
});
function el(e11) {
  try {
    let t10 = e11.getReader({ mode: "byob" });
    return t10 instanceof ReadableStreamDefaultReader ? new Ir(t10) : new hs(t10);
  } catch (t10) {
    if (t10 instanceof TypeError)
      return new Ir(e11.getReader());
    throw t10;
  }
}
var Ed = I(() => {
  Ya();
  Ja();
});
var Kn = I(() => {
  ps();
  bd();
  Ya();
  Ja();
  Ed();
});
var An;
var ds = I(() => {
  Kn();
  An = class {
    constructor(t10) {
      this.numBuffer = new Uint8Array(8), this.position = 0, this.onClose = t10?.onClose, t10?.abortSignal && t10.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
    async readToken(t10, n10 = this.position) {
      let r10 = new Uint8Array(t10.len);
      if (await this.readBuffer(r10, { position: n10 }) < t10.len)
        throw new Ue();
      return t10.get(r10, 0);
    }
    async peekToken(t10, n10 = this.position) {
      let r10 = new Uint8Array(t10.len);
      if (await this.peekBuffer(r10, { position: n10 }) < t10.len)
        throw new Ue();
      return t10.get(r10, 0);
    }
    async readNumber(t10) {
      if (await this.readBuffer(this.numBuffer, { length: t10.len }) < t10.len)
        throw new Ue();
      return t10.get(this.numBuffer, 0);
    }
    async peekNumber(t10) {
      if (await this.peekBuffer(this.numBuffer, { length: t10.len }) < t10.len)
        throw new Ue();
      return t10.get(this.numBuffer, 0);
    }
    async ignore(t10) {
      if (this.fileInfo.size !== void 0) {
        let n10 = this.fileInfo.size - this.position;
        if (t10 > n10)
          return this.position += n10, n10;
      }
      return this.position += t10, t10;
    }
    async close() {
      await this.abort(), await this.onClose?.();
    }
    normalizeOptions(t10, n10) {
      if (!this.supportsRandomAccess() && n10 && n10.position !== void 0 && n10.position < this.position)
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      return { mayBeLess: false, offset: 0, length: t10.length, position: this.position, ...n10 };
    }
    abort() {
      return Promise.resolve();
    }
  };
});
var G5;
var vi;
var Ad = I(() => {
  ds();
  Kn();
  G5 = 256e3, vi = class extends An {
    constructor(t10, n10) {
      super(n10), this.streamReader = t10, this.fileInfo = n10?.fileInfo ?? {};
    }
    async readBuffer(t10, n10) {
      let r10 = this.normalizeOptions(t10, n10), s10 = r10.position - this.position;
      if (s10 > 0)
        return await this.ignore(s10), this.readBuffer(t10, n10);
      if (s10 < 0)
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      if (r10.length === 0)
        return 0;
      let i10 = await this.streamReader.read(t10.subarray(0, r10.length), r10.mayBeLess);
      if (this.position += i10, (!n10 || !n10.mayBeLess) && i10 < r10.length)
        throw new Ue();
      return i10;
    }
    async peekBuffer(t10, n10) {
      let r10 = this.normalizeOptions(t10, n10), s10 = 0;
      if (r10.position) {
        let i10 = r10.position - this.position;
        if (i10 > 0) {
          let o10 = new Uint8Array(r10.length + i10);
          return s10 = await this.peekBuffer(o10, { mayBeLess: r10.mayBeLess }), t10.set(o10.subarray(i10)), s10 - i10;
        }
        if (i10 < 0)
          throw new Error("Cannot peek from a negative offset in a stream");
      }
      if (r10.length > 0) {
        try {
          s10 = await this.streamReader.peek(t10.subarray(0, r10.length), r10.mayBeLess);
        } catch (i10) {
          if (n10?.mayBeLess && i10 instanceof Ue)
            return 0;
          throw i10;
        }
        if (!r10.mayBeLess && s10 < r10.length)
          throw new Ue();
      }
      return s10;
    }
    async ignore(t10) {
      let n10 = Math.min(G5, t10), r10 = new Uint8Array(n10), s10 = 0;
      for (; s10 < t10; ) {
        let i10 = t10 - s10, o10 = await this.readBuffer(r10, { length: Math.min(n10, i10) });
        if (o10 < 0)
          return o10;
        s10 += o10;
      }
      return s10;
    }
    abort() {
      return this.streamReader.abort();
    }
    async close() {
      return this.streamReader.close();
    }
    supportsRandomAccess() {
      return false;
    }
  };
});
var Ii;
var Sd = I(() => {
  Kn();
  ds();
  Ii = class extends An {
    constructor(t10, n10) {
      super(n10), this.uint8Array = t10, this.fileInfo = { ...n10?.fileInfo ?? {}, size: t10.length };
    }
    async readBuffer(t10, n10) {
      n10?.position && (this.position = n10.position);
      let r10 = await this.peekBuffer(t10, n10);
      return this.position += r10, r10;
    }
    async peekBuffer(t10, n10) {
      let r10 = this.normalizeOptions(t10, n10), s10 = Math.min(this.uint8Array.length - r10.position, r10.length);
      if (!r10.mayBeLess && s10 < r10.length)
        throw new Ue();
      return t10.set(this.uint8Array.subarray(r10.position, r10.position + s10)), s10;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(t10) {
      this.position = t10;
    }
  };
});
var Oi;
var Cd = I(() => {
  Kn();
  ds();
  Oi = class extends An {
    constructor(t10, n10) {
      super(n10), this.blob = t10, this.fileInfo = { ...n10?.fileInfo ?? {}, size: t10.size, mimeType: t10.type };
    }
    async readBuffer(t10, n10) {
      n10?.position && (this.position = n10.position);
      let r10 = await this.peekBuffer(t10, n10);
      return this.position += r10, r10;
    }
    async peekBuffer(t10, n10) {
      let r10 = this.normalizeOptions(t10, n10), s10 = Math.min(this.blob.size - r10.position, r10.length);
      if (!r10.mayBeLess && s10 < r10.length)
        throw new Ue();
      let i10 = await this.blob.slice(r10.position, r10.position + s10).arrayBuffer();
      return t10.set(new Uint8Array(i10)), s10;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(t10) {
      this.position = t10;
    }
  };
});
function Nd(e11, t10) {
  let n10 = el(e11), r10 = t10 ?? {}, s10 = r10.onClose;
  return r10.onClose = async () => {
    if (await n10.close(), s10)
      return s10();
  }, new vi(n10, r10);
}
function kd(e11, t10) {
  return new Ii(e11, t10);
}
function vd(e11, t10) {
  return new Oi(e11, t10);
}
var Id = I(() => {
  Kn();
  Ad();
  Sd();
  Cd();
  Kn();
  ds();
});
var Rd = Ls((Gv, Od) => {
  var Or = 1e3, Rr = Or * 60, $r = Rr * 60, Xn = $r * 24, q5 = Xn * 7, Z5 = Xn * 365.25;
  Od.exports = function(e11, t10) {
    t10 = t10 || {};
    var n10 = typeof e11;
    if (n10 === "string" && e11.length > 0)
      return Q5(e11);
    if (n10 === "number" && isFinite(e11))
      return t10.long ? X5(e11) : K5(e11);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e11));
  };
  function Q5(e11) {
    if (e11 = String(e11), !(e11.length > 100)) {
      var t10 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e11);
      if (t10) {
        var n10 = parseFloat(t10[1]), r10 = (t10[2] || "ms").toLowerCase();
        switch (r10) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n10 * Z5;
          case "weeks":
          case "week":
          case "w":
            return n10 * q5;
          case "days":
          case "day":
          case "d":
            return n10 * Xn;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n10 * $r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n10 * Rr;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n10 * Or;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n10;
          default:
            return;
        }
      }
    }
  }
  function K5(e11) {
    var t10 = Math.abs(e11);
    return t10 >= Xn ? Math.round(e11 / Xn) + "d" : t10 >= $r ? Math.round(e11 / $r) + "h" : t10 >= Rr ? Math.round(e11 / Rr) + "m" : t10 >= Or ? Math.round(e11 / Or) + "s" : e11 + "ms";
  }
  function X5(e11) {
    var t10 = Math.abs(e11);
    return t10 >= Xn ? Ri(e11, t10, Xn, "day") : t10 >= $r ? Ri(e11, t10, $r, "hour") : t10 >= Rr ? Ri(e11, t10, Rr, "minute") : t10 >= Or ? Ri(e11, t10, Or, "second") : e11 + " ms";
  }
  function Ri(e11, t10, n10, r10) {
    var s10 = t10 >= n10 * 1.5;
    return Math.round(e11 / n10) + " " + r10 + (s10 ? "s" : "");
  }
});
var Td = Ls((Vv, $d) => {
  function Y5(e11) {
    n10.debug = n10, n10.default = n10, n10.coerce = l, n10.disable = o10, n10.enable = s10, n10.enabled = a, n10.humanize = Rd(), n10.destroy = c, Object.keys(e11).forEach((u) => {
      n10[u] = e11[u];
    }), n10.names = [], n10.skips = [], n10.formatters = {};
    function t10(u) {
      let f10 = 0;
      for (let p = 0; p < u.length; p++)
        f10 = (f10 << 5) - f10 + u.charCodeAt(p), f10 |= 0;
      return n10.colors[Math.abs(f10) % n10.colors.length];
    }
    n10.selectColor = t10;
    function n10(u) {
      let f10, p = null, h, m;
      function d(...g) {
        if (!d.enabled)
          return;
        let y = d, w = Number(/* @__PURE__ */ new Date()), b = w - (f10 || w);
        y.diff = b, y.prev = f10, y.curr = w, f10 = w, g[0] = n10.coerce(g[0]), typeof g[0] != "string" && g.unshift("%O");
        let x = 0;
        g[0] = g[0].replace(/%([a-zA-Z%])/g, (O, R10) => {
          if (O === "%%")
            return "%";
          x++;
          let F4 = n10.formatters[R10];
          if (typeof F4 == "function") {
            let $ = g[x];
            O = F4.call(y, $), g.splice(x, 1), x--;
          }
          return O;
        }), n10.formatArgs.call(y, g), (y.log || n10.log).apply(y, g);
      }
      return d.namespace = u, d.useColors = n10.useColors(), d.color = n10.selectColor(u), d.extend = r10, d.destroy = n10.destroy, Object.defineProperty(d, "enabled", { enumerable: true, configurable: false, get: () => p !== null ? p : (h !== n10.namespaces && (h = n10.namespaces, m = n10.enabled(u)), m), set: (g) => {
        p = g;
      } }), typeof n10.init == "function" && n10.init(d), d;
    }
    function r10(u, f10) {
      let p = n10(this.namespace + (typeof f10 > "u" ? ":" : f10) + u);
      return p.log = this.log, p;
    }
    function s10(u) {
      n10.save(u), n10.namespaces = u, n10.names = [], n10.skips = [];
      let f10 = (typeof u == "string" ? u : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (let p of f10)
        p[0] === "-" ? n10.skips.push(p.slice(1)) : n10.names.push(p);
    }
    function i10(u, f10) {
      let p = 0, h = 0, m = -1, d = 0;
      for (; p < u.length; )
        if (h < f10.length && (f10[h] === u[p] || f10[h] === "*"))
          f10[h] === "*" ? (m = h, d = p, h++) : (p++, h++);
        else if (m !== -1)
          h = m + 1, d++, p = d;
        else
          return false;
      for (; h < f10.length && f10[h] === "*"; )
        h++;
      return h === f10.length;
    }
    function o10() {
      let u = [...n10.names, ...n10.skips.map((f10) => "-" + f10)].join(",");
      return n10.enable(""), u;
    }
    function a(u) {
      for (let f10 of n10.skips)
        if (i10(u, f10))
          return false;
      for (let f10 of n10.names)
        if (i10(u, f10))
          return true;
      return false;
    }
    function l(u) {
      return u instanceof Error ? u.stack || u.message : u;
    }
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return n10.enable(n10.load()), n10;
  }
  $d.exports = Y5;
});
var Pd = Ls((Ot, $i) => {
  Ot.formatArgs = ew;
  Ot.save = tw;
  Ot.load = nw;
  Ot.useColors = J5;
  Ot.storage = rw();
  Ot.destroy = (() => {
    let e11 = false;
    return () => {
      e11 || (e11 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })();
  Ot.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
  function J5() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return true;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return false;
    let e11;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (e11 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(e11[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function ew(e11) {
    if (e11[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e11[0] + (this.useColors ? "%c " : " ") + "+" + $i.exports.humanize(this.diff), !this.useColors)
      return;
    let t10 = "color: " + this.color;
    e11.splice(1, 0, t10, "color: inherit");
    let n10 = 0, r10 = 0;
    e11[0].replace(/%[a-zA-Z%]/g, (s10) => {
      s10 !== "%%" && (n10++, s10 === "%c" && (r10 = n10));
    }), e11.splice(r10, 0, t10);
  }
  Ot.log = console.debug || console.log || (() => {
  });
  function tw(e11) {
    try {
      e11 ? Ot.storage.setItem("debug", e11) : Ot.storage.removeItem("debug");
    } catch {
    }
  }
  function nw() {
    let e11;
    try {
      e11 = Ot.storage.getItem("debug") || Ot.storage.getItem("DEBUG");
    } catch {
    }
    return !e11 && typeof process < "u" && "env" in process && (e11 = process.env.DEBUG), e11;
  }
  function rw() {
    try {
      return localStorage;
    } catch {
    }
  }
  $i.exports = Td()(Ot);
  var { formatters: sw } = $i.exports;
  sw.j = function(e11) {
    try {
      return JSON.stringify(e11);
    } catch (t10) {
      return "[UnexpectedJSONParseError]: " + t10.message;
    }
  };
});
var Yn;
var tl;
var Dd;
var _d;
var Ld;
var Fd = I(() => {
  fs2();
  Yn = { LocalFileHeader: 67324752, DataDescriptor: 134695760, CentralFileHeader: 33639248, EndOfCentralDirectory: 101010256 }, tl = { get(e11) {
    return { signature: Qe.get(e11, 0), compressedSize: Qe.get(e11, 8), uncompressedSize: Qe.get(e11, 12) };
  }, len: 16 }, Dd = { get(e11) {
    let t10 = Ge.get(e11, 6);
    return { signature: Qe.get(e11, 0), minVersion: Ge.get(e11, 4), dataDescriptor: !!(t10 & 8), compressedMethod: Ge.get(e11, 8), compressedSize: Qe.get(e11, 18), uncompressedSize: Qe.get(e11, 22), filenameLength: Ge.get(e11, 26), extraFieldLength: Ge.get(e11, 28), filename: null };
  }, len: 30 }, _d = { get(e11) {
    return { signature: Qe.get(e11, 0), nrOfThisDisk: Ge.get(e11, 4), nrOfThisDiskWithTheStart: Ge.get(e11, 6), nrOfEntriesOnThisDisk: Ge.get(e11, 8), nrOfEntriesOfSize: Ge.get(e11, 10), sizeOfCd: Qe.get(e11, 12), offsetOfStartOfCd: Qe.get(e11, 16), zipFileCommentLength: Ge.get(e11, 20) };
  }, len: 22 }, Ld = { get(e11) {
    let t10 = Ge.get(e11, 8);
    return { signature: Qe.get(e11, 0), minVersion: Ge.get(e11, 6), dataDescriptor: !!(t10 & 8), compressedMethod: Ge.get(e11, 10), compressedSize: Qe.get(e11, 20), uncompressedSize: Qe.get(e11, 24), filenameLength: Ge.get(e11, 28), extraFieldLength: Ge.get(e11, 30), fileCommentLength: Ge.get(e11, 32), relativeOffsetOfLocalHeader: Qe.get(e11, 42), filename: null };
  }, len: 46 };
});
function Ud(e11) {
  let t10 = new Uint8Array(Qe.len);
  return Qe.put(t10, 0, e11), t10;
}
function ow(e11, t10) {
  let n10 = e11.length, r10 = t10.length;
  if (r10 > n10)
    return -1;
  for (let s10 = 0; s10 <= n10 - r10; s10++) {
    let i10 = true;
    for (let o10 = 0; o10 < r10; o10++)
      if (e11[s10 + o10] !== t10[o10]) {
        i10 = false;
        break;
      }
    if (i10)
      return s10;
  }
  return -1;
}
function aw(e11) {
  let t10 = e11.reduce((s10, i10) => s10 + i10.length, 0), n10 = new Uint8Array(t10), r10 = 0;
  for (let s10 of e11)
    n10.set(s10, r10), r10 += s10.length;
  return n10;
}
var Md;
var fn2;
var nl;
var iw;
var Ti;
var ms;
var Wd = I(() => {
  fs2();
  Md = lu(Pd(), 1);
  Fd();
  fn2 = (0, Md.default)("tokenizer:inflate"), nl = 256 * 1024, iw = Ud(Yn.DataDescriptor), Ti = Ud(Yn.EndOfCentralDirectory), ms = class e11 {
    constructor(t10) {
      this.tokenizer = t10, this.syncBuffer = new Uint8Array(nl);
    }
    async isZip() {
      return await this.peekSignature() === Yn.LocalFileHeader;
    }
    peekSignature() {
      return this.tokenizer.peekToken(Qe);
    }
    async findEndOfCentralDirectoryLocator() {
      let t10 = this.tokenizer, n10 = Math.min(16 * 1024, t10.fileInfo.size), r10 = this.syncBuffer.subarray(0, n10);
      await this.tokenizer.readBuffer(r10, { position: t10.fileInfo.size - n10 });
      for (let s10 = r10.length - 4; s10 >= 0; s10--)
        if (r10[s10] === Ti[0] && r10[s10 + 1] === Ti[1] && r10[s10 + 2] === Ti[2] && r10[s10 + 3] === Ti[3])
          return t10.fileInfo.size - n10 + s10;
      return -1;
    }
    async readCentralDirectory() {
      if (!this.tokenizer.supportsRandomAccess()) {
        fn2("Cannot reading central-directory without random-read support");
        return;
      }
      fn2("Reading central-directory...");
      let t10 = this.tokenizer.position, n10 = await this.findEndOfCentralDirectoryLocator();
      if (n10 > 0) {
        fn2("Central-directory 32-bit signature found");
        let r10 = await this.tokenizer.readToken(_d, n10), s10 = [];
        this.tokenizer.setPosition(r10.offsetOfStartOfCd);
        for (let i10 = 0; i10 < r10.nrOfEntriesOfSize; ++i10) {
          let o10 = await this.tokenizer.readToken(Ld);
          if (o10.signature !== Yn.CentralFileHeader)
            throw new Error("Expected Central-File-Header signature");
          o10.filename = await this.tokenizer.readToken(new It(o10.filenameLength, "utf-8")), await this.tokenizer.ignore(o10.extraFieldLength), await this.tokenizer.ignore(o10.fileCommentLength), s10.push(o10), fn2(`Add central-directory file-entry: n=${i10 + 1}/${s10.length}: filename=${s10[i10].filename}`);
        }
        return this.tokenizer.setPosition(t10), s10;
      }
      this.tokenizer.setPosition(t10);
    }
    async unzip(t10) {
      let n10 = await this.readCentralDirectory();
      if (n10)
        return this.iterateOverCentralDirectory(n10, t10);
      let r10 = false;
      do {
        let s10 = await this.readLocalFileHeader();
        if (!s10)
          break;
        let i10 = t10(s10);
        r10 = !!i10.stop;
        let o10;
        if (await this.tokenizer.ignore(s10.extraFieldLength), s10.dataDescriptor && s10.compressedSize === 0) {
          let a = [], l = nl;
          fn2("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
          let c = -1;
          for (; c < 0 && l === nl; ) {
            l = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true }), c = ow(this.syncBuffer.subarray(0, l), iw);
            let u = c >= 0 ? c : l;
            if (i10.handler) {
              let f10 = new Uint8Array(u);
              await this.tokenizer.readBuffer(f10), a.push(f10);
            } else
              await this.tokenizer.ignore(u);
          }
          fn2(`Found data-descriptor-signature at pos=${this.tokenizer.position}`), i10.handler && await this.inflate(s10, aw(a), i10.handler);
        } else
          i10.handler ? (fn2(`Reading compressed-file-data: ${s10.compressedSize} bytes`), o10 = new Uint8Array(s10.compressedSize), await this.tokenizer.readBuffer(o10), await this.inflate(s10, o10, i10.handler)) : (fn2(`Ignoring compressed-file-data: ${s10.compressedSize} bytes`), await this.tokenizer.ignore(s10.compressedSize));
        if (fn2(`Reading data-descriptor at pos=${this.tokenizer.position}`), s10.dataDescriptor && (await this.tokenizer.readToken(tl)).signature !== 134695760)
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - tl.len}`);
      } while (!r10);
    }
    async iterateOverCentralDirectory(t10, n10) {
      for (let r10 of t10) {
        let s10 = n10(r10);
        if (s10.handler) {
          this.tokenizer.setPosition(r10.relativeOffsetOfLocalHeader);
          let i10 = await this.readLocalFileHeader();
          if (i10) {
            await this.tokenizer.ignore(i10.extraFieldLength);
            let o10 = new Uint8Array(r10.compressedSize);
            await this.tokenizer.readBuffer(o10), await this.inflate(i10, o10, s10.handler);
          }
        }
        if (s10.stop)
          break;
      }
    }
    async inflate(t10, n10, r10) {
      if (t10.compressedMethod === 0)
        return r10(n10);
      if (t10.compressedMethod !== 8)
        throw new Error(`Unsupported ZIP compression method: ${t10.compressedMethod}`);
      fn2(`Decompress filename=${t10.filename}, compressed-size=${n10.length}`);
      let s10 = await e11.decompressDeflateRaw(n10);
      return r10(s10);
    }
    static async decompressDeflateRaw(t10) {
      let n10 = new ReadableStream({ start(i10) {
        i10.enqueue(t10), i10.close();
      } }), r10 = new DecompressionStream("deflate-raw"), s10 = n10.pipeThrough(r10);
      try {
        let o10 = await new Response(s10).arrayBuffer();
        return new Uint8Array(o10);
      } catch (i10) {
        let o10 = i10 instanceof Error ? `Failed to deflate ZIP entry: ${i10.message}` : "Unknown decompression error in ZIP entry";
        throw new TypeError(o10);
      }
    }
    async readLocalFileHeader() {
      let t10 = await this.tokenizer.peekToken(Qe);
      if (t10 === Yn.LocalFileHeader) {
        let n10 = await this.tokenizer.readToken(Dd);
        return n10.filename = await this.tokenizer.readToken(new It(n10.filenameLength, "utf-8")), n10;
      }
      if (t10 === Yn.CentralFileHeader)
        return false;
      throw t10 === 3759263696 ? new Error("Encrypted ZIP") : new Error("Unexpected signature");
    }
  };
});
var gs;
var Bd = I(() => {
  gs = class {
    constructor(t10) {
      this.tokenizer = t10;
    }
    inflate() {
      let t10 = this.tokenizer;
      return new ReadableStream({ async pull(n10) {
        let r10 = new Uint8Array(1024), s10 = await t10.readBuffer(r10, { mayBeLess: true });
        if (s10 === 0) {
          n10.close();
          return;
        }
        n10.enqueue(r10.subarray(0, s10));
      } }).pipeThrough(new DecompressionStream("gzip"));
    }
  };
});
var zd = I(() => {
  Wd();
  Bd();
});
function rl(e11) {
  let { byteLength: t10 } = e11;
  if (t10 === 6)
    return e11.getUint16(0) * 2 ** 32 + e11.getUint32(2);
  if (t10 === 5)
    return e11.getUint8(0) * 2 ** 32 + e11.getUint32(1);
  if (t10 === 4)
    return e11.getUint32(0);
  if (t10 === 3)
    return e11.getUint8(0) * 2 ** 16 + e11.getUint16(1);
  if (t10 === 2)
    return e11.getUint16(0);
  if (t10 === 1)
    return e11.getUint8(0);
}
var nI;
var rI;
var sI;
var Hd = I(() => {
  nI = { utf8: new globalThis.TextDecoder("utf8") }, rI = new globalThis.TextEncoder(), sI = Array.from({ length: 256 }, (e11, t10) => t10.toString(16).padStart(2, "0"));
});
function jd(e11, t10) {
  if (t10 === "utf-16le") {
    let n10 = [];
    for (let r10 = 0; r10 < e11.length; r10++) {
      let s10 = e11.charCodeAt(r10);
      n10.push(s10 & 255, s10 >> 8 & 255);
    }
    return n10;
  }
  if (t10 === "utf-16be") {
    let n10 = [];
    for (let r10 = 0; r10 < e11.length; r10++) {
      let s10 = e11.charCodeAt(r10);
      n10.push(s10 >> 8 & 255, s10 & 255);
    }
    return n10;
  }
  return [...e11].map((n10) => n10.charCodeAt(0));
}
function Gd(e11, t10 = 0) {
  let n10 = Number.parseInt(new It(6).get(e11, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(n10))
    return false;
  let r10 = 256;
  for (let s10 = t10; s10 < t10 + 148; s10++)
    r10 += e11[s10];
  for (let s10 = t10 + 156; s10 < t10 + 512; s10++)
    r10 += e11[s10];
  return n10 === r10;
}
var Vd;
var qd = I(() => {
  fs2();
  Vd = { get: (e11, t10) => e11[t10 + 3] & 127 | e11[t10 + 2] << 7 | e11[t10 + 1] << 14 | e11[t10] << 21, len: 4 };
});
var Zd;
var Qd;
var Kd = I(() => {
  Zd = ["jpg", "png", "apng", "gif", "webp", "flif", "xcf", "cr2", "cr3", "orf", "arw", "dng", "nef", "rw2", "raf", "tif", "bmp", "icns", "jxr", "psd", "indd", "zip", "tar", "rar", "gz", "bz2", "7z", "dmg", "mp4", "mid", "mkv", "webm", "mov", "avi", "mpg", "mp2", "mp3", "m4a", "oga", "ogg", "ogv", "opus", "flac", "wav", "spx", "amr", "pdf", "epub", "elf", "macho", "exe", "swf", "rtf", "wasm", "woff", "woff2", "eot", "ttf", "otf", "ttc", "ico", "flv", "ps", "xz", "sqlite", "nes", "crx", "xpi", "cab", "deb", "ar", "rpm", "Z", "lz", "cfb", "mxf", "mts", "blend", "bpg", "docx", "pptx", "xlsx", "3gp", "3g2", "j2c", "jp2", "jpm", "jpx", "mj2", "aif", "qcp", "odt", "ods", "odp", "xml", "mobi", "heic", "cur", "ktx", "ape", "wv", "dcm", "ics", "glb", "pcap", "dsf", "lnk", "alias", "voc", "ac3", "m4v", "m4p", "m4b", "f4v", "f4p", "f4b", "f4a", "mie", "asf", "ogm", "ogx", "mpc", "arrow", "shp", "aac", "mp1", "it", "s3m", "xm", "skp", "avif", "eps", "lzh", "pgp", "asar", "stl", "chm", "3mf", "zst", "jxl", "vcf", "jls", "pst", "dwg", "parquet", "class", "arj", "cpio", "ace", "avro", "icc", "fbx", "vsdx", "vtt", "apk", "drc", "lz4", "potx", "xltx", "dotx", "xltm", "ott", "ots", "otp", "odg", "otg", "xlsm", "docm", "dotm", "potm", "pptm", "jar", "jmp", "rm", "sav", "ppsm", "ppsx", "tar.gz", "reg", "dat"], Qd = ["image/jpeg", "image/png", "image/gif", "image/webp", "image/flif", "image/x-xcf", "image/x-canon-cr2", "image/x-canon-cr3", "image/tiff", "image/bmp", "image/vnd.ms-photo", "image/vnd.adobe.photoshop", "application/x-indesign", "application/epub+zip", "application/x-xpinstall", "application/vnd.ms-powerpoint.slideshow.macroenabled.12", "application/vnd.oasis.opendocument.text", "application/vnd.oasis.opendocument.spreadsheet", "application/vnd.oasis.opendocument.presentation", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.openxmlformats-officedocument.presentationml.slideshow", "application/zip", "application/x-tar", "application/x-rar-compressed", "application/gzip", "application/x-bzip2", "application/x-7z-compressed", "application/x-apple-diskimage", "application/vnd.apache.arrow.file", "video/mp4", "audio/midi", "video/matroska", "video/webm", "video/quicktime", "video/vnd.avi", "audio/wav", "audio/qcelp", "audio/x-ms-asf", "video/x-ms-asf", "application/vnd.ms-asf", "video/mpeg", "video/3gpp", "audio/mpeg", "audio/mp4", "video/ogg", "audio/ogg", "audio/ogg; codecs=opus", "application/ogg", "audio/flac", "audio/ape", "audio/wavpack", "audio/amr", "application/pdf", "application/x-elf", "application/x-mach-binary", "application/x-msdownload", "application/x-shockwave-flash", "application/rtf", "application/wasm", "font/woff", "font/woff2", "application/vnd.ms-fontobject", "font/ttf", "font/otf", "font/collection", "image/x-icon", "video/x-flv", "application/postscript", "application/eps", "application/x-xz", "application/x-sqlite3", "application/x-nintendo-nes-rom", "application/x-google-chrome-extension", "application/vnd.ms-cab-compressed", "application/x-deb", "application/x-unix-archive", "application/x-rpm", "application/x-compress", "application/x-lzip", "application/x-cfb", "application/x-mie", "application/mxf", "video/mp2t", "application/x-blender", "image/bpg", "image/j2c", "image/jp2", "image/jpx", "image/jpm", "image/mj2", "audio/aiff", "application/xml", "application/x-mobipocket-ebook", "image/heif", "image/heif-sequence", "image/heic", "image/heic-sequence", "image/icns", "image/ktx", "application/dicom", "audio/x-musepack", "text/calendar", "text/vcard", "text/vtt", "model/gltf-binary", "application/vnd.tcpdump.pcap", "audio/x-dsf", "application/x.ms.shortcut", "application/x.apple.alias", "audio/x-voc", "audio/vnd.dolby.dd-raw", "audio/x-m4a", "image/apng", "image/x-olympus-orf", "image/x-sony-arw", "image/x-adobe-dng", "image/x-nikon-nef", "image/x-panasonic-rw2", "image/x-fujifilm-raf", "video/x-m4v", "video/3gpp2", "application/x-esri-shape", "audio/aac", "audio/x-it", "audio/x-s3m", "audio/x-xm", "video/MP1S", "video/MP2P", "application/vnd.sketchup.skp", "image/avif", "application/x-lzh-compressed", "application/pgp-encrypted", "application/x-asar", "model/stl", "application/vnd.ms-htmlhelp", "model/3mf", "image/jxl", "application/zstd", "image/jls", "application/vnd.ms-outlook", "image/vnd.dwg", "application/vnd.apache.parquet", "application/java-vm", "application/x-arj", "application/x-cpio", "application/x-ace-compressed", "application/avro", "application/vnd.iccprofile", "application/x.autodesk.fbx", "application/vnd.visio", "application/vnd.android.package-archive", "application/vnd.google.draco", "application/x-lz4", "application/vnd.openxmlformats-officedocument.presentationml.template", "application/vnd.openxmlformats-officedocument.spreadsheetml.template", "application/vnd.openxmlformats-officedocument.wordprocessingml.template", "application/vnd.ms-excel.template.macroenabled.12", "application/vnd.oasis.opendocument.text-template", "application/vnd.oasis.opendocument.spreadsheet-template", "application/vnd.oasis.opendocument.presentation-template", "application/vnd.oasis.opendocument.graphics", "application/vnd.oasis.opendocument.graphics-template", "application/vnd.ms-excel.sheet.macroenabled.12", "application/vnd.ms-word.document.macroenabled.12", "application/vnd.ms-word.template.macroenabled.12", "application/vnd.ms-powerpoint.template.macroenabled.12", "application/vnd.ms-powerpoint.presentation.macroenabled.12", "application/java-archive", "application/vnd.rn-realmedia", "application/x-spss-sav", "application/x-ms-regedit", "application/x-ft-windows-registry-hive", "application/x-jmp-data"];
});
async function Xd(e11, t10) {
  return new ol(t10).fromBuffer(e11);
}
function il(e11) {
  switch (e11 = e11.toLowerCase(), e11) {
    case "application/epub+zip":
      return { ext: "epub", mime: e11 };
    case "application/vnd.oasis.opendocument.text":
      return { ext: "odt", mime: e11 };
    case "application/vnd.oasis.opendocument.text-template":
      return { ext: "ott", mime: e11 };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return { ext: "ods", mime: e11 };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return { ext: "ots", mime: e11 };
    case "application/vnd.oasis.opendocument.presentation":
      return { ext: "odp", mime: e11 };
    case "application/vnd.oasis.opendocument.presentation-template":
      return { ext: "otp", mime: e11 };
    case "application/vnd.oasis.opendocument.graphics":
      return { ext: "odg", mime: e11 };
    case "application/vnd.oasis.opendocument.graphics-template":
      return { ext: "otg", mime: e11 };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return { ext: "ppsx", mime: e11 };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return { ext: "xlsx", mime: e11 };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return { ext: "xlsm", mime: "application/vnd.ms-excel.sheet.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return { ext: "xltx", mime: e11 };
    case "application/vnd.ms-excel.template.macroenabled":
      return { ext: "xltm", mime: "application/vnd.ms-excel.template.macroenabled.12" };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return { ext: "ppsm", mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return { ext: "docx", mime: e11 };
    case "application/vnd.ms-word.document.macroenabled":
      return { ext: "docm", mime: "application/vnd.ms-word.document.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return { ext: "dotx", mime: e11 };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return { ext: "dotm", mime: "application/vnd.ms-word.template.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return { ext: "potx", mime: e11 };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return { ext: "potm", mime: "application/vnd.ms-powerpoint.template.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return { ext: "pptx", mime: e11 };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return { ext: "pptm", mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12" };
    case "application/vnd.ms-visio.drawing":
      return { ext: "vsdx", mime: "application/vnd.visio" };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return { ext: "3mf", mime: "model/3mf" };
    default:
  }
}
function pn(e11, t10, n10) {
  n10 = { offset: 0, ...n10 };
  for (let [r10, s10] of t10.entries())
    if (n10.mask) {
      if (s10 !== (n10.mask[r10] & e11[r10 + n10.offset]))
        return false;
    } else if (s10 !== e11[r10 + n10.offset])
      return false;
  return true;
}
var sl;
var ol;
var hI;
var dI;
var Yd = I(() => {
  fs2();
  Id();
  zd();
  Hd();
  qd();
  Kd();
  sl = 4100;
  ol = class {
    constructor(t10) {
      this.options = { mpegOffsetTolerance: 0, ...t10 }, this.detectors = [...t10?.customDetectors ?? [], { id: "core", detect: this.detectConfident }, { id: "core.imprecise", detect: this.detectImprecise }], this.tokenizerOptions = { abortSignal: t10?.signal };
    }
    async fromTokenizer(t10) {
      let n10 = t10.position;
      for (let r10 of this.detectors) {
        let s10 = await r10.detect(t10);
        if (s10)
          return s10;
        if (n10 !== t10.position)
          return;
      }
    }
    async fromBuffer(t10) {
      if (!(t10 instanceof Uint8Array || t10 instanceof ArrayBuffer))
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof t10}\``);
      let n10 = t10 instanceof Uint8Array ? t10 : new Uint8Array(t10);
      if (n10?.length > 1)
        return this.fromTokenizer(kd(n10, this.tokenizerOptions));
    }
    async fromBlob(t10) {
      let n10 = vd(t10, this.tokenizerOptions);
      try {
        return await this.fromTokenizer(n10);
      } finally {
        await n10.close();
      }
    }
    async fromStream(t10) {
      let n10 = Nd(t10, this.tokenizerOptions);
      try {
        return await this.fromTokenizer(n10);
      } finally {
        await n10.close();
      }
    }
    async toDetectionStream(t10, n10) {
      let { sampleSize: r10 = sl } = n10, s10, i10, o10 = t10.getReader({ mode: "byob" });
      try {
        let { value: c, done: u } = await o10.read(new Uint8Array(r10));
        if (i10 = c, !u && c)
          try {
            s10 = await this.fromBuffer(c.subarray(0, r10));
          } catch (f10) {
            if (!(f10 instanceof Ue))
              throw f10;
            s10 = void 0;
          }
        i10 = c;
      } finally {
        o10.releaseLock();
      }
      let a = new TransformStream({ async start(c) {
        c.enqueue(i10);
      }, transform(c, u) {
        u.enqueue(c);
      } }), l = t10.pipeThrough(a);
      return l.fileType = s10, l;
    }
    check(t10, n10) {
      return pn(this.buffer, t10, n10);
    }
    checkString(t10, n10) {
      return this.check(jd(t10, n10?.encoding), n10);
    }
    detectConfident = async (t10) => {
      if (this.buffer = new Uint8Array(sl), t10.fileInfo.size === void 0 && (t10.fileInfo.size = Number.MAX_SAFE_INTEGER), this.tokenizer = t10, await t10.peekBuffer(this.buffer, { length: 32, mayBeLess: true }), this.check([66, 77]))
        return { ext: "bmp", mime: "image/bmp" };
      if (this.check([11, 119]))
        return { ext: "ac3", mime: "audio/vnd.dolby.dd-raw" };
      if (this.check([120, 1]))
        return { ext: "dmg", mime: "application/x-apple-diskimage" };
      if (this.check([77, 90]))
        return { ext: "exe", mime: "application/x-msdownload" };
      if (this.check([37, 33]))
        return await t10.peekBuffer(this.buffer, { length: 24, mayBeLess: true }), this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 }) ? { ext: "eps", mime: "application/eps" } : { ext: "ps", mime: "application/postscript" };
      if (this.check([31, 160]) || this.check([31, 157]))
        return { ext: "Z", mime: "application/x-compress" };
      if (this.check([199, 113]))
        return { ext: "cpio", mime: "application/x-cpio" };
      if (this.check([96, 234]))
        return { ext: "arj", mime: "application/x-arj" };
      if (this.check([239, 187, 191]))
        return this.tokenizer.ignore(3), this.detectConfident(t10);
      if (this.check([71, 73, 70]))
        return { ext: "gif", mime: "image/gif" };
      if (this.check([73, 73, 188]))
        return { ext: "jxr", mime: "image/vnd.ms-photo" };
      if (this.check([31, 139, 8])) {
        let r10 = new gs(t10).inflate(), s10 = true;
        try {
          let i10;
          try {
            i10 = await this.fromStream(r10);
          } catch {
            s10 = false;
          }
          if (i10 && i10.ext === "tar")
            return { ext: "tar.gz", mime: "application/gzip" };
        } finally {
          s10 && await r10.cancel();
        }
        return { ext: "gz", mime: "application/gzip" };
      }
      if (this.check([66, 90, 104]))
        return { ext: "bz2", mime: "application/x-bzip2" };
      if (this.checkString("ID3")) {
        await t10.ignore(6);
        let n10 = await t10.readToken(Vd);
        return t10.position + n10 > t10.fileInfo.size ? { ext: "mp3", mime: "audio/mpeg" } : (await t10.ignore(n10), this.fromTokenizer(t10));
      }
      if (this.checkString("MP+"))
        return { ext: "mpc", mime: "audio/x-musepack" };
      if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 }))
        return { ext: "swf", mime: "application/x-shockwave-flash" };
      if (this.check([255, 216, 255]))
        return this.check([247], { offset: 3 }) ? { ext: "jls", mime: "image/jls" } : { ext: "jpg", mime: "image/jpeg" };
      if (this.check([79, 98, 106, 1]))
        return { ext: "avro", mime: "application/avro" };
      if (this.checkString("FLIF"))
        return { ext: "flif", mime: "image/flif" };
      if (this.checkString("8BPS"))
        return { ext: "psd", mime: "image/vnd.adobe.photoshop" };
      if (this.checkString("MPCK"))
        return { ext: "mpc", mime: "audio/x-musepack" };
      if (this.checkString("FORM"))
        return { ext: "aif", mime: "audio/aiff" };
      if (this.checkString("icns", { offset: 0 }))
        return { ext: "icns", mime: "image/icns" };
      if (this.check([80, 75, 3, 4])) {
        let n10;
        return await new ms(t10).unzip((r10) => {
          switch (r10.filename) {
            case "META-INF/mozilla.rsa":
              return n10 = { ext: "xpi", mime: "application/x-xpinstall" }, { stop: true };
            case "META-INF/MANIFEST.MF":
              return n10 = { ext: "jar", mime: "application/java-archive" }, { stop: true };
            case "mimetype":
              return { async handler(s10) {
                let i10 = new TextDecoder("utf-8").decode(s10).trim();
                n10 = il(i10);
              }, stop: true };
            case "[Content_Types].xml":
              return { async handler(s10) {
                let i10 = new TextDecoder("utf-8").decode(s10), o10 = i10.indexOf('.main+xml"');
                if (o10 === -1) {
                  let a = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  i10.includes(`ContentType="${a}"`) && (n10 = il(a));
                } else {
                  i10 = i10.slice(0, Math.max(0, o10));
                  let a = i10.lastIndexOf('"'), l = i10.slice(Math.max(0, a + 1));
                  n10 = il(l);
                }
              }, stop: true };
            default:
              return /classes\d*\.dex/.test(r10.filename) ? (n10 = { ext: "apk", mime: "application/vnd.android.package-archive" }, { stop: true }) : {};
          }
        }).catch((r10) => {
          if (!(r10 instanceof Ue))
            throw r10;
        }), n10 ?? { ext: "zip", mime: "application/zip" };
      }
      if (this.checkString("OggS")) {
        await t10.ignore(28);
        let n10 = new Uint8Array(8);
        return await t10.readBuffer(n10), pn(n10, [79, 112, 117, 115, 72, 101, 97, 100]) ? { ext: "opus", mime: "audio/ogg; codecs=opus" } : pn(n10, [128, 116, 104, 101, 111, 114, 97]) ? { ext: "ogv", mime: "video/ogg" } : pn(n10, [1, 118, 105, 100, 101, 111, 0]) ? { ext: "ogm", mime: "video/ogg" } : pn(n10, [127, 70, 76, 65, 67]) ? { ext: "oga", mime: "audio/ogg" } : pn(n10, [83, 112, 101, 101, 120, 32, 32]) ? { ext: "spx", mime: "audio/ogg" } : pn(n10, [1, 118, 111, 114, 98, 105, 115]) ? { ext: "ogg", mime: "audio/ogg" } : { ext: "ogx", mime: "application/ogg" };
      }
      if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8))
        return { ext: "zip", mime: "application/zip" };
      if (this.checkString("MThd"))
        return { ext: "mid", mime: "audio/midi" };
      if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 })))
        return { ext: "woff", mime: "font/woff" };
      if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 })))
        return { ext: "woff2", mime: "font/woff2" };
      if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212]))
        return { ext: "pcap", mime: "application/vnd.tcpdump.pcap" };
      if (this.checkString("DSD "))
        return { ext: "dsf", mime: "audio/x-dsf" };
      if (this.checkString("LZIP"))
        return { ext: "lz", mime: "application/x-lzip" };
      if (this.checkString("fLaC"))
        return { ext: "flac", mime: "audio/flac" };
      if (this.check([66, 80, 71, 251]))
        return { ext: "bpg", mime: "image/bpg" };
      if (this.checkString("wvpk"))
        return { ext: "wv", mime: "audio/wavpack" };
      if (this.checkString("%PDF"))
        return { ext: "pdf", mime: "application/pdf" };
      if (this.check([0, 97, 115, 109]))
        return { ext: "wasm", mime: "application/wasm" };
      if (this.check([73, 73])) {
        let n10 = await this.readTiffHeader(false);
        if (n10)
          return n10;
      }
      if (this.check([77, 77])) {
        let n10 = await this.readTiffHeader(true);
        if (n10)
          return n10;
      }
      if (this.checkString("MAC "))
        return { ext: "ape", mime: "audio/ape" };
      if (this.check([26, 69, 223, 163])) {
        async function n10() {
          let a = await t10.peekNumber(dd), l = 128, c = 0;
          for (; (a & l) === 0 && l !== 0; )
            ++c, l >>= 1;
          let u = new Uint8Array(c + 1);
          return await t10.readBuffer(u), u;
        }
        async function r10() {
          let a = await n10(), l = await n10();
          l[0] ^= 128 >> l.length - 1;
          let c = Math.min(6, l.length), u = new DataView(a.buffer), f10 = new DataView(l.buffer, l.length - c, c);
          return { id: rl(u), len: rl(f10) };
        }
        async function s10(a) {
          for (; a > 0; ) {
            let l = await r10();
            if (l.id === 17026)
              return (await t10.readToken(new It(l.len))).replaceAll(/\00.*$/g, "");
            await t10.ignore(l.len), --a;
          }
        }
        let i10 = await r10();
        switch (await s10(i10.len)) {
          case "webm":
            return { ext: "webm", mime: "video/webm" };
          case "matroska":
            return { ext: "mkv", mime: "video/matroska" };
          default:
            return;
        }
      }
      if (this.checkString("SQLi"))
        return { ext: "sqlite", mime: "application/x-sqlite3" };
      if (this.check([78, 69, 83, 26]))
        return { ext: "nes", mime: "application/x-nintendo-nes-rom" };
      if (this.checkString("Cr24"))
        return { ext: "crx", mime: "application/x-google-chrome-extension" };
      if (this.checkString("MSCF") || this.checkString("ISc("))
        return { ext: "cab", mime: "application/vnd.ms-cab-compressed" };
      if (this.check([237, 171, 238, 219]))
        return { ext: "rpm", mime: "application/x-rpm" };
      if (this.check([197, 208, 211, 198]))
        return { ext: "eps", mime: "application/eps" };
      if (this.check([40, 181, 47, 253]))
        return { ext: "zst", mime: "application/zstd" };
      if (this.check([127, 69, 76, 70]))
        return { ext: "elf", mime: "application/x-elf" };
      if (this.check([33, 66, 68, 78]))
        return { ext: "pst", mime: "application/vnd.ms-outlook" };
      if (this.checkString("PAR1") || this.checkString("PARE"))
        return { ext: "parquet", mime: "application/vnd.apache.parquet" };
      if (this.checkString("ttcf"))
        return { ext: "ttc", mime: "font/collection" };
      if (this.check([207, 250, 237, 254]))
        return { ext: "macho", mime: "application/x-mach-binary" };
      if (this.check([4, 34, 77, 24]))
        return { ext: "lz4", mime: "application/x-lz4" };
      if (this.checkString("regf"))
        return { ext: "dat", mime: "application/x-ft-windows-registry-hive" };
      if (this.checkString("$FL2") || this.checkString("$FL3"))
        return { ext: "sav", mime: "application/x-spss-sav" };
      if (this.check([79, 84, 84, 79, 0]))
        return { ext: "otf", mime: "font/otf" };
      if (this.checkString("#!AMR"))
        return { ext: "amr", mime: "audio/amr" };
      if (this.checkString("{\\rtf"))
        return { ext: "rtf", mime: "application/rtf" };
      if (this.check([70, 76, 86, 1]))
        return { ext: "flv", mime: "video/x-flv" };
      if (this.checkString("IMPM"))
        return { ext: "it", mime: "audio/x-it" };
      if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 }))
        return { ext: "lzh", mime: "application/x-lzh-compressed" };
      if (this.check([0, 0, 1, 186])) {
        if (this.check([33], { offset: 4, mask: [241] }))
          return { ext: "mpg", mime: "video/MP1S" };
        if (this.check([68], { offset: 4, mask: [196] }))
          return { ext: "mpg", mime: "video/MP2P" };
      }
      if (this.checkString("ITSF"))
        return { ext: "chm", mime: "application/vnd.ms-htmlhelp" };
      if (this.check([202, 254, 186, 190]))
        return { ext: "class", mime: "application/java-vm" };
      if (this.checkString(".RMF"))
        return { ext: "rm", mime: "application/vnd.rn-realmedia" };
      if (this.checkString("DRACO"))
        return { ext: "drc", mime: "application/vnd.google.draco" };
      if (this.check([253, 55, 122, 88, 90, 0]))
        return { ext: "xz", mime: "application/x-xz" };
      if (this.checkString("<?xml "))
        return { ext: "xml", mime: "application/xml" };
      if (this.check([55, 122, 188, 175, 39, 28]))
        return { ext: "7z", mime: "application/x-7z-compressed" };
      if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1))
        return { ext: "rar", mime: "application/x-rar-compressed" };
      if (this.checkString("solid "))
        return { ext: "stl", mime: "model/stl" };
      if (this.checkString("AC")) {
        let n10 = new It(4, "latin1").get(this.buffer, 2);
        if (n10.match("^d*") && n10 >= 1e3 && n10 <= 1050)
          return { ext: "dwg", mime: "image/vnd.dwg" };
      }
      if (this.checkString("070707"))
        return { ext: "cpio", mime: "application/x-cpio" };
      if (this.checkString("BLENDER"))
        return { ext: "blend", mime: "application/x-blender" };
      if (this.checkString("!<arch>"))
        return await t10.ignore(8), await t10.readToken(new It(13, "ascii")) === "debian-binary" ? { ext: "deb", mime: "application/x-deb" } : { ext: "ar", mime: "application/x-unix-archive" };
      if (this.checkString("WEBVTT") && [`
`, "\r", "	", " ", "\0"].some((n10) => this.checkString(n10, { offset: 6 })))
        return { ext: "vtt", mime: "text/vtt" };
      if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
        await t10.ignore(8);
        async function n10() {
          return { length: await t10.readToken(gd), type: await t10.readToken(new It(4, "latin1")) };
        }
        do {
          let r10 = await n10();
          if (r10.length < 0)
            return;
          switch (r10.type) {
            case "IDAT":
              return { ext: "png", mime: "image/png" };
            case "acTL":
              return { ext: "apng", mime: "image/apng" };
            default:
              await t10.ignore(r10.length + 4);
          }
        } while (t10.position + 8 < t10.fileInfo.size);
        return { ext: "png", mime: "image/png" };
      }
      if (this.check([65, 82, 82, 79, 87, 49, 0, 0]))
        return { ext: "arrow", mime: "application/vnd.apache.arrow.file" };
      if (this.check([103, 108, 84, 70, 2, 0, 0, 0]))
        return { ext: "glb", mime: "model/gltf-binary" };
      if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 }))
        return { ext: "mov", mime: "video/quicktime" };
      if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24]))
        return { ext: "orf", mime: "image/x-olympus-orf" };
      if (this.checkString("gimp xcf "))
        return { ext: "xcf", mime: "image/x-xcf" };
      if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
        let n10 = new It(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
        switch (n10) {
          case "avif":
          case "avis":
            return { ext: "avif", mime: "image/avif" };
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B":
            return { ext: "f4b", mime: "audio/mp4" };
          case "crx":
            return { ext: "cr3", mime: "image/x-canon-cr3" };
          default:
            return n10.startsWith("3g") ? n10.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (this.checkString(`REGEDIT4\r
`))
        return { ext: "reg", mime: "application/x-ms-regedit" };
      if (this.check([82, 73, 70, 70])) {
        if (this.checkString("WEBP", { offset: 8 }))
          return { ext: "webp", mime: "image/webp" };
        if (this.check([65, 86, 73], { offset: 8 }))
          return { ext: "avi", mime: "video/vnd.avi" };
        if (this.check([87, 65, 86, 69], { offset: 8 }))
          return { ext: "wav", mime: "audio/wav" };
        if (this.check([81, 76, 67, 77], { offset: 8 }))
          return { ext: "qcp", mime: "audio/qcelp" };
      }
      if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
        return { ext: "rw2", mime: "image/x-panasonic-rw2" };
      if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        async function n10() {
          let r10 = new Uint8Array(16);
          return await t10.readBuffer(r10), { id: r10, size: Number(await t10.readToken(yd)) };
        }
        for (await t10.ignore(30); t10.position + 24 < t10.fileInfo.size; ) {
          let r10 = await n10(), s10 = r10.size - 24;
          if (pn(r10.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
            let i10 = new Uint8Array(16);
            if (s10 -= await t10.readBuffer(i10), pn(i10, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
              return { ext: "asf", mime: "audio/x-ms-asf" };
            if (pn(i10, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
              return { ext: "asf", mime: "video/x-ms-asf" };
            break;
          }
          await t10.ignore(s10);
        }
        return { ext: "asf", mime: "application/vnd.ms-asf" };
      }
      if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
        return { ext: "ktx", mime: "image/ktx" };
      if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 }))
        return { ext: "mie", mime: "application/x-mie" };
      if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
        return { ext: "shp", mime: "application/x-esri-shape" };
      if (this.check([255, 79, 255, 81]))
        return { ext: "j2c", mime: "image/j2c" };
      if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10]))
        switch (await t10.ignore(20), await t10.readToken(new It(4, "ascii"))) {
          case "jp2 ":
            return { ext: "jp2", mime: "image/jp2" };
          case "jpx ":
            return { ext: "jpx", mime: "image/jpx" };
          case "jpm ":
            return { ext: "jpm", mime: "image/jpm" };
          case "mjp2":
            return { ext: "mj2", mime: "image/mj2" };
          default:
            return;
        }
      if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10]))
        return { ext: "jxl", mime: "image/jxl" };
      if (this.check([254, 255]))
        return this.checkString("<?xml ", { offset: 2, encoding: "utf-16be" }) ? { ext: "xml", mime: "application/xml" } : void 0;
      if (this.check([208, 207, 17, 224, 161, 177, 26, 225]))
        return { ext: "cfb", mime: "application/x-cfb" };
      if (await t10.peekBuffer(this.buffer, { length: Math.min(256, t10.fileInfo.size), mayBeLess: true }), this.check([97, 99, 115, 112], { offset: 36 }))
        return { ext: "icc", mime: "application/vnd.iccprofile" };
      if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 }))
        return { ext: "ace", mime: "application/x-ace-compressed" };
      if (this.checkString("BEGIN:")) {
        if (this.checkString("VCARD", { offset: 6 }))
          return { ext: "vcf", mime: "text/vcard" };
        if (this.checkString("VCALENDAR", { offset: 6 }))
          return { ext: "ics", mime: "text/calendar" };
      }
      if (this.checkString("FUJIFILMCCD-RAW"))
        return { ext: "raf", mime: "image/x-fujifilm-raf" };
      if (this.checkString("Extended Module:"))
        return { ext: "xm", mime: "audio/x-xm" };
      if (this.checkString("Creative Voice File"))
        return { ext: "voc", mime: "audio/x-voc" };
      if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
        let n10 = new DataView(this.buffer.buffer).getUint32(12, true);
        if (n10 > 12 && this.buffer.length >= n10 + 16)
          try {
            let r10 = new TextDecoder().decode(this.buffer.subarray(16, n10 + 16));
            if (JSON.parse(r10).files)
              return { ext: "asar", mime: "application/x-asar" };
          } catch {
          }
      }
      if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
        return { ext: "mxf", mime: "application/mxf" };
      if (this.checkString("SCRM", { offset: 44 }))
        return { ext: "s3m", mime: "audio/x-s3m" };
      if (this.check([71]) && this.check([71], { offset: 188 }))
        return { ext: "mts", mime: "video/mp2t" };
      if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 }))
        return { ext: "mts", mime: "video/mp2t" };
      if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
        return { ext: "mobi", mime: "application/x-mobipocket-ebook" };
      if (this.check([68, 73, 67, 77], { offset: 128 }))
        return { ext: "dcm", mime: "application/dicom" };
      if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70]))
        return { ext: "lnk", mime: "application/x.ms.shortcut" };
      if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0]))
        return { ext: "alias", mime: "application/x.apple.alias" };
      if (this.checkString("Kaydara FBX Binary  \0"))
        return { ext: "fbx", mime: "application/x.autodesk.fbx" };
      if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 })))
        return { ext: "eot", mime: "application/vnd.ms-fontobject" };
      if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29]))
        return { ext: "indd", mime: "application/x-indesign" };
      if (this.check([255, 255, 0, 0, 7, 0, 0, 0, 4, 0, 0, 0, 1, 0, 1, 0]) || this.check([0, 0, 255, 255, 0, 0, 0, 7, 0, 0, 0, 4, 0, 1, 0, 1]))
        return { ext: "jmp", mime: "application/x-jmp-data" };
      if (await t10.peekBuffer(this.buffer, { length: Math.min(512, t10.fileInfo.size), mayBeLess: true }), this.checkString("ustar", { offset: 257 }) && (this.checkString("\0", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && Gd(this.buffer))
        return { ext: "tar", mime: "application/x-tar" };
      if (this.check([255, 254])) {
        let n10 = "utf-16le";
        return this.checkString("<?xml ", { offset: 2, encoding: n10 }) ? { ext: "xml", mime: "application/xml" } : this.check([255, 14], { offset: 2 }) && this.checkString("SketchUp Model", { offset: 4, encoding: n10 }) ? { ext: "skp", mime: "application/vnd.sketchup.skp" } : this.checkString(`Windows Registry Editor Version 5.00\r
`, { offset: 2, encoding: n10 }) ? { ext: "reg", mime: "application/x-ms-regedit" } : void 0;
      }
      if (this.checkString("-----BEGIN PGP MESSAGE-----"))
        return { ext: "pgp", mime: "application/pgp-encrypted" };
    };
    detectImprecise = async (t10) => {
      if (this.buffer = new Uint8Array(sl), await t10.peekBuffer(this.buffer, { length: Math.min(8, t10.fileInfo.size), mayBeLess: true }), this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179]))
        return { ext: "mpg", mime: "video/mpeg" };
      if (this.check([0, 1, 0, 0, 0]))
        return { ext: "ttf", mime: "font/ttf" };
      if (this.check([0, 0, 1, 0]))
        return { ext: "ico", mime: "image/x-icon" };
      if (this.check([0, 0, 2, 0]))
        return { ext: "cur", mime: "image/x-icon" };
      if (await t10.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, t10.fileInfo.size), mayBeLess: true }), this.buffer.length >= 2 + this.options.mpegOffsetTolerance)
        for (let n10 = 0; n10 <= this.options.mpegOffsetTolerance; ++n10) {
          let r10 = this.scanMpeg(n10);
          if (r10)
            return r10;
        }
    };
    async readTiffTag(t10) {
      let n10 = await this.tokenizer.readToken(t10 ? vr : Ge);
      switch (this.tokenizer.ignore(10), n10) {
        case 50341:
          return { ext: "arw", mime: "image/x-sony-arw" };
        case 50706:
          return { ext: "dng", mime: "image/x-adobe-dng" };
        default:
      }
    }
    async readTiffIFD(t10) {
      let n10 = await this.tokenizer.readToken(t10 ? vr : Ge);
      for (let r10 = 0; r10 < n10; ++r10) {
        let s10 = await this.readTiffTag(t10);
        if (s10)
          return s10;
      }
    }
    async readTiffHeader(t10) {
      let n10 = (t10 ? vr : Ge).get(this.buffer, 2), r10 = (t10 ? md : Qe).get(this.buffer, 4);
      if (n10 === 42) {
        if (r10 >= 6) {
          if (this.checkString("CR", { offset: 8 }))
            return { ext: "cr2", mime: "image/x-canon-cr2" };
          if (r10 >= 8) {
            let i10 = (t10 ? vr : Ge).get(this.buffer, 8), o10 = (t10 ? vr : Ge).get(this.buffer, 10);
            if (i10 === 28 && o10 === 254 || i10 === 31 && o10 === 11)
              return { ext: "nef", mime: "image/x-nikon-nef" };
          }
        }
        return await this.tokenizer.ignore(r10), await this.readTiffIFD(t10) ?? { ext: "tif", mime: "image/tiff" };
      }
      if (n10 === 43)
        return { ext: "tif", mime: "image/tiff" };
    }
    scanMpeg(t10) {
      if (this.check([255, 224], { offset: t10, mask: [255, 224] })) {
        if (this.check([16], { offset: t10 + 1, mask: [22] }))
          return this.check([8], { offset: t10 + 1, mask: [8] }) ? { ext: "aac", mime: "audio/aac" } : { ext: "aac", mime: "audio/aac" };
        if (this.check([2], { offset: t10 + 1, mask: [6] }))
          return { ext: "mp3", mime: "audio/mpeg" };
        if (this.check([4], { offset: t10 + 1, mask: [6] }))
          return { ext: "mp2", mime: "audio/mpeg" };
        if (this.check([6], { offset: t10 + 1, mask: [6] }))
          return { ext: "mp1", mime: "audio/mpeg" };
      }
    }
  }, hI = new Set(Zd), dI = new Set(Qd);
});
var Jd = {};
Q(Jd, { fileCommand: () => mw, flagsForFuzzing: () => gw });
function fw(e11, t10) {
  let n10 = uw.get(e11);
  if (n10)
    return n10;
  let [r10, s10] = t10.split("/"), i10 = s10?.split("+")[0]?.replace(/-/g, " ") || e11;
  switch (r10) {
    case "image":
      return `${i10.toUpperCase()} image data`;
    case "audio":
      return `${i10.toUpperCase()} audio`;
    case "video":
      return `${i10.toUpperCase()} video`;
    case "font":
      return `${i10} font`;
    case "model":
      return `${i10} 3D model`;
    case "application":
      return s10?.includes("zip") || s10?.includes("compressed") ? `${i10} archive data` : s10?.includes("executable") ? `${i10} executable` : `${e11.toUpperCase()} data`;
    default:
      return `${e11.toUpperCase()} data`;
  }
}
function pw(e11) {
  let t10 = e11.split("/").pop() || e11;
  if (t10.startsWith(".") && !t10.includes(".", 1))
    return t10;
  let n10 = t10.lastIndexOf(".");
  return n10 === -1 || n10 === 0 ? "" : t10.slice(n10).toLowerCase();
}
function hw(e11, t10) {
  if (e11.startsWith("#!")) {
    let c = e11.split(`
`)[0];
    return c.includes("python") ? { description: "Python script, ASCII text executable", mime: "text/x-python" } : c.includes("node") || c.includes("bun") || c.includes("deno") ? { description: "JavaScript script, ASCII text executable", mime: "text/javascript" } : c.includes("bash") ? { description: "Bourne-Again shell script, ASCII text executable", mime: "text/x-shellscript" } : c.includes("sh") ? { description: "POSIX shell script, ASCII text executable", mime: "text/x-shellscript" } : c.includes("ruby") ? { description: "Ruby script, ASCII text executable", mime: "text/x-ruby" } : c.includes("perl") ? { description: "Perl script, ASCII text executable", mime: "text/x-perl" } : { description: "script, ASCII text executable", mime: "text/plain" };
  }
  let n10 = e11.trimStart();
  if (n10.startsWith("<?xml"))
    return { description: "XML document", mime: "application/xml" };
  if (n10.startsWith("<!DOCTYPE html") || n10.toLowerCase().startsWith("<html"))
    return { description: "HTML document", mime: "text/html" };
  let r10 = e11.includes(`\r
`), s10 = e11.includes("\r") && !r10, i10 = "";
  r10 ? i10 = ", with CRLF line terminators" : s10 && (i10 = ", with CR line terminators");
  let o10 = pw(t10), a = o10 ? cw.get(o10) : void 0;
  if (a)
    return a.mime.startsWith("text/") && i10 ? { description: `${a.description}${i10}`, mime: a.mime } : a;
  let l = false;
  for (let c = 0; c < Math.min(e11.length, 8192); c++)
    if (e11.charCodeAt(c) > 127) {
      l = true;
      break;
    }
  return l ? { description: `UTF-8 Unicode text${i10}`, mime: "text/plain; charset=utf-8" } : { description: `ASCII text${i10}`, mime: "text/plain" };
}
async function dw(e11, t10) {
  if (t10.length === 0)
    return { description: "empty", mime: "inode/x-empty" };
  let n10 = await Xd(t10);
  if (n10)
    return { description: fw(n10.ext, n10.mime), mime: n10.mime };
  let r10 = new TextDecoder("utf-8", { fatal: false }).decode(t10);
  return hw(r10, e11);
}
var lw;
var cw;
var uw;
var mw;
var gw;
var e0 = I(() => {
  "use strict";
  Yd();
  se();
  lw = { name: "file", summary: "determine file type", usage: "file [OPTION]... FILE...", options: ["-b, --brief          do not prepend filenames to output", "-i, --mime           output MIME type strings", "-L, --dereference    follow symlinks", "    --help           display this help and exit"] }, cw = /* @__PURE__ */ new Map([[".js", { description: "JavaScript source", mime: "text/javascript" }], [".mjs", { description: "JavaScript module", mime: "text/javascript" }], [".cjs", { description: "CommonJS module", mime: "text/javascript" }], [".ts", { description: "TypeScript source", mime: "text/typescript" }], [".tsx", { description: "TypeScript JSX source", mime: "text/typescript" }], [".jsx", { description: "JavaScript JSX source", mime: "text/javascript" }], [".py", { description: "Python script", mime: "text/x-python" }], [".rb", { description: "Ruby script", mime: "text/x-ruby" }], [".go", { description: "Go source", mime: "text/x-go" }], [".rs", { description: "Rust source", mime: "text/x-rust" }], [".c", { description: "C source", mime: "text/x-c" }], [".h", { description: "C header", mime: "text/x-c" }], [".cpp", { description: "C++ source", mime: "text/x-c++" }], [".hpp", { description: "C++ header", mime: "text/x-c++" }], [".java", { description: "Java source", mime: "text/x-java" }], [".sh", { description: "Bourne-Again shell script", mime: "text/x-shellscript" }], [".bash", { description: "Bourne-Again shell script", mime: "text/x-shellscript" }], [".zsh", { description: "Zsh shell script", mime: "text/x-shellscript" }], [".json", { description: "JSON data", mime: "application/json" }], [".yaml", { description: "YAML data", mime: "text/yaml" }], [".yml", { description: "YAML data", mime: "text/yaml" }], [".xml", { description: "XML document", mime: "application/xml" }], [".csv", { description: "CSV text", mime: "text/csv" }], [".toml", { description: "TOML data", mime: "text/toml" }], [".html", { description: "HTML document", mime: "text/html" }], [".htm", { description: "HTML document", mime: "text/html" }], [".css", { description: "CSS stylesheet", mime: "text/css" }], [".svg", { description: "SVG image", mime: "image/svg+xml" }], [".md", { description: "Markdown document", mime: "text/markdown" }], [".markdown", { description: "Markdown document", mime: "text/markdown" }], [".txt", { description: "ASCII text", mime: "text/plain" }], [".rst", { description: "reStructuredText", mime: "text/x-rst" }], [".env", { description: "ASCII text", mime: "text/plain" }], [".gitignore", { description: "ASCII text", mime: "text/plain" }], [".dockerignore", { description: "ASCII text", mime: "text/plain" }]]), uw = /* @__PURE__ */ new Map([["jpg", "JPEG image data"], ["jpeg", "JPEG image data"], ["png", "PNG image data"], ["gif", "GIF image data"], ["webp", "WebP image data"], ["bmp", "PC bitmap"], ["ico", "MS Windows icon resource"], ["tif", "TIFF image data"], ["tiff", "TIFF image data"], ["psd", "Adobe Photoshop Document"], ["avif", "AVIF image"], ["heic", "HEIC image"], ["heif", "HEIF image"], ["jxl", "JPEG XL image"], ["icns", "Mac OS X icon"], ["svg", "SVG Scalable Vector Graphics image"], ["pdf", "PDF document"], ["epub", "EPUB document"], ["mobi", "Mobipocket E-book"], ["djvu", "DjVu document"], ["zip", "Zip archive data"], ["gz", "gzip compressed data"], ["gzip", "gzip compressed data"], ["bz2", "bzip2 compressed data"], ["xz", "XZ compressed data"], ["tar", "POSIX tar archive"], ["rar", "RAR archive data"], ["7z", "7-zip archive data"], ["lz", "lzip compressed data"], ["lzma", "LZMA compressed data"], ["zst", "Zstandard compressed data"], ["cab", "Microsoft Cabinet archive"], ["ar", "Unix ar archive"], ["rpm", "RPM package"], ["deb", "Debian binary package"], ["apk", "Android Package"], ["dmg", "Apple disk image"], ["iso", "ISO 9660 CD-ROM filesystem data"], ["vhd", "Microsoft Virtual Hard Disk"], ["vhdx", "Microsoft Virtual Hard Disk (new format)"], ["qcow2", "QEMU QCOW Image"], ["mp3", "Audio file with ID3"], ["m4a", "MPEG-4 audio"], ["aac", "AAC audio"], ["wav", "RIFF (little-endian) data, WAVE audio"], ["flac", "FLAC audio bitstream data"], ["ogg", "Ogg data"], ["oga", "Ogg audio"], ["opus", "Ogg Opus audio"], ["aiff", "AIFF audio"], ["wma", "Windows Media Audio"], ["amr", "AMR audio"], ["mid", "MIDI audio"], ["midi", "MIDI audio"], ["ape", "Monkey's Audio"], ["mp4", "ISO Media, MPEG-4"], ["m4v", "MPEG-4 video"], ["webm", "WebM"], ["avi", "RIFF (little-endian) data, AVI"], ["mov", "ISO Media, Apple QuickTime movie"], ["mkv", "Matroska data"], ["wmv", "Windows Media Video"], ["flv", "Flash Video"], ["3gp", "3GPP multimedia"], ["3g2", "3GPP2 multimedia"], ["ogv", "Ogg video"], ["mts", "MPEG transport stream"], ["m2ts", "MPEG transport stream"], ["ts", "MPEG transport stream"], ["mpg", "MPEG video"], ["mpeg", "MPEG video"], ["exe", "PE32 executable"], ["dll", "PE32 DLL"], ["elf", "ELF executable"], ["mach", "Mach-O executable"], ["wasm", "WebAssembly (wasm) binary module"], ["dex", "Android Dalvik executable"], ["class", "Java class file"], ["swf", "Adobe Flash"], ["doc", "Microsoft Word Document"], ["docx", "Microsoft Word 2007+ Document"], ["xls", "Microsoft Excel Spreadsheet"], ["xlsx", "Microsoft Excel 2007+ Spreadsheet"], ["ppt", "Microsoft PowerPoint Presentation"], ["pptx", "Microsoft PowerPoint 2007+ Presentation"], ["odt", "OpenDocument Text"], ["ods", "OpenDocument Spreadsheet"], ["odp", "OpenDocument Presentation"], ["ttf", "TrueType Font"], ["otf", "OpenType Font"], ["woff", "Web Open Font Format"], ["woff2", "Web Open Font Format 2"], ["eot", "Embedded OpenType font"], ["stl", "Stereolithography CAD"], ["obj", "Wavefront 3D Object"], ["gltf", "GL Transmission Format"], ["glb", "GL Transmission Format (binary)"], ["sqlite", "SQLite 3.x database"], ["mdb", "Microsoft Access Database"], ["xml", "XML document"], ["json", "JSON data"], ["macho", "Mach-O binary"], ["ics", "iCalendar data"], ["vcf", "vCard data"], ["msi", "Microsoft Installer"], ["ps", "PostScript"], ["ai", "Adobe Illustrator"], ["indd", "Adobe InDesign"], ["sketch", "Sketch design file"], ["fig", "Figma design file"], ["xd", "Adobe XD"], ["blend", "Blender"], ["fbx", "Autodesk FBX"], ["lnk", "MS Windows shortcut"], ["alias", "Mac OS alias"], ["torrent", "BitTorrent file"], ["pcap", "pcap capture file"], ["arrow", "Apache Arrow"], ["parquet", "Apache Parquet"]]);
  mw = { name: "file", async execute(e11, t10) {
    if (U2(e11))
      return M(lw);
    let n10 = false, r10 = false, s10 = [];
    for (let a of e11)
      if (a.startsWith("--")) {
        if (a === "--brief")
          n10 = true;
        else if (a === "--mime" || a === "--mime-type")
          r10 = true;
        else if (a !== "--dereference")
          return Y("file", a);
      } else if (a.startsWith("-") && a !== "-") {
        for (let l of a.slice(1))
          if (l === "b")
            n10 = true;
          else if (l === "i")
            r10 = true;
          else if (l !== "L")
            return Y("file", `-${l}`);
      } else
        s10.push(a);
    if (s10.length === 0)
      return { stdout: "", stderr: `Usage: file [-bLi] FILE...
`, exitCode: 1 };
    let i10 = "", o10 = 0;
    for (let a of s10)
      try {
        let l = t10.fs.resolvePath(t10.cwd, a);
        if ((await t10.fs.stat(l)).isDirectory) {
          let h = r10 ? "inode/directory" : "directory";
          i10 += n10 ? `${h}
` : `${a}: ${h}
`;
          continue;
        }
        let u = await t10.fs.readFileBuffer(l), f10 = await dw(a, u), p = r10 ? f10.mime : f10.description;
        i10 += n10 ? `${p}
` : `${a}: ${p}
`;
      } catch {
        i10 += n10 ? `cannot open
` : `${a}: cannot open (No such file or directory)
`, o10 = 1;
      }
    return { stdout: i10, stderr: "", exitCode: o10 };
  } }, gw = { name: "file", flags: [{ flag: "-b", type: "boolean" }, { flag: "-i", type: "boolean" }, { flag: "-L", type: "boolean" }], needsArgs: true };
});
var t0 = {};
Q(t0, { flagsForFuzzing: () => xw, htmlToMarkdownCommand: () => bw });
var ww;
var bw;
var xw;
var n0 = I(() => {
  "use strict";
  se();
  ww = { name: "html-to-markdown", summary: "convert HTML to Markdown (BashEnv extension)", usage: "html-to-markdown [OPTION]... [FILE]", description: ["Convert HTML content to Markdown format using the turndown library.", "This is a non-standard BashEnv extension command, not available in regular bash.", "", "Read HTML from FILE or standard input and output Markdown to standard output.", "Commonly used with curl to convert web pages:", "  curl -s https://example.com | html-to-markdown", "", "Supported HTML elements:", "  - Headings (h1-h6) \u2192 # Markdown headings", "  - Paragraphs (p) \u2192 Plain text with blank lines", "  - Links (a) \u2192 [text](url)", "  - Images (img) \u2192 ![alt](src)", "  - Bold/Strong \u2192 **text**", "  - Italic/Em \u2192 _text_", "  - Code (code, pre) \u2192 `inline` or fenced blocks", "  - Lists (ul, ol, li) \u2192 - or 1. items", "  - Blockquotes \u2192 > quoted text", "  - Horizontal rules (hr) \u2192 ---"], options: ["-b, --bullet=CHAR     bullet character for unordered lists (-, +, or *)", "-c, --code=FENCE      fence style for code blocks (``` or ~~~)", "-r, --hr=STRING       string for horizontal rules (default: ---)", "    --heading-style=STYLE", "                      heading style: 'atx' for # headings (default),", "                      'setext' for underlined headings (h1/h2 only)", "    --help            display this help and exit"], examples: ["echo '<h1>Hello</h1><p>World</p>' | html-to-markdown", "html-to-markdown page.html", "curl -s https://example.com | html-to-markdown > page.md"] }, bw = { name: "html-to-markdown", async execute(e11, t10) {
    if (U2(e11))
      return M(ww);
    let n10 = "-", r10 = "```", s10 = "---", i10 = "atx", o10 = [];
    for (let l = 0; l < e11.length; l++) {
      let c = e11[l];
      if (c === "-b" || c === "--bullet")
        n10 = e11[++l] ?? "-";
      else if (c.startsWith("--bullet="))
        n10 = c.slice(9);
      else if (c === "-c" || c === "--code")
        r10 = e11[++l] ?? "```";
      else if (c.startsWith("--code="))
        r10 = c.slice(7);
      else if (c === "-r" || c === "--hr")
        s10 = e11[++l] ?? "---";
      else if (c.startsWith("--hr="))
        s10 = c.slice(5);
      else if (c.startsWith("--heading-style=")) {
        let u = c.slice(16);
        (u === "setext" || u === "atx") && (i10 = u);
      } else if (c === "-")
        o10.push("-");
      else {
        if (c.startsWith("--"))
          return Y("html-to-markdown", c);
        if (c.startsWith("-"))
          return Y("html-to-markdown", c);
        o10.push(c);
      }
    }
    let a;
    if (o10.length === 0 || o10.length === 1 && o10[0] === "-")
      a = t10.stdin;
    else
      try {
        let l = t10.fs.resolvePath(t10.cwd, o10[0]);
        a = await t10.fs.readFile(l);
      } catch {
        return { stdout: "", stderr: `html-to-markdown: ${o10[0]}: No such file or directory
`, exitCode: 1 };
      }
    if (!a.trim())
      return { stdout: "", stderr: "", exitCode: 0 };
    try {
      let l = new turndown_browser_es_default({ bulletListMarker: n10, codeBlockStyle: "fenced", fence: r10, hr: s10, headingStyle: i10 });
      return l.remove(["script", "style", "footer"]), { stdout: `${l.turndown(a).trim()}
`, stderr: "", exitCode: 0 };
    } catch (l) {
      return { stdout: "", stderr: `html-to-markdown: conversion error: ${l.message}
`, exitCode: 1 };
    }
  } }, xw = { name: "html-to-markdown", flags: [], stdinType: "text" };
});
var r0 = {};
Q(r0, { flagsForFuzzing: () => Cw, helpCommand: () => Sw });
function Aw(e11) {
  let t10 = [], n10 = new Set(e11);
  t10.push(`Available commands:
`);
  let r10 = [];
  for (let [s10, i10] of Ew) {
    let o10 = i10.filter((a) => n10.has(a));
    if (o10.length > 0) {
      t10.push(`  ${s10}:`), t10.push(`    ${o10.join(", ")}
`);
      for (let a of o10)
        n10.delete(a);
    }
  }
  for (let s10 of n10)
    r10.push(s10);
  return r10.length > 0 && (t10.push("  Other:"), t10.push(`    ${r10.sort().join(", ")}
`)), t10.push("Use '<command> --help' for details on a specific command."), `${t10.join(`
`)}
`;
}
var Ew;
var Sw;
var Cw;
var s0 = I(() => {
  "use strict";
  Ew = /* @__PURE__ */ new Map([["File operations", ["ls", "cat", "head", "tail", "wc", "touch", "mkdir", "rm", "cp", "mv", "ln", "chmod", "stat", "readlink"]], ["Text processing", ["grep", "sed", "awk", "sort", "uniq", "cut", "tr", "tee", "diff"]], ["Search", ["find"]], ["Navigation & paths", ["pwd", "basename", "dirname", "tree", "du"]], ["Environment & shell", ["echo", "printf", "env", "printenv", "export", "alias", "unalias", "history", "clear", "true", "false", "bash", "sh"]], ["Data processing", ["xargs", "jq", "base64", "date"]], ["Network", ["curl", "html-to-markdown"]]]);
  Sw = { name: "help", async execute(e11, t10) {
    if (e11.includes("--help") || e11.includes("-h"))
      return { stdout: `help - display available commands

Usage: help [command]

Options:
  -h, --help    Show this help message

If a command name is provided, shows help for that command.
Otherwise, lists all available commands.
`, stderr: "", exitCode: 0 };
    if (e11.length > 0 && t10.exec) {
      let r10 = e11[0];
      return t10.exec(`${r10} --help`, { cwd: t10.cwd });
    }
    let n10 = t10.getRegisteredCommands?.() ?? [];
    return { stdout: Aw(n10), stderr: "", exitCode: 0 };
  } }, Cw = { name: "help", flags: [] };
});
var i0 = {};
Q(i0, { flagsForFuzzing: () => Iw, whichCommand: () => vw });
var Nw;
var kw2;
var vw;
var Iw;
var o0 = I(() => {
  "use strict";
  qe();
  se();
  Nw = { name: "which", summary: "locate a command", usage: "which [-as] program ...", options: ["-a         List all instances of executables found", "-s         No output, just return 0 if found, 1 if not", "--help     display this help and exit"] }, kw2 = { showAll: { short: "a", type: "boolean" }, silent: { short: "s", type: "boolean" } }, vw = { name: "which", async execute(e11, t10) {
    if (U2(e11))
      return M(Nw);
    let n10 = be("which", e11, kw2);
    if (!n10.ok)
      return n10.error;
    let r10 = n10.result.flags.showAll, s10 = n10.result.flags.silent, i10 = n10.result.positional;
    if (i10.length === 0)
      return { stdout: "", stderr: "", exitCode: 1 };
    let a = (t10.env.get("PATH") || "/usr/bin:/bin").split(":"), l = "", c = true;
    for (let u of i10) {
      let f10 = false;
      for (let p of a) {
        if (!p)
          continue;
        let h = `${p}/${u}`;
        if (await t10.fs.exists(h) && (f10 = true, s10 || (l += `${h}
`), !r10))
          break;
      }
      f10 || (c = false);
    }
    return { stdout: l, stderr: "", exitCode: c ? 0 : 1 };
  } }, Iw = { name: "which", flags: [{ flag: "-a", type: "boolean" }, { flag: "-s", type: "boolean" }], needsArgs: true };
});
var a0 = {};
Q(a0, { flagsForFuzzing: () => $w, tac: () => Rw });
async function Ow(e11, t10) {
  if (e11.length > 0 && e11[0] !== "-") {
    let s10 = e11[0].startsWith("/") ? e11[0] : `${t10.cwd}/${e11[0]}`;
    try {
      let o10 = (await t10.fs.readFile(s10)).split(`
`);
      o10[o10.length - 1] === "" && o10.pop();
      let a = o10.reverse();
      return { stdout: a.length > 0 ? `${a.join(`
`)}
` : "", stderr: "", exitCode: 0 };
    } catch {
      return { stdout: "", stderr: `tac: ${e11[0]}: No such file or directory
`, exitCode: 1 };
    }
  }
  let n10 = t10.stdin.split(`
`);
  n10[n10.length - 1] === "" && n10.pop();
  let r10 = n10.reverse();
  return { stdout: r10.length > 0 ? `${r10.join(`
`)}
` : "", stderr: "", exitCode: 0 };
}
var Rw;
var $w;
var l0 = I(() => {
  "use strict";
  Rw = { name: "tac", execute: Ow }, $w = { name: "tac", flags: [], stdinType: "text", needsFiles: true };
});
var c0 = {};
Q(c0, { flagsForFuzzing: () => Dw, hostname: () => Pw });
async function Tw(e11, t10) {
  return { stdout: `localhost
`, stderr: "", exitCode: 0 };
}
var Pw;
var Dw;
var u0 = I(() => {
  "use strict";
  Pw = { name: "hostname", execute: Tw }, Dw = { name: "hostname", flags: [] };
});
var f0 = {};
Q(f0, { flagsForFuzzing: () => Fw, whoami: () => Lw });
async function _w(e11, t10) {
  return { stdout: `user
`, stderr: "", exitCode: 0 };
}
var Lw;
var Fw;
var p0 = I(() => {
  "use strict";
  Lw = { name: "whoami", execute: _w }, Fw = { name: "whoami", flags: [] };
});
var h0 = {};
Q(h0, { flagsForFuzzing: () => Ww, od: () => Uw });
async function Mw(e11, t10) {
  let n10 = "octal", r10 = [], s10 = [];
  for (let h = 0; h < e11.length; h++) {
    let m = e11[h];
    if (m === "-c")
      r10.push("char");
    else if (m === "-An" || m === "-A" && e11[h + 1] === "n")
      n10 = "none", m === "-A" && h++;
    else if (m === "-t" && e11[h + 1]) {
      let d = e11[++h];
      d === "x1" ? r10.push("hex") : d === "c" ? r10.push("char") : d.startsWith("o") && r10.push("octal");
    } else
      (!m.startsWith("-") || m === "-") && s10.push(m);
  }
  r10.length === 0 && r10.push("octal");
  let i10 = t10.stdin;
  if (s10.length > 0 && s10[0] !== "-") {
    let h = s10[0].startsWith("/") ? s10[0] : `${t10.cwd}/${s10[0]}`;
    try {
      i10 = await t10.fs.readFile(h);
    } catch {
      return { stdout: "", stderr: `od: ${s10[0]}: No such file or directory
`, exitCode: 1 };
    }
  }
  let o10 = r10.includes("char");
  function a(h) {
    return h === 0 ? "  \\0" : h === 7 ? "  \\a" : h === 8 ? "  \\b" : h === 9 ? "  \\t" : h === 10 ? "  \\n" : h === 11 ? "  \\v" : h === 12 ? "  \\f" : h === 13 ? "  \\r" : h >= 32 && h < 127 ? `   ${String.fromCharCode(h)}` : ` ${h.toString(8).padStart(3, "0")}`;
  }
  function l(h) {
    return o10 ? `  ${h.toString(16).padStart(2, "0")}` : ` ${h.toString(16).padStart(2, "0")}`;
  }
  function c(h) {
    return ` ${h.toString(8).padStart(3, "0")}`;
  }
  let u = [];
  for (let h of i10)
    u.push(h.charCodeAt(0));
  let f10 = 16, p = [];
  for (let h = 0; h < u.length; h += f10) {
    let m = u.slice(h, h + f10);
    for (let d = 0; d < r10.length; d++) {
      let g = r10[d], y;
      g === "char" ? y = m.map(a) : g === "hex" ? y = m.map(l) : y = m.map(c);
      let w = "";
      d === 0 && n10 !== "none" ? w = `${h.toString(8).padStart(7, "0")} ` : (d > 0 || n10 === "none") && (w = n10 === "none" ? "" : "        "), p.push(w + y.join(""));
    }
  }
  return n10 !== "none" && u.length > 0 && p.push(u.length.toString(8).padStart(7, "0")), { stdout: p.length > 0 ? `${p.join(`
`)}
` : "", stderr: "", exitCode: 0 };
}
var Uw;
var Ww;
var d0 = I(() => {
  "use strict";
  Uw = { name: "od", execute: Mw }, Ww = { name: "od", flags: [{ flag: "-c", type: "boolean" }, { flag: "-A", type: "value", valueHint: "string" }, { flag: "-t", type: "value", valueHint: "string" }, { flag: "-N", type: "value", valueHint: "number" }], stdinType: "text", needsFiles: true };
});
var Di = {};
Q(Di, { flagsForFuzzing: () => Xw, gunzipCommand: () => Qw, gunzipFlagsForFuzzing: () => Yw, gzipCommand: () => Zw, zcatCommand: () => Kw, zcatFlagsForFuzzing: () => Jw });
function g0(e11) {
  return e11.best ? constants3.Z_BEST_COMPRESSION : e11.level8 ? 8 : e11.level7 ? 7 : e11.level6 ? 6 : e11.level5 ? 5 : e11.level4 ? 4 : e11.level3 ? 3 : e11.level2 ? 2 : e11.fast ? constants3.Z_BEST_SPEED : constants3.Z_DEFAULT_COMPRESSION;
}
function y0(e11) {
  if (e11.length < 10)
    return { originalName: null, mtime: null, headerSize: 0 };
  if (e11[0] !== 31 || e11[1] !== 139)
    return { originalName: null, mtime: null, headerSize: 0 };
  let t10 = e11[3], n10 = e11[4] | e11[5] << 8 | e11[6] << 16 | e11[7] << 24, r10 = 10;
  if (t10 & 4) {
    if (r10 + 2 > e11.length)
      return { originalName: null, mtime: null, headerSize: 0 };
    let i10 = e11[r10] | e11[r10 + 1] << 8;
    r10 += 2 + i10;
  }
  let s10 = null;
  if (t10 & 8) {
    let i10 = r10;
    for (; r10 < e11.length && e11[r10] !== 0; )
      r10++;
    r10 < e11.length && (s10 = new TextDecoder().decode(e11.slice(i10, r10)), r10++);
  }
  if (t10 & 16) {
    for (; r10 < e11.length && e11[r10] !== 0; )
      r10++;
    r10++;
  }
  return t10 & 2 && (r10 += 2), { originalName: s10, mtime: n10 > 0 ? new Date(n10 * 1e3) : null, headerSize: r10 };
}
function Gw(e11) {
  if (e11.length < 4)
    return 0;
  let t10 = e11.length;
  return e11[t10 - 4] | e11[t10 - 3] << 8 | e11[t10 - 2] << 16 | e11[t10 - 1] << 24;
}
function Pi(e11) {
  return e11.length >= 2 && e11[0] === 31 && e11[1] === 139;
}
async function w0(e11, t10, n10, r10, s10, i10) {
  let o10 = n10.suffix, a, l, c;
  if (t10 === "-" || t10 === "")
    if (c = Uint8Array.from(e11.stdin, (u) => u.charCodeAt(0)), s10) {
      if (!Pi(c))
        return n10.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r10}: stdin: not in gzip format
`, exitCode: 1 };
      try {
        let u = gunzipSync2(c);
        return { stdout: String.fromCharCode(...u), stderr: "", exitCode: 0 };
      } catch (u) {
        let f10 = u instanceof Error ? u.message : "unknown error";
        return { stdout: "", stderr: `${r10}: stdin: ${f10}
`, exitCode: 1 };
      }
    } else {
      let u = g0(n10), f10 = gzipSync2(c, { level: u });
      return { stdout: String.fromCharCode(...f10), stderr: "", exitCode: 0 };
    }
  a = e11.fs.resolvePath(e11.cwd, t10);
  try {
    if ((await e11.fs.stat(a)).isDirectory)
      return n10.recursive ? await b0(e11, a, n10, r10, s10, i10) : n10.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r10}: ${t10}: is a directory -- ignored
`, exitCode: 1 };
  } catch {
    return { stdout: "", stderr: `${r10}: ${t10}: No such file or directory
`, exitCode: 1 };
  }
  try {
    c = await e11.fs.readFileBuffer(a);
  } catch {
    return { stdout: "", stderr: `${r10}: ${t10}: No such file or directory
`, exitCode: 1 };
  }
  if (s10) {
    if (!t10.endsWith(o10))
      return n10.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r10}: ${t10}: unknown suffix -- ignored
`, exitCode: 1 };
    if (!Pi(c))
      return n10.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r10}: ${t10}: not in gzip format
`, exitCode: 1 };
    let u;
    try {
      u = gunzipSync2(c);
    } catch (f10) {
      let p = f10 instanceof Error ? f10.message : "unknown error";
      return { stdout: "", stderr: `${r10}: ${t10}: ${p}
`, exitCode: 1 };
    }
    if (i10)
      return { stdout: String.fromCharCode(...u), stderr: "", exitCode: 0 };
    if (n10.name) {
      let f10 = y0(c);
      f10.originalName ? l = e11.fs.resolvePath(e11.cwd, f10.originalName) : l = a.slice(0, -o10.length);
    } else
      l = a.slice(0, -o10.length);
    if (!n10.force)
      try {
        return await e11.fs.stat(l), { stdout: "", stderr: `${r10}: ${l} already exists; not overwritten
`, exitCode: 1 };
      } catch {
      }
    if (await e11.fs.writeFile(l, u), !n10.keep && !i10 && await e11.fs.rm(a), n10.verbose) {
      let f10 = c.length > 0 ? ((1 - c.length / u.length) * 100).toFixed(1) : "0.0";
      return { stdout: "", stderr: `${t10}:	${f10}% -- replaced with ${l.split("/").pop()}
`, exitCode: 0 };
    }
    return { stdout: "", stderr: "", exitCode: 0 };
  } else {
    if (t10.endsWith(o10))
      return n10.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r10}: ${t10} already has ${o10} suffix -- unchanged
`, exitCode: 1 };
    let u = g0(n10), f10;
    try {
      f10 = gzipSync2(c, { level: u });
    } catch (p) {
      let h = p instanceof Error ? p.message : "unknown error";
      return { stdout: "", stderr: `${r10}: ${t10}: ${h}
`, exitCode: 1 };
    }
    if (i10)
      return { stdout: String.fromCharCode(...f10), stderr: "", exitCode: 0 };
    if (l = a + o10, !n10.force)
      try {
        return await e11.fs.stat(l), { stdout: "", stderr: `${r10}: ${l} already exists; not overwritten
`, exitCode: 1 };
      } catch {
      }
    if (await e11.fs.writeFile(l, f10), !n10.keep && !i10 && await e11.fs.rm(a), n10.verbose) {
      let p = c.length > 0 ? ((1 - f10.length / c.length) * 100).toFixed(1) : "0.0";
      return { stdout: "", stderr: `${t10}:	${p}% -- replaced with ${l.split("/").pop()}
`, exitCode: 0 };
    }
    return { stdout: "", stderr: "", exitCode: 0 };
  }
}
async function b0(e11, t10, n10, r10, s10, i10) {
  let o10 = await e11.fs.readdir(t10), a = "", l = "", c = 0;
  for (let u of o10) {
    let f10 = e11.fs.resolvePath(t10, u), p = await e11.fs.stat(f10);
    if (p.isDirectory) {
      let h = await b0(e11, f10, n10, r10, s10, i10);
      a += h.stdout, l += h.stderr, h.exitCode !== 0 && (c = h.exitCode);
    } else if (p.isFile) {
      let h = n10.suffix;
      if (s10 && !u.endsWith(h) || !s10 && u.endsWith(h))
        continue;
      let m = f10.startsWith(`${e11.cwd}/`) ? f10.slice(e11.cwd.length + 1) : f10, d = await w0(e11, m, n10, r10, s10, i10);
      a += d.stdout, l += d.stderr, d.exitCode !== 0 && (c = d.exitCode);
    }
  }
  return { stdout: a, stderr: l, exitCode: c };
}
async function Vw(e11, t10, n10, r10) {
  let s10;
  if (t10 === "-" || t10 === "")
    s10 = Uint8Array.from(e11.stdin, (f10) => f10.charCodeAt(0));
  else {
    let f10 = e11.fs.resolvePath(e11.cwd, t10);
    try {
      s10 = await e11.fs.readFileBuffer(f10);
    } catch {
      return { stdout: "", stderr: `${r10}: ${t10}: No such file or directory
`, exitCode: 1 };
    }
  }
  if (!Pi(s10))
    return n10.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r10}: ${t10}: not in gzip format
`, exitCode: 1 };
  let i10 = s10.length, o10 = Gw(s10), a = o10 > 0 ? ((1 - i10 / o10) * 100).toFixed(1) : "0.0", c = y0(s10).originalName || (t10 === "-" ? "" : t10.replace(/\.gz$/, ""));
  return { stdout: `${i10.toString().padStart(10)} ${o10.toString().padStart(10)} ${a.padStart(5)}% ${c}
`, stderr: "", exitCode: 0 };
}
async function qw(e11, t10, n10, r10) {
  let s10;
  if (t10 === "-" || t10 === "")
    s10 = Uint8Array.from(e11.stdin, (i10) => i10.charCodeAt(0));
  else {
    let i10 = e11.fs.resolvePath(e11.cwd, t10);
    try {
      s10 = await e11.fs.readFileBuffer(i10);
    } catch {
      return { stdout: "", stderr: `${r10}: ${t10}: No such file or directory
`, exitCode: 1 };
    }
  }
  if (!Pi(s10))
    return n10.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r10}: ${t10}: not in gzip format
`, exitCode: 1 };
  try {
    return gunzipSync2(s10), n10.verbose ? { stdout: "", stderr: `${t10}:	OK
`, exitCode: 0 } : { stdout: "", stderr: "", exitCode: 0 };
  } catch (i10) {
    let o10 = i10 instanceof Error ? i10.message : "invalid";
    return { stdout: "", stderr: `${r10}: ${t10}: ${o10}
`, exitCode: 1 };
  }
}
async function cl(e11, t10, n10) {
  let r10 = n10 === "zcat" ? Hw : n10 === "gunzip" ? zw : Bw;
  if (U2(e11))
    return M(r10);
  let s10 = be(n10, e11, jw);
  if (!s10.ok)
    return s10.error.stderr.includes("unrecognized option"), s10.error;
  let i10 = s10.result.flags, o10 = s10.result.positional, a = n10 === "gunzip" || n10 === "zcat" || i10.decompress || i10.uncompress, l = n10 === "zcat" || i10.stdout || i10.toStdout;
  if (i10.list) {
    o10.length === 0 && (o10 = ["-"]);
    let p = `  compressed uncompressed  ratio uncompressed_name
`, h = "", m = 0;
    for (let d of o10) {
      let g = await Vw(t10, d, i10, n10);
      p += g.stdout, h += g.stderr, g.exitCode !== 0 && (m = g.exitCode);
    }
    return { stdout: p, stderr: h, exitCode: m };
  }
  if (i10.test) {
    o10.length === 0 && (o10 = ["-"]);
    let p = "", h = "", m = 0;
    for (let d of o10) {
      let g = await qw(t10, d, i10, n10);
      p += g.stdout, h += g.stderr, g.exitCode !== 0 && (m = g.exitCode);
    }
    return { stdout: p, stderr: h, exitCode: m };
  }
  o10.length === 0 && (o10 = ["-"]);
  let c = "", u = "", f10 = 0;
  for (let p of o10) {
    let h = await w0(t10, p, i10, n10, a, l);
    c += h.stdout, u += h.stderr, h.exitCode !== 0 && (f10 = h.exitCode);
  }
  return { stdout: c, stderr: u, exitCode: f10 };
}
var Bw;
var zw;
var Hw;
var jw;
var Zw;
var Qw;
var Kw;
var Xw;
var Yw;
var Jw;
var _i = I(() => {
  "use strict";
  qe();
  se();
  Bw = { name: "gzip", summary: "compress or expand files", usage: "gzip [OPTION]... [FILE]...", description: `Compress FILEs (by default, in-place).

When no FILE is given, or when FILE is -, read from standard input.

With -d, decompress instead.`, options: ["-c, --stdout      write to standard output, keep original files", "-d, --decompress  decompress", "-f, --force       force overwrite of output file", "-k, --keep        keep (don't delete) input files", "-l, --list        list compressed file contents", "-n, --no-name     do not save or restore the original name and timestamp", "-N, --name        save or restore the original file name and timestamp", "-q, --quiet       suppress all warnings", "-r, --recursive   operate recursively on directories", "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)", "-t, --test        test compressed file integrity", "-v, --verbose     verbose mode", "-1, --fast        compress faster", "-9, --best        compress better", "    --help        display this help and exit"] }, zw = { name: "gunzip", summary: "decompress files", usage: "gunzip [OPTION]... [FILE]...", description: `Decompress FILEs (by default, in-place).

When no FILE is given, or when FILE is -, read from standard input.`, options: ["-c, --stdout      write to standard output, keep original files", "-f, --force       force overwrite of output file", "-k, --keep        keep (don't delete) input files", "-l, --list        list compressed file contents", "-n, --no-name     do not restore the original name and timestamp", "-N, --name        restore the original file name and timestamp", "-q, --quiet       suppress all warnings", "-r, --recursive   operate recursively on directories", "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)", "-t, --test        test compressed file integrity", "-v, --verbose     verbose mode", "    --help        display this help and exit"] }, Hw = { name: "zcat", summary: "decompress files to stdout", usage: "zcat [OPTION]... [FILE]...", description: `Decompress FILEs to standard output.

When no FILE is given, or when FILE is -, read from standard input.`, options: ["-f, --force       force; read compressed data even from a terminal", "-l, --list        list compressed file contents", "-q, --quiet       suppress all warnings", "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)", "-t, --test        test compressed file integrity", "-v, --verbose     verbose mode", "    --help        display this help and exit"] }, jw = { stdout: { short: "c", long: "stdout", type: "boolean" }, toStdout: { long: "to-stdout", type: "boolean" }, decompress: { short: "d", long: "decompress", type: "boolean" }, uncompress: { long: "uncompress", type: "boolean" }, force: { short: "f", long: "force", type: "boolean" }, keep: { short: "k", long: "keep", type: "boolean" }, list: { short: "l", long: "list", type: "boolean" }, noName: { short: "n", long: "no-name", type: "boolean" }, name: { short: "N", long: "name", type: "boolean" }, quiet: { short: "q", long: "quiet", type: "boolean" }, recursive: { short: "r", long: "recursive", type: "boolean" }, suffix: { short: "S", long: "suffix", type: "string", default: ".gz" }, test: { short: "t", long: "test", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" }, fast: { short: "1", long: "fast", type: "boolean" }, level2: { short: "2", type: "boolean" }, level3: { short: "3", type: "boolean" }, level4: { short: "4", type: "boolean" }, level5: { short: "5", type: "boolean" }, level6: { short: "6", type: "boolean" }, level7: { short: "7", type: "boolean" }, level8: { short: "8", type: "boolean" }, best: { short: "9", long: "best", type: "boolean" } };
  Zw = { name: "gzip", async execute(e11, t10) {
    return cl(e11, t10, "gzip");
  } }, Qw = { name: "gunzip", async execute(e11, t10) {
    return cl(e11, t10, "gunzip");
  } }, Kw = { name: "zcat", async execute(e11, t10) {
    return cl(e11, t10, "zcat");
  } }, Xw = { name: "gzip", flags: [{ flag: "-c", type: "boolean" }, { flag: "-d", type: "boolean" }, { flag: "-f", type: "boolean" }, { flag: "-k", type: "boolean" }, { flag: "-l", type: "boolean" }, { flag: "-n", type: "boolean" }, { flag: "-q", type: "boolean" }, { flag: "-r", type: "boolean" }, { flag: "-t", type: "boolean" }, { flag: "-v", type: "boolean" }, { flag: "-1", type: "boolean" }, { flag: "-9", type: "boolean" }], stdinType: "binary", needsFiles: true }, Yw = { name: "gunzip", flags: [{ flag: "-c", type: "boolean" }, { flag: "-f", type: "boolean" }, { flag: "-k", type: "boolean" }, { flag: "-q", type: "boolean" }, { flag: "-v", type: "boolean" }], stdinType: "binary", needsFiles: true }, Jw = { name: "zcat", flags: [{ flag: "-f", type: "boolean" }, { flag: "-q", type: "boolean" }, { flag: "-v", type: "boolean" }], stdinType: "binary", needsFiles: true };
});
function ul(e11) {
  let t10 = e11.indexOf("=");
  if (t10 >= 0) {
    let n10 = e11.slice(0, t10), r10 = e11.slice(t10 + 1);
    return n10 ? `${encodeURIComponent(n10)}=${encodeURIComponent(r10)}` : encodeURIComponent(r10);
  }
  return encodeURIComponent(e11);
}
function fl(e11) {
  let t10 = e11.indexOf("=");
  if (t10 < 0)
    return null;
  let n10 = e11.slice(0, t10), r10 = e11.slice(t10 + 1), s10, i10, o10 = r10.match(/;type=([^;]+)$/);
  o10 && (i10 = o10[1], r10 = r10.slice(0, -o10[0].length));
  let a = r10.match(/;filename=([^;]+)/);
  return a && (s10 = a[1], r10 = r10.replace(a[0], "")), (r10.startsWith("@") || r10.startsWith("<")) && (s10 = s10 ?? r10.slice(1).split("/").pop()), { name: n10, value: r10, filename: s10, contentType: i10 };
}
function x0(e11, t10) {
  let n10 = `----CurlFormBoundary${Date.now().toString(36)}`, r10 = [];
  for (let s10 of e11) {
    let i10 = s10.value;
    if (i10.startsWith("@") || i10.startsWith("<")) {
      let a = i10.slice(1);
      i10 = t10.get(a) ?? "";
    }
    let o10 = `--${n10}\r
`;
    s10.filename ? (o10 += `Content-Disposition: form-data; name="${s10.name}"; filename="${s10.filename}"\r
`, s10.contentType && (o10 += `Content-Type: ${s10.contentType}\r
`)) : o10 += `Content-Disposition: form-data; name="${s10.name}"\r
`, o10 += `\r
${i10}\r
`, r10.push(o10);
  }
  return r10.push(`--${n10}--\r
`), { body: r10.join(""), boundary: n10 };
}
var pl = I(() => {
  "use strict";
});
var E0;
var A0 = I(() => {
  "use strict";
  E0 = { name: "curl", summary: "transfer a URL", usage: "curl [OPTIONS] URL", options: ["-X, --request METHOD  HTTP method (GET, POST, PUT, DELETE, etc.)", "-H, --header HEADER   Add header (can be used multiple times)", "-d, --data DATA       HTTP POST data", "    --data-raw DATA   HTTP POST data (no @ interpretation)", "    --data-binary DATA  HTTP POST binary data", "    --data-urlencode DATA  URL-encode and POST data", "-F, --form NAME=VALUE  Multipart form data", "-u, --user USER:PASS  HTTP authentication", "-A, --user-agent STR  Set User-Agent header", "-e, --referer URL     Set Referer header", "-b, --cookie DATA     Send cookies (name=value or @file)", "-c, --cookie-jar FILE Save cookies to file", "-T, --upload-file FILE  Upload file (PUT)", "-o, --output FILE     Write output to file", "-O, --remote-name     Write to file named from URL", "-I, --head            Show headers only (HEAD request)", "-i, --include         Include response headers in output", "-s, --silent          Silent mode (no progress)", "-S, --show-error      Show errors even when silent", "-f, --fail            Fail silently on HTTP errors (no output)", "-L, --location        Follow redirects (default)", "    --max-redirs NUM  Maximum redirects (default: 20)", "-m, --max-time SECS   Maximum time for request", "    --connect-timeout SECS  Connection timeout", "-w, --write-out FMT   Output format after completion", "-v, --verbose         Verbose output", "    --help            Display this help and exit", "", "Note: Network access must be configured via BashEnv network option.", "      curl is not available by default for security reasons."] };
});
function S0(e11) {
  let t10 = { method: "GET", headers: /* @__PURE__ */ Object.create(null), dataBinary: false, formFields: [], useRemoteName: false, headOnly: false, includeHeaders: false, silent: false, showError: false, failSilently: false, followRedirects: true, verbose: false };
  for (let n10 = 0; n10 < e11.length; n10++) {
    let r10 = e11[n10];
    if (r10 === "-X" || r10 === "--request")
      t10.method = e11[++n10] ?? "GET";
    else if (r10.startsWith("-X"))
      t10.method = r10.slice(2);
    else if (r10.startsWith("--request="))
      t10.method = r10.slice(10);
    else if (r10 === "-H" || r10 === "--header") {
      let s10 = e11[++n10];
      if (s10) {
        let i10 = s10.indexOf(":");
        if (i10 > 0) {
          let o10 = s10.slice(0, i10).trim(), a = s10.slice(i10 + 1).trim();
          t10.headers[o10] = a;
        }
      }
    } else if (r10.startsWith("--header=")) {
      let s10 = r10.slice(9), i10 = s10.indexOf(":");
      if (i10 > 0) {
        let o10 = s10.slice(0, i10).trim(), a = s10.slice(i10 + 1).trim();
        t10.headers[o10] = a;
      }
    } else if (r10 === "-d" || r10 === "--data" || r10 === "--data-raw")
      t10.data = e11[++n10] ?? "", t10.method === "GET" && (t10.method = "POST");
    else if (r10.startsWith("-d"))
      t10.data = r10.slice(2), t10.method === "GET" && (t10.method = "POST");
    else if (r10.startsWith("--data="))
      t10.data = r10.slice(7), t10.method === "GET" && (t10.method = "POST");
    else if (r10.startsWith("--data-raw="))
      t10.data = r10.slice(11), t10.method === "GET" && (t10.method = "POST");
    else if (r10 === "--data-binary")
      t10.data = e11[++n10] ?? "", t10.dataBinary = true, t10.method === "GET" && (t10.method = "POST");
    else if (r10.startsWith("--data-binary="))
      t10.data = r10.slice(14), t10.dataBinary = true, t10.method === "GET" && (t10.method = "POST");
    else if (r10 === "--data-urlencode") {
      let s10 = e11[++n10] ?? "";
      t10.data = (t10.data ? `${t10.data}&` : "") + ul(s10), t10.method === "GET" && (t10.method = "POST");
    } else if (r10.startsWith("--data-urlencode=")) {
      let s10 = r10.slice(17);
      t10.data = (t10.data ? `${t10.data}&` : "") + ul(s10), t10.method === "GET" && (t10.method = "POST");
    } else if (r10 === "-F" || r10 === "--form") {
      let s10 = e11[++n10] ?? "", i10 = fl(s10);
      i10 && t10.formFields.push(i10), t10.method === "GET" && (t10.method = "POST");
    } else if (r10.startsWith("--form=")) {
      let s10 = r10.slice(7), i10 = fl(s10);
      i10 && t10.formFields.push(i10), t10.method === "GET" && (t10.method = "POST");
    } else if (r10 === "-u" || r10 === "--user")
      t10.user = e11[++n10];
    else if (r10.startsWith("-u"))
      t10.user = r10.slice(2);
    else if (r10.startsWith("--user="))
      t10.user = r10.slice(7);
    else if (r10 === "-A" || r10 === "--user-agent")
      t10.headers["User-Agent"] = e11[++n10] ?? "";
    else if (r10.startsWith("-A"))
      t10.headers["User-Agent"] = r10.slice(2);
    else if (r10.startsWith("--user-agent="))
      t10.headers["User-Agent"] = r10.slice(13);
    else if (r10 === "-e" || r10 === "--referer")
      t10.headers.Referer = e11[++n10] ?? "";
    else if (r10.startsWith("-e"))
      t10.headers.Referer = r10.slice(2);
    else if (r10.startsWith("--referer="))
      t10.headers.Referer = r10.slice(10);
    else if (r10 === "-b" || r10 === "--cookie")
      t10.headers.Cookie = e11[++n10] ?? "";
    else if (r10.startsWith("-b"))
      t10.headers.Cookie = r10.slice(2);
    else if (r10.startsWith("--cookie="))
      t10.headers.Cookie = r10.slice(9);
    else if (r10 === "-c" || r10 === "--cookie-jar")
      t10.cookieJar = e11[++n10];
    else if (r10.startsWith("--cookie-jar="))
      t10.cookieJar = r10.slice(13);
    else if (r10 === "-T" || r10 === "--upload-file")
      t10.uploadFile = e11[++n10], t10.method === "GET" && (t10.method = "PUT");
    else if (r10.startsWith("--upload-file="))
      t10.uploadFile = r10.slice(14), t10.method === "GET" && (t10.method = "PUT");
    else if (r10 === "-m" || r10 === "--max-time") {
      let s10 = parseFloat(e11[++n10] ?? "0");
      !Number.isNaN(s10) && s10 > 0 && (t10.timeoutMs = s10 * 1e3);
    } else if (r10.startsWith("--max-time=")) {
      let s10 = parseFloat(r10.slice(11));
      !Number.isNaN(s10) && s10 > 0 && (t10.timeoutMs = s10 * 1e3);
    } else if (r10 === "--connect-timeout") {
      let s10 = parseFloat(e11[++n10] ?? "0");
      !Number.isNaN(s10) && s10 > 0 && t10.timeoutMs === void 0 && (t10.timeoutMs = s10 * 1e3);
    } else if (r10.startsWith("--connect-timeout=")) {
      let s10 = parseFloat(r10.slice(18));
      !Number.isNaN(s10) && s10 > 0 && t10.timeoutMs === void 0 && (t10.timeoutMs = s10 * 1e3);
    } else if (r10 === "-o" || r10 === "--output")
      t10.outputFile = e11[++n10];
    else if (r10.startsWith("--output="))
      t10.outputFile = r10.slice(9);
    else if (r10 === "-O" || r10 === "--remote-name")
      t10.useRemoteName = true;
    else if (r10 === "-I" || r10 === "--head")
      t10.headOnly = true, t10.method = "HEAD";
    else if (r10 === "-i" || r10 === "--include")
      t10.includeHeaders = true;
    else if (r10 === "-s" || r10 === "--silent")
      t10.silent = true;
    else if (r10 === "-S" || r10 === "--show-error")
      t10.showError = true;
    else if (r10 === "-f" || r10 === "--fail")
      t10.failSilently = true;
    else if (r10 === "-L" || r10 === "--location")
      t10.followRedirects = true;
    else if (r10 === "--max-redirs")
      n10++;
    else if (!r10.startsWith("--max-redirs="))
      if (r10 === "-w" || r10 === "--write-out")
        t10.writeOut = e11[++n10];
      else if (r10.startsWith("--write-out="))
        t10.writeOut = r10.slice(12);
      else if (r10 === "-v" || r10 === "--verbose")
        t10.verbose = true;
      else {
        if (r10.startsWith("--") && r10 !== "--")
          return Y("curl", r10);
        if (r10.startsWith("-") && r10 !== "-")
          for (let s10 of r10.slice(1))
            switch (s10) {
              case "s":
                t10.silent = true;
                break;
              case "S":
                t10.showError = true;
                break;
              case "f":
                t10.failSilently = true;
                break;
              case "L":
                t10.followRedirects = true;
                break;
              case "I":
                t10.headOnly = true, t10.method = "HEAD";
                break;
              case "i":
                t10.includeHeaders = true;
                break;
              case "O":
                t10.useRemoteName = true;
                break;
              case "v":
                t10.verbose = true;
                break;
              default:
                return Y("curl", `-${s10}`);
            }
        else
          r10.startsWith("-") || (t10.url = r10);
      }
  }
  return t10;
}
var C0 = I(() => {
  "use strict";
  se();
  pl();
});
function hl(e11) {
  return Object.entries(e11).map(([t10, n10]) => `${t10}: ${n10}`).join(`\r
`);
}
function N0(e11) {
  try {
    return new URL(e11).pathname.split("/").pop() || "index.html";
  } catch {
    return "index.html";
  }
}
function dl(e11, t10) {
  let n10 = e11;
  return n10 = n10.replace(/%\{http_code\}/g, String(t10.status)), n10 = n10.replace(/%\{content_type\}/g, t10.headers["content-type"] || ""), n10 = n10.replace(/%\{url_effective\}/g, t10.url), n10 = n10.replace(/%\{size_download\}/g, String(t10.bodyLength)), n10 = n10.replace(/\\n/g, `
`), n10;
}
var k0 = I(() => {
  "use strict";
});
var v0 = {};
Q(v0, { curlCommand: () => sb });
async function eb(e11, t10) {
  if (e11.uploadFile) {
    let n10 = t10.fs.resolvePath(t10.cwd, e11.uploadFile);
    return { body: await t10.fs.readFile(n10) };
  }
  if (e11.formFields.length > 0) {
    let n10 = /* @__PURE__ */ new Map();
    for (let i10 of e11.formFields)
      if (i10.value.startsWith("@") || i10.value.startsWith("<")) {
        let o10 = t10.fs.resolvePath(t10.cwd, i10.value.slice(1));
        try {
          let a = await t10.fs.readFile(o10);
          n10.set(i10.value.slice(1), a);
        } catch {
          n10.set(i10.value.slice(1), "");
        }
      }
    let { body: r10, boundary: s10 } = x0(e11.formFields, n10);
    return { body: r10, contentType: `multipart/form-data; boundary=${s10}` };
  }
  return e11.data !== void 0 ? { body: e11.data } : {};
}
function tb(e11, t10) {
  let n10 = Ze(e11.headers ?? {});
  if (e11.user) {
    let r10 = Buffer.from(e11.user).toString("base64");
    n10.Authorization = `Basic ${r10}`;
  }
  return t10 && !n10["Content-Type"] && (n10["Content-Type"] = t10), n10;
}
async function nb(e11, t10, n10) {
  if (!e11.cookieJar)
    return;
  let r10 = t10["set-cookie"];
  if (!r10)
    return;
  let s10 = n10.fs.resolvePath(n10.cwd, e11.cookieJar);
  await n10.fs.writeFile(s10, r10);
}
function rb(e11, t10, n10) {
  let r10 = "";
  if (e11.verbose) {
    r10 += `> ${e11.method} ${n10}
`;
    for (let [s10, i10] of Object.entries(e11.headers))
      r10 += `> ${s10}: ${i10}
`;
    r10 += `>
`, r10 += `< HTTP/1.1 ${t10.status} ${t10.statusText}
`;
    for (let [s10, i10] of Object.entries(t10.headers))
      r10 += `< ${s10}: ${i10}
`;
    r10 += `<
`;
  }
  return e11.includeHeaders && !e11.verbose && (r10 += `HTTP/1.1 ${t10.status} ${t10.statusText}\r
`, r10 += hl(t10.headers), r10 += `\r
\r
`), e11.headOnly ? e11.includeHeaders || e11.verbose || (r10 += `HTTP/1.1 ${t10.status} ${t10.statusText}\r
`, r10 += hl(t10.headers), r10 += `\r
`) : r10 += t10.body, e11.writeOut && (r10 += dl(e11.writeOut, { status: t10.status, headers: t10.headers, url: t10.url, bodyLength: t10.body.length })), r10;
}
var sb;
var I0 = I(() => {
  "use strict";
  Wt();
  se();
  En();
  pl();
  A0();
  C0();
  k0();
  sb = { name: "curl", async execute(e11, t10) {
    if (U2(e11))
      return M(E0);
    let n10 = S0(e11);
    if ("exitCode" in n10)
      return n10;
    let r10 = n10;
    if (!r10.url)
      return { stdout: "", stderr: `curl: no URL specified
`, exitCode: 2 };
    if (!t10.fetch)
      return { stdout: "", stderr: `curl: internal error: fetch not available
`, exitCode: 1 };
    let s10 = r10.url;
    s10.match(/^https?:\/\//) || (s10 = `https://${s10}`);
    try {
      let { body: i10, contentType: o10 } = await eb(r10, t10), a = tb(r10, o10), l = await t10.fetch(s10, { method: r10.method, headers: Object.keys(a).length > 0 ? a : void 0, body: i10, followRedirects: r10.followRedirects, timeoutMs: r10.timeoutMs });
      if (await nb(r10, l.headers, t10), r10.failSilently && l.status >= 400)
        return { stdout: "", stderr: r10.showError || !r10.silent ? `curl: (22) The requested URL returned error: ${l.status}
` : "", exitCode: 22 };
      let c = rb(r10, l, s10);
      if (r10.outputFile || r10.useRemoteName) {
        let u = r10.outputFile || N0(s10), f10 = t10.fs.resolvePath(t10.cwd, u);
        await t10.fs.writeFile(f10, r10.headOnly ? "" : l.body), r10.verbose || (c = ""), r10.writeOut && (c = dl(r10.writeOut, { status: l.status, headers: l.headers, url: l.url, bodyLength: l.body.length }));
      }
      return { stdout: c, stderr: "", exitCode: 0 };
    } catch (i10) {
      let o10 = Me(i10), a = 1;
      return o10.includes("Network access denied") ? a = 7 : o10.includes("HTTP method") && o10.includes("not allowed") ? a = 3 : o10.includes("Redirect target not in allow-list") || o10.includes("Too many redirects") ? a = 47 : o10.includes("aborted") && (a = 28), { stdout: "", stderr: !r10.silent || r10.showError ? `curl: (${a}) ${o10}
` : "", exitCode: a };
    }
  } };
});
function ys() {
  return { pid: process.pid, ppid: process.ppid, uid: process.getuid?.() ?? 1e3, gid: process.getgid?.() ?? 1e3 };
}
function U0() {
  let { pid: e11, ppid: t10, uid: n10, gid: r10 } = ys();
  return `Name:	bash
State:	R (running)
Pid:	${e11}
PPid:	${t10}
Uid:	${n10}	${n10}	${n10}	${n10}
Gid:	${r10}	${r10}	${r10}	${r10}
`;
}
var F0;
var M0;
var wl = I(() => {
  "use strict";
  F0 = "5.1.0(1)-release", M0 = "Linux version 5.15.0-generic (just-bash) #1 SMP PREEMPT";
});
function z0(e11) {
  let t10 = e11.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
  if (!t10)
    return false;
  let n10 = e11.slice(t10[0].length);
  if (n10 === "" || n10 === "+")
    return true;
  if (n10[0] === "[") {
    let r10 = 0, s10 = 0;
    for (; s10 < n10.length; s10++)
      if (n10[s10] === "[")
        r10++;
      else if (n10[s10] === "]" && (r10--, r10 === 0))
        break;
    if (r10 !== 0 || s10 >= n10.length)
      return false;
    let i10 = n10.slice(s10 + 1);
    return i10 === "" || i10 === "+";
  }
  return false;
}
function H0(e11) {
  let t10 = 0;
  for (let n10 = 0; n10 < e11.length; n10++) {
    let r10 = e11[n10];
    if (r10 === "[")
      t10++;
    else if (r10 === "]")
      t10--;
    else {
      if (t10 === 0 && r10 === "=")
        return n10;
      if (t10 === 0 && r10 === "+" && e11[n10 + 1] === "=")
        return n10 + 1;
    }
  }
  return -1;
}
function Ab(e11) {
  return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e11);
}
function j0(e11) {
  return e11 === " " || e11 === "	" || e11 === `
` || e11 === ";" || e11 === "&" || e11 === "|" || e11 === "(" || e11 === ")" || e11 === "<" || e11 === ">";
}
var E;
var Tn;
var B0;
var bb;
var xb;
var Eb;
var Mi;
var Pn = I(() => {
  "use strict";
  (function(e11) {
    e11.EOF = "EOF", e11.NEWLINE = "NEWLINE", e11.SEMICOLON = "SEMICOLON", e11.AMP = "AMP", e11.PIPE = "PIPE", e11.PIPE_AMP = "PIPE_AMP", e11.AND_AND = "AND_AND", e11.OR_OR = "OR_OR", e11.BANG = "BANG", e11.LESS = "LESS", e11.GREAT = "GREAT", e11.DLESS = "DLESS", e11.DGREAT = "DGREAT", e11.LESSAND = "LESSAND", e11.GREATAND = "GREATAND", e11.LESSGREAT = "LESSGREAT", e11.DLESSDASH = "DLESSDASH", e11.CLOBBER = "CLOBBER", e11.TLESS = "TLESS", e11.AND_GREAT = "AND_GREAT", e11.AND_DGREAT = "AND_DGREAT", e11.LPAREN = "LPAREN", e11.RPAREN = "RPAREN", e11.LBRACE = "LBRACE", e11.RBRACE = "RBRACE", e11.DSEMI = "DSEMI", e11.SEMI_AND = "SEMI_AND", e11.SEMI_SEMI_AND = "SEMI_SEMI_AND", e11.DBRACK_START = "DBRACK_START", e11.DBRACK_END = "DBRACK_END", e11.DPAREN_START = "DPAREN_START", e11.DPAREN_END = "DPAREN_END", e11.IF = "IF", e11.THEN = "THEN", e11.ELSE = "ELSE", e11.ELIF = "ELIF", e11.FI = "FI", e11.FOR = "FOR", e11.WHILE = "WHILE", e11.UNTIL = "UNTIL", e11.DO = "DO", e11.DONE = "DONE", e11.CASE = "CASE", e11.ESAC = "ESAC", e11.IN = "IN", e11.FUNCTION = "FUNCTION", e11.SELECT = "SELECT", e11.TIME = "TIME", e11.COPROC = "COPROC", e11.WORD = "WORD", e11.NAME = "NAME", e11.NUMBER = "NUMBER", e11.ASSIGNMENT_WORD = "ASSIGNMENT_WORD", e11.FD_VARIABLE = "FD_VARIABLE", e11.COMMENT = "COMMENT", e11.HEREDOC_CONTENT = "HEREDOC_CONTENT";
  })(E || (E = {}));
  Tn = class extends Error {
    line;
    column;
    constructor(t10, n10, r10) {
      super(`line ${n10}: ${t10}`), this.line = n10, this.column = r10, this.name = "LexerError";
    }
  }, B0 = /* @__PURE__ */ new Map([["if", E.IF], ["then", E.THEN], ["else", E.ELSE], ["elif", E.ELIF], ["fi", E.FI], ["for", E.FOR], ["while", E.WHILE], ["until", E.UNTIL], ["do", E.DO], ["done", E.DONE], ["case", E.CASE], ["esac", E.ESAC], ["in", E.IN], ["function", E.FUNCTION], ["select", E.SELECT], ["time", E.TIME], ["coproc", E.COPROC]]);
  bb = [[";", ";", "&", E.SEMI_SEMI_AND], ["<", "<", "<", E.TLESS], ["&", ">", ">", E.AND_DGREAT]], xb = [["[", "[", E.DBRACK_START], ["]", "]", E.DBRACK_END], ["(", "(", E.DPAREN_START], [")", ")", E.DPAREN_END], ["&", "&", E.AND_AND], ["|", "|", E.OR_OR], [";", ";", E.DSEMI], [";", "&", E.SEMI_AND], ["|", "&", E.PIPE_AMP], [">", ">", E.DGREAT], ["<", "&", E.LESSAND], [">", "&", E.GREATAND], ["<", ">", E.LESSGREAT], [">", "|", E.CLOBBER], ["&", ">", E.AND_GREAT]], Eb = /* @__PURE__ */ new Map([["|", E.PIPE], ["&", E.AMP], [";", E.SEMICOLON], ["(", E.LPAREN], [")", E.RPAREN], ["<", E.LESS], [">", E.GREAT]]);
  Mi = class {
    input;
    pos = 0;
    line = 1;
    column = 1;
    tokens = [];
    pendingHeredocs = [];
    dparenDepth = 0;
    constructor(t10) {
      this.input = t10;
    }
    tokenize() {
      let n10 = this.input.length, r10 = this.tokens, s10 = this.pendingHeredocs;
      for (; this.pos < n10; ) {
        if (s10.length > 0 && r10.length > 0 && r10[r10.length - 1].type === E.NEWLINE) {
          this.readHeredocContent();
          continue;
        }
        if (this.skipWhitespace(), this.pos >= n10)
          break;
        let i10 = this.nextToken();
        i10 && r10.push(i10);
      }
      return r10.push({ type: E.EOF, value: "", start: this.pos, end: this.pos, line: this.line, column: this.column }), r10;
    }
    skipWhitespace() {
      let t10 = this.input, n10 = t10.length, r10 = this.pos, s10 = this.column, i10 = this.line;
      for (; r10 < n10; ) {
        let o10 = t10[r10];
        if (o10 === " " || o10 === "	")
          r10++, s10++;
        else if (o10 === "\\" && t10[r10 + 1] === `
`)
          r10 += 2, i10++, s10 = 1;
        else
          break;
      }
      this.pos = r10, this.column = s10, this.line = i10;
    }
    nextToken() {
      let t10 = this.input, n10 = this.pos, r10 = this.line, s10 = this.column, i10 = t10[n10], o10 = t10[n10 + 1], a = t10[n10 + 2];
      if (i10 === "#" && this.dparenDepth === 0)
        return this.readComment(n10, r10, s10);
      if (i10 === `
`)
        return this.pos = n10 + 1, this.line++, this.column = 1, { type: E.NEWLINE, value: `
`, start: n10, end: n10 + 1, line: r10, column: s10 };
      if (i10 === "<" && o10 === "<" && a === "-")
        return this.pos = n10 + 3, this.column = s10 + 3, this.registerHeredocFromLookahead(true), this.makeToken(E.DLESSDASH, "<<-", n10, r10, s10);
      for (let [c, u, f10, p] of bb)
        if (i10 === c && o10 === u && a === f10)
          return this.pos = n10 + 3, this.column = s10 + 3, this.makeToken(p, c + u + f10, n10, r10, s10);
      if (i10 === "<" && o10 === "<")
        return this.pos = n10 + 2, this.column = s10 + 2, this.registerHeredocFromLookahead(false), this.makeToken(E.DLESS, "<<", n10, r10, s10);
      if (i10 === "(" && o10 === "(")
        return this.dparenDepth > 0 ? (this.pos = n10 + 1, this.column = s10 + 1, this.dparenDepth++, this.makeToken(E.LPAREN, "(", n10, r10, s10)) : this.looksLikeNestedSubshells(n10 + 2) || this.dparenClosesWithSpacedParens(n10 + 2) ? (this.pos = n10 + 1, this.column = s10 + 1, this.makeToken(E.LPAREN, "(", n10, r10, s10)) : (this.pos = n10 + 2, this.column = s10 + 2, this.dparenDepth = 1, this.makeToken(E.DPAREN_START, "((", n10, r10, s10));
      if (i10 === ")" && o10 === ")")
        return this.dparenDepth === 1 ? (this.pos = n10 + 2, this.column = s10 + 2, this.dparenDepth = 0, this.makeToken(E.DPAREN_END, "))", n10, r10, s10)) : this.dparenDepth > 1 ? (this.pos = n10 + 1, this.column = s10 + 1, this.dparenDepth--, this.makeToken(E.RPAREN, ")", n10, r10, s10)) : (this.pos = n10 + 1, this.column = s10 + 1, this.makeToken(E.RPAREN, ")", n10, r10, s10));
      for (let [c, u, f10] of xb)
        if (!(c === "(" && u === "(" || c === ")" && u === ")") && !(this.dparenDepth > 0 && c === ";" && (f10 === E.DSEMI || f10 === E.SEMI_AND || f10 === E.SEMI_SEMI_AND)) && i10 === c && o10 === u) {
          if (f10 === E.DBRACK_START || f10 === E.DBRACK_END) {
            let p = t10[n10 + 2];
            if (p !== void 0 && p !== " " && p !== "	" && p !== `
` && p !== ";" && p !== "&" && p !== "|" && p !== "(" && p !== ")" && p !== "<" && p !== ">")
              break;
          }
          return this.pos = n10 + 2, this.column = s10 + 2, this.makeToken(f10, c + u, n10, r10, s10);
        }
      if (i10 === "(" && this.dparenDepth > 0)
        return this.pos = n10 + 1, this.column = s10 + 1, this.dparenDepth++, this.makeToken(E.LPAREN, "(", n10, r10, s10);
      if (i10 === ")" && this.dparenDepth > 1)
        return this.pos = n10 + 1, this.column = s10 + 1, this.dparenDepth--, this.makeToken(E.RPAREN, ")", n10, r10, s10);
      let l = Eb.get(i10);
      if (l !== void 0)
        return this.pos = n10 + 1, this.column = s10 + 1, this.makeToken(l, i10, n10, r10, s10);
      if (i10 === "{") {
        let c = this.scanFdVariable(n10);
        return c !== null ? (this.pos = c.end, this.column = s10 + (c.end - n10), { type: E.FD_VARIABLE, value: c.varname, start: n10, end: c.end, line: r10, column: s10 }) : o10 === "}" ? (this.pos = n10 + 2, this.column = s10 + 2, { type: E.WORD, value: "{}", start: n10, end: n10 + 2, line: r10, column: s10, quoted: false, singleQuoted: false }) : this.scanBraceExpansion(n10) !== null ? this.readWordWithBraceExpansion(n10, r10, s10) : this.scanLiteralBraceWord(n10) !== null ? this.readWordWithBraceExpansion(n10, r10, s10) : o10 !== void 0 && o10 !== " " && o10 !== "	" && o10 !== `
` ? this.readWord(n10, r10, s10) : (this.pos = n10 + 1, this.column = s10 + 1, this.makeToken(E.LBRACE, "{", n10, r10, s10));
      }
      return i10 === "}" ? this.isWordCharFollowing(n10 + 1) ? this.readWord(n10, r10, s10) : (this.pos = n10 + 1, this.column = s10 + 1, this.makeToken(E.RBRACE, "}", n10, r10, s10)) : i10 === "!" ? o10 === "=" ? (this.pos = n10 + 2, this.column = s10 + 2, this.makeToken(E.WORD, "!=", n10, r10, s10)) : (this.pos = n10 + 1, this.column = s10 + 1, this.makeToken(E.BANG, "!", n10, r10, s10)) : this.readWord(n10, r10, s10);
    }
    looksLikeNestedSubshells(t10) {
      let n10 = this.input, r10 = n10.length, s10 = t10;
      for (; s10 < r10 && (n10[s10] === " " || n10[s10] === "	"); )
        s10++;
      if (s10 >= r10)
        return false;
      let i10 = n10[s10];
      if (i10 === "(")
        return this.looksLikeNestedSubshells(s10 + 1);
      let o10 = /[a-zA-Z_]/.test(i10), a = i10 === "!" || i10 === "[";
      if (!o10 && !a)
        return false;
      let l = s10;
      for (; l < r10 && /[a-zA-Z0-9_\-.]/.test(n10[l]); )
        l++;
      if (l === s10)
        return a;
      let c = l;
      for (; c < r10 && (n10[c] === " " || n10[c] === "	"); )
        c++;
      if (c >= r10)
        return false;
      let u = n10[c];
      if (u === "=" && n10[c + 1] !== "=" || u === `
` || l === c && /[+\-*/%<>&|^!~?:]/.test(u) && u !== "-" || u === ")" && n10[c + 1] === ")")
        return false;
      if (c > l && (u === "-" || u === '"' || u === "'" || u === "$" || /[a-zA-Z_/.]/.test(u))) {
        let f10 = c;
        for (; f10 < r10 && n10[f10] !== `
`; ) {
          if (n10[f10] === ")")
            return true;
          f10++;
        }
        return false;
      }
      if (u === ")") {
        let f10 = c + 1;
        for (; f10 < r10 && (n10[f10] === " " || n10[f10] === "	"); )
          f10++;
        if (n10[f10] === "|" && n10[f10 + 1] === "|" || n10[f10] === "&" && n10[f10 + 1] === "&" || n10[f10] === ";" || n10[f10] === "|" && n10[f10 + 1] !== "|")
          return true;
      }
      return false;
    }
    makeToken(t10, n10, r10, s10, i10) {
      return { type: t10, value: n10, start: r10, end: this.pos, line: s10, column: i10 };
    }
    readComment(t10, n10, r10) {
      let s10 = this.input, i10 = s10.length, o10 = this.pos;
      for (; o10 < i10 && s10[o10] !== `
`; )
        o10++;
      let a = s10.slice(t10, o10);
      return this.pos = o10, this.column = r10 + (o10 - t10), { type: E.COMMENT, value: a, start: t10, end: o10, line: n10, column: r10 };
    }
    readWord(t10, n10, r10) {
      let s10 = this.input, i10 = s10.length, o10 = this.pos, a = o10;
      for (; o10 < i10; ) {
        let b = s10[o10];
        if (b === " " || b === "	" || b === `
` || b === ";" || b === "&" || b === "|" || b === "(" || b === ")" || b === "<" || b === ">" || b === "'" || b === '"' || b === "\\" || b === "$" || b === "`" || b === "{" || b === "}" || b === "~" || b === "*" || b === "?" || b === "[")
          break;
        o10++;
      }
      if (o10 > a) {
        let b = s10[o10];
        if (!(b === "(" && o10 > a && "@*+?!".includes(s10[o10 - 1]))) {
          if (o10 >= i10 || b === " " || b === "	" || b === `
` || b === ";" || b === "&" || b === "|" || b === "(" || b === ")" || b === "<" || b === ">") {
            let x = s10.slice(a, o10);
            this.pos = o10, this.column = r10 + (o10 - a);
            let S = B0.get(x);
            if (S !== void 0)
              return { type: S, value: x, start: t10, end: o10, line: n10, column: r10 };
            let O = H0(x);
            return O > 0 && z0(x.slice(0, O)) ? { type: E.ASSIGNMENT_WORD, value: x, start: t10, end: o10, line: n10, column: r10 } : /^[0-9]+$/.test(x) ? { type: E.NUMBER, value: x, start: t10, end: o10, line: n10, column: r10 } : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(x) ? { type: E.NAME, value: x, start: t10, end: o10, line: n10, column: r10, quoted: false, singleQuoted: false } : { type: E.WORD, value: x, start: t10, end: o10, line: n10, column: r10, quoted: false, singleQuoted: false };
          }
        }
      }
      o10 = this.pos;
      let l = this.column, c = this.line, u = "", f10 = false, p = false, h = false, m = false, d = s10[o10] === '"' || s10[o10] === "'", g = false, y = 0;
      for (; o10 < i10; ) {
        let b = s10[o10];
        if (!h && !m) {
          if (b === "(" && u.length > 0 && "@*+?!".includes(u[u.length - 1])) {
            let x = this.scanExtglobPattern(o10);
            if (x !== null) {
              u += x.content, o10 = x.end, l += x.content.length;
              continue;
            }
          }
          if (b === "[" && y === 0) {
            if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(u)) {
              let x = o10 + 1 < i10 ? s10[o10 + 1] : "";
              if (x === "^" || x === "!") {
                u += b, o10++, l++;
                continue;
              }
              y = 1, u += b, o10++, l++;
              continue;
            }
          } else if (b === "[" && y > 0) {
            u.length > 0 && u[u.length - 1] !== "\\" && y++, u += b, o10++, l++;
            continue;
          } else if (b === "]" && y > 0) {
            u.length > 0 && u[u.length - 1] !== "\\" && y--, u += b, o10++, l++;
            continue;
          }
          if (y > 0) {
            if (b === `
`)
              break;
            u += b, o10++, l++;
            continue;
          }
          if (b === " " || b === "	" || b === `
` || b === ";" || b === "&" || b === "|" || b === "(" || b === ")" || b === "<" || b === ">")
            break;
        }
        if (b === "$" && o10 + 1 < i10 && s10[o10 + 1] === "'" && !h && !m) {
          for (u += "$'", o10 += 2, l += 2; o10 < i10 && s10[o10] !== "'"; )
            s10[o10] === "\\" && o10 + 1 < i10 ? (u += s10[o10] + s10[o10 + 1], o10 += 2, l += 2) : (u += s10[o10], o10++, l++);
          o10 < i10 && (u += "'", o10++, l++);
          continue;
        }
        if (b === "$" && o10 + 1 < i10 && s10[o10 + 1] === '"' && !h && !m) {
          o10++, l++, m = true, f10 = true, u === "" && (d = true), o10++, l++;
          continue;
        }
        if (b === "'" && !m) {
          if (h)
            if (h = false, !d || g)
              u += b;
            else {
              let x = o10 + 1 < i10 ? s10[o10 + 1] : "";
              x && !j0(x) && x !== "'" && (x === '"' ? (g = true, u += b, p = false, f10 = false) : (g = true, u += b));
            }
          else
            h = true, d && !g ? (p = true, f10 = true) : u += b;
          o10++, l++;
          continue;
        }
        if (b === '"' && !h) {
          if (m)
            if (m = false, !d || g)
              u += b;
            else {
              let x = o10 + 1 < i10 ? s10[o10 + 1] : "";
              x && !j0(x) && x !== '"' && (x === "'" ? (g = true, u += b, p = false, f10 = false) : (g = true, u += b));
            }
          else
            m = true, d && !g ? f10 = true : u += b;
          o10++, l++;
          continue;
        }
        if (b === "\\" && !h && o10 + 1 < i10) {
          let x = s10[o10 + 1];
          if (x === `
`) {
            o10 += 2, c++, l = 1;
            continue;
          }
          if (m) {
            if (x === '"' || x === "\\" || x === "$" || x === "`" || x === `
`) {
              if (x === `
`) {
                o10 += 2, l = 1, c++;
                continue;
              }
              u += b + x, o10 += 2, l += 2;
              continue;
            }
          } else {
            x === "\\" || x === '"' || x === "'" || x === "`" || x === "*" || x === "?" || x === "[" || x === "]" || x === "(" || x === ")" || x === "$" || x === "-" || x === "." || x === "^" || x === "+" || x === "{" || x === "}" ? u += b + x : u += x, o10 += 2, l += 2;
            continue;
          }
        }
        if (b === "$" && o10 + 1 < i10 && s10[o10 + 1] === "(" && !h) {
          u += b, o10++, l++, u += s10[o10], o10++, l++;
          let x = 1, S = false, O = false, R10 = 0, F4 = false, $ = "", z = s10[o10] === "(" && !this.dollarDparenIsSubshell(o10);
          for (; x > 0 && o10 < i10; ) {
            let k = s10[o10];
            if (u += k, S)
              k === "'" && (S = false);
            else if (O)
              k === "\\" && o10 + 1 < i10 ? (u += s10[o10 + 1], o10++, l++) : k === '"' && (O = false);
            else if (k === "'")
              S = true, $ = "";
            else if (k === '"')
              O = true, $ = "";
            else if (k === "\\" && o10 + 1 < i10)
              u += s10[o10 + 1], o10++, l++, $ = "";
            else if (k === "$" && o10 + 1 < i10 && s10[o10 + 1] === "{") {
              o10++, l++, u += s10[o10], o10++, l++;
              let N10 = 1, P = false, v = false;
              for (; N10 > 0 && o10 < i10; ) {
                let T = s10[o10];
                if (T === "\\" && o10 + 1 < i10 && !P) {
                  u += T, o10++, l++, u += s10[o10], o10++, l++;
                  continue;
                }
                u += T, P ? T === "'" && (P = false) : v ? T === '"' && (v = false) : T === "'" ? P = true : T === '"' ? v = true : T === "{" ? N10++ : T === "}" && N10--, T === `
` ? (c++, l = 0) : l++, o10++;
              }
              $ = "";
              continue;
            } else if (k === "#" && !z && ($ === "" || /\s/.test(s10[o10 - 1] || ""))) {
              for (; o10 + 1 < i10 && s10[o10 + 1] !== `
`; )
                o10++, l++, u += s10[o10];
              $ = "";
            } else
              /[a-zA-Z_]/.test(k) ? $ += k : ($ === "case" ? (R10++, F4 = false) : $ === "in" && R10 > 0 ? F4 = true : $ === "esac" && R10 > 0 && (R10--, F4 = false), $ = "", k === "(" ? o10 > 0 && s10[o10 - 1] === "$" ? x++ : F4 || x++ : k === ")" ? F4 ? F4 = false : x-- : k === ";" && R10 > 0 && o10 + 1 < i10 && s10[o10 + 1] === ";" && (F4 = true));
            k === `
` && (c++, l = 0, $ = ""), o10++, l++;
          }
          continue;
        }
        if (b === "$" && o10 + 1 < i10 && s10[o10 + 1] === "[" && !h) {
          u += b, o10++, l++, u += s10[o10], o10++, l++;
          let x = 1;
          for (; x > 0 && o10 < i10; ) {
            let S = s10[o10];
            u += S, S === "[" ? x++ : S === "]" ? x-- : S === `
` && (c++, l = 0), o10++, l++;
          }
          continue;
        }
        if (b === "$" && o10 + 1 < i10 && s10[o10 + 1] === "{" && !h) {
          u += b, o10++, l++, u += s10[o10], o10++, l++;
          let x = 1, S = false, O = false, R10 = c, F4 = l, $ = c, z = l;
          for (; x > 0 && o10 < i10; ) {
            let k = s10[o10];
            if (k === "\\" && o10 + 1 < i10 && s10[o10 + 1] === `
`) {
              o10 += 2, c++, l = 1;
              continue;
            }
            if (k === "\\" && o10 + 1 < i10 && !S) {
              u += k, o10++, l++, u += s10[o10], o10++, l++;
              continue;
            }
            u += k, S ? k === "'" && (S = false) : O ? k === '"' && (O = false) : k === "'" ? (S = true, R10 = c, F4 = l) : k === '"' ? (O = true, $ = c, z = l) : k === "{" ? x++ : k === "}" && x--, k === `
` && (c++, l = 0), o10++, l++;
          }
          if (S)
            throw new Tn("unexpected EOF while looking for matching `''", R10, F4);
          if (O)
            throw new Tn("unexpected EOF while looking for matching `\"'", $, z);
          continue;
        }
        if (b === "$" && o10 + 1 < i10 && !h) {
          let x = s10[o10 + 1];
          if (x === "#" || x === "?" || x === "$" || x === "!" || x === "@" || x === "*" || x === "-" || x >= "0" && x <= "9") {
            u += b + x, o10 += 2, l += 2;
            continue;
          }
        }
        if (b === "`" && !h) {
          for (u += b, o10++, l++; o10 < i10 && s10[o10] !== "`"; ) {
            let x = s10[o10];
            u += x, x === "\\" && o10 + 1 < i10 && (u += s10[o10 + 1], o10++, l++), x === `
` && (c++, l = 0), o10++, l++;
          }
          o10 < i10 && (u += s10[o10], o10++, l++);
          continue;
        }
        u += b, o10++, b === `
` ? (c++, l = 1) : l++;
      }
      if (this.pos = o10, this.column = l, this.line = c, g && d && (u = s10[t10] + u, f10 = false, p = false), h || m) {
        let b = h ? "'" : '"';
        throw new Tn(`unexpected EOF while looking for matching \`${b}'`, n10, r10);
      }
      if (!d && u.length >= 2) {
        if (u[0] === "'" && u[u.length - 1] === "'") {
          let b = u.slice(1, -1);
          !b.includes("'") && !b.includes('"') && (u = b, f10 = true, p = true);
        } else if (u[0] === '"' && u[u.length - 1] === '"') {
          let b = u.slice(1, -1), x = false;
          for (let S = 0; S < b.length; S++) {
            if (b[S] === '"') {
              x = true;
              break;
            }
            b[S] === "\\" && S + 1 < b.length && S++;
          }
          x || (u = b, f10 = true, p = false);
        }
      }
      if (u === "")
        return { type: E.WORD, value: "", start: t10, end: o10, line: n10, column: r10, quoted: f10, singleQuoted: p };
      let w = B0.get(u);
      if (!f10 && w !== void 0)
        return { type: w, value: u, start: t10, end: o10, line: n10, column: r10 };
      if (!d) {
        let b = H0(u);
        if (b > 0 && z0(u.slice(0, b)))
          return { type: E.ASSIGNMENT_WORD, value: u, start: t10, end: o10, line: n10, column: r10, quoted: f10, singleQuoted: p };
      }
      return /^[0-9]+$/.test(u) ? { type: E.NUMBER, value: u, start: t10, end: o10, line: n10, column: r10 } : Ab(u) ? { type: E.NAME, value: u, start: t10, end: o10, line: n10, column: r10, quoted: f10, singleQuoted: p } : { type: E.WORD, value: u, start: t10, end: o10, line: n10, column: r10, quoted: f10, singleQuoted: p };
    }
    readHeredocContent() {
      for (; this.pendingHeredocs.length > 0; ) {
        let t10 = this.pendingHeredocs.shift();
        if (!t10)
          break;
        let n10 = this.pos, r10 = this.line, s10 = this.column, i10 = "";
        for (; this.pos < this.input.length; ) {
          let o10 = this.pos, a = "";
          for (; this.pos < this.input.length && this.input[this.pos] !== `
`; )
            a += this.input[this.pos], this.pos++, this.column++;
          if ((t10.stripTabs ? a.replace(/^\t+/, "") : a) === t10.delimiter) {
            this.pos < this.input.length && this.input[this.pos] === `
` && (this.pos++, this.line++, this.column = 1);
            break;
          }
          if (i10 += a, i10.length > 10485760)
            throw new Tn("Heredoc size limit exceeded (10485760 bytes)", r10, s10);
          this.pos < this.input.length && this.input[this.pos] === `
` && (i10 += `
`, this.pos++, this.line++, this.column = 1);
        }
        this.tokens.push({ type: E.HEREDOC_CONTENT, value: i10, start: n10, end: this.pos, line: r10, column: s10 });
      }
    }
    addPendingHeredoc(t10, n10, r10) {
      this.pendingHeredocs.push({ delimiter: t10, stripTabs: n10, quoted: r10 });
    }
    registerHeredocFromLookahead(t10) {
      let n10 = this.pos, r10 = this.column;
      for (; this.pos < this.input.length && (this.input[this.pos] === " " || this.input[this.pos] === "	"); )
        this.pos++, this.column++;
      let s10 = "", i10 = false;
      for (; this.pos < this.input.length; ) {
        let o10 = this.input[this.pos];
        if (/[\s;<>&|()]/.test(o10))
          break;
        if (o10 === "'" || o10 === '"') {
          i10 = true;
          let a = o10;
          for (this.pos++, this.column++; this.pos < this.input.length && this.input[this.pos] !== a; )
            s10 += this.input[this.pos], this.pos++, this.column++;
          this.pos < this.input.length && this.input[this.pos] === a && (this.pos++, this.column++);
        } else
          o10 === "\\" ? (i10 = true, this.pos++, this.column++, this.pos < this.input.length && (s10 += this.input[this.pos], this.pos++, this.column++)) : (s10 += o10, this.pos++, this.column++);
      }
      this.pos = n10, this.column = r10, s10 && this.pendingHeredocs.push({ delimiter: s10, stripTabs: t10, quoted: i10 });
    }
    isWordCharFollowing(t10) {
      if (t10 >= this.input.length)
        return false;
      let n10 = this.input[t10];
      return !(n10 === " " || n10 === "	" || n10 === `
` || n10 === ";" || n10 === "&" || n10 === "|" || n10 === "(" || n10 === ")" || n10 === "<" || n10 === ">");
    }
    readWordWithBraceExpansion(t10, n10, r10) {
      let s10 = this.input, i10 = s10.length, o10 = t10, a = r10;
      for (; o10 < i10; ) {
        let c = s10[o10];
        if (c === " " || c === "	" || c === `
` || c === ";" || c === "&" || c === "|" || c === "(" || c === ")" || c === "<" || c === ">")
          break;
        if (c === "{") {
          if (this.scanBraceExpansion(o10) !== null) {
            let f10 = 1;
            for (o10++, a++; o10 < i10 && f10 > 0; )
              s10[o10] === "{" ? f10++ : s10[o10] === "}" && f10--, o10++, a++;
            continue;
          }
          o10++, a++;
          continue;
        }
        if (c === "}") {
          o10++, a++;
          continue;
        }
        if (c === "$" && o10 + 1 < i10 && s10[o10 + 1] === "(") {
          o10++, a++, o10++, a++;
          let u = 1;
          for (; u > 0 && o10 < i10; )
            s10[o10] === "(" ? u++ : s10[o10] === ")" && u--, o10++, a++;
          continue;
        }
        if (c === "$" && o10 + 1 < i10 && s10[o10 + 1] === "{") {
          o10++, a++, o10++, a++;
          let u = 1;
          for (; u > 0 && o10 < i10; )
            s10[o10] === "{" ? u++ : s10[o10] === "}" && u--, o10++, a++;
          continue;
        }
        if (c === "`") {
          for (o10++, a++; o10 < i10 && s10[o10] !== "`"; )
            s10[o10] === "\\" && o10 + 1 < i10 ? (o10 += 2, a += 2) : (o10++, a++);
          o10 < i10 && (o10++, a++);
          continue;
        }
        o10++, a++;
      }
      let l = s10.slice(t10, o10);
      return this.pos = o10, this.column = a, { type: E.WORD, value: l, start: t10, end: o10, line: n10, column: r10, quoted: false, singleQuoted: false };
    }
    scanBraceExpansion(t10) {
      let n10 = this.input, r10 = n10.length, s10 = t10 + 1, i10 = 1, o10 = false, a = false;
      for (; s10 < r10 && i10 > 0; ) {
        let l = n10[s10];
        if (l === "{")
          i10++, s10++;
        else if (l === "}")
          i10--, s10++;
        else if (l === "," && i10 === 1)
          o10 = true, s10++;
        else if (l === "." && s10 + 1 < r10 && n10[s10 + 1] === ".")
          a = true, s10 += 2;
        else {
          if (l === " " || l === "	" || l === `
` || l === ";" || l === "&" || l === "|")
            return null;
          s10++;
        }
      }
      return i10 === 0 && (o10 || a) ? n10.slice(t10, s10) : null;
    }
    scanLiteralBraceWord(t10) {
      let n10 = this.input, r10 = n10.length, s10 = t10 + 1, i10 = 1;
      for (; s10 < r10 && i10 > 0; ) {
        let o10 = n10[s10];
        if (o10 === "{")
          i10++, s10++;
        else if (o10 === "}") {
          if (i10--, i10 === 0)
            return n10.slice(t10, s10 + 1);
          s10++;
        } else {
          if (o10 === " " || o10 === "	" || o10 === `
` || o10 === ";" || o10 === "&" || o10 === "|")
            return null;
          s10++;
        }
      }
      return null;
    }
    scanExtglobPattern(t10) {
      let n10 = this.input, r10 = n10.length, s10 = t10 + 1, i10 = 1;
      for (; s10 < r10 && i10 > 0; ) {
        let o10 = n10[s10];
        if (o10 === "\\" && s10 + 1 < r10) {
          s10 += 2;
          continue;
        }
        if ("@*+?!".includes(o10) && s10 + 1 < r10 && n10[s10 + 1] === "(") {
          s10++, i10++, s10++;
          continue;
        }
        if (o10 === "(")
          i10++, s10++;
        else if (o10 === ")")
          i10--, s10++;
        else {
          if (o10 === `
`)
            return null;
          s10++;
        }
      }
      return i10 === 0 ? { content: n10.slice(t10, s10), end: s10 } : null;
    }
    scanFdVariable(t10) {
      let n10 = this.input, r10 = n10.length, s10 = t10 + 1, i10 = s10;
      for (; s10 < r10; ) {
        let u = n10[s10];
        if (s10 === i10) {
          if (!(u >= "a" && u <= "z" || u >= "A" && u <= "Z" || u === "_"))
            return null;
        } else if (!(u >= "a" && u <= "z" || u >= "A" && u <= "Z" || u >= "0" && u <= "9" || u === "_"))
          break;
        s10++;
      }
      if (s10 === i10)
        return null;
      let o10 = n10.slice(i10, s10);
      if (s10 >= r10 || n10[s10] !== "}" || (s10++, s10 >= r10))
        return null;
      let a = n10[s10], l = s10 + 1 < r10 ? n10[s10 + 1] : "";
      return a === ">" || a === "<" || a === "&" && (l === ">" || l === "<") ? { varname: o10, end: s10 } : null;
    }
    dollarDparenIsSubshell(t10) {
      let n10 = this.input, r10 = n10.length, s10 = t10 + 1, i10 = 2, o10 = false, a = false, l = false;
      for (; s10 < r10 && i10 > 0; ) {
        let c = n10[s10];
        if (o10) {
          c === "'" && (o10 = false), c === `
` && (l = true), s10++;
          continue;
        }
        if (a) {
          if (c === "\\") {
            s10 += 2;
            continue;
          }
          c === '"' && (a = false), c === `
` && (l = true), s10++;
          continue;
        }
        if (c === "'") {
          o10 = true, s10++;
          continue;
        }
        if (c === '"') {
          a = true, s10++;
          continue;
        }
        if (c === "\\") {
          s10 += 2;
          continue;
        }
        if (c === `
` && (l = true), c === "(") {
          i10++, s10++;
          continue;
        }
        if (c === ")") {
          if (i10--, i10 === 1) {
            let u = s10 + 1;
            if (u < r10 && n10[u] === ")")
              return false;
            let f10 = u, p = false;
            for (; f10 < r10 && (n10[f10] === " " || n10[f10] === "	" || n10[f10] === `
`); )
              p = true, f10++;
            if (p && f10 < r10 && n10[f10] === ")" || l)
              return true;
          }
          if (i10 === 0)
            return false;
          s10++;
          continue;
        }
        s10++;
      }
      return false;
    }
    dparenClosesWithSpacedParens(t10) {
      let n10 = this.input, r10 = n10.length, s10 = t10, i10 = 2, o10 = false, a = false;
      for (; s10 < r10 && i10 > 0; ) {
        let l = n10[s10];
        if (o10) {
          l === "'" && (o10 = false), s10++;
          continue;
        }
        if (a) {
          if (l === "\\") {
            s10 += 2;
            continue;
          }
          l === '"' && (a = false), s10++;
          continue;
        }
        if (l === "'") {
          o10 = true, s10++;
          continue;
        }
        if (l === '"') {
          a = true, s10++;
          continue;
        }
        if (l === "\\") {
          s10 += 2;
          continue;
        }
        if (l === "(") {
          i10++, s10++;
          continue;
        }
        if (l === ")") {
          if (i10--, i10 === 1) {
            let c = s10 + 1;
            if (c < r10 && n10[c] === ")")
              return false;
            let u = c, f10 = false;
            for (; u < r10 && (n10[u] === " " || n10[u] === "	" || n10[u] === `
`); )
              f10 = true, u++;
            if (f10 && u < r10 && n10[u] === ")")
              return true;
          }
          if (i10 === 0)
            return false;
          s10++;
          continue;
        }
        if (i10 === 1 && (l === "|" && s10 + 1 < r10 && n10[s10 + 1] === "|" || l === "&" && s10 + 1 < r10 && n10[s10 + 1] === "&" || l === "|" && s10 + 1 < r10 && n10[s10 + 1] !== "|"))
          return true;
        s10++;
      }
      return false;
    }
  };
});
var Al;
var Sl;
var G0;
var Cl;
var V0;
var q0;
var Z0;
var ot;
var er = I(() => {
  "use strict";
  Pn();
  Al = 1e6, Sl = 1e5, G0 = 1e6, Cl = 200, V0 = /* @__PURE__ */ new Set([E.LESS, E.GREAT, E.DLESS, E.DGREAT, E.LESSAND, E.GREATAND, E.LESSGREAT, E.DLESSDASH, E.CLOBBER, E.TLESS, E.AND_GREAT, E.AND_DGREAT]), q0 = /* @__PURE__ */ new Set([E.LESS, E.GREAT, E.DLESS, E.DGREAT, E.LESSAND, E.GREATAND, E.LESSGREAT, E.DLESSDASH, E.CLOBBER, E.TLESS]), Z0 = /* @__PURE__ */ new Set([E.LESS, E.GREAT, E.DLESS, E.DGREAT, E.LESSAND, E.GREATAND, E.LESSGREAT, E.DLESSDASH, E.CLOBBER, E.TLESS, E.AND_GREAT, E.AND_DGREAT]), ot = class extends Error {
    line;
    column;
    token;
    constructor(t10, n10, r10, s10 = void 0) {
      super(`Parse error at ${n10}:${r10}: ${t10}`), this.line = n10, this.column = r10, this.token = s10, this.name = "ParseException";
    }
  };
});
var q;
var tr = I(() => {
  "use strict";
  q = { script(e11) {
    return { type: "Script", statements: e11 };
  }, statement(e11, t10 = [], n10 = false, r10, s10) {
    let i10 = { type: "Statement", pipelines: e11, operators: t10, background: n10 };
    return r10 && (i10.deferredError = r10), s10 !== void 0 && (i10.sourceText = s10), i10;
  }, pipeline(e11, t10 = false, n10 = false, r10 = false, s10) {
    return { type: "Pipeline", commands: e11, negated: t10, timed: n10, timePosix: r10, pipeStderr: s10 };
  }, simpleCommand(e11, t10 = [], n10 = [], r10 = []) {
    return { type: "SimpleCommand", name: e11, args: t10, assignments: n10, redirections: r10 };
  }, word(e11) {
    return { type: "Word", parts: e11 };
  }, literal(e11) {
    return { type: "Literal", value: e11 };
  }, singleQuoted(e11) {
    return { type: "SingleQuoted", value: e11 };
  }, doubleQuoted(e11) {
    return { type: "DoubleQuoted", parts: e11 };
  }, escaped(e11) {
    return { type: "Escaped", value: e11 };
  }, parameterExpansion(e11, t10 = null) {
    return { type: "ParameterExpansion", parameter: e11, operation: t10 };
  }, commandSubstitution(e11, t10 = false) {
    return { type: "CommandSubstitution", body: e11, legacy: t10 };
  }, arithmeticExpansion(e11) {
    return { type: "ArithmeticExpansion", expression: e11 };
  }, assignment(e11, t10, n10 = false, r10 = null) {
    return { type: "Assignment", name: e11, value: t10, append: n10, array: r10 };
  }, redirection(e11, t10, n10 = null, r10) {
    let s10 = { type: "Redirection", fd: n10, operator: e11, target: t10 };
    return r10 && (s10.fdVariable = r10), s10;
  }, hereDoc(e11, t10, n10 = false, r10 = false) {
    return { type: "HereDoc", delimiter: e11, content: t10, stripTabs: n10, quoted: r10 };
  }, ifNode(e11, t10 = null, n10 = []) {
    return { type: "If", clauses: e11, elseBody: t10, redirections: n10 };
  }, forNode(e11, t10, n10, r10 = []) {
    return { type: "For", variable: e11, words: t10, body: n10, redirections: r10 };
  }, whileNode(e11, t10, n10 = []) {
    return { type: "While", condition: e11, body: t10, redirections: n10 };
  }, untilNode(e11, t10, n10 = []) {
    return { type: "Until", condition: e11, body: t10, redirections: n10 };
  }, caseNode(e11, t10, n10 = []) {
    return { type: "Case", word: e11, items: t10, redirections: n10 };
  }, caseItem(e11, t10, n10 = ";;") {
    return { type: "CaseItem", patterns: e11, body: t10, terminator: n10 };
  }, subshell(e11, t10 = []) {
    return { type: "Subshell", body: e11, redirections: t10 };
  }, group(e11, t10 = []) {
    return { type: "Group", body: e11, redirections: t10 };
  }, functionDef(e11, t10, n10 = [], r10) {
    return { type: "FunctionDef", name: e11, body: t10, redirections: n10, sourceFile: r10 };
  }, conditionalCommand(e11, t10 = [], n10) {
    return { type: "ConditionalCommand", expression: e11, redirections: t10, line: n10 };
  }, arithmeticCommand(e11, t10 = [], n10) {
    return { type: "ArithmeticCommand", expression: e11, redirections: t10, line: n10 };
  } };
});
function We(e11, t10) {
  for (; t10 < e11.length; ) {
    if (e11[t10] === "\\" && e11[t10 + 1] === `
`) {
      t10 += 2;
      continue;
    }
    if (/\s/.test(e11[t10])) {
      t10++;
      continue;
    }
    break;
  }
  return t10;
}
function ws(e11) {
  if (e11.includes("#")) {
    let [t10, n10] = e11.split("#"), r10 = Number.parseInt(t10, 10);
    if (r10 < 2 || r10 > 64)
      return Number.NaN;
    if (r10 <= 36)
      return Number.parseInt(n10, r10);
    let s10 = 0;
    for (let i10 of n10) {
      let o10;
      if (/[0-9]/.test(i10))
        o10 = i10.charCodeAt(0) - 48;
      else if (/[a-z]/.test(i10))
        o10 = i10.charCodeAt(0) - 97 + 10;
      else if (/[A-Z]/.test(i10))
        o10 = i10.charCodeAt(0) - 65 + 36;
      else if (i10 === "@")
        o10 = 62;
      else if (i10 === "_")
        o10 = 63;
      else
        return Number.NaN;
      if (o10 >= r10)
        return Number.NaN;
      s10 = s10 * r10 + o10;
    }
    return s10;
  }
  return e11.startsWith("0x") || e11.startsWith("0X") ? Number.parseInt(e11.slice(2), 16) : e11.startsWith("0") && e11.length > 1 && /^[0-9]+$/.test(e11) ? /[89]/.test(e11) ? Number.NaN : Number.parseInt(e11, 8) : Number.parseInt(e11, 10);
}
function Q0(e11, t10, n10, r10) {
  if (n10.slice(r10, r10 + 3) !== "$((")
    return null;
  let s10 = r10 + 3, i10 = 1, o10 = s10;
  for (; s10 < n10.length - 1 && i10 > 0; )
    n10[s10] === "(" && n10[s10 + 1] === "(" ? (i10++, s10 += 2) : n10[s10] === ")" && n10[s10 + 1] === ")" ? (i10--, i10 > 0 && (s10 += 2)) : s10++;
  let a = n10.slice(o10, s10), { expr: l } = e11(t10, a, 0);
  return s10 += 2, { expr: { type: "ArithNested", expression: l }, pos: s10 };
}
function K0(e11, t10) {
  if (e11.slice(t10, t10 + 2) !== "$'")
    return null;
  let n10 = t10 + 2, r10 = "";
  for (; n10 < e11.length && e11[n10] !== "'"; )
    if (e11[n10] === "\\" && n10 + 1 < e11.length) {
      let i10 = e11[n10 + 1];
      switch (i10) {
        case "n":
          r10 += `
`;
          break;
        case "t":
          r10 += "	";
          break;
        case "r":
          r10 += "\r";
          break;
        case "\\":
          r10 += "\\";
          break;
        case "'":
          r10 += "'";
          break;
        default:
          r10 += i10;
      }
      n10 += 2;
    } else
      r10 += e11[n10], n10++;
  e11[n10] === "'" && n10++;
  let s10 = Number.parseInt(r10, 10);
  return { expr: { type: "ArithNumber", value: Number.isNaN(s10) ? 0 : s10 }, pos: n10 };
}
function X0(e11, t10) {
  if (e11.slice(t10, t10 + 2) !== '$"')
    return null;
  let n10 = t10 + 2, r10 = "";
  for (; n10 < e11.length && e11[n10] !== '"'; )
    e11[n10] === "\\" && n10 + 1 < e11.length ? (r10 += e11[n10 + 1], n10 += 2) : (r10 += e11[n10], n10++);
  e11[n10] === '"' && n10++;
  let s10 = Number.parseInt(r10, 10);
  return { expr: { type: "ArithNumber", value: Number.isNaN(s10) ? 0 : s10 }, pos: n10 };
}
var Ui;
var Y0 = I(() => {
  "use strict";
  Ui = ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", "&=", "|=", "^="];
});
function Sb(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; )
    if (e11[n10] === '"') {
      for (n10++; n10 < e11.length && e11[n10] !== '"'; )
        e11[n10] === "\\" && n10 + 1 < e11.length ? (t10 += e11[n10 + 1], n10 += 2) : (t10 += e11[n10], n10++);
      n10 < e11.length && n10++;
    } else
      t10 += e11[n10], n10++;
  return t10;
}
function Ae(e11, t10) {
  let n10 = Sb(t10), { expr: r10, pos: s10 } = Bt(e11, n10, 0), i10 = We(n10, s10);
  if (i10 < n10.length) {
    let o10 = t10.slice(i10).trim();
    if (o10)
      return { type: "ArithmeticExpression", originalText: t10, expression: { type: "ArithSyntaxError", errorToken: o10, message: `${o10}: syntax error: invalid arithmetic operator (error token is "${o10}")` } };
  }
  return { type: "ArithmeticExpression", expression: r10, originalText: t10 };
}
function Rt(e11, t10) {
  return { expr: { type: "ArithSyntaxError", errorToken: e11, message: `syntax error: operand expected (error token is "${e11}")` }, pos: t10 };
}
function $t(e11, t10) {
  return We(e11, t10) >= e11.length;
}
function Bt(e11, t10, n10) {
  return Cb(e11, t10, n10);
}
function Cb(e11, t10, n10) {
  let { expr: r10, pos: s10 } = bs(e11, t10, n10);
  for (s10 = We(t10, s10); t10[s10] === ","; ) {
    if (s10++, $t(t10, s10))
      return Rt(",", s10);
    let { expr: o10, pos: a } = bs(e11, t10, s10);
    r10 = { type: "ArithBinary", operator: ",", left: r10, right: o10 }, s10 = We(t10, a);
  }
  return { expr: r10, pos: s10 };
}
function bs(e11, t10, n10) {
  let { expr: r10, pos: s10 } = Nb(e11, t10, n10);
  if (s10 = We(t10, s10), t10[s10] === "?") {
    s10++;
    let { expr: i10, pos: o10 } = Bt(e11, t10, s10);
    if (s10 = We(t10, o10), t10[s10] === ":") {
      s10++;
      let { expr: a, pos: l } = Bt(e11, t10, s10);
      return { expr: { type: "ArithTernary", condition: r10, consequent: i10, alternate: a }, pos: l };
    }
  }
  return { expr: r10, pos: s10 };
}
function Nb(e11, t10, n10) {
  let { expr: r10, pos: s10 } = J0(e11, t10, n10);
  for (; s10 = We(t10, s10), t10.slice(s10, s10 + 2) === "||"; ) {
    if (s10 += 2, $t(t10, s10))
      return Rt("||", s10);
    let { expr: o10, pos: a } = J0(e11, t10, s10);
    r10 = { type: "ArithBinary", operator: "||", left: r10, right: o10 }, s10 = a;
  }
  return { expr: r10, pos: s10 };
}
function J0(e11, t10, n10) {
  let { expr: r10, pos: s10 } = em(e11, t10, n10);
  for (; s10 = We(t10, s10), t10.slice(s10, s10 + 2) === "&&"; ) {
    if (s10 += 2, $t(t10, s10))
      return Rt("&&", s10);
    let { expr: o10, pos: a } = em(e11, t10, s10);
    r10 = { type: "ArithBinary", operator: "&&", left: r10, right: o10 }, s10 = a;
  }
  return { expr: r10, pos: s10 };
}
function em(e11, t10, n10) {
  let { expr: r10, pos: s10 } = tm(e11, t10, n10);
  for (; s10 = We(t10, s10), t10[s10] === "|" && t10[s10 + 1] !== "|"; ) {
    if (s10++, $t(t10, s10))
      return Rt("|", s10);
    let { expr: o10, pos: a } = tm(e11, t10, s10);
    r10 = { type: "ArithBinary", operator: "|", left: r10, right: o10 }, s10 = a;
  }
  return { expr: r10, pos: s10 };
}
function tm(e11, t10, n10) {
  let { expr: r10, pos: s10 } = nm(e11, t10, n10);
  for (; s10 = We(t10, s10), t10[s10] === "^"; ) {
    if (s10++, $t(t10, s10))
      return Rt("^", s10);
    let { expr: o10, pos: a } = nm(e11, t10, s10);
    r10 = { type: "ArithBinary", operator: "^", left: r10, right: o10 }, s10 = a;
  }
  return { expr: r10, pos: s10 };
}
function nm(e11, t10, n10) {
  let { expr: r10, pos: s10 } = rm(e11, t10, n10);
  for (; s10 = We(t10, s10), t10[s10] === "&" && t10[s10 + 1] !== "&"; ) {
    if (s10++, $t(t10, s10))
      return Rt("&", s10);
    let { expr: o10, pos: a } = rm(e11, t10, s10);
    r10 = { type: "ArithBinary", operator: "&", left: r10, right: o10 }, s10 = a;
  }
  return { expr: r10, pos: s10 };
}
function rm(e11, t10, n10) {
  let { expr: r10, pos: s10 } = sm(e11, t10, n10);
  for (; s10 = We(t10, s10), t10.slice(s10, s10 + 2) === "==" || t10.slice(s10, s10 + 2) === "!="; ) {
    let i10 = t10.slice(s10, s10 + 2);
    if (s10 += 2, $t(t10, s10))
      return Rt(i10, s10);
    let { expr: o10, pos: a } = sm(e11, t10, s10);
    r10 = { type: "ArithBinary", operator: i10, left: r10, right: o10 }, s10 = a;
  }
  return { expr: r10, pos: s10 };
}
function sm(e11, t10, n10) {
  let { expr: r10, pos: s10 } = Nl(e11, t10, n10);
  for (; ; )
    if (s10 = We(t10, s10), t10.slice(s10, s10 + 2) === "<=" || t10.slice(s10, s10 + 2) === ">=") {
      let i10 = t10.slice(s10, s10 + 2);
      if (s10 += 2, $t(t10, s10))
        return Rt(i10, s10);
      let { expr: o10, pos: a } = Nl(e11, t10, s10);
      r10 = { type: "ArithBinary", operator: i10, left: r10, right: o10 }, s10 = a;
    } else if (t10[s10] === "<" || t10[s10] === ">") {
      let i10 = t10[s10];
      if (s10++, $t(t10, s10))
        return Rt(i10, s10);
      let { expr: o10, pos: a } = Nl(e11, t10, s10);
      r10 = { type: "ArithBinary", operator: i10, left: r10, right: o10 }, s10 = a;
    } else
      break;
  return { expr: r10, pos: s10 };
}
function Nl(e11, t10, n10) {
  let { expr: r10, pos: s10 } = im(e11, t10, n10);
  for (; s10 = We(t10, s10), t10.slice(s10, s10 + 2) === "<<" || t10.slice(s10, s10 + 2) === ">>"; ) {
    let i10 = t10.slice(s10, s10 + 2);
    if (s10 += 2, $t(t10, s10))
      return Rt(i10, s10);
    let { expr: o10, pos: a } = im(e11, t10, s10);
    r10 = { type: "ArithBinary", operator: i10, left: r10, right: o10 }, s10 = a;
  }
  return { expr: r10, pos: s10 };
}
function im(e11, t10, n10) {
  let { expr: r10, pos: s10 } = om(e11, t10, n10);
  for (; s10 = We(t10, s10), (t10[s10] === "+" || t10[s10] === "-") && t10[s10 + 1] !== t10[s10]; ) {
    let i10 = t10[s10];
    if (s10++, $t(t10, s10))
      return Rt(i10, s10);
    let { expr: o10, pos: a } = om(e11, t10, s10);
    r10 = { type: "ArithBinary", operator: i10, left: r10, right: o10 }, s10 = a;
  }
  return { expr: r10, pos: s10 };
}
function om(e11, t10, n10) {
  let { expr: r10, pos: s10 } = Wi(e11, t10, n10);
  for (; ; )
    if (s10 = We(t10, s10), t10[s10] === "*" && t10[s10 + 1] !== "*") {
      if (s10++, $t(t10, s10))
        return Rt("*", s10);
      let { expr: o10, pos: a } = Wi(e11, t10, s10);
      r10 = { type: "ArithBinary", operator: "*", left: r10, right: o10 }, s10 = a;
    } else if (t10[s10] === "/" || t10[s10] === "%") {
      let i10 = t10[s10];
      if (s10++, $t(t10, s10))
        return Rt(i10, s10);
      let { expr: o10, pos: a } = Wi(e11, t10, s10);
      r10 = { type: "ArithBinary", operator: i10, left: r10, right: o10 }, s10 = a;
    } else
      break;
  return { expr: r10, pos: s10 };
}
function Wi(e11, t10, n10) {
  let { expr: r10, pos: s10 } = kl(e11, t10, n10), i10 = We(t10, s10);
  if (t10.slice(i10, i10 + 2) === "**") {
    if (i10 += 2, $t(t10, i10))
      return Rt("**", i10);
    let { expr: a, pos: l } = Wi(e11, t10, i10);
    return { expr: { type: "ArithBinary", operator: "**", left: r10, right: a }, pos: l };
  }
  return { expr: r10, pos: s10 };
}
function kl(e11, t10, n10) {
  let r10 = We(t10, n10);
  if (t10.slice(r10, r10 + 2) === "++" || t10.slice(r10, r10 + 2) === "--") {
    let s10 = t10.slice(r10, r10 + 2);
    r10 += 2;
    let { expr: i10, pos: o10 } = kl(e11, t10, r10);
    return { expr: { type: "ArithUnary", operator: s10, operand: i10, prefix: true }, pos: o10 };
  }
  if (t10[r10] === "+" || t10[r10] === "-" || t10[r10] === "!" || t10[r10] === "~") {
    let s10 = t10[r10];
    r10++;
    let { expr: i10, pos: o10 } = kl(e11, t10, r10);
    return { expr: { type: "ArithUnary", operator: s10, operand: i10, prefix: true }, pos: o10 };
  }
  return vb(e11, t10, r10);
}
function kb(e11, t10) {
  let n10 = e11[t10];
  return n10 === "$" || n10 === "`";
}
function vb(e11, t10, n10) {
  let { expr: r10, pos: s10 } = am(e11, t10, n10, false), i10 = [r10];
  for (; kb(t10, s10); ) {
    let { expr: a, pos: l } = am(e11, t10, s10, true);
    i10.push(a), s10 = l;
  }
  i10.length > 1 && (r10 = { type: "ArithConcat", parts: i10 });
  let o10;
  if (t10[s10] === "[" && r10.type === "ArithConcat") {
    s10++;
    let { expr: a, pos: l } = Bt(e11, t10, s10);
    o10 = a, s10 = l, t10[s10] === "]" && s10++;
  }
  if (o10 && r10.type === "ArithConcat" && (r10 = { type: "ArithDynamicElement", nameExpr: r10, subscript: o10 }, o10 = void 0), s10 = We(t10, s10), r10.type === "ArithConcat" || r10.type === "ArithVariable" || r10.type === "ArithDynamicElement") {
    for (let a of Ui)
      if (t10.slice(s10, s10 + a.length) === a && t10.slice(s10, s10 + a.length + 1) !== "==") {
        s10 += a.length;
        let { expr: l, pos: c } = bs(e11, t10, s10);
        return r10.type === "ArithDynamicElement" ? { expr: { type: "ArithDynamicAssignment", operator: a, target: r10.nameExpr, subscript: r10.subscript, value: l }, pos: c } : r10.type === "ArithConcat" ? { expr: { type: "ArithDynamicAssignment", operator: a, target: r10, value: l }, pos: c } : { expr: { type: "ArithAssignment", operator: a, variable: r10.name, value: l }, pos: c };
      }
  }
  if (t10.slice(s10, s10 + 2) === "++" || t10.slice(s10, s10 + 2) === "--") {
    let a = t10.slice(s10, s10 + 2);
    return s10 += 2, { expr: { type: "ArithUnary", operator: a, operand: r10, prefix: false }, pos: s10 };
  }
  return { expr: r10, pos: s10 };
}
function am(e11, t10, n10, r10 = false) {
  let s10 = We(t10, n10), i10 = Q0(Bt, e11, t10, s10);
  if (i10)
    return i10;
  let o10 = K0(t10, s10);
  if (o10)
    return o10;
  let a = X0(t10, s10);
  if (a)
    return a;
  if (t10.slice(s10, s10 + 2) === "$(" && t10[s10 + 2] !== "(") {
    s10 += 2;
    let c = 1, u = s10;
    for (; s10 < t10.length && c > 0; )
      t10[s10] === "(" ? c++ : t10[s10] === ")" && c--, c > 0 && s10++;
    let f10 = t10.slice(u, s10);
    return s10++, { expr: { type: "ArithCommandSubst", command: f10 }, pos: s10 };
  }
  if (t10[s10] === "`") {
    s10++;
    let c = s10;
    for (; s10 < t10.length && t10[s10] !== "`"; )
      s10++;
    let u = t10.slice(c, s10);
    return t10[s10] === "`" && s10++, { expr: { type: "ArithCommandSubst", command: u }, pos: s10 };
  }
  if (t10[s10] === "(") {
    s10++;
    let { expr: c, pos: u } = Bt(e11, t10, s10);
    return s10 = We(t10, u), t10[s10] === ")" && s10++, { expr: { type: "ArithGroup", expression: c }, pos: s10 };
  }
  if (t10[s10] === "'") {
    s10++;
    let c = "";
    for (; s10 < t10.length && t10[s10] !== "'"; )
      c += t10[s10], s10++;
    t10[s10] === "'" && s10++;
    let u = Number.parseInt(c, 10);
    return { expr: { type: "ArithSingleQuote", content: c, value: Number.isNaN(u) ? 0 : u }, pos: s10 };
  }
  if (t10[s10] === '"') {
    s10++;
    let c = "";
    for (; s10 < t10.length && t10[s10] !== '"'; )
      t10[s10] === "\\" && s10 + 1 < t10.length ? (c += t10[s10 + 1], s10 += 2) : (c += t10[s10], s10++);
    t10[s10] === '"' && s10++;
    let u = c.trim();
    if (!u)
      return { expr: { type: "ArithNumber", value: 0 }, pos: s10 };
    let { expr: f10 } = Bt(e11, u, 0);
    return { expr: f10, pos: s10 };
  }
  if (/[0-9]/.test(t10[s10])) {
    let c = "", u = false, f10 = false;
    for (; s10 < t10.length; ) {
      let h = t10[s10];
      if (u)
        if (/[0-9a-zA-Z@_]/.test(h))
          c += h, s10++;
        else
          break;
      else if (h === "#")
        u = true, c += h, s10++;
      else if (c === "0" && (h === "x" || h === "X") && s10 + 1 < t10.length && /[0-9a-fA-F]/.test(t10[s10 + 1]))
        f10 = true, c += h, s10++;
      else if (f10 && /[0-9a-fA-F]/.test(h))
        c += h, s10++;
      else if (!f10 && /[0-9]/.test(h))
        c += h, s10++;
      else
        break;
    }
    if (s10 < t10.length && /[a-zA-Z_]/.test(t10[s10])) {
      let h = c;
      for (; s10 < t10.length && /[a-zA-Z0-9_]/.test(t10[s10]); )
        h += t10[s10], s10++;
      return { expr: { type: "ArithSyntaxError", errorToken: h, message: `${h}: value too great for base (error token is "${h}")` }, pos: s10 };
    }
    if (t10[s10] === "." && /[0-9]/.test(t10[s10 + 1]))
      throw new $e(`${c}.${t10[s10 + 1]}...: syntax error: invalid arithmetic operator`);
    if (t10[s10] === "[") {
      let h = t10.slice(s10).trim();
      return { expr: { type: "ArithNumberSubscript", number: c, errorToken: h }, pos: t10.length };
    }
    return { expr: { type: "ArithNumber", value: ws(c) }, pos: s10 };
  }
  if (t10[s10] === "$" && t10[s10 + 1] === "{") {
    let c = s10 + 2, u = 1, f10 = c;
    for (; f10 < t10.length && u > 0; )
      t10[f10] === "{" ? u++ : t10[f10] === "}" && u--, u > 0 && f10++;
    let p = t10.slice(c, f10), h = f10 + 1;
    if (t10[h] === "#") {
      let m = h + 1;
      for (; m < t10.length && /[0-9a-zA-Z@_]/.test(t10[m]); )
        m++;
      let d = t10.slice(h + 1, m);
      return { expr: { type: "ArithDynamicBase", baseExpr: p, value: d }, pos: m };
    }
    if (/[0-9]/.test(t10[h]) || t10[h] === "x" || t10[h] === "X") {
      let m = h;
      if (t10[h] === "x" || t10[h] === "X")
        for (m++; m < t10.length && /[0-9a-fA-F]/.test(t10[m]); )
          m++;
      else
        for (; m < t10.length && /[0-9]/.test(t10[m]); )
          m++;
      let d = t10.slice(h, m);
      return { expr: { type: "ArithDynamicNumber", prefix: p, suffix: d }, pos: m };
    }
    return s10 = h, { expr: { type: "ArithBracedExpansion", content: p }, pos: s10 };
  }
  if (t10[s10] === "$" && s10 + 1 < t10.length && /[0-9]/.test(t10[s10 + 1])) {
    s10++;
    let c = "";
    for (; s10 < t10.length && /[0-9]/.test(t10[s10]); )
      c += t10[s10], s10++;
    return { expr: { type: "ArithVariable", name: c, hasDollarPrefix: true }, pos: s10 };
  }
  if (t10[s10] === "$" && s10 + 1 < t10.length && /[*@#?\-!$]/.test(t10[s10 + 1])) {
    let c = t10[s10 + 1];
    return s10 += 2, { expr: { type: "ArithSpecialVar", name: c }, pos: s10 };
  }
  let l = false;
  if (t10[s10] === "$" && s10 + 1 < t10.length && /[a-zA-Z_]/.test(t10[s10 + 1]) && (l = true, s10++), s10 < t10.length && /[a-zA-Z_]/.test(t10[s10])) {
    let c = "";
    for (; s10 < t10.length && /[a-zA-Z0-9_]/.test(t10[s10]); )
      c += t10[s10], s10++;
    if (t10[s10] === "[" && !r10) {
      s10++;
      let u;
      if (t10[s10] === "'" || t10[s10] === '"') {
        let p = t10[s10];
        for (s10++, u = ""; s10 < t10.length && t10[s10] !== p; )
          u += t10[s10], s10++;
        t10[s10] === p && s10++, s10 = We(t10, s10), t10[s10] === "]" && s10++;
      }
      let f10;
      if (u === void 0) {
        let { expr: p, pos: h } = Bt(e11, t10, s10);
        f10 = p, s10 = h, t10[s10] === "]" && s10++;
      }
      if (s10 = We(t10, s10), t10[s10] === "[" && f10)
        return { expr: { type: "ArithDoubleSubscript", array: c, index: f10 }, pos: s10 };
      if (!r10) {
        for (let p of Ui)
          if (t10.slice(s10, s10 + p.length) === p && t10.slice(s10, s10 + p.length + 1) !== "==") {
            s10 += p.length;
            let { expr: h, pos: m } = bs(e11, t10, s10);
            return { expr: { type: "ArithAssignment", operator: p, variable: c, subscript: f10, stringKey: u, value: h }, pos: m };
          }
      }
      return { expr: { type: "ArithArrayElement", array: c, index: f10, stringKey: u }, pos: s10 };
    }
    if (s10 = We(t10, s10), !r10) {
      for (let u of Ui)
        if (t10.slice(s10, s10 + u.length) === u && t10.slice(s10, s10 + u.length + 1) !== "==") {
          s10 += u.length;
          let { expr: f10, pos: p } = bs(e11, t10, s10);
          return { expr: { type: "ArithAssignment", operator: u, variable: c, value: f10 }, pos: p };
        }
    }
    return { expr: { type: "ArithVariable", name: c, hasDollarPrefix: l }, pos: s10 };
  }
  if (t10[s10] === "#") {
    let c = s10 + 1;
    for (; c < t10.length && t10[c] !== `
`; )
      c++;
    let u = t10.slice(s10, c).trim() || "#";
    return { expr: { type: "ArithSyntaxError", errorToken: u, message: `${u}: syntax error: invalid arithmetic operator (error token is "${u}")` }, pos: t10.length };
  }
  return { expr: { type: "ArithNumber", value: 0 }, pos: s10 };
}
var dt = I(() => {
  "use strict";
  ye();
  Y0();
});
function Ib(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; ) {
    let r10 = e11[n10];
    if (r10 < 128) {
      t10 += String.fromCharCode(r10), n10++;
      continue;
    }
    if ((r10 & 224) === 192) {
      if (n10 + 1 < e11.length && (e11[n10 + 1] & 192) === 128 && r10 >= 194) {
        let s10 = (r10 & 31) << 6 | e11[n10 + 1] & 63;
        t10 += String.fromCharCode(s10), n10 += 2;
        continue;
      }
      t10 += String.fromCharCode(r10), n10++;
      continue;
    }
    if ((r10 & 240) === 224) {
      if (n10 + 2 < e11.length && (e11[n10 + 1] & 192) === 128 && (e11[n10 + 2] & 192) === 128) {
        if (r10 === 224 && e11[n10 + 1] < 160) {
          t10 += String.fromCharCode(r10), n10++;
          continue;
        }
        let s10 = (r10 & 15) << 12 | (e11[n10 + 1] & 63) << 6 | e11[n10 + 2] & 63;
        if (s10 >= 55296 && s10 <= 57343) {
          t10 += String.fromCharCode(r10), n10++;
          continue;
        }
        t10 += String.fromCharCode(s10), n10 += 3;
        continue;
      }
      t10 += String.fromCharCode(r10), n10++;
      continue;
    }
    if ((r10 & 248) === 240 && r10 <= 244) {
      if (n10 + 3 < e11.length && (e11[n10 + 1] & 192) === 128 && (e11[n10 + 2] & 192) === 128 && (e11[n10 + 3] & 192) === 128) {
        if (r10 === 240 && e11[n10 + 1] < 144) {
          t10 += String.fromCharCode(r10), n10++;
          continue;
        }
        let s10 = (r10 & 7) << 18 | (e11[n10 + 1] & 63) << 12 | (e11[n10 + 2] & 63) << 6 | e11[n10 + 3] & 63;
        if (s10 > 1114111) {
          t10 += String.fromCharCode(r10), n10++;
          continue;
        }
        t10 += String.fromCodePoint(s10), n10 += 4;
        continue;
      }
      t10 += String.fromCharCode(r10), n10++;
      continue;
    }
    t10 += String.fromCharCode(r10), n10++;
  }
  return t10;
}
function um(e11, t10, n10) {
  let r10 = n10 + 1;
  for (; r10 < t10.length && /[a-zA-Z0-9_-]/.test(t10[r10]); )
    r10++;
  return r10;
}
function vl(e11, t10, n10, r10, s10) {
  let i10 = 1, o10 = n10 + 1;
  for (; o10 < t10.length && i10 > 0; )
    t10[o10] === r10 ? i10++ : t10[o10] === s10 && i10--, i10 > 0 && o10++;
  return i10 === 0 ? o10 : -1;
}
function nr(e11, t10, n10) {
  let r10 = n10, s10 = 1;
  for (; r10 < t10.length && s10 > 0; ) {
    let i10 = t10[r10];
    if (i10 === "\\" && r10 + 1 < t10.length) {
      r10 += 2;
      continue;
    }
    if (i10 === "'") {
      let o10 = t10.indexOf("'", r10 + 1);
      if (o10 !== -1) {
        r10 = o10 + 1;
        continue;
      }
    }
    if (i10 === '"') {
      for (r10++; r10 < t10.length && t10[r10] !== '"'; )
        t10[r10] === "\\" && r10 + 1 < t10.length ? r10 += 2 : r10++;
      r10 < t10.length && r10++;
      continue;
    }
    i10 === "{" ? s10++ : i10 === "}" && s10--, s10 > 0 && r10++;
  }
  return r10;
}
function fm(e11, t10, n10) {
  let r10 = n10, s10 = false;
  for (; r10 < t10.length; ) {
    let i10 = t10[r10];
    if (i10 === "/" && s10 || i10 === "}")
      break;
    if (i10 === "'") {
      let o10 = t10.indexOf("'", r10 + 1);
      if (o10 !== -1) {
        r10 = o10 + 1, s10 = true;
        continue;
      }
    }
    if (i10 === '"') {
      for (r10++; r10 < t10.length && t10[r10] !== '"'; )
        t10[r10] === "\\" && r10 + 1 < t10.length ? r10 += 2 : r10++;
      r10 < t10.length && r10++, s10 = true;
      continue;
    }
    i10 === "\\" ? (r10 += 2, s10 = true) : (r10++, s10 = true);
  }
  return r10;
}
function pm(e11, t10, n10) {
  let r10 = n10, s10 = "";
  for (; r10 < t10.length; ) {
    let i10 = t10[r10];
    if (i10 === "*" || i10 === "?")
      s10 += i10, r10++;
    else if (i10 === "[") {
      let o10 = Ob(t10, r10);
      o10 === -1 ? (s10 += i10, r10++) : (s10 += t10.slice(r10, o10 + 1), r10 = o10 + 1);
    } else
      break;
  }
  return { pattern: s10, endIndex: r10 };
}
function Ob(e11, t10) {
  let n10 = t10 + 1;
  for (n10 < e11.length && e11[n10] === "^" && n10++, n10 < e11.length && e11[n10] === "]" && n10++; n10 < e11.length; ) {
    let r10 = e11[n10];
    if (r10 === "\\" && n10 + 1 < e11.length) {
      let s10 = e11[n10 + 1];
      if (s10 === '"' || s10 === "'")
        return -1;
      n10 += 2;
      continue;
    }
    if (r10 === "]")
      return n10;
    if (r10 === '"' || r10 === "$" || r10 === "`")
      return -1;
    if (r10 === "'") {
      let s10 = e11.indexOf("'", n10 + 1);
      if (s10 !== -1) {
        n10 = s10 + 1;
        continue;
      }
    }
    if (r10 === "[" && n10 + 1 < e11.length && e11[n10 + 1] === ":") {
      let s10 = e11.indexOf(":]", n10 + 2);
      if (s10 !== -1) {
        n10 = s10 + 2;
        continue;
      }
    }
    if (r10 === "[" && n10 + 1 < e11.length && (e11[n10 + 1] === "." || e11[n10 + 1] === "=")) {
      let i10 = `${e11[n10 + 1]}]`, o10 = e11.indexOf(i10, n10 + 2);
      if (o10 !== -1) {
        n10 = o10 + 2;
        continue;
      }
    }
    n10++;
  }
  return -1;
}
function hm(e11, t10, n10) {
  let r10 = "", s10 = n10;
  for (; s10 < t10.length && t10[s10] !== "'"; ) {
    let i10 = t10[s10];
    if (i10 === "\\" && s10 + 1 < t10.length)
      switch (t10[s10 + 1]) {
        case "n":
          r10 += `
`, s10 += 2;
          break;
        case "t":
          r10 += "	", s10 += 2;
          break;
        case "r":
          r10 += "\r", s10 += 2;
          break;
        case "\\":
          r10 += "\\", s10 += 2;
          break;
        case "'":
          r10 += "'", s10 += 2;
          break;
        case '"':
          r10 += '"', s10 += 2;
          break;
        case "a":
          r10 += "\x07", s10 += 2;
          break;
        case "b":
          r10 += "\b", s10 += 2;
          break;
        case "e":
        case "E":
          r10 += "\x1B", s10 += 2;
          break;
        case "f":
          r10 += "\f", s10 += 2;
          break;
        case "v":
          r10 += "\v", s10 += 2;
          break;
        case "x": {
          let a = [], l = s10;
          for (; l + 1 < t10.length && t10[l] === "\\" && t10[l + 1] === "x"; ) {
            let c = t10.slice(l + 2, l + 4), u = parseInt(c, 16);
            if (!Number.isNaN(u) && c.length > 0)
              a.push(u), l += 2 + c.length;
            else
              break;
          }
          a.length > 0 ? (r10 += Ib(a), s10 = l) : (r10 += "\\x", s10 += 2);
          break;
        }
        case "u": {
          let a = t10.slice(s10 + 2, s10 + 6), l = parseInt(a, 16);
          Number.isNaN(l) ? (r10 += "\\u", s10 += 2) : (r10 += String.fromCharCode(l), s10 += 6);
          break;
        }
        case "c": {
          if (s10 + 2 < t10.length) {
            let l = t10[s10 + 2].charCodeAt(0) & 31;
            r10 += String.fromCharCode(l), s10 += 3;
          } else
            r10 += "\\c", s10 += 2;
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7": {
          let a = "", l = s10 + 1;
          for (; l < t10.length && l < s10 + 4 && /[0-7]/.test(t10[l]); )
            a += t10[l], l++;
          let c = parseInt(a, 8);
          r10 += String.fromCharCode(c), s10 = l;
          break;
        }
        default:
          r10 += i10, s10++;
      }
    else
      r10 += i10, s10++;
  }
  return s10 < t10.length && t10[s10] === "'" && s10++, { part: q.literal(r10), endIndex: s10 };
}
function Il(e11, t10) {
  let n10 = t10.trim();
  return n10 === "" ? { type: "ArithmeticExpression", expression: { type: "ArithNumber", value: 0 } } : Ae(e11, n10);
}
function cm(e11) {
  let t10 = [], n10 = "", r10 = 0;
  for (let s10 = 0; s10 < e11.length; s10++) {
    let i10 = e11[s10];
    i10 === "{" ? (r10++, n10 += i10) : i10 === "}" ? (r10--, n10 += i10) : i10 === "," && r10 === 0 ? (t10.push(n10), n10 = "") : n10 += i10;
  }
  return t10.push(n10), t10;
}
function dm(e11, t10, n10, r10) {
  let s10 = vl(e11, t10, n10, "{", "}");
  if (s10 === -1)
    return null;
  let i10 = t10.slice(n10 + 1, s10), o10 = i10.match(/^(-?\d+)\.\.(-?\d+)(?:\.\.(-?\d+))?$/);
  if (o10)
    return { part: { type: "BraceExpansion", items: [{ type: "Range", start: Number.parseInt(o10[1], 10), end: Number.parseInt(o10[2], 10), step: o10[3] ? Number.parseInt(o10[3], 10) : void 0, startStr: o10[1], endStr: o10[2] }] }, endIndex: s10 + 1 };
  let a = i10.match(/^([a-zA-Z])\.\.([a-zA-Z])(?:\.\.(-?\d+))?$/);
  return a ? { part: { type: "BraceExpansion", items: [{ type: "Range", start: a[1], end: a[2], step: a[3] ? Number.parseInt(a[3], 10) : void 0 }] }, endIndex: s10 + 1 } : i10.includes(",") && r10 ? { part: { type: "BraceExpansion", items: cm(i10).map((u) => ({ type: "Word", word: q.word(r10(e11, u, false, false, false)) })) }, endIndex: s10 + 1 } : i10.includes(",") ? { part: { type: "BraceExpansion", items: cm(i10).map((u) => ({ type: "Word", word: q.word([q.literal(u)]) })) }, endIndex: s10 + 1 } : null;
}
function Ol(e11, t10) {
  let n10 = "";
  for (let r10 of t10.parts)
    switch (r10.type) {
      case "Literal":
        n10 += r10.value;
        break;
      case "SingleQuoted":
        n10 += `'${r10.value}'`;
        break;
      case "Escaped":
        n10 += r10.value;
        break;
      case "DoubleQuoted":
        n10 += '"';
        for (let s10 of r10.parts)
          s10.type === "Literal" || s10.type === "Escaped" ? n10 += s10.value : s10.type === "ParameterExpansion" && (n10 += `\${${s10.parameter}}`);
        n10 += '"';
        break;
      case "ParameterExpansion":
        n10 += `\${${r10.parameter}}`;
        break;
      case "Glob":
        n10 += r10.pattern;
        break;
      case "TildeExpansion":
        n10 += "~", r10.user && (n10 += r10.user);
        break;
      case "BraceExpansion": {
        n10 += "{";
        let s10 = [];
        for (let i10 of r10.items)
          if (i10.type === "Range") {
            let o10 = i10.startStr ?? String(i10.start), a = i10.endStr ?? String(i10.end);
            i10.step !== void 0 ? s10.push(`${o10}..${a}..${i10.step}`) : s10.push(`${o10}..${a}`);
          } else
            s10.push(Ol(e11, i10.word));
        s10.length === 1 && r10.items[0].type === "Range" ? n10 += s10[0] : n10 += s10.join(","), n10 += "}";
        break;
      }
      default:
        n10 += r10.type;
    }
  return n10;
}
function mm(e11, t10) {
  return { [E.LESS]: "<", [E.GREAT]: ">", [E.DGREAT]: ">>", [E.LESSAND]: "<&", [E.GREATAND]: ">&", [E.LESSGREAT]: "<>", [E.CLOBBER]: ">|", [E.TLESS]: "<<<", [E.AND_GREAT]: "&>", [E.AND_DGREAT]: "&>>", [E.DLESS]: "<", [E.DLESSDASH]: "<" }[t10] || ">";
}
var Rl = I(() => {
  "use strict";
  tr();
  dt();
  Pn();
});
function Bi(e11) {
  let t10 = e11.current(), n10 = t10.type;
  if (n10 === E.NUMBER) {
    let r10 = e11.peek(1);
    return t10.end !== r10.start ? false : q0.has(r10.type);
  }
  if (n10 === E.FD_VARIABLE) {
    let r10 = e11.peek(1);
    return Z0.has(r10.type);
  }
  return V0.has(n10);
}
function zi(e11) {
  let t10 = null, n10;
  e11.check(E.NUMBER) ? t10 = Number.parseInt(e11.advance().value, 10) : e11.check(E.FD_VARIABLE) && (n10 = e11.advance().value);
  let r10 = e11.advance(), s10 = mm(e11, r10.type);
  if (r10.type === E.DLESS || r10.type === E.DLESSDASH)
    return Rb(e11, s10, t10, r10.type === E.DLESSDASH);
  e11.isWord() || e11.error("Expected redirection target");
  let i10 = e11.parseWord();
  return q.redirection(s10, i10, t10, n10);
}
function Rb(e11, t10, n10, r10) {
  e11.isWord() || e11.error("Expected here-document delimiter");
  let s10 = e11.advance(), i10 = s10.value, o10 = s10.quoted || false;
  (i10.startsWith("'") && i10.endsWith("'") || i10.startsWith('"') && i10.endsWith('"')) && (i10 = i10.slice(1, -1));
  let a = q.redirection(r10 ? "<<-" : "<<", q.hereDoc(i10, q.word([]), r10, o10), n10);
  return e11.addPendingHeredoc(a, i10, r10, o10), a;
}
function ym(e11) {
  let t10 = e11.current().line, n10 = [], r10 = null, s10 = [], i10 = [];
  for (; e11.check(E.ASSIGNMENT_WORD) || Bi(e11); )
    e11.checkIterationLimit(), e11.check(E.ASSIGNMENT_WORD) ? n10.push($b(e11)) : i10.push(zi(e11));
  if (e11.isWord())
    r10 = e11.parseWord();
  else if (n10.length > 0 && (e11.check(E.DBRACK_START) || e11.check(E.DPAREN_START))) {
    let a = e11.advance();
    r10 = q.word([q.literal(a.value)]);
  }
  for (; (!e11.isStatementEnd() || e11.check(E.RBRACE)) && !e11.check(E.PIPE, E.PIPE_AMP); )
    if (e11.checkIterationLimit(), Bi(e11))
      i10.push(zi(e11));
    else if (e11.check(E.RBRACE)) {
      let a = e11.advance();
      s10.push(e11.parseWordFromString(a.value, false, false));
    } else if (e11.check(E.LBRACE)) {
      let a = e11.advance();
      s10.push(e11.parseWordFromString(a.value, false, false));
    } else if (e11.check(E.DBRACK_END)) {
      let a = e11.advance();
      s10.push(e11.parseWordFromString(a.value, false, false));
    } else if (e11.isWord())
      s10.push(e11.parseWord());
    else if (e11.check(E.ASSIGNMENT_WORD)) {
      let a = e11.advance(), l = a.value, c = l.endsWith("="), u = l.endsWith("=(");
      if ((c || u) && (u || e11.check(E.LPAREN))) {
        let f10 = u ? l.slice(0, -2) : l.slice(0, -1);
        u || e11.expect(E.LPAREN);
        let p = $l(e11);
        e11.expect(E.RPAREN);
        let h = p.map((d) => Ol(e11, d)), m = `${f10}=(${h.join(" ")})`;
        s10.push(e11.parseWordFromString(m, false, false));
      } else
        s10.push(e11.parseWordFromString(l, a.quoted, a.singleQuoted));
    } else if (e11.check(E.LPAREN))
      e11.error("syntax error near unexpected token `('");
    else
      break;
  let o10 = q.simpleCommand(r10, s10, n10, i10);
  return o10.line = t10, o10;
}
function $b(e11) {
  let t10 = e11.expect(E.ASSIGNMENT_WORD), n10 = t10.value, r10 = n10.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
  r10 || e11.error(`Invalid assignment: ${n10}`);
  let s10 = r10[0], i10, o10 = s10.length;
  if (n10[o10] === "[") {
    let f10 = 0, p = o10 + 1;
    for (; o10 < n10.length; o10++)
      if (n10[o10] === "[")
        f10++;
      else if (n10[o10] === "]" && (f10--, f10 === 0))
        break;
    f10 !== 0 && e11.error(`Invalid assignment: ${n10}`), i10 = n10.slice(p, o10), o10++;
  }
  let a = n10[o10] === "+";
  a && o10++, n10[o10] !== "=" && e11.error(`Invalid assignment: ${n10}`), o10++;
  let l = n10.slice(o10);
  if (l === "(") {
    let f10 = $l(e11);
    e11.expect(E.RPAREN);
    let p = i10 !== void 0 ? `${s10}[${i10}]` : s10;
    return q.assignment(p, null, a, f10);
  }
  if (l === "" && e11.check(E.LPAREN)) {
    let f10 = e11.current();
    if (t10.end === f10.start) {
      e11.advance();
      let p = $l(e11);
      e11.expect(E.RPAREN);
      let h = i10 !== void 0 ? `${s10}[${i10}]` : s10;
      return q.assignment(h, null, a, p);
    }
  }
  let c = l ? e11.parseWordFromString(l, t10.quoted, t10.singleQuoted, true) : null, u = i10 !== void 0 ? `${s10}[${i10}]` : s10;
  return q.assignment(u, c, a, null);
}
function $l(e11) {
  let t10 = [];
  for (e11.skipNewlines(); !e11.check(E.RPAREN, E.EOF); )
    e11.checkIterationLimit(), e11.isWord() ? t10.push(e11.parseWord()) : Tb.has(e11.current().type) ? e11.error(`syntax error near unexpected token \`${e11.current().value}'`) : e11.advance(), e11.skipNewlines();
  return t10;
}
var Tb;
var wm = I(() => {
  "use strict";
  tr();
  Pn();
  er();
  Rl();
  Tb = /* @__PURE__ */ new Set([E.AMP, E.PIPE, E.PIPE_AMP, E.SEMICOLON, E.AND_AND, E.OR_OR, E.DSEMI, E.SEMI_AND, E.SEMI_SEMI_AND]);
});
function Tl(e11, t10) {
  e11.expect(E.IF);
  let n10 = [], r10 = e11.parseCompoundList();
  e11.expect(E.THEN);
  let s10 = e11.parseCompoundList();
  if (s10.length === 0) {
    let a = e11.check(E.FI) ? "fi" : e11.check(E.ELSE) ? "else" : e11.check(E.ELIF) ? "elif" : "fi";
    e11.error(`syntax error near unexpected token \`${a}'`);
  }
  for (n10.push({ condition: r10, body: s10 }); e11.check(E.ELIF); ) {
    e11.advance();
    let a = e11.parseCompoundList();
    e11.expect(E.THEN);
    let l = e11.parseCompoundList();
    if (l.length === 0) {
      let c = e11.check(E.FI) ? "fi" : e11.check(E.ELSE) ? "else" : e11.check(E.ELIF) ? "elif" : "fi";
      e11.error(`syntax error near unexpected token \`${c}'`);
    }
    n10.push({ condition: a, body: l });
  }
  let i10 = null;
  e11.check(E.ELSE) && (e11.advance(), i10 = e11.parseCompoundList(), i10.length === 0 && e11.error("syntax error near unexpected token `fi'")), e11.expect(E.FI);
  let o10 = t10?.skipRedirections ? [] : e11.parseOptionalRedirections();
  return q.ifNode(n10, i10, o10);
}
function Pl(e11, t10) {
  let n10 = e11.expect(E.FOR);
  if (e11.check(E.DPAREN_START))
    return Db(e11, t10, n10.line);
  e11.isWord() || e11.error("Expected variable name in for loop");
  let s10 = e11.advance().value, i10 = null;
  if (e11.skipNewlines(), e11.check(E.IN))
    for (e11.advance(), i10 = []; !e11.check(E.SEMICOLON, E.NEWLINE, E.DO, E.EOF) && e11.isWord(); )
      i10.push(e11.parseWord());
  e11.check(E.SEMICOLON) && e11.advance(), e11.skipNewlines(), e11.expect(E.DO);
  let o10 = e11.parseCompoundList();
  e11.expect(E.DONE);
  let a = t10?.skipRedirections ? [] : e11.parseOptionalRedirections();
  return q.forNode(s10, i10, o10, a);
}
function Db(e11, t10, n10) {
  e11.expect(E.DPAREN_START);
  let r10 = null, s10 = null, i10 = null, o10 = ["", "", ""], a = 0, l = 0;
  for (; !e11.check(E.DPAREN_END, E.EOF); ) {
    let f10 = e11.advance();
    if (f10.type === E.SEMICOLON && l === 0) {
      if (a++, a > 2)
        break;
    } else
      f10.value === "(" && l++, f10.value === ")" && l--, o10[a] += f10.value;
  }
  e11.expect(E.DPAREN_END), o10[0].trim() && (r10 = Ae(e11, o10[0].trim())), o10[1].trim() && (s10 = Ae(e11, o10[1].trim())), o10[2].trim() && (i10 = Ae(e11, o10[2].trim())), e11.skipNewlines(), e11.check(E.SEMICOLON) && e11.advance(), e11.skipNewlines();
  let c;
  e11.check(E.LBRACE) ? (e11.advance(), c = e11.parseCompoundList(), e11.expect(E.RBRACE)) : (e11.expect(E.DO), c = e11.parseCompoundList(), e11.expect(E.DONE));
  let u = t10?.skipRedirections ? [] : e11.parseOptionalRedirections();
  return { type: "CStyleFor", init: r10, condition: s10, update: i10, body: c, redirections: u, line: n10 };
}
function Dl(e11, t10) {
  e11.expect(E.WHILE);
  let n10 = e11.parseCompoundList();
  e11.expect(E.DO);
  let r10 = e11.parseCompoundList();
  r10.length === 0 && e11.error("syntax error near unexpected token `done'"), e11.expect(E.DONE);
  let s10 = t10?.skipRedirections ? [] : e11.parseOptionalRedirections();
  return q.whileNode(n10, r10, s10);
}
function _l(e11, t10) {
  e11.expect(E.UNTIL);
  let n10 = e11.parseCompoundList();
  e11.expect(E.DO);
  let r10 = e11.parseCompoundList();
  r10.length === 0 && e11.error("syntax error near unexpected token `done'"), e11.expect(E.DONE);
  let s10 = t10?.skipRedirections ? [] : e11.parseOptionalRedirections();
  return q.untilNode(n10, r10, s10);
}
function Ll(e11, t10) {
  e11.expect(E.CASE), e11.isWord() || e11.error("Expected word after 'case'");
  let n10 = e11.parseWord();
  e11.skipNewlines(), e11.expect(E.IN), e11.skipNewlines();
  let r10 = [];
  for (; !e11.check(E.ESAC, E.EOF); ) {
    e11.checkIterationLimit();
    let i10 = e11.getPos(), o10 = _b2(e11);
    if (o10 && r10.push(o10), e11.skipNewlines(), e11.getPos() === i10 && !o10)
      break;
  }
  e11.expect(E.ESAC);
  let s10 = t10?.skipRedirections ? [] : e11.parseOptionalRedirections();
  return q.caseNode(n10, r10, s10);
}
function _b2(e11) {
  e11.check(E.LPAREN) && e11.advance();
  let t10 = [];
  for (; e11.isWord() && (t10.push(e11.parseWord()), e11.check(E.PIPE)); )
    e11.advance();
  if (t10.length === 0)
    return null;
  e11.expect(E.RPAREN), e11.skipNewlines();
  let n10 = [];
  for (; !e11.check(E.DSEMI, E.SEMI_AND, E.SEMI_SEMI_AND, E.ESAC, E.EOF); ) {
    e11.checkIterationLimit(), e11.isWord() && e11.peek(1).type === E.RPAREN && e11.error("syntax error near unexpected token `)'"), e11.check(E.LPAREN) && e11.peek(1).type === E.WORD && e11.error(`syntax error near unexpected token \`${e11.peek(1).value}'`);
    let s10 = e11.getPos(), i10 = e11.parseStatement();
    if (i10 && n10.push(i10), e11.skipSeparators(false), e11.getPos() === s10 && !i10)
      break;
  }
  let r10 = ";;";
  return e11.check(E.DSEMI) ? (e11.advance(), r10 = ";;") : e11.check(E.SEMI_AND) ? (e11.advance(), r10 = ";&") : e11.check(E.SEMI_SEMI_AND) && (e11.advance(), r10 = ";;&"), q.caseItem(t10, n10, r10);
}
function Fl(e11, t10) {
  e11.expect(E.LPAREN);
  let n10 = e11.parseCompoundList();
  e11.expect(E.RPAREN);
  let r10 = t10?.skipRedirections ? [] : e11.parseOptionalRedirections();
  return q.subshell(n10, r10);
}
function Ml(e11, t10) {
  e11.expect(E.LBRACE);
  let n10 = e11.parseCompoundList();
  e11.expect(E.RBRACE);
  let r10 = t10?.skipRedirections ? [] : e11.parseOptionalRedirections();
  return q.group(n10, r10);
}
var bm = I(() => {
  "use strict";
  tr();
  dt();
  Pn();
});
function xm(e11) {
  return e11.isWord() || e11.check(E.LBRACE) || e11.check(E.RBRACE) || e11.check(E.ASSIGNMENT_WORD);
}
function Em(e11) {
  if (e11.check(E.BANG) && e11.peek(1).type === E.LPAREN) {
    e11.advance(), e11.advance();
    let t10 = 1, n10 = "!(";
    for (; t10 > 0 && !e11.check(E.EOF); )
      if (e11.check(E.LPAREN))
        t10++, n10 += "(", e11.advance();
      else if (e11.check(E.RPAREN))
        t10--, t10 > 0 && (n10 += ")"), e11.advance();
      else if (e11.isWord())
        n10 += e11.advance().value;
      else if (e11.check(E.PIPE))
        n10 += "|", e11.advance();
      else
        break;
    return n10 += ")", e11.parseWordFromString(n10, false, false, false, false, true);
  }
  return e11.parseWordNoBraceExpansion();
}
function Wl(e11) {
  return e11.skipNewlines(), Ub(e11);
}
function Ub(e11) {
  let t10 = Am(e11);
  for (e11.skipNewlines(); e11.check(E.OR_OR); ) {
    e11.advance(), e11.skipNewlines();
    let n10 = Am(e11);
    t10 = { type: "CondOr", left: t10, right: n10 }, e11.skipNewlines();
  }
  return t10;
}
function Am(e11) {
  let t10 = Ul(e11);
  for (e11.skipNewlines(); e11.check(E.AND_AND); ) {
    e11.advance(), e11.skipNewlines();
    let n10 = Ul(e11);
    t10 = { type: "CondAnd", left: t10, right: n10 }, e11.skipNewlines();
  }
  return t10;
}
function Ul(e11) {
  return e11.skipNewlines(), e11.check(E.BANG) ? (e11.advance(), e11.skipNewlines(), { type: "CondNot", operand: Ul(e11) }) : Wb(e11);
}
function Wb(e11) {
  if (e11.check(E.LPAREN)) {
    e11.advance();
    let t10 = Wl(e11);
    return e11.expect(E.RPAREN), { type: "CondGroup", expression: t10 };
  }
  if (xm(e11)) {
    let t10 = e11.current(), n10 = t10.value;
    if (Fb.includes(n10) && !t10.quoted) {
      if (e11.advance(), e11.check(E.DBRACK_END) && e11.error(`Expected operand after ${n10}`), xm(e11)) {
        let i10 = e11.parseWordNoBraceExpansion();
        return { type: "CondUnary", operator: n10, operand: i10 };
      }
      let s10 = e11.current();
      e11.error(`unexpected argument \`${s10.value}' to conditional unary operator`);
    }
    let r10 = e11.parseWordNoBraceExpansion();
    if (e11.isWord() && Mb.includes(e11.current().value)) {
      let s10 = e11.advance().value, i10;
      return s10 === "=~" ? i10 = Bb(e11) : s10 === "==" || s10 === "!=" ? i10 = Em(e11) : i10 = e11.parseWordNoBraceExpansion(), { type: "CondBinary", operator: s10, left: r10, right: i10 };
    }
    if (e11.check(E.LESS)) {
      e11.advance();
      let s10 = e11.parseWordNoBraceExpansion();
      return { type: "CondBinary", operator: "<", left: r10, right: s10 };
    }
    if (e11.check(E.GREAT)) {
      e11.advance();
      let s10 = e11.parseWordNoBraceExpansion();
      return { type: "CondBinary", operator: ">", left: r10, right: s10 };
    }
    if (e11.isWord() && e11.current().value === "=") {
      e11.advance();
      let s10 = Em(e11);
      return { type: "CondBinary", operator: "==", left: r10, right: s10 };
    }
    return { type: "CondWord", word: r10 };
  }
  e11.error("Expected conditional expression");
}
function Bb(e11) {
  let t10 = [], n10 = 0, r10 = -1, s10 = e11.getInput(), i10 = () => e11.check(E.DBRACK_END) || e11.check(E.AND_AND) || e11.check(E.OR_OR) || e11.check(E.NEWLINE) || e11.check(E.EOF);
  for (; !i10(); ) {
    let o10 = e11.current(), a = r10 >= 0 && o10.start > r10;
    if (n10 === 0 && a)
      break;
    if (n10 > 0 && a) {
      let l = s10.slice(r10, o10.start);
      t10.push({ type: "Literal", value: l });
    }
    if (e11.isWord() || e11.check(E.ASSIGNMENT_WORD)) {
      let l = e11.parseWordForRegex();
      t10.push(...l.parts), r10 = e11.peek(-1).end;
    } else if (e11.check(E.LPAREN)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: "(" }), n10++, r10 = l.end;
    } else if (e11.check(E.DPAREN_START)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: "((" }), n10 += 2, r10 = l.end;
    } else if (e11.check(E.DPAREN_END))
      if (n10 >= 2) {
        let l = e11.advance();
        t10.push({ type: "Literal", value: "))" }), n10 -= 2, r10 = l.end;
      } else {
        if (n10 === 1)
          break;
        break;
      }
    else if (e11.check(E.RPAREN))
      if (n10 > 0) {
        let l = e11.advance();
        t10.push({ type: "Literal", value: ")" }), n10--, r10 = l.end;
      } else
        break;
    else if (e11.check(E.PIPE)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: "|" }), r10 = l.end;
    } else if (e11.check(E.SEMICOLON))
      if (n10 > 0) {
        let l = e11.advance();
        t10.push({ type: "Literal", value: ";" }), r10 = l.end;
      } else
        break;
    else if (n10 > 0 && e11.check(E.LESS)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: "<" }), r10 = l.end;
    } else if (n10 > 0 && e11.check(E.GREAT)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: ">" }), r10 = l.end;
    } else if (n10 > 0 && e11.check(E.DGREAT)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: ">>" }), r10 = l.end;
    } else if (n10 > 0 && e11.check(E.DLESS)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: "<<" }), r10 = l.end;
    } else if (n10 > 0 && e11.check(E.LESSAND)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: "<&" }), r10 = l.end;
    } else if (n10 > 0 && e11.check(E.GREATAND)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: ">&" }), r10 = l.end;
    } else if (n10 > 0 && e11.check(E.LESSGREAT)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: "<>" }), r10 = l.end;
    } else if (n10 > 0 && e11.check(E.CLOBBER)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: ">|" }), r10 = l.end;
    } else if (n10 > 0 && e11.check(E.TLESS)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: "<<<" }), r10 = l.end;
    } else if (n10 > 0 && e11.check(E.AMP)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: "&" }), r10 = l.end;
    } else if (n10 > 0 && e11.check(E.LBRACE)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: "{" }), r10 = l.end;
    } else if (n10 > 0 && e11.check(E.RBRACE)) {
      let l = e11.advance();
      t10.push({ type: "Literal", value: "}" }), r10 = l.end;
    } else
      break;
  }
  return t10.length === 0 && e11.error("Expected regex pattern after =~"), { type: "Word", parts: t10 };
}
var Fb;
var Mb;
var Sm = I(() => {
  "use strict";
  Pn();
  Fb = ["-a", "-b", "-c", "-d", "-e", "-f", "-g", "-h", "-k", "-p", "-r", "-s", "-t", "-u", "-w", "-x", "-G", "-L", "-N", "-O", "-S", "-z", "-n", "-o", "-v", "-R"], Mb = ["==", "!=", "=~", "<", ">", "-eq", "-ne", "-lt", "-le", "-gt", "-ge", "-nt", "-ot", "-ef"];
});
function Hb(e11, t10) {
  let n10 = 1, r10 = t10 + 1;
  for (; r10 < e11.length && n10 > 0; ) {
    let s10 = e11[r10];
    if (s10 === "\\") {
      r10 += 2;
      continue;
    }
    if ("@*+?!".includes(s10) && r10 + 1 < e11.length && e11[r10 + 1] === "(") {
      r10++, n10++, r10++;
      continue;
    }
    if (s10 === "(")
      n10++;
    else if (s10 === ")" && (n10--, n10 === 0))
      return r10;
    r10++;
  }
  return -1;
}
function jb(e11, t10, n10) {
  let r10 = n10 + 1, s10 = t10[r10];
  if ("@*#?$!-0123456789".includes(s10))
    return { part: q.parameterExpansion(s10), endIndex: r10 + 1 };
  let i10 = "";
  for (; r10 < t10.length && /[a-zA-Z0-9_]/.test(t10[r10]); )
    i10 += t10[r10], r10++;
  return { part: q.parameterExpansion(i10), endIndex: r10 };
}
function Gb(e11, t10, n10, r10 = false) {
  let s10 = n10 + 2, i10 = false;
  t10[s10] === "!" && (i10 = true, s10++);
  let o10 = false;
  t10[s10] === "#" && !/[}:#%/^,]/.test(t10[s10 + 1] || "}") && (o10 = true, s10++);
  let a = "", l = t10[s10];
  if (/[@*#?$!-]/.test(l) && !/[a-zA-Z0-9_]/.test(t10[s10 + 1] || ""))
    a = l, s10++;
  else
    for (; s10 < t10.length && /[a-zA-Z0-9_]/.test(t10[s10]); )
      a += t10[s10], s10++;
  if (t10[s10] === "[") {
    let u = vl(e11, t10, s10, "[", "]");
    if (a += t10.slice(s10, u + 1), s10 = u + 1, t10[s10] === "[") {
      let f10 = 1, p = s10;
      for (; p < t10.length && f10 > 0; )
        t10[p] === "{" ? f10++ : t10[p] === "}" && f10--, f10 > 0 && p++;
      let h = t10.slice(n10 + 2, p);
      return { part: q.parameterExpansion("", { type: "BadSubstitution", text: h }), endIndex: p + 1 };
    }
  }
  if (a === "" && !i10 && !o10 && t10[s10] !== "}") {
    let u = 1, f10 = s10;
    for (; f10 < t10.length && u > 0; )
      t10[f10] === "{" ? u++ : t10[f10] === "}" && u--, u > 0 && f10++;
    if (u > 0)
      throw new ot("unexpected EOF while looking for matching '}'", 0, 0);
    let p = t10.slice(n10 + 2, f10);
    return { part: q.parameterExpansion("", { type: "BadSubstitution", text: p }), endIndex: f10 + 1 };
  }
  let c = null;
  if (i10) {
    let u = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
    if (u)
      if (s10 < t10.length && t10[s10] !== "}" && /[:=\-+?#%/^,@]/.test(t10[s10])) {
        let f10 = Bl(e11, t10, s10, a, r10);
        f10.operation ? (c = { type: "Indirection", innerOp: f10.operation }, s10 = f10.endIndex) : (c = { type: "ArrayKeys", array: u[1], star: u[2] === "*" }, a = "");
      } else
        c = { type: "ArrayKeys", array: u[1], star: u[2] === "*" }, a = "";
    else if (t10[s10] === "*" || t10[s10] === "@" && !/[QPaAEKkuUL]/.test(t10[s10 + 1] || "")) {
      let f10 = t10[s10];
      s10++, c = { type: "VarNamePrefix", prefix: a, star: f10 === "*" }, a = "";
    } else if (s10 < t10.length && t10[s10] !== "}" && /[:=\-+?#%/^,@]/.test(t10[s10])) {
      let f10 = Bl(e11, t10, s10, a, r10);
      f10.operation ? (c = { type: "Indirection", innerOp: f10.operation }, s10 = f10.endIndex) : c = { type: "Indirection" };
    } else
      c = { type: "Indirection" };
  } else if (o10)
    if (t10[s10] === ":")
      for (c = { type: "LengthSliceError" }; s10 < t10.length && t10[s10] !== "}"; )
        s10++;
    else
      t10[s10] !== "}" && /[-+=?]/.test(t10[s10]) ? e11.error(`\${#${a}${t10.slice(s10, t10.indexOf("}", s10))}}: bad substitution`) : t10[s10] === "/" ? e11.error(`\${#${a}${t10.slice(s10, t10.indexOf("}", s10))}}: bad substitution`) : c = { type: "Length" };
  if (!c && s10 < t10.length && t10[s10] !== "}") {
    let u = Bl(e11, t10, s10, a, r10);
    c = u.operation, s10 = u.endIndex;
  }
  if (s10 < t10.length && t10[s10] !== "}") {
    let u = t10[s10];
    if (!/[:\-+=?#%/^,@[]/.test(u)) {
      let f10 = s10;
      for (; f10 < t10.length && t10[f10] !== "}"; )
        f10++;
      let p = t10.slice(n10, f10 + 1);
      e11.error(`\${${p.slice(2, -1)}}: bad substitution`);
    }
  }
  for (; s10 < t10.length && t10[s10] !== "}"; )
    s10++;
  if (s10 >= t10.length)
    throw new ot("unexpected EOF while looking for matching '}'", 0, 0);
  return { part: q.parameterExpansion(a, c), endIndex: s10 + 1 };
}
function Bl(e11, t10, n10, r10, s10 = false) {
  let i10 = n10, o10 = t10[i10], a = t10[i10 + 1] || "";
  if (o10 === ":") {
    let l = a;
    if ("-=?+".includes(l)) {
      i10 += 2;
      let y = nr(e11, t10, i10), w = t10.slice(i10, y), b = Dn(e11, w, false, false, true, false, s10, false, false, true), x = q.word(b.length > 0 ? b : [q.literal("")]);
      if (l === "-")
        return { operation: { type: "DefaultValue", word: x, checkEmpty: true }, endIndex: y };
      if (l === "=")
        return { operation: { type: "AssignDefault", word: x, checkEmpty: true }, endIndex: y };
      if (l === "?")
        return { operation: { type: "ErrorIfUnset", word: x, checkEmpty: true }, endIndex: y };
      if (l === "+")
        return { operation: { type: "UseAlternative", word: x, checkEmpty: true }, endIndex: y };
    }
    i10++;
    let c = nr(e11, t10, i10), u = t10.slice(i10, c), f10 = -1, p = 0, h = 0;
    for (let g = 0; g < u.length; g++) {
      let y = u[g];
      if (y === "(" || y === "[")
        p++;
      else if (y === ")" || y === "]")
        p--;
      else if (y === "?" && p === 0)
        h++;
      else if (y === ":" && p === 0)
        if (h > 0)
          h--;
        else {
          f10 = g;
          break;
        }
    }
    let m = f10 >= 0 ? u.slice(0, f10) : u, d = f10 >= 0 ? u.slice(f10 + 1) : null;
    return { operation: { type: "Substring", offset: Il(e11, m), length: d !== null ? Il(e11, d) : null }, endIndex: c };
  }
  if ("-=?+".includes(o10)) {
    i10++;
    let l = nr(e11, t10, i10), c = t10.slice(i10, l), u = Dn(e11, c, false, false, true, false, s10, false, false, true), f10 = q.word(u.length > 0 ? u : [q.literal("")]);
    if (o10 === "-")
      return { operation: { type: "DefaultValue", word: f10, checkEmpty: false }, endIndex: l };
    if (o10 === "=")
      return { operation: { type: "AssignDefault", word: f10, checkEmpty: false }, endIndex: l };
    if (o10 === "?")
      return { operation: { type: "ErrorIfUnset", word: c ? f10 : null, checkEmpty: false }, endIndex: l };
    if (o10 === "+")
      return { operation: { type: "UseAlternative", word: f10, checkEmpty: false }, endIndex: l };
  }
  if (o10 === "#" || o10 === "%") {
    let l = a === o10, c = o10 === "#" ? "prefix" : "suffix";
    i10 += l ? 2 : 1;
    let u = nr(e11, t10, i10), f10 = t10.slice(i10, u), p = Dn(e11, f10, false, false, false);
    return { operation: { type: "PatternRemoval", pattern: q.word(p.length > 0 ? p : [q.literal("")]), side: c, greedy: l }, endIndex: u };
  }
  if (o10 === "/") {
    let l = a === "/";
    i10 += l ? 2 : 1;
    let c = null;
    t10[i10] === "#" ? (c = "start", i10++) : t10[i10] === "%" && (c = "end", i10++);
    let u;
    c !== null && (t10[i10] === "/" || t10[i10] === "}") ? u = i10 : u = fm(e11, t10, i10);
    let f10 = t10.slice(i10, u), p = Dn(e11, f10, false, false, false), h = q.word(p.length > 0 ? p : [q.literal("")]), m = null, d = u;
    if (t10[u] === "/") {
      let g = u + 1, y = nr(e11, t10, g), w = t10.slice(g, y), b = Dn(e11, w, false, false, false);
      m = q.word(b.length > 0 ? b : [q.literal("")]), d = y;
    }
    return { operation: { type: "PatternReplacement", pattern: h, replacement: m, all: l, anchor: c }, endIndex: d };
  }
  if (o10 === "^" || o10 === ",") {
    let l = a === o10, c = o10 === "^" ? "upper" : "lower";
    i10 += l ? 2 : 1;
    let u = nr(e11, t10, i10), f10 = t10.slice(i10, u), p = f10 ? q.word([q.literal(f10)]) : null;
    return { operation: { type: "CaseModification", direction: c, all: l, pattern: p }, endIndex: u };
  }
  return o10 === "@" && /[QPaAEKkuUL]/.test(a) ? { operation: { type: "Transform", operator: a }, endIndex: i10 + 2 } : { operation: null, endIndex: i10 };
}
function zl(e11, t10, n10, r10 = false) {
  let s10 = n10 + 1;
  if (s10 >= t10.length)
    return { part: q.literal("$"), endIndex: s10 };
  let i10 = t10[s10];
  if (i10 === "(" && t10[s10 + 1] === "(")
    return e11.isDollarDparenSubshell(t10, n10) ? e11.parseCommandSubstitution(t10, n10) : e11.parseArithmeticExpansion(t10, n10);
  if (i10 === "[") {
    let o10 = 1, a = s10 + 1;
    for (; a < t10.length && o10 > 0; )
      t10[a] === "[" ? o10++ : t10[a] === "]" && o10--, o10 > 0 && a++;
    if (o10 === 0) {
      let l = t10.slice(s10 + 1, a), c = Ae(e11, l);
      return { part: q.arithmeticExpansion(c), endIndex: a + 1 };
    }
  }
  return i10 === "(" ? e11.parseCommandSubstitution(t10, n10) : i10 === "{" ? Gb(e11, t10, n10, r10) : /[a-zA-Z_0-9@*#?$!-]/.test(i10) ? jb(e11, t10, n10) : { part: q.literal("$"), endIndex: s10 };
}
function Cm(e11, t10) {
  let n10 = [], r10 = 0, s10 = "", i10 = () => {
    s10 && (n10.push(q.literal(s10)), s10 = "");
  };
  for (; r10 < t10.length; ) {
    let o10 = t10[r10];
    if (o10 === "\\" && r10 + 1 < t10.length) {
      let a = t10[r10 + 1];
      if (a === "$" || a === "`" || a === '"' || a === "\\") {
        s10 += a, r10 += 2;
        continue;
      }
      s10 += o10, r10++;
      continue;
    }
    if (o10 === "$") {
      i10();
      let { part: a, endIndex: l } = zl(e11, t10, r10, true);
      a && n10.push(a), r10 = l;
      continue;
    }
    if (o10 === "`") {
      i10();
      let { part: a, endIndex: l } = e11.parseBacktickSubstitution(t10, r10, true);
      n10.push(a), r10 = l;
      continue;
    }
    s10 += o10, r10++;
  }
  return i10(), n10;
}
function Vb(e11, t10, n10) {
  let r10 = [], s10 = n10, i10 = "", o10 = () => {
    i10 && (r10.push(q.literal(i10)), i10 = "");
  };
  for (; s10 < t10.length && t10[s10] !== '"'; ) {
    let a = t10[s10];
    if (a === "\\" && s10 + 1 < t10.length) {
      let l = t10[s10 + 1];
      if ('"\\$`\n'.includes(l)) {
        i10 += l, s10 += 2;
        continue;
      }
      i10 += a, s10++;
      continue;
    }
    if (a === "$") {
      o10();
      let { part: l, endIndex: c } = zl(e11, t10, s10, true);
      l && r10.push(l), s10 = c;
      continue;
    }
    if (a === "`") {
      o10();
      let { part: l, endIndex: c } = e11.parseBacktickSubstitution(t10, s10, true);
      r10.push(l), s10 = c;
      continue;
    }
    i10 += a, s10++;
  }
  return o10(), { part: q.doubleQuoted(r10), endIndex: s10 };
}
function Dn(e11, t10, n10 = false, r10 = false, s10 = false, i10 = false, o10 = false, a = false, l = false, c = false) {
  if (r10)
    return [q.singleQuoted(t10)];
  if (n10) {
    let m = Cm(e11, t10);
    return [q.doubleQuoted(m)];
  }
  if (t10.length >= 2 && t10[0] === '"' && t10[t10.length - 1] === '"') {
    let m = t10.slice(1, -1), d = false;
    for (let g = 0; g < m.length; g++) {
      if (m[g] === '"') {
        d = true;
        break;
      }
      m[g] === "\\" && g + 1 < m.length && g++;
    }
    if (!d) {
      let g = Cm(e11, m);
      return [q.doubleQuoted(g)];
    }
  }
  let u = [], f10 = 0, p = "", h = () => {
    p && (u.push(q.literal(p)), p = "");
  };
  for (; f10 < t10.length; ) {
    let m = t10[f10];
    if (m === "\\" && f10 + 1 < t10.length) {
      let d = t10[f10 + 1];
      if (l) {
        h(), u.push(q.escaped(d)), f10 += 2;
        continue;
      }
      let g = i10 ? d === "$" || d === "`" || d === `
` : d === "$" || d === "`" || d === '"' || d === "'" || d === `
` || c && d === "}", y = o10 ? "*?[]\\".includes(d) : "*?[]\\(){}.^+".includes(d);
      g ? p += d : y ? (h(), u.push(q.escaped(d))) : p += `\\${d}`, f10 += 2;
      continue;
    }
    if (m === "'" && !o10 && !i10) {
      h();
      let d = t10.indexOf("'", f10 + 1);
      if (d === -1) {
        p += t10.slice(f10);
        break;
      }
      u.push(q.singleQuoted(t10.slice(f10 + 1, d))), f10 = d + 1;
      continue;
    }
    if (m === '"' && !i10) {
      h();
      let { part: d, endIndex: g } = Vb(e11, t10, f10 + 1);
      u.push(d), f10 = g + 1;
      continue;
    }
    if (m === "$" && t10[f10 + 1] === "'") {
      h();
      let { part: d, endIndex: g } = hm(e11, t10, f10 + 2);
      u.push(d), f10 = g;
      continue;
    }
    if (m === "$") {
      h();
      let { part: d, endIndex: g } = zl(e11, t10, f10);
      d && u.push(d), f10 = g;
      continue;
    }
    if (m === "`") {
      h();
      let { part: d, endIndex: g } = e11.parseBacktickSubstitution(t10, f10);
      u.push(d), f10 = g;
      continue;
    }
    if (m === "~") {
      let d = f10 > 0 ? t10[f10 - 1] : "";
      if (f10 === 0 || d === "=" || s10 && d === ":") {
        let y = um(e11, t10, f10), w = t10[y];
        if (w === void 0 || w === "/" || w === ":") {
          h();
          let b = t10.slice(f10 + 1, y) || null;
          u.push({ type: "TildeExpansion", user: b }), f10 = y;
          continue;
        }
      }
    }
    if ("@*+?!".includes(m) && f10 + 1 < t10.length && t10[f10 + 1] === "(") {
      let d = Hb(t10, f10 + 1);
      if (d !== -1) {
        h();
        let g = t10.slice(f10, d + 1);
        u.push({ type: "Glob", pattern: g }), f10 = d + 1;
        continue;
      }
    }
    if (m === "*" || m === "?" || m === "[") {
      h();
      let { pattern: d, endIndex: g } = pm(e11, t10, f10);
      u.push({ type: "Glob", pattern: d }), f10 = g;
      continue;
    }
    if (m === "{" && !s10 && !a) {
      let d = dm(e11, t10, f10, Dn);
      if (d) {
        h(), u.push(d.part), f10 = d.endIndex;
        continue;
      }
    }
    p += m, f10++;
  }
  return h(), u;
}
var Nm = I(() => {
  "use strict";
  tr();
  dt();
  er();
  Rl();
});
function km(e11, t10) {
  let n10 = e11.length, r10 = t10 + 3, s10 = 2, i10 = false, o10 = false;
  for (; r10 < n10 && s10 > 0; ) {
    let a = e11[r10];
    if (i10) {
      a === "'" && (i10 = false), r10++;
      continue;
    }
    if (o10) {
      if (a === "\\") {
        r10 += 2;
        continue;
      }
      a === '"' && (o10 = false), r10++;
      continue;
    }
    if (a === "'") {
      i10 = true, r10++;
      continue;
    }
    if (a === '"') {
      o10 = true, r10++;
      continue;
    }
    if (a === "\\") {
      r10 += 2;
      continue;
    }
    if (a === "(") {
      s10++, r10++;
      continue;
    }
    if (a === ")") {
      if (s10--, s10 === 1) {
        let l = r10 + 1;
        return !(l < n10 && e11[l] === ")");
      }
      if (s10 === 0)
        return false;
      r10++;
      continue;
    }
    if (s10 === 1 && (a === "|" && r10 + 1 < n10 && e11[r10 + 1] === "|" || a === "&" && r10 + 1 < n10 && e11[r10 + 1] === "&" || a === "|" && r10 + 1 < n10 && e11[r10 + 1] !== "|"))
      return true;
    r10++;
  }
  return false;
}
function vm2(e11, t10, n10, r10) {
  let s10 = t10 + 2, i10 = 1, o10 = s10, a = false, l = false, c = 0, u = false, f10 = "";
  for (; o10 < e11.length && i10 > 0; ) {
    let d = e11[o10];
    a ? d === "'" && (a = false) : l ? d === "\\" && o10 + 1 < e11.length ? o10++ : d === '"' && (l = false) : d === "'" ? (a = true, f10 = "") : d === '"' ? (l = true, f10 = "") : d === "\\" && o10 + 1 < e11.length ? (o10++, f10 = "") : /[a-zA-Z_]/.test(d) ? f10 += d : (f10 === "case" ? (c++, u = false) : f10 === "in" && c > 0 ? u = true : f10 === "esac" && c > 0 && (c--, u = false), f10 = "", d === "(" ? o10 > 0 && e11[o10 - 1] === "$" ? i10++ : u || i10++ : d === ")" ? u ? u = false : i10-- : d === ";" && c > 0 && o10 + 1 < e11.length && e11[o10 + 1] === ";" && (u = true)), i10 > 0 && o10++;
  }
  i10 > 0 && r10("unexpected EOF while looking for matching `)'");
  let p = e11.slice(s10, o10), m = n10().parse(p);
  return { part: q.commandSubstitution(m, false), endIndex: o10 + 1 };
}
function Im(e11, t10, n10, r10, s10) {
  let o10 = t10 + 1, a = "";
  for (; o10 < e11.length && e11[o10] !== "`"; )
    if (e11[o10] === "\\") {
      let u = e11[o10 + 1];
      u === "$" || u === "`" || u === "\\" || u === `
` || n10 && u === '"' ? (u !== `
` && (a += u), o10 += 2) : (a += e11[o10], o10++);
    } else
      a += e11[o10], o10++;
  o10 >= e11.length && s10("unexpected EOF while looking for matching ``'");
  let c = r10().parse(a);
  return { part: q.commandSubstitution(c, true), endIndex: o10 + 1 };
}
var Om = I(() => {
  "use strict";
  tr();
});
function hn(e11) {
  return new ce().parse(e11);
}
var ce;
var Ke = I(() => {
  "use strict";
  tr();
  dt();
  wm();
  bm();
  Sm();
  Nm();
  Pn();
  Om();
  er();
  er();
  ce = class e11 {
    tokens = [];
    pos = 0;
    pendingHeredocs = [];
    parseIterations = 0;
    parseDepth = 0;
    _input = "";
    getInput() {
      return this._input;
    }
    checkIterationLimit() {
      if (this.parseIterations++, this.parseIterations > G0)
        throw new ot("Maximum parse iterations exceeded (possible infinite loop)", this.current().line, this.current().column);
    }
    enterDepth() {
      if (this.parseDepth++, this.parseDepth > Cl)
        throw new ot(`Maximum parser nesting depth exceeded (${Cl})`, this.current().line, this.current().column);
      return () => {
        this.parseDepth--;
      };
    }
    parse(t10) {
      if (t10.length > Al)
        throw new ot(`Input too large: ${t10.length} bytes exceeds limit of ${Al}`, 1, 1);
      this._input = t10;
      let n10 = new Mi(t10);
      if (this.tokens = n10.tokenize(), this.tokens.length > Sl)
        throw new ot(`Too many tokens: ${this.tokens.length} exceeds limit of ${Sl}`, 1, 1);
      return this.pos = 0, this.pendingHeredocs = [], this.parseIterations = 0, this.parseDepth = 0, this.parseScript();
    }
    parseTokens(t10) {
      return this.tokens = t10, this.pos = 0, this.pendingHeredocs = [], this.parseIterations = 0, this.parseDepth = 0, this.parseScript();
    }
    current() {
      return this.tokens[this.pos] || this.tokens[this.tokens.length - 1];
    }
    peek(t10 = 0) {
      return this.tokens[this.pos + t10] || this.tokens[this.tokens.length - 1];
    }
    advance() {
      let t10 = this.current();
      return this.pos < this.tokens.length - 1 && this.pos++, t10;
    }
    getPos() {
      return this.pos;
    }
    check(t10, n10, r10, s10, ...i10) {
      let o10 = this.tokens[this.pos]?.type;
      return o10 === t10 || n10 !== void 0 && o10 === n10 || r10 !== void 0 && o10 === r10 || s10 !== void 0 && o10 === s10 ? true : i10.length > 0 ? i10.includes(o10) : false;
    }
    expect(t10, n10) {
      if (this.check(t10))
        return this.advance();
      let r10 = this.current();
      throw new ot(n10 || `Expected ${t10}, got ${r10.type}`, r10.line, r10.column, r10);
    }
    error(t10) {
      let n10 = this.current();
      throw new ot(t10, n10.line, n10.column, n10);
    }
    skipNewlines() {
      for (; this.check(E.NEWLINE, E.COMMENT); )
        this.check(E.NEWLINE) ? (this.advance(), this.processHeredocs()) : this.advance();
    }
    skipSeparators(t10 = true) {
      for (; ; ) {
        if (this.check(E.NEWLINE)) {
          this.advance(), this.processHeredocs();
          continue;
        }
        if (this.check(E.SEMICOLON, E.COMMENT)) {
          this.advance();
          continue;
        }
        if (t10 && this.check(E.DSEMI, E.SEMI_AND, E.SEMI_SEMI_AND)) {
          this.advance();
          continue;
        }
        break;
      }
    }
    addPendingHeredoc(t10, n10, r10, s10) {
      this.pendingHeredocs.push({ redirect: t10, delimiter: n10, stripTabs: r10, quoted: s10 });
    }
    processHeredocs() {
      for (let t10 of this.pendingHeredocs)
        if (this.check(E.HEREDOC_CONTENT)) {
          let n10 = this.advance(), r10;
          t10.quoted ? r10 = q.word([q.literal(n10.value)]) : r10 = this.parseWordFromString(n10.value, false, false, false, true), t10.redirect.target = q.hereDoc(t10.delimiter, r10, t10.stripTabs, t10.quoted);
        }
      this.pendingHeredocs = [];
    }
    isStatementEnd() {
      return this.check(E.EOF, E.NEWLINE, E.SEMICOLON, E.AMP, E.AND_AND, E.OR_OR, E.RPAREN, E.RBRACE, E.DSEMI, E.SEMI_AND, E.SEMI_SEMI_AND);
    }
    isCommandStart() {
      let t10 = this.current().type;
      return t10 === E.WORD || t10 === E.NAME || t10 === E.NUMBER || t10 === E.ASSIGNMENT_WORD || t10 === E.IF || t10 === E.FOR || t10 === E.WHILE || t10 === E.UNTIL || t10 === E.CASE || t10 === E.LPAREN || t10 === E.LBRACE || t10 === E.DPAREN_START || t10 === E.DBRACK_START || t10 === E.FUNCTION || t10 === E.BANG || t10 === E.TIME || t10 === E.IN || t10 === E.LESS || t10 === E.GREAT || t10 === E.DLESS || t10 === E.DGREAT || t10 === E.LESSAND || t10 === E.GREATAND || t10 === E.LESSGREAT || t10 === E.DLESSDASH || t10 === E.CLOBBER || t10 === E.TLESS || t10 === E.AND_GREAT || t10 === E.AND_DGREAT;
    }
    parseScript() {
      let t10 = [], r10 = 0;
      for (this.skipNewlines(); !this.check(E.EOF); ) {
        r10++, r10 > 1e4 && this.error("Parser stuck: too many iterations (>10000)");
        let s10 = this.checkUnexpectedToken();
        if (s10) {
          t10.push(s10), this.skipSeparators(false);
          continue;
        }
        let i10 = this.pos, o10 = this.parseStatement();
        o10 && t10.push(o10), this.skipSeparators(false), this.check(E.DSEMI, E.SEMI_AND, E.SEMI_SEMI_AND) && this.error(`syntax error near unexpected token \`${this.current().value}'`), this.pos === i10 && !this.check(E.EOF) && this.advance();
      }
      return q.script(t10);
    }
    checkUnexpectedToken() {
      let t10 = this.current().type, n10 = this.current().value;
      if ((t10 === E.DO || t10 === E.DONE || t10 === E.THEN || t10 === E.ELSE || t10 === E.ELIF || t10 === E.FI || t10 === E.ESAC) && this.error(`syntax error near unexpected token \`${n10}'`), t10 === E.RBRACE || t10 === E.RPAREN) {
        let r10 = `syntax error near unexpected token \`${n10}'`;
        return this.advance(), q.statement([q.pipeline([q.simpleCommand(null, [], [], [])])], [], false, { message: r10, token: n10 });
      }
      return (t10 === E.DSEMI || t10 === E.SEMI_AND || t10 === E.SEMI_SEMI_AND) && this.error(`syntax error near unexpected token \`${n10}'`), t10 === E.SEMICOLON && this.error(`syntax error near unexpected token \`${n10}'`), (t10 === E.PIPE || t10 === E.PIPE_AMP) && this.error(`syntax error near unexpected token \`${n10}'`), null;
    }
    parseStatement() {
      if (this.skipNewlines(), !this.isCommandStart())
        return null;
      let t10 = this.current().start, n10 = [], r10 = [], s10 = false, i10 = this.parsePipeline();
      for (n10.push(i10); this.check(E.AND_AND, E.OR_OR); ) {
        let l = this.advance();
        r10.push(l.type === E.AND_AND ? "&&" : "||"), this.skipNewlines();
        let c = this.parsePipeline();
        n10.push(c);
      }
      this.check(E.AMP) && (this.advance(), s10 = true);
      let o10 = this.pos > 0 ? this.tokens[this.pos - 1].end : t10, a = this._input.slice(t10, o10);
      return q.statement(n10, r10, s10, void 0, a);
    }
    parsePipeline() {
      let t10 = false, n10 = false;
      this.check(E.TIME) && (this.advance(), t10 = true, this.check(E.WORD, E.NAME) && this.current().value === "-p" && (this.advance(), n10 = true));
      let r10 = 0;
      for (; this.check(E.BANG); )
        this.advance(), r10++;
      let s10 = r10 % 2 === 1, i10 = [], o10 = [], a = this.parseCommand();
      for (i10.push(a); this.check(E.PIPE, E.PIPE_AMP); ) {
        let l = this.advance();
        this.skipNewlines(), o10.push(l.type === E.PIPE_AMP);
        let c = this.parseCommand();
        i10.push(c);
      }
      return q.pipeline(i10, s10, t10, n10, o10.length > 0 ? o10 : void 0);
    }
    parseCommand() {
      return this.check(E.IF) ? Tl(this) : this.check(E.FOR) ? Pl(this) : this.check(E.WHILE) ? Dl(this) : this.check(E.UNTIL) ? _l(this) : this.check(E.CASE) ? Ll(this) : this.check(E.LPAREN) ? Fl(this) : this.check(E.LBRACE) ? Ml(this) : this.check(E.DPAREN_START) ? this.dparenClosesWithSpacedParens() ? this.parseNestedSubshellsFromDparen() : this.parseArithmeticCommand() : this.check(E.DBRACK_START) ? this.parseConditionalCommand() : this.check(E.FUNCTION) ? this.parseFunctionDef() : this.check(E.NAME, E.WORD) && this.peek(1).type === E.LPAREN && this.peek(2).type === E.RPAREN ? this.parseFunctionDef() : ym(this);
    }
    dparenClosesWithSpacedParens() {
      let t10 = 1, n10 = 1;
      for (; n10 < this.tokens.length - this.pos; ) {
        let r10 = this.peek(n10);
        if (r10.type === E.EOF)
          return false;
        if (r10.type === E.DPAREN_START || r10.type === E.LPAREN)
          t10++;
        else if (r10.type === E.DPAREN_END) {
          if (t10 -= 2, t10 <= 0)
            return false;
        } else if (r10.type === E.RPAREN && (t10--, t10 === 0 && this.peek(n10 + 1).type === E.RPAREN))
          return true;
        n10++;
      }
      return false;
    }
    parseNestedSubshellsFromDparen() {
      this.advance();
      let t10 = this.parseCompoundList();
      this.expect(E.RPAREN), this.expect(E.RPAREN);
      let n10 = this.parseOptionalRedirections(), r10 = q.subshell(t10, []);
      return q.subshell([q.statement([q.pipeline([r10], false, false, false)])], n10);
    }
    isWord() {
      let t10 = this.current().type;
      return t10 === E.WORD || t10 === E.NAME || t10 === E.NUMBER || t10 === E.IF || t10 === E.FOR || t10 === E.WHILE || t10 === E.UNTIL || t10 === E.CASE || t10 === E.FUNCTION || t10 === E.ELSE || t10 === E.ELIF || t10 === E.FI || t10 === E.THEN || t10 === E.DO || t10 === E.DONE || t10 === E.ESAC || t10 === E.IN || t10 === E.SELECT || t10 === E.TIME || t10 === E.COPROC || t10 === E.BANG;
    }
    parseWord() {
      let t10 = this.advance();
      return this.parseWordFromString(t10.value, t10.quoted, t10.singleQuoted);
    }
    parseWordNoBraceExpansion() {
      let t10 = this.advance();
      return this.parseWordFromString(t10.value, t10.quoted, t10.singleQuoted, false, false, true);
    }
    parseWordForRegex() {
      let t10 = this.advance();
      return this.parseWordFromString(t10.value, t10.quoted, t10.singleQuoted, false, false, true, true);
    }
    parseWordFromString(t10, n10 = false, r10 = false, s10 = false, i10 = false, o10 = false, a = false) {
      let l = Dn(this, t10, n10, r10, s10, i10, false, o10, a);
      return q.word(l);
    }
    parseCommandSubstitution(t10, n10) {
      return vm2(t10, n10, () => new e11(), (r10) => this.error(r10));
    }
    parseBacktickSubstitution(t10, n10, r10 = false) {
      return Im(t10, n10, r10, () => new e11(), (s10) => this.error(s10));
    }
    isDollarDparenSubshell(t10, n10) {
      return km(t10, n10);
    }
    parseArithmeticExpansion(t10, n10) {
      let r10 = n10 + 3, s10 = 1, i10 = 0, o10 = r10;
      for (; o10 < t10.length - 1 && s10 > 0; )
        t10[o10] === "$" && t10[o10 + 1] === "(" ? t10[o10 + 2] === "(" ? (s10++, o10 += 3) : (i10++, o10 += 2) : t10[o10] === "(" && t10[o10 + 1] === "(" ? (s10++, o10 += 2) : t10[o10] === ")" && t10[o10 + 1] === ")" ? i10 > 0 ? (i10--, o10++) : (s10--, s10 > 0 && (o10 += 2)) : t10[o10] === "(" ? (i10++, o10++) : (t10[o10] === ")" && i10 > 0 && i10--, o10++);
      let a = t10.slice(r10, o10), l = this.parseArithmeticExpression(a);
      return { part: q.arithmeticExpansion(l), endIndex: o10 + 2 };
    }
    parseArithmeticCommand() {
      let t10 = this.expect(E.DPAREN_START), n10 = "", r10 = 1, s10 = 0, i10 = false, o10 = false;
      for (; r10 > 0 && !this.check(E.EOF); ) {
        if (i10) {
          if (i10 = false, s10 > 0) {
            s10--, n10 += ")";
            continue;
          }
          if (this.check(E.RPAREN)) {
            r10--, o10 = true, this.advance();
            continue;
          }
          if (this.check(E.DPAREN_END)) {
            r10--, o10 = true;
            continue;
          }
          n10 += ")";
          continue;
        }
        if (this.check(E.DPAREN_START))
          r10++, n10 += "((", this.advance();
        else if (this.check(E.DPAREN_END))
          s10 >= 2 ? (s10 -= 2, n10 += "))", this.advance()) : s10 === 1 ? (s10--, n10 += ")", i10 = true, this.advance()) : (r10--, o10 = true, r10 > 0 && (n10 += "))"), this.advance());
        else if (this.check(E.LPAREN))
          s10++, n10 += "(", this.advance();
        else if (this.check(E.RPAREN))
          s10 > 0 && s10--, n10 += ")", this.advance();
        else {
          let c = this.current().value, u = n10.length > 0 ? n10[n10.length - 1] : "";
          n10.length > 0 && !n10.endsWith(" ") && !(c === "=" && /[|&^+\-*/%<>]$/.test(n10)) && !(c === "<" && u === "<") && !(c === ">" && u === ">") && (n10 += " "), n10 += c, this.advance();
        }
      }
      o10 || this.expect(E.DPAREN_END);
      let a = this.parseArithmeticExpression(n10.trim()), l = this.parseOptionalRedirections();
      return q.arithmeticCommand(a, l, t10.line);
    }
    parseConditionalCommand() {
      let t10 = this.expect(E.DBRACK_START), n10 = Wl(this);
      this.expect(E.DBRACK_END);
      let r10 = this.parseOptionalRedirections();
      return q.conditionalCommand(n10, r10, t10.line);
    }
    parseFunctionDef() {
      let t10;
      if (this.check(E.FUNCTION)) {
        if (this.advance(), this.check(E.NAME) || this.check(E.WORD))
          t10 = this.advance().value;
        else {
          let s10 = this.current();
          throw new ot("Expected function name", s10.line, s10.column, s10);
        }
        this.check(E.LPAREN) && (this.advance(), this.expect(E.RPAREN));
      } else
        t10 = this.advance().value, t10.includes("$") && this.error(`\`${t10}': not a valid identifier`), this.expect(E.LPAREN), this.expect(E.RPAREN);
      this.skipNewlines();
      let n10 = this.parseCompoundCommandBody({ forFunctionBody: true }), r10 = this.parseOptionalRedirections();
      return q.functionDef(t10, n10, r10);
    }
    parseCompoundCommandBody(t10) {
      let n10 = t10?.forFunctionBody;
      if (this.check(E.LBRACE))
        return Ml(this, { skipRedirections: n10 });
      if (this.check(E.LPAREN))
        return Fl(this, { skipRedirections: n10 });
      if (this.check(E.IF))
        return Tl(this, { skipRedirections: n10 });
      if (this.check(E.FOR))
        return Pl(this, { skipRedirections: n10 });
      if (this.check(E.WHILE))
        return Dl(this, { skipRedirections: n10 });
      if (this.check(E.UNTIL))
        return _l(this, { skipRedirections: n10 });
      if (this.check(E.CASE))
        return Ll(this, { skipRedirections: n10 });
      this.error("Expected compound command for function body");
    }
    parseCompoundList() {
      let t10 = this.enterDepth(), n10 = [];
      for (this.skipNewlines(); !this.check(E.EOF, E.FI, E.ELSE, E.ELIF, E.THEN, E.DO, E.DONE, E.ESAC, E.RPAREN, E.RBRACE, E.DSEMI, E.SEMI_AND, E.SEMI_SEMI_AND) && this.isCommandStart(); ) {
        this.checkIterationLimit();
        let r10 = this.pos, s10 = this.parseStatement();
        if (s10 && n10.push(s10), this.skipSeparators(), this.pos === r10 && !s10)
          break;
      }
      return t10(), n10;
    }
    parseOptionalRedirections() {
      let t10 = [];
      for (; Bi(this); ) {
        this.checkIterationLimit();
        let n10 = this.pos;
        if (t10.push(zi(this)), this.pos === n10)
          break;
      }
      return t10;
    }
    parseArithmeticExpression(t10) {
      return Ae(this, t10);
    }
  };
});
function jl(e11) {
  return Qb.get(e11) ?? "";
}
function _m(e11) {
  let t10 = [], n10 = "", r10 = 0;
  for (; r10 < e11.length; ) {
    let s10 = e11[r10];
    if (s10 === "[") {
      for (n10 += s10, r10++, r10 < e11.length && (e11[r10] === "!" || e11[r10] === "^") && (n10 += e11[r10], r10++), r10 < e11.length && e11[r10] === "]" && (n10 += e11[r10], r10++); r10 < e11.length && e11[r10] !== "]"; ) {
        if (e11[r10] === "[" && r10 + 1 < e11.length && e11[r10 + 1] === ":") {
          let i10 = e11.indexOf(":]", r10 + 2);
          if (i10 !== -1) {
            n10 += e11.slice(r10, i10 + 2), r10 = i10 + 2;
            continue;
          }
        }
        if (e11[r10] === "\\" && r10 + 1 < e11.length) {
          n10 += e11[r10] + e11[r10 + 1], r10 += 2;
          continue;
        }
        n10 += e11[r10], r10++;
      }
      r10 < e11.length && e11[r10] === "]" && (n10 += e11[r10], r10++);
    } else
      s10 === ":" ? (n10 !== "" && t10.push(n10), n10 = "", r10++) : s10 === "\\" && r10 + 1 < e11.length ? (n10 += s10 + e11[r10 + 1], r10 += 2) : (n10 += s10, r10++);
  }
  return n10 !== "" && t10.push(n10), t10;
}
function Lm(e11) {
  let t10 = "^";
  for (let n10 = 0; n10 < e11.length; n10++) {
    let r10 = e11[n10];
    if (r10 === "*")
      t10 += "[^/]*";
    else if (r10 === "?")
      t10 += "[^/]";
    else if (r10 === "[") {
      let s10 = n10 + 1, i10 = "[";
      s10 < e11.length && (e11[s10] === "^" || e11[s10] === "!") && (i10 += "^", s10++), s10 < e11.length && e11[s10] === "]" && (i10 += "\\]", s10++);
      let o10 = s10;
      for (; o10 < e11.length; ) {
        if (e11[o10] === "\\" && o10 + 1 < e11.length) {
          o10 += 2;
          continue;
        }
        if (e11[o10] === "[" && o10 + 1 < e11.length && e11[o10 + 1] === ":") {
          let l = e11.indexOf(":]", o10 + 2);
          if (l !== -1) {
            o10 = l + 2;
            continue;
          }
        }
        if (e11[o10] === "]")
          break;
        o10++;
      }
      let a = s10;
      for (; s10 < e11.length && e11[s10] !== "]"; ) {
        if (e11[s10] === "[" && s10 + 1 < e11.length && e11[s10 + 1] === ":") {
          let l = e11.indexOf(":]", s10 + 2);
          if (l !== -1) {
            let c = e11.slice(s10 + 2, l), u = jl(c);
            i10 += u, s10 = l + 2;
            continue;
          }
        }
        if (e11[s10] === "\\" && s10 + 1 < e11.length) {
          i10 += `\\${e11[s10 + 1]}`, s10 += 2;
          continue;
        }
        if (e11[s10] === "-") {
          let l = s10 === a, c = s10 + 1 === o10;
          l || c ? i10 += "\\-" : i10 += "-";
        } else
          i10 += e11[s10];
        s10++;
      }
      i10 += "]", t10 += i10, n10 = s10;
    } else if (r10 === "\\" && n10 + 1 < e11.length) {
      let s10 = e11[n10 + 1];
      /[.+^${}()|\\*?[\]]/.test(s10) ? t10 += `\\${s10}` : t10 += s10, n10++;
    } else
      /[.+^${}()|]/.test(r10) ? t10 += `\\${r10}` : t10 += r10;
  }
  return t10 += "$", V(t10);
}
function Gl(e11, t10) {
  let n10 = 1, r10 = t10 + 1;
  for (; r10 < e11.length && n10 > 0; ) {
    let s10 = e11[r10];
    if (s10 === "\\") {
      r10 += 2;
      continue;
    }
    if (s10 === "(")
      n10++;
    else if (s10 === ")" && (n10--, n10 === 0))
      return r10;
    r10++;
  }
  return -1;
}
function Vl(e11) {
  let t10 = [], n10 = "", r10 = 0, s10 = false, i10 = 0;
  for (; i10 < e11.length; ) {
    let o10 = e11[i10];
    if (o10 === "'" && !s10) {
      s10 = true, n10 += "\0QUOTE_START\0", i10++;
      continue;
    }
    if (o10 === "'" && s10) {
      s10 = false, n10 += "\0QUOTE_END\0", i10++;
      continue;
    }
    if (s10) {
      n10 += o10, i10++;
      continue;
    }
    if (o10 === "\\") {
      n10 += o10, i10 + 1 < e11.length ? (n10 += e11[i10 + 1], i10 += 2) : i10++;
      continue;
    }
    o10 === "(" ? (r10++, n10 += o10) : o10 === ")" ? (r10--, n10 += o10) : o10 === "|" && r10 === 0 ? (t10.push(n10), n10 = "") : n10 += o10, i10++;
  }
  return t10.push(n10), t10;
}
var Qb;
var Fm = I(() => {
  "use strict";
  Fe();
  Qb = /* @__PURE__ */ new Map([["alnum", "a-zA-Z0-9"], ["alpha", "a-zA-Z"], ["ascii", "\\x00-\\x7F"], ["blank", " \\t"], ["cntrl", "\\x00-\\x1F\\x7F"], ["digit", "0-9"], ["graph", "!-~"], ["lower", "a-z"], ["print", " -~"], ["punct", "!-/:-@\\[-`{-~"], ["space", " \\t\\n\\r\\f\\v"], ["upper", "A-Z"], ["word", "a-zA-Z0-9_"], ["xdigit", "0-9a-fA-F"]]);
});
var _n;
var Hi = I(() => {
  "use strict";
  ye();
  Fe();
  lr();
  Fm();
  _n = class {
    fs;
    cwd;
    globignorePatterns = [];
    hasGlobignore = false;
    globstar = false;
    nullglob = false;
    failglob = false;
    dotglob = false;
    extglob = false;
    globskipdots = true;
    ops = { count: 0 };
    maxOps;
    constructor(t10, n10, r10, s10) {
      this.fs = t10, this.cwd = n10, typeof s10 == "boolean" ? (this.globstar = s10, this.maxOps = 1e5) : s10 ? (this.globstar = s10.globstar ?? false, this.nullglob = s10.nullglob ?? false, this.failglob = s10.failglob ?? false, this.dotglob = s10.dotglob ?? false, this.extglob = s10.extglob ?? false, this.globskipdots = s10.globskipdots ?? true, this.maxOps = s10.maxGlobOperations ?? 1e5) : this.maxOps = 1e5;
      let i10 = r10?.get("GLOBIGNORE");
      i10 !== void 0 && i10 !== "" && (this.hasGlobignore = true, this.globignorePatterns = _m(i10));
    }
    checkOpsLimit() {
      if (++this.ops.count > this.maxOps)
        throw new te(`Glob operation limit exceeded (${this.maxOps})`, "glob_operations");
    }
    hasNullglob() {
      return this.nullglob;
    }
    hasFailglob() {
      return this.failglob;
    }
    filterGlobignore(t10) {
      return !this.hasGlobignore && !this.globskipdots ? t10 : t10.filter((n10) => {
        let r10 = n10.split("/").pop() || n10;
        if ((this.hasGlobignore || this.globskipdots) && (r10 === "." || r10 === ".."))
          return false;
        if (this.hasGlobignore) {
          for (let s10 of this.globignorePatterns)
            if (this.matchGlobignorePattern(n10, s10))
              return false;
        }
        return true;
      });
    }
    matchGlobignorePattern(t10, n10) {
      return Lm(n10).test(t10);
    }
    isGlobPattern(t10) {
      return !!(t10.includes("*") || t10.includes("?") || /\[.*\]/.test(t10) || this.extglob && /[@*+?!]\(/.test(t10));
    }
    async expandArgs(t10, n10) {
      let r10 = t10.map((o10, a) => (n10?.[a] ?? false) || !this.isGlobPattern(o10) ? null : this.expand(o10)), s10 = await Promise.all(r10.map((o10) => o10 || Promise.resolve(null))), i10 = [];
      for (let o10 = 0; o10 < t10.length; o10++) {
        let a = s10[o10];
        a === null ? i10.push(t10[o10]) : a.length > 0 ? i10.push(...a) : i10.push(t10[o10]);
      }
      return i10;
    }
    async expand(t10) {
      let n10;
      if (t10.includes("**") && this.globstar && this.isGlobstarValid(t10))
        n10 = await this.expandRecursive(t10);
      else {
        let r10 = t10.replace(/\*\*+/g, "*");
        n10 = await this.expandSimple(r10);
      }
      return this.filterGlobignore(n10);
    }
    isGlobstarValid(t10) {
      let n10 = t10.split("/");
      for (let r10 of n10)
        if (r10.includes("**") && r10 !== "**")
          return false;
      return true;
    }
    hasGlobChars(t10) {
      return !!(t10.includes("*") || t10.includes("?") || /\[.*\]/.test(t10) || this.extglob && /[@*+?!]\(/.test(t10));
    }
    async expandSimple(t10) {
      let n10 = t10.startsWith("/"), r10 = t10.split("/").filter((c) => c !== ""), s10 = -1;
      for (let c = 0; c < r10.length; c++)
        if (this.hasGlobChars(r10[c])) {
          s10 = c;
          break;
        }
      if (s10 === -1)
        return [t10];
      let i10, o10;
      if (s10 === 0)
        n10 ? (i10 = "/", o10 = "/") : (i10 = this.cwd, o10 = "");
      else {
        let c = r10.slice(0, s10);
        n10 ? (i10 = `/${c.join("/")}`, o10 = `/${c.join("/")}`) : (i10 = this.fs.resolvePath(this.cwd, c.join("/")), o10 = c.join("/"));
      }
      let a = r10.slice(s10);
      return (await this.expandSegments(i10, o10, a)).sort();
    }
    async expandSegments(t10, n10, r10) {
      if (this.checkOpsLimit(), r10.length === 0)
        return [n10];
      let [s10, ...i10] = r10, o10 = [];
      try {
        if (this.fs.readdirWithFileTypes) {
          this.checkOpsLimit();
          let a = await this.fs.readdirWithFileTypes(t10), l = [], c = [...a], u = this.dotglob || this.hasGlobignore;
          if (s10.startsWith(".") || this.dotglob) {
            let p = a.some((m) => m.name === "."), h = a.some((m) => m.name === "..");
            p || c.push({ name: ".", isFile: false, isDirectory: true, isSymbolicLink: false }), h || c.push({ name: "..", isFile: false, isDirectory: true, isSymbolicLink: false });
          }
          for (let p of c)
            if (!(p.name.startsWith(".") && !s10.startsWith(".") && !u) && this.matchPattern(p.name, s10)) {
              let h = t10 === "/" ? `/${p.name}` : `${t10}/${p.name}`, m;
              n10 === "" ? m = p.name : n10 === "/" ? m = `/${p.name}` : m = `${n10}/${p.name}`, i10.length === 0 ? l.push(Promise.resolve([m])) : p.isDirectory && l.push(this.expandSegments(h, m, i10));
            }
          let f10 = await Promise.all(l);
          for (let p of f10)
            o10.push(...p);
        } else {
          this.checkOpsLimit();
          let a = await this.fs.readdir(t10), l = [], c = [...a], u = this.dotglob || this.hasGlobignore;
          (s10.startsWith(".") || this.dotglob) && (a.includes(".") || c.push("."), a.includes("..") || c.push(".."));
          for (let p of c)
            if (!(p.startsWith(".") && !s10.startsWith(".") && !u) && this.matchPattern(p, s10)) {
              let h = t10 === "/" ? `/${p}` : `${t10}/${p}`, m;
              n10 === "" ? m = p : n10 === "/" ? m = `/${p}` : m = `${n10}/${p}`, i10.length === 0 ? l.push(Promise.resolve([m])) : l.push((async () => {
                try {
                  if (this.checkOpsLimit(), (await this.fs.stat(h)).isDirectory)
                    return this.expandSegments(h, m, i10);
                } catch (d) {
                  if (d instanceof te)
                    throw d;
                }
                return [];
              })());
            }
          let f10 = await Promise.all(l);
          for (let p of f10)
            o10.push(...p);
        }
      } catch (a) {
        if (a instanceof te)
          throw a;
      }
      return o10;
    }
    async expandRecursive(t10) {
      let n10 = [], r10 = t10.indexOf("**"), s10 = t10.slice(0, r10).replace(/\/$/, "") || ".", o10 = t10.slice(r10 + 2).replace(/^\//, "");
      return o10.includes("**") && this.isGlobstarValid(o10) ? (await this.walkDirectoryMultiGlobstar(s10, o10, n10), [...new Set(n10)].sort()) : (await this.walkDirectory(s10, o10, n10), n10.sort());
    }
    async walkDirectoryMultiGlobstar(t10, n10, r10) {
      this.checkOpsLimit();
      let s10 = this.fs.resolvePath(this.cwd, t10);
      try {
        this.checkOpsLimit();
        let i10 = this.fs.readdirWithFileTypes ? await this.fs.readdirWithFileTypes(s10) : null;
        if (i10) {
          let o10 = [];
          for (let c of i10) {
            let u = t10 === "." ? c.name : `${t10}/${c.name}`;
            c.isDirectory && o10.push(u);
          }
          let a = t10 === "." ? n10 : `${t10}/${n10}`, l = await this.expandRecursive(a);
          r10.push(...l);
          for (let c = 0; c < o10.length; c += 100) {
            let u = o10.slice(c, c + 100);
            await Promise.all(u.map((f10) => this.walkDirectoryMultiGlobstar(f10, n10, r10)));
          }
        } else {
          this.checkOpsLimit();
          let o10 = await this.fs.readdir(s10), a = [];
          for (let u of o10) {
            let f10 = t10 === "." ? u : `${t10}/${u}`, p = this.fs.resolvePath(this.cwd, f10);
            try {
              this.checkOpsLimit(), (await this.fs.stat(p)).isDirectory && a.push(f10);
            } catch (h) {
              if (h instanceof te)
                throw h;
            }
          }
          let l = t10 === "." ? n10 : `${t10}/${n10}`, c = await this.expandRecursive(l);
          r10.push(...c);
          for (let u = 0; u < a.length; u += 100) {
            let f10 = a.slice(u, u + 100);
            await Promise.all(f10.map((p) => this.walkDirectoryMultiGlobstar(p, n10, r10)));
          }
        }
      } catch (i10) {
        if (i10 instanceof te)
          throw i10;
      }
    }
    async walkDirectory(t10, n10, r10) {
      this.checkOpsLimit();
      let s10 = this.fs.resolvePath(this.cwd, t10);
      try {
        if (this.fs.readdirWithFileTypes) {
          this.checkOpsLimit();
          let i10 = await this.fs.readdirWithFileTypes(s10), o10 = [], a = [];
          for (let l of i10) {
            let c = t10 === "." ? l.name : `${t10}/${l.name}`;
            l.isDirectory ? a.push(c) : n10 && this.matchPattern(l.name, n10) && o10.push(c);
          }
          r10.push(...o10);
          for (let l = 0; l < a.length; l += 100) {
            let c = a.slice(l, l + 100);
            await Promise.all(c.map((u) => this.walkDirectory(u, n10, r10)));
          }
        } else {
          this.checkOpsLimit();
          let i10 = await this.fs.readdir(s10), o10 = [];
          for (let l = 0; l < i10.length; l += 100) {
            let c = i10.slice(l, l + 100), u = await Promise.all(c.map(async (f10) => {
              let p = t10 === "." ? f10 : `${t10}/${f10}`, h = this.fs.resolvePath(this.cwd, p);
              try {
                this.checkOpsLimit();
                let m = await this.fs.stat(h);
                return { name: f10, path: p, isDirectory: m.isDirectory };
              } catch (m) {
                if (m instanceof te)
                  throw m;
                return null;
              }
            }));
            o10.push(...u.filter((f10) => f10 !== null));
          }
          for (let l of o10)
            !l.isDirectory && n10 && this.matchPattern(l.name, n10) && r10.push(l.path);
          let a = o10.filter((l) => l.isDirectory);
          for (let l = 0; l < a.length; l += 100) {
            let c = a.slice(l, l + 100);
            await Promise.all(c.map((u) => this.walkDirectory(u.path, n10, r10)));
          }
        }
      } catch (i10) {
        if (i10 instanceof te)
          throw i10;
      }
    }
    matchPattern(t10, n10) {
      return this.patternToRegex(n10).test(t10);
    }
    patternToRegex(t10) {
      let n10 = this.patternToRegexStr(t10);
      return V(`^${n10}$`);
    }
    patternToRegexStr(t10) {
      let n10 = "", r10 = false;
      for (let s10 = 0; s10 < t10.length; s10++) {
        if (t10.slice(s10, s10 + 13) === "\0QUOTE_START\0") {
          r10 = true, s10 += 12;
          continue;
        }
        if (t10.slice(s10, s10 + 11) === "\0QUOTE_END\0") {
          r10 = false, s10 += 10;
          continue;
        }
        let i10 = t10[s10];
        if (r10) {
          /[.+^${}()|\\*?[\]]/.test(i10) ? n10 += `\\${i10}` : n10 += i10;
          continue;
        }
        if (this.extglob && (i10 === "@" || i10 === "*" || i10 === "+" || i10 === "?" || i10 === "!") && s10 + 1 < t10.length && t10[s10 + 1] === "(") {
          let o10 = Gl(t10, s10 + 1);
          if (o10 !== -1) {
            let a = t10.slice(s10 + 2, o10), l = Vl(a), c = l.map((f10) => this.patternToRegexStr(f10)), u = c.length > 0 ? c.join("|") : "(?:)";
            if (i10 === "@")
              n10 += `(?:${u})`;
            else if (i10 === "*")
              n10 += `(?:${u})*`;
            else if (i10 === "+")
              n10 += `(?:${u})+`;
            else if (i10 === "?")
              n10 += `(?:${u})?`;
            else if (i10 === "!")
              if (o10 < t10.length - 1) {
                let p = l.map((m) => this.computePatternLength(m));
                if (p.every((m) => m !== null) && p.every((m) => m === p[0]) && p[0] !== null) {
                  let m = p[0];
                  if (m === 0)
                    n10 += "(?:.+)";
                  else {
                    let d = [];
                    m > 0 && d.push(`.{0,${m - 1}}`), d.push(`.{${m + 1},}`), d.push(`(?!(?:${u})).{${m}}`), n10 += `(?:${d.join("|")})`;
                  }
                } else
                  n10 += `(?:(?!(?:${u})).)*?`;
              } else
                n10 += `(?!(?:${u})$).*`;
            s10 = o10;
            continue;
          }
        }
        if (i10 === "*")
          n10 += ".*";
        else if (i10 === "?")
          n10 += ".";
        else if (i10 === "[") {
          let o10 = s10 + 1, a = "[";
          o10 < t10.length && (t10[o10] === "^" || t10[o10] === "!") && (a += "^", o10++), o10 < t10.length && t10[o10] === "]" && (a += "\\]", o10++);
          let l = o10;
          for (; l < t10.length; ) {
            if (t10[l] === "\\" && l + 1 < t10.length) {
              l += 2;
              continue;
            }
            if (t10[l] === "[" && l + 1 < t10.length && t10[l + 1] === ":") {
              let u = t10.indexOf(":]", l + 2);
              if (u !== -1) {
                l = u + 2;
                continue;
              }
            }
            if (t10[l] === "]")
              break;
            l++;
          }
          let c = o10;
          for (; o10 < t10.length && t10[o10] !== "]"; ) {
            if (t10[o10] === "[" && o10 + 1 < t10.length && t10[o10 + 1] === ":") {
              let u = t10.indexOf(":]", o10 + 2);
              if (u !== -1) {
                let f10 = t10.slice(o10 + 2, u), p = jl(f10);
                a += p, o10 = u + 2;
                continue;
              }
            }
            if (t10[o10] === "\\" && o10 + 1 < t10.length) {
              a += `\\${t10[o10 + 1]}`, o10 += 2;
              continue;
            }
            if (t10[o10] === "-") {
              let u = o10 === c, f10 = o10 + 1 === l;
              u || f10 ? a += "\\-" : a += "-";
            } else
              a += t10[o10];
            o10++;
          }
          a += "]", n10 += a, s10 = o10;
        } else if (i10 === "\\" && s10 + 1 < t10.length) {
          let o10 = t10[s10 + 1];
          /[.+^${}()|\\*?[\]]/.test(o10) ? n10 += `\\${o10}` : n10 += o10, s10++;
        } else
          /[.+^${}()|]/.test(i10) ? n10 += `\\${i10}` : n10 += i10;
      }
      return n10;
    }
    computePatternLength(t10) {
      let n10 = 0, r10 = 0, s10 = false;
      for (; r10 < t10.length; ) {
        if (t10.slice(r10, r10 + 13) === "\0QUOTE_START\0") {
          s10 = true, r10 += 13;
          continue;
        }
        if (t10.slice(r10, r10 + 11) === "\0QUOTE_END\0") {
          s10 = false, r10 += 11;
          continue;
        }
        let i10 = t10[r10];
        if (s10) {
          n10 += 1, r10++;
          continue;
        }
        if ((i10 === "@" || i10 === "*" || i10 === "+" || i10 === "?" || i10 === "!") && r10 + 1 < t10.length && t10[r10 + 1] === "(") {
          let o10 = Gl(t10, r10 + 1);
          if (o10 !== -1) {
            if (i10 === "@") {
              let a = t10.slice(r10 + 2, o10), c = Vl(a).map((u) => this.computePatternLength(u));
              if (c.every((u) => u !== null) && c.every((u) => u === c[0])) {
                n10 += c[0], r10 = o10 + 1;
                continue;
              }
              return null;
            }
            return null;
          }
        }
        if (i10 === "*")
          return null;
        if (i10 === "?") {
          n10 += 1, r10++;
          continue;
        }
        if (i10 === "[") {
          let o10 = t10.indexOf("]", r10 + 1);
          if (o10 !== -1) {
            n10 += 1, r10 = o10 + 1;
            continue;
          }
          n10 += 1, r10++;
          continue;
        }
        if (i10 === "\\") {
          n10 += 1, r10 += 2;
          continue;
        }
        n10 += 1, r10++;
      }
      return n10;
    }
  };
});
function ql(e11) {
  for (let t10 = 0; t10 < e11.length; t10++) {
    if (e11[t10] === "\\") {
      t10++;
      continue;
    }
    if (e11[t10] === "$") {
      let n10 = e11[t10 + 1];
      if (n10 === "{" || n10 && /[a-zA-Z_]/.test(n10))
        return true;
    }
  }
  return false;
}
function Kb(e11) {
  if (!e11.operation)
    return false;
  let t10 = e11.operation, n10;
  if ((t10.type === "DefaultValue" || t10.type === "AssignDefault" || t10.type === "UseAlternative" || t10.type === "ErrorIfUnset") && (n10 = t10.word?.parts), !n10)
    return false;
  for (let r10 of n10)
    if (r10.type === "DoubleQuoted" || r10.type === "SingleQuoted")
      return true;
  return false;
}
function Mm(e11) {
  if (!e11.operation)
    return false;
  let t10 = e11.operation, n10;
  if ((t10.type === "DefaultValue" || t10.type === "AssignDefault" || t10.type === "UseAlternative" || t10.type === "ErrorIfUnset") && (n10 = t10.word?.parts), !n10 || n10.length === 0)
    return false;
  for (let r10 of n10)
    if (r10.type !== "DoubleQuoted" && r10.type !== "SingleQuoted")
      return false;
  return true;
}
function xs(e11) {
  let t10 = false, n10 = false, r10 = false, s10 = false, i10 = false, o10 = false, a = false;
  for (let l of e11) {
    if ((l.type === "SingleQuoted" || l.type === "DoubleQuoted") && (t10 = true, l.type === "DoubleQuoted"))
      for (let c of l.parts)
        c.type === "ParameterExpansion" && (c.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/) && (!c.operation || c.operation.type === "PatternRemoval" || c.operation.type === "PatternReplacement") && (s10 = true), (c.operation?.type === "VarNamePrefix" || c.operation?.type === "ArrayKeys") && (o10 = true), c.operation?.type === "Indirection" && (a = true));
    l.type === "CommandSubstitution" && (n10 = true), l.type === "ParameterExpansion" && (i10 = true, (l.parameter === "@" || l.parameter === "*") && (r10 = true), Kb(l) && (t10 = true), (l.operation?.type === "VarNamePrefix" || l.operation?.type === "ArrayKeys") && (o10 = true), l.operation?.type === "Indirection" && (a = true)), l.type === "Glob" && ql(l.pattern) && (i10 = true);
  }
  return { hasQuoted: t10, hasCommandSub: n10, hasArrayVar: r10, hasArrayAtExpansion: s10, hasParamExpansion: i10, hasVarNamePrefixExpansion: o10, hasIndirection: a };
}
var ji = I(() => {
  "use strict";
});
function Xe(e11, t10) {
  let n10 = `${t10}_`, r10 = [];
  for (let s10 of e11.state.env.keys())
    if (s10.startsWith(n10)) {
      let i10 = s10.slice(n10.length), o10 = Number.parseInt(i10, 10);
      !Number.isNaN(o10) && String(o10) === i10 && r10.push(o10);
    }
  return r10.sort((s10, i10) => s10 - i10);
}
function dn(e11, t10) {
  let n10 = `${t10}_`;
  for (let r10 of e11.state.env.keys())
    r10.startsWith(n10) && e11.state.env.delete(r10);
}
function en(e11, t10) {
  let n10 = `${t10}_`, r10 = `${t10}__length`, s10 = [];
  for (let i10 of e11.state.env.keys())
    if (i10 !== r10 && i10.startsWith(n10)) {
      let o10 = i10.slice(n10.length);
      if (o10.startsWith("_length"))
        continue;
      s10.push(o10);
    }
  return s10.sort();
}
function Gi(e11) {
  return e11.startsWith("'") && e11.endsWith("'") || e11.startsWith('"') && e11.endsWith('"') ? e11.slice(1, -1) : e11;
}
function Zl(e11) {
  if (e11.parts.length < 2)
    return null;
  let t10 = e11.parts[0], n10 = e11.parts[1];
  if (t10.type !== "Glob" || !t10.pattern.startsWith("["))
    return null;
  let r10, s10 = n10, i10 = 1;
  if (n10.type === "Literal" && n10.value.startsWith("]")) {
    let f10 = n10.value.slice(1);
    if (f10.startsWith("+=") || f10.startsWith("="))
      r10 = t10.pattern.slice(1);
    else if (f10 === "") {
      if (e11.parts.length < 3)
        return null;
      let p = e11.parts[2];
      if (p.type !== "Literal" || !p.value.startsWith("=") && !p.value.startsWith("+="))
        return null;
      r10 = t10.pattern.slice(1), s10 = p, i10 = 2;
    } else
      return null;
  } else if (t10.pattern === "[" && (n10.type === "DoubleQuoted" || n10.type === "SingleQuoted")) {
    if (e11.parts.length < 3)
      return null;
    let f10 = e11.parts[2];
    if (f10.type !== "Literal" || !f10.value.startsWith("]=") && !f10.value.startsWith("]+="))
      return null;
    if (n10.type === "SingleQuoted")
      r10 = n10.value;
    else {
      r10 = "";
      for (let p of n10.parts)
        (p.type === "Literal" || p.type === "Escaped") && (r10 += p.value);
    }
    s10 = f10, i10 = 2;
  } else if (t10.pattern.endsWith("]")) {
    if (n10.type !== "Literal" || !n10.value.startsWith("=") && !n10.value.startsWith("+="))
      return null;
    r10 = t10.pattern.slice(1, -1);
  } else
    return null;
  r10 = Gi(r10);
  let o10;
  if (s10.type !== "Literal")
    return null;
  s10.value.startsWith("]=") || s10.value.startsWith("]+=") ? o10 = s10.value.slice(1) : o10 = s10.value;
  let a = o10.startsWith("+=");
  if (!a && !o10.startsWith("="))
    return null;
  let l = [], c = a ? 2 : 1, u = o10.slice(c);
  u && l.push({ type: "Literal", value: u });
  for (let f10 = i10 + 1; f10 < e11.parts.length; f10++) {
    let p = e11.parts[f10];
    p.type === "BraceExpansion" ? l.push({ type: "Literal", value: Xb(p) }) : l.push(p);
  }
  return { key: r10, valueParts: l, append: a };
}
function Xb(e11) {
  return `{${e11.items.map((n10) => {
    if (n10.type === "Range") {
      let r10 = n10.startStr ?? String(n10.start), s10 = n10.endStr ?? String(n10.end), i10 = `${r10}..${s10}`;
      return n10.step && (i10 += `..${n10.step}`), i10;
    }
    return Pr(n10.word);
  }).join(",")}}`;
}
function Pr(e11) {
  let t10 = "";
  for (let n10 of e11.parts)
    switch (n10.type) {
      case "Literal":
        t10 += n10.value;
        break;
      case "Glob":
        t10 += n10.pattern;
        break;
      case "SingleQuoted":
        t10 += n10.value;
        break;
      case "DoubleQuoted":
        for (let r10 of n10.parts)
          (r10.type === "Literal" || r10.type === "Escaped") && (t10 += r10.value);
        break;
      case "Escaped":
        t10 += n10.value;
        break;
      case "BraceExpansion":
        t10 += "{", t10 += n10.items.map((r10) => r10.type === "Range" ? `${r10.startStr}..${r10.endStr}${r10.step ? `..${r10.step}` : ""}` : Pr(r10.word)).join(","), t10 += "}";
        break;
      case "TildeExpansion":
        t10 += "~", n10.user && (t10 += n10.user);
        break;
    }
  return t10;
}
var Qt = I(() => {
  "use strict";
});
function nt(e11) {
  return e11.get("IFS") ?? ` 	
`;
}
function ut(e11) {
  return e11.get("IFS") === "";
}
function Vi(e11) {
  let t10 = nt(e11);
  if (t10 === "")
    return true;
  for (let n10 of t10)
    if (n10 !== " " && n10 !== "	" && n10 !== `
`)
      return false;
  return true;
}
function Um(e11) {
  return e11.split("").map((t10) => /[\\^$.*+?()[\]{}|-]/.test(t10) ? `\\${t10}` : t10 === "	" ? "\\t" : t10 === `
` ? "\\n" : t10).join("");
}
function fe(e11) {
  let t10 = e11.get("IFS");
  return t10 === void 0 ? " " : t10[0] || "";
}
function Jb(e11) {
  return Yb.includes(e11);
}
function Ql(e11) {
  let t10 = /* @__PURE__ */ new Set(), n10 = /* @__PURE__ */ new Set();
  for (let r10 of e11)
    Jb(r10) ? t10.add(r10) : n10.add(r10);
  return { whitespace: t10, nonWhitespace: n10 };
}
function Kl(e11, t10, n10, r10) {
  if (t10 === "")
    return e11 === "" ? { words: [], wordStarts: [] } : { words: [e11], wordStarts: [0] };
  let { whitespace: s10, nonWhitespace: i10 } = Ql(t10), o10 = [], a = [], l = 0;
  for (; l < e11.length && s10.has(e11[l]); )
    l++;
  if (l >= e11.length)
    return { words: [], wordStarts: [] };
  if (i10.has(e11[l]))
    for (o10.push(""), a.push(l), l++; l < e11.length && s10.has(e11[l]); )
      l++;
  for (; l < e11.length && !(n10 !== void 0 && o10.length >= n10); ) {
    let c = l;
    for (a.push(c); l < e11.length; ) {
      let u = e11[l];
      if (!r10 && u === "\\") {
        l++, l < e11.length && l++;
        continue;
      }
      if (s10.has(u) || i10.has(u))
        break;
      l++;
    }
    if (o10.push(e11.substring(c, l)), l >= e11.length)
      break;
    for (; l < e11.length && s10.has(e11[l]); )
      l++;
    if (l < e11.length && i10.has(e11[l])) {
      for (l++; l < e11.length && s10.has(e11[l]); )
        l++;
      for (; l < e11.length && i10.has(e11[l]) && !(n10 !== void 0 && o10.length >= n10); )
        for (o10.push(""), a.push(l), l++; l < e11.length && s10.has(e11[l]); )
          l++;
    }
  }
  return { words: o10, wordStarts: a };
}
function qi(e11, t10) {
  if (t10 === "")
    return { words: e11 ? [e11] : [], hadLeadingDelimiter: false, hadTrailingDelimiter: false };
  if (e11 === "")
    return { words: [], hadLeadingDelimiter: false, hadTrailingDelimiter: false };
  let { whitespace: n10, nonWhitespace: r10 } = Ql(t10), s10 = [], i10 = 0, o10 = false, a = false, l = i10;
  for (; i10 < e11.length && n10.has(e11[i10]); )
    i10++;
  if (i10 > l && (o10 = true), i10 >= e11.length)
    return { words: [], hadLeadingDelimiter: true, hadTrailingDelimiter: true };
  if (r10.has(e11[i10]))
    for (s10.push(""), i10++; i10 < e11.length && n10.has(e11[i10]); )
      i10++;
  for (; i10 < e11.length; ) {
    let c = i10;
    for (; i10 < e11.length; ) {
      let f10 = e11[i10];
      if (n10.has(f10) || r10.has(f10))
        break;
      i10++;
    }
    if (s10.push(e11.substring(c, i10)), i10 >= e11.length) {
      a = false;
      break;
    }
    let u = i10;
    for (; i10 < e11.length && n10.has(e11[i10]); )
      i10++;
    if (i10 < e11.length && r10.has(e11[i10])) {
      for (i10++; i10 < e11.length && n10.has(e11[i10]); )
        i10++;
      for (; i10 < e11.length && r10.has(e11[i10]); )
        for (s10.push(""), i10++; i10 < e11.length && n10.has(e11[i10]); )
          i10++;
    }
    i10 >= e11.length && i10 > u && (a = true);
  }
  return { words: s10, hadLeadingDelimiter: o10, hadTrailingDelimiter: a };
}
function _e(e11, t10) {
  return qi(e11, t10).words;
}
function ex(e11, t10) {
  for (let n10 of e11)
    if (t10.has(n10))
      return true;
  return false;
}
function Wm(e11, t10, n10) {
  if (t10 === "")
    return e11;
  let { whitespace: r10, nonWhitespace: s10 } = Ql(t10), i10 = e11.length;
  for (; i10 > 0 && r10.has(e11[i10 - 1]); ) {
    if (!n10 && i10 >= 2) {
      let a = 0, l = i10 - 2;
      for (; l >= 0 && e11[l] === "\\"; )
        a++, l--;
      if (a % 2 === 1)
        break;
    }
    i10--;
  }
  let o10 = e11.substring(0, i10);
  if (o10.length >= 1 && s10.has(o10[o10.length - 1])) {
    if (!n10 && o10.length >= 2) {
      let l = 0, c = o10.length - 2;
      for (; c >= 0 && o10[c] === "\\"; )
        l++, c--;
      if (l % 2 === 1)
        return o10;
    }
    let a = o10.substring(0, o10.length - 1);
    if (!ex(a, s10))
      return a;
  }
  return o10;
}
var Yb;
var zt = I(() => {
  "use strict";
  Yb = ` 	
`;
});
function Te(e11, t10) {
  return e11.state.namerefs?.has(t10) ?? false;
}
function Sn(e11, t10) {
  e11.state.namerefs ??= /* @__PURE__ */ new Set(), e11.state.namerefs.add(t10);
}
function Bm(e11, t10) {
  e11.state.namerefs?.delete(t10), e11.state.boundNamerefs?.delete(t10), e11.state.invalidNamerefs?.delete(t10);
}
function zm(e11, t10) {
  e11.state.invalidNamerefs ??= /* @__PURE__ */ new Set(), e11.state.invalidNamerefs.add(t10);
}
function Hm(e11, t10) {
  return e11.state.invalidNamerefs?.has(t10) ?? false;
}
function Xl(e11, t10) {
  e11.state.boundNamerefs ??= /* @__PURE__ */ new Set(), e11.state.boundNamerefs.add(t10);
}
function Zi(e11, t10) {
  let n10 = t10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (n10) {
    let s10 = n10[1], i10 = Array.from(e11.state.env.keys()).some((a) => a.startsWith(`${s10}_`) && !a.includes("__")), o10 = e11.state.associativeArrays?.has(s10) ?? false;
    return i10 || o10;
  }
  return Array.from(e11.state.env.keys()).some((s10) => s10.startsWith(`${t10}_`) && !s10.includes("__")) ? true : e11.state.env.has(t10);
}
function At(e11, t10, n10 = 100) {
  if (!Te(e11, t10) || Hm(e11, t10))
    return t10;
  let r10 = /* @__PURE__ */ new Set(), s10 = t10;
  for (; n10-- > 0; ) {
    if (r10.has(s10))
      return;
    if (r10.add(s10), !Te(e11, s10))
      return s10;
    let i10 = e11.state.env.get(s10);
    if (i10 === void 0 || i10 === "" || !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(i10))
      return s10;
    s10 = i10;
  }
}
function rr(e11, t10) {
  if (Te(e11, t10))
    return e11.state.env.get(t10);
}
function jm(e11, t10, n10, r10 = 100) {
  if (!Te(e11, t10) || Hm(e11, t10))
    return t10;
  let s10 = /* @__PURE__ */ new Set(), i10 = t10;
  for (; r10-- > 0; ) {
    if (s10.has(i10))
      return;
    if (s10.add(i10), !Te(e11, i10))
      return i10;
    let o10 = e11.state.env.get(i10);
    if (o10 === void 0 || o10 === "")
      return n10 !== void 0 ? /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(n10) && Zi(e11, n10) ? i10 : null : i10;
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(o10))
      return i10;
    i10 = o10;
  }
}
var tn = I(() => {
  "use strict";
});
function tx(e11, t10) {
  let n10 = t10.replace(/\$\{([a-zA-Z_][a-zA-Z0-9_]*)\}/g, (r10, s10) => e11.state.env.get(s10) ?? "");
  return n10 = n10.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (r10, s10) => e11.state.env.get(s10) ?? ""), n10;
}
function ae(e11, t10) {
  return t10 === "FUNCNAME" ? (e11.state.funcNameStack ?? []).map((i10, o10) => [o10, i10]) : t10 === "BASH_LINENO" ? (e11.state.callLineStack ?? []).map((i10, o10) => [o10, String(i10)]) : t10 === "BASH_SOURCE" ? (e11.state.sourceStack ?? []).map((i10, o10) => [o10, i10]) : e11.state.associativeArrays?.has(t10) ? en(e11, t10).map((i10) => [i10, e11.state.env.get(`${t10}_${i10}`) ?? ""]) : Xe(e11, t10).map((s10) => [s10, e11.state.env.get(`${t10}_${s10}`) ?? ""]);
}
function Cn(e11, t10) {
  return t10 === "FUNCNAME" ? (e11.state.funcNameStack?.length ?? 0) > 0 : t10 === "BASH_LINENO" ? (e11.state.callLineStack?.length ?? 0) > 0 : t10 === "BASH_SOURCE" ? (e11.state.sourceStack?.length ?? 0) > 0 : e11.state.associativeArrays?.has(t10) ? en(e11, t10).length > 0 : Xe(e11, t10).length > 0;
}
async function Se(e11, t10, n10 = true, r10 = false) {
  switch (t10) {
    case "?":
      return String(e11.state.lastExitCode);
    case "$":
      return String(process.pid);
    case "#":
      return e11.state.env.get("#") || "0";
    case "@":
      return e11.state.env.get("@") || "";
    case "_":
      return e11.state.lastArg;
    case "-": {
      let o10 = "";
      return o10 += "h", e11.state.options.errexit && (o10 += "e"), e11.state.options.noglob && (o10 += "f"), e11.state.options.nounset && (o10 += "u"), e11.state.options.verbose && (o10 += "v"), e11.state.options.xtrace && (o10 += "x"), o10 += "B", e11.state.options.noclobber && (o10 += "C"), o10 += "s", o10;
    }
    case "*": {
      let o10 = Number.parseInt(e11.state.env.get("#") || "0", 10);
      if (o10 === 0)
        return "";
      let a = [];
      for (let l = 1; l <= o10; l++)
        a.push(e11.state.env.get(String(l)) || "");
      return a.join(fe(e11.state.env));
    }
    case "0":
      return e11.state.env.get("0") || "bash";
    case "PWD":
      return e11.state.env.get("PWD") ?? "";
    case "OLDPWD":
      return e11.state.env.get("OLDPWD") ?? "";
    case "PPID": {
      let { ppid: o10 } = ys();
      return String(o10);
    }
    case "UID": {
      let { uid: o10 } = ys();
      return String(o10);
    }
    case "EUID":
      return String(process.geteuid?.() ?? ys().uid);
    case "RANDOM":
      return String(Math.floor(Math.random() * 32768));
    case "SECONDS":
      return String(Math.floor((Date.now() - e11.state.startTime) / 1e3));
    case "BASH_VERSION":
      return F0;
    case "!":
      return String(e11.state.lastBackgroundPid);
    case "BASHPID":
      return String(e11.state.bashPid);
    case "LINENO":
      return String(e11.state.currentLine);
    case "FUNCNAME": {
      let o10 = e11.state.funcNameStack?.[0];
      if (o10 !== void 0)
        return o10;
      if (n10 && e11.state.options.nounset)
        throw new yt("FUNCNAME");
      return "";
    }
    case "BASH_LINENO": {
      let o10 = e11.state.callLineStack?.[0];
      if (o10 !== void 0)
        return String(o10);
      if (n10 && e11.state.options.nounset)
        throw new yt("BASH_LINENO");
      return "";
    }
    case "BASH_SOURCE": {
      let o10 = e11.state.sourceStack?.[0];
      if (o10 !== void 0)
        return o10;
      if (n10 && e11.state.options.nounset)
        throw new yt("BASH_SOURCE");
      return "";
    }
  }
  if (/^[a-zA-Z_][a-zA-Z0-9_]*\[\]$/.test(t10))
    throw new wt(`\${${t10}}`);
  let s10 = t10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (s10) {
    let o10 = s10[1], a = s10[2];
    if (Te(e11, o10)) {
      let f10 = At(e11, o10);
      if (f10 && f10 !== o10) {
        if (f10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/))
          return "";
        o10 = f10;
      }
    }
    if (a === "@" || a === "*") {
      let f10 = ae(e11, o10);
      if (f10.length > 0)
        return f10.map(([, h]) => h).join(" ");
      let p = e11.state.env.get(o10);
      return p !== void 0 ? p : "";
    }
    if (o10 === "FUNCNAME") {
      let f10 = Number.parseInt(a, 10);
      return !Number.isNaN(f10) && f10 >= 0 ? e11.state.funcNameStack?.[f10] ?? "" : "";
    }
    if (o10 === "BASH_LINENO") {
      let f10 = Number.parseInt(a, 10);
      if (!Number.isNaN(f10) && f10 >= 0) {
        let p = e11.state.callLineStack?.[f10];
        return p !== void 0 ? String(p) : "";
      }
      return "";
    }
    if (o10 === "BASH_SOURCE") {
      let f10 = Number.parseInt(a, 10);
      return !Number.isNaN(f10) && f10 >= 0 ? e11.state.sourceStack?.[f10] ?? "" : "";
    }
    if (e11.state.associativeArrays?.has(o10)) {
      let f10 = Gi(a);
      f10 = tx(e11, f10);
      let p = e11.state.env.get(`${o10}_${f10}`);
      if (p === void 0 && n10 && e11.state.options.nounset)
        throw new yt(`${o10}[${a}]`);
      return p || "";
    }
    let c;
    if (/^-?\d+$/.test(a))
      c = Number.parseInt(a, 10);
    else
      try {
        let f10 = new ce(), p = Ae(f10, a);
        c = await ne(e11, p.expression);
      } catch {
        let f10 = e11.state.env.get(a);
        c = f10 ? Number.parseInt(f10, 10) : 0, Number.isNaN(c) && (c = 0);
      }
    if (c < 0) {
      let f10 = ae(e11, o10), p = e11.state.currentLine;
      if (f10.length === 0)
        return e11.state.expansionStderr = (e11.state.expansionStderr || "") + `bash: line ${p}: ${o10}: bad array subscript
`, "";
      let m = Math.max(...f10.map(([g]) => typeof g == "number" ? g : 0)) + 1 + c;
      return m < 0 ? (e11.state.expansionStderr = (e11.state.expansionStderr || "") + `bash: line ${p}: ${o10}: bad array subscript
`, "") : e11.state.env.get(`${o10}_${m}`) || "";
    }
    let u = e11.state.env.get(`${o10}_${c}`);
    if (u !== void 0)
      return u;
    if (c === 0) {
      let f10 = e11.state.env.get(o10);
      if (f10 !== void 0)
        return f10;
    }
    if (n10 && e11.state.options.nounset)
      throw new yt(`${o10}[${c}]`);
    return "";
  }
  if (/^[1-9][0-9]*$/.test(t10)) {
    let o10 = e11.state.env.get(t10);
    if (o10 === void 0 && n10 && e11.state.options.nounset)
      throw new yt(t10);
    return o10 || "";
  }
  if (Te(e11, t10)) {
    let o10 = At(e11, t10);
    if (o10 === void 0)
      return "";
    if (o10 !== t10)
      return await Se(e11, o10, n10, r10);
    let a = e11.state.env.get(t10);
    if ((a === void 0 || a === "") && n10 && e11.state.options.nounset)
      throw new yt(t10);
    return a || "";
  }
  let i10 = e11.state.env.get(t10);
  if (i10 !== void 0)
    return e11.state.tempEnvBindings?.some((o10) => o10.has(t10)) && (e11.state.accessedTempEnvVars = e11.state.accessedTempEnvVars || /* @__PURE__ */ new Set(), e11.state.accessedTempEnvVars.add(t10)), i10;
  if (Cn(e11, t10)) {
    let o10 = e11.state.env.get(`${t10}_0`);
    return o10 !== void 0 ? o10 : "";
  }
  if (n10 && e11.state.options.nounset)
    throw new yt(t10);
  return "";
}
async function mn(e11, t10) {
  if ((/* @__PURE__ */ new Set(["?", "$", "#", "_", "-", "0", "PPID", "UID", "EUID", "RANDOM", "SECONDS", "BASH_VERSION", "!", "BASHPID", "LINENO"])).has(t10))
    return true;
  if (t10 === "@" || t10 === "*")
    return Number.parseInt(e11.state.env.get("#") || "0", 10) > 0;
  if (t10 === "PWD" || t10 === "OLDPWD")
    return e11.state.env.has(t10);
  let r10 = t10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (r10) {
    let s10 = r10[1], i10 = r10[2];
    if (Te(e11, s10)) {
      let l = At(e11, s10);
      if (l && l !== s10) {
        if (l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/))
          return false;
        s10 = l;
      }
    }
    if (i10 === "@" || i10 === "*")
      return ae(e11, s10).length > 0 ? true : e11.state.env.has(s10);
    if (e11.state.associativeArrays?.has(s10)) {
      let l = Gi(i10);
      return e11.state.env.has(`${s10}_${l}`);
    }
    let a;
    if (/^-?\d+$/.test(i10))
      a = Number.parseInt(i10, 10);
    else
      try {
        let l = new ce(), c = Ae(l, i10);
        a = await ne(e11, c.expression);
      } catch {
        let l = e11.state.env.get(i10);
        a = l ? Number.parseInt(l, 10) : 0, Number.isNaN(a) && (a = 0);
      }
    if (a < 0) {
      let l = ae(e11, s10);
      if (l.length === 0)
        return false;
      let u = Math.max(...l.map(([f10]) => typeof f10 == "number" ? f10 : 0)) + 1 + a;
      return u < 0 ? false : e11.state.env.has(`${s10}_${u}`);
    }
    return e11.state.env.has(`${s10}_${a}`);
  }
  if (Te(e11, t10)) {
    let s10 = At(e11, t10);
    return s10 === void 0 || s10 === t10 ? e11.state.env.has(t10) : mn(e11, s10);
  }
  return !!(e11.state.env.has(t10) || Cn(e11, t10));
}
var Tt = I(() => {
  "use strict";
  dt();
  Ke();
  wl();
  St();
  ye();
  Qt();
  zt();
  tn();
});
async function Gm(e11, t10) {
  let n10 = "", r10 = 0;
  for (; r10 < t10.length; ) {
    if (t10[r10] === "$") {
      if (t10[r10 + 1] === "{") {
        let s10 = 1, i10 = r10 + 2;
        for (; i10 < t10.length && s10 > 0; )
          t10[i10] === "{" ? s10++ : t10[i10] === "}" && s10--, i10++;
        n10 += t10.slice(r10, i10), r10 = i10;
        continue;
      }
      if (t10[r10 + 1] === "(") {
        let s10 = 1, i10 = r10 + 2;
        for (; i10 < t10.length && s10 > 0; )
          t10[i10] === "(" ? s10++ : t10[i10] === ")" && s10--, i10++;
        n10 += t10.slice(r10, i10), r10 = i10;
        continue;
      }
      if (/[a-zA-Z_]/.test(t10[r10 + 1] || "")) {
        let s10 = r10 + 1;
        for (; s10 < t10.length && /[a-zA-Z0-9_]/.test(t10[s10]); )
          s10++;
        let i10 = t10.slice(r10 + 1, s10), o10 = await Se(e11, i10);
        n10 += o10, r10 = s10;
        continue;
      }
      if (/[0-9]/.test(t10[r10 + 1] || "")) {
        let s10 = r10 + 1;
        for (; s10 < t10.length && /[0-9]/.test(t10[s10]); )
          s10++;
        let i10 = t10.slice(r10 + 1, s10), o10 = await Se(e11, i10);
        n10 += o10, r10 = s10;
        continue;
      }
      if (/[*@#?\-!$]/.test(t10[r10 + 1] || "")) {
        let s10 = t10[r10 + 1], i10 = await Se(e11, s10);
        n10 += i10, r10 += 2;
        continue;
      }
    }
    if (t10[r10] === '"') {
      for (n10 += '"', r10++; r10 < t10.length && t10[r10] !== '"'; )
        if (t10[r10] === "$" && /[a-zA-Z_]/.test(t10[r10 + 1] || "")) {
          let s10 = r10 + 1;
          for (; s10 < t10.length && /[a-zA-Z0-9_]/.test(t10[s10]); )
            s10++;
          let i10 = t10.slice(r10 + 1, s10), o10 = await Se(e11, i10);
          n10 += o10, r10 = s10;
        } else
          t10[r10] === "\\" ? (n10 += t10[r10], r10++, r10 < t10.length && (n10 += t10[r10], r10++)) : (n10 += t10[r10], r10++);
      r10 < t10.length && (n10 += '"', r10++);
      continue;
    }
    n10 += t10[r10], r10++;
  }
  return n10;
}
async function Yl(e11, t10) {
  let n10 = t10, r10 = t10.startsWith('"') && t10.endsWith('"'), s10 = t10.startsWith("'") && t10.endsWith("'");
  if ((r10 || s10) && (n10 = t10.slice(1, -1)), s10)
    return n10;
  let i10 = "", o10 = 0;
  for (; o10 < n10.length; )
    if (n10[o10] === "$")
      if (n10[o10 + 1] === "(") {
        let a = 1, l = o10 + 2;
        for (; l < n10.length && a > 0; )
          n10[l] === "(" && n10[l - 1] === "$" || n10[l] === "(" ? a++ : n10[l] === ")" && a--, l++;
        let c = n10.slice(o10 + 2, l - 1);
        if (e11.execFn) {
          let u = await e11.execFn(c);
          i10 += u.stdout.replace(/\n+$/, ""), u.stderr && (e11.state.expansionStderr = (e11.state.expansionStderr || "") + u.stderr);
        }
        o10 = l;
      } else if (n10[o10 + 1] === "{") {
        let a = 1, l = o10 + 2;
        for (; l < n10.length && a > 0; )
          n10[l] === "{" ? a++ : n10[l] === "}" && a--, l++;
        let c = n10.slice(o10 + 2, l - 1), u = await Se(e11, c);
        i10 += u, o10 = l;
      } else if (/[a-zA-Z_]/.test(n10[o10 + 1] || "")) {
        let a = o10 + 1;
        for (; a < n10.length && /[a-zA-Z0-9_]/.test(n10[a]); )
          a++;
        let l = n10.slice(o10 + 1, a), c = await Se(e11, l);
        i10 += c, o10 = a;
      } else
        i10 += n10[o10], o10++;
    else if (n10[o10] === "`") {
      let a = o10 + 1;
      for (; a < n10.length && n10[a] !== "`"; )
        a++;
      let l = n10.slice(o10 + 1, a);
      if (e11.execFn) {
        let c = await e11.execFn(l);
        i10 += c.stdout.replace(/\n+$/, ""), c.stderr && (e11.state.expansionStderr = (e11.state.expansionStderr || "") + c.stderr);
      }
      o10 = a + 1;
    } else
      i10 += n10[o10], o10++;
  return i10;
}
var Vm = I(() => {
  "use strict";
  Tt();
});
function nx(e11, t10, n10, r10, s10) {
  let i10 = n10 ?? 1;
  i10 === 0 && (i10 = 1);
  let o10 = Math.abs(i10), a = [], l = 0;
  r10?.match(/^-?0\d/) && (l = Math.max(l, r10.replace(/^-/, "").length)), s10?.match(/^-?0\d/) && (l = Math.max(l, s10.replace(/^-/, "").length));
  let c = (u) => {
    if (l > 0) {
      let f10 = u < 0, p = String(Math.abs(u)).padStart(l, "0");
      return f10 ? `-${p}` : p;
    }
    return String(u);
  };
  if (e11 <= t10)
    for (let u = e11, f10 = 0; u <= t10 && f10 < Qi; u += o10, f10++)
      a.push(c(u));
  else
    for (let u = e11, f10 = 0; u >= t10 && f10 < Qi; u -= o10, f10++)
      a.push(c(u));
  return a;
}
function rx(e11, t10, n10) {
  let r10 = n10 ?? 1;
  r10 === 0 && (r10 = 1);
  let s10 = e11.charCodeAt(0), i10 = t10.charCodeAt(0), o10 = Math.abs(r10), a = e11 >= "A" && e11 <= "Z", l = e11 >= "a" && e11 <= "z", c = t10 >= "A" && t10 <= "Z", u = t10 >= "a" && t10 <= "z";
  if (a && u || l && c) {
    let p = n10 !== void 0 ? `..${n10}` : "";
    throw new ur(`{${e11}..${t10}${p}}: invalid sequence`);
  }
  let f10 = [];
  if (s10 <= i10)
    for (let p = s10, h = 0; p <= i10 && h < Qi; p += o10, h++)
      f10.push(String.fromCharCode(p));
  else
    for (let p = s10, h = 0; p >= i10 && h < Qi; p -= o10, h++)
      f10.push(String.fromCharCode(p));
  return f10;
}
function Jl(e11, t10, n10, r10, s10) {
  let i10 = n10 !== void 0 ? `..${n10}` : "";
  return typeof e11 == "number" && typeof t10 == "number" ? { expanded: nx(e11, t10, n10, r10, s10), literal: `{${e11}..${t10}${i10}}` } : typeof e11 == "string" && typeof t10 == "string" ? { expanded: rx(e11, t10, n10), literal: `{${e11}..${t10}${i10}}` } : { expanded: null, literal: `{${e11}..${t10}${i10}}` };
}
var Qi;
var qm = I(() => {
  "use strict";
  ye();
  Qi = 1e4;
});
function Zm(e11) {
  if (e11.statements.length !== 1)
    return null;
  let t10 = e11.statements[0];
  if (t10.operators.length !== 0 || t10.pipelines.length !== 1)
    return null;
  let n10 = t10.pipelines[0];
  if (n10.negated || n10.commands.length !== 1)
    return null;
  let r10 = n10.commands[0];
  if (r10.type !== "SimpleCommand")
    return null;
  let s10 = r10;
  if (s10.name !== null || s10.args.length !== 0 || s10.assignments.length !== 0 || s10.redirections.length !== 1)
    return null;
  let i10 = s10.redirections[0];
  return i10.operator !== "<" || i10.target.type !== "Word" ? null : { target: i10.target };
}
var Qm = I(() => {
  "use strict";
});
function gn(e11, t10) {
  return !!(/[*?[]/.test(e11) || t10 && /[@*+?!]\(/.test(e11));
}
function ec(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; )
    e11[n10] === "\\" && n10 + 1 < e11.length ? (t10 += e11[n10 + 1], n10 += 2) : (t10 += e11[n10], n10++);
  return t10;
}
function Pt(e11) {
  return e11.replace(/([*?[\]\\()|])/g, "\\$1");
}
function Dr(e11) {
  return e11.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
}
var _r = I(() => {
  "use strict";
});
function xe(e11) {
  return e11.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var Lr = I(() => {
  "use strict";
});
function me(e11, t10, n10 = false) {
  let r10 = "", s10 = 0;
  for (; s10 < e11.length; ) {
    let i10 = e11[s10];
    if (n10 && (i10 === "@" || i10 === "*" || i10 === "+" || i10 === "?" || i10 === "!") && s10 + 1 < e11.length && e11[s10 + 1] === "(") {
      let o10 = sx(e11, s10 + 1);
      if (o10 !== -1) {
        let a = e11.slice(s10 + 2, o10), c = ix(a).map((f10) => me(f10, t10, n10)), u = c.length > 0 ? c.join("|") : "(?:)";
        i10 === "@" ? r10 += `(?:${u})` : i10 === "*" ? r10 += `(?:${u})*` : i10 === "+" ? r10 += `(?:${u})+` : i10 === "?" ? r10 += `(?:${u})?` : i10 === "!" && (r10 += `(?!(?:${u})$).*`), s10 = o10 + 1;
        continue;
      }
    }
    if (i10 === "\\")
      if (s10 + 1 < e11.length) {
        let o10 = e11[s10 + 1];
        /[\\^$.|+(){}[\]*?]/.test(o10) ? r10 += `\\${o10}` : r10 += o10, s10 += 2;
      } else
        r10 += "\\\\", s10++;
    else if (i10 === "*")
      r10 += t10 ? ".*" : ".*?", s10++;
    else if (i10 === "?")
      r10 += ".", s10++;
    else if (i10 === "[") {
      let o10 = ox(e11, s10);
      if (o10 === -1)
        r10 += "\\[", s10++;
      else {
        let a = e11.slice(s10 + 1, o10);
        r10 += ax(a), s10 = o10 + 1;
      }
    } else
      /[\^$.|+(){}]/.test(i10) ? (r10 += `\\${i10}`, s10++) : (r10 += i10, s10++);
  }
  return r10;
}
function sx(e11, t10) {
  let n10 = 1, r10 = t10 + 1;
  for (; r10 < e11.length && n10 > 0; ) {
    let s10 = e11[r10];
    if (s10 === "\\") {
      r10 += 2;
      continue;
    }
    if (s10 === "(")
      n10++;
    else if (s10 === ")" && (n10--, n10 === 0))
      return r10;
    r10++;
  }
  return -1;
}
function ix(e11) {
  let t10 = [], n10 = "", r10 = 0, s10 = 0;
  for (; s10 < e11.length; ) {
    let i10 = e11[s10];
    if (i10 === "\\") {
      n10 += i10, s10 + 1 < e11.length ? (n10 += e11[s10 + 1], s10 += 2) : s10++;
      continue;
    }
    i10 === "(" ? (r10++, n10 += i10) : i10 === ")" ? (r10--, n10 += i10) : i10 === "|" && r10 === 0 ? (t10.push(n10), n10 = "") : n10 += i10, s10++;
  }
  return t10.push(n10), t10;
}
function ox(e11, t10) {
  let n10 = t10 + 1;
  for (n10 < e11.length && e11[n10] === "^" && n10++, n10 < e11.length && e11[n10] === "]" && n10++; n10 < e11.length; ) {
    if (e11[n10] === "\\" && n10 + 1 < e11.length) {
      n10 += 2;
      continue;
    }
    if (e11[n10] === "]")
      return n10;
    if (e11[n10] === "'") {
      let r10 = e11.indexOf("'", n10 + 1);
      if (r10 !== -1) {
        n10 = r10 + 1;
        continue;
      }
    }
    if (e11[n10] === "[" && n10 + 1 < e11.length && e11[n10 + 1] === ":") {
      let r10 = e11.indexOf(":]", n10 + 2);
      if (r10 !== -1) {
        n10 = r10 + 2;
        continue;
      }
    }
    n10++;
  }
  return -1;
}
function ax(e11) {
  let t10 = "[", n10 = 0;
  for ((e11[0] === "^" || e11[0] === "!") && (t10 += "^", n10++); n10 < e11.length; ) {
    if (e11[n10] === "'") {
      let s10 = e11.indexOf("'", n10 + 1);
      if (s10 !== -1) {
        let i10 = e11.slice(n10 + 1, s10);
        for (let o10 of i10)
          o10 === "\\" ? t10 += "\\\\" : o10 === "]" ? t10 += "\\]" : o10 === "^" && t10 === "[" ? t10 += "\\^" : t10 += o10;
        n10 = s10 + 1;
        continue;
      }
    }
    if (e11[n10] === "[" && n10 + 1 < e11.length && e11[n10 + 1] === ":") {
      let s10 = e11.indexOf(":]", n10 + 2);
      if (s10 !== -1) {
        let i10 = e11.slice(n10 + 2, s10);
        t10 += cx(i10), n10 = s10 + 2;
        continue;
      }
    }
    let r10 = e11[n10];
    r10 === "\\" ? n10 + 1 < e11.length ? (t10 += `\\${e11[n10 + 1]}`, n10 += 2) : (t10 += "\\\\", n10++) : r10 === "-" && n10 > 0 && n10 < e11.length - 1 ? (t10 += "-", n10++) : r10 === "^" && n10 === 0 ? (t10 += "^", n10++) : (r10 === "]" && n10 === 0 ? t10 += "\\]" : t10 += r10, n10++);
  }
  return t10 += "]", t10;
}
function cx(e11) {
  return lx.get(e11) ?? "";
}
var lx;
var Fr = I(() => {
  "use strict";
  lx = /* @__PURE__ */ new Map([["alnum", "a-zA-Z0-9"], ["alpha", "a-zA-Z"], ["ascii", "\\x00-\\x7F"], ["blank", " \\t"], ["cntrl", "\\x00-\\x1F\\x7F"], ["digit", "0-9"], ["graph", "!-~"], ["lower", "a-z"], ["print", " -~"], ["punct", "!-/:-@\\[-`{-~"], ["space", " \\t\\n\\r\\f\\v"], ["upper", "A-Z"], ["word", "a-zA-Z0-9_"], ["xdigit", "0-9A-Fa-f"]]);
});
function Nn(e11, t10, n10, r10) {
  if (n10 === "prefix")
    return V(`^${t10}`, "s").replace(e11, "");
  let s10 = V(`${t10}$`, "s");
  if (r10)
    return s10.replace(e11, "");
  for (let i10 = e11.length; i10 >= 0; i10--) {
    let o10 = e11.slice(i10);
    if (s10.test(o10))
      return e11.slice(0, i10);
  }
  return e11;
}
function Mr(e11, t10) {
  let n10 = Array.from(e11.state.env.keys()), r10 = /* @__PURE__ */ new Set(), s10 = e11.state.associativeArrays ?? /* @__PURE__ */ new Set(), i10 = /* @__PURE__ */ new Set();
  for (let a of n10) {
    let l = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_\d+$/);
    l && i10.add(l[1]);
    let c = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
    c && i10.add(c[1]);
  }
  let o10 = (a) => {
    for (let l of s10) {
      let c = `${l}_`;
      if (a.startsWith(c) && a !== l)
        return true;
    }
    return false;
  };
  for (let a of n10)
    if (a.startsWith(t10))
      if (a.includes("__")) {
        let l = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
        l?.[1].startsWith(t10) && r10.add(l[1]);
      } else if (/_\d+$/.test(a)) {
        let l = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_\d+$/);
        l?.[1].startsWith(t10) && r10.add(l[1]);
      } else
        o10(a) || r10.add(a);
  return [...r10].sort();
}
var sr = I(() => {
  "use strict";
  Fe();
});
function ux(e11, t10) {
  let n10 = (i10, o10 = 2) => String(i10).padStart(o10, "0");
  if (e11 === "") {
    let i10 = n10(t10.getHours()), o10 = n10(t10.getMinutes()), a = n10(t10.getSeconds());
    return `${i10}:${o10}:${a}`;
  }
  let r10 = "", s10 = 0;
  for (; s10 < e11.length; )
    if (e11[s10] === "%") {
      if (s10 + 1 >= e11.length) {
        r10 += "%", s10++;
        continue;
      }
      let i10 = e11[s10 + 1];
      switch (i10) {
        case "H":
          r10 += n10(t10.getHours());
          break;
        case "M":
          r10 += n10(t10.getMinutes());
          break;
        case "S":
          r10 += n10(t10.getSeconds());
          break;
        case "d":
          r10 += n10(t10.getDate());
          break;
        case "m":
          r10 += n10(t10.getMonth() + 1);
          break;
        case "Y":
          r10 += t10.getFullYear();
          break;
        case "y":
          r10 += n10(t10.getFullYear() % 100);
          break;
        case "I": {
          let o10 = t10.getHours() % 12;
          o10 === 0 && (o10 = 12), r10 += n10(o10);
          break;
        }
        case "p":
          r10 += t10.getHours() < 12 ? "AM" : "PM";
          break;
        case "P":
          r10 += t10.getHours() < 12 ? "am" : "pm";
          break;
        case "%":
          r10 += "%";
          break;
        case "a": {
          r10 += ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][t10.getDay()];
          break;
        }
        case "b": {
          r10 += ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][t10.getMonth()];
          break;
        }
        default:
          r10 += `%${i10}`;
      }
      s10 += 2;
    } else
      r10 += e11[s10], s10++;
  return r10;
}
function Es(e11, t10) {
  let n10 = "", r10 = 0, s10 = e11.state.env.get("USER") || e11.state.env.get("LOGNAME") || "user", i10 = e11.state.env.get("HOSTNAME") || "localhost", o10 = i10.split(".")[0], a = e11.state.env.get("PWD") || "/", l = e11.state.env.get("HOME") || "/", c = a.startsWith(l) ? `~${a.slice(l.length)}` : a, u = a.split("/").pop() || a, f10 = /* @__PURE__ */ new Date(), p = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], h = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], m = e11.state.env.get("__COMMAND_NUMBER") || "1";
  for (; r10 < t10.length; ) {
    let d = t10[r10];
    if (d === "\\") {
      if (r10 + 1 >= t10.length) {
        n10 += "\\", r10++;
        continue;
      }
      let g = t10[r10 + 1];
      if (g >= "0" && g <= "7") {
        let y = "", w = r10 + 1;
        for (; w < t10.length && w < r10 + 4 && t10[w] >= "0" && t10[w] <= "7"; )
          y += t10[w], w++;
        let b = Number.parseInt(y, 8) % 256;
        n10 += String.fromCharCode(b), r10 = w;
        continue;
      }
      switch (g) {
        case "\\":
          n10 += "\\", r10 += 2;
          break;
        case "a":
          n10 += "\x07", r10 += 2;
          break;
        case "e":
          n10 += "\x1B", r10 += 2;
          break;
        case "n":
          n10 += `
`, r10 += 2;
          break;
        case "r":
          n10 += "\r", r10 += 2;
          break;
        case "$":
          n10 += "$", r10 += 2;
          break;
        case "[":
        case "]":
          r10 += 2;
          break;
        case "u":
          n10 += s10, r10 += 2;
          break;
        case "h":
          n10 += o10, r10 += 2;
          break;
        case "H":
          n10 += i10, r10 += 2;
          break;
        case "w":
          n10 += c, r10 += 2;
          break;
        case "W":
          n10 += u, r10 += 2;
          break;
        case "d": {
          let y = String(f10.getDate()).padStart(2, " ");
          n10 += `${p[f10.getDay()]} ${h[f10.getMonth()]} ${y}`, r10 += 2;
          break;
        }
        case "t": {
          let y = String(f10.getHours()).padStart(2, "0"), w = String(f10.getMinutes()).padStart(2, "0"), b = String(f10.getSeconds()).padStart(2, "0");
          n10 += `${y}:${w}:${b}`, r10 += 2;
          break;
        }
        case "T": {
          let y = f10.getHours() % 12;
          y === 0 && (y = 12);
          let w = String(y).padStart(2, "0"), b = String(f10.getMinutes()).padStart(2, "0"), x = String(f10.getSeconds()).padStart(2, "0");
          n10 += `${w}:${b}:${x}`, r10 += 2;
          break;
        }
        case "@": {
          let y = f10.getHours() % 12;
          y === 0 && (y = 12);
          let w = String(y).padStart(2, "0"), b = String(f10.getMinutes()).padStart(2, "0"), x = f10.getHours() < 12 ? "AM" : "PM";
          n10 += `${w}:${b} ${x}`, r10 += 2;
          break;
        }
        case "A": {
          let y = String(f10.getHours()).padStart(2, "0"), w = String(f10.getMinutes()).padStart(2, "0");
          n10 += `${y}:${w}`, r10 += 2;
          break;
        }
        case "D":
          if (r10 + 2 < t10.length && t10[r10 + 2] === "{") {
            let y = t10.indexOf("}", r10 + 3);
            if (y !== -1) {
              let w = t10.slice(r10 + 3, y);
              n10 += ux(w, f10), r10 = y + 1;
            } else
              n10 += "\\D", r10 += 2;
          } else
            n10 += "\\D", r10 += 2;
          break;
        case "s":
          n10 += "bash", r10 += 2;
          break;
        case "v":
          n10 += "5.0", r10 += 2;
          break;
        case "V":
          n10 += "5.0.0", r10 += 2;
          break;
        case "j":
          n10 += "0", r10 += 2;
          break;
        case "l":
          n10 += "tty", r10 += 2;
          break;
        case "#":
          n10 += m, r10 += 2;
          break;
        case "!":
          n10 += m, r10 += 2;
          break;
        case "x":
          n10 += "\\x", r10 += 2;
          break;
        default:
          n10 += `\\${g}`, r10 += 2;
      }
    } else
      n10 += d, r10++;
  }
  return n10;
}
var tc = I(() => {
  "use strict";
});
function Ln(e11) {
  if (e11 === "")
    return "''";
  if (/[\n\r\t\x00-\x1f\x7f']/.test(e11)) {
    let n10 = "$'";
    for (let r10 of e11)
      switch (r10) {
        case "'":
          n10 += "\\'";
          break;
        case "\\":
          n10 += "\\\\";
          break;
        case `
`:
          n10 += "\\n";
          break;
        case "\r":
          n10 += "\\r";
          break;
        case "	":
          n10 += "\\t";
          break;
        default: {
          let s10 = r10.charCodeAt(0);
          s10 < 32 || s10 === 127 ? n10 += `\\${s10.toString(8).padStart(3, "0")}` : n10 += r10;
        }
      }
    return `${n10}'`;
  }
  return `'${e11}'`;
}
var nc = I(() => {
  "use strict";
});
function Dt(e11, t10) {
  e11.state.readonlyVars = e11.state.readonlyVars || /* @__PURE__ */ new Set(), e11.state.readonlyVars.add(t10);
}
function yn(e11, t10) {
  return e11.state.readonlyVars?.has(t10) ?? false;
}
function st(e11, t10, n10 = "bash") {
  if (yn(e11, t10)) {
    let r10 = `${n10}: ${t10}: readonly variable
`;
    throw new pe(1, "", r10);
  }
  return null;
}
function nn(e11, t10) {
  let n10 = e11.state.exportedVars?.has(t10) ?? false;
  if (e11.state.exportedVars = e11.state.exportedVars || /* @__PURE__ */ new Set(), e11.state.exportedVars.add(t10), e11.state.localScopes.length > 0 && e11.state.localScopes[e11.state.localScopes.length - 1].has(t10) && !n10) {
    for (e11.state.localExportedVars || (e11.state.localExportedVars = []); e11.state.localExportedVars.length < e11.state.localScopes.length; )
      e11.state.localExportedVars.push(/* @__PURE__ */ new Set());
    e11.state.localExportedVars[e11.state.localExportedVars.length - 1].add(t10);
  }
}
function Ki(e11, t10) {
  e11.state.exportedVars?.delete(t10);
}
var Fn = I(() => {
  "use strict";
  ye();
});
function Mn(e11, t10) {
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t10))
    return "";
  let n10 = "", r10 = e11.state.env.has(`${t10}__length`) || Array.from(e11.state.env.keys()).some((i10) => i10.startsWith(`${t10}_`) && /^[0-9]+$/.test(i10.slice(t10.length + 1))), s10 = e11.state.associativeArrays?.has(t10) ?? false;
  return r10 && !s10 && (n10 += "a"), s10 && (n10 += "A"), e11.state.integerVars?.has(t10) && (n10 += "i"), Te(e11, t10) && (n10 += "n"), yn(e11, t10) && (n10 += "r"), e11.state.exportedVars?.has(t10) && (n10 += "x"), n10;
}
var Xi = I(() => {
  "use strict";
  tn();
  Fn();
});
async function Km(e11, t10, n10, r10) {
  return e11.coverage?.hit("bash:expansion:default_value"), (n10.isUnset || t10.checkEmpty && n10.isEmpty) && t10.word ? r10(e11, t10.word.parts, n10.inDoubleQuotes) : n10.effectiveValue;
}
async function Xm(e11, t10, n10, r10, s10) {
  if (e11.coverage?.hit("bash:expansion:assign_default"), (r10.isUnset || n10.checkEmpty && r10.isEmpty) && n10.word) {
    let o10 = await s10(e11, n10.word.parts, r10.inDoubleQuotes), a = t10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    if (a) {
      let [, l, c] = a, u;
      if (/^\d+$/.test(c))
        u = Number.parseInt(c, 10);
      else {
        try {
          let p = new ce(), h = Ae(p, c);
          u = await ne(e11, h.expression);
        } catch {
          let p = e11.state.env.get(c);
          u = p ? Number.parseInt(p, 10) : 0;
        }
        Number.isNaN(u) && (u = 0);
      }
      e11.state.env.set(`${l}_${u}`, o10);
      let f10 = Number.parseInt(e11.state.env.get(`${l}__length`) || "0", 10);
      u >= f10 && e11.state.env.set(`${l}__length`, String(u + 1));
    } else
      e11.state.env.set(t10, o10);
    return o10;
  }
  return r10.effectiveValue;
}
async function Ym(e11, t10, n10, r10, s10) {
  if (e11.coverage?.hit("bash:expansion:error_if_unset"), r10.isUnset || n10.checkEmpty && r10.isEmpty) {
    let o10 = n10.word ? await s10(e11, n10.word.parts, r10.inDoubleQuotes) : `${t10}: parameter null or not set`;
    throw new pe(1, "", `bash: ${o10}
`);
  }
  return r10.effectiveValue;
}
async function Jm(e11, t10, n10, r10) {
  return e11.coverage?.hit("bash:expansion:use_alternative"), !(n10.isUnset || t10.checkEmpty && n10.isEmpty) && t10.word ? r10(e11, t10.word.parts, n10.inDoubleQuotes) : "";
}
async function e2(e11, t10, n10, r10, s10) {
  e11.coverage?.hit("bash:expansion:pattern_removal");
  let i10 = "", o10 = e11.state.shoptOptions.extglob;
  if (n10.pattern)
    for (let l of n10.pattern.parts)
      if (l.type === "Glob")
        i10 += me(l.pattern, n10.greedy, o10);
      else if (l.type === "Literal")
        i10 += me(l.value, n10.greedy, o10);
      else if (l.type === "SingleQuoted" || l.type === "Escaped")
        i10 += xe(l.value);
      else if (l.type === "DoubleQuoted") {
        let c = await r10(e11, l.parts);
        i10 += xe(c);
      } else if (l.type === "ParameterExpansion") {
        let c = await s10(e11, l);
        i10 += me(c, n10.greedy, o10);
      } else {
        let c = await s10(e11, l);
        i10 += xe(c);
      }
  if (n10.side === "prefix")
    return V(`^${i10}`, "s").replace(t10, "");
  let a = V(`${i10}$`, "s");
  if (n10.greedy)
    return a.replace(t10, "");
  for (let l = t10.length; l >= 0; l--) {
    let c = t10.slice(l);
    if (a.test(c))
      return t10.slice(0, l);
  }
  return t10;
}
async function t2(e11, t10, n10, r10, s10) {
  e11.coverage?.hit("bash:expansion:pattern_replacement");
  let i10 = "", o10 = e11.state.shoptOptions.extglob;
  if (n10.pattern)
    for (let c of n10.pattern.parts)
      if (c.type === "Glob")
        i10 += me(c.pattern, true, o10);
      else if (c.type === "Literal")
        i10 += me(c.value, true, o10);
      else if (c.type === "SingleQuoted" || c.type === "Escaped")
        i10 += xe(c.value);
      else if (c.type === "DoubleQuoted") {
        let u = await r10(e11, c.parts);
        i10 += xe(u);
      } else if (c.type === "ParameterExpansion") {
        let u = await s10(e11, c);
        i10 += me(u, true, o10);
      } else {
        let u = await s10(e11, c);
        i10 += xe(u);
      }
  let a = n10.replacement ? await r10(e11, n10.replacement.parts) : "";
  if (n10.anchor === "start" ? i10 = `^${i10}` : n10.anchor === "end" && (i10 = `${i10}$`), i10 === "")
    return t10;
  let l = n10.all ? "gs" : "s";
  try {
    let c = V(i10, l);
    if (n10.all) {
      let u = "", f10 = 0, p = c.exec(t10);
      for (; p !== null && !(p[0].length === 0 && p.index === t10.length); )
        u += t10.slice(f10, p.index) + a, f10 = p.index + p[0].length, p[0].length === 0 && f10++, p = c.exec(t10);
      return u += t10.slice(f10), u;
    }
    return c.replace(t10, a);
  } catch {
    return t10;
  }
}
function n2(e11, t10, n10) {
  e11.coverage?.hit("bash:expansion:length");
  let r10 = t10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
  if (r10) {
    let s10 = r10[1], i10 = ae(e11, s10);
    return i10.length > 0 ? String(i10.length) : e11.state.env.get(s10) !== void 0 ? "1" : "0";
  }
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t10) && Cn(e11, t10)) {
    if (t10 === "FUNCNAME") {
      let i10 = e11.state.funcNameStack?.[0] || "";
      return String([...i10].length);
    }
    if (t10 === "BASH_LINENO") {
      let i10 = e11.state.callLineStack?.[0];
      return String(i10 !== void 0 ? [...String(i10)].length : 0);
    }
    let s10 = e11.state.env.get(`${t10}_0`) || "";
    return String([...s10].length);
  }
  return String([...n10].length);
}
async function r2(e11, t10, n10, r10) {
  e11.coverage?.hit("bash:expansion:substring");
  let s10 = await ne(e11, r10.offset.expression), i10 = r10.length ? await ne(e11, r10.length.expression) : void 0;
  if (t10 === "@" || t10 === "*") {
    let c = Number.parseInt(e11.state.env.get("#") || "0", 10), u = [];
    for (let m = 1; m <= c; m++)
      u.push(e11.state.env.get(String(m)) || "");
    let f10 = e11.state.env.get("0") || "bash", p, h;
    if (s10 <= 0)
      if (p = [f10, ...u], s10 < 0) {
        if (h = p.length + s10, h < 0)
          return "";
      } else
        h = 0;
    else
      p = u, h = s10 - 1;
    if (h < 0 || h >= p.length)
      return "";
    if (i10 !== void 0) {
      let m = i10 < 0 ? p.length + i10 : h + i10;
      return p.slice(h, Math.max(h, m)).join(" ");
    }
    return p.slice(h).join(" ");
  }
  let o10 = t10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
  if (o10) {
    let c = o10[1];
    if (e11.state.associativeArrays?.has(c))
      throw new pe(1, "", `bash: \${${c}[@]: 0: 3}: bad substitution
`);
    let u = ae(e11, c), f10 = 0;
    if (s10 < 0) {
      if (u.length > 0) {
        let p = u[u.length - 1][0], m = (typeof p == "number" ? p : 0) + 1 + s10;
        if (m < 0 || (f10 = u.findIndex(([d]) => typeof d == "number" && d >= m), f10 < 0))
          return "";
      }
    } else if (f10 = u.findIndex(([p]) => typeof p == "number" && p >= s10), f10 < 0)
      return "";
    if (i10 !== void 0) {
      if (i10 < 0)
        throw new $e(`${o10[1]}[@]: substring expression < 0`);
      return u.slice(f10, f10 + i10).map(([, p]) => p).join(" ");
    }
    return u.slice(f10).map(([, p]) => p).join(" ");
  }
  let a = [...n10], l = s10;
  if (l < 0 && (l = Math.max(0, a.length + l)), i10 !== void 0) {
    if (i10 < 0) {
      let c = a.length + i10;
      return a.slice(l, Math.max(l, c)).join("");
    }
    return a.slice(l, l + i10).join("");
  }
  return a.slice(l).join("");
}
async function s2(e11, t10, n10, r10, s10) {
  if (e11.coverage?.hit("bash:expansion:case_modification"), n10.pattern) {
    let i10 = e11.state.shoptOptions.extglob, o10 = "";
    for (let f10 of n10.pattern.parts)
      if (f10.type === "Glob")
        o10 += me(f10.pattern, true, i10);
      else if (f10.type === "Literal")
        o10 += me(f10.value, true, i10);
      else if (f10.type === "SingleQuoted" || f10.type === "Escaped")
        o10 += xe(f10.value);
      else if (f10.type === "DoubleQuoted") {
        let p = await r10(e11, f10.parts);
        o10 += xe(p);
      } else if (f10.type === "ParameterExpansion") {
        let p = await s10(e11, f10);
        o10 += me(p, true, i10);
      }
    let a = V(`^(?:${o10})$`), l = n10.direction === "upper" ? (f10) => f10.toUpperCase() : (f10) => f10.toLowerCase(), c = "", u = false;
    for (let f10 of t10)
      !n10.all && u ? c += f10 : a.test(f10) ? (c += l(f10), u = true) : c += f10;
    return c;
  }
  return n10.direction === "upper" ? n10.all ? t10.toUpperCase() : t10.charAt(0).toUpperCase() + t10.slice(1) : n10.all ? t10.toLowerCase() : t10.charAt(0).toLowerCase() + t10.slice(1);
}
function i2(e11, t10, n10, r10, s10) {
  e11.coverage?.hit("bash:expansion:transform");
  let i10 = t10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
  if (i10 && s10.operator === "Q")
    return ae(e11, i10[1]).map(([, c]) => Ln(c)).join(" ");
  if (i10 && s10.operator === "a")
    return Mn(e11, i10[1]);
  let o10 = t10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[.+\]$/);
  if (o10 && s10.operator === "a")
    return Mn(e11, o10[1]);
  switch (s10.operator) {
    case "Q":
      return r10 ? "" : Ln(n10);
    case "P":
      return Es(e11, n10);
    case "a":
      return Mn(e11, t10);
    case "A":
      return r10 ? "" : `${t10}=${Ln(n10)}`;
    case "E":
      return n10.replace(/\\([\\abefnrtv'"?])/g, (a, l) => {
        switch (l) {
          case "\\":
            return "\\";
          case "a":
            return "\x07";
          case "b":
            return "\b";
          case "e":
            return "\x1B";
          case "f":
            return "\f";
          case "n":
            return `
`;
          case "r":
            return "\r";
          case "t":
            return "	";
          case "v":
            return "\v";
          case "'":
            return "'";
          case '"':
            return '"';
          case "?":
            return "?";
          default:
            return l;
        }
      });
    case "K":
    case "k":
      return r10 ? "" : Ln(n10);
    case "u":
      return n10.charAt(0).toUpperCase() + n10.slice(1);
    case "U":
      return n10.toUpperCase();
    case "L":
      return n10.toLowerCase();
    default:
      return n10;
  }
}
async function o2(e11, t10, n10, r10, s10, i10, o10 = false) {
  if (e11.coverage?.hit("bash:expansion:indirection"), Te(e11, t10))
    return rr(e11, t10) || "";
  let a = /^[a-zA-Z_][a-zA-Z0-9_]*\[([@*])\]$/.test(t10);
  if (r10) {
    if (s10.innerOp?.type === "UseAlternative")
      return "";
    throw new wt(`\${!${t10}}`);
  }
  let l = n10;
  if (a && (l === "" || l.includes(" ")))
    throw new wt(`\${!${t10}}`);
  let c = l.match(/^[a-zA-Z_][a-zA-Z0-9_]*\[(.+)\]$/);
  if (c && c[1].includes("~"))
    throw new wt(`\${!${t10}}`);
  if (s10.innerOp) {
    let u = { type: "ParameterExpansion", parameter: l, operation: s10.innerOp };
    return i10(e11, u, o10);
  }
  return await Se(e11, l);
}
function a2(e11, t10) {
  e11.coverage?.hit("bash:expansion:array_keys");
  let r10 = ae(e11, t10.array).map(([s10]) => String(s10));
  return t10.star ? r10.join(fe(e11.state.env)) : r10.join(" ");
}
function l2(e11, t10) {
  e11.coverage?.hit("bash:expansion:var_name_prefix");
  let n10 = Mr(e11, t10.prefix);
  return t10.star ? n10.join(fe(e11.state.env)) : n10.join(" ");
}
function c2(e11, t10, n10, r10) {
  let s10 = Number.parseInt(e11.state.env.get("#") || "0", 10), i10 = t10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (t10 === "*")
    return { isEmpty: s10 === 0, effectiveValue: n10 };
  if (t10 === "@")
    return { isEmpty: s10 === 0 || s10 === 1 && e11.state.env.get("1") === "", effectiveValue: n10 };
  if (i10) {
    let [, o10, a] = i10, l = ae(e11, o10);
    if (l.length === 0)
      return { isEmpty: true, effectiveValue: "" };
    if (a === "*") {
      let c = fe(e11.state.env), u = l.map(([, f10]) => f10).join(c);
      return { isEmpty: r10 ? u === "" : false, effectiveValue: u };
    }
    return { isEmpty: l.length === 1 && l.every(([, c]) => c === ""), effectiveValue: l.map(([, c]) => c).join(" ") };
  }
  return { isEmpty: n10 === "", effectiveValue: n10 };
}
var u2 = I(() => {
  "use strict";
  dt();
  Ke();
  Fe();
  St();
  ye();
  zt();
  tn();
  Lr();
  Fr();
  sr();
  tc();
  nc();
  Tt();
  Xi();
});
function f2(e11) {
  let t10 = 0;
  for (; t10 < e11.length; ) {
    let n10 = e11[t10];
    if (n10 === "\\" && t10 + 1 < e11.length) {
      t10 += 2;
      continue;
    }
    if (n10 === "'") {
      let r10 = e11.indexOf("'", t10 + 1);
      if (r10 !== -1) {
        t10 = r10 + 1;
        continue;
      }
    }
    if (n10 === "$" && t10 + 1 < e11.length && e11[t10 + 1] === "(" || n10 === "`")
      return true;
    t10++;
  }
  return false;
}
function p2(e11, t10) {
  let n10 = 1, r10 = t10, s10 = false, i10 = false;
  for (; r10 < e11.length && n10 > 0; ) {
    let o10 = e11[r10];
    if (o10 === "\\" && !s10 && r10 + 1 < e11.length) {
      r10 += 2;
      continue;
    }
    if (o10 === "'" && !i10) {
      s10 = !s10, r10++;
      continue;
    }
    if (o10 === '"' && !s10) {
      i10 = !i10, r10++;
      continue;
    }
    if (!s10 && !i10) {
      if (o10 === "(")
        n10++;
      else if (o10 === ")" && (n10--, n10 === 0))
        return r10;
    }
    r10++;
  }
  return -1;
}
async function Yi(e11, t10) {
  let n10 = new ce(), r10;
  try {
    r10 = n10.parse(t10);
  } catch {
    return "";
  }
  let s10 = e11.state.bashPid;
  e11.state.bashPid = e11.state.nextVirtualPid++;
  let i10 = new Map(e11.state.env), o10 = e11.state.cwd, a = e11.state.suppressVerbose;
  e11.state.suppressVerbose = true;
  try {
    let l = await e11.executeScript(r10), c = l.exitCode;
    return e11.state.env = i10, e11.state.cwd = o10, e11.state.suppressVerbose = a, e11.state.lastExitCode = c, e11.state.env.set("?", String(c)), l.stderr && (e11.state.expansionStderr = (e11.state.expansionStderr || "") + l.stderr), e11.state.bashPid = s10, l.stdout.replace(/\n+$/, "");
  } catch (l) {
    if (e11.state.env = i10, e11.state.cwd = o10, e11.state.bashPid = s10, e11.state.suppressVerbose = a, l instanceof te)
      throw l;
    return l instanceof pe ? (e11.state.lastExitCode = l.exitCode, e11.state.env.set("?", String(l.exitCode)), l.stdout?.replace(/\n+$/, "") ?? "") : "";
  }
}
function rc(e11, t10) {
  let n10 = "", r10 = 0;
  for (; r10 < t10.length; ) {
    let s10 = t10[r10];
    if (s10 === "'") {
      let i10 = t10.indexOf("'", r10 + 1);
      if (i10 !== -1) {
        let o10 = t10.slice(r10 + 1, i10);
        n10 += Pt(o10), r10 = i10 + 1;
        continue;
      }
    }
    if (s10 === '"') {
      let i10 = -1, o10 = r10 + 1;
      for (; o10 < t10.length; ) {
        if (t10[o10] === "\\") {
          o10 += 2;
          continue;
        }
        if (t10[o10] === '"') {
          i10 = o10;
          break;
        }
        o10++;
      }
      if (i10 !== -1) {
        let a = t10.slice(r10 + 1, i10), l = fx(e11, a);
        n10 += Pt(l), r10 = i10 + 1;
        continue;
      }
    }
    if (s10 === "$" && r10 + 1 < t10.length) {
      let i10 = t10[r10 + 1];
      if (i10 === "{") {
        let o10 = t10.indexOf("}", r10 + 2);
        if (o10 !== -1) {
          let a = t10.slice(r10 + 2, o10);
          n10 += e11.state.env.get(a) ?? "", r10 = o10 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(i10)) {
        let o10 = r10 + 1;
        for (; o10 < t10.length && /[a-zA-Z0-9_]/.test(t10[o10]); )
          o10++;
        let a = t10.slice(r10 + 1, o10);
        n10 += e11.state.env.get(a) ?? "", r10 = o10;
        continue;
      }
    }
    if (s10 === "\\" && r10 + 1 < t10.length) {
      n10 += s10 + t10[r10 + 1], r10 += 2;
      continue;
    }
    n10 += s10, r10++;
  }
  return n10;
}
function fx(e11, t10) {
  let n10 = "", r10 = 0;
  for (; r10 < t10.length; ) {
    let s10 = t10[r10];
    if (s10 === "\\" && r10 + 1 < t10.length) {
      let i10 = t10[r10 + 1];
      if (i10 === "$" || i10 === "`" || i10 === "\\" || i10 === '"') {
        n10 += i10, r10 += 2;
        continue;
      }
      n10 += s10, r10++;
      continue;
    }
    if (s10 === "$" && r10 + 1 < t10.length) {
      let i10 = t10[r10 + 1];
      if (i10 === "{") {
        let o10 = t10.indexOf("}", r10 + 2);
        if (o10 !== -1) {
          let a = t10.slice(r10 + 2, o10);
          n10 += e11.state.env.get(a) ?? "", r10 = o10 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(i10)) {
        let o10 = r10 + 1;
        for (; o10 < t10.length && /[a-zA-Z0-9_]/.test(t10[o10]); )
          o10++;
        let a = t10.slice(r10 + 1, o10);
        n10 += e11.state.env.get(a) ?? "", r10 = o10;
        continue;
      }
    }
    n10 += s10, r10++;
  }
  return n10;
}
async function h2(e11, t10) {
  let n10 = "", r10 = 0;
  for (; r10 < t10.length; ) {
    let s10 = t10[r10];
    if (s10 === "'") {
      let i10 = t10.indexOf("'", r10 + 1);
      if (i10 !== -1) {
        let o10 = t10.slice(r10 + 1, i10);
        n10 += Pt(o10), r10 = i10 + 1;
        continue;
      }
    }
    if (s10 === '"') {
      let i10 = -1, o10 = r10 + 1;
      for (; o10 < t10.length; ) {
        if (t10[o10] === "\\") {
          o10 += 2;
          continue;
        }
        if (t10[o10] === '"') {
          i10 = o10;
          break;
        }
        o10++;
      }
      if (i10 !== -1) {
        let a = t10.slice(r10 + 1, i10), l = await px(e11, a);
        n10 += Pt(l), r10 = i10 + 1;
        continue;
      }
    }
    if (s10 === "$" && r10 + 1 < t10.length && t10[r10 + 1] === "(") {
      let i10 = p2(t10, r10 + 2);
      if (i10 !== -1) {
        let o10 = t10.slice(r10 + 2, i10), a = await Yi(e11, o10);
        n10 += a, r10 = i10 + 1;
        continue;
      }
    }
    if (s10 === "`") {
      let i10 = t10.indexOf("`", r10 + 1);
      if (i10 !== -1) {
        let o10 = t10.slice(r10 + 1, i10), a = await Yi(e11, o10);
        n10 += a, r10 = i10 + 1;
        continue;
      }
    }
    if (s10 === "$" && r10 + 1 < t10.length) {
      let i10 = t10[r10 + 1];
      if (i10 === "{") {
        let o10 = t10.indexOf("}", r10 + 2);
        if (o10 !== -1) {
          let a = t10.slice(r10 + 2, o10);
          n10 += e11.state.env.get(a) ?? "", r10 = o10 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(i10)) {
        let o10 = r10 + 1;
        for (; o10 < t10.length && /[a-zA-Z0-9_]/.test(t10[o10]); )
          o10++;
        let a = t10.slice(r10 + 1, o10);
        n10 += e11.state.env.get(a) ?? "", r10 = o10;
        continue;
      }
    }
    if (s10 === "\\" && r10 + 1 < t10.length) {
      n10 += s10 + t10[r10 + 1], r10 += 2;
      continue;
    }
    n10 += s10, r10++;
  }
  return n10;
}
async function px(e11, t10) {
  let n10 = "", r10 = 0;
  for (; r10 < t10.length; ) {
    let s10 = t10[r10];
    if (s10 === "\\" && r10 + 1 < t10.length) {
      let i10 = t10[r10 + 1];
      if (i10 === "$" || i10 === "`" || i10 === "\\" || i10 === '"') {
        n10 += i10, r10 += 2;
        continue;
      }
      n10 += s10, r10++;
      continue;
    }
    if (s10 === "$" && r10 + 1 < t10.length && t10[r10 + 1] === "(") {
      let i10 = p2(t10, r10 + 2);
      if (i10 !== -1) {
        let o10 = t10.slice(r10 + 2, i10), a = await Yi(e11, o10);
        n10 += a, r10 = i10 + 1;
        continue;
      }
    }
    if (s10 === "`") {
      let i10 = t10.indexOf("`", r10 + 1);
      if (i10 !== -1) {
        let o10 = t10.slice(r10 + 1, i10), a = await Yi(e11, o10);
        n10 += a, r10 = i10 + 1;
        continue;
      }
    }
    if (s10 === "$" && r10 + 1 < t10.length) {
      let i10 = t10[r10 + 1];
      if (i10 === "{") {
        let o10 = t10.indexOf("}", r10 + 2);
        if (o10 !== -1) {
          let a = t10.slice(r10 + 2, o10);
          n10 += e11.state.env.get(a) ?? "", r10 = o10 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(i10)) {
        let o10 = r10 + 1;
        for (; o10 < t10.length && /[a-zA-Z0-9_]/.test(t10[o10]); )
          o10++;
        let a = t10.slice(r10 + 1, o10);
        n10 += e11.state.env.get(a) ?? "", r10 = o10;
        continue;
      }
    }
    n10 += s10, r10++;
  }
  return n10;
}
var d2 = I(() => {
  "use strict";
  Ke();
  ye();
  _r();
});
function m2(e11, t10) {
  if (!t10.startsWith("~"))
    return t10;
  e11.coverage?.hit("bash:expansion:tilde");
  let n10 = e11.state.env.get("HOME") !== void 0 ? e11.state.env.get("HOME") : "/home/user";
  if (t10 === "~" || t10.startsWith("~/"))
    return n10 + t10.slice(1);
  let r10 = 1;
  for (; r10 < t10.length && /[a-zA-Z0-9_-]/.test(t10[r10]); )
    r10++;
  let s10 = t10.slice(1, r10), i10 = t10.slice(r10);
  return i10 !== "" && !i10.startsWith("/") ? t10 : s10 === "root" ? `/root${i10}` : t10;
}
var g2 = I(() => {
  "use strict";
});
async function hx(e11, t10, n10, r10) {
  let s10 = "";
  for (let i10 of t10.parts)
    if (i10.type === "Glob")
      s10 += me(i10.pattern, true, e11.state.shoptOptions.extglob);
    else if (i10.type === "Literal")
      s10 += me(i10.value, true, e11.state.shoptOptions.extglob);
    else if (i10.type === "SingleQuoted" || i10.type === "Escaped")
      s10 += xe(i10.value);
    else if (i10.type === "DoubleQuoted") {
      let o10 = await n10(e11, i10.parts);
      s10 += xe(o10);
    } else if (i10.type === "ParameterExpansion") {
      let o10 = await r10(e11, i10);
      s10 += me(o10, true, e11.state.shoptOptions.extglob);
    } else {
      let o10 = await r10(e11, i10);
      s10 += xe(o10);
    }
  return s10;
}
async function y2(e11, t10, n10, r10) {
  if (t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let s10 = t10[0];
  if (s10.parts.length !== 1 || s10.parts[0].type !== "ParameterExpansion" || s10.parts[0].operation?.type !== "PatternReplacement")
    return null;
  let i10 = s10.parts[0], o10 = i10.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!o10)
    return null;
  let a = o10[1], l = o10[2] === "*", c = i10.operation, u = ae(e11, a), f10 = u.map(([, g]) => g);
  if (u.length === 0) {
    let g = e11.state.env.get(a);
    g !== void 0 && f10.push(g);
  }
  if (f10.length === 0)
    return { values: [], quoted: true };
  let p = "";
  c.pattern && (p = await hx(e11, c.pattern, n10, r10));
  let h = c.replacement ? await n10(e11, c.replacement.parts) : "", m = p;
  c.anchor === "start" ? m = `^${p}` : c.anchor === "end" && (m = `${p}$`);
  let d = [];
  try {
    let g = V(m, c.all ? "g" : "");
    for (let y of f10)
      d.push(g.replace(y, h));
  } catch {
    d.push(...f10);
  }
  if (l) {
    let g = fe(e11.state.env);
    return { values: [d.join(g)], quoted: true };
  }
  return { values: d, quoted: true };
}
async function w2(e11, t10, n10, r10) {
  if (t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let s10 = t10[0];
  if (s10.parts.length !== 1 || s10.parts[0].type !== "ParameterExpansion" || s10.parts[0].operation?.type !== "PatternRemoval")
    return null;
  let i10 = s10.parts[0], o10 = i10.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!o10)
    return null;
  let a = o10[1], l = o10[2] === "*", c = i10.operation, u = ae(e11, a), f10 = u.map(([, d]) => d);
  if (u.length === 0) {
    let d = e11.state.env.get(a);
    d !== void 0 && f10.push(d);
  }
  if (f10.length === 0)
    return { values: [], quoted: true };
  let p = "", h = e11.state.shoptOptions.extglob;
  if (c.pattern)
    for (let d of c.pattern.parts)
      if (d.type === "Glob")
        p += me(d.pattern, c.greedy, h);
      else if (d.type === "Literal")
        p += me(d.value, c.greedy, h);
      else if (d.type === "SingleQuoted" || d.type === "Escaped")
        p += xe(d.value);
      else if (d.type === "DoubleQuoted") {
        let g = await n10(e11, d.parts);
        p += xe(g);
      } else if (d.type === "ParameterExpansion") {
        let g = await r10(e11, d);
        p += me(g, c.greedy, h);
      } else {
        let g = await r10(e11, d);
        p += xe(g);
      }
  let m = [];
  for (let d of f10)
    m.push(Nn(d, p, c.side, c.greedy));
  if (l) {
    let d = fe(e11.state.env);
    return { values: [m.join(d)], quoted: true };
  }
  return { values: m, quoted: true };
}
var b2 = I(() => {
  "use strict";
  Fe();
  zt();
  Lr();
  Fr();
  sr();
  Tt();
});
async function x2(e11, t10) {
  if (t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let n10 = t10[0];
  if (n10.parts.length !== 1 || n10.parts[0].type !== "ParameterExpansion" || n10.parts[0].operation?.type !== "DefaultValue" && n10.parts[0].operation?.type !== "UseAlternative" && n10.parts[0].operation?.type !== "AssignDefault")
    return null;
  let r10 = n10.parts[0], s10 = r10.operation, i10 = r10.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/), o10, a = false;
  if (i10) {
    let l = i10[1];
    a = i10[2] === "*";
    let c = ae(e11, l), u = c.length > 0 || e11.state.env.has(l), f10 = c.length === 0 || c.length === 1 && c.every(([, h]) => h === ""), p = s10.checkEmpty ?? false;
    if (s10.type === "UseAlternative" ? o10 = u && !(p && f10) : o10 = !u || p && f10, !o10) {
      if (c.length > 0) {
        let m = c.map(([, d]) => d);
        if (a) {
          let d = fe(e11.state.env);
          return { values: [m.join(d)], quoted: true };
        }
        return { values: m, quoted: true };
      }
      let h = e11.state.env.get(l);
      return h !== void 0 ? { values: [h], quoted: true } : { values: [], quoted: true };
    }
  } else {
    let l = r10.parameter, c = await mn(e11, l), u = await Se(e11, l), f10 = u === "", p = s10.checkEmpty ?? false;
    if (s10.type === "UseAlternative" ? o10 = c && !(p && f10) : o10 = !c || p && f10, !o10)
      return { values: [u], quoted: true };
  }
  if (o10 && s10.word) {
    let l = s10.word.parts, c = null, u = false;
    for (let f10 of l)
      if (f10.type === "ParameterExpansion" && !f10.operation) {
        let p = f10.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
        if (p) {
          c = p[1], u = p[2] === "*";
          break;
        }
      }
    if (c) {
      let f10 = ae(e11, c);
      if (f10.length > 0) {
        let h = f10.map(([, m]) => m);
        if (u || a) {
          let m = fe(e11.state.env);
          return { values: [h.join(m)], quoted: true };
        }
        return { values: h, quoted: true };
      }
      let p = e11.state.env.get(c);
      return p !== void 0 ? { values: [p], quoted: true } : { values: [], quoted: true };
    }
  }
  return null;
}
async function E2(e11, t10, n10, r10, s10) {
  if (!n10 || t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let i10 = t10[0], o10 = -1, a = "", l = false, c = null;
  for (let d = 0; d < i10.parts.length; d++) {
    let g = i10.parts[d];
    if (g.type === "ParameterExpansion" && (g.operation?.type === "PatternRemoval" || g.operation?.type === "PatternReplacement")) {
      let y = g.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (y) {
        o10 = d, a = y[1], l = y[2] === "*", c = g.operation;
        break;
      }
    }
  }
  if (o10 === -1 || o10 === 0 && o10 === i10.parts.length - 1)
    return null;
  let u = "";
  for (let d = 0; d < o10; d++)
    u += await r10(e11, i10.parts[d]);
  let f10 = "";
  for (let d = o10 + 1; d < i10.parts.length; d++)
    f10 += await r10(e11, i10.parts[d]);
  let p = ae(e11, a), h = p.map(([, d]) => d);
  if (p.length === 0) {
    let d = e11.state.env.get(a);
    if (d !== void 0)
      h = [d];
    else {
      if (l)
        return { values: [u + f10], quoted: true };
      let g = u + f10;
      return { values: g ? [g] : [], quoted: true };
    }
  }
  if (c?.type === "PatternRemoval") {
    let d = c, g = "", y = e11.state.shoptOptions.extglob;
    if (d.pattern)
      for (let w of d.pattern.parts)
        if (w.type === "Glob")
          g += me(w.pattern, d.greedy, y);
        else if (w.type === "Literal")
          g += me(w.value, d.greedy, y);
        else if (w.type === "SingleQuoted" || w.type === "Escaped")
          g += xe(w.value);
        else if (w.type === "DoubleQuoted") {
          let b = await s10(e11, w.parts);
          g += xe(b);
        } else if (w.type === "ParameterExpansion") {
          let b = await r10(e11, w);
          g += me(b, d.greedy, y);
        } else {
          let b = await r10(e11, w);
          g += xe(b);
        }
    h = h.map((w) => Nn(w, g, d.side, d.greedy));
  } else if (c?.type === "PatternReplacement") {
    let d = c, g = "";
    if (d.pattern)
      for (let b of d.pattern.parts)
        if (b.type === "Glob")
          g += me(b.pattern, true, e11.state.shoptOptions.extglob);
        else if (b.type === "Literal")
          g += me(b.value, true, e11.state.shoptOptions.extglob);
        else if (b.type === "SingleQuoted" || b.type === "Escaped")
          g += xe(b.value);
        else if (b.type === "DoubleQuoted") {
          let x = await s10(e11, b.parts);
          g += xe(x);
        } else if (b.type === "ParameterExpansion") {
          let x = await r10(e11, b);
          g += me(x, true, e11.state.shoptOptions.extglob);
        } else {
          let x = await r10(e11, b);
          g += xe(x);
        }
    let y = d.replacement ? await s10(e11, d.replacement.parts) : "", w = g;
    d.anchor === "start" ? w = `^${g}` : d.anchor === "end" && (w = `${g}$`);
    try {
      let b = V(w, d.all ? "g" : "");
      h = h.map((x) => b.replace(x, y));
    } catch {
    }
  }
  if (l) {
    let d = fe(e11.state.env);
    return { values: [u + h.join(d) + f10], quoted: true };
  }
  return h.length === 1 ? { values: [u + h[0] + f10], quoted: true } : { values: [u + h[0], ...h.slice(1, -1), h[h.length - 1] + f10], quoted: true };
}
async function A2(e11, t10, n10, r10) {
  if (!n10 || t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let s10 = t10[0], i10 = -1, o10 = "", a = false;
  for (let h = 0; h < s10.parts.length; h++) {
    let m = s10.parts[h];
    if (m.type === "ParameterExpansion" && !m.operation) {
      let d = m.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (d) {
        i10 = h, o10 = d[1], a = d[2] === "*";
        break;
      }
    }
  }
  if (i10 === -1)
    return null;
  let l = "";
  for (let h = 0; h < i10; h++)
    l += await r10(e11, s10.parts[h]);
  let c = "";
  for (let h = i10 + 1; h < s10.parts.length; h++)
    c += await r10(e11, s10.parts[h]);
  let u = ae(e11, o10), f10 = u.map(([, h]) => h);
  if (u.length === 0) {
    let h = e11.state.env.get(o10);
    if (h !== void 0)
      return { values: [l + h + c], quoted: true };
    if (a)
      return { values: [l + c], quoted: true };
    let m = l + c;
    return { values: m ? [m] : [], quoted: true };
  }
  if (a) {
    let h = fe(e11.state.env);
    return { values: [l + f10.join(h) + c], quoted: true };
  }
  return f10.length === 1 ? { values: [l + f10[0] + c], quoted: true } : { values: [l + f10[0], ...f10.slice(1, -1), f10[f10.length - 1] + c], quoted: true };
}
var S2 = I(() => {
  "use strict";
  Fe();
  zt();
  Lr();
  Fr();
  sr();
  Tt();
});
async function C2(e11, t10, n10) {
  if (t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let r10 = t10[0];
  if (r10.parts.length !== 1 || r10.parts[0].type !== "ParameterExpansion" || r10.parts[0].operation?.type !== "Substring")
    return null;
  let s10 = r10.parts[0], i10 = s10.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!i10)
    return null;
  let o10 = i10[1], a = i10[2] === "*", l = s10.operation;
  if (e11.state.associativeArrays?.has(o10))
    throw new pe(1, "", `bash: \${${o10}[@]: 0: 3}: bad substitution
`);
  let c = l.offset ? await n10(e11, l.offset.expression) : 0, u = l.length ? await n10(e11, l.length.expression) : void 0, f10 = ae(e11, o10), p = 0;
  if (c < 0) {
    if (f10.length > 0) {
      let m = f10[f10.length - 1][0], g = (typeof m == "number" ? m : 0) + 1 + c;
      if (g < 0)
        return { values: [], quoted: true };
      p = f10.findIndex(([y]) => typeof y == "number" && y >= g), p < 0 && (p = f10.length);
    }
  } else
    p = f10.findIndex(([m]) => typeof m == "number" && m >= c), p < 0 && (p = f10.length);
  let h;
  if (u !== void 0) {
    if (u < 0)
      throw new $e(`${o10}[@]: substring expression < 0`);
    h = f10.slice(p, p + u).map(([, m]) => m);
  } else
    h = f10.slice(p).map(([, m]) => m);
  if (h.length === 0)
    return { values: [], quoted: true };
  if (a) {
    let m = fe(e11.state.env);
    return { values: [h.join(m)], quoted: true };
  }
  return { values: h, quoted: true };
}
function N2(e11, t10) {
  if (t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let n10 = t10[0];
  if (n10.parts.length !== 1 || n10.parts[0].type !== "ParameterExpansion" || n10.parts[0].operation?.type !== "Transform")
    return null;
  let r10 = n10.parts[0], s10 = r10.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!s10)
    return null;
  let i10 = s10[1], o10 = s10[2] === "*", a = r10.operation, l = ae(e11, i10);
  if (l.length === 0) {
    let f10 = e11.state.env.get(i10);
    if (f10 !== void 0) {
      let p;
      switch (a.operator) {
        case "a":
          p = "";
          break;
        case "P":
          p = Es(e11, f10);
          break;
        case "Q":
          p = Ln(f10);
          break;
        default:
          p = f10;
      }
      return { values: [p], quoted: true };
    }
    return o10 ? { values: [""], quoted: true } : { values: [], quoted: true };
  }
  let c = Mn(e11, i10), u;
  switch (a.operator) {
    case "a":
      u = l.map(() => c);
      break;
    case "P":
      u = l.map(([, f10]) => Es(e11, f10));
      break;
    case "Q":
      u = l.map(([, f10]) => Ln(f10));
      break;
    case "u":
      u = l.map(([, f10]) => f10.charAt(0).toUpperCase() + f10.slice(1));
      break;
    case "U":
      u = l.map(([, f10]) => f10.toUpperCase());
      break;
    case "L":
      u = l.map(([, f10]) => f10.toLowerCase());
      break;
    default:
      u = l.map(([, f10]) => f10);
  }
  if (o10) {
    let f10 = fe(e11.state.env);
    return { values: [u.join(f10)], quoted: true };
  }
  return { values: u, quoted: true };
}
var k2 = I(() => {
  "use strict";
  ye();
  zt();
  tc();
  nc();
  Tt();
  Xi();
});
function v2(e11, t10) {
  if (t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let n10 = t10[0];
  if (n10.parts.length !== 1 || n10.parts[0].type !== "ParameterExpansion")
    return null;
  let r10 = n10.parts[0];
  if (r10.operation)
    return null;
  let s10 = r10.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(@)\]$/);
  if (!s10)
    return null;
  let i10 = s10[1];
  if (Te(e11, i10)) {
    let l = rr(e11, i10);
    if (l?.endsWith("[@]") || l?.endsWith("[*]"))
      return { values: [], quoted: true };
  }
  let o10 = ae(e11, i10);
  if (o10.length > 0)
    return { values: o10.map(([, l]) => l), quoted: true };
  let a = e11.state.env.get(i10);
  return a !== void 0 ? { values: [a], quoted: true } : { values: [], quoted: true };
}
function I2(e11, t10) {
  if (t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let n10 = t10[0];
  if (n10.parts.length !== 1 || n10.parts[0].type !== "ParameterExpansion" || n10.parts[0].operation)
    return null;
  let s10 = n10.parts[0].parameter;
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s10) || !Te(e11, s10))
    return null;
  let i10 = rr(e11, s10);
  if (!i10)
    return null;
  let o10 = i10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(@)\]$/);
  if (!o10)
    return null;
  let a = o10[1], l = ae(e11, a);
  if (l.length > 0)
    return { values: l.map(([, u]) => u), quoted: true };
  let c = e11.state.env.get(a);
  return c !== void 0 ? { values: [c], quoted: true } : { values: [], quoted: true };
}
var O2 = I(() => {
  "use strict";
  tn();
  Tt();
});
async function R2(e11, t10, n10, r10, s10) {
  if (!n10 || t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let i10 = t10[0];
  if (i10.parts.length !== 1 || i10.parts[0].type !== "ParameterExpansion" || i10.parts[0].operation?.type !== "Indirection")
    return null;
  let o10 = i10.parts[0], a = o10.operation, l = await Se(e11, o10.parameter), c = l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!c) {
    if (!a.innerOp && (l === "@" || l === "*")) {
      let m = Number.parseInt(e11.state.env.get("#") || "0", 10), d = [];
      for (let g = 1; g <= m; g++)
        d.push(e11.state.env.get(String(g)) || "");
      return l === "*" ? { values: [d.join(fe(e11.state.env))], quoted: true } : { values: d, quoted: true };
    }
    return null;
  }
  let u = c[1], f10 = c[2] === "*", p = ae(e11, u);
  if (a.innerOp) {
    if (a.innerOp.type === "Substring")
      return dx(e11, p, u, f10, a.innerOp);
    if (a.innerOp.type === "DefaultValue" || a.innerOp.type === "UseAlternative" || a.innerOp.type === "AssignDefault" || a.innerOp.type === "ErrorIfUnset")
      return mx(e11, p, u, f10, a.innerOp, s10);
    if (a.innerOp.type === "Transform" && a.innerOp.operator === "a") {
      let d = Mn(e11, u), g = p.map(() => d);
      return f10 ? { values: [g.join(fe(e11.state.env))], quoted: true } : { values: g, quoted: true };
    }
    let m = [];
    for (let [, d] of p) {
      let g = { type: "ParameterExpansion", parameter: "_indirect_elem_", operation: a.innerOp }, y = e11.state.env.get("_indirect_elem_");
      e11.state.env.set("_indirect_elem_", d);
      try {
        let w = await r10(e11, g, true);
        m.push(w);
      } finally {
        y !== void 0 ? e11.state.env.set("_indirect_elem_", y) : e11.state.env.delete("_indirect_elem_");
      }
    }
    return f10 ? { values: [m.join(fe(e11.state.env))], quoted: true } : { values: m, quoted: true };
  }
  if (p.length > 0) {
    let m = p.map(([, d]) => d);
    return f10 ? { values: [m.join(fe(e11.state.env))], quoted: true } : { values: m, quoted: true };
  }
  let h = e11.state.env.get(u);
  return h !== void 0 ? { values: [h], quoted: true } : { values: [], quoted: true };
}
async function dx(e11, t10, n10, r10, s10) {
  let i10 = s10.offset ? await ne(e11, s10.offset.expression) : 0, o10 = s10.length ? await ne(e11, s10.length.expression) : void 0, a = 0;
  if (i10 < 0) {
    if (t10.length > 0) {
      let u = t10[t10.length - 1][0], p = (typeof u == "number" ? u : 0) + 1 + i10;
      if (p < 0)
        return { values: [], quoted: true };
      if (a = t10.findIndex(([h]) => typeof h == "number" && h >= p), a < 0)
        return { values: [], quoted: true };
    }
  } else if (a = t10.findIndex(([u]) => typeof u == "number" && u >= i10), a < 0)
    return { values: [], quoted: true };
  let l;
  if (o10 !== void 0) {
    if (o10 < 0)
      throw new $e(`${n10}[@]: substring expression < 0`);
    l = t10.slice(a, a + o10);
  } else
    l = t10.slice(a);
  let c = l.map(([, u]) => u);
  return r10 ? { values: [c.join(fe(e11.state.env))], quoted: true } : { values: c, quoted: true };
}
async function mx(e11, t10, n10, r10, s10, i10) {
  let o10 = s10.checkEmpty ?? false, a = t10.map(([, u]) => u), l = t10.length === 0, c = t10.length === 0;
  if (s10.type === "UseAlternative")
    return !c && !(o10 && l) && s10.word ? { values: [await i10(e11, s10.word.parts, true)], quoted: true } : { values: [], quoted: true };
  if (s10.type === "DefaultValue")
    return (c || o10 && l) && s10.word ? { values: [await i10(e11, s10.word.parts, true)], quoted: true } : r10 ? { values: [a.join(fe(e11.state.env))], quoted: true } : { values: a, quoted: true };
  if (s10.type === "AssignDefault") {
    if ((c || o10 && l) && s10.word) {
      let f10 = await i10(e11, s10.word.parts, true);
      return e11.state.env.set(`${n10}_0`, f10), e11.state.env.set(`${n10}__length`, "1"), { values: [f10], quoted: true };
    }
    return r10 ? { values: [a.join(fe(e11.state.env))], quoted: true } : { values: a, quoted: true };
  }
  return r10 ? { values: [a.join(fe(e11.state.env))], quoted: true } : { values: a, quoted: true };
}
async function $2(e11, t10) {
  if (t10.length !== 1 || t10[0].type !== "ParameterExpansion" || t10[0].operation?.type !== "UseAlternative" && t10[0].operation?.type !== "DefaultValue")
    return null;
  let n10 = t10[0], r10 = n10.operation, s10 = r10?.word;
  if (!s10 || s10.parts.length !== 1 || s10.parts[0].type !== "DoubleQuoted")
    return null;
  let i10 = s10.parts[0];
  if (i10.parts.length !== 1 || i10.parts[0].type !== "ParameterExpansion" || i10.parts[0].operation?.type !== "Indirection")
    return null;
  let o10 = i10.parts[0], l = (await Se(e11, o10.parameter)).match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!l)
    return null;
  let c = await mn(e11, n10.parameter), u = await Se(e11, n10.parameter) === "", f10 = r10.checkEmpty ?? false, p;
  if (r10.type === "UseAlternative" ? p = c && !(f10 && u) : p = !c || f10 && u, p) {
    let h = l[1], m = l[2] === "*", d = ae(e11, h);
    if (d.length > 0) {
      let y = d.map(([, w]) => w);
      return m ? { values: [y.join(fe(e11.state.env))], quoted: true } : { values: y, quoted: true };
    }
    let g = e11.state.env.get(h);
    return g !== void 0 ? { values: [g], quoted: true } : { values: [], quoted: true };
  }
  return { values: [], quoted: false };
}
async function T2(e11, t10) {
  if (t10.length !== 1 || t10[0].type !== "ParameterExpansion" || t10[0].operation?.type !== "Indirection")
    return null;
  let n10 = t10[0], s10 = n10.operation.innerOp;
  if (!s10 || s10.type !== "UseAlternative" && s10.type !== "DefaultValue")
    return null;
  let i10 = s10.word;
  if (!i10 || i10.parts.length !== 1 || i10.parts[0].type !== "DoubleQuoted")
    return null;
  let o10 = i10.parts[0];
  if (o10.parts.length !== 1 || o10.parts[0].type !== "ParameterExpansion" || o10.parts[0].operation?.type !== "Indirection")
    return null;
  let a = o10.parts[0], c = (await Se(e11, a.parameter)).match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!c)
    return null;
  let u = await Se(e11, n10.parameter), f10 = await mn(e11, n10.parameter), p = u === "", h = s10.checkEmpty ?? false, m;
  if (s10.type === "UseAlternative" ? m = f10 && !(h && p) : m = !f10 || h && p, m) {
    let d = c[1], g = c[2] === "*", y = ae(e11, d);
    if (y.length > 0) {
      let b = y.map(([, x]) => x);
      return g ? { values: [b.join(fe(e11.state.env))], quoted: true } : { values: b, quoted: true };
    }
    let w = e11.state.env.get(d);
    return w !== void 0 ? { values: [w], quoted: true } : { values: [], quoted: true };
  }
  return { values: [], quoted: false };
}
var P2 = I(() => {
  "use strict";
  St();
  ye();
  zt();
  Tt();
  Xi();
});
function D2(e11) {
  let t10 = Number.parseInt(e11.state.env.get("#") || "0", 10), n10 = [];
  for (let r10 = 1; r10 <= t10; r10++)
    n10.push(e11.state.env.get(String(r10)) || "");
  return n10;
}
async function _2(e11, t10, n10, r10) {
  if (t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let s10 = t10[0], i10 = -1, o10 = false;
  for (let w = 0; w < s10.parts.length; w++) {
    let b = s10.parts[w];
    if (b.type === "ParameterExpansion" && (b.parameter === "@" || b.parameter === "*") && b.operation?.type === "Substring") {
      i10 = w, o10 = b.parameter === "*";
      break;
    }
  }
  if (i10 === -1)
    return null;
  let l = s10.parts[i10].operation, c = l.offset ? await n10(e11, l.offset.expression) : 0, u = l.length ? await n10(e11, l.length.expression) : void 0, f10 = Number.parseInt(e11.state.env.get("#") || "0", 10), p = [];
  for (let w = 1; w <= f10; w++)
    p.push(e11.state.env.get(String(w)) || "");
  let h = e11.state.env.get("0") || "bash", m;
  if (c <= 0) {
    let w = [h, ...p], b = w.length + c;
    if (b < 0)
      m = [];
    else {
      let x = c < 0 ? b : 0;
      if (u !== void 0) {
        let S = u < 0 ? w.length + u : x + u;
        m = w.slice(x, Math.max(x, S));
      } else
        m = w.slice(x);
    }
  } else {
    let w = c - 1;
    if (w >= p.length)
      m = [];
    else if (u !== void 0) {
      let b = u < 0 ? p.length + u : w + u;
      m = p.slice(w, Math.max(w, b));
    } else
      m = p.slice(w);
  }
  let d = "";
  for (let w = 0; w < i10; w++)
    d += await r10(e11, s10.parts[w]);
  let g = "";
  for (let w = i10 + 1; w < s10.parts.length; w++)
    g += await r10(e11, s10.parts[w]);
  if (m.length === 0) {
    let w = d + g;
    return { values: w ? [w] : [], quoted: true };
  }
  if (o10) {
    let w = fe(e11.state.env);
    return { values: [d + m.join(w) + g], quoted: true };
  }
  return m.length === 1 ? { values: [d + m[0] + g], quoted: true } : { values: [d + m[0], ...m.slice(1, -1), m[m.length - 1] + g], quoted: true };
}
async function L2(e11, t10, n10, r10) {
  if (t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let s10 = t10[0], i10 = -1, o10 = false;
  for (let y = 0; y < s10.parts.length; y++) {
    let w = s10.parts[y];
    if (w.type === "ParameterExpansion" && (w.parameter === "@" || w.parameter === "*") && w.operation?.type === "PatternReplacement") {
      i10 = y, o10 = w.parameter === "*";
      break;
    }
  }
  if (i10 === -1)
    return null;
  let l = s10.parts[i10].operation, c = D2(e11), u = "";
  for (let y = 0; y < i10; y++)
    u += await n10(e11, s10.parts[y]);
  let f10 = "";
  for (let y = i10 + 1; y < s10.parts.length; y++)
    f10 += await n10(e11, s10.parts[y]);
  if (c.length === 0) {
    let y = u + f10;
    return { values: y ? [y] : [], quoted: true };
  }
  let p = "";
  if (l.pattern)
    for (let y of l.pattern.parts)
      if (y.type === "Glob")
        p += me(y.pattern, true, e11.state.shoptOptions.extglob);
      else if (y.type === "Literal")
        p += me(y.value, true, e11.state.shoptOptions.extglob);
      else if (y.type === "SingleQuoted" || y.type === "Escaped")
        p += xe(y.value);
      else if (y.type === "DoubleQuoted") {
        let w = await r10(e11, y.parts);
        p += xe(w);
      } else if (y.type === "ParameterExpansion") {
        let w = await n10(e11, y);
        p += me(w, true, e11.state.shoptOptions.extglob);
      } else {
        let w = await n10(e11, y);
        p += xe(w);
      }
  let h = l.replacement ? await r10(e11, l.replacement.parts) : "", m = p;
  l.anchor === "start" ? m = `^${p}` : l.anchor === "end" && (m = `${p}$`);
  let d = [];
  try {
    let y = V(m, l.all ? "g" : "");
    for (let w of c)
      d.push(y.replace(w, h));
  } catch {
    d.push(...c);
  }
  if (o10) {
    let y = fe(e11.state.env);
    return { values: [u + d.join(y) + f10], quoted: true };
  }
  return d.length === 1 ? { values: [u + d[0] + f10], quoted: true } : { values: [u + d[0], ...d.slice(1, -1), d[d.length - 1] + f10], quoted: true };
}
async function F2(e11, t10, n10, r10) {
  if (t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let s10 = t10[0], i10 = -1, o10 = false;
  for (let g = 0; g < s10.parts.length; g++) {
    let y = s10.parts[g];
    if (y.type === "ParameterExpansion" && (y.parameter === "@" || y.parameter === "*") && y.operation?.type === "PatternRemoval") {
      i10 = g, o10 = y.parameter === "*";
      break;
    }
  }
  if (i10 === -1)
    return null;
  let l = s10.parts[i10].operation, c = D2(e11), u = "";
  for (let g = 0; g < i10; g++)
    u += await n10(e11, s10.parts[g]);
  let f10 = "";
  for (let g = i10 + 1; g < s10.parts.length; g++)
    f10 += await n10(e11, s10.parts[g]);
  if (c.length === 0) {
    let g = u + f10;
    return { values: g ? [g] : [], quoted: true };
  }
  let p = "", h = e11.state.shoptOptions.extglob;
  if (l.pattern)
    for (let g of l.pattern.parts)
      if (g.type === "Glob")
        p += me(g.pattern, l.greedy, h);
      else if (g.type === "Literal")
        p += me(g.value, l.greedy, h);
      else if (g.type === "SingleQuoted" || g.type === "Escaped")
        p += xe(g.value);
      else if (g.type === "DoubleQuoted") {
        let y = await r10(e11, g.parts);
        p += xe(y);
      } else if (g.type === "ParameterExpansion") {
        let y = await n10(e11, g);
        p += me(y, l.greedy, h);
      } else {
        let y = await n10(e11, g);
        p += xe(y);
      }
  let m = [];
  for (let g of c)
    m.push(Nn(g, p, l.side, l.greedy));
  if (o10) {
    let g = fe(e11.state.env);
    return { values: [u + m.join(g) + f10], quoted: true };
  }
  return m.length === 1 ? { values: [u + m[0] + f10], quoted: true } : { values: [u + m[0], ...m.slice(1, -1), m[m.length - 1] + f10], quoted: true };
}
async function M2(e11, t10, n10) {
  if (t10.length !== 1 || t10[0].type !== "DoubleQuoted")
    return null;
  let r10 = t10[0], s10 = -1, i10 = false;
  for (let p = 0; p < r10.parts.length; p++) {
    let h = r10.parts[p];
    if (h.type === "ParameterExpansion" && (h.parameter === "@" || h.parameter === "*")) {
      s10 = p, i10 = h.parameter === "*";
      break;
    }
  }
  if (s10 === -1)
    return null;
  let o10 = r10.parts[s10];
  if (o10.type === "ParameterExpansion" && o10.operation)
    return null;
  let a = Number.parseInt(e11.state.env.get("#") || "0", 10), l = "";
  for (let p = 0; p < s10; p++)
    l += await n10(e11, r10.parts[p]);
  let c = "";
  for (let p = s10 + 1; p < r10.parts.length; p++)
    c += await n10(e11, r10.parts[p]);
  if (a === 0) {
    if (i10)
      return { values: [l + c], quoted: true };
    let p = l + c;
    return { values: p ? [p] : [], quoted: true };
  }
  let u = [];
  for (let p = 1; p <= a; p++)
    u.push(e11.state.env.get(String(p)) || "");
  if (i10) {
    let p = fe(e11.state.env);
    return { values: [l + u.join(p) + c], quoted: true };
  }
  return u.length === 1 ? { values: [l + u[0] + c], quoted: true } : { values: [l + u[0], ...u.slice(1, -1), u[u.length - 1] + c], quoted: true };
}
var U22 = I(() => {
  "use strict";
  Fe();
  zt();
  Lr();
  Fr();
  sr();
});
function gx(e11) {
  return new _n(e11.fs, e11.state.cwd, e11.state.env, { globstar: e11.state.shoptOptions.globstar, nullglob: e11.state.shoptOptions.nullglob, failglob: e11.state.shoptOptions.failglob, dotglob: e11.state.shoptOptions.dotglob, extglob: e11.state.shoptOptions.extglob, globskipdots: e11.state.shoptOptions.globskipdots, maxGlobOperations: e11.limits.maxGlobOperations });
}
async function Ji(e11, t10) {
  if (e11.state.options.noglob)
    return t10;
  let n10 = gx(e11), r10 = [];
  for (let s10 of t10)
    if (gn(s10, e11.state.shoptOptions.extglob)) {
      let i10 = await n10.expand(s10);
      if (i10.length > 0)
        r10.push(...i10);
      else {
        if (n10.hasFailglob())
          throw new on2(s10);
        n10.hasNullglob() || r10.push(s10);
      }
    } else
      r10.push(s10);
  return r10;
}
async function W2(e11, t10, n10, r10) {
  let s10 = -1, i10 = "", o10 = false;
  for (let w = 0; w < t10.length; w++) {
    let b = t10[w];
    if (b.type === "ParameterExpansion" && b.operation?.type === "PatternReplacement") {
      let x = b.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (x) {
        s10 = w, i10 = x[1], o10 = x[2] === "*";
        break;
      }
    }
  }
  if (s10 === -1)
    return null;
  let l = t10[s10].operation, c = ae(e11, i10), u = c.map(([, w]) => w);
  if (c.length === 0) {
    let w = e11.state.env.get(i10);
    w !== void 0 && (u = [w]);
  }
  if (u.length === 0)
    return { values: [], quoted: false };
  let f10 = "";
  if (l.pattern)
    for (let w of l.pattern.parts)
      if (w.type === "Glob")
        f10 += me(w.pattern, true, e11.state.shoptOptions.extglob);
      else if (w.type === "Literal")
        f10 += me(w.value, true, e11.state.shoptOptions.extglob);
      else if (w.type === "SingleQuoted" || w.type === "Escaped")
        f10 += xe(w.value);
      else if (w.type === "DoubleQuoted") {
        let b = await n10(e11, w.parts);
        f10 += xe(b);
      } else if (w.type === "ParameterExpansion") {
        let b = await r10(e11, w);
        f10 += me(b, true, e11.state.shoptOptions.extglob);
      } else {
        let b = await r10(e11, w);
        f10 += xe(b);
      }
  let p = l.replacement ? await n10(e11, l.replacement.parts) : "", h = f10;
  l.anchor === "start" ? h = `^${f10}` : l.anchor === "end" && (h = `${f10}$`);
  let m = [];
  try {
    let w = V(h, l.all ? "g" : "");
    for (let b of u)
      m.push(w.replace(b, p));
  } catch {
    m.push(...u);
  }
  let d = nt(e11.state.env), g = ut(e11.state.env);
  if (o10) {
    let w = fe(e11.state.env), b = m.join(w);
    return g ? { values: b ? [b] : [], quoted: false } : { values: _e(b, d), quoted: false };
  }
  if (g)
    return { values: m, quoted: false };
  let y = [];
  for (let w of m)
    w === "" ? y.push("") : y.push(..._e(w, d));
  return { values: y, quoted: false };
}
async function B2(e11, t10, n10, r10) {
  let s10 = -1, i10 = "", o10 = false;
  for (let y = 0; y < t10.length; y++) {
    let w = t10[y];
    if (w.type === "ParameterExpansion" && w.operation?.type === "PatternRemoval") {
      let b = w.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (b) {
        s10 = y, i10 = b[1], o10 = b[2] === "*";
        break;
      }
    }
  }
  if (s10 === -1)
    return null;
  let l = t10[s10].operation, c = ae(e11, i10), u = c.map(([, y]) => y);
  if (c.length === 0) {
    let y = e11.state.env.get(i10);
    y !== void 0 && (u = [y]);
  }
  if (u.length === 0)
    return { values: [], quoted: false };
  let f10 = "", p = e11.state.shoptOptions.extglob;
  if (l.pattern)
    for (let y of l.pattern.parts)
      if (y.type === "Glob")
        f10 += me(y.pattern, l.greedy, p);
      else if (y.type === "Literal")
        f10 += me(y.value, l.greedy, p);
      else if (y.type === "SingleQuoted" || y.type === "Escaped")
        f10 += xe(y.value);
      else if (y.type === "DoubleQuoted") {
        let w = await n10(e11, y.parts);
        f10 += xe(w);
      } else if (y.type === "ParameterExpansion") {
        let w = await r10(e11, y);
        f10 += me(w, l.greedy, p);
      } else {
        let w = await r10(e11, y);
        f10 += xe(w);
      }
  let h = [];
  for (let y of u)
    h.push(Nn(y, f10, l.side, l.greedy));
  let m = nt(e11.state.env), d = ut(e11.state.env);
  if (o10) {
    let y = fe(e11.state.env), w = h.join(y);
    return d ? { values: w ? [w] : [], quoted: false } : { values: _e(w, m), quoted: false };
  }
  if (d)
    return { values: h, quoted: false };
  let g = [];
  for (let y of h)
    y === "" ? g.push("") : g.push(..._e(y, m));
  return { values: g, quoted: false };
}
async function z2(e11, t10, n10, r10) {
  let s10 = -1, i10 = false;
  for (let g = 0; g < t10.length; g++) {
    let y = t10[g];
    if (y.type === "ParameterExpansion" && (y.parameter === "@" || y.parameter === "*") && y.operation?.type === "PatternRemoval") {
      s10 = g, i10 = y.parameter === "*";
      break;
    }
  }
  if (s10 === -1)
    return null;
  let a = t10[s10].operation, l = Number.parseInt(e11.state.env.get("#") || "0", 10), c = [];
  for (let g = 1; g <= l; g++)
    c.push(e11.state.env.get(String(g)) || "");
  if (c.length === 0)
    return { values: [], quoted: false };
  let u = "", f10 = e11.state.shoptOptions.extglob;
  if (a.pattern)
    for (let g of a.pattern.parts)
      if (g.type === "Glob")
        u += me(g.pattern, a.greedy, f10);
      else if (g.type === "Literal")
        u += me(g.value, a.greedy, f10);
      else if (g.type === "SingleQuoted" || g.type === "Escaped")
        u += xe(g.value);
      else if (g.type === "DoubleQuoted") {
        let y = await n10(e11, g.parts);
        u += xe(y);
      } else if (g.type === "ParameterExpansion") {
        let y = await r10(e11, g);
        u += me(y, a.greedy, f10);
      } else {
        let y = await r10(e11, g);
        u += xe(y);
      }
  let p = [];
  for (let g of c)
    p.push(Nn(g, u, a.side, a.greedy));
  let h = nt(e11.state.env), m = ut(e11.state.env);
  if (i10) {
    let g = fe(e11.state.env), y = p.join(g);
    return m ? { values: y ? [y] : [], quoted: false } : { values: _e(y, h), quoted: false };
  }
  if (m)
    return { values: p, quoted: false };
  let d = [];
  for (let g of p)
    g === "" ? d.push("") : d.push(..._e(g, h));
  return { values: d, quoted: false };
}
async function H2(e11, t10, n10, r10) {
  let s10 = -1, i10 = false;
  for (let b = 0; b < t10.length; b++) {
    let x = t10[b];
    if (x.type === "ParameterExpansion" && (x.parameter === "@" || x.parameter === "*") && x.operation?.type === "Substring") {
      s10 = b, i10 = x.parameter === "*";
      break;
    }
  }
  if (s10 === -1)
    return null;
  let a = t10[s10].operation, l = a.offset ? await n10(e11, a.offset.expression) : 0, c = a.length ? await n10(e11, a.length.expression) : void 0, u = Number.parseInt(e11.state.env.get("#") || "0", 10), f10 = [];
  for (let b = 1; b <= u; b++)
    f10.push(e11.state.env.get(String(b)) || "");
  let p = e11.state.env.get("0") || "bash", h;
  if (l <= 0) {
    let b = [p, ...f10], x = b.length + l;
    if (x < 0)
      h = [];
    else {
      let S = l < 0 ? x : 0;
      if (c !== void 0) {
        let O = c < 0 ? b.length + c : S + c;
        h = b.slice(S, Math.max(S, O));
      } else
        h = b.slice(S);
    }
  } else {
    let b = l - 1;
    if (b >= f10.length)
      h = [];
    else if (c !== void 0) {
      let x = c < 0 ? f10.length + c : b + c;
      h = f10.slice(b, Math.max(b, x));
    } else
      h = f10.slice(b);
  }
  let m = "";
  for (let b = 0; b < s10; b++)
    m += await r10(e11, t10[b]);
  let d = "";
  for (let b = s10 + 1; b < t10.length; b++)
    d += await r10(e11, t10[b]);
  let g = nt(e11.state.env), y = ut(e11.state.env);
  if (h.length === 0) {
    let b = m + d;
    return b ? y ? { values: [b], quoted: false } : { values: _e(b, g), quoted: false } : { values: [], quoted: false };
  }
  let w;
  if (i10) {
    let b = fe(e11.state.env), x = m + h.join(b) + d;
    y ? w = x ? [x] : [] : w = _e(x, g);
  } else if (y)
    h.length === 1 ? w = [m + h[0] + d] : w = [m + h[0], ...h.slice(1, -1), h[h.length - 1] + d];
  else {
    w = [];
    for (let b = 0; b < h.length; b++) {
      let x = h[b];
      if (b === 0 && (x = m + x), b === h.length - 1 && (x = x + d), x === "")
        w.push("");
      else {
        let S = _e(x, g);
        w.push(...S);
      }
    }
  }
  return { values: await Ji(e11, w), quoted: false };
}
async function j2(e11, t10) {
  if (t10.length !== 1 || t10[0].type !== "ParameterExpansion" || t10[0].parameter !== "@" && t10[0].parameter !== "*" || t10[0].operation)
    return null;
  let n10 = t10[0].parameter === "*", r10 = Number.parseInt(e11.state.env.get("#") || "0", 10);
  if (r10 === 0)
    return { values: [], quoted: false };
  let s10 = [];
  for (let c = 1; c <= r10; c++)
    s10.push(e11.state.env.get(String(c)) || "");
  let i10 = nt(e11.state.env), o10 = ut(e11.state.env), a = Vi(e11.state.env), l;
  if (n10)
    if (o10)
      l = s10.filter((c) => c !== "");
    else {
      let c = fe(e11.state.env), u = s10.join(c);
      l = _e(u, i10);
    }
  else if (o10)
    l = s10.filter((c) => c !== "");
  else if (a) {
    l = [];
    for (let c of s10) {
      if (c === "")
        continue;
      let u = _e(c, i10);
      l.push(...u);
    }
  } else {
    l = [];
    for (let c of s10)
      if (c === "")
        l.push("");
      else {
        let u = _e(c, i10);
        l.push(...u);
      }
    for (; l.length > 0 && l[l.length - 1] === ""; )
      l.pop();
  }
  return { values: await Ji(e11, l), quoted: false };
}
async function G2(e11, t10) {
  if (t10.length !== 1 || t10[0].type !== "ParameterExpansion" || t10[0].operation)
    return null;
  let n10 = t10[0].parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!n10)
    return null;
  let r10 = n10[1], s10 = n10[2] === "*", i10 = ae(e11, r10), o10;
  if (i10.length === 0) {
    let f10 = e11.state.env.get(r10);
    if (f10 !== void 0)
      o10 = [f10];
    else
      return { values: [], quoted: false };
  } else
    o10 = i10.map(([, f10]) => f10);
  let a = nt(e11.state.env), l = ut(e11.state.env), c = Vi(e11.state.env), u;
  if (s10)
    if (l)
      u = o10.filter((f10) => f10 !== "");
    else {
      let f10 = fe(e11.state.env), p = o10.join(f10);
      u = _e(p, a);
    }
  else if (l)
    u = o10.filter((f10) => f10 !== "");
  else if (c) {
    u = [];
    for (let f10 of o10) {
      if (f10 === "")
        continue;
      let p = _e(f10, a);
      u.push(...p);
    }
  } else {
    u = [];
    for (let f10 of o10)
      if (f10 === "")
        u.push("");
      else {
        let p = _e(f10, a);
        u.push(...p);
      }
    for (; u.length > 0 && u[u.length - 1] === ""; )
      u.pop();
  }
  return { values: await Ji(e11, u), quoted: false };
}
function V2(e11, t10) {
  if (t10.length !== 1 || t10[0].type !== "ParameterExpansion" || t10[0].operation?.type !== "VarNamePrefix")
    return null;
  let n10 = t10[0].operation, r10 = Mr(e11, n10.prefix);
  if (r10.length === 0)
    return { values: [], quoted: false };
  let s10 = nt(e11.state.env), i10 = ut(e11.state.env), o10;
  if (n10.star)
    if (i10)
      o10 = r10;
    else {
      let a = fe(e11.state.env), l = r10.join(a);
      o10 = _e(l, s10);
    }
  else if (i10)
    o10 = r10;
  else {
    o10 = [];
    for (let a of r10) {
      let l = _e(a, s10);
      o10.push(...l);
    }
  }
  return { values: o10, quoted: false };
}
function q2(e11, t10) {
  if (t10.length !== 1 || t10[0].type !== "ParameterExpansion" || t10[0].operation?.type !== "ArrayKeys")
    return null;
  let n10 = t10[0].operation, s10 = ae(e11, n10.array).map(([l]) => String(l));
  if (s10.length === 0)
    return { values: [], quoted: false };
  let i10 = nt(e11.state.env), o10 = ut(e11.state.env), a;
  if (n10.star)
    if (o10)
      a = s10;
    else {
      let l = fe(e11.state.env), c = s10.join(l);
      a = _e(c, i10);
    }
  else if (o10)
    a = s10;
  else {
    a = [];
    for (let l of s10) {
      let c = _e(l, i10);
      a.push(...c);
    }
  }
  return { values: a, quoted: false };
}
async function Z2(e11, t10, n10) {
  let r10 = -1;
  for (let p = 0; p < t10.length; p++) {
    let h = t10[p];
    if (h.type === "ParameterExpansion" && (h.parameter === "@" || h.parameter === "*") && !h.operation) {
      r10 = p;
      break;
    }
  }
  if (r10 === -1 || t10.length <= 1)
    return null;
  let s10 = Number.parseInt(e11.state.env.get("#") || "0", 10), i10 = [];
  for (let p = 1; p <= s10; p++)
    i10.push(e11.state.env.get(String(p)) || "");
  let o10 = "";
  for (let p = 0; p < r10; p++)
    o10 += await n10(e11, t10[p]);
  let a = "";
  for (let p = r10 + 1; p < t10.length; p++)
    a += await n10(e11, t10[p]);
  let l = nt(e11.state.env), c = ut(e11.state.env), u = Vi(e11.state.env);
  if (s10 === 0) {
    let p = o10 + a;
    return { values: p ? [p] : [], quoted: false };
  }
  let f10;
  {
    let p = [];
    for (let h = 0; h < i10.length; h++) {
      let m = i10[h];
      h === 0 && (m = o10 + m), h === i10.length - 1 && (m = m + a), p.push(m);
    }
    if (c)
      f10 = p.filter((h) => h !== "");
    else if (u) {
      f10 = [];
      for (let h of p) {
        if (h === "")
          continue;
        let m = _e(h, l);
        f10.push(...m);
      }
    } else {
      f10 = [];
      for (let h of p)
        if (h === "")
          f10.push("");
        else {
          let m = _e(h, l);
          f10.push(...m);
        }
      for (; f10.length > 0 && f10[f10.length - 1] === ""; )
        f10.pop();
    }
  }
  return f10.length === 0 ? { values: [], quoted: false } : { values: await Ji(e11, f10), quoted: false };
}
var Q2 = I(() => {
  "use strict";
  Fe();
  Hi();
  ye();
  zt();
  Lr();
  _r();
  Fr();
  sr();
  Tt();
});
async function Y2(e11, t10, n10) {
  e11.coverage?.hit("bash:expansion:word_glob");
  let r10 = t10.parts, { hasQuoted: s10, hasCommandSub: i10, hasArrayVar: o10, hasArrayAtExpansion: a, hasParamExpansion: l, hasVarNamePrefixExpansion: c, hasIndirection: u } = xs(r10), p = n10.hasBraceExpansion(r10) ? await n10.expandWordWithBracesAsync(e11, t10) : null;
  if (p && p.length > 1)
    return yx(e11, p, s10);
  let h = await wx(e11, r10, a, c, u, n10);
  if (h !== null)
    return h;
  let m = await xx(e11, r10, n10);
  if (m !== null)
    return m;
  let d = await Ex(e11, r10, n10);
  if (d !== null)
    return d;
  let g = await Sx(e11, r10, n10.expandPart);
  if (g !== null)
    return X2(e11, g);
  if ((i10 || o10 || l) && !ut(e11.state.env)) {
    let w = nt(e11.state.env), b = n10.buildIfsCharClassPattern(w), x = await n10.smartWordSplit(e11, r10, w, b, n10.expandPart);
    return X2(e11, x);
  }
  let y = await n10.expandWordAsync(e11, t10);
  return Cx(e11, t10, r10, y, s10, n10.expandWordForGlobbing);
}
async function yx(e11, t10, n10) {
  let r10 = [];
  for (let s10 of t10)
    if (!(!n10 && s10 === ""))
      if (!n10 && !e11.state.options.noglob && gn(s10, e11.state.shoptOptions.extglob)) {
        let i10 = await eo(e11, s10);
        r10.push(...i10);
      } else
        r10.push(s10);
  return { values: r10, quoted: false };
}
async function wx(e11, t10, n10, r10, s10, i10) {
  if (n10) {
    let o10 = v2(e11, t10);
    if (o10 !== null)
      return o10;
  }
  {
    let o10 = I2(e11, t10);
    if (o10 !== null)
      return o10;
  }
  {
    let o10 = await x2(e11, t10);
    if (o10 !== null)
      return o10;
  }
  {
    let o10 = await E2(e11, t10, n10, i10.expandPart, i10.expandWordPartsAsync);
    if (o10 !== null)
      return o10;
  }
  {
    let o10 = await A2(e11, t10, n10, i10.expandPart);
    if (o10 !== null)
      return o10;
  }
  {
    let o10 = await C2(e11, t10, i10.evaluateArithmetic);
    if (o10 !== null)
      return o10;
  }
  {
    let o10 = N2(e11, t10);
    if (o10 !== null)
      return o10;
  }
  {
    let o10 = await y2(e11, t10, i10.expandWordPartsAsync, i10.expandPart);
    if (o10 !== null)
      return o10;
  }
  {
    let o10 = await w2(e11, t10, i10.expandWordPartsAsync, i10.expandPart);
    if (o10 !== null)
      return o10;
  }
  if (r10 && t10.length === 1 && t10[0].type === "DoubleQuoted") {
    let o10 = bx(e11, t10);
    if (o10 !== null)
      return o10;
  }
  {
    let o10 = await R2(e11, t10, s10, i10.expandParameterAsync, i10.expandWordPartsAsync);
    if (o10 !== null)
      return o10;
  }
  {
    let o10 = await $2(e11, t10);
    if (o10 !== null)
      return o10;
  }
  {
    let o10 = await T2(e11, t10);
    if (o10 !== null)
      return o10;
  }
  return null;
}
function bx(e11, t10) {
  let n10 = t10[0];
  if (n10.type !== "DoubleQuoted")
    return null;
  if (n10.parts.length === 1 && n10.parts[0].type === "ParameterExpansion" && n10.parts[0].operation?.type === "VarNamePrefix") {
    let r10 = n10.parts[0].operation, s10 = Mr(e11, r10.prefix);
    return r10.star ? { values: [s10.join(fe(e11.state.env))], quoted: true } : { values: s10, quoted: true };
  }
  if (n10.parts.length === 1 && n10.parts[0].type === "ParameterExpansion" && n10.parts[0].operation?.type === "ArrayKeys") {
    let r10 = n10.parts[0].operation, i10 = ae(e11, r10.array).map(([o10]) => String(o10));
    return r10.star ? { values: [i10.join(fe(e11.state.env))], quoted: true } : { values: i10, quoted: true };
  }
  return null;
}
async function xx(e11, t10, n10) {
  {
    let r10 = await _2(e11, t10, n10.evaluateArithmetic, n10.expandPart);
    if (r10 !== null)
      return r10;
  }
  {
    let r10 = await L2(e11, t10, n10.expandPart, n10.expandWordPartsAsync);
    if (r10 !== null)
      return r10;
  }
  {
    let r10 = await F2(e11, t10, n10.expandPart, n10.expandWordPartsAsync);
    if (r10 !== null)
      return r10;
  }
  {
    let r10 = await M2(e11, t10, n10.expandPart);
    if (r10 !== null)
      return r10;
  }
  return null;
}
async function Ex(e11, t10, n10) {
  {
    let r10 = await W2(e11, t10, n10.expandWordPartsAsync, n10.expandPart);
    if (r10 !== null)
      return r10;
  }
  {
    let r10 = await B2(e11, t10, n10.expandWordPartsAsync, n10.expandPart);
    if (r10 !== null)
      return r10;
  }
  {
    let r10 = await z2(e11, t10, n10.expandWordPartsAsync, n10.expandPart);
    if (r10 !== null)
      return r10;
  }
  {
    let r10 = await H2(e11, t10, n10.evaluateArithmetic, n10.expandPart);
    if (r10 !== null)
      return r10;
  }
  {
    let r10 = await j2(e11, t10);
    if (r10 !== null)
      return r10;
  }
  {
    let r10 = await G2(e11, t10);
    if (r10 !== null)
      return r10;
  }
  {
    let r10 = V2(e11, t10);
    if (r10 !== null)
      return r10;
  }
  {
    let r10 = q2(e11, t10);
    if (r10 !== null)
      return r10;
  }
  {
    let r10 = await Z2(e11, t10, n10.expandPart);
    if (r10 !== null)
      return r10;
  }
  return null;
}
function K2(e11) {
  if (e11.type !== "DoubleQuoted")
    return null;
  for (let t10 = 0; t10 < e11.parts.length; t10++) {
    let n10 = e11.parts[t10];
    if (n10.type !== "ParameterExpansion" || n10.operation)
      continue;
    let r10 = n10.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
    if (r10)
      return { type: "array", name: r10[1], atIndex: t10, isStar: r10[2] === "*" };
    if (n10.parameter === "@" || n10.parameter === "*")
      return { type: "positional", atIndex: t10, isStar: n10.parameter === "*" };
  }
  return null;
}
async function Ax(e11, t10, n10, r10) {
  let s10 = "";
  for (let a = 0; a < n10.atIndex; a++)
    s10 += await r10(e11, t10.parts[a]);
  let i10 = "";
  for (let a = n10.atIndex + 1; a < t10.parts.length; a++)
    i10 += await r10(e11, t10.parts[a]);
  let o10;
  if (n10.type === "array") {
    if (o10 = ae(e11, n10.name).map(([, l]) => l), o10.length === 0) {
      let l = e11.state.env.get(n10.name);
      l !== void 0 && (o10 = [l]);
    }
  } else {
    let a = Number.parseInt(e11.state.env.get("#") || "0", 10);
    o10 = [];
    for (let l = 1; l <= a; l++)
      o10.push(e11.state.env.get(String(l)) || "");
  }
  if (n10.isStar) {
    let a = fe(e11.state.env), l = o10.join(a);
    return [s10 + l + i10];
  }
  if (o10.length === 0) {
    let a = s10 + i10;
    return a ? [a] : [];
  }
  return o10.length === 1 ? [s10 + o10[0] + i10] : [s10 + o10[0], ...o10.slice(1, -1), o10[o10.length - 1] + i10];
}
async function Sx(e11, t10, n10) {
  if (t10.length < 2)
    return null;
  let r10 = false;
  for (let l of t10)
    if (K2(l)) {
      r10 = true;
      break;
    }
  if (!r10)
    return null;
  let s10 = nt(e11.state.env), i10 = ut(e11.state.env), o10 = [];
  for (let l of t10) {
    let c = K2(l);
    if (c && l.type === "DoubleQuoted") {
      let u = await Ax(e11, l, c, n10);
      o10.push(u);
    } else if (l.type === "DoubleQuoted" || l.type === "SingleQuoted") {
      let u = await n10(e11, l);
      o10.push([u]);
    } else if (l.type === "Literal")
      o10.push([l.value]);
    else if (l.type === "ParameterExpansion") {
      let u = await n10(e11, l);
      if (i10)
        o10.push(u ? [u] : []);
      else {
        let f10 = _e(u, s10);
        o10.push(f10);
      }
    } else {
      let u = await n10(e11, l);
      if (i10)
        o10.push(u ? [u] : []);
      else {
        let f10 = _e(u, s10);
        o10.push(f10);
      }
    }
  }
  let a = [];
  for (let l of o10)
    if (l.length !== 0)
      if (a.length === 0)
        a.push(...l);
      else {
        let c = a.length - 1;
        a[c] = a[c] + l[0];
        for (let u = 1; u < l.length; u++)
          a.push(l[u]);
      }
  return a;
}
async function X2(e11, t10) {
  if (e11.state.options.noglob)
    return { values: t10, quoted: false };
  let n10 = [];
  for (let r10 of t10)
    if (gn(r10, e11.state.shoptOptions.extglob)) {
      let s10 = await eo(e11, r10);
      n10.push(...s10);
    } else
      n10.push(r10);
  return { values: n10, quoted: false };
}
async function eo(e11, t10) {
  let n10 = new _n(e11.fs, e11.state.cwd, e11.state.env, { globstar: e11.state.shoptOptions.globstar, nullglob: e11.state.shoptOptions.nullglob, failglob: e11.state.shoptOptions.failglob, dotglob: e11.state.shoptOptions.dotglob, extglob: e11.state.shoptOptions.extglob, globskipdots: e11.state.shoptOptions.globskipdots, maxGlobOperations: e11.limits.maxGlobOperations }), r10 = await n10.expand(t10);
  if (r10.length > 0)
    return r10;
  if (n10.hasFailglob())
    throw new on2(t10);
  return n10.hasNullglob() ? [] : [t10];
}
async function Cx(e11, t10, n10, r10, s10, i10) {
  let o10 = n10.some((a) => a.type === "Glob");
  if (!e11.state.options.noglob && o10) {
    let a = await i10(e11, t10);
    if (gn(a, e11.state.shoptOptions.extglob)) {
      let c = await eo(e11, a);
      if (c.length > 0 && c[0] !== a)
        return { values: c, quoted: false };
      if (c.length === 0)
        return { values: [], quoted: false };
    }
    let l = ec(r10);
    if (!ut(e11.state.env)) {
      let c = nt(e11.state.env);
      return { values: _e(l, c), quoted: false };
    }
    return { values: [l], quoted: false };
  }
  if (!s10 && !e11.state.options.noglob && gn(r10, e11.state.shoptOptions.extglob)) {
    let a = await i10(e11, t10);
    if (gn(a, e11.state.shoptOptions.extglob)) {
      let l = await eo(e11, a);
      if (l.length > 0 && l[0] !== a)
        return { values: l, quoted: false };
    }
  }
  if (r10 === "" && !s10)
    return { values: [], quoted: false };
  if (o10 && !s10) {
    let a = ec(r10);
    if (!ut(e11.state.env)) {
      let l = nt(e11.state.env);
      return { values: _e(a, l), quoted: false };
    }
    return { values: [a], quoted: false };
  }
  return { values: [r10], quoted: s10 };
}
var J2 = I(() => {
  "use strict";
  Hi();
  ye();
  zt();
  ji();
  b2();
  S2();
  k2();
  O2();
  _r();
  P2();
  sr();
  U22();
  Q2();
  Tt();
});
async function t6(e11, t10) {
  let n10 = t10.operation;
  if (!n10 || n10.type !== "DefaultValue" && n10.type !== "AssignDefault" && n10.type !== "UseAlternative")
    return null;
  let r10 = n10.word;
  if (!r10 || r10.parts.length === 0)
    return null;
  let s10 = await mn(e11, t10.parameter), o10 = await Se(e11, t10.parameter, false) === "", a = n10.checkEmpty ?? false, l;
  return n10.type === "UseAlternative" ? l = s10 && !(a && o10) : l = !s10 || a && o10, l ? r10.parts : null;
}
function Nx(e11) {
  return e11.type === "SingleQuoted" ? true : e11.type === "DoubleQuoted" ? e11.parts.every((n10) => n10.type === "Literal") : false;
}
async function kx(e11, t10) {
  if (t10.type !== "ParameterExpansion")
    return null;
  let n10 = await t6(e11, t10);
  if (!n10 || n10.length <= 1)
    return null;
  let r10 = n10.some((i10) => Nx(i10)), s10 = n10.some((i10) => i10.type === "Literal" || i10.type === "ParameterExpansion" || i10.type === "CommandSubstitution" || i10.type === "ArithmeticExpansion");
  return r10 && s10 ? n10 : null;
}
function vx(e11) {
  return e11.type === "DoubleQuoted" || e11.type === "SingleQuoted" || e11.type === "Literal" ? false : e11.type === "Glob" ? ql(e11.pattern) : !(!(e11.type === "ParameterExpansion" || e11.type === "CommandSubstitution" || e11.type === "ArithmeticExpansion") || e11.type === "ParameterExpansion" && Mm(e11));
}
async function n6(e11, t10, n10, r10, s10) {
  if (e11.coverage?.hit("bash:expansion:word_split"), t10.length === 1 && t10[0].type === "ParameterExpansion") {
    let p = t10[0], h = await t6(e11, p);
    if (h && h.length > 0 && h.length > 1 && h.some((d) => d.type === "DoubleQuoted" || d.type === "SingleQuoted") && h.some((d) => d.type === "Literal" || d.type === "ParameterExpansion" || d.type === "CommandSubstitution" || d.type === "ArithmeticExpansion"))
      return e6(e11, h, n10, r10, s10);
  }
  let i10 = [], o10 = false;
  for (let p of t10) {
    let h = vx(p), m = p.type === "DoubleQuoted" || p.type === "SingleQuoted", d = h ? await kx(e11, p) : null, g = await s10(e11, p);
    i10.push({ value: g, isSplittable: h, isQuoted: m, mixedDefaultParts: d ?? void 0 }), h && (o10 = true);
  }
  if (!o10) {
    let p = i10.map((h) => h.value).join("");
    return p ? [p] : [];
  }
  let a = [], l = "", c = false, u = false, f10 = false;
  for (let p of i10)
    if (!p.isSplittable)
      u ? p.isQuoted && p.value === "" ? (l !== "" && a.push(l), a.push(""), c = true, l = "", u = false, f10 = true) : p.value !== "" ? (l !== "" && a.push(l), l = p.value, u = false, f10 = false) : (l += p.value, f10 = false) : (l += p.value, f10 = p.isQuoted && p.value === "");
    else if (p.mixedDefaultParts) {
      let h = await e6(e11, p.mixedDefaultParts, n10, r10, s10);
      if (h.length !== 0)
        if (h.length === 1)
          l += h[0], c = true;
        else {
          l += h[0], a.push(l), c = true;
          for (let m = 1; m < h.length - 1; m++)
            a.push(h[m]);
          l = h[h.length - 1];
        }
      u = false, f10 = false;
    } else {
      let { words: h, hadLeadingDelimiter: m, hadTrailingDelimiter: d } = qi(p.value, n10);
      if (f10 && m && l === "" && (a.push(""), c = true), h.length === 0)
        d && (u = true);
      else if (h.length === 1)
        l += h[0], c = true, u = d;
      else {
        l += h[0], a.push(l), c = true;
        for (let g = 1; g < h.length - 1; g++)
          a.push(h[g]);
        l = h[h.length - 1], u = d;
      }
      f10 = false;
    }
  return l !== "" ? a.push(l) : a.length === 0 && c && a.push(""), a;
}
function Ix(e11, t10) {
  return e11.length > 0 && t10.includes(e11[0]);
}
async function e6(e11, t10, n10, r10, s10) {
  let i10 = [];
  for (let u of t10) {
    let p = !(u.type === "DoubleQuoted" || u.type === "SingleQuoted"), h = await s10(e11, u);
    i10.push({ value: h, isSplittable: p });
  }
  let o10 = [], a = "", l = false, c = false;
  for (let u of i10)
    if (!u.isSplittable)
      c && u.value !== "" ? (a !== "" && o10.push(a), a = u.value, c = false) : a += u.value;
    else {
      Ix(u.value, n10) && a !== "" && (o10.push(a), a = "", l = true);
      let { words: p, hadTrailingDelimiter: h } = qi(u.value, n10);
      if (p.length === 0)
        h && (c = true);
      else if (p.length === 1)
        a += p[0], l = true, c = h;
      else {
        a += p[0], o10.push(a), l = true;
        for (let m = 1; m < p.length - 1; m++)
          o10.push(p[m]);
        a = p[p.length - 1], c = h;
      }
    }
  return a !== "" ? o10.push(a) : o10.length === 0 && l && o10.push(""), o10;
}
var r6 = I(() => {
  "use strict";
  Tt();
  zt();
  ji();
});
function s6(e11) {
  switch (e11.type) {
    case "Literal":
      return e11.value;
    case "SingleQuoted":
      return e11.value;
    case "Escaped":
      return e11.value;
    default:
      return null;
  }
}
function i6(e11) {
  switch (e11.type) {
    case "SingleQuoted":
    case "Escaped":
    case "DoubleQuoted":
      return true;
    case "Literal":
      return e11.value === "";
    default:
      return false;
  }
}
var o6 = I(() => {
  "use strict";
});
var cc = {};
Q(cc, { escapeGlobChars: () => Pt, escapeRegexChars: () => Dr, expandRedirectTarget: () => Cs, expandWord: () => ie, expandWordForPattern: () => ac, expandWordForRegex: () => oc, expandWordWithGlob: () => sn, getArrayElements: () => ae, getVariable: () => Se, hasQuotedMultiValueAt: () => Ss, isArray: () => Cn, isWordFullyQuoted: () => ic });
function As(e11, t10, n10) {
  if (e11.length > t10)
    throw new te(`${n10}: string length limit exceeded (${t10} bytes)`, "string_length");
}
async function rn(e11, t10, n10 = false) {
  let r10 = [];
  for (let s10 of t10)
    r10.push(await Ht(e11, s10, n10));
  return r10.join("");
}
function Ox(e11) {
  return i6(e11);
}
function ic(e11) {
  if (e11.parts.length === 0)
    return true;
  for (let t10 of e11.parts)
    if (!Ox(t10))
      return false;
  return true;
}
function Rx(e11, t10, n10 = false) {
  let r10 = s6(t10);
  if (r10 !== null)
    return r10;
  switch (t10.type) {
    case "TildeExpansion":
      return n10 ? t10.user === null ? "~" : `~${t10.user}` : (e11.coverage?.hit("bash:expansion:tilde"), t10.user === null ? e11.state.env.get("HOME") ?? "/home/user" : t10.user === "root" ? "/root" : `~${t10.user}`);
    case "Glob":
      return rc(e11, t10.pattern);
    default:
      return null;
  }
}
async function ie(e11, t10) {
  return lc(e11, t10);
}
async function oc(e11, t10) {
  let n10 = [];
  for (let r10 of t10.parts)
    if (r10.type === "Escaped")
      n10.push(`\\${r10.value}`);
    else if (r10.type === "SingleQuoted")
      n10.push(r10.value);
    else if (r10.type === "DoubleQuoted") {
      let s10 = await rn(e11, r10.parts);
      n10.push(s10);
    } else if (r10.type === "TildeExpansion") {
      let s10 = await Ht(e11, r10);
      n10.push(Dr(s10));
    } else
      n10.push(await Ht(e11, r10));
  return n10.join("");
}
async function ac(e11, t10) {
  let n10 = [];
  for (let r10 of t10.parts)
    if (r10.type === "Escaped") {
      let s10 = r10.value;
      "()|*?[]".includes(s10) ? n10.push(`\\${s10}`) : n10.push(s10);
    } else if (r10.type === "SingleQuoted")
      n10.push(Pt(r10.value));
    else if (r10.type === "DoubleQuoted") {
      let s10 = await rn(e11, r10.parts);
      n10.push(Pt(s10));
    } else
      n10.push(await Ht(e11, r10));
  return n10.join("");
}
async function a6(e11, t10) {
  let n10 = [];
  for (let r10 of t10.parts)
    if (r10.type === "SingleQuoted")
      n10.push(Pt(r10.value));
    else if (r10.type === "Escaped") {
      let s10 = r10.value;
      "*?[]\\()|".includes(s10) ? n10.push(`\\${s10}`) : n10.push(s10);
    } else if (r10.type === "DoubleQuoted") {
      let s10 = await rn(e11, r10.parts);
      n10.push(Pt(s10));
    } else
      r10.type === "Glob" ? f2(r10.pattern) ? n10.push(await h2(e11, r10.pattern)) : n10.push(rc(e11, r10.pattern)) : r10.type === "Literal" ? n10.push(r10.value) : n10.push(await Ht(e11, r10));
  return n10.join("");
}
function no(e11) {
  for (let t10 of e11)
    if (t10.type === "BraceExpansion" || t10.type === "DoubleQuoted" && no(t10.parts))
      return true;
  return false;
}
async function l6(e11, t10, n10 = { count: 0 }) {
  if (n10.count > sc)
    return [[]];
  let r10 = [[]];
  for (let s10 of t10)
    if (s10.type === "BraceExpansion") {
      let i10 = [], o10 = false, a = "";
      for (let u of s10.items)
        if (u.type === "Range") {
          let f10 = Jl(u.start, u.end, u.step, u.startStr, u.endStr);
          if (f10.expanded)
            for (let p of f10.expanded)
              n10.count++, i10.push(p);
          else {
            o10 = true, a = f10.literal;
            break;
          }
        } else {
          let f10 = await l6(e11, u.word.parts, n10);
          for (let p of f10) {
            n10.count++;
            let h = [];
            for (let m of p)
              typeof m == "string" ? h.push(m) : h.push(await Ht(e11, m));
            i10.push(h.join(""));
          }
        }
      if (o10) {
        for (let u of r10)
          n10.count++, u.push(a);
        continue;
      }
      if (r10.length * i10.length > $x || n10.count > sc)
        return r10;
      let c = [];
      for (let u of r10)
        for (let f10 of i10) {
          if (n10.count++, n10.count > sc)
            return c.length > 0 ? c : r10;
          c.push([...u, f10]);
        }
      r10 = c;
    } else
      for (let i10 of r10)
        n10.count++, i10.push(s10);
  return r10;
}
async function c6(e11, t10) {
  let n10 = t10.parts;
  if (!no(n10))
    return [await ie(e11, t10)];
  let r10 = await l6(e11, n10), s10 = [];
  for (let i10 of r10) {
    let o10 = [];
    for (let a of i10)
      typeof a == "string" ? o10.push(a) : o10.push(await Ht(e11, a));
    s10.push(m2(e11, o10.join("")));
  }
  return s10;
}
function Tx() {
  return { expandWordAsync: lc, expandWordForGlobbing: a6, expandWordWithBracesAsync: c6, expandWordPartsAsync: rn, expandPart: Ht, expandParameterAsync: to, hasBraceExpansion: no, evaluateArithmetic: ne, buildIfsCharClassPattern: Um, smartWordSplit: n6 };
}
async function sn(e11, t10) {
  return Y2(e11, t10, Tx());
}
function Px(e11) {
  for (let t10 of e11) {
    if (t10.type === "ParameterExpansion")
      return t10.parameter;
    if (t10.type === "Literal")
      return t10.value;
  }
  return "";
}
function Ss(e11, t10) {
  if (Number.parseInt(e11.state.env.get("#") || "0", 10) < 2)
    return false;
  function r10(s10) {
    for (let i10 of s10)
      if (i10.type === "DoubleQuoted") {
        for (let o10 of i10.parts)
          if (o10.type === "ParameterExpansion" && o10.parameter === "@" && !o10.operation)
            return true;
      }
    return false;
  }
  return r10(t10.parts);
}
async function Cs(e11, t10) {
  if (Ss(e11, t10))
    return { error: `bash: $@: ambiguous redirect
` };
  let n10 = t10.parts, { hasQuoted: r10 } = xs(n10);
  if (no(n10) && (await c6(e11, t10)).length > 1)
    return { error: `bash: ${n10.map((h) => h.type === "Literal" ? h.value : h.type === "BraceExpansion" ? `{${h.items.map((d) => {
      if (d.type === "Range") {
        let g = d.step ? `..${d.step}` : "";
        return `${d.startStr ?? d.start}..${d.endStr ?? d.end}${g}`;
      }
      return d.word.parts.map((g) => g.type === "Literal" ? g.value : "").join("");
    }).join(",")}}` : "").join("")}: ambiguous redirect
` };
  let s10 = await lc(e11, t10), { hasParamExpansion: i10, hasCommandSub: o10 } = xs(n10);
  if ((i10 || o10) && !r10 && !ut(e11.state.env)) {
    let f10 = nt(e11.state.env);
    if (_e(s10, f10).length > 1)
      return { error: `bash: $${Px(n10)}: ambiguous redirect
` };
  }
  if (r10 || e11.state.options.noglob)
    return { target: s10 };
  let l = await a6(e11, t10);
  if (!gn(l, e11.state.shoptOptions.extglob))
    return { target: s10 };
  let c = new _n(e11.fs, e11.state.cwd, e11.state.env, { globstar: e11.state.shoptOptions.globstar, nullglob: e11.state.shoptOptions.nullglob, failglob: e11.state.shoptOptions.failglob, dotglob: e11.state.shoptOptions.dotglob, extglob: e11.state.shoptOptions.extglob, globskipdots: e11.state.shoptOptions.globskipdots, maxGlobOperations: e11.limits.maxGlobOperations }), u = await c.expand(l);
  return u.length === 0 ? c.hasFailglob() ? { error: `bash: no match: ${s10}
` } : { target: s10 } : u.length === 1 ? { target: u[0] } : { error: `bash: ${s10}: ambiguous redirect
` };
}
async function lc(e11, t10) {
  let n10 = t10.parts, r10 = n10.length;
  if (r10 === 1) {
    let o10 = await Ht(e11, n10[0]);
    return As(o10, e11.limits.maxStringLength, "word expansion"), o10;
  }
  let s10 = [];
  for (let o10 = 0; o10 < r10; o10++)
    s10.push(await Ht(e11, n10[o10]));
  let i10 = s10.join("");
  return As(i10, e11.limits.maxStringLength, "word expansion"), i10;
}
async function Ht(e11, t10, n10 = false) {
  if (t10.type === "ParameterExpansion")
    return to(e11, t10, n10);
  let r10 = Rx(e11, t10, n10);
  if (r10 !== null)
    return r10;
  switch (t10.type) {
    case "DoubleQuoted": {
      let s10 = [];
      for (let i10 of t10.parts)
        s10.push(await Ht(e11, i10, true));
      return s10.join("");
    }
    case "CommandSubstitution": {
      let s10 = Zm(t10.body);
      if (s10)
        try {
          let p = await ie(e11, s10.target), h = p.startsWith("/") ? p : `${e11.state.cwd}/${p}`, m = await e11.fs.readFile(h);
          e11.state.lastExitCode = 0, e11.state.env.set("?", "0");
          let d = m.replace(/\n+$/, "");
          return As(d, e11.limits.maxStringLength, "command substitution"), d;
        } catch (p) {
          if (p instanceof te)
            throw p;
          return e11.state.lastExitCode = 1, e11.state.env.set("?", "1"), "";
        }
      let i10 = e11.substitutionDepth ?? 0, o10 = e11.limits.maxSubstitutionDepth;
      if (i10 >= o10)
        throw new te(`Command substitution nesting limit exceeded (${o10})`, "substitution_depth");
      let a = e11.substitutionDepth;
      e11.substitutionDepth = i10 + 1;
      let l = e11.state.bashPid;
      e11.state.bashPid = e11.state.nextVirtualPid++;
      let c = new Map(e11.state.env), u = e11.state.cwd, f10 = e11.state.suppressVerbose;
      e11.state.suppressVerbose = true;
      try {
        let p = await e11.executeScript(t10.body), h = p.exitCode;
        e11.state.env = c, e11.state.cwd = u, e11.state.suppressVerbose = f10, e11.state.lastExitCode = h, e11.state.env.set("?", String(h)), p.stderr && (e11.state.expansionStderr = (e11.state.expansionStderr || "") + p.stderr), e11.state.bashPid = l, e11.substitutionDepth = a;
        let m = p.stdout.replace(/\n+$/, "");
        return As(m, e11.limits.maxStringLength, "command substitution"), m;
      } catch (p) {
        if (e11.state.env = c, e11.state.cwd = u, e11.state.bashPid = l, e11.substitutionDepth = a, e11.state.suppressVerbose = f10, p instanceof te)
          throw p;
        if (p instanceof pe) {
          e11.state.lastExitCode = p.exitCode, e11.state.env.set("?", String(p.exitCode)), p.stderr && (e11.state.expansionStderr = (e11.state.expansionStderr || "") + p.stderr);
          let h = p.stdout.replace(/\n+$/, "");
          return As(h, e11.limits.maxStringLength, "command substitution"), h;
        }
        throw p;
      }
    }
    case "ArithmeticExpansion": {
      let s10 = t10.expression.originalText;
      if (s10 && /\$[a-zA-Z_][a-zA-Z0-9_]*(?![{[(])/.test(s10)) {
        let o10 = await Gm(e11, s10), a = new ce(), l = Ae(a, o10);
        return String(await ne(e11, l.expression, true));
      }
      return String(await ne(e11, t10.expression.expression, true));
    }
    case "BraceExpansion": {
      let s10 = [];
      for (let i10 of t10.items)
        if (i10.type === "Range") {
          let o10 = Jl(i10.start, i10.end, i10.step, i10.startStr, i10.endStr);
          if (o10.expanded)
            s10.push(...o10.expanded);
          else
            return o10.literal;
        } else
          s10.push(await ie(e11, i10.word));
      return s10.join(" ");
    }
    default:
      return "";
  }
}
async function to(e11, t10, n10 = false) {
  let { parameter: r10 } = t10, { operation: s10 } = t10, i10 = r10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (i10) {
    let [, p, h] = i10;
    if (e11.state.associativeArrays?.has(p) || h.includes("$(") || h.includes("`") || h.includes("${")) {
      let d = await Yl(e11, h);
      r10 = `${p}[${d}]`;
    }
  } else if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r10) && Te(e11, r10)) {
    let p = At(e11, r10);
    if (p && p !== r10) {
      let h = p.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
      if (h) {
        let [, m, d] = h;
        if (e11.state.associativeArrays?.has(m) || d.includes("$(") || d.includes("`") || d.includes("${")) {
          let y = await Yl(e11, d);
          r10 = `${m}[${y}]`;
        }
      }
    }
  }
  let o10 = s10 && (s10.type === "DefaultValue" || s10.type === "AssignDefault" || s10.type === "UseAlternative" || s10.type === "ErrorIfUnset"), a = await Se(e11, r10, !o10);
  if (!s10)
    return a;
  let l = !await mn(e11, r10), { isEmpty: c, effectiveValue: u } = c2(e11, r10, a, n10), f10 = { value: a, isUnset: l, isEmpty: c, effectiveValue: u, inDoubleQuotes: n10 };
  switch (s10.type) {
    case "DefaultValue":
      return Km(e11, s10, f10, rn);
    case "AssignDefault":
      return Xm(e11, r10, s10, f10, rn);
    case "ErrorIfUnset":
      return Ym(e11, r10, s10, f10, rn);
    case "UseAlternative":
      return Jm(e11, s10, f10, rn);
    case "PatternRemoval":
      return e2(e11, a, s10, rn, Ht);
    case "PatternReplacement":
      return t2(e11, a, s10, rn, Ht);
    case "Length":
      return n2(e11, r10, a);
    case "LengthSliceError":
      throw new wt(r10);
    case "BadSubstitution":
      throw new wt(s10.text);
    case "Substring":
      return r2(e11, r10, a, s10);
    case "CaseModification":
      return s2(e11, a, s10, rn, to);
    case "Transform":
      return i2(e11, r10, a, l, s10);
    case "Indirection":
      return o2(e11, r10, a, l, s10, to, n10);
    case "ArrayKeys":
      return a2(e11, s10);
    case "VarNamePrefix":
      return l2(e11, s10);
    default:
      return a;
  }
}
var $x;
var sc;
var Ct = I(() => {
  "use strict";
  dt();
  Ke();
  Hi();
  St();
  ye();
  ji();
  Vm();
  qm();
  Qm();
  _r();
  u2();
  d2();
  g2();
  Tt();
  J2();
  r6();
  zt();
  tn();
  o6();
  _r();
  Tt();
  $x = 1e4, sc = 1e5;
});
function Dx(e11, t10, n10) {
  switch (n10) {
    case "+":
      return e11 + t10;
    case "-":
      return e11 - t10;
    case "*":
      return e11 * t10;
    case "/":
      if (t10 === 0)
        throw new $e("division by 0");
      return Math.trunc(e11 / t10);
    case "%":
      if (t10 === 0)
        throw new $e("division by 0");
      return e11 % t10;
    case "**":
      if (t10 < 0)
        throw new $e("exponent less than 0");
      return e11 ** t10;
    case "<<":
      return e11 << t10;
    case ">>":
      return e11 >> t10;
    case "<":
      return e11 < t10 ? 1 : 0;
    case "<=":
      return e11 <= t10 ? 1 : 0;
    case ">":
      return e11 > t10 ? 1 : 0;
    case ">=":
      return e11 >= t10 ? 1 : 0;
    case "==":
      return e11 === t10 ? 1 : 0;
    case "!=":
      return e11 !== t10 ? 1 : 0;
    case "&":
      return e11 & t10;
    case "|":
      return e11 | t10;
    case "^":
      return e11 ^ t10;
    case ",":
      return t10;
    default:
      return 0;
  }
}
function u6(e11, t10, n10) {
  switch (n10) {
    case "=":
      return t10;
    case "+=":
      return e11 + t10;
    case "-=":
      return e11 - t10;
    case "*=":
      return e11 * t10;
    case "/=":
      return t10 !== 0 ? Math.trunc(e11 / t10) : 0;
    case "%=":
      return t10 !== 0 ? e11 % t10 : 0;
    case "<<=":
      return e11 << t10;
    case ">>=":
      return e11 >> t10;
    case "&=":
      return e11 & t10;
    case "|=":
      return e11 | t10;
    case "^=":
      return e11 ^ t10;
    default:
      return t10;
  }
}
function _x(e11, t10) {
  switch (t10) {
    case "-":
      return -e11;
    case "+":
      return +e11;
    case "!":
      return e11 === 0 ? 1 : 0;
    case "~":
      return ~e11;
    default:
      return e11;
  }
}
async function Lx(e11, t10) {
  let n10 = e11.state.env.get(t10);
  if (n10 !== void 0)
    return n10;
  let r10 = e11.state.env.get(`${t10}_0`);
  return r10 !== void 0 ? r10 : await Se(e11, t10);
}
function Fx(e11) {
  if (!e11)
    return 0;
  let t10 = Number.parseInt(e11, 10);
  if (!Number.isNaN(t10) && /^-?\d+$/.test(e11.trim()))
    return t10;
  let n10 = e11.trim();
  if (!n10)
    return 0;
  try {
    let r10 = new ce(), { expr: s10, pos: i10 } = Bt(r10, n10, 0);
    if (i10 < n10.length) {
      let o10 = n10.slice(i10).trim().split(/\s+/)[0];
      throw new $e(`${n10}: syntax error in expression (error token is "${o10}")`);
    }
    return s10.type === "ArithNumber" ? s10.value : t10 || 0;
  } catch (r10) {
    if (r10 instanceof $e)
      throw r10;
    let s10 = n10.split(/\s+/).slice(1)[0] || n10;
    throw new $e(`${n10}: syntax error in expression (error token is "${s10}")`);
  }
}
async function uc(e11, t10) {
  if (!t10)
    return 0;
  let n10 = Number.parseInt(t10, 10);
  if (!Number.isNaN(n10) && /^-?\d+$/.test(t10.trim()))
    return n10;
  let r10 = t10.trim();
  if (!r10)
    return 0;
  let s10 = new ce(), { expr: i10, pos: o10 } = Bt(s10, r10, 0);
  if (o10 < r10.length) {
    let a = r10.slice(o10).trim(), l = a.split(/\s+/)[0] || a;
    throw new $e(`syntax error in expression (error token is "${l}")`, "", "");
  }
  return await ne(e11, i10);
}
async function fc(e11, t10, n10 = /* @__PURE__ */ new Set()) {
  if (n10.has(t10))
    return 0;
  n10.add(t10);
  let r10 = await Lx(e11, t10);
  if (!r10)
    return 0;
  let s10 = Number.parseInt(r10, 10);
  if (!Number.isNaN(s10) && /^-?\d+$/.test(r10.trim()))
    return s10;
  let i10 = r10.trim();
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(i10))
    return await fc(e11, i10, n10);
  let o10 = new ce(), { expr: a, pos: l } = Bt(o10, i10, 0);
  if (l < i10.length) {
    let c = i10.slice(l).trim(), u = c.split(/\s+/)[0] || c;
    throw new $e(`${i10}: syntax error in expression (error token is "${u}")`);
  }
  return await ne(e11, a);
}
async function ro(e11, t10) {
  if (t10.startsWith("#")) {
    let f10 = t10.slice(1), p = f10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
    if (p) {
      let m = p[1], d = ae(e11, m);
      return String(d.length);
    }
    let h = e11.state.env.get(f10) || "";
    return String(h.length);
  }
  if (t10.startsWith("!")) {
    let f10 = t10.slice(1), p = e11.state.env.get(f10) || "";
    return e11.state.env.get(p) || "";
  }
  let n10 = [":-", ":=", ":?", ":+", "-", "=", "?", "+"], r10 = -1, s10 = "";
  for (let f10 of n10) {
    let p = t10.indexOf(f10);
    p > 0 && (r10 === -1 || p < r10) && (r10 = p, s10 = f10);
  }
  if (r10 === -1)
    return await Se(e11, t10);
  let i10 = t10.slice(0, r10), o10 = t10.slice(r10 + s10.length), a = e11.state.env.get(i10), l = a === void 0, c = a === "", u = s10.startsWith(":");
  switch (s10) {
    case ":-":
    case "-":
      return l || u && c ? o10 : a || "";
    case ":=":
    case "=":
      return l || u && c ? (e11.state.env.set(i10, o10), o10) : a || "";
    case ":+":
    case "+":
      return !(l || u && c) ? o10 : "";
    case ":?":
    case "?": {
      if (l || u && c)
        throw new Error(o10 || `${i10}: parameter null or not set`);
      return a || "";
    }
    default:
      return a || "";
  }
}
async function ne(e11, t10, n10 = false) {
  switch (t10.type) {
    case "ArithNumber":
      if (Number.isNaN(t10.value))
        throw new $e("value too great for base");
      return t10.value;
    case "ArithVariable":
      return await fc(e11, t10.name);
    case "ArithSpecialVar": {
      let s10 = (await Se(e11, t10.name)).trim();
      if (!s10)
        return 0;
      let i10 = Number.parseInt(s10, 10);
      if (!Number.isNaN(i10) && /^-?\d+$/.test(s10))
        return i10;
      let o10 = new ce(), { expr: a } = Bt(o10, s10, 0);
      return await ne(e11, a);
    }
    case "ArithNested":
      return await ne(e11, t10.expression);
    case "ArithCommandSubst": {
      if (e11.execFn) {
        let r10 = await e11.execFn(t10.command);
        r10.stderr && (e11.state.expansionStderr = (e11.state.expansionStderr || "") + r10.stderr);
        let s10 = r10.stdout.trim();
        return Number.parseInt(s10, 10) || 0;
      }
      return 0;
    }
    case "ArithBracedExpansion": {
      let r10 = await ro(e11, t10.content);
      return Number.parseInt(r10, 10) || 0;
    }
    case "ArithDynamicBase": {
      let r10 = await ro(e11, t10.baseExpr), s10 = Number.parseInt(r10, 10);
      if (s10 < 2 || s10 > 64)
        return 0;
      let i10 = `${s10}#${t10.value}`;
      return ws(i10);
    }
    case "ArithDynamicNumber": {
      let s10 = await ro(e11, t10.prefix) + t10.suffix;
      return ws(s10);
    }
    case "ArithArrayElement": {
      let r10 = e11.state.associativeArrays?.has(t10.array), s10 = async (i10) => {
        let o10 = e11.state.env.get(i10);
        return o10 !== void 0 ? await uc(e11, o10) : 0;
      };
      if (t10.stringKey !== void 0)
        return await s10(`${t10.array}_${t10.stringKey}`);
      if (r10 && t10.index?.type === "ArithVariable" && !t10.index.hasDollarPrefix)
        return await s10(`${t10.array}_${t10.index.name}`);
      if (r10 && t10.index?.type === "ArithVariable" && t10.index.hasDollarPrefix) {
        let i10 = await Se(e11, t10.index.name);
        return await s10(`${t10.array}_${i10}`);
      }
      if (t10.index) {
        let i10 = await ne(e11, t10.index, n10);
        if (i10 < 0) {
          let l = ae(e11, t10.array), c = e11.state.currentLine;
          if (l.length === 0)
            return e11.state.expansionStderr = (e11.state.expansionStderr || "") + `bash: line ${c}: ${t10.array}: bad array subscript
`, 0;
          let f10 = Math.max(...l.map(([p]) => typeof p == "number" ? p : 0)) + 1 + i10;
          if (f10 < 0)
            return e11.state.expansionStderr = (e11.state.expansionStderr || "") + `bash: line ${c}: ${t10.array}: bad array subscript
`, 0;
          i10 = f10;
        }
        let o10 = `${t10.array}_${i10}`, a = e11.state.env.get(o10);
        if (a !== void 0)
          return uc(e11, a);
        if (i10 === 0) {
          let l = e11.state.env.get(t10.array);
          if (l !== void 0)
            return uc(e11, l);
        }
        if (e11.state.options.nounset && !Array.from(e11.state.env.keys()).some((c) => c === t10.array || c.startsWith(`${t10.array}_`)))
          throw new yt(`${t10.array}[${i10}]`);
        return 0;
      }
      return 0;
    }
    case "ArithDoubleSubscript":
      throw new $e("double subscript", "", "");
    case "ArithNumberSubscript":
      throw new $e(`${t10.number}${t10.errorToken}: syntax error: invalid arithmetic operator (error token is "${t10.errorToken}")`);
    case "ArithSyntaxError":
      throw new $e(t10.message, "", "", true);
    case "ArithSingleQuote": {
      if (n10)
        throw new $e(`syntax error: operand expected (error token is "'${t10.content}'")`);
      return t10.value;
    }
    case "ArithBinary": {
      if (t10.operator === "||")
        return await ne(e11, t10.left, n10) || await ne(e11, t10.right, n10) ? 1 : 0;
      if (t10.operator === "&&")
        return await ne(e11, t10.left, n10) && await ne(e11, t10.right, n10) ? 1 : 0;
      let r10 = await ne(e11, t10.left, n10), s10 = await ne(e11, t10.right, n10);
      return Dx(r10, s10, t10.operator);
    }
    case "ArithUnary": {
      let r10 = await ne(e11, t10.operand, n10);
      if (t10.operator === "++" || t10.operator === "--") {
        if (t10.operand.type === "ArithVariable") {
          let s10 = t10.operand.name, i10 = Number.parseInt(await Se(e11, s10), 10) || 0, o10 = t10.operator === "++" ? i10 + 1 : i10 - 1;
          return e11.state.env.set(s10, String(o10)), t10.prefix ? o10 : i10;
        }
        if (t10.operand.type === "ArithArrayElement") {
          let s10 = t10.operand.array, i10 = e11.state.associativeArrays?.has(s10), o10;
          if (t10.operand.stringKey !== void 0)
            o10 = `${s10}_${t10.operand.stringKey}`;
          else if (i10 && t10.operand.index?.type === "ArithVariable" && !t10.operand.index.hasDollarPrefix)
            o10 = `${s10}_${t10.operand.index.name}`;
          else if (i10 && t10.operand.index?.type === "ArithVariable" && t10.operand.index.hasDollarPrefix) {
            let c = await Se(e11, t10.operand.index.name);
            o10 = `${s10}_${c}`;
          } else if (t10.operand.index) {
            let c = await ne(e11, t10.operand.index, n10);
            o10 = `${s10}_${c}`;
          } else
            return r10;
          let a = Number.parseInt(e11.state.env.get(o10) || "0", 10) || 0, l = t10.operator === "++" ? a + 1 : a - 1;
          return e11.state.env.set(o10, String(l)), t10.prefix ? l : a;
        }
        if (t10.operand.type === "ArithConcat") {
          let s10 = "";
          for (let i10 of t10.operand.parts)
            s10 += await Ur(e11, i10, n10);
          if (s10 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s10)) {
            let i10 = Number.parseInt(e11.state.env.get(s10) || "0", 10) || 0, o10 = t10.operator === "++" ? i10 + 1 : i10 - 1;
            return e11.state.env.set(s10, String(o10)), t10.prefix ? o10 : i10;
          }
        }
        if (t10.operand.type === "ArithDynamicElement") {
          let s10 = "";
          if (t10.operand.nameExpr.type === "ArithConcat")
            for (let i10 of t10.operand.nameExpr.parts)
              s10 += await Ur(e11, i10, n10);
          else
            t10.operand.nameExpr.type === "ArithVariable" && (s10 = t10.operand.nameExpr.hasDollarPrefix ? await Se(e11, t10.operand.nameExpr.name) : t10.operand.nameExpr.name);
          if (s10 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s10)) {
            let i10 = await ne(e11, t10.operand.subscript, n10), o10 = `${s10}_${i10}`, a = Number.parseInt(e11.state.env.get(o10) || "0", 10) || 0, l = t10.operator === "++" ? a + 1 : a - 1;
            return e11.state.env.set(o10, String(l)), t10.prefix ? l : a;
          }
        }
        return r10;
      }
      return _x(r10, t10.operator);
    }
    case "ArithTernary":
      return await ne(e11, t10.condition, n10) ? await ne(e11, t10.consequent, n10) : await ne(e11, t10.alternate, n10);
    case "ArithAssignment": {
      let r10 = t10.variable, s10 = r10;
      if (t10.stringKey !== void 0)
        s10 = `${r10}_${t10.stringKey}`;
      else if (t10.subscript) {
        let l = e11.state.associativeArrays?.has(r10);
        if (l && t10.subscript.type === "ArithVariable" && !t10.subscript.hasDollarPrefix)
          s10 = `${r10}_${t10.subscript.name}`;
        else if (l && t10.subscript.type === "ArithVariable" && t10.subscript.hasDollarPrefix) {
          let c = await Se(e11, t10.subscript.name);
          s10 = `${r10}_${c || "\\"}`;
        } else if (l) {
          let c = await ne(e11, t10.subscript, n10);
          s10 = `${r10}_${c}`;
        } else {
          let c = await ne(e11, t10.subscript, n10);
          if (c < 0) {
            let u = ae(e11, r10);
            u.length > 0 && (c = Math.max(...u.map(([p]) => typeof p == "number" ? p : 0)) + 1 + c);
          }
          s10 = `${r10}_${c}`;
        }
      }
      let i10 = Number.parseInt(e11.state.env.get(s10) || "0", 10) || 0, o10 = await ne(e11, t10.value, n10), a = u6(i10, o10, t10.operator);
      return e11.state.env.set(s10, String(a)), a;
    }
    case "ArithGroup":
      return await ne(e11, t10.expression, n10);
    case "ArithConcat": {
      let r10 = "";
      for (let s10 of t10.parts)
        r10 += await Ur(e11, s10, n10);
      return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r10) ? await fc(e11, r10) : Number.parseInt(r10, 10) || 0;
    }
    case "ArithDynamicAssignment": {
      let r10 = "";
      if (t10.target.type === "ArithConcat")
        for (let l of t10.target.parts)
          r10 += await Ur(e11, l, n10);
      else
        t10.target.type === "ArithVariable" && (r10 = t10.target.hasDollarPrefix ? await Se(e11, t10.target.name) : t10.target.name);
      if (!r10 || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r10))
        return 0;
      let s10 = r10;
      if (t10.subscript) {
        let l = await ne(e11, t10.subscript, n10);
        s10 = `${r10}_${l}`;
      }
      let i10 = Number.parseInt(e11.state.env.get(s10) || "0", 10) || 0, o10 = await ne(e11, t10.value, n10), a = u6(i10, o10, t10.operator);
      return e11.state.env.set(s10, String(a)), a;
    }
    case "ArithDynamicElement": {
      let r10 = "";
      if (t10.nameExpr.type === "ArithConcat")
        for (let a of t10.nameExpr.parts)
          r10 += await Ur(e11, a, n10);
      else
        t10.nameExpr.type === "ArithVariable" && (r10 = t10.nameExpr.hasDollarPrefix ? await Se(e11, t10.nameExpr.name) : t10.nameExpr.name);
      if (!r10 || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r10))
        return 0;
      let s10 = await ne(e11, t10.subscript, n10), i10 = `${r10}_${s10}`, o10 = e11.state.env.get(i10);
      return o10 !== void 0 ? Fx(o10) : 0;
    }
    default:
      return 0;
  }
}
async function Ur(e11, t10, n10 = false) {
  switch (t10.type) {
    case "ArithNumber":
      return String(t10.value);
    case "ArithSingleQuote":
      return String(await ne(e11, t10, n10));
    case "ArithVariable":
      return t10.hasDollarPrefix ? await Se(e11, t10.name) : t10.name;
    case "ArithSpecialVar":
      return await Se(e11, t10.name);
    case "ArithBracedExpansion":
      return await ro(e11, t10.content);
    case "ArithCommandSubst":
      return e11.execFn ? (await e11.execFn(t10.command)).stdout.trim() : "0";
    case "ArithConcat": {
      let r10 = "";
      for (let s10 of t10.parts)
        r10 += await Ur(e11, s10, n10);
      return r10;
    }
    default:
      return String(await ne(e11, t10, n10));
  }
}
var St = I(() => {
  "use strict";
  dt();
  Ke();
  ye();
  Ct();
});
var ml = [{ name: "echo", load: async () => (await Promise.resolve().then(() => (uu(), cu))).echoCommand }, { name: "cat", load: async () => (await Promise.resolve().then(() => (pu(), fu))).catCommand }, { name: "printf", load: async () => (await Promise.resolve().then(() => (Eu(), xu))).printfCommand }, { name: "ls", load: async () => (await Promise.resolve().then(() => (Nu(), Cu))).lsCommand }, { name: "mkdir", load: async () => (await Promise.resolve().then(() => (vu(), ku))).mkdirCommand }, { name: "rmdir", load: async () => (await Promise.resolve().then(() => ($u(), Ru))).rmdirCommand }, { name: "touch", load: async () => (await Promise.resolve().then(() => (Pu(), Tu))).touchCommand }, { name: "rm", load: async () => (await Promise.resolve().then(() => (_u(), Du))).rmCommand }, { name: "cp", load: async () => (await Promise.resolve().then(() => (Fu(), Lu))).cpCommand }, { name: "mv", load: async () => (await Promise.resolve().then(() => (Uu(), Mu))).mvCommand }, { name: "ln", load: async () => (await Promise.resolve().then(() => (Bu(), Wu))).lnCommand }, { name: "chmod", load: async () => (await Promise.resolve().then(() => (ju(), Hu))).chmodCommand }, { name: "pwd", load: async () => (await Promise.resolve().then(() => (Vu(), Gu))).pwdCommand }, { name: "readlink", load: async () => (await Promise.resolve().then(() => (Zu(), qu))).readlinkCommand }, { name: "head", load: async () => (await Promise.resolve().then(() => (Yu(), Xu))).headCommand }, { name: "tail", load: async () => (await Promise.resolve().then(() => (ef(), Ju))).tailCommand }, { name: "wc", load: async () => (await Promise.resolve().then(() => (rf(), nf))).wcCommand }, { name: "stat", load: async () => (await Promise.resolve().then(() => (af(), of))).statCommand }, { name: "grep", load: async () => (await Promise.resolve().then(() => (Ks(), Qs))).grepCommand }, { name: "fgrep", load: async () => (await Promise.resolve().then(() => (Ks(), Qs))).fgrepCommand }, { name: "egrep", load: async () => (await Promise.resolve().then(() => (Ks(), Qs))).egrepCommand }, { name: "rg", load: async () => (await Promise.resolve().then(() => (Xf(), Kf))).rgCommand }, { name: "sed", load: async () => (await Promise.resolve().then(() => (l1(), a1))).sedCommand }, { name: "awk", load: async () => (await Promise.resolve().then(() => (W1(), U1))).awkCommand2 }, { name: "sort", load: async () => (await Promise.resolve().then(() => (K1(), Q1))).sortCommand }, { name: "uniq", load: async () => (await Promise.resolve().then(() => (Y1(), X1))).uniqCommand }, { name: "comm", load: async () => (await Promise.resolve().then(() => (ep(), J1))).commCommand }, { name: "cut", load: async () => (await Promise.resolve().then(() => (np(), tp))).cutCommand }, { name: "paste", load: async () => (await Promise.resolve().then(() => (ip(), sp))).pasteCommand }, { name: "tr", load: async () => (await Promise.resolve().then(() => (lp(), ap))).trCommand }, { name: "rev", load: async () => (await Promise.resolve().then(() => (up(), cp))).rev }, { name: "nl", load: async () => (await Promise.resolve().then(() => (hp(), pp2))).nl }, { name: "fold", load: async () => (await Promise.resolve().then(() => (gp(), mp))).fold }, { name: "expand", load: async () => (await Promise.resolve().then(() => (bp(), wp))).expand }, { name: "unexpand", load: async () => (await Promise.resolve().then(() => (Sp(), Ap))).unexpand }, { name: "strings", load: async () => (await Promise.resolve().then(() => (vp(), kp))).strings }, { name: "split", load: async () => (await Promise.resolve().then(() => (Rp(), Op))).split }, { name: "column", load: async () => (await Promise.resolve().then(() => (Pp(), Tp))).column }, { name: "join", load: async () => (await Promise.resolve().then(() => (_p(), Dp))).join }, { name: "tee", load: async () => (await Promise.resolve().then(() => (Fp(), Lp))).teeCommand }, { name: "find", load: async () => (await Promise.resolve().then(() => (Vp(), Gp))).findCommand }, { name: "basename", load: async () => (await Promise.resolve().then(() => (Zp(), qp))).basenameCommand }, { name: "dirname", load: async () => (await Promise.resolve().then(() => (Kp(), Qp))).dirnameCommand }, { name: "tree", load: async () => (await Promise.resolve().then(() => (Jp(), Yp))).treeCommand }, { name: "du", load: async () => (await Promise.resolve().then(() => (nh(), th))).duCommand }, { name: "env", load: async () => (await Promise.resolve().then(() => (va(), ka))).envCommand }, { name: "printenv", load: async () => (await Promise.resolve().then(() => (va(), ka))).printenvCommand }, { name: "alias", load: async () => (await Promise.resolve().then(() => (Oa(), Ia))).aliasCommand }, { name: "unalias", load: async () => (await Promise.resolve().then(() => (Oa(), Ia))).unaliasCommand }, { name: "history", load: async () => (await Promise.resolve().then(() => (ih(), sh))).historyCommand }, { name: "xargs", load: async () => (await Promise.resolve().then(() => (ah(), oh))).xargsCommand }, { name: "true", load: async () => (await Promise.resolve().then(() => ($a(), Ra))).trueCommand }, { name: "false", load: async () => (await Promise.resolve().then(() => ($a(), Ra))).falseCommand }, { name: "clear", load: async () => (await Promise.resolve().then(() => (ch(), lh))).clearCommand }, { name: "bash", load: async () => (await Promise.resolve().then(() => (Pa(), Ta))).bashCommand }, { name: "sh", load: async () => (await Promise.resolve().then(() => (Pa(), Ta))).shCommand }, { name: "jq", load: async () => (await Promise.resolve().then(() => (Mh(), Fh))).jqCommand }, { name: "base64", load: async () => (await Promise.resolve().then(() => (Bh(), Wh))).base64Command }, { name: "diff", load: async () => (await Promise.resolve().then(() => (jh(), Hh))).diffCommand }, { name: "date", load: async () => (await Promise.resolve().then(() => (Vh(), Gh))).dateCommand }, { name: "sleep", load: async () => (await Promise.resolve().then(() => (Zh(), qh))).sleepCommand }, { name: "timeout", load: async () => (await Promise.resolve().then(() => (Kh(), Qh))).timeoutCommand }, { name: "time", load: async () => (await Promise.resolve().then(() => (Yh(), Xh))).timeCommand }, { name: "seq", load: async () => (await Promise.resolve().then(() => (ed(), Jh))).seqCommand }, { name: "expr", load: async () => (await Promise.resolve().then(() => (nd(), td))).exprCommand }, { name: "md5sum", load: async () => (await Promise.resolve().then(() => (id(), sd))).md5sumCommand }, { name: "sha1sum", load: async () => (await Promise.resolve().then(() => (ad(), od))).sha1sumCommand }, { name: "sha256sum", load: async () => (await Promise.resolve().then(() => (cd(), ld))).sha256sumCommand }, { name: "file", load: async () => (await Promise.resolve().then(() => (e0(), Jd))).fileCommand }, { name: "html-to-markdown", load: async () => (await Promise.resolve().then(() => (n0(), t0))).htmlToMarkdownCommand }, { name: "help", load: async () => (await Promise.resolve().then(() => (s0(), r0))).helpCommand }, { name: "which", load: async () => (await Promise.resolve().then(() => (o0(), i0))).whichCommand }, { name: "tac", load: async () => (await Promise.resolve().then(() => (l0(), a0))).tac }, { name: "hostname", load: async () => (await Promise.resolve().then(() => (u0(), c0))).hostname }, { name: "whoami", load: async () => (await Promise.resolve().then(() => (p0(), f0))).whoami }, { name: "od", load: async () => (await Promise.resolve().then(() => (d0(), h0))).od }, { name: "gzip", load: async () => (await Promise.resolve().then(() => (_i(), Di))).gzipCommand }, { name: "gunzip", load: async () => (await Promise.resolve().then(() => (_i(), Di))).gunzipCommand }, { name: "zcat", load: async () => (await Promise.resolve().then(() => (_i(), Di))).zcatCommand }];
var ib = [];
var R0 = [{ name: "curl", load: async () => (await Promise.resolve().then(() => (I0(), v0))).curlCommand }];
var O0 = /* @__PURE__ */ new Map();
function gl(e11) {
  return { name: e11.name, async execute(t10, n10) {
    let r10 = O0.get(e11.name);
    return r10 || (r10 = await e11.load(), O0.set(e11.name, r10)), n10.coverage, r10.execute(t10, n10);
  } };
}
function $0(e11) {
  return (e11 ? ml.filter((n10) => e11.includes(n10.name)) : ml).map(gl);
}
function T0() {
  return R0.map(gl);
}
function P0() {
  return ib.map(gl);
}
function D0(e11) {
  return "load" in e11 && typeof e11.load == "function";
}
function lb(e11, t10) {
  return { name: e11, execute: t10 };
}
function _0(e11) {
  let t10 = null;
  return { name: e11.name, async execute(n10, r10) {
    return t10 || (t10 = await e11.load()), t10.execute(n10, r10);
  } };
}
var cb = new TextEncoder();
var ub = new TextDecoder();
function yl(e11, t10) {
  if (e11 instanceof Uint8Array)
    return e11;
  if (t10 === "base64")
    return Uint8Array.from(atob(e11), (n10) => n10.charCodeAt(0));
  if (t10 === "hex") {
    let n10 = new Uint8Array(e11.length / 2);
    for (let r10 = 0; r10 < e11.length; r10 += 2)
      n10[r10 / 2] = parseInt(e11.slice(r10, r10 + 2), 16);
    return n10;
  }
  if (t10 === "binary" || t10 === "latin1") {
    if (e11.length <= 65536)
      return Uint8Array.from(e11, (s10) => s10.charCodeAt(0));
    let r10 = new Uint8Array(e11.length);
    for (let s10 = 0; s10 < e11.length; s10++)
      r10[s10] = e11.charCodeAt(s10);
    return r10;
  }
  return cb.encode(e11);
}
function L0(e11, t10) {
  if (t10 === "base64")
    return btoa(String.fromCharCode(...e11));
  if (t10 === "hex")
    return Array.from(e11).map((n10) => n10.toString(16).padStart(2, "0")).join("");
  if (t10 === "binary" || t10 === "latin1") {
    if (typeof Buffer < "u")
      return Buffer.from(e11).toString(t10);
    let n10 = 65536;
    if (e11.length <= n10)
      return String.fromCharCode(...e11);
    let r10 = "";
    for (let s10 = 0; s10 < e11.length; s10 += n10) {
      let i10 = e11.subarray(s10, s10 + n10);
      r10 += String.fromCharCode(...i10);
    }
    return r10;
  }
  return ub.decode(e11);
}
function Li(e11) {
  if (e11 != null)
    return typeof e11 == "string" ? e11 : e11.encoding ?? void 0;
}
var Fi = new TextEncoder();
function fb(e11) {
  return typeof e11 == "object" && e11 !== null && !(e11 instanceof Uint8Array) && "content" in e11;
}
function ct(e11, t10) {
  if (e11.includes("\0"))
    throw new Error(`ENOENT: path contains null byte, ${t10} '${e11}'`);
}
var Jn = class {
  data = /* @__PURE__ */ new Map();
  constructor(t10) {
    if (this.data.set("/", { type: "directory", mode: 493, mtime: /* @__PURE__ */ new Date() }), t10)
      for (let [n10, r10] of Object.entries(t10))
        fb(r10) ? this.writeFileSync(n10, r10.content, void 0, { mode: r10.mode, mtime: r10.mtime }) : this.writeFileSync(n10, r10);
  }
  normalizePath(t10) {
    if (!t10 || t10 === "/")
      return "/";
    let n10 = t10.endsWith("/") && t10 !== "/" ? t10.slice(0, -1) : t10;
    n10.startsWith("/") || (n10 = `/${n10}`);
    let r10 = n10.split("/").filter((i10) => i10 && i10 !== "."), s10 = [];
    for (let i10 of r10)
      i10 === ".." ? s10.pop() : s10.push(i10);
    return `/${s10.join("/")}` || "/";
  }
  dirname(t10) {
    let n10 = this.normalizePath(t10);
    if (n10 === "/")
      return "/";
    let r10 = n10.lastIndexOf("/");
    return r10 === 0 ? "/" : n10.slice(0, r10);
  }
  ensureParentDirs(t10) {
    let n10 = this.dirname(t10);
    n10 !== "/" && (this.data.has(n10) || (this.ensureParentDirs(n10), this.data.set(n10, { type: "directory", mode: 493, mtime: /* @__PURE__ */ new Date() })));
  }
  writeFileSync(t10, n10, r10, s10) {
    ct(t10, "write");
    let i10 = this.normalizePath(t10);
    this.ensureParentDirs(i10);
    let o10 = Li(r10), a = yl(n10, o10);
    this.data.set(i10, { type: "file", content: a, mode: s10?.mode ?? 420, mtime: s10?.mtime ?? /* @__PURE__ */ new Date() });
  }
  async readFile(t10, n10) {
    let r10 = await this.readFileBuffer(t10), s10 = Li(n10);
    return L0(r10, s10);
  }
  async readFileBuffer(t10) {
    ct(t10, "open");
    let n10 = this.resolvePathWithSymlinks(t10), r10 = this.data.get(n10);
    if (!r10)
      throw new Error(`ENOENT: no such file or directory, open '${t10}'`);
    if (r10.type !== "file")
      throw new Error(`EISDIR: illegal operation on a directory, read '${t10}'`);
    return r10.content instanceof Uint8Array ? r10.content : Fi.encode(r10.content);
  }
  async writeFile(t10, n10, r10) {
    this.writeFileSync(t10, n10, r10);
  }
  async appendFile(t10, n10, r10) {
    ct(t10, "append");
    let s10 = this.normalizePath(t10), i10 = this.data.get(s10);
    if (i10 && i10.type === "directory")
      throw new Error(`EISDIR: illegal operation on a directory, write '${t10}'`);
    let o10 = Li(r10), a = yl(n10, o10);
    if (i10?.type === "file") {
      let l = i10.content instanceof Uint8Array ? i10.content : Fi.encode(i10.content), c = new Uint8Array(l.length + a.length);
      c.set(l), c.set(a, l.length), this.data.set(s10, { type: "file", content: c, mode: i10.mode, mtime: /* @__PURE__ */ new Date() });
    } else
      this.writeFileSync(t10, n10, r10);
  }
  async exists(t10) {
    if (t10.includes("\0"))
      return false;
    try {
      let n10 = this.resolvePathWithSymlinks(t10);
      return this.data.has(n10);
    } catch {
      return false;
    }
  }
  async stat(t10) {
    ct(t10, "stat");
    let n10 = this.resolvePathWithSymlinks(t10), r10 = this.data.get(n10);
    if (!r10)
      throw new Error(`ENOENT: no such file or directory, stat '${t10}'`);
    let s10 = 0;
    return r10.type === "file" && r10.content && (r10.content instanceof Uint8Array ? s10 = r10.content.length : s10 = Fi.encode(r10.content).length), { isFile: r10.type === "file", isDirectory: r10.type === "directory", isSymbolicLink: false, mode: r10.mode, size: s10, mtime: r10.mtime || /* @__PURE__ */ new Date() };
  }
  async lstat(t10) {
    ct(t10, "lstat");
    let n10 = this.resolveIntermediateSymlinks(t10), r10 = this.data.get(n10);
    if (!r10)
      throw new Error(`ENOENT: no such file or directory, lstat '${t10}'`);
    if (r10.type === "symlink")
      return { isFile: false, isDirectory: false, isSymbolicLink: true, mode: r10.mode, size: r10.target.length, mtime: r10.mtime || /* @__PURE__ */ new Date() };
    let s10 = 0;
    return r10.type === "file" && r10.content && (r10.content instanceof Uint8Array ? s10 = r10.content.length : s10 = Fi.encode(r10.content).length), { isFile: r10.type === "file", isDirectory: r10.type === "directory", isSymbolicLink: false, mode: r10.mode, size: s10, mtime: r10.mtime || /* @__PURE__ */ new Date() };
  }
  resolveSymlink(t10, n10) {
    if (n10.startsWith("/"))
      return this.normalizePath(n10);
    let r10 = this.dirname(t10);
    return this.normalizePath(r10 === "/" ? `/${n10}` : `${r10}/${n10}`);
  }
  resolveIntermediateSymlinks(t10) {
    let n10 = this.normalizePath(t10);
    if (n10 === "/")
      return "/";
    let r10 = n10.slice(1).split("/");
    if (r10.length <= 1)
      return n10;
    let s10 = "", i10 = /* @__PURE__ */ new Set();
    for (let o10 = 0; o10 < r10.length - 1; o10++) {
      let a = r10[o10];
      s10 = `${s10}/${a}`;
      let l = this.data.get(s10), c = 0, u = 40;
      for (; l && l.type === "symlink" && c < u; ) {
        if (i10.has(s10))
          throw new Error(`ELOOP: too many levels of symbolic links, lstat '${t10}'`);
        i10.add(s10), s10 = this.resolveSymlink(s10, l.target), l = this.data.get(s10), c++;
      }
      if (c >= u)
        throw new Error(`ELOOP: too many levels of symbolic links, lstat '${t10}'`);
    }
    return `${s10}/${r10[r10.length - 1]}`;
  }
  resolvePathWithSymlinks(t10) {
    let n10 = this.normalizePath(t10);
    if (n10 === "/")
      return "/";
    let r10 = n10.slice(1).split("/"), s10 = "", i10 = /* @__PURE__ */ new Set();
    for (let o10 of r10) {
      s10 = `${s10}/${o10}`;
      let a = this.data.get(s10), l = 0, c = 40;
      for (; a && a.type === "symlink" && l < c; ) {
        if (i10.has(s10))
          throw new Error(`ELOOP: too many levels of symbolic links, open '${t10}'`);
        i10.add(s10), s10 = this.resolveSymlink(s10, a.target), a = this.data.get(s10), l++;
      }
      if (l >= c)
        throw new Error(`ELOOP: too many levels of symbolic links, open '${t10}'`);
    }
    return s10;
  }
  async mkdir(t10, n10) {
    this.mkdirSync(t10, n10);
  }
  mkdirSync(t10, n10) {
    ct(t10, "mkdir");
    let r10 = this.normalizePath(t10);
    if (this.data.has(r10)) {
      if (this.data.get(r10)?.type === "file")
        throw new Error(`EEXIST: file already exists, mkdir '${t10}'`);
      if (!n10?.recursive)
        throw new Error(`EEXIST: directory already exists, mkdir '${t10}'`);
      return;
    }
    let s10 = this.dirname(r10);
    if (s10 !== "/" && !this.data.has(s10))
      if (n10?.recursive)
        this.mkdirSync(s10, { recursive: true });
      else
        throw new Error(`ENOENT: no such file or directory, mkdir '${t10}'`);
    this.data.set(r10, { type: "directory", mode: 493, mtime: /* @__PURE__ */ new Date() });
  }
  async readdir(t10) {
    return (await this.readdirWithFileTypes(t10)).map((r10) => r10.name);
  }
  async readdirWithFileTypes(t10) {
    ct(t10, "scandir");
    let n10 = this.normalizePath(t10), r10 = this.data.get(n10);
    if (!r10)
      throw new Error(`ENOENT: no such file or directory, scandir '${t10}'`);
    let s10 = /* @__PURE__ */ new Set();
    for (; r10 && r10.type === "symlink"; ) {
      if (s10.has(n10))
        throw new Error(`ELOOP: too many levels of symbolic links, scandir '${t10}'`);
      s10.add(n10), n10 = this.resolveSymlink(n10, r10.target), r10 = this.data.get(n10);
    }
    if (!r10)
      throw new Error(`ENOENT: no such file or directory, scandir '${t10}'`);
    if (r10.type !== "directory")
      throw new Error(`ENOTDIR: not a directory, scandir '${t10}'`);
    let i10 = n10 === "/" ? "/" : `${n10}/`, o10 = /* @__PURE__ */ new Map();
    for (let [a, l] of this.data.entries())
      if (a !== n10 && a.startsWith(i10)) {
        let c = a.slice(i10.length), u = c.split("/")[0];
        u && !c.includes("/", u.length) && !o10.has(u) && o10.set(u, { name: u, isFile: l.type === "file", isDirectory: l.type === "directory", isSymbolicLink: l.type === "symlink" });
      }
    return Array.from(o10.values()).sort((a, l) => a.name < l.name ? -1 : a.name > l.name ? 1 : 0);
  }
  async rm(t10, n10) {
    ct(t10, "rm");
    let r10 = this.normalizePath(t10), s10 = this.data.get(r10);
    if (!s10) {
      if (n10?.force)
        return;
      throw new Error(`ENOENT: no such file or directory, rm '${t10}'`);
    }
    if (s10.type === "directory") {
      let i10 = await this.readdir(r10);
      if (i10.length > 0) {
        if (!n10?.recursive)
          throw new Error(`ENOTEMPTY: directory not empty, rm '${t10}'`);
        for (let o10 of i10) {
          let a = r10 === "/" ? `/${o10}` : `${r10}/${o10}`;
          await this.rm(a, n10);
        }
      }
    }
    this.data.delete(r10);
  }
  async cp(t10, n10, r10) {
    ct(t10, "cp"), ct(n10, "cp");
    let s10 = this.normalizePath(t10), i10 = this.normalizePath(n10), o10 = this.data.get(s10);
    if (!o10)
      throw new Error(`ENOENT: no such file or directory, cp '${t10}'`);
    if (o10.type === "file")
      this.ensureParentDirs(i10), this.data.set(i10, { ...o10 });
    else if (o10.type === "directory") {
      if (!r10?.recursive)
        throw new Error(`EISDIR: is a directory, cp '${t10}'`);
      await this.mkdir(i10, { recursive: true });
      let a = await this.readdir(s10);
      for (let l of a) {
        let c = s10 === "/" ? `/${l}` : `${s10}/${l}`, u = i10 === "/" ? `/${l}` : `${i10}/${l}`;
        await this.cp(c, u, r10);
      }
    }
  }
  async mv(t10, n10) {
    await this.cp(t10, n10, { recursive: true }), await this.rm(t10, { recursive: true });
  }
  getAllPaths() {
    return Array.from(this.data.keys());
  }
  resolvePath(t10, n10) {
    if (n10.startsWith("/"))
      return this.normalizePath(n10);
    let r10 = t10 === "/" ? `/${n10}` : `${t10}/${n10}`;
    return this.normalizePath(r10);
  }
  async chmod(t10, n10) {
    ct(t10, "chmod");
    let r10 = this.normalizePath(t10), s10 = this.data.get(r10);
    if (!s10)
      throw new Error(`ENOENT: no such file or directory, chmod '${t10}'`);
    s10.mode = n10;
  }
  async symlink(t10, n10) {
    ct(n10, "symlink");
    let r10 = this.normalizePath(n10);
    if (this.data.has(r10))
      throw new Error(`EEXIST: file already exists, symlink '${n10}'`);
    this.ensureParentDirs(r10), this.data.set(r10, { type: "symlink", target: t10, mode: 511, mtime: /* @__PURE__ */ new Date() });
  }
  async link(t10, n10) {
    ct(t10, "link"), ct(n10, "link");
    let r10 = this.normalizePath(t10), s10 = this.normalizePath(n10), i10 = this.data.get(r10);
    if (!i10)
      throw new Error(`ENOENT: no such file or directory, link '${t10}'`);
    if (i10.type !== "file")
      throw new Error(`EPERM: operation not permitted, link '${t10}'`);
    if (this.data.has(s10))
      throw new Error(`EEXIST: file already exists, link '${n10}'`);
    this.ensureParentDirs(s10), this.data.set(s10, { type: "file", content: i10.content, mode: i10.mode, mtime: i10.mtime });
  }
  async readlink(t10) {
    ct(t10, "readlink");
    let n10 = this.normalizePath(t10), r10 = this.data.get(n10);
    if (!r10)
      throw new Error(`ENOENT: no such file or directory, readlink '${t10}'`);
    if (r10.type !== "symlink")
      throw new Error(`EINVAL: invalid argument, readlink '${t10}'`);
    return r10.target;
  }
  async realpath(t10) {
    ct(t10, "realpath");
    let n10 = this.resolvePathWithSymlinks(t10);
    if (!this.data.has(n10))
      throw new Error(`ENOENT: no such file or directory, realpath '${t10}'`);
    return n10;
  }
  async utimes(t10, n10, r10) {
    ct(t10, "utimes");
    let s10 = this.normalizePath(t10), i10 = this.resolvePathWithSymlinks(s10), o10 = this.data.get(i10);
    if (!o10)
      throw new Error(`ENOENT: no such file or directory, utimes '${t10}'`);
    o10.mtime = r10;
  }
};
wl();
function pb(e11) {
  let t10 = e11;
  return typeof t10.mkdirSync == "function" && typeof t10.writeFileSync == "function";
}
function hb(e11, t10) {
  e11.mkdirSync("/bin", { recursive: true }), e11.mkdirSync("/usr/bin", { recursive: true }), t10 && (e11.mkdirSync("/home/user", { recursive: true }), e11.mkdirSync("/tmp", { recursive: true }));
}
function db(e11) {
  e11.mkdirSync("/dev", { recursive: true }), e11.writeFileSync("/dev/null", ""), e11.writeFileSync("/dev/zero", new Uint8Array(0)), e11.writeFileSync("/dev/stdin", ""), e11.writeFileSync("/dev/stdout", ""), e11.writeFileSync("/dev/stderr", "");
}
function mb(e11) {
  e11.mkdirSync("/proc/self/fd", { recursive: true }), e11.writeFileSync("/proc/version", `${M0}
`), e11.writeFileSync("/proc/self/exe", "/bin/bash"), e11.writeFileSync("/proc/self/cmdline", "bash\0"), e11.writeFileSync("/proc/self/comm", `bash
`), e11.writeFileSync("/proc/self/status", U0()), e11.writeFileSync("/proc/self/fd/0", "/dev/stdin"), e11.writeFileSync("/proc/self/fd/1", "/dev/stdout"), e11.writeFileSync("/proc/self/fd/2", "/dev/stderr");
}
function W0(e11, t10) {
  pb(e11) && (hb(e11, t10), db(e11), mb(e11));
}
On();
ye();
var gb = ["allexport", "errexit", "noglob", "noclobber", "noexec", "nounset", "pipefail", "posix", "verbose", "xtrace"];
var yb = ["braceexpand", "hashall", "interactive-comments"];
function bl(e11) {
  let t10 = [], n10 = [...yb.map((r10) => ({ name: r10, enabled: true })), ...gb.map((r10) => ({ name: r10, enabled: e11[r10] }))].sort((r10, s10) => r10.name.localeCompare(s10.name));
  for (let r10 of n10)
    r10.enabled && t10.push(r10.name);
  return t10.join(":");
}
function Tr(e11) {
  e11.state.env.set("SHELLOPTS", bl(e11.state.options));
}
var wb = ["dotglob", "expand_aliases", "extglob", "failglob", "globskipdots", "globstar", "lastpipe", "nocaseglob", "nocasematch", "nullglob", "xpg_echo"];
function xl(e11) {
  let t10 = [];
  for (let n10 of wb)
    e11[n10] && t10.push(n10);
  return t10.join(":");
}
function El(e11) {
  e11.state.env.set("BASHOPTS", xl(e11.state.shoptOptions));
}
On();
er();
Ke();
er();
var Zb = "BASH_ALIAS_";
function Rm(e11) {
  return e11.parts.length !== 1 ? false : e11.parts[0].type === "Literal";
}
function $m(e11) {
  if (e11.parts.length !== 1)
    return null;
  let t10 = e11.parts[0];
  return t10.type === "Literal" ? t10.value : null;
}
function Tm(e11, t10) {
  return e11.env.get(`${Zb}${t10}`);
}
function Hl(e11, t10, n10) {
  if (!t10.name || !Rm(t10.name))
    return t10;
  let r10 = $m(t10.name);
  if (!r10)
    return t10;
  let s10 = Tm(e11, r10);
  if (!s10 || n10.has(r10))
    return t10;
  try {
    n10.add(r10);
    let i10 = new ce(), o10 = s10, a = s10.endsWith(" ");
    if (!a)
      for (let f10 of t10.args) {
        let p = Dm(f10);
        o10 += ` ${p}`;
      }
    let l;
    try {
      l = i10.parse(o10);
    } catch (f10) {
      if (f10 instanceof ot)
        throw f10;
      return t10;
    }
    if (l.statements.length !== 1 || l.statements[0].pipelines.length !== 1 || l.statements[0].pipelines[0].commands.length !== 1)
      return Pm(t10, s10);
    let c = l.statements[0].pipelines[0].commands[0];
    if (c.type !== "SimpleCommand")
      return Pm(t10, s10);
    let u = { ...c, assignments: [...t10.assignments, ...c.assignments], redirections: [...c.redirections, ...t10.redirections], line: t10.line };
    if (a && t10.args.length > 0 && (u = { ...u, args: [...u.args, ...t10.args] }, u.args.length > 0)) {
      let f10 = u.args[0];
      if (Rm(f10)) {
        let p = $m(f10);
        if (p && Tm(e11, p)) {
          let h = { type: "SimpleCommand", name: f10, args: u.args.slice(1), assignments: [], redirections: [] }, m = Hl(e11, h, n10);
          m !== h && (u = { ...u, name: m.name, args: [...m.args] });
        }
      }
    }
    return u;
  } catch (i10) {
    throw n10.delete(r10), i10;
  }
}
function Pm(e11, t10) {
  let n10 = t10;
  for (let o10 of e11.args) {
    let a = Dm(o10);
    n10 += ` ${a}`;
  }
  let r10 = new ce(), s10 = r10.parseWordFromString("eval", false, false), i10 = r10.parseWordFromString(`'${n10.replace(/'/g, "'\\''")}'`, false, false);
  return { type: "SimpleCommand", name: s10, args: [i10], assignments: e11.assignments, redirections: e11.redirections, line: e11.line };
}
function Dm(e11) {
  let t10 = "";
  for (let n10 of e11.parts)
    switch (n10.type) {
      case "Literal":
        t10 += n10.value.replace(/([\s"'$`\\*?[\]{}()<>|&;#!])/g, "\\$1");
        break;
      case "SingleQuoted":
        t10 += `'${n10.value}'`;
        break;
      case "DoubleQuoted":
        t10 += `"${n10.parts.map((r10) => r10.type === "Literal" ? r10.value : `$${r10.type}`).join("")}"`;
        break;
      case "ParameterExpansion":
        t10 += `\${${n10.parameter}}`;
        break;
      case "CommandSubstitution":
        t10 += "$(...)";
        break;
      case "ArithmeticExpansion":
        t10 += `$((${n10.expression}))`;
        break;
      case "Glob":
        t10 += n10.pattern;
        break;
      default:
        break;
    }
  return t10;
}
St();
Ct();
Qt();
async function f6(e11, t10) {
  let n10 = t10.parts.map((u) => u.type === "Literal" ? u.value : "\0").join(""), r10 = n10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\(/);
  if (!r10 || !n10.endsWith(")"))
    return null;
  let s10 = r10[1], i10 = [], o10 = false, a = "", l = false;
  for (let u of t10.parts)
    if (u.type === "Literal") {
      let f10 = u.value;
      if (!o10) {
        let p = f10.indexOf("=(");
        p !== -1 && (o10 = true, f10 = f10.slice(p + 2));
      }
      if (o10) {
        f10.endsWith(")") && (f10 = f10.slice(0, -1));
        let p = f10.split(/(\s+)/);
        for (let h of p)
          /^\s+$/.test(h) ? (a || l) && (i10.push(a), a = "", l = false) : h && (a += h);
      }
    } else if (o10)
      if (u.type === "BraceExpansion")
        if (/^\[.+\]=/.test(a))
          a += Pr({ type: "Word", parts: [u] });
        else {
          (a || l) && (i10.push(a), a = "", l = false);
          let p = await sn(e11, { type: "Word", parts: [u] });
          i10.push(...p.values);
        }
      else {
        (u.type === "SingleQuoted" || u.type === "DoubleQuoted" || u.type === "Escaped") && (l = true);
        let f10 = await ie(e11, { type: "Word", parts: [u] });
        a += f10;
      }
  (a || l) && i10.push(a);
  let c = i10.map((u) => /^\[.+\]=/.test(u) ? u : u === "" ? "''" : /[\s"'\\$`!*?[\]{}|&;<>()]/.test(u) && !u.startsWith("'") && !u.startsWith('"') ? `'${u.replace(/'/g, "'\\''")}'` : u);
  return `${s10}=(${c.join(" ")})`;
}
async function p6(e11, t10) {
  let n10 = -1, r10 = -1, s10 = false;
  for (let d = 0; d < t10.parts.length; d++) {
    let g = t10.parts[d];
    if (g.type === "Literal") {
      let y = g.value.indexOf("+=");
      if (y !== -1) {
        let b = g.value.slice(0, y);
        if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(b)) {
          n10 = d, r10 = y, s10 = true;
          break;
        }
        if (/^[a-zA-Z_][a-zA-Z0-9_]*\[[^\]]+\]$/.test(b)) {
          n10 = d, r10 = y, s10 = true;
          break;
        }
      }
      let w = g.value.indexOf("=");
      if (w !== -1 && (w === 0 || g.value[w - 1] !== "+")) {
        let b = g.value.slice(0, w);
        if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(b) || /^[a-zA-Z_][a-zA-Z0-9_]*\[[^\]]+\]$/.test(b)) {
          n10 = d, r10 = w;
          break;
        }
      }
    }
  }
  if (n10 === -1)
    return null;
  let i10 = t10.parts.slice(0, n10), o10 = t10.parts[n10];
  if (o10.type !== "Literal")
    return null;
  let a = s10 ? 2 : 1, l = o10.value.slice(0, r10), c = o10.value.slice(r10 + a), u = t10.parts.slice(n10 + 1), f10 = "";
  for (let d of i10)
    f10 += await ie(e11, { type: "Word", parts: [d] });
  f10 += l;
  let p = { type: "Word", parts: c !== "" ? [{ type: "Literal", value: c }, ...u] : u }, h = p.parts.length > 0 ? await ie(e11, p) : "";
  return `${f10}${s10 ? "+=" : "="}${h}`;
}
var Mx = ["tar", "yq", "xan", "sqlite3", "python3", "python"];
function h6(e11) {
  return Mx.includes(e11);
}
ye();
ye();
var de = Object.freeze({ stdout: "", stderr: "", exitCode: 0 });
function ge(e11 = "") {
  return { stdout: e11, stderr: "", exitCode: 0 };
}
function W(e11, t10 = 1) {
  return { stdout: "", stderr: e11, exitCode: t10 };
}
function B(e11, t10, n10) {
  return { stdout: e11, stderr: t10, exitCode: n10 };
}
function Ye(e11) {
  return { stdout: "", stderr: "", exitCode: e11 ? 0 : 1 };
}
function kn(e11, t10, n10 = "", r10 = "") {
  throw new te(e11, t10, n10, r10);
}
function pc(e11, t10) {
  if (e11.state.loopDepth === 0) {
    if (e11.state.parentHasLoopContext)
      throw new an();
    return de;
  }
  if (t10.length > 1)
    throw new pe(1, "", `bash: break: too many arguments
`);
  let n10 = 1;
  if (t10.length > 0) {
    let r10 = Number.parseInt(t10[0], 10);
    if (Number.isNaN(r10) || r10 < 1)
      throw new pe(128, "", `bash: break: ${t10[0]}: numeric argument required
`);
    n10 = r10;
  }
  throw new ft(n10);
}
async function hc(e11, t10) {
  let n10, r10 = false, s10 = false, i10 = 0;
  for (; i10 < t10.length; )
    if (t10[i10] === "--") {
      i10++;
      break;
    } else if (t10[i10] === "-L")
      s10 = false, i10++;
    else if (t10[i10] === "-P")
      s10 = true, i10++;
    else if (t10[i10].startsWith("-") && t10[i10] !== "-")
      i10++;
    else
      break;
  let o10 = t10.slice(i10);
  if (o10.length === 0 || o10[0] === "~" ? n10 = e11.state.env.get("HOME") || "/" : o10[0] === "-" ? (n10 = e11.state.previousDir, r10 = true) : n10 = o10[0], !n10.startsWith("/") && !n10.startsWith("./") && !n10.startsWith("../") && n10 !== "." && n10 !== "..") {
    let f10 = e11.state.env.get("CDPATH");
    if (f10) {
      let p = f10.split(":").filter((h) => h);
      for (let h of p) {
        let m = h.startsWith("/") ? `${h}/${n10}` : `${e11.state.cwd}/${h}/${n10}`;
        try {
          if ((await e11.fs.stat(m)).isDirectory) {
            n10 = m, r10 = true;
            break;
          }
        } catch {
        }
      }
    }
  }
  let l = (n10.startsWith("/") ? n10 : `${e11.state.cwd}/${n10}`).split("/").filter((f10) => f10 && f10 !== "."), c = "";
  for (let f10 of l)
    if (f10 === "..")
      c = c.split("/").slice(0, -1).join("/") || "/";
    else {
      c = c ? `${c}/${f10}` : `/${f10}`;
      try {
        if (!(await e11.fs.stat(c)).isDirectory)
          return W(`bash: cd: ${n10}: Not a directory
`);
      } catch {
        return W(`bash: cd: ${n10}: No such file or directory
`);
      }
    }
  let u = c || "/";
  if (s10)
    try {
      u = await e11.fs.realpath(u);
    } catch {
    }
  return e11.state.previousDir = e11.state.cwd, e11.state.cwd = u, e11.state.env.set("PWD", e11.state.cwd), e11.state.env.set("OLDPWD", e11.state.previousDir), ge(r10 ? `${u}
` : "");
}
Ke();
dt();
Ke();
Fe();
St();
Ct();
Qt();
function dc(e11, t10) {
  return e11.fs.resolvePath(e11.state.cwd, t10);
}
var Ux = ["-e", "-a", "-f", "-d", "-r", "-w", "-x", "-s", "-L", "-h", "-k", "-g", "-u", "-G", "-O", "-b", "-c", "-p", "-S", "-t", "-N"];
function so(e11) {
  return Ux.includes(e11);
}
async function io(e11, t10, n10) {
  let r10 = dc(e11, n10);
  switch (t10) {
    case "-e":
    case "-a":
      return e11.fs.exists(r10);
    case "-f":
      return await e11.fs.exists(r10) ? (await e11.fs.stat(r10)).isFile : false;
    case "-d":
      return await e11.fs.exists(r10) ? (await e11.fs.stat(r10)).isDirectory : false;
    case "-r":
      return await e11.fs.exists(r10) ? ((await e11.fs.stat(r10)).mode & 256) !== 0 : false;
    case "-w":
      return await e11.fs.exists(r10) ? ((await e11.fs.stat(r10)).mode & 128) !== 0 : false;
    case "-x":
      return await e11.fs.exists(r10) ? ((await e11.fs.stat(r10)).mode & 64) !== 0 : false;
    case "-s":
      return await e11.fs.exists(r10) ? (await e11.fs.stat(r10)).size > 0 : false;
    case "-L":
    case "-h":
      try {
        return (await e11.fs.lstat(r10)).isSymbolicLink;
      } catch {
        return false;
      }
    case "-k":
      return await e11.fs.exists(r10) ? ((await e11.fs.stat(r10)).mode & 512) !== 0 : false;
    case "-g":
      return await e11.fs.exists(r10) ? ((await e11.fs.stat(r10)).mode & 1024) !== 0 : false;
    case "-u":
      return await e11.fs.exists(r10) ? ((await e11.fs.stat(r10)).mode & 2048) !== 0 : false;
    case "-G":
    case "-O":
      return e11.fs.exists(r10);
    case "-b":
      return false;
    case "-c":
      return ["/dev/null", "/dev/zero", "/dev/random", "/dev/urandom", "/dev/tty", "/dev/stdin", "/dev/stdout", "/dev/stderr"].some((i10) => r10 === i10 || r10.endsWith(i10));
    case "-p":
      return false;
    case "-S":
      return false;
    case "-t":
      return false;
    case "-N":
      return e11.fs.exists(r10);
    default:
      return false;
  }
}
var Wx = ["-nt", "-ot", "-ef"];
function oo(e11) {
  return Wx.includes(e11);
}
async function ao(e11, t10, n10, r10) {
  let s10 = dc(e11, n10), i10 = dc(e11, r10);
  switch (t10) {
    case "-nt":
      try {
        let o10 = await e11.fs.stat(s10), a = await e11.fs.stat(i10);
        return o10.mtime > a.mtime;
      } catch {
        return false;
      }
    case "-ot":
      try {
        let o10 = await e11.fs.stat(s10), a = await e11.fs.stat(i10);
        return o10.mtime < a.mtime;
      } catch {
        return false;
      }
    case "-ef":
      try {
        if (!await e11.fs.exists(s10) || !await e11.fs.exists(i10))
          return false;
        let o10 = e11.fs.resolvePath(e11.state.cwd, s10), a = e11.fs.resolvePath(e11.state.cwd, i10);
        return o10 === a;
      } catch {
        return false;
      }
    default:
      return false;
  }
}
var Bx = /* @__PURE__ */ new Set(["-eq", "-ne", "-lt", "-le", "-gt", "-ge"]);
function lo(e11) {
  return Bx.has(e11);
}
function co(e11, t10, n10) {
  switch (e11) {
    case "-eq":
      return t10 === n10;
    case "-ne":
      return t10 !== n10;
    case "-lt":
      return t10 < n10;
    case "-le":
      return t10 <= n10;
    case "-gt":
      return t10 > n10;
    case "-ge":
      return t10 >= n10;
  }
}
function Ns(e11) {
  return e11 === "=" || e11 === "==" || e11 === "!=";
}
function uo(e11, t10, n10, r10 = false, s10 = false, i10 = false) {
  if (r10) {
    let a = Wr(t10, n10, s10, i10);
    return e11 === "!=" ? !a : a;
  }
  if (s10) {
    let a = t10.toLowerCase() === n10.toLowerCase();
    return e11 === "!=" ? !a : a;
  }
  let o10 = t10 === n10;
  return e11 === "!=" ? !o10 : o10;
}
var zx = /* @__PURE__ */ new Set(["-z", "-n"]);
function fo(e11) {
  return zx.has(e11);
}
function po(e11, t10) {
  switch (e11) {
    case "-z":
      return t10 === "";
    case "-n":
      return t10 !== "";
  }
}
dt();
Ke();
St();
Qt();
async function ho(e11, t10) {
  let n10 = t10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (n10) {
    let r10 = n10[1], s10 = n10[2];
    if (e11.state.associativeArrays?.has(r10)) {
      let a = s10;
      return (a.startsWith("'") && a.endsWith("'") || a.startsWith('"') && a.endsWith('"')) && (a = a.slice(1, -1)), a = a.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (l, c) => e11.state.env.get(c) || ""), e11.state.env.has(`${r10}_${a}`);
    }
    let o10;
    try {
      let a = new ce(), l = Ae(a, s10);
      o10 = await ne(e11, l.expression);
    } catch {
      if (/^-?\d+$/.test(s10))
        o10 = Number.parseInt(s10, 10);
      else {
        let a = e11.state.env.get(s10);
        o10 = a ? Number.parseInt(a, 10) : 0;
      }
    }
    if (o10 < 0) {
      let a = Xe(e11, r10), l = e11.state.currentLine;
      if (a.length === 0)
        return e11.state.expansionStderr = (e11.state.expansionStderr || "") + `bash: line ${l}: ${r10}: bad array subscript
`, false;
      if (o10 = Math.max(...a) + 1 + o10, o10 < 0)
        return e11.state.expansionStderr = (e11.state.expansionStderr || "") + `bash: line ${l}: ${r10}: bad array subscript
`, false;
    }
    return e11.state.env.has(`${r10}_${o10}`);
  }
  return e11.state.env.has(t10) ? true : e11.state.associativeArrays?.has(t10) ? en(e11, t10).length > 0 : Xe(e11, t10).length > 0;
}
async function Un(e11, t10) {
  switch (t10.type) {
    case "CondBinary": {
      let n10 = await ie(e11, t10.left), r10 = t10.right.parts.length > 0 && t10.right.parts.every((i10) => i10.type === "SingleQuoted" || i10.type === "DoubleQuoted" || i10.type === "Escaped" && t10.operator !== "=~"), s10;
      if (t10.operator === "=~")
        if (r10) {
          let i10 = await ie(e11, t10.right);
          s10 = Dr(i10);
        } else
          s10 = await oc(e11, t10.right);
      else
        Ns(t10.operator) && !r10 ? s10 = await ac(e11, t10.right) : s10 = await ie(e11, t10.right);
      if (Ns(t10.operator)) {
        let i10 = e11.state.shoptOptions.nocasematch;
        return uo(t10.operator, n10, s10, !r10, i10, true);
      }
      if (lo(t10.operator))
        return co(t10.operator, await m6(e11, n10), await m6(e11, s10));
      if (oo(t10.operator))
        return ao(e11, t10.operator, n10, s10);
      switch (t10.operator) {
        case "=~":
          try {
            let i10 = e11.state.shoptOptions.nocasematch, o10 = Vx(s10), l = V(o10, i10 ? "i" : "").match(n10);
            if (dn(e11, "BASH_REMATCH"), l)
              for (let c = 0; c < l.length; c++)
                e11.state.env.set(`BASH_REMATCH_${c}`, l[c] || "");
            return l !== null;
          } catch {
            throw new Error("syntax error in regular expression");
          }
        case "<":
          return n10 < s10;
        case ">":
          return n10 > s10;
        default:
          return false;
      }
    }
    case "CondUnary": {
      let n10 = await ie(e11, t10.operand);
      return so(t10.operator) ? io(e11, t10.operator, n10) : fo(t10.operator) ? po(t10.operator, n10) : t10.operator === "-v" ? await ho(e11, n10) : t10.operator === "-o" ? gc(e11, n10) : false;
    }
    case "CondNot":
      return e11.state.shoptOptions.extglob && t10.operand.type === "CondGroup" && t10.operand.expression.type === "CondWord" ? `!(${await ie(e11, t10.operand.expression.word)})` !== "" : !await Un(e11, t10.operand);
    case "CondAnd":
      return await Un(e11, t10.left) ? await Un(e11, t10.right) : false;
    case "CondOr":
      return await Un(e11, t10.left) ? true : await Un(e11, t10.right);
    case "CondGroup":
      return await Un(e11, t10.expression);
    case "CondWord":
      return await ie(e11, t10.word) !== "";
    default:
      return false;
  }
}
async function ks(e11, t10) {
  if (t10.length === 0)
    return B("", "", 1);
  if (t10.length === 1)
    return Ye(!!t10[0]);
  if (t10.length === 2) {
    let r10 = t10[0], s10 = t10[1];
    return r10 === "(" ? W(`test: '(' without matching ')'
`, 2) : so(r10) ? Ye(await io(e11, r10, s10)) : fo(r10) ? Ye(po(r10, s10)) : r10 === "!" ? Ye(!s10) : r10 === "-v" ? Ye(await ho(e11, s10)) : r10 === "-o" ? Ye(gc(e11, s10)) : r10 === "=" || r10 === "==" || r10 === "!=" || r10 === "<" || r10 === ">" || r10 === "-eq" || r10 === "-ne" || r10 === "-lt" || r10 === "-le" || r10 === "-gt" || r10 === "-ge" || r10 === "-nt" || r10 === "-ot" || r10 === "-ef" ? W(`test: ${r10}: unary operator expected
`, 2) : B("", "", 1);
  }
  if (t10.length === 3) {
    let r10 = t10[0], s10 = t10[1], i10 = t10[2];
    if (Ns(s10))
      return Ye(uo(s10, r10, i10));
    if (lo(s10)) {
      let o10 = mo(r10), a = mo(i10);
      return !o10.valid || !a.valid ? B("", "", 2) : Ye(co(s10, o10.value, a.value));
    }
    if (oo(s10))
      return Ye(await ao(e11, s10, r10, i10));
    switch (s10) {
      case "-a":
        return Ye(r10 !== "" && i10 !== "");
      case "-o":
        return Ye(r10 !== "" || i10 !== "");
      case ">":
        return Ye(r10 > i10);
      case "<":
        return Ye(r10 < i10);
    }
    if (r10 === "!") {
      let o10 = await ks(e11, [s10, i10]);
      return B("", o10.stderr, o10.exitCode === 0 ? 1 : o10.exitCode === 1 ? 0 : o10.exitCode);
    }
    if (r10 === "(" && i10 === ")")
      return Ye(s10 !== "");
  }
  if (t10.length === 4) {
    if (t10[0] === "!") {
      let r10 = await ks(e11, t10.slice(1));
      return B("", r10.stderr, r10.exitCode === 0 ? 1 : r10.exitCode === 1 ? 0 : r10.exitCode);
    }
    if (t10[0] === "(" && t10[3] === ")")
      return ks(e11, [t10[1], t10[2]]);
  }
  let n10 = await y6(e11, t10, 0);
  return n10.pos < t10.length ? W(`test: too many arguments
`, 2) : Ye(n10.value);
}
async function y6(e11, t10, n10) {
  return Hx(e11, t10, n10);
}
async function Hx(e11, t10, n10) {
  let { value: r10, pos: s10 } = await d6(e11, t10, n10);
  for (; t10[s10] === "-o"; ) {
    let i10 = await d6(e11, t10, s10 + 1);
    r10 = r10 || i10.value, s10 = i10.pos;
  }
  return { value: r10, pos: s10 };
}
async function d6(e11, t10, n10) {
  let { value: r10, pos: s10 } = await mc(e11, t10, n10);
  for (; t10[s10] === "-a"; ) {
    let i10 = await mc(e11, t10, s10 + 1);
    r10 = r10 && i10.value, s10 = i10.pos;
  }
  return { value: r10, pos: s10 };
}
async function mc(e11, t10, n10) {
  if (t10[n10] === "!") {
    let { value: r10, pos: s10 } = await mc(e11, t10, n10 + 1);
    return { value: !r10, pos: s10 };
  }
  return jx(e11, t10, n10);
}
async function jx(e11, t10, n10) {
  let r10 = t10[n10];
  if (r10 === "(") {
    let { value: i10, pos: o10 } = await y6(e11, t10, n10 + 1);
    return { value: i10, pos: t10[o10] === ")" ? o10 + 1 : o10 };
  }
  let s10 = t10[n10 + 1];
  if (Ns(s10)) {
    let i10 = r10, o10 = t10[n10 + 2] ?? "";
    return { value: uo(s10, i10, o10), pos: n10 + 3 };
  }
  if (lo(s10)) {
    let i10 = mo(r10), o10 = mo(t10[n10 + 2] ?? "0");
    return !i10.valid || !o10.valid ? { value: false, pos: n10 + 3 } : { value: co(s10, i10.value, o10.value), pos: n10 + 3 };
  }
  if (oo(s10)) {
    let i10 = r10, o10 = t10[n10 + 2] ?? "";
    return { value: await ao(e11, s10, i10, o10), pos: n10 + 3 };
  }
  if (so(r10)) {
    let i10 = t10[n10 + 1] ?? "";
    return { value: await io(e11, r10, i10), pos: n10 + 2 };
  }
  if (fo(r10)) {
    let i10 = t10[n10 + 1] ?? "";
    return { value: po(r10, i10), pos: n10 + 2 };
  }
  if (r10 === "-v") {
    let i10 = t10[n10 + 1] ?? "";
    return { value: await ho(e11, i10), pos: n10 + 2 };
  }
  if (r10 === "-o") {
    let i10 = t10[n10 + 1] ?? "";
    return { value: gc(e11, i10), pos: n10 + 2 };
  }
  return { value: r10 !== void 0 && r10 !== "", pos: n10 + 1 };
}
function Wr(e11, t10, n10 = false, r10 = false) {
  let s10 = `^${w6(t10, r10)}$`;
  return V(s10, n10 ? "is" : "s").test(e11);
}
function w6(e11, t10) {
  let n10 = "";
  for (let r10 = 0; r10 < e11.length; r10++) {
    let s10 = e11[r10];
    if (t10 && (s10 === "@" || s10 === "*" || s10 === "+" || s10 === "?" || s10 === "!") && r10 + 1 < e11.length && e11[r10 + 1] === "(") {
      let i10 = b6(e11, r10 + 1);
      if (i10 !== -1) {
        let o10 = e11.slice(r10 + 2, i10), a = x6(o10), l = a.map((u) => w6(u, t10)), c = l.length > 0 ? l.join("|") : "(?:)";
        if (s10 === "@")
          n10 += `(?:${c})`;
        else if (s10 === "*")
          n10 += `(?:${c})*`;
        else if (s10 === "+")
          n10 += `(?:${c})+`;
        else if (s10 === "?")
          n10 += `(?:${c})?`;
        else if (s10 === "!")
          if (i10 < e11.length - 1) {
            let f10 = a.map((h) => E6(h, t10));
            if (f10.every((h) => h !== null) && f10.every((h) => h === f10[0]) && f10[0] !== null) {
              let h = f10[0];
              if (h === 0)
                n10 += "(?:.+)";
              else {
                let m = [];
                h > 0 && m.push(`.{0,${h - 1}}`), m.push(`.{${h + 1},}`), m.push(`(?!(?:${c})).{${h}}`), n10 += `(?:${m.join("|")})`;
              }
            } else
              n10 += `(?:(?!(?:${c})).)*?`;
          } else
            n10 += `(?!(?:${c})$).*`;
        r10 = i10;
        continue;
      }
    }
    if (s10 === "\\")
      if (r10 + 1 < e11.length) {
        let i10 = e11[r10 + 1];
        /[\\^$.|+(){}[\]*?]/.test(i10) ? n10 += `\\${i10}` : n10 += i10, r10++;
      } else
        n10 += "\\\\";
    else if (s10 === "*")
      n10 += ".*";
    else if (s10 === "?")
      n10 += ".";
    else if (s10 === "[") {
      let i10 = e11.indexOf("]", r10 + 1);
      i10 !== -1 ? (n10 += e11.slice(r10, i10 + 1), r10 = i10) : n10 += "\\[";
    } else
      /[\\^$.|+(){}]/.test(s10) ? n10 += `\\${s10}` : n10 += s10;
  }
  return n10;
}
function b6(e11, t10) {
  let n10 = 1, r10 = t10 + 1;
  for (; r10 < e11.length && n10 > 0; ) {
    let s10 = e11[r10];
    if (s10 === "\\") {
      r10 += 2;
      continue;
    }
    if (s10 === "(")
      n10++;
    else if (s10 === ")" && (n10--, n10 === 0))
      return r10;
    r10++;
  }
  return -1;
}
function x6(e11) {
  let t10 = [], n10 = "", r10 = 0, s10 = 0;
  for (; s10 < e11.length; ) {
    let i10 = e11[s10];
    if (i10 === "\\") {
      n10 += i10, s10 + 1 < e11.length ? (n10 += e11[s10 + 1], s10 += 2) : s10++;
      continue;
    }
    i10 === "(" ? (r10++, n10 += i10) : i10 === ")" ? (r10--, n10 += i10) : i10 === "|" && r10 === 0 ? (t10.push(n10), n10 = "") : n10 += i10, s10++;
  }
  return t10.push(n10), t10;
}
function E6(e11, t10) {
  let n10 = 0, r10 = 0;
  for (; r10 < e11.length; ) {
    let s10 = e11[r10];
    if (t10 && (s10 === "@" || s10 === "*" || s10 === "+" || s10 === "?" || s10 === "!") && r10 + 1 < e11.length && e11[r10 + 1] === "(") {
      let i10 = b6(e11, r10 + 1);
      if (i10 !== -1) {
        if (s10 === "@") {
          let o10 = e11.slice(r10 + 2, i10), l = x6(o10).map((c) => E6(c, t10));
          if (l.every((c) => c !== null) && l.every((c) => c === l[0])) {
            n10 += l[0], r10 = i10 + 1;
            continue;
          }
          return null;
        }
        return null;
      }
    }
    if (s10 === "*")
      return null;
    if (s10 === "?") {
      n10 += 1, r10++;
      continue;
    }
    if (s10 === "[") {
      let i10 = e11.indexOf("]", r10 + 1);
      if (i10 !== -1) {
        n10 += 1, r10 = i10 + 1;
        continue;
      }
      n10 += 1, r10++;
      continue;
    }
    if (s10 === "\\") {
      n10 += 1, r10 += 2;
      continue;
    }
    n10 += 1, r10++;
  }
  return n10;
}
function gc(e11, t10) {
  let r10 = (/* @__PURE__ */ new Map([["errexit", () => e11.state.options.errexit === true], ["nounset", () => e11.state.options.nounset === true], ["pipefail", () => e11.state.options.pipefail === true], ["xtrace", () => e11.state.options.xtrace === true], ["e", () => e11.state.options.errexit === true], ["u", () => e11.state.options.nounset === true], ["x", () => e11.state.options.xtrace === true]])).get(t10);
  return r10 ? r10() : false;
}
async function m6(e11, t10) {
  if (t10 = t10.trim(), t10 === "")
    return 0;
  if (/^[+-]?(\d+#[a-zA-Z0-9@_]+|0[xX][0-9a-fA-F]+|0[0-7]+|\d+)$/.test(t10))
    return g6(t10);
  try {
    let n10 = new ce(), r10 = Ae(n10, t10);
    return await ne(e11, r10.expression);
  } catch {
    return g6(t10);
  }
}
function Gx(e11, t10) {
  let n10 = 0;
  for (let r10 of e11) {
    let s10;
    if (r10 >= "0" && r10 <= "9")
      s10 = r10.charCodeAt(0) - 48;
    else if (r10 >= "a" && r10 <= "z")
      s10 = r10.charCodeAt(0) - 97 + 10;
    else if (r10 >= "A" && r10 <= "Z")
      s10 = r10.charCodeAt(0) - 65 + 36;
    else if (r10 === "@")
      s10 = 62;
    else if (r10 === "_")
      s10 = 63;
    else
      return Number.NaN;
    if (s10 >= t10)
      return Number.NaN;
    n10 = n10 * t10 + s10;
  }
  return n10;
}
function g6(e11) {
  if (e11 = e11.trim(), e11 === "")
    return 0;
  let t10 = false;
  e11.startsWith("-") ? (t10 = true, e11 = e11.slice(1)) : e11.startsWith("+") && (e11 = e11.slice(1));
  let n10, r10 = e11.match(/^(\d+)#([a-zA-Z0-9@_]+)$/);
  if (r10) {
    let s10 = Number.parseInt(r10[1], 10);
    s10 >= 2 && s10 <= 64 ? n10 = Gx(r10[2], s10) : n10 = 0;
  } else
    /^0[xX][0-9a-fA-F]+$/.test(e11) ? n10 = Number.parseInt(e11, 16) : /^0[0-7]+$/.test(e11) ? n10 = Number.parseInt(e11, 8) : n10 = Number.parseInt(e11, 10);
  return Number.isNaN(n10) && (n10 = 0), t10 ? -n10 : n10;
}
function mo(e11) {
  if (e11 = e11.trim(), e11 === "")
    return { value: 0, valid: true };
  let t10 = false;
  if (e11.startsWith("-") ? (t10 = true, e11 = e11.slice(1)) : e11.startsWith("+") && (e11 = e11.slice(1)), !/^\d+$/.test(e11))
    return { value: 0, valid: false };
  let n10 = Number.parseInt(e11, 10);
  return Number.isNaN(n10) ? { value: 0, valid: false } : { value: t10 ? -n10 : n10, valid: true };
}
function Vx(e11) {
  let t10 = "", n10 = 0;
  for (; n10 < e11.length; )
    if (e11[n10] === "\\" && n10 + 1 < e11.length)
      t10 += e11[n10] + e11[n10 + 1], n10 += 2;
    else if (e11[n10] === "[") {
      let r10 = qx(e11, n10);
      t10 += r10.converted, n10 = r10.endIndex;
    } else
      t10 += e11[n10], n10++;
  return t10;
}
function qx(e11, t10) {
  let n10 = t10 + 1, r10 = "[";
  n10 < e11.length && (e11[n10] === "^" || e11[n10] === "!") && (r10 += "^", n10++);
  let s10 = false;
  n10 < e11.length && e11[n10] === "]" && (s10 = true, n10++);
  let i10 = false;
  n10 < e11.length && e11[n10] === "[" && n10 + 1 < e11.length && e11[n10 + 1] !== ":" && (i10 = true, n10++);
  let o10 = "", a = false;
  for (; n10 < e11.length; ) {
    let l = e11[n10];
    if (l === "]") {
      a = true, n10++;
      break;
    }
    if (l === "[" && n10 + 1 < e11.length && e11[n10 + 1] === ":") {
      let c = e11.indexOf(":]", n10 + 2);
      if (c !== -1) {
        let u = e11.slice(n10 + 2, c);
        o10 += Zx(u), n10 = c + 2;
        continue;
      }
    }
    if (l === "[" && n10 + 1 < e11.length) {
      let c = e11[n10 + 1];
      if (c === "." || c === "=") {
        let u = `${c}]`, f10 = e11.indexOf(u, n10 + 2);
        if (f10 !== -1) {
          let p = e11.slice(n10 + 2, f10);
          o10 += p, n10 = f10 + 2;
          continue;
        }
      }
    }
    if (l === "\\" && n10 + 1 < e11.length) {
      o10 += l + e11[n10 + 1], n10 += 2;
      continue;
    }
    o10 += l, n10++;
  }
  return a ? (s10 && (r10 += "\\]"), i10 && (r10 += "\\["), r10 += o10, r10 += "]", { converted: r10, endIndex: n10 }) : { converted: "\\[", endIndex: t10 + 1 };
}
function Zx(e11) {
  return (/* @__PURE__ */ new Map([["alnum", "a-zA-Z0-9"], ["alpha", "a-zA-Z"], ["ascii", "\\x00-\\x7F"], ["blank", " \\t"], ["cntrl", "\\x00-\\x1F\\x7F"], ["digit", "0-9"], ["graph", "!-~"], ["lower", "a-z"], ["print", " -~"], ["punct", "!-/:-@\\[-`{-~"], ["space", " \\t\\n\\r\\f\\v"], ["upper", "A-Z"], ["word", "a-zA-Z0-9_"], ["xdigit", "0-9A-Fa-f"]])).get(e11) ?? "";
}
Ct();
dt();
Ke();
St();
Fn();
function wn(e11) {
  let t10 = [], n10 = "", r10 = false, s10 = false, i10 = false, o10 = false;
  for (let a of e11) {
    if (i10) {
      n10 += a, i10 = false, o10 = true;
      continue;
    }
    if (a === "\\") {
      i10 = true;
      continue;
    }
    if (a === "'" && !s10) {
      r10 || (o10 = true), r10 = !r10;
      continue;
    }
    if (a === '"' && !r10) {
      s10 || (o10 = true), s10 = !s10;
      continue;
    }
    if ((a === " " || a === "	" || a === `
`) && !r10 && !s10) {
      o10 && (t10.push(n10), n10 = "", o10 = false);
      continue;
    }
    n10 += a, o10 = true;
  }
  return o10 && t10.push(n10), t10;
}
function go(e11) {
  let t10 = [], n10 = 0;
  for (; n10 < e11.length; ) {
    for (; n10 < e11.length && /\s/.test(e11[n10]); )
      n10++;
    if (n10 >= e11.length)
      break;
    if (e11[n10] !== "[") {
      n10++;
      continue;
    }
    n10++;
    let r10 = "";
    if (e11[n10] === "'" || e11[n10] === '"') {
      let i10 = e11[n10];
      for (n10++; n10 < e11.length && e11[n10] !== i10; )
        r10 += e11[n10], n10++;
      e11[n10] === i10 && n10++;
    } else
      for (; n10 < e11.length && e11[n10] !== "]" && e11[n10] !== "="; )
        r10 += e11[n10], n10++;
    for (; n10 < e11.length && e11[n10] !== "]"; )
      n10++;
    if (e11[n10] === "]" && n10++, e11[n10] !== "=")
      continue;
    n10++;
    let s10 = "";
    if (e11[n10] === "'" || e11[n10] === '"') {
      let i10 = e11[n10];
      for (n10++; n10 < e11.length && e11[n10] !== i10; )
        e11[n10] === "\\" && n10 + 1 < e11.length && n10++, s10 += e11[n10], n10++;
      e11[n10] === i10 && n10++;
    } else
      for (; n10 < e11.length && !/\s/.test(e11[n10]); )
        s10 += e11[n10], n10++;
    t10.push([r10, s10]);
  }
  return t10;
}
function A6(e11) {
  let t10 = e11.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
  if (t10)
    return { name: t10[1], isArray: true, arrayElements: wn(t10[2]) };
  let n10 = e11.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([^\]]+)\]=(.*)$/s);
  if (n10)
    return { name: n10[1], isArray: false, arrayIndex: n10[2], value: n10[3] };
  if (e11.includes("=")) {
    let r10 = e11.indexOf("=");
    return { name: e11.slice(0, r10), isArray: false, value: e11.slice(r10 + 1) };
  }
  return { name: e11, isArray: false };
}
async function Qx(e11, t10) {
  try {
    let n10 = new ce(), r10 = Ae(n10, t10);
    return await ne(e11, r10.expression);
  } catch {
    let n10 = parseInt(t10, 10);
    return Number.isNaN(n10) ? 0 : n10;
  }
}
async function S6(e11, t10, n10 = {}) {
  let { name: r10, isArray: s10, arrayElements: i10, value: o10, arrayIndex: a } = t10, { makeReadonly: l = false, checkReadonly: c = true } = n10;
  if (c) {
    let u = st(e11, r10);
    if (u)
      return u;
  }
  if (s10 && i10) {
    for (let u = 0; u < i10.length; u++)
      e11.state.env.set(`${r10}_${u}`, i10[u]);
    e11.state.env.set(`${r10}__length`, String(i10.length));
  } else if (a !== void 0 && o10 !== void 0) {
    let u = await Qx(e11, a);
    e11.state.env.set(`${r10}_${u}`, o10);
    let f10 = parseInt(e11.state.env.get(`${r10}__length`) ?? "0", 10);
    u >= f10 && e11.state.env.set(`${r10}__length`, String(u + 1));
  } else
    o10 !== void 0 && e11.state.env.set(r10, o10);
  return l && Dt(e11, r10), null;
}
function Wn(e11, t10) {
  e11.state.localVarDepth = e11.state.localVarDepth || /* @__PURE__ */ new Map(), e11.state.localVarDepth.set(t10, e11.state.callDepth);
}
function Br(e11, t10) {
  return e11.state.localVarDepth?.get(t10);
}
function yo(e11, t10) {
  e11.state.localVarDepth?.delete(t10);
}
function C6(e11, t10, n10) {
  e11.state.localVarStack = e11.state.localVarStack || /* @__PURE__ */ new Map();
  let r10 = e11.state.localVarStack.get(t10) || [];
  r10.push({ value: n10, scopeIndex: e11.state.localScopes.length - 1 }), e11.state.localVarStack.set(t10, r10);
}
function wo(e11, t10) {
  let n10 = e11.state.localVarStack?.get(t10);
  if (!(!n10 || n10.length === 0))
    return n10.pop();
}
function N6(e11, t10) {
  if (e11.state.localVarStack)
    for (let [n10, r10] of e11.state.localVarStack.entries()) {
      for (; r10.length > 0 && r10[r10.length - 1].scopeIndex === t10; )
        r10.pop();
      r10.length === 0 && e11.state.localVarStack.delete(n10);
    }
}
ye();
Ct();
var yc = /* @__PURE__ */ new Set([":", ".", "break", "continue", "eval", "exec", "exit", "export", "readonly", "return", "set", "shift", "trap", "unset"]);
function k6(e11) {
  return yc.has(e11);
}
var wc = /* @__PURE__ */ new Set(["if", "then", "else", "elif", "fi", "case", "esac", "for", "select", "while", "until", "do", "done", "in", "function", "{", "}", "time", "[[", "]]", "!"]);
var zr = /* @__PURE__ */ new Set([":", "true", "false", "cd", "export", "unset", "exit", "local", "set", "break", "continue", "return", "eval", "shift", "getopts", "compgen", "complete", "compopt", "pushd", "popd", "dirs", "source", ".", "read", "mapfile", "readarray", "declare", "typeset", "readonly", "let", "command", "shopt", "exec", "test", "[", "echo", "printf", "pwd", "alias", "unalias", "type", "hash", "ulimit", "umask", "trap", "times", "wait", "kill", "jobs", "fg", "bg", "disown", "suspend", "fc", "history", "help", "enable", "builtin", "caller"]);
Ct();
async function ir(e11, t10, n10, r10) {
  try {
    if ((await e11.fs.stat(t10)).isDirectory)
      return `bash: ${n10}: Is a directory
`;
    if (r10.checkNoclobber && e11.state.options.noclobber && !r10.isClobber && n10 !== "/dev/null")
      return `bash: ${n10}: cannot overwrite existing file
`;
  } catch {
  }
  return null;
}
function it(e11) {
  let n10 = Math.min(e11.length, 8192);
  for (let r10 = 0; r10 < n10; r10++)
    if (e11.charCodeAt(r10) > 255)
      return "utf8";
  return "binary";
}
function Kx(e11) {
  if (!e11.startsWith("__rw__:"))
    return null;
  let t10 = e11.slice(7), n10 = t10.indexOf(":");
  if (n10 === -1)
    return null;
  let r10 = Number.parseInt(t10.slice(0, n10), 10);
  if (Number.isNaN(r10) || r10 < 0)
    return null;
  let s10 = n10 + 1, i10 = t10.slice(s10, s10 + r10), o10 = s10 + r10 + 1, a = t10.slice(o10), l = a.indexOf(":");
  if (l === -1)
    return null;
  let c = Number.parseInt(a.slice(0, l), 10);
  if (Number.isNaN(c) || c < 0)
    return null;
  let u = a.slice(l + 1);
  return { path: i10, position: c, content: u };
}
async function v6(e11, t10) {
  let n10 = /* @__PURE__ */ new Map();
  for (let r10 = 0; r10 < t10.length; r10++) {
    let s10 = t10[r10];
    if (s10.target.type === "HereDoc")
      continue;
    if (s10.operator === ">&" || s10.operator === "<&") {
      if (Ss(e11, s10.target))
        return { targets: n10, error: `bash: $@: ambiguous redirect
` };
      n10.set(r10, await ie(e11, s10.target));
    } else {
      let o10 = await Cs(e11, s10.target);
      if ("error" in o10)
        return { targets: n10, error: o10.error };
      n10.set(r10, o10.target);
    }
  }
  return { targets: n10 };
}
function Xx(e11) {
  e11.state.nextFd === void 0 && (e11.state.nextFd = 10);
  let t10 = e11.state.nextFd;
  return e11.state.nextFd++, t10;
}
async function bo(e11, t10) {
  for (let n10 of t10) {
    if (!n10.fdVariable)
      continue;
    if (e11.state.fileDescriptors || (e11.state.fileDescriptors = /* @__PURE__ */ new Map()), (n10.operator === ">&" || n10.operator === "<&") && n10.target.type === "Word" && await ie(e11, n10.target) === "-") {
      let i10 = e11.state.env.get(n10.fdVariable);
      if (i10 !== void 0) {
        let o10 = Number.parseInt(i10, 10);
        Number.isNaN(o10) || e11.state.fileDescriptors.delete(o10);
      }
      continue;
    }
    let r10 = Xx(e11);
    if (e11.state.env.set(n10.fdVariable, String(r10)), n10.target.type === "Word") {
      let s10 = await ie(e11, n10.target);
      if (n10.operator === ">&" || n10.operator === "<&") {
        let i10 = Number.parseInt(s10, 10);
        if (!Number.isNaN(i10)) {
          let o10 = e11.state.fileDescriptors.get(i10);
          o10 !== void 0 && e11.state.fileDescriptors.set(r10, o10);
          continue;
        }
      }
      if (n10.operator === ">" || n10.operator === ">>" || n10.operator === ">|" || n10.operator === "&>" || n10.operator === "&>>") {
        let i10 = e11.fs.resolvePath(e11.state.cwd, s10);
        (n10.operator === ">" || n10.operator === ">|" || n10.operator === "&>") && await e11.fs.writeFile(i10, "", "binary"), e11.state.fileDescriptors.set(r10, `__file__:${i10}`);
      } else if (n10.operator === "<<<")
        e11.state.fileDescriptors.set(r10, `${s10}
`);
      else if (n10.operator === "<" || n10.operator === "<>")
        try {
          let i10 = e11.fs.resolvePath(e11.state.cwd, s10), o10 = await e11.fs.readFile(i10);
          e11.state.fileDescriptors.set(r10, o10);
        } catch {
          return B("", `bash: ${s10}: No such file or directory
`, 1);
        }
    }
  }
  return null;
}
async function bn(e11, t10) {
  for (let n10 of t10) {
    if (n10.target.type === "HereDoc")
      continue;
    let r10 = n10.operator === ">&";
    if (n10.operator !== ">" && n10.operator !== ">|" && n10.operator !== "&>" && !r10)
      continue;
    let s10;
    if (r10) {
      if (s10 = await ie(e11, n10.target), s10 === "-" || !Number.isNaN(Number.parseInt(s10, 10)) || n10.fd != null)
        continue;
    } else {
      let a = await Cs(e11, n10.target);
      if ("error" in a)
        return B("", a.error, 1);
      s10 = a.target;
    }
    let i10 = e11.fs.resolvePath(e11.state.cwd, s10), o10 = n10.operator === ">|";
    if (i10.includes("\0"))
      return B("", `bash: ${s10}: No such file or directory
`, 1);
    try {
      let a = await e11.fs.stat(i10);
      if (a.isDirectory)
        return B("", `bash: ${s10}: Is a directory
`, 1);
      if (e11.state.options.noclobber && !o10 && !a.isDirectory && s10 !== "/dev/null")
        return B("", `bash: ${s10}: cannot overwrite existing file
`, 1);
    } catch {
    }
    if (s10 !== "/dev/null" && s10 !== "/dev/stdout" && s10 !== "/dev/stderr" && s10 !== "/dev/full" && await e11.fs.writeFile(i10, "", "binary"), s10 === "/dev/full")
      return B("", `bash: /dev/full: No space left on device
`, 1);
  }
  return null;
}
async function Be(e11, t10, n10, r10) {
  let { stdout: s10, stderr: i10, exitCode: o10 } = t10;
  for (let c = 0; c < n10.length; c++) {
    let u = n10[c];
    if (u.target.type === "HereDoc")
      continue;
    let f10, p = r10?.get(c);
    if (p !== void 0)
      f10 = p;
    else if (u.operator === ">&" || u.operator === "<&") {
      if (Ss(e11, u.target)) {
        i10 += `bash: $@: ambiguous redirect
`, o10 = 1, s10 = "";
        continue;
      }
      f10 = await ie(e11, u.target);
    } else {
      let m = await Cs(e11, u.target);
      if ("error" in m) {
        i10 += m.error, o10 = 1, s10 = "";
        continue;
      }
      f10 = m.target;
    }
    if (!u.fdVariable) {
      if (f10.includes("\0")) {
        i10 += `bash: ${f10.replace(/\0/g, "")}: No such file or directory
`, o10 = 1, s10 = "";
        continue;
      }
      switch (u.operator) {
        case ">":
        case ">|": {
          let h = u.fd ?? 1, m = u.operator === ">|";
          if (h === 1) {
            if (f10 === "/dev/stdout")
              break;
            if (f10 === "/dev/stderr") {
              i10 += s10, s10 = "";
              break;
            }
            if (f10 === "/dev/full") {
              i10 += `bash: echo: write error: No space left on device
`, o10 = 1, s10 = "";
              break;
            }
            let d = e11.fs.resolvePath(e11.state.cwd, f10), g = await ir(e11, d, f10, { checkNoclobber: true, isClobber: m });
            if (g) {
              i10 += g, o10 = 1, s10 = "";
              break;
            }
            await e11.fs.writeFile(d, s10, it(s10)), s10 = "";
          } else if (h === 2) {
            if (f10 === "/dev/stderr")
              break;
            if (f10 === "/dev/stdout") {
              s10 += i10, i10 = "";
              break;
            }
            if (f10 === "/dev/full") {
              i10 += `bash: echo: write error: No space left on device
`, o10 = 1;
              break;
            }
            if (f10 === "/dev/null")
              i10 = "";
            else {
              let d = e11.fs.resolvePath(e11.state.cwd, f10), g = await ir(e11, d, f10, { checkNoclobber: true, isClobber: m });
              if (g) {
                i10 += g, o10 = 1;
                break;
              }
              await e11.fs.writeFile(d, i10, it(i10)), i10 = "";
            }
          }
          break;
        }
        case ">>": {
          let h = u.fd ?? 1;
          if (h === 1) {
            if (f10 === "/dev/stdout")
              break;
            if (f10 === "/dev/stderr") {
              i10 += s10, s10 = "";
              break;
            }
            if (f10 === "/dev/full") {
              i10 += `bash: echo: write error: No space left on device
`, o10 = 1, s10 = "";
              break;
            }
            let m = e11.fs.resolvePath(e11.state.cwd, f10), d = await ir(e11, m, f10, {});
            if (d) {
              i10 += d, o10 = 1, s10 = "";
              break;
            }
            await e11.fs.appendFile(m, s10, it(s10)), s10 = "";
          } else if (h === 2) {
            if (f10 === "/dev/stderr")
              break;
            if (f10 === "/dev/stdout") {
              s10 += i10, i10 = "";
              break;
            }
            if (f10 === "/dev/full") {
              i10 += `bash: echo: write error: No space left on device
`, o10 = 1;
              break;
            }
            let m = e11.fs.resolvePath(e11.state.cwd, f10), d = await ir(e11, m, f10, {});
            if (d) {
              i10 += d, o10 = 1;
              break;
            }
            await e11.fs.appendFile(m, i10, it(i10)), i10 = "";
          }
          break;
        }
        case ">&":
        case "<&": {
          let h = u.fd ?? 1;
          if (f10 === "-")
            break;
          if (f10.endsWith("-")) {
            let m = f10.slice(0, -1), d = Number.parseInt(m, 10);
            if (!Number.isNaN(d)) {
              let g = e11.state.fileDescriptors?.get(d);
              g !== void 0 ? (e11.state.fileDescriptors || (e11.state.fileDescriptors = /* @__PURE__ */ new Map()), e11.state.fileDescriptors.set(h, g), d >= 3 && e11.state.fileDescriptors?.delete(d)) : d === 1 || d === 2 ? (e11.state.fileDescriptors || (e11.state.fileDescriptors = /* @__PURE__ */ new Map()), e11.state.fileDescriptors.set(h, `__dupout__:${d}`)) : d === 0 ? (e11.state.fileDescriptors || (e11.state.fileDescriptors = /* @__PURE__ */ new Map()), e11.state.fileDescriptors.set(h, `__dupin__:${d}`)) : d >= 3 && (i10 += `bash: ${d}: Bad file descriptor
`, o10 = 1);
            }
            break;
          }
          if (f10 === "2" || f10 === "&2")
            h === 1 && (i10 += s10, s10 = "");
          else if (f10 === "1" || f10 === "&1")
            s10 += i10, i10 = "";
          else {
            let m = Number.parseInt(f10, 10);
            if (Number.isNaN(m)) {
              if (u.operator === ">&") {
                let d = e11.fs.resolvePath(e11.state.cwd, f10), g = await ir(e11, d, f10, { checkNoclobber: true });
                if (g) {
                  i10 = g, o10 = 1, s10 = "";
                  break;
                }
                if (u.fd == null) {
                  let y = s10 + i10;
                  await e11.fs.writeFile(d, y, it(y)), s10 = "", i10 = "";
                } else
                  h === 1 ? (await e11.fs.writeFile(d, s10, it(s10)), s10 = "") : h === 2 && (await e11.fs.writeFile(d, i10, it(i10)), i10 = "");
              }
            } else {
              let d = e11.state.fileDescriptors?.get(m);
              if (d?.startsWith("__file__:")) {
                let g = d.slice(9);
                h === 1 ? (await e11.fs.appendFile(g, s10, it(s10)), s10 = "") : h === 2 && (await e11.fs.appendFile(g, i10, it(i10)), i10 = "");
              } else if (d?.startsWith("__rw__:")) {
                let g = Kx(d);
                g && (h === 1 ? (await e11.fs.appendFile(g.path, s10, it(s10)), s10 = "") : h === 2 && (await e11.fs.appendFile(g.path, i10, it(i10)), i10 = ""));
              } else if (d?.startsWith("__dupout__:")) {
                let g = Number.parseInt(d.slice(11), 10);
                if (g !== 1)
                  if (g === 2)
                    h === 1 && (i10 += s10, s10 = "");
                  else {
                    let y = e11.state.fileDescriptors?.get(g);
                    if (y?.startsWith("__file__:")) {
                      let w = y.slice(9);
                      h === 1 ? (await e11.fs.appendFile(w, s10, it(s10)), s10 = "") : h === 2 && (await e11.fs.appendFile(w, i10, it(i10)), i10 = "");
                    }
                  }
              } else
                d?.startsWith("__dupin__:") ? (i10 += `bash: ${m}: Bad file descriptor
`, o10 = 1, s10 = "") : m >= 3 && (i10 += `bash: ${m}: Bad file descriptor
`, o10 = 1, s10 = "");
            }
          }
          break;
        }
        case "&>": {
          if (f10 === "/dev/full") {
            i10 = `bash: echo: write error: No space left on device
`, o10 = 1, s10 = "";
            break;
          }
          let h = e11.fs.resolvePath(e11.state.cwd, f10), m = await ir(e11, h, f10, { checkNoclobber: true });
          if (m) {
            i10 = m, o10 = 1, s10 = "";
            break;
          }
          let d = s10 + i10;
          await e11.fs.writeFile(h, d, it(d)), s10 = "", i10 = "";
          break;
        }
        case "&>>": {
          if (f10 === "/dev/full") {
            i10 = `bash: echo: write error: No space left on device
`, o10 = 1, s10 = "";
            break;
          }
          let h = e11.fs.resolvePath(e11.state.cwd, f10), m = await ir(e11, h, f10, {});
          if (m) {
            i10 = m, o10 = 1, s10 = "";
            break;
          }
          let d = s10 + i10;
          await e11.fs.appendFile(h, d, it(d)), s10 = "", i10 = "";
          break;
        }
      }
    }
  }
  let a = e11.state.fileDescriptors?.get(1);
  if (a) {
    if (a === "__dupout__:2")
      i10 += s10, s10 = "";
    else if (a.startsWith("__file__:")) {
      let c = a.slice(9);
      await e11.fs.appendFile(c, s10, it(s10)), s10 = "";
    } else if (a.startsWith("__file_append__:")) {
      let c = a.slice(16);
      await e11.fs.appendFile(c, s10, it(s10)), s10 = "";
    }
  }
  let l = e11.state.fileDescriptors?.get(2);
  if (l) {
    if (l === "__dupout__:1")
      s10 += i10, i10 = "";
    else if (l.startsWith("__file__:")) {
      let c = l.slice(9);
      await e11.fs.appendFile(c, i10, it(i10)), i10 = "";
    } else if (l.startsWith("__file_append__:")) {
      let c = l.slice(16);
      await e11.fs.appendFile(c, i10, it(i10)), i10 = "";
    }
  }
  return B(s10, i10, o10);
}
function I6(e11, t10) {
  if (e11.state.options.posix && yc.has(t10.name)) {
    let r10 = `bash: line ${e11.state.currentLine}: \`${t10.name}': is a special builtin
`;
    throw new pe(2, "", r10);
  }
  let n10 = { ...t10, sourceFile: t10.sourceFile ?? e11.state.currentSource ?? "main" };
  return e11.state.functions.set(t10.name, n10), de;
}
async function Yx(e11, t10) {
  let n10 = "";
  for (let r10 of t10)
    if ((r10.operator === "<<" || r10.operator === "<<-") && r10.target.type === "HereDoc") {
      let s10 = r10.target, i10 = await ie(e11, s10.content);
      s10.stripTabs && (i10 = i10.split(`
`).map((a) => a.replace(/^\t+/, "")).join(`
`)), (r10.fd ?? 0) === 0 && (n10 = i10);
    } else if (r10.operator === "<<<" && r10.target.type === "Word")
      n10 = `${await ie(e11, r10.target)}
`;
    else if (r10.operator === "<" && r10.target.type === "Word") {
      let s10 = await ie(e11, r10.target), i10 = e11.fs.resolvePath(e11.state.cwd, s10);
      try {
        n10 = await e11.fs.readFile(i10);
      } catch {
      }
    }
  return n10;
}
async function xo(e11, t10, n10, r10 = "", s10) {
  e11.state.callDepth++, e11.state.callDepth > e11.limits.maxCallDepth && (e11.state.callDepth--, kn(`${t10.name}: maximum recursion depth (${e11.limits.maxCallDepth}) exceeded, increase executionLimits.maxCallDepth`, "recursion")), e11.state.funcNameStack || (e11.state.funcNameStack = []), e11.state.callLineStack || (e11.state.callLineStack = []), e11.state.sourceStack || (e11.state.sourceStack = []), e11.state.funcNameStack.unshift(t10.name), e11.state.callLineStack.unshift(s10 ?? e11.state.currentLine), e11.state.sourceStack.unshift(t10.sourceFile ?? "main"), e11.state.localScopes.push(/* @__PURE__ */ new Map()), e11.state.localExportedVars || (e11.state.localExportedVars = []), e11.state.localExportedVars.push(/* @__PURE__ */ new Set());
  let i10 = /* @__PURE__ */ new Map();
  for (let c = 0; c < n10.length; c++)
    i10.set(String(c + 1), e11.state.env.get(String(c + 1))), e11.state.env.set(String(c + 1), n10[c]);
  i10.set("@", e11.state.env.get("@")), i10.set("#", e11.state.env.get("#")), e11.state.env.set("@", n10.join(" ")), e11.state.env.set("#", String(n10.length));
  let o10 = () => {
    let c = e11.state.localScopes.length - 1, u = e11.state.localScopes.pop();
    if (u)
      for (let [f10, p] of u)
        p === void 0 ? e11.state.env.delete(f10) : e11.state.env.set(f10, p);
    if (N6(e11, c), e11.state.fullyUnsetLocals)
      for (let [f10, p] of e11.state.fullyUnsetLocals.entries())
        p === c && e11.state.fullyUnsetLocals.delete(f10);
    if (e11.state.localExportedVars && e11.state.localExportedVars.length > 0) {
      let f10 = e11.state.localExportedVars.pop();
      if (f10)
        for (let p of f10)
          e11.state.exportedVars?.delete(p);
    }
    for (let [f10, p] of i10)
      p === void 0 ? e11.state.env.delete(f10) : e11.state.env.set(f10, p);
    e11.state.funcNameStack?.shift(), e11.state.callLineStack?.shift(), e11.state.sourceStack?.shift(), e11.state.callDepth--;
  }, { targets: a, error: l } = await v6(e11, t10.redirections);
  if (l)
    return o10(), B("", l, 1);
  try {
    let c = await Yx(e11, t10.redirections), u = r10 || c, f10 = await e11.executeCommand(t10.body, u);
    return o10(), Be(e11, f10, t10.redirections, a);
  } catch (c) {
    if (o10(), c instanceof at) {
      let u = B(c.stdout, c.stderr, c.exitCode);
      return Be(e11, u, t10.redirections, a);
    }
    throw c;
  }
}
var R6 = ["!", "[[", "]]", "case", "do", "done", "elif", "else", "esac", "fi", "for", "function", "if", "in", "then", "time", "until", "while", "{", "}"];
var xc = [".", ":", "[", "alias", "bg", "bind", "break", "builtin", "caller", "cd", "command", "compgen", "complete", "compopt", "continue", "declare", "dirs", "disown", "echo", "enable", "eval", "exec", "exit", "export", "false", "fc", "fg", "getopts", "hash", "help", "history", "jobs", "kill", "let", "local", "logout", "mapfile", "popd", "printf", "pushd", "pwd", "read", "readarray", "readonly", "return", "set", "shift", "shopt", "source", "suspend", "test", "times", "trap", "true", "type", "typeset", "ulimit", "umask", "unalias", "unset", "wait"];
var Jx = ["autocd", "assoc_expand_once", "cdable_vars", "cdspell", "checkhash", "checkjobs", "checkwinsize", "cmdhist", "compat31", "compat32", "compat40", "compat41", "compat42", "compat43", "compat44", "complete_fullquote", "direxpand", "dirspell", "dotglob", "execfail", "expand_aliases", "extdebug", "extglob", "extquote", "failglob", "force_fignore", "globasciiranges", "globstar", "gnu_errfmt", "histappend", "histreedit", "histverify", "hostcomplete", "huponexit", "inherit_errexit", "interactive_comments", "lastpipe", "lithist", "localvar_inherit", "localvar_unset", "login_shell", "mailwarn", "no_empty_cmd_completion", "nocaseglob", "nocasematch", "nullglob", "progcomp", "progcomp_alias", "promptvars", "restricted_shell", "shift_verbose", "sourcepath", "xpg_echo"];
var eE = xc;
async function Ec(e11, t10) {
  let n10 = [], r10 = null, s10 = "", i10 = "", o10 = null, a = false, l = false, c = false, u = null, f10 = null, p = null, h = [], m = ["alias", "arrayvar", "binding", "builtin", "command", "directory", "disabled", "enabled", "export", "file", "function", "group", "helptopic", "hostname", "job", "keyword", "running", "service", "setopt", "shopt", "signal", "stopped", "user", "variable"];
  for (let x = 0; x < t10.length; x++) {
    let S = t10[x];
    if (S === "-v")
      n10.push("variable");
    else if (S === "-e")
      n10.push("export");
    else if (S === "-f")
      n10.push("file");
    else if (S === "-d")
      n10.push("directory");
    else if (S === "-k")
      n10.push("keyword");
    else if (S === "-A") {
      if (x++, x >= t10.length)
        return W(`compgen: -A: option requires an argument
`, 2);
      let O = t10[x];
      if (!m.includes(O))
        return W(`compgen: ${O}: invalid action name
`, 2);
      n10.push(O);
    } else if (S === "-W") {
      if (x++, x >= t10.length)
        return W(`compgen: -W: option requires an argument
`, 2);
      r10 = t10[x];
    } else if (S === "-P") {
      if (x++, x >= t10.length)
        return W(`compgen: -P: option requires an argument
`, 2);
      s10 = t10[x];
    } else if (S === "-S") {
      if (x++, x >= t10.length)
        return W(`compgen: -S: option requires an argument
`, 2);
      i10 = t10[x];
    } else if (S === "-o") {
      if (x++, x >= t10.length)
        return W(`compgen: -o: option requires an argument
`, 2);
      let O = t10[x];
      if (O === "plusdirs")
        a = true;
      else if (O === "dirnames")
        l = true;
      else if (O === "default")
        c = true;
      else if (!(O === "filenames" || O === "nospace" || O === "bashdefault" || O === "noquote"))
        return W(`compgen: ${O}: invalid option name
`, 2);
    } else if (S === "-F") {
      if (x++, x >= t10.length)
        return W(`compgen: -F: option requires an argument
`, 2);
      f10 = t10[x];
    } else if (S === "-C") {
      if (x++, x >= t10.length)
        return W(`compgen: -C: option requires an argument
`, 2);
      p = t10[x];
    } else if (S === "-X") {
      if (x++, x >= t10.length)
        return W(`compgen: -X: option requires an argument
`, 2);
      u = t10[x];
    } else if (S === "-G") {
      if (x++, x >= t10.length)
        return W(`compgen: -G: option requires an argument
`, 2);
    } else if (S === "--") {
      h.push(...t10.slice(x + 1));
      break;
    } else
      S.startsWith("-") || h.push(S);
  }
  o10 = h[0] ?? null;
  let d = [];
  if (l) {
    let x = await bc(e11, o10);
    d.push(...x);
  }
  if (c) {
    let x = await O6(e11, o10);
    d.push(...x);
  }
  for (let x of n10)
    if (x === "variable") {
      let S = tE(e11, o10);
      d.push(...S);
    } else if (x === "export") {
      let S = nE(e11, o10);
      d.push(...S);
    } else if (x === "function") {
      let S = rE(e11, o10);
      d.push(...S);
    } else if (x === "builtin") {
      let S = sE(o10);
      d.push(...S);
    } else if (x === "keyword") {
      let S = iE(o10);
      d.push(...S);
    } else if (x === "alias") {
      let S = oE(e11, o10);
      d.push(...S);
    } else if (x === "shopt") {
      let S = aE(o10);
      d.push(...S);
    } else if (x === "helptopic") {
      let S = lE(o10);
      d.push(...S);
    } else if (x === "directory") {
      let S = await bc(e11, o10);
      d.push(...S);
    } else if (x === "file") {
      let S = await O6(e11, o10);
      d.push(...S);
    } else if (x === "user") {
      let S = cE(o10);
      d.push(...S);
    } else if (x === "command") {
      let S = await uE(e11, o10);
      d.push(...S);
    }
  if (r10 !== null)
    try {
      let x = await fE(e11, r10), S = pE(e11, x);
      for (let O of S)
        (o10 === null || O.startsWith(o10)) && d.push(O);
    } catch {
      return B("", "", 1);
    }
  if (a) {
    let x = await bc(e11, o10);
    for (let S of x)
      d.includes(S) || d.push(S);
  }
  let g = "";
  if (f10 !== null) {
    let x = e11.state.functions.get(f10);
    if (x) {
      let S = /* @__PURE__ */ new Map();
      S.set("COMP_WORDS__length", e11.state.env.get("COMP_WORDS__length")), e11.state.env.set("COMP_WORDS__length", "0"), S.set("COMP_CWORD", e11.state.env.get("COMP_CWORD")), e11.state.env.set("COMP_CWORD", "-1"), S.set("COMP_LINE", e11.state.env.get("COMP_LINE")), e11.state.env.set("COMP_LINE", ""), S.set("COMP_POINT", e11.state.env.get("COMP_POINT")), e11.state.env.set("COMP_POINT", "0");
      let O = /* @__PURE__ */ new Map();
      for (let F4 of e11.state.env.keys())
        (F4 === "COMPREPLY" || F4.startsWith("COMPREPLY_") || F4 === "COMPREPLY__length") && (O.set(F4, e11.state.env.get(F4)), e11.state.env.delete(F4));
      let R10 = ["compgen", h[0] ?? "", ""];
      try {
        let F4 = await xo(e11, x, R10, "");
        if (F4.exitCode !== 0)
          return Hr(e11, S), Hr(e11, O), B("", F4.stderr, 1);
        g = F4.stdout;
        let $ = hE(e11);
        d.push(...$);
      } catch {
        return Hr(e11, S), Hr(e11, O), B("", "", 1);
      }
      Hr(e11, S), Hr(e11, O);
    }
  }
  if (p !== null)
    try {
      let x = hn(p), S = await e11.executeScript(x);
      if (S.exitCode !== 0)
        return B("", S.stderr, S.exitCode);
      if (S.stdout) {
        let O = S.stdout.split(`
`);
        for (let R10 of O)
          R10.length > 0 && d.push(R10);
      }
    } catch (x) {
      if (x.name === "ParseException")
        return W(`compgen: -C: ${x.message}
`, 2);
      throw x;
    }
  let y = d;
  if (u !== null) {
    let x = u.startsWith("!"), S = x ? u.slice(1) : u;
    y = d.filter((O) => {
      let R10 = Wr(O, S, false, true);
      return x ? R10 : !R10;
    });
  }
  if (y.length === 0 && o10 !== null)
    return B(g, "", 1);
  let w = y.map((x) => `${s10}${x}${i10}`).join(`
`), b = g + (w ? `${w}
` : "");
  return ge(b);
}
function tE(e11, t10) {
  let n10 = /* @__PURE__ */ new Set();
  for (let s10 of e11.state.env.keys()) {
    if (s10.includes("_") && /^[a-zA-Z_][a-zA-Z0-9_]*_\d+$/.test(s10) || s10.endsWith("__length"))
      continue;
    let i10 = s10.split("_")[0];
    /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s10) ? n10.add(s10) : i10 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(i10) && e11.state.env.has(`${i10}__length`) && n10.add(i10);
  }
  let r10 = Array.from(n10);
  return t10 !== null && (r10 = r10.filter((s10) => s10.startsWith(t10))), r10.sort();
}
function nE(e11, t10) {
  let n10 = e11.state.exportedVars ?? /* @__PURE__ */ new Set(), r10 = Array.from(n10);
  return t10 !== null && (r10 = r10.filter((s10) => s10.startsWith(t10))), r10 = r10.filter((s10) => s10.includes("_") && /^[a-zA-Z_][a-zA-Z0-9_]*_\d+$/.test(s10) || s10.endsWith("__length") ? false : e11.state.env.has(s10)), r10.sort();
}
function rE(e11, t10) {
  let n10 = Array.from(e11.state.functions.keys());
  return t10 !== null && (n10 = n10.filter((r10) => r10.startsWith(t10))), n10.sort();
}
function sE(e11) {
  let t10 = [...xc];
  return e11 !== null && (t10 = t10.filter((n10) => n10.startsWith(e11))), t10.sort();
}
function iE(e11) {
  let t10 = [...R6];
  return e11 !== null && (t10 = t10.filter((n10) => n10.startsWith(e11))), t10.sort();
}
function oE(e11, t10) {
  let n10 = [];
  for (let s10 of e11.state.env.keys())
    if (s10.startsWith("BASH_ALIAS_")) {
      let i10 = s10.slice(11);
      n10.push(i10);
    }
  let r10 = n10;
  return t10 !== null && (r10 = r10.filter((s10) => s10.startsWith(t10))), r10.sort();
}
function aE(e11) {
  let t10 = [...Jx];
  return e11 !== null && (t10 = t10.filter((n10) => n10.startsWith(e11))), t10.sort();
}
function lE(e11) {
  let t10 = [...eE];
  return e11 !== null && (t10 = t10.filter((n10) => n10.startsWith(e11))), t10.sort();
}
async function bc(e11, t10) {
  let n10 = [];
  try {
    let r10 = e11.state.cwd, s10 = t10 ?? "";
    if (t10) {
      let o10 = t10.lastIndexOf("/");
      if (o10 !== -1) {
        let a = t10.slice(0, o10) || "/";
        s10 = t10.slice(o10 + 1), a.startsWith("/") ? r10 = a : r10 = `${e11.state.cwd}/${a}`;
      }
    }
    let i10 = await e11.fs.readdir(r10);
    for (let o10 of i10) {
      let a = `${r10}/${o10}`;
      try {
        if ((await e11.fs.stat(a)).isDirectory && (!s10 || o10.startsWith(s10)))
          if (t10?.includes("/")) {
            let c = t10.lastIndexOf("/"), u = t10.slice(0, c + 1);
            n10.push(u + o10);
          } else
            n10.push(o10);
      } catch {
      }
    }
  } catch {
  }
  return n10.sort();
}
async function O6(e11, t10) {
  let n10 = [];
  try {
    let r10 = e11.state.cwd, s10 = t10 ?? "";
    if (t10) {
      let o10 = t10.lastIndexOf("/");
      if (o10 !== -1) {
        let a = t10.slice(0, o10) || "/";
        s10 = t10.slice(o10 + 1), a.startsWith("/") ? r10 = a : r10 = `${e11.state.cwd}/${a}`;
      }
    }
    let i10 = await e11.fs.readdir(r10);
    for (let o10 of i10)
      if (!s10 || o10.startsWith(s10))
        if (t10?.includes("/")) {
          let a = t10.lastIndexOf("/"), l = t10.slice(0, a + 1);
          n10.push(l + o10);
        } else
          n10.push(o10);
  } catch {
  }
  return n10.sort();
}
function cE(e11) {
  return ["root", "nobody"];
}
async function uE(e11, t10) {
  let n10 = /* @__PURE__ */ new Set();
  for (let i10 of xc)
    n10.add(i10);
  for (let i10 of e11.state.functions.keys())
    n10.add(i10);
  for (let i10 of e11.state.env.keys())
    i10.startsWith("BASH_ALIAS_") && n10.add(i10.slice(11));
  for (let i10 of R6)
    n10.add(i10);
  let r10 = e11.state.env.get("PATH") ?? "/usr/bin:/bin";
  for (let i10 of r10.split(":"))
    if (i10)
      try {
        let o10 = await e11.fs.readdir(i10);
        for (let a of o10)
          n10.add(a);
      } catch {
      }
  let s10 = Array.from(n10);
  return t10 !== null && (s10 = s10.filter((i10) => i10.startsWith(t10))), s10.sort();
}
async function fE(e11, t10) {
  let r10 = new ce().parseWordFromString(t10, false, false);
  return await ie(e11, r10);
}
function pE(e11, t10) {
  let n10 = e11.state.env.get("IFS") ?? ` 	
`;
  if (n10.length === 0)
    return [t10];
  let r10 = new Set(n10.split("")), s10 = [], i10 = "", o10 = 0;
  for (; o10 < t10.length; ) {
    let a = t10[o10];
    if (a === "\\" && o10 + 1 < t10.length) {
      let l = t10[o10 + 1];
      i10 += l, o10 += 2;
    } else
      r10.has(a) ? (i10.length > 0 && (s10.push(i10), i10 = ""), o10++) : (i10 += a, o10++);
  }
  return i10.length > 0 && s10.push(i10), s10;
}
function Hr(e11, t10) {
  for (let [n10, r10] of t10)
    r10 === void 0 ? e11.state.env.delete(n10) : e11.state.env.set(n10, r10);
}
function hE(e11) {
  let t10 = [];
  if (e11.state.env.get("COMPREPLY__length") !== void 0) {
    let s10 = ae(e11, "COMPREPLY");
    for (let [, i10] of s10)
      t10.push(i10);
  } else {
    let s10 = e11.state.env.get("COMPREPLY");
    s10 !== void 0 && t10.push(s10);
  }
  return t10;
}
var dE = ["bashdefault", "default", "dirnames", "filenames", "noquote", "nosort", "nospace", "plusdirs"];
function Sc(e11, t10) {
  e11.state.completionSpecs || (e11.state.completionSpecs = /* @__PURE__ */ new Map());
  let n10 = false, r10 = false, s10 = false, i10, o10, a, l = [], c = [], u = [];
  for (let f10 = 0; f10 < t10.length; f10++) {
    let p = t10[f10];
    if (p === "-p")
      n10 = true;
    else if (p === "-r")
      r10 = true;
    else if (p === "-D")
      s10 = true;
    else if (p === "-W") {
      if (f10++, f10 >= t10.length)
        return W(`complete: -W: option requires an argument
`, 2);
      i10 = t10[f10];
    } else if (p === "-F") {
      if (f10++, f10 >= t10.length)
        return W(`complete: -F: option requires an argument
`, 2);
      o10 = t10[f10];
    } else if (p === "-o") {
      if (f10++, f10 >= t10.length)
        return W(`complete: -o: option requires an argument
`, 2);
      let h = t10[f10];
      if (!dE.includes(h))
        return W(`complete: ${h}: invalid option name
`, 2);
      l.push(h);
    } else if (p === "-A") {
      if (f10++, f10 >= t10.length)
        return W(`complete: -A: option requires an argument
`, 2);
      c.push(t10[f10]);
    } else if (p === "-C") {
      if (f10++, f10 >= t10.length)
        return W(`complete: -C: option requires an argument
`, 2);
      a = t10[f10];
    } else if (p === "-G") {
      if (f10++, f10 >= t10.length)
        return W(`complete: -G: option requires an argument
`, 2);
    } else if (p === "-P") {
      if (f10++, f10 >= t10.length)
        return W(`complete: -P: option requires an argument
`, 2);
    } else if (p === "-S") {
      if (f10++, f10 >= t10.length)
        return W(`complete: -S: option requires an argument
`, 2);
    } else if (p === "-X") {
      if (f10++, f10 >= t10.length)
        return W(`complete: -X: option requires an argument
`, 2);
    } else if (p === "--") {
      u.push(...t10.slice(f10 + 1));
      break;
    } else
      p.startsWith("-") || u.push(p);
  }
  if (r10) {
    if (u.length === 0)
      return e11.state.completionSpecs.clear(), ge("");
    for (let f10 of u)
      e11.state.completionSpecs.delete(f10);
    return ge("");
  }
  if (n10)
    return u.length === 0 ? Ac(e11) : Ac(e11, u);
  if (t10.length === 0 || u.length === 0 && !i10 && !o10 && !a && l.length === 0 && c.length === 0 && !s10)
    return Ac(e11);
  if (o10 && u.length === 0 && !s10)
    return W(`complete: -F: option requires a command name
`, 2);
  if (s10) {
    let f10 = { isDefault: true };
    return i10 !== void 0 && (f10.wordlist = i10), o10 !== void 0 && (f10.function = o10), a !== void 0 && (f10.command = a), l.length > 0 && (f10.options = l), c.length > 0 && (f10.actions = c), e11.state.completionSpecs.set("__default__", f10), ge("");
  }
  for (let f10 of u) {
    let p = /* @__PURE__ */ Object.create(null);
    i10 !== void 0 && (p.wordlist = i10), o10 !== void 0 && (p.function = o10), a !== void 0 && (p.command = a), l.length > 0 && (p.options = l), c.length > 0 && (p.actions = c), e11.state.completionSpecs.set(f10, p);
  }
  return ge("");
}
function Ac(e11, t10) {
  let n10 = e11.state.completionSpecs;
  if (!n10 || n10.size === 0) {
    if (t10 && t10.length > 0) {
      let i10 = "";
      for (let o10 of t10)
        i10 += `complete: ${o10}: no completion specification
`;
      return B("", i10, 1);
    }
    return ge("");
  }
  let r10 = [], s10 = t10 || Array.from(n10.keys());
  for (let i10 of s10) {
    if (i10 === "__default__")
      continue;
    let o10 = n10.get(i10);
    if (!o10) {
      if (t10)
        return B(r10.join(`
`) + (r10.length > 0 ? `
` : ""), `complete: ${i10}: no completion specification
`, 1);
      continue;
    }
    let a = "complete";
    if (o10.options)
      for (let l of o10.options)
        a += ` -o ${l}`;
    if (o10.actions)
      for (let l of o10.actions)
        a += ` -A ${l}`;
    o10.wordlist !== void 0 && (o10.wordlist.includes(" ") || o10.wordlist.includes("'") ? a += ` -W '${o10.wordlist}'` : a += ` -W ${o10.wordlist}`), o10.function !== void 0 && (a += ` -F ${o10.function}`), o10.isDefault && (a += " -D"), a += ` ${i10}`, r10.push(a);
  }
  return r10.length === 0 ? ge("") : ge(`${r10.join(`
`)}
`);
}
var $6 = ["bashdefault", "default", "dirnames", "filenames", "noquote", "nosort", "nospace", "plusdirs"];
function Cc(e11, t10) {
  e11.state.completionSpecs || (e11.state.completionSpecs = /* @__PURE__ */ new Map());
  let n10 = false, r10 = false, s10 = [], i10 = [], o10 = [];
  for (let a = 0; a < t10.length; a++) {
    let l = t10[a];
    if (l === "-D")
      n10 = true;
    else if (l === "-E")
      r10 = true;
    else if (l === "-o") {
      if (a++, a >= t10.length)
        return W(`compopt: -o: option requires an argument
`, 2);
      let c = t10[a];
      if (!$6.includes(c))
        return W(`compopt: ${c}: invalid option name
`, 2);
      s10.push(c);
    } else if (l === "+o") {
      if (a++, a >= t10.length)
        return W(`compopt: +o: option requires an argument
`, 2);
      let c = t10[a];
      if (!$6.includes(c))
        return W(`compopt: ${c}: invalid option name
`, 2);
      i10.push(c);
    } else if (l === "--") {
      o10.push(...t10.slice(a + 1));
      break;
    } else
      !l.startsWith("-") && !l.startsWith("+") && o10.push(l);
  }
  if (n10) {
    let a = e11.state.completionSpecs.get("__default__") ?? { isDefault: true }, l = new Set(a.options ?? []);
    for (let c of s10)
      l.add(c);
    for (let c of i10)
      l.delete(c);
    return a.options = l.size > 0 ? Array.from(l) : void 0, e11.state.completionSpecs.set("__default__", a), ge("");
  }
  if (r10) {
    let a = e11.state.completionSpecs.get("__empty__") ?? {}, l = new Set(a.options ?? []);
    for (let c of s10)
      l.add(c);
    for (let c of i10)
      l.delete(c);
    return a.options = l.size > 0 ? Array.from(l) : void 0, e11.state.completionSpecs.set("__empty__", a), ge("");
  }
  if (o10.length > 0) {
    for (let a of o10) {
      let l = e11.state.completionSpecs.get(a) ?? {}, c = new Set(l.options ?? []);
      for (let u of s10)
        c.add(u);
      for (let u of i10)
        c.delete(u);
      l.options = c.size > 0 ? Array.from(c) : void 0, e11.state.completionSpecs.set(a, l);
    }
    return ge("");
  }
  return W(`compopt: not currently executing completion function
`, 1);
}
ye();
function Nc(e11, t10) {
  if (e11.state.loopDepth === 0) {
    if (e11.state.parentHasLoopContext)
      throw new an();
    return de;
  }
  if (t10.length > 1)
    throw new pe(1, "", `bash: continue: too many arguments
`);
  let n10 = 1;
  if (t10.length > 0) {
    let r10 = Number.parseInt(t10[0], 10);
    if (Number.isNaN(r10) || r10 < 1)
      throw new pe(1, "", `bash: continue: ${t10[0]}: numeric argument required
`);
    n10 = r10;
  }
  throw new pt(n10);
}
dt();
Ke();
St();
Qt();
tn();
Fn();
function Ve(e11, t10) {
  let n10 = e11.state.env.get("HOME") || "/home/user";
  return t10.split(":").map((i10) => i10 === "~" ? n10 : i10 === "~root" ? "/root" : i10.startsWith("~/") ? n10 + i10.slice(1) : i10.startsWith("~root/") ? `/root${i10.slice(5)}` : i10).join(":");
}
Qt();
tn();
function kc(e11) {
  for (let t10 = 0; t10 < e11.length; t10++) {
    let n10 = e11.charCodeAt(t10);
    if (n10 < 32 || n10 === 127)
      return true;
  }
  return false;
}
function vc(e11) {
  let t10 = "$'";
  for (let n10 = 0; n10 < e11.length; n10++) {
    let r10 = e11[n10], s10 = e11.charCodeAt(n10);
    s10 === 7 ? t10 += "\\a" : s10 === 8 ? t10 += "\\b" : s10 === 9 ? t10 += "\\t" : s10 === 10 ? t10 += "\\n" : s10 === 11 ? t10 += "\\v" : s10 === 12 ? t10 += "\\f" : s10 === 13 ? t10 += "\\r" : s10 === 27 ? t10 += "\\e" : s10 === 39 ? t10 += "\\'" : s10 === 92 ? t10 += "\\\\" : s10 < 32 || s10 === 127 ? t10 += `\\${s10.toString(8).padStart(3, "0")}` : t10 += r10;
  }
  return t10 += "'", t10;
}
function Eo(e11) {
  return kc(e11) ? vc(e11) : /^[a-zA-Z0-9_/.:\-@%+,=]*$/.test(e11) ? e11 : `'${e11.replace(/'/g, "'\\''")}'`;
}
function or(e11) {
  return kc(e11) ? vc(e11) : `"${e11.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function Ic(e11) {
  return kc(e11) ? vc(e11) : `"${e11.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function T6(e11, t10) {
  let n10 = "";
  return e11.state.integerVars?.has(t10) && (n10 += "i"), e11.state.lowercaseVars?.has(t10) && (n10 += "l"), Te(e11, t10) && (n10 += "n"), e11.state.readonlyVars?.has(t10) && (n10 += "r"), e11.state.uppercaseVars?.has(t10) && (n10 += "u"), e11.state.exportedVars?.has(t10) && (n10 += "x"), n10 === "" ? "--" : `-${n10}`;
}
function Oc(e11) {
  return e11 === "" ? "''" : /[\s'\\]/.test(e11) ? `'${e11.replace(/'/g, "'\\''")}'` : e11;
}
function P6(e11, t10) {
  let n10 = "", r10 = "", s10 = false;
  for (let i10 of t10) {
    let o10 = T6(e11, i10);
    if (e11.state.associativeArrays?.has(i10)) {
      let u = en(e11, i10);
      if (u.length === 0)
        n10 += `declare -A ${i10}=()
`;
      else {
        let f10 = u.map((p) => {
          let h = e11.state.env.get(`${i10}_${p}`) ?? "", m = Oc(h);
          return `['${p}']=${m}`;
        });
        n10 += `declare -A ${i10}=(${f10.join(" ")})
`;
      }
      continue;
    }
    let l = Xe(e11, i10);
    if (l.length > 0) {
      let u = l.map((f10) => {
        let p = e11.state.env.get(`${i10}_${f10}`) ?? "";
        return `[${f10}]=${or(p)}`;
      });
      n10 += `declare -a ${i10}=(${u.join(" ")})
`;
      continue;
    }
    if (e11.state.env.has(`${i10}__length`)) {
      n10 += `declare -a ${i10}=()
`;
      continue;
    }
    let c = e11.state.env.get(i10);
    if (c !== void 0)
      n10 += `declare ${o10} ${i10}=${Ic(c)}
`;
    else {
      let u = e11.state.declaredVars?.has(i10), f10 = e11.state.localVarDepth?.has(i10);
      u || f10 ? n10 += `declare ${o10} ${i10}
` : (r10 += `bash: declare: ${i10}: not found
`, s10 = true);
    }
  }
  return B(n10, r10, s10 ? 1 : 0);
}
function D6(e11, t10) {
  let { filterExport: n10, filterReadonly: r10, filterNameref: s10, filterIndexedArray: i10, filterAssocArray: o10 } = t10, a = n10 || r10 || s10 || i10 || o10, l = "", c = /* @__PURE__ */ new Set();
  for (let f10 of e11.state.env.keys()) {
    if (f10.startsWith("BASH_"))
      continue;
    if (f10.endsWith("__length")) {
      let h = f10.slice(0, -8);
      c.add(h);
      continue;
    }
    let p = f10.lastIndexOf("_");
    if (p > 0) {
      let h = f10.slice(0, p), m = f10.slice(p + 1);
      if (/^\d+$/.test(m) || e11.state.associativeArrays?.has(h)) {
        c.add(h);
        continue;
      }
    }
    c.add(f10);
  }
  if (e11.state.localVarDepth)
    for (let f10 of e11.state.localVarDepth.keys())
      c.add(f10);
  if (e11.state.associativeArrays)
    for (let f10 of e11.state.associativeArrays)
      c.add(f10);
  let u = Array.from(c).sort();
  for (let f10 of u) {
    let p = T6(e11, f10), h = e11.state.associativeArrays?.has(f10), m = Xe(e11, f10), d = !h && (m.length > 0 || e11.state.env.has(`${f10}__length`));
    if (a && (o10 && !h || i10 && !d || n10 && !e11.state.exportedVars?.has(f10) || r10 && !e11.state.readonlyVars?.has(f10) || s10 && !Te(e11, f10)))
      continue;
    if (h) {
      let y = en(e11, f10);
      if (y.length === 0)
        l += `declare -A ${f10}=()
`;
      else {
        let w = y.map((b) => {
          let x = e11.state.env.get(`${f10}_${b}`) ?? "", S = Oc(x);
          return `['${b}']=${S}`;
        });
        l += `declare -A ${f10}=(${w.join(" ")})
`;
      }
      continue;
    }
    if (m.length > 0) {
      let y = m.map((w) => {
        let b = e11.state.env.get(`${f10}_${w}`) ?? "";
        return `[${w}]=${or(b)}`;
      });
      l += `declare -a ${f10}=(${y.join(" ")})
`;
      continue;
    }
    if (e11.state.env.has(`${f10}__length`)) {
      l += `declare -a ${f10}=()
`;
      continue;
    }
    let g = e11.state.env.get(f10);
    g !== void 0 && (l += `declare ${p} ${f10}=${Ic(g)}
`);
  }
  return ge(l);
}
function _6(e11) {
  let t10 = "", n10 = Array.from(e11.state.associativeArrays ?? []).sort();
  for (let r10 of n10) {
    let s10 = en(e11, r10);
    if (s10.length === 0)
      t10 += `declare -A ${r10}=()
`;
    else {
      let i10 = s10.map((o10) => {
        let a = e11.state.env.get(`${r10}_${o10}`) ?? "", l = Oc(a);
        return `['${o10}']=${l}`;
      });
      t10 += `declare -A ${r10}=(${i10.join(" ")})
`;
    }
  }
  return ge(t10);
}
function L6(e11) {
  let t10 = "", n10 = /* @__PURE__ */ new Set();
  for (let s10 of e11.state.env.keys()) {
    if (s10.startsWith("BASH_"))
      continue;
    if (s10.endsWith("__length")) {
      let o10 = s10.slice(0, -8);
      e11.state.associativeArrays?.has(o10) || n10.add(o10);
      continue;
    }
    let i10 = s10.lastIndexOf("_");
    if (i10 > 0) {
      let o10 = s10.slice(0, i10), a = s10.slice(i10 + 1);
      /^\d+$/.test(a) && (e11.state.associativeArrays?.has(o10) || n10.add(o10));
    }
  }
  let r10 = Array.from(n10).sort();
  for (let s10 of r10) {
    let i10 = Xe(e11, s10);
    if (i10.length === 0)
      t10 += `declare -a ${s10}=()
`;
    else {
      let o10 = i10.map((a) => {
        let l = e11.state.env.get(`${s10}_${a}`) ?? "";
        return `[${a}]=${or(l)}`;
      });
      t10 += `declare -a ${s10}=(${o10.join(" ")})
`;
    }
  }
  return ge(t10);
}
function F6(e11) {
  let t10 = "", n10 = /* @__PURE__ */ new Set();
  for (let s10 of e11.state.env.keys()) {
    if (s10.startsWith("BASH_"))
      continue;
    if (s10.endsWith("__length")) {
      let o10 = s10.slice(0, -8);
      n10.add(o10);
      continue;
    }
    let i10 = s10.lastIndexOf("_");
    if (i10 > 0) {
      let o10 = s10.slice(0, i10), a = s10.slice(i10 + 1);
      if (/^\d+$/.test(a) || e11.state.associativeArrays?.has(o10)) {
        n10.add(o10);
        continue;
      }
    }
    n10.add(s10);
  }
  let r10 = Array.from(n10).sort();
  for (let s10 of r10) {
    if (e11.state.associativeArrays?.has(s10) || Xe(e11, s10).length > 0 || e11.state.env.has(`${s10}__length`))
      continue;
    let a = e11.state.env.get(s10);
    a !== void 0 && (t10 += `${s10}=${Eo(a)}
`);
  }
  return ge(t10);
}
function Rc(e11, t10) {
  e11.state.integerVars ??= /* @__PURE__ */ new Set(), e11.state.integerVars.add(t10);
}
function vs(e11, t10) {
  return e11.state.integerVars?.has(t10) ?? false;
}
function $c(e11, t10) {
  e11.state.lowercaseVars ??= /* @__PURE__ */ new Set(), e11.state.lowercaseVars.add(t10), e11.state.uppercaseVars?.delete(t10);
}
function mE(e11, t10) {
  return e11.state.lowercaseVars?.has(t10) ?? false;
}
function Tc(e11, t10) {
  e11.state.uppercaseVars ??= /* @__PURE__ */ new Set(), e11.state.uppercaseVars.add(t10), e11.state.lowercaseVars?.delete(t10);
}
function gE(e11, t10) {
  return e11.state.uppercaseVars?.has(t10) ?? false;
}
function jr(e11, t10, n10) {
  return mE(e11, t10) ? n10.toLowerCase() : gE(e11, t10) ? n10.toUpperCase() : n10;
}
async function M6(e11, t10) {
  try {
    let n10 = new ce(), r10 = Ae(n10, t10), s10 = await ne(e11, r10.expression);
    return String(s10);
  } catch {
    return "0";
  }
}
function yE(e11) {
  let t10 = e11.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
  if (!t10)
    return null;
  let n10 = t10[0], r10 = n10.length;
  if (e11[r10] !== "[")
    return null;
  let s10 = 0, i10 = r10 + 1;
  for (; r10 < e11.length; r10++)
    if (e11[r10] === "[")
      s10++;
    else if (e11[r10] === "]" && (s10--, s10 === 0))
      break;
  if (s10 !== 0)
    return null;
  let o10 = e11.slice(i10, r10);
  if (r10++, e11[r10] !== "=")
    return null;
  r10++;
  let a = e11.slice(r10);
  return { name: n10, indexExpr: o10, value: a };
}
async function Pc(e11, t10) {
  let n10 = false, r10 = false, s10 = false, i10 = false, o10 = false, a = false, l = false, c = false, u = false, f10 = false, p = false, h = false, m = false, d = false, g = false, y = [];
  for (let $ = 0; $ < t10.length; $++) {
    let z = t10[$];
    if (z === "-a")
      n10 = true;
    else if (z === "-A")
      r10 = true;
    else if (z === "-r")
      s10 = true;
    else if (z === "-x")
      i10 = true;
    else if (z === "-p")
      o10 = true;
    else if (z === "-n")
      a = true;
    else if (z === "+n")
      l = true;
    else if (z === "+a")
      c = true;
    else if (z === "+x")
      u = true;
    else if (z === "--") {
      y.push(...t10.slice($ + 1));
      break;
    } else if (z.startsWith("+")) {
      for (let k of z.slice(1))
        if (k === "n")
          l = true;
        else if (k === "a")
          c = true;
        else if (k === "x")
          u = true;
        else if (k !== "r") {
          if (k !== "i") {
            if (!(k === "f" || k === "F"))
              return B("", `bash: typeset: +${k}: invalid option
`, 2);
          }
        }
    } else if (z === "-i")
      f10 = true;
    else if (z === "-l")
      p = true;
    else if (z === "-u")
      h = true;
    else if (z === "-f")
      m = true;
    else if (z === "-F")
      d = true;
    else if (z === "-g")
      g = true;
    else if (z.startsWith("-"))
      for (let k of z.slice(1))
        if (k === "a")
          n10 = true;
        else if (k === "A")
          r10 = true;
        else if (k === "r")
          s10 = true;
        else if (k === "x")
          i10 = true;
        else if (k === "p")
          o10 = true;
        else if (k === "n")
          a = true;
        else if (k === "i")
          f10 = true;
        else if (k === "l")
          p = true;
        else if (k === "u")
          h = true;
        else if (k === "f")
          m = true;
        else if (k === "F")
          d = true;
        else if (k === "g")
          g = true;
        else
          return B("", `bash: typeset: -${k}: invalid option
`, 2);
    else
      y.push(z);
  }
  let b = e11.state.localScopes.length > 0 && !g, x = ($) => {
    if (!b)
      return;
    let z = e11.state.localScopes[e11.state.localScopes.length - 1];
    z.has($) || z.set($, e11.state.env.get($));
  }, S = ($) => {
    if (!b)
      return;
    let z = e11.state.localScopes[e11.state.localScopes.length - 1];
    z.has($) || z.set($, e11.state.env.get($));
    let k = `${$}_`;
    for (let P of e11.state.env.keys())
      P.startsWith(k) && !P.includes("__") && (z.has(P) || z.set(P, e11.state.env.get(P)));
    let N10 = `${$}__length`;
    e11.state.env.has(N10) && !z.has(N10) && z.set(N10, e11.state.env.get(N10));
  }, O = ($) => {
    b && Wn(e11, $);
  };
  if (d) {
    if (y.length === 0) {
      let k = Array.from(e11.state.functions.keys()).sort(), N10 = "";
      for (let P of k)
        N10 += `declare -f ${P}
`;
      return ge(N10);
    }
    let $ = true, z = "";
    for (let k of y)
      e11.state.functions.has(k) ? z += `${k}
` : $ = false;
    return B(z, "", $ ? 0 : 1);
  }
  if (m) {
    if (y.length === 0) {
      let z = "", k = Array.from(e11.state.functions.keys()).sort();
      for (let N10 of k)
        z += `${N10} ()
{
    # function body
}
`;
      return ge(z);
    }
    let $ = true;
    for (let z of y)
      e11.state.functions.has(z) || ($ = false);
    return B("", "", $ ? 0 : 1);
  }
  if (o10 && y.length > 0)
    return P6(e11, y);
  if (o10 && y.length === 0)
    return D6(e11, { filterExport: i10, filterReadonly: s10, filterNameref: a, filterIndexedArray: n10, filterAssocArray: r10 });
  if (y.length === 0 && r10 && !o10)
    return _6(e11);
  if (y.length === 0 && n10 && !o10)
    return L6(e11);
  if (y.length === 0 && !o10)
    return F6(e11);
  let R10 = "", F4 = 0;
  for (let $ of y) {
    let z = $.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
    if (z && !c) {
      let v = z[1], T = z[2];
      if (r10 && Xe(e11, v).length > 0) {
        R10 += `bash: declare: ${v}: cannot convert indexed to associative array
`, F4 = 1;
        continue;
      }
      if ((n10 || !r10 && !n10) && e11.state.associativeArrays?.has(v)) {
        R10 += `bash: declare: ${v}: cannot convert associative to indexed array
`, F4 = 1;
        continue;
      }
      if (S(v), r10 && (e11.state.associativeArrays ??= /* @__PURE__ */ new Set(), e11.state.associativeArrays.add(v)), dn(e11, v), e11.state.env.delete(v), e11.state.env.delete(`${v}__length`), r10 && T.includes("[")) {
        let L = go(T);
        for (let [ue, re] of L) {
          let J = Ve(e11, re);
          e11.state.env.set(`${v}_${ue}`, J);
        }
      } else if (r10) {
        let L = wn(T);
        for (let ue = 0; ue < L.length; ue += 2) {
          let re = L[ue], J = ue + 1 < L.length ? Ve(e11, L[ue + 1]) : "";
          e11.state.env.set(`${v}_${re}`, J);
        }
      } else {
        let L = wn(T);
        if (L.some((re) => /^\[[^\]]+\]=/.test(re))) {
          let re = 0;
          for (let J of L) {
            let H = J.match(/^\[([^\]]+)\]=(.*)$/);
            if (H) {
              let X = H[1], Ee = H[2], oe = Ve(e11, Ee), ke;
              if (/^-?\d+$/.test(X))
                ke = Number.parseInt(X, 10);
              else
                try {
                  let j = new ce(), ve = Ae(j, X);
                  ke = await ne(e11, ve.expression);
                } catch {
                  ke = 0;
                }
              e11.state.env.set(`${v}_${ke}`, oe), re = ke + 1;
            } else {
              let X = Ve(e11, J);
              e11.state.env.set(`${v}_${re}`, X), re++;
            }
          }
        } else {
          for (let re = 0; re < L.length; re++)
            e11.state.env.set(`${v}_${re}`, L[re]);
          e11.state.env.set(`${v}__length`, String(L.length));
        }
      }
      O(v), s10 && Dt(e11, v), i10 && nn(e11, v);
      continue;
    }
    if (l) {
      let v = $.includes("=") ? $.slice(0, $.indexOf("=")) : $;
      if (Bm(e11, v), !$.includes("="))
        continue;
    }
    if (u) {
      let v = $.includes("=") ? $.slice(0, $.indexOf("=")) : $;
      if (Ki(e11, v), !$.includes("="))
        continue;
    }
    let k = yE($);
    if (k) {
      let { name: v, indexExpr: T, value: L } = k, ue = st(e11, v);
      if (ue)
        return ue;
      S(v);
      let re;
      try {
        let H = new ce(), X = Ae(H, T);
        re = await ne(e11, X.expression);
      } catch {
        let H = parseInt(T, 10);
        re = Number.isNaN(H) ? 0 : H;
      }
      e11.state.env.set(`${v}_${re}`, L);
      let J = parseInt(e11.state.env.get(`${v}__length`) ?? "0", 10);
      re >= J && e11.state.env.set(`${v}__length`, String(re + 1)), O(v), s10 && Dt(e11, v), i10 && nn(e11, v);
      continue;
    }
    let N10 = $.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
    if (N10 && !c) {
      let v = N10[1], T = N10[2], L = st(e11, v);
      if (L)
        return L;
      S(v);
      let ue = wn(T);
      if (e11.state.associativeArrays?.has(v)) {
        let re = go(T);
        for (let [J, H] of re) {
          let X = Ve(e11, H);
          e11.state.env.set(`${v}_${J}`, X);
        }
      } else {
        let re = Xe(e11, v), J = 0, H = e11.state.env.get(v);
        re.length === 0 && H !== void 0 ? (e11.state.env.set(`${v}_0`, H), e11.state.env.delete(v), J = 1) : re.length > 0 && (J = Math.max(...re) + 1);
        for (let Ee = 0; Ee < ue.length; Ee++)
          e11.state.env.set(`${v}_${J + Ee}`, Ve(e11, ue[Ee]));
        let X = J + ue.length;
        e11.state.env.set(`${v}__length`, String(X));
      }
      O(v), s10 && Dt(e11, v), i10 && nn(e11, v);
      continue;
    }
    let P = $.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (P) {
      let v = P[1], T = Ve(e11, P[2]), L = st(e11, v);
      if (L)
        return L;
      x(v), f10 && Rc(e11, v), p && $c(e11, v), h && Tc(e11, v);
      let re = Xe(e11, v).length > 0 || e11.state.associativeArrays?.has(v);
      if (vs(e11, v)) {
        let J = e11.state.env.get(v) ?? "0", H = parseInt(J, 10) || 0, X = parseInt(await M6(e11, T), 10) || 0;
        T = String(H + X), e11.state.env.set(v, T);
      } else if (re) {
        T = jr(e11, v, T);
        let J = `${v}_0`, H = e11.state.env.get(J) ?? "";
        e11.state.env.set(J, H + T);
      } else {
        T = jr(e11, v, T);
        let J = e11.state.env.get(v) ?? "";
        e11.state.env.set(v, J + T);
      }
      O(v), s10 && Dt(e11, v), i10 && nn(e11, v), e11.state.options.allexport && !u && (e11.state.exportedVars = e11.state.exportedVars || /* @__PURE__ */ new Set(), e11.state.exportedVars.add(v));
      continue;
    }
    if ($.includes("=")) {
      let v = $.indexOf("="), T = $.slice(0, v), L = $.slice(v + 1);
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(T)) {
        R10 += `bash: typeset: \`${T}': not a valid identifier
`, F4 = 1;
        continue;
      }
      let ue = st(e11, T);
      if (ue)
        return ue;
      if (x(T), a) {
        if (L !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(L)) {
          R10 += `bash: declare: \`${L}': invalid variable name for name reference
`, F4 = 1;
          continue;
        }
        e11.state.env.set(T, L), Sn(e11, T), L !== "" && Zi(e11, L) && Xl(e11, T), O(T), s10 && Dt(e11, T), i10 && nn(e11, T);
        continue;
      }
      if (f10 && Rc(e11, T), p && $c(e11, T), h && Tc(e11, T), vs(e11, T) && (L = await M6(e11, L)), L = jr(e11, T, L), Te(e11, T)) {
        let re = At(e11, T);
        re && re !== T ? e11.state.env.set(re, L) : e11.state.env.set(T, L);
      } else
        e11.state.env.set(T, L);
      O(T), s10 && Dt(e11, T), i10 && nn(e11, T), e11.state.options.allexport && !u && (e11.state.exportedVars = e11.state.exportedVars || /* @__PURE__ */ new Set(), e11.state.exportedVars.add(T));
    } else {
      let v = $;
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(v)) {
        R10 += `bash: typeset: \`${v}': not a valid identifier
`, F4 = 1;
        continue;
      }
      if (n10 || r10 ? S(v) : x(v), a) {
        Sn(e11, v);
        let L = e11.state.env.get(v);
        L !== void 0 && L !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(L) ? zm(e11, v) : L && Zi(e11, L) && Xl(e11, v), O(v), s10 && Dt(e11, v), i10 && nn(e11, v);
        continue;
      }
      if (f10 && Rc(e11, v), p && $c(e11, v), h && Tc(e11, v), r10) {
        if (Xe(e11, v).length > 0) {
          R10 += `bash: declare: ${v}: cannot convert indexed to associative array
`, F4 = 1;
          continue;
        }
        e11.state.associativeArrays ??= /* @__PURE__ */ new Set(), e11.state.associativeArrays.add(v);
      }
      let T = Array.from(e11.state.env.keys()).some((L) => L.startsWith(`${v}_`) && !L.startsWith(`${v}__length`));
      !e11.state.env.has(v) && !T && (n10 || r10 ? e11.state.env.set(`${v}__length`, "0") : (e11.state.declaredVars ??= /* @__PURE__ */ new Set(), e11.state.declaredVars.add(v))), O(v), s10 && Dt(e11, v), i10 && nn(e11, v);
    }
  }
  return B("", R10, F4);
}
async function Dc(e11, t10) {
  let n10 = false, r10 = false, s10 = false, i10 = [];
  for (let o10 = 0; o10 < t10.length; o10++) {
    let a = t10[o10];
    if (a === "-a")
      n10 = true;
    else if (a === "-A")
      r10 = true;
    else if (a === "-p")
      s10 = true;
    else if (a === "--") {
      i10.push(...t10.slice(o10 + 1));
      break;
    } else
      a.startsWith("-") || i10.push(a);
  }
  if (i10.length === 0) {
    let o10 = "", a = Array.from(e11.state.readonlyVars || []).sort();
    for (let l of a) {
      let c = e11.state.env.get(l);
      if (c !== void 0) {
        let u = c.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        o10 += `declare -r ${l}="${u}"
`;
      }
    }
    return ge(o10);
  }
  for (let o10 of i10) {
    let a = o10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
    if (a) {
      let f10 = a[1], p = a[2], h = st(e11, f10);
      if (h)
        return h;
      let m = wn(p);
      if (e11.state.associativeArrays?.has(f10)) {
        let d = go(p);
        for (let [g, y] of d) {
          let w = Ve(e11, y);
          e11.state.env.set(`${f10}_${g}`, w);
        }
      } else {
        let d = Xe(e11, f10), g = 0, y = e11.state.env.get(f10);
        d.length === 0 && y !== void 0 ? (e11.state.env.set(`${f10}_0`, y), e11.state.env.delete(f10), g = 1) : d.length > 0 && (g = Math.max(...d) + 1);
        for (let b = 0; b < m.length; b++)
          e11.state.env.set(`${f10}_${g + b}`, Ve(e11, m[b]));
        let w = g + m.length;
        e11.state.env.set(`${f10}__length`, String(w));
      }
      Dt(e11, f10);
      continue;
    }
    let l = o10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (l) {
      let f10 = l[1], p = Ve(e11, l[2]), h = st(e11, f10);
      if (h)
        return h;
      let m = e11.state.env.get(f10) ?? "";
      e11.state.env.set(f10, m + p), Dt(e11, f10);
      continue;
    }
    let c = A6(o10);
    if (c.value === void 0 && !c.isArray) {
      Dt(e11, c.name);
      continue;
    }
    let u = await S6(e11, c, { makeReadonly: true });
    if (u)
      return u;
  }
  return de;
}
function _c2(e11) {
  return e11.state.directoryStack ??= [], e11.state.directoryStack;
}
function Is(e11, t10) {
  return t10 && e11 === t10 ? "~" : t10 && e11.startsWith(`${t10}/`) ? `~${e11.slice(t10.length)}` : e11;
}
function wE(e11) {
  let t10 = e11.split("/").filter((r10) => r10 && r10 !== "."), n10 = [];
  for (let r10 of t10)
    r10 === ".." ? n10.pop() : n10.push(r10);
  return `/${n10.join("/")}`;
}
async function Lc(e11, t10) {
  let n10 = _c2(e11), r10;
  for (let a = 0; a < t10.length; a++) {
    let l = t10[a];
    if (l === "--") {
      if (a + 1 < t10.length) {
        if (r10 !== void 0)
          return W(`bash: pushd: too many arguments
`, 2);
        r10 = t10[a + 1], a++;
      }
    } else {
      if (l.startsWith("-") && l !== "-")
        return W(`bash: pushd: ${l}: invalid option
`, 2);
      if (r10 !== void 0)
        return W(`bash: pushd: too many arguments
`, 2);
      r10 = l;
    }
  }
  if (r10 === void 0) {
    if (n10.length < 2)
      return W(`bash: pushd: no other directory
`, 1);
    let a = n10[0];
    n10[0] = n10[1], n10[1] = a, r10 = n10[0];
  }
  let s10;
  if (r10.startsWith("/"))
    s10 = r10;
  else if (r10 === "..") {
    let a = e11.state.cwd.split("/").filter((l) => l);
    a.pop(), s10 = `/${a.join("/")}`;
  } else
    r10 === "." ? s10 = e11.state.cwd : r10.startsWith("~") ? s10 = (e11.state.env.get("HOME") || "/") + r10.slice(1) : s10 = `${e11.state.cwd}/${r10}`;
  s10 = wE(s10);
  try {
    if (!(await e11.fs.stat(s10)).isDirectory)
      return W(`bash: pushd: ${r10}: Not a directory
`, 1);
  } catch {
    return W(`bash: pushd: ${r10}: No such file or directory
`, 1);
  }
  n10.unshift(e11.state.cwd), e11.state.previousDir = e11.state.cwd, e11.state.cwd = s10, e11.state.env.set("PWD", s10), e11.state.env.set("OLDPWD", e11.state.previousDir);
  let i10 = e11.state.env.get("HOME") || "", o10 = `${[s10, ...n10].map((a) => Is(a, i10)).join(" ")}
`;
  return ge(o10);
}
function Fc(e11, t10) {
  let n10 = _c2(e11);
  for (let o10 of t10)
    if (o10 !== "--")
      return o10.startsWith("-") && o10 !== "-" ? W(`bash: popd: ${o10}: invalid option
`, 2) : W(`bash: popd: too many arguments
`, 2);
  if (n10.length === 0)
    return W(`bash: popd: directory stack empty
`, 1);
  let r10 = n10.shift();
  if (!r10)
    return W(`bash: popd: directory stack empty
`, 1);
  e11.state.previousDir = e11.state.cwd, e11.state.cwd = r10, e11.state.env.set("PWD", r10), e11.state.env.set("OLDPWD", e11.state.previousDir);
  let s10 = e11.state.env.get("HOME") || "", i10 = `${[r10, ...n10].map((o10) => Is(o10, s10)).join(" ")}
`;
  return ge(i10);
}
function Mc(e11, t10) {
  let n10 = _c2(e11), r10 = false, s10 = false, i10 = false, o10 = false;
  for (let u of t10)
    if (u !== "--")
      if (u.startsWith("-"))
        for (let f10 of u.slice(1))
          if (f10 === "c")
            r10 = true;
          else if (f10 === "l")
            s10 = true;
          else if (f10 === "p")
            i10 = true;
          else if (f10 === "v")
            i10 = true, o10 = true;
          else
            return W(`bash: dirs: -${f10}: invalid option
`, 2);
      else
        return W(`bash: dirs: too many arguments
`, 1);
  if (r10)
    return e11.state.directoryStack = [], de;
  let a = [e11.state.cwd, ...n10], l = e11.state.env.get("HOME") || "", c;
  return o10 ? (c = a.map((u, f10) => {
    let p = s10 ? u : Is(u, l);
    return ` ${f10}  ${p}`;
  }).join(`
`), c += `
`) : i10 ? c = a.map((u) => s10 ? u : Is(u, l)).join(`
`) + `
` : c = a.map((u) => s10 ? u : Is(u, l)).join(" ") + `
`, ge(c);
}
Ke();
ye();
async function Ao(e11, t10, n10) {
  let r10 = t10;
  if (r10.length > 0) {
    let a = r10[0];
    if (a === "--")
      r10 = r10.slice(1);
    else if (a.startsWith("-") && a !== "-" && a.length > 1)
      return W(`bash: eval: ${a}: invalid option
eval: usage: eval [arg ...]
`, 2);
  }
  if (r10.length === 0)
    return de;
  let s10 = r10.join(" ");
  if (s10.trim() === "")
    return de;
  let i10 = e11.state.groupStdin, o10 = n10 ?? e11.state.groupStdin;
  o10 !== void 0 && (e11.state.groupStdin = o10);
  try {
    let a = hn(s10);
    return await e11.executeScript(a);
  } catch (a) {
    if (a instanceof ft || a instanceof pt || a instanceof at || a instanceof pe)
      throw a;
    if (a.name === "ParseException")
      return W(`bash: eval: ${a.message}
`);
    throw a;
  } finally {
    e11.state.groupStdin = i10;
  }
}
ye();
function Uc(e11, t10) {
  let n10, r10 = "";
  if (t10.length === 0)
    n10 = e11.state.lastExitCode;
  else {
    let s10 = t10[0], i10 = Number.parseInt(s10, 10);
    s10 === "" || Number.isNaN(i10) || !/^-?\d+$/.test(s10) ? (r10 = `bash: exit: ${s10}: numeric argument required
`, n10 = 2) : n10 = (i10 % 256 + 256) % 256;
  }
  throw new pe(n10, "", r10);
}
Fn();
function Wc(e11, t10) {
  let n10 = false, r10 = [];
  for (let o10 of t10)
    o10 === "-n" ? n10 = true : o10 === "-p" || o10 === "--" || r10.push(o10);
  if (r10.length === 0 && !n10) {
    let o10 = "", a = e11.state.exportedVars ?? /* @__PURE__ */ new Set(), l = Array.from(a).sort();
    for (let c of l) {
      let u = e11.state.env.get(c);
      if (u !== void 0) {
        let f10 = u.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        o10 += `declare -x ${c}="${f10}"
`;
      }
    }
    return ge(o10);
  }
  if (n10) {
    for (let o10 of r10) {
      let a, l;
      if (o10.includes("=")) {
        let c = o10.indexOf("=");
        a = o10.slice(0, c), l = Ve(e11, o10.slice(c + 1)), e11.state.env.set(a, l);
      } else
        a = o10;
      Ki(e11, a);
    }
    return de;
  }
  let s10 = "", i10 = 0;
  for (let o10 of r10) {
    let a, l, c = false, u = o10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (u)
      a = u[1], l = Ve(e11, u[2]), c = true;
    else if (o10.includes("=")) {
      let f10 = o10.indexOf("=");
      a = o10.slice(0, f10), l = Ve(e11, o10.slice(f10 + 1));
    } else
      a = o10;
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(a)) {
      s10 += `bash: export: \`${o10}': not a valid identifier
`, i10 = 1;
      continue;
    }
    if (l !== void 0)
      if (c) {
        let f10 = e11.state.env.get(a) ?? "";
        e11.state.env.set(a, f10 + l);
      } else
        e11.state.env.set(a, l);
    else
      e11.state.env.has(a) || e11.state.env.set(a, "");
    nn(e11, a);
  }
  return B("", s10, i10);
}
function So(e11, t10) {
  if (t10.length < 2)
    return W(`bash: getopts: usage: getopts optstring name [arg ...]
`);
  let n10 = t10[0], r10 = t10[1], s10 = !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r10), i10 = n10.startsWith(":"), o10 = i10 ? n10.slice(1) : n10, a;
  if (t10.length > 2)
    a = t10.slice(2);
  else {
    let d = Number.parseInt(e11.state.env.get("#") || "0", 10);
    a = [];
    for (let g = 1; g <= d; g++)
      a.push(e11.state.env.get(String(g)) || "");
  }
  let l = Number.parseInt(e11.state.env.get("OPTIND") || "1", 10);
  l < 1 && (l = 1);
  let c = Number.parseInt(e11.state.env.get("__GETOPTS_CHARINDEX") || "0", 10);
  if (e11.state.env.set("OPTARG", ""), l > a.length)
    return s10 || e11.state.env.set(r10, "?"), e11.state.env.set("OPTIND", String(a.length + 1)), e11.state.env.set("__GETOPTS_CHARINDEX", "0"), { exitCode: s10 ? 2 : 1, stdout: "", stderr: "" };
  let u = a[l - 1];
  if (!u || u === "-" || !u.startsWith("-"))
    return s10 || e11.state.env.set(r10, "?"), { exitCode: s10 ? 2 : 1, stdout: "", stderr: "" };
  if (u === "--")
    return e11.state.env.set("OPTIND", String(l + 1)), e11.state.env.set("__GETOPTS_CHARINDEX", "0"), s10 || e11.state.env.set(r10, "?"), { exitCode: s10 ? 2 : 1, stdout: "", stderr: "" };
  let f10 = c === 0 ? 1 : c, p = u[f10];
  if (!p)
    return e11.state.env.set("OPTIND", String(l + 1)), e11.state.env.set("__GETOPTS_CHARINDEX", "0"), So(e11, t10);
  let h = o10.indexOf(p);
  if (h === -1) {
    let d = "";
    return i10 ? e11.state.env.set("OPTARG", p) : d = `bash: illegal option -- ${p}
`, s10 || e11.state.env.set(r10, "?"), f10 + 1 < u.length ? (e11.state.env.set("__GETOPTS_CHARINDEX", String(f10 + 1)), e11.state.env.set("OPTIND", String(l))) : (e11.state.env.set("OPTIND", String(l + 1)), e11.state.env.set("__GETOPTS_CHARINDEX", "0")), { exitCode: s10 ? 2 : 0, stdout: "", stderr: d };
  }
  if (h + 1 < o10.length && o10[h + 1] === ":")
    if (f10 + 1 < u.length)
      e11.state.env.set("OPTARG", u.slice(f10 + 1)), e11.state.env.set("OPTIND", String(l + 1)), e11.state.env.set("__GETOPTS_CHARINDEX", "0");
    else {
      if (l >= a.length) {
        let d = "";
        return i10 ? (e11.state.env.set("OPTARG", p), s10 || e11.state.env.set(r10, ":")) : (d = `bash: option requires an argument -- ${p}
`, s10 || e11.state.env.set(r10, "?")), e11.state.env.set("OPTIND", String(l + 1)), e11.state.env.set("__GETOPTS_CHARINDEX", "0"), { exitCode: s10 ? 2 : 0, stdout: "", stderr: d };
      }
      e11.state.env.set("OPTARG", a[l]), e11.state.env.set("OPTIND", String(l + 2)), e11.state.env.set("__GETOPTS_CHARINDEX", "0");
    }
  else
    f10 + 1 < u.length ? (e11.state.env.set("__GETOPTS_CHARINDEX", String(f10 + 1)), e11.state.env.set("OPTIND", String(l))) : (e11.state.env.set("OPTIND", String(l + 1)), e11.state.env.set("__GETOPTS_CHARINDEX", "0"));
  return s10 || e11.state.env.set(r10, p), { exitCode: s10 ? 2 : 0, stdout: "", stderr: "" };
}
async function Bc(e11, t10) {
  e11.state.hashTable || (e11.state.hashTable = /* @__PURE__ */ new Map());
  let n10 = false, r10 = false, s10 = false, i10 = false, o10 = false, a = "", l = [], c = 0;
  for (; c < t10.length; ) {
    let m = t10[c];
    if (m === "--") {
      c++, l.push(...t10.slice(c));
      break;
    }
    if (m === "-r")
      n10 = true, c++;
    else if (m === "-d")
      r10 = true, c++;
    else if (m === "-l")
      s10 = true, c++;
    else if (m === "-t")
      o10 = true, c++;
    else if (m === "-p") {
      if (i10 = true, c++, c >= t10.length)
        return W(`bash: hash: -p: option requires an argument
`, 1);
      a = t10[c], c++;
    } else if (m.startsWith("-") && m.length > 1) {
      for (let d of m.slice(1))
        if (d === "r")
          n10 = true;
        else if (d === "d")
          r10 = true;
        else if (d === "l")
          s10 = true;
        else if (d === "t")
          o10 = true;
        else
          return d === "p" ? W(`bash: hash: -p: option requires an argument
`, 1) : W(`bash: hash: -${d}: invalid option
`, 1);
      c++;
    } else
      l.push(m), c++;
  }
  if (n10)
    return e11.state.hashTable.clear(), de;
  if (r10) {
    if (l.length === 0)
      return W(`bash: hash: -d: option requires an argument
`, 1);
    let m = false, d = "";
    for (let g of l)
      e11.state.hashTable.has(g) ? e11.state.hashTable.delete(g) : (d += `bash: hash: ${g}: not found
`, m = true);
    return m ? W(d, 1) : de;
  }
  if (o10) {
    if (l.length === 0)
      return W(`bash: hash: -t: option requires an argument
`, 1);
    let m = "", d = false, g = "";
    for (let y of l) {
      let w = e11.state.hashTable.get(y);
      w ? l.length > 1 ? m += `${y}	${w}
` : m += `${w}
` : (g += `bash: hash: ${y}: not found
`, d = true);
    }
    return d ? { exitCode: 1, stdout: m, stderr: g } : ge(m);
  }
  if (i10) {
    if (l.length === 0)
      return W(`bash: hash: usage: hash [-lr] [-p pathname] [-dt] [name ...]
`, 1);
    let m = l[0];
    return e11.state.hashTable.set(m, a), de;
  }
  if (l.length === 0) {
    if (e11.state.hashTable.size === 0)
      return ge(`hash: hash table empty
`);
    let m = "";
    if (s10)
      for (let [d, g] of e11.state.hashTable)
        m += `builtin hash -p ${g} ${d}
`;
    else {
      m = `hits	command
`;
      for (let [, d] of e11.state.hashTable)
        m += `   1	${d}
`;
    }
    return ge(m);
  }
  let u = false, f10 = "", h = (e11.state.env.get("PATH") || "/usr/bin:/bin").split(":");
  for (let m of l) {
    if (m.includes("/")) {
      f10 += `bash: hash: ${m}: cannot use / in name
`, u = true;
      continue;
    }
    let d = false;
    for (let g of h) {
      if (!g)
        continue;
      let y = `${g}/${m}`;
      if (await e11.fs.exists(y)) {
        e11.state.hashTable.set(m, y), d = true;
        break;
      }
    }
    d || (f10 += `bash: hash: ${m}: not found
`, u = true);
  }
  return u ? W(f10, 1) : de;
}
Fe();
var U6 = /* @__PURE__ */ new Map([[":", [": [arguments]", `Null command.
    No effect; the command does nothing.
    Exit Status:
    Always succeeds.`]], [".", [". filename [arguments]", `Execute commands from a file in the current shell.
    Read and execute commands from FILENAME in the current shell.
    The entries in $PATH are used to find the directory containing FILENAME.
    Exit Status:
    Returns the status of the last command executed in FILENAME.`]], ["[", ["[ arg... ]", `Evaluate conditional expression.
    This is a synonym for the "test" builtin, but the last argument must
    be a literal \`]', to match the opening \`['.`]], ["alias", ["alias [-p] [name[=value] ... ]", `Define or display aliases.
    Without arguments, \`alias' prints the list of aliases in the reusable
    form \`alias NAME=VALUE' on standard output.
    Exit Status:
    alias returns true unless a NAME is supplied for which no alias has been
    defined.`]], ["bg", ["bg [job_spec ...]", `Move jobs to the background.
    Place the jobs identified by each JOB_SPEC in the background, as if they
    had been started with \`&'.`]], ["break", ["break [n]", `Exit for, while, or until loops.
    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing
    loops.
    Exit Status:
    The exit status is 0 unless N is not greater than or equal to 1.`]], ["builtin", ["builtin [shell-builtin [arg ...]]", `Execute shell builtins.
    Execute SHELL-BUILTIN with arguments ARGs without performing command
    lookup.  This is useful when you wish to reimplement a shell builtin
    as a shell function, but need to execute the builtin within the function.
    Exit Status:
    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is
    not a shell builtin.`]], ["caller", ["caller [expr]", `Return the context of the current subroutine call.
    Without EXPR, returns "$line $filename".  With EXPR, returns
    "$line $subroutine $filename"; this extra information can be used to
    provide a stack trace.
    Exit Status:
    Returns 0 unless the shell is not executing a subroutine call or
    EXPR is invalid.`]], ["cd", ["cd [-L|-P] [dir]", `Change the shell working directory.
    Change the current directory to DIR.  The default DIR is the value of the
    HOME shell variable.

    The variable CDPATH defines the search path for the directory containing
    DIR.  Alternative directory names in CDPATH are separated by a colon (:).
    A null directory name is the same as the current directory.  If DIR begins
    with a slash (/), then CDPATH is not used.

    If the directory is not found, and the shell option \`cdable_vars' is set,
    the word is assumed to be a variable name.  If that variable has a value,
    its value is used for DIR.

    Options:
      -L	force symbolic links to be followed
      -P	use the physical directory structure without following symbolic
    	links

    The default is to follow symbolic links, as if \`-L' were specified.

    Exit Status:
    Returns 0 if the directory is changed; non-zero otherwise.`]], ["command", ["command [-pVv] command [arg ...]", `Execute a simple command or display information about commands.
    Runs COMMAND with ARGS suppressing shell function lookup, or display
    information about the specified COMMANDs.

    Options:
      -p	use a default value for PATH that is guaranteed to find all of
    	the standard utilities
      -v	print a description of COMMAND similar to the \`type' builtin
      -V	print a more verbose description of each COMMAND

    Exit Status:
    Returns exit status of COMMAND, or failure if COMMAND is not found.`]], ["compgen", ["compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]", `Display possible completions depending on the options.
    Intended to be used from within a shell function generating possible
    completions.  If the optional WORD argument is supplied, matches against
    WORD are generated.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`]], ["complete", ["complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]", `Specify how arguments are to be completed.
    For each NAME, specify how arguments are to be completed.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`]], ["continue", ["continue [n]", `Resume for, while, or until loops.
    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.
    If N is specified, resumes the Nth enclosing loop.
    Exit Status:
    The exit status is 0 unless N is not greater than or equal to 1.`]], ["declare", ["declare [-aAfFgilnrtux] [-p] [name[=value] ...]", `Set variable values and attributes.
    Declare variables and give them attributes.  If no NAMEs are given,
    display the attributes and values of all variables.

    Options:
      -a	to make NAMEs indexed arrays (if supported)
      -A	to make NAMEs associative arrays (if supported)
      -i	to make NAMEs have the \`integer' attribute
      -l	to convert the value of each NAME to lower case on assignment
      -n	make NAME a reference to the variable named by its value
      -r	to make NAMEs readonly
      -t	to make NAMEs have the \`trace' attribute
      -u	to convert the value of each NAME to upper case on assignment
      -x	to make NAMEs export

    Exit Status:
    Returns success unless an invalid option is supplied or a variable
    assignment error occurs.`]], ["dirs", ["dirs [-clpv] [+N] [-N]", `Display directory stack.
    Display the list of currently remembered directories.  Directories
    find their way onto the list with the \`pushd' command; you can get
    back up through the list with the \`popd' command.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`]], ["disown", ["disown [-h] [-ar] [jobspec ...]", `Remove jobs from current shell.
    Without any JOBSPECs, remove the current job.`]], ["echo", ["echo [-neE] [arg ...]", `Write arguments to the standard output.
    Display the ARGs, separated by a single space character and followed by a
    newline, on the standard output.

    Options:
      -n	do not append a newline
      -e	enable interpretation of the following backslash escapes
      -E	explicitly suppress interpretation of backslash escapes

    Exit Status:
    Returns success unless a write error occurs.`]], ["enable", ["enable [-a] [-dnps] [-f filename] [name ...]", `Enable and disable shell builtins.
    Enables and disables builtin shell commands.
    Exit Status:
    Returns success unless NAME is not a shell builtin or an error occurs.`]], ["eval", ["eval [arg ...]", `Execute arguments as a shell command.
    Combine ARGs into a single string, use the result as input to the shell,
    and execute the resulting commands.
    Exit Status:
    Returns exit status of command or success if command is null.`]], ["exec", ["exec [-cl] [-a name] [command [arguments ...]] [redirection ...]", `Replace the shell with the given command.
    Execute COMMAND, replacing this shell with the specified program.
    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,
    any redirections take effect in the current shell.
    Exit Status:
    Returns success unless COMMAND is not found or a redirection error occurs.`]], ["exit", ["exit [n]", `Exit the shell.
    Exits the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.`]], ["export", ["export [-fn] [name[=value] ...] or export -p", `Set export attribute for shell variables.
    Marks each NAME for automatic export to the environment of subsequently
    executed commands.  If VALUE is supplied, assign VALUE before exporting.

    Options:
      -f	refer to shell functions
      -n	remove the export property from each NAME
      -p	display a list of all exported variables and functions

    Exit Status:
    Returns success unless an invalid option is given or NAME is invalid.`]], ["false", ["false", `Return an unsuccessful result.
    Exit Status:
    Always fails.`]], ["fc", ["fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]", `Display or execute commands from the history list.
    Exit Status:
    Returns success or status of executed command.`]], ["fg", ["fg [job_spec]", `Move job to the foreground.
    Place the job identified by JOB_SPEC in the foreground, making it the
    current job.`]], ["getopts", ["getopts optstring name [arg]", `Parse option arguments.
    Getopts is used by shell procedures to parse positional parameters
    as options.

    OPTSTRING contains the option letters to be recognized; if a letter
    is followed by a colon, the option is expected to have an argument,
    which should be separated from it by white space.
    Exit Status:
    Returns success if an option is found; fails if the end of options is
    encountered or an error occurs.`]], ["hash", ["hash [-lr] [-p pathname] [-dt] [name ...]", `Remember or display program locations.
    Determine and remember the full pathname of each command NAME.
    Exit Status:
    Returns success unless NAME is not found or an invalid option is given.`]], ["help", ["help [-s] [pattern ...]", `Display information about builtin commands.
    Displays brief summaries of builtin commands.  If PATTERN is
    specified, gives detailed help on all commands matching PATTERN,
    otherwise the list of help topics is printed.

    Options:
      -s	output only a short usage synopsis for each topic matching
    	PATTERN

    Exit Status:
    Returns success unless PATTERN is not found.`]], ["history", ["history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]", `Display or manipulate the history list.
    Display the history list with line numbers, prefixing each modified
    entry with a \`*'.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`]], ["jobs", ["jobs [-lnprs] [jobspec ...] or jobs -x command [args]", `Display status of jobs.
    Lists the active jobs.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`]], ["kill", ["kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]", `Send a signal to a job.
    Send the processes identified by PID or JOBSPEC the signal named by
    SIGSPEC or SIGNUM.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`]], ["let", ["let arg [arg ...]", `Evaluate arithmetic expressions.
    Evaluate each ARG as an arithmetic expression.  Evaluation is done in
    fixed-width integers with no check for overflow, though division by 0
    is trapped and flagged as an error.
    Exit Status:
    If the last ARG evaluates to 0, let returns 1; 0 is returned otherwise.`]], ["local", ["local [option] name[=value] ...", `Define local variables.
    Create a local variable called NAME, and give it VALUE.  OPTION can
    be any option accepted by \`declare'.

    Local can only be used within a function; it makes the variable NAME
    have a visible scope restricted to that function and its children.
    Exit Status:
    Returns success unless an invalid option is supplied, a variable
    assignment error occurs, or the shell is not executing a function.`]], ["logout", ["logout [n]", `Exit a login shell.
    Exits a login shell with exit status N.  Returns an error if not executed
    in a login shell.`]], ["mapfile", ["mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]", `Read lines from the standard input into an indexed array variable.
    Read lines from the standard input into the indexed array variable ARRAY,
    or from file descriptor FD if the -u option is supplied.

    Options:
      -d delim	Use DELIM to terminate lines, instead of newline
      -n count	Copy at most COUNT lines
      -O origin	Begin assigning to ARRAY at index ORIGIN
      -s count	Discard the first COUNT lines read
      -t	Remove a trailing DELIM from each line read (default newline)
      -u fd	Read lines from file descriptor FD instead of standard input

    Exit Status:
    Returns success unless an invalid option is given or ARRAY is readonly.`]], ["popd", ["popd [-n] [+N | -N]", `Remove directories from stack.
    Removes entries from the directory stack.
    Exit Status:
    Returns success unless an invalid argument is supplied or the directory
    change fails.`]], ["printf", ["printf [-v var] format [arguments]", `Formats and prints ARGUMENTS under control of the FORMAT.

    Options:
      -v var	assign the output to shell variable VAR rather than
    		display it on the standard output

    FORMAT is a character string which contains three types of objects: plain
    characters, which are simply copied to standard output; character escape
    sequences, which are converted and copied to the standard output; and
    format specifications, each of which causes printing of the next successive
    argument.
    Exit Status:
    Returns success unless an invalid option is given or a write or assignment
    error occurs.`]], ["pushd", ["pushd [-n] [+N | -N | dir]", `Add directories to stack.
    Adds a directory to the top of the directory stack, or rotates
    the stack, making the new top of the stack the current working
    directory.
    Exit Status:
    Returns success unless an invalid argument is supplied or the directory
    change fails.`]], ["pwd", ["pwd [-LP]", `Print the name of the current working directory.

    Options:
      -L	print the value of $PWD if it names the current working
    	directory
      -P	print the physical directory, without any symbolic links

    By default, \`pwd' behaves as if \`-L' were specified.
    Exit Status:
    Returns 0 unless an invalid option is given or the current directory
    cannot be read.`]], ["read", ["read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]", `Read a line from the standard input and split it into fields.
    Reads a single line from the standard input, or from file descriptor FD
    if the -u option is supplied.  The line is split into fields as with word
    splitting, and the first word is assigned to the first NAME, the second
    word to the second NAME, and so on, with any leftover words assigned to
    the last NAME.
    Exit Status:
    The return code is zero, unless end-of-file is encountered, read times out,
    or an invalid file descriptor is supplied as the argument to -u.`]], ["readarray", ["readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]", "Read lines from a file into an array variable.\n    A synonym for `mapfile'."]], ["readonly", ["readonly [-aAf] [name[=value] ...] or readonly -p", `Mark shell variables as unchangeable.
    Mark each NAME as read-only; the values of these NAMEs may not be
    changed by subsequent assignment.
    Exit Status:
    Returns success unless an invalid option is given or NAME is invalid.`]], ["return", ["return [n]", `Return from a shell function.
    Causes a function or sourced script to exit with the return value
    specified by N.  If N is omitted, the return status is that of the
    last command executed within the function or script.
    Exit Status:
    Returns N, or failure if the shell is not executing a function or script.`]], ["set", ["set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]", `Set or unset values of shell options and positional parameters.
    Change the value of shell attributes and positional parameters, or
    display the names and values of shell variables.

    Options:
      -e  Exit immediately if a command exits with a non-zero status.
      -u  Treat unset variables as an error when substituting.
      -x  Print commands and their arguments as they are executed.
      -o option-name
          Set the variable corresponding to option-name

    Exit Status:
    Returns success unless an invalid option is given.`]], ["shift", ["shift [n]", `Shift positional parameters.
    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is
    not given, it is assumed to be 1.
    Exit Status:
    Returns success unless N is negative or greater than $#.`]], ["shopt", ["shopt [-pqsu] [-o] [optname ...]", `Set and unset shell options.
    Change the setting of each shell option OPTNAME.  Without any option
    arguments, list each supplied OPTNAME, or all shell options if no
    OPTNAMEs are given, with an indication of whether or not each is set.

    Options:
      -o	restrict OPTNAMEs to those defined for use with \`set -o'
      -p	print each shell option with an indication of its status
      -q	suppress output
      -s	enable (set) each OPTNAME
      -u	disable (unset) each OPTNAME

    Exit Status:
    Returns success if OPTNAME is enabled; fails if an invalid option is
    given or OPTNAME is disabled.`]], ["source", ["source filename [arguments]", `Execute commands from a file in the current shell.
    Read and execute commands from FILENAME in the current shell.
    The entries in $PATH are used to find the directory containing FILENAME.
    Exit Status:
    Returns the status of the last command executed in FILENAME.`]], ["suspend", ["suspend [-f]", `Suspend shell execution.
    Suspend the execution of this shell until it receives a SIGCONT signal.`]], ["test", ["test [expr]", `Evaluate conditional expression.
    Exits with a status of 0 (true) or 1 (false) depending on
    the evaluation of EXPR.  Expressions may be unary or binary.
    Exit Status:
    Returns success if EXPR evaluates to true; fails if EXPR evaluates to
    false or an invalid argument is given.`]], ["times", ["times", `Display process times.
    Prints the accumulated user and system times for the shell and all of its
    child processes.
    Exit Status:
    Always succeeds.`]], ["trap", ["trap [-lp] [[arg] signal_spec ...]", `Trap signals and other events.
    Defines and activates handlers to be run when the shell receives signals
    or other conditions.
    Exit Status:
    Returns success unless a SIGSPEC is invalid or an invalid option is given.`]], ["true", ["true", `Return a successful result.
    Exit Status:
    Always succeeds.`]], ["type", ["type [-afptP] name [name ...]", `Display information about command type.
    For each NAME, indicate how it would be interpreted if used as a
    command name.

    Options:
      -a	display all locations containing an executable named NAME
      -f	suppress shell function lookup
      -P	force a PATH search for each NAME, even if it is an alias,
    	builtin, or function, and returns the name of the disk file
    	that would be executed
      -p	returns either the name of the disk file that would be executed,
    	or nothing if \`type -t NAME' would not return \`file'
      -t	output a single word which is one of \`alias', \`keyword',
    	\`function', \`builtin', \`file' or \`', if NAME is an alias,
    	shell reserved word, shell function, shell builtin, disk file,
    	or not found, respectively

    Exit Status:
    Returns success if all of the NAMEs are found; fails if any are not found.`]], ["typeset", ["typeset [-aAfFgilnrtux] [-p] name[=value] ...", "Set variable values and attributes.\n    A synonym for `declare'."]], ["ulimit", ["ulimit [-SHabcdefiklmnpqrstuvxPT] [limit]", `Modify shell resource limits.
    Provides control over the resources available to the shell and processes
    it creates, on systems that allow such control.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`]], ["umask", ["umask [-p] [-S] [mode]", `Display or set file mode mask.
    Sets the user file-creation mask to MODE.  If MODE is omitted, prints
    the current value of the mask.
    Exit Status:
    Returns success unless MODE is invalid or an invalid option is given.`]], ["unalias", ["unalias [-a] name [name ...]", `Remove each NAME from the list of defined aliases.
    Exit Status:
    Returns success unless a NAME is not an existing alias.`]], ["unset", ["unset [-f] [-v] [-n] [name ...]", `Unset values and attributes of shell variables and functions.
    For each NAME, remove the corresponding variable or function.

    Options:
      -f	treat each NAME as a shell function
      -v	treat each NAME as a shell variable
      -n	treat each NAME as a name reference and unset the variable itself
    	rather than the variable it references

    Without options, unset first tries to unset a variable, and if that fails,
    tries to unset a function.
    Exit Status:
    Returns success unless an invalid option is given or a NAME is read-only.`]], ["wait", ["wait [-fn] [id ...]", `Wait for job completion and return exit status.
    Waits for each process identified by an ID, which may be a process ID or a
    job specification, and reports its termination status.
    Exit Status:
    Returns the status of the last ID; fails if ID is invalid or an invalid
    option is given.`]]]);
var W6 = [...U6.keys()].sort();
function zc(e11, t10) {
  let n10 = false, r10 = [], s10 = 0;
  for (; s10 < t10.length; ) {
    let l = t10[s10];
    if (l === "--") {
      for (s10++; s10 < t10.length; )
        r10.push(t10[s10]), s10++;
      break;
    }
    if (l.startsWith("-") && l.length > 1) {
      for (let c = 1; c < l.length; c++) {
        let u = l[c];
        if (u === "s")
          n10 = true;
        else
          return W(`bash: help: -${u}: invalid option
`, 2);
      }
      s10++;
    } else
      r10.push(l), s10++;
  }
  if (r10.length === 0)
    return xE();
  let i10 = "", o10 = false, a = "";
  for (let l of r10) {
    let c = bE(l);
    if (c.length === 0) {
      a += `bash: help: no help topics match \`${l}'.  Try \`help help' or \`man -k ${l}' or \`info ${l}'.
`, o10 = true;
      continue;
    }
    for (let u of c) {
      let f10 = U6.get(u);
      if (!f10)
        continue;
      let [p, h] = f10;
      n10 ? i10 += `${u}: ${p}
` : i10 += `${u}: ${p}
${h}
`;
    }
  }
  return { exitCode: o10 ? 1 : 0, stdout: i10, stderr: a };
}
function bE(e11) {
  let t10 = e11.replace(/[.+^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*").replace(/\?/g, "."), n10 = V(`^${t10}$`);
  return W6.filter((r10) => n10.test(r10));
}
function xE() {
  let e11 = [];
  e11.push("just-bash shell builtins"), e11.push("These shell commands are defined internally. Type `help' to see this list."), e11.push("Type `help name' to find out more about the function `name'."), e11.push("");
  let t10 = 36, n10 = W6.slice(), r10 = Math.ceil(n10.length / 2);
  for (let s10 = 0; s10 < r10; s10++) {
    let i10 = n10[s10] || "", o10 = n10[s10 + r10] || "", a = i10.padEnd(t10);
    e11.push(o10 ? `${a}${o10}` : i10);
  }
  return ge(`${e11.join(`
`)}
`);
}
Ke();
St();
function EE(e11) {
  let t10 = [], n10 = "", r10 = 0;
  for (let s10 of e11) {
    for (let i10 of s10)
      i10 === "(" ? r10++ : i10 === ")" && r10--;
    n10 ? n10 += ` ${s10}` : n10 = s10, r10 === 0 && (t10.push(n10), n10 = "");
  }
  return n10 && t10.push(n10), t10;
}
async function Hc(e11, t10) {
  if (t10.length === 0)
    return W(`bash: let: expression expected
`);
  let n10 = EE(t10), r10 = 0;
  for (let s10 of n10)
    try {
      let o10 = hn(`(( ${s10} ))`).statements[0];
      if (o10 && o10.pipelines.length > 0 && o10.pipelines[0].commands.length > 0) {
        let a = o10.pipelines[0].commands[0];
        a.type === "ArithmeticCommand" && (r10 = await ne(e11, a.expression.expression));
      }
    } catch (i10) {
      return W(`bash: let: ${s10}: ${i10.message}
`);
    }
  return B("", "", r10 === 0 ? 1 : 0);
}
dt();
Ke();
St();
Qt();
tn();
Fn();
async function jc(e11, t10) {
  if (e11.state.localScopes.length === 0)
    return W(`bash: local: can only be used in a function
`);
  let n10 = e11.state.localScopes[e11.state.localScopes.length - 1], r10 = "", s10 = 0, i10 = false, o10 = false, a = false, l = [];
  for (let c of t10)
    if (c === "-n")
      i10 = true;
    else if (c === "-a")
      o10 = true;
    else if (c === "-p")
      a = true;
    else if (c.startsWith("-") && !c.includes("="))
      for (let u of c.slice(1))
        u === "n" ? i10 = true : u === "a" ? o10 = true : u === "p" && (a = true);
    else
      l.push(c);
  if (l.length === 0) {
    let c = "", u = Array.from(n10.keys()).filter((f10) => !f10.includes("_") || !f10.match(/_\d+$/)).filter((f10) => !f10.includes("__length")).sort();
    for (let f10 of u) {
      let p = e11.state.env.get(f10);
      p !== void 0 && (c += `${f10}=${p}
`);
    }
    return B(c, "", 0);
  }
  for (let c of l) {
    let u, f10, p = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
    if (p) {
      u = p[1];
      let y = p[2];
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(u)) {
        r10 += `bash: local: \`${c}': not a valid identifier
`, s10 = 1;
        continue;
      }
      if (st(e11, u, "bash"), !n10.has(u)) {
        n10.set(u, e11.state.env.get(u));
        let x = `${u}_`;
        for (let S of e11.state.env.keys())
          S.startsWith(x) && !S.includes("__") && (n10.has(S) || n10.set(S, e11.state.env.get(S)));
      }
      let w = `${u}_`;
      for (let x of e11.state.env.keys())
        x.startsWith(w) && !x.includes("__") && e11.state.env.delete(x);
      let b = wn(y);
      for (let x = 0; x < b.length; x++)
        e11.state.env.set(`${u}_${x}`, b[x]);
      e11.state.env.set(`${u}__length`, String(b.length)), Wn(e11, u), i10 && Sn(e11, u);
      continue;
    }
    let h = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
    if (h) {
      u = h[1];
      let y = h[2];
      if (st(e11, u, "bash"), !n10.has(u)) {
        n10.set(u, e11.state.env.get(u));
        let R10 = `${u}_`;
        for (let $ of e11.state.env.keys())
          $.startsWith(R10) && !$.includes("__") && (n10.has($) || n10.set($, e11.state.env.get($)));
        let F4 = `${u}__length`;
        e11.state.env.has(F4) && !n10.has(F4) && n10.set(F4, e11.state.env.get(F4));
      }
      let w = wn(y), b = Xe(e11, u), x = 0, S = e11.state.env.get(u);
      b.length === 0 && S !== void 0 ? (e11.state.env.set(`${u}_0`, S), e11.state.env.delete(u), x = 1) : b.length > 0 && (x = Math.max(...b) + 1);
      for (let R10 = 0; R10 < w.length; R10++)
        e11.state.env.set(`${u}_${x + R10}`, Ve(e11, w[R10]));
      let O = x + w.length;
      e11.state.env.set(`${u}__length`, String(O)), Wn(e11, u), i10 && Sn(e11, u);
      continue;
    }
    let m = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (m) {
      u = m[1];
      let y = Ve(e11, m[2]);
      st(e11, u, "bash"), n10.has(u) || n10.set(u, e11.state.env.get(u));
      let w = e11.state.env.get(u) ?? "";
      e11.state.env.set(u, w + y), Wn(e11, u), i10 && Sn(e11, u);
      continue;
    }
    let d = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([^\]]+)\]=(.*)$/s);
    if (d) {
      u = d[1];
      let y = d[2], w = Ve(e11, d[3]);
      if (st(e11, u, "bash"), !n10.has(u)) {
        n10.set(u, e11.state.env.get(u));
        let S = `${u}_`;
        for (let R10 of e11.state.env.keys())
          R10.startsWith(S) && !R10.includes("__") && (n10.has(R10) || n10.set(R10, e11.state.env.get(R10)));
        let O = `${u}__length`;
        e11.state.env.has(O) && !n10.has(O) && n10.set(O, e11.state.env.get(O));
      }
      let b;
      try {
        let S = new ce(), O = Ae(S, y);
        b = await ne(e11, O.expression);
      } catch {
        let S = parseInt(y, 10);
        b = Number.isNaN(S) ? 0 : S;
      }
      e11.state.env.set(`${u}_${b}`, w);
      let x = parseInt(e11.state.env.get(`${u}__length`) ?? "0", 10);
      b >= x && e11.state.env.set(`${u}__length`, String(b + 1)), Wn(e11, u), i10 && Sn(e11, u);
      continue;
    }
    if (c.includes("=")) {
      let y = c.indexOf("=");
      u = c.slice(0, y), f10 = Ve(e11, c.slice(y + 1));
    } else
      u = c;
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(u)) {
      r10 += `bash: local: \`${c}': not a valid identifier
`, s10 = 1;
      continue;
    }
    let g = n10.has(u);
    if (f10 !== void 0) {
      let y = e11.state.env.get(u);
      if (e11.state.tempEnvBindings) {
        let w = e11.state.accessedTempEnvVars?.has(u), b = e11.state.mutatedTempEnvVars?.has(u);
        if (!w && !b)
          for (let x = e11.state.tempEnvBindings.length - 1; x >= 0; x--) {
            let S = e11.state.tempEnvBindings[x];
            if (S.has(u)) {
              y = S.get(u);
              break;
            }
          }
      }
      C6(e11, u, y);
    }
    if (!g) {
      let y = e11.state.env.get(u);
      if (e11.state.tempEnvBindings)
        for (let w = e11.state.tempEnvBindings.length - 1; w >= 0; w--) {
          let b = e11.state.tempEnvBindings[w];
          if (b.has(u)) {
            y = b.get(u);
            break;
          }
        }
      if (n10.set(u, y), o10) {
        let w = `${u}_`;
        for (let x of e11.state.env.keys())
          x.startsWith(w) && !x.includes("__") && (n10.has(x) || n10.set(x, e11.state.env.get(x)));
        let b = `${u}__length`;
        e11.state.env.has(b) && !n10.has(b) && n10.set(b, e11.state.env.get(b));
      }
    }
    if (o10 && f10 === void 0) {
      let y = `${u}_`;
      for (let w of e11.state.env.keys())
        w.startsWith(y) && !w.includes("__") && e11.state.env.delete(w);
      e11.state.env.set(`${u}__length`, "0");
    } else if (f10 !== void 0) {
      if (st(e11, u, "bash"), i10 && f10 !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(f10)) {
        r10 += `bash: local: \`${f10}': invalid variable name for name reference
`, s10 = 1;
        continue;
      }
      e11.state.env.set(u, f10), e11.state.options.allexport && (e11.state.exportedVars = e11.state.exportedVars || /* @__PURE__ */ new Set(), e11.state.exportedVars.add(u));
    } else {
      let y = e11.state.tempEnvBindings?.some((w) => w.has(u));
      !g && !y && e11.state.env.delete(u);
    }
    Wn(e11, u), i10 && Sn(e11, u);
  }
  return B("", r10, s10);
}
Qt();
function Gc(e11, t10, n10) {
  let r10 = `
`, s10 = 0, i10 = 0, o10 = 0, a = false, l = "MAPFILE", c = 0;
  for (; c < t10.length; ) {
    let w = t10[c];
    w === "-d" && c + 1 < t10.length ? (r10 = t10[c + 1] === "" ? "\0" : t10[c + 1] || `
`, c += 2) : w === "-n" && c + 1 < t10.length ? (s10 = Number.parseInt(t10[c + 1], 10) || 0, c += 2) : w === "-O" && c + 1 < t10.length ? (i10 = Number.parseInt(t10[c + 1], 10) || 0, c += 2) : w === "-s" && c + 1 < t10.length ? (o10 = Number.parseInt(t10[c + 1], 10) || 0, c += 2) : w === "-t" ? (a = true, c++) : w === "-u" || w === "-C" || w === "-c" ? c += 2 : (w.startsWith("-") || (l = w), c++);
  }
  let u = n10;
  !u && e11.state.groupStdin !== void 0 && (u = e11.state.groupStdin);
  let f10 = [], p = u, h = 0, m = 0, d = e11.limits?.maxArrayElements ?? 1e5;
  for (; p.length > 0; ) {
    let w = p.indexOf(r10);
    if (w === -1) {
      if (p.length > 0) {
        if (m < o10)
          m++;
        else if (s10 === 0 || h < s10) {
          if (i10 + h >= d)
            return B("", `mapfile: array element limit exceeded (${d})
`, 1);
          let S = p, O = S.indexOf("\0");
          O !== -1 && (S = S.substring(0, O)), f10.push(S), h++;
        }
      }
      break;
    }
    let b = p.substring(0, w), x = b.indexOf("\0");
    if (x !== -1 && (b = b.substring(0, x)), !a && r10 !== "\0" && (b += r10), p = p.substring(w + r10.length), m < o10) {
      m++;
      continue;
    }
    if (s10 > 0 && h >= s10)
      break;
    if (i10 + h >= d)
      return B("", `mapfile: array element limit exceeded (${d})
`, 1);
    f10.push(b), h++;
  }
  i10 === 0 && dn(e11, l);
  for (let w = 0; w < f10.length; w++)
    e11.state.env.set(`${l}_${i10 + w}`, f10[w]);
  let g = parseInt(e11.state.env.get(`${l}__length`) || "0", 10), y = i10 + f10.length;
  return e11.state.env.set(`${l}__length`, String(Math.max(g, y))), e11.state.groupStdin !== void 0 && !n10 && (e11.state.groupStdin = ""), B("", "", 0);
}
Qt();
zt();
function AE(e11) {
  if (!e11.startsWith("__rw__:"))
    return null;
  let t10 = e11.slice(7), n10 = t10.indexOf(":");
  if (n10 === -1)
    return null;
  let r10 = Number.parseInt(t10.slice(0, n10), 10);
  if (Number.isNaN(r10) || r10 < 0)
    return null;
  let s10 = n10 + 1, i10 = t10.slice(s10, s10 + r10), o10 = s10 + r10 + 1, a = t10.slice(o10), l = a.indexOf(":");
  if (l === -1)
    return null;
  let c = Number.parseInt(a.slice(0, l), 10);
  if (Number.isNaN(c) || c < 0)
    return null;
  let u = a.slice(l + 1);
  return { path: i10, position: c, content: u };
}
function SE(e11, t10, n10) {
  return `__rw__:${e11.length}:${e11}:${t10}:${n10}`;
}
function Vc(e11, t10, n10, r10 = -1) {
  let s10 = false, i10 = `
`, o10 = "", a = -1, l = -1, c = null, u = -1, f10 = -1, p = [], h = 0, m = false, d = (k, N10) => {
    let P = 1;
    for (; P < k.length; ) {
      let v = k[P];
      if (v === "r")
        s10 = true, P++;
      else if (v === "s")
        P++;
      else {
        if (v === "d")
          return P + 1 < k.length ? (i10 = k.substring(P + 1), { nextArgIndex: N10 + 1 }) : N10 + 1 < t10.length ? (i10 = t10[N10 + 1], { nextArgIndex: N10 + 2 }) : { nextArgIndex: N10 + 1 };
        if (v === "n") {
          if (P + 1 < k.length) {
            let T = k.substring(P + 1);
            return a = Number.parseInt(T, 10), (Number.isNaN(a) || a < 0) && (m = true, a = 0), { nextArgIndex: N10 + 1 };
          } else if (N10 + 1 < t10.length)
            return a = Number.parseInt(t10[N10 + 1], 10), (Number.isNaN(a) || a < 0) && (m = true, a = 0), { nextArgIndex: N10 + 2 };
          return { nextArgIndex: N10 + 1 };
        } else if (v === "N") {
          if (P + 1 < k.length) {
            let T = k.substring(P + 1);
            return l = Number.parseInt(T, 10), (Number.isNaN(l) || l < 0) && (m = true, l = 0), { nextArgIndex: N10 + 1 };
          } else if (N10 + 1 < t10.length)
            return l = Number.parseInt(t10[N10 + 1], 10), (Number.isNaN(l) || l < 0) && (m = true, l = 0), { nextArgIndex: N10 + 2 };
          return { nextArgIndex: N10 + 1 };
        } else {
          if (v === "a")
            return P + 1 < k.length ? (c = k.substring(P + 1), { nextArgIndex: N10 + 1 }) : N10 + 1 < t10.length ? (c = t10[N10 + 1], { nextArgIndex: N10 + 2 }) : { nextArgIndex: N10 + 1 };
          if (v === "p")
            return P + 1 < k.length ? (o10 = k.substring(P + 1), { nextArgIndex: N10 + 1 }) : N10 + 1 < t10.length ? (o10 = t10[N10 + 1], { nextArgIndex: N10 + 2 }) : { nextArgIndex: N10 + 1 };
          if (v === "u") {
            if (P + 1 < k.length) {
              let T = k.substring(P + 1);
              return u = Number.parseInt(T, 10), Number.isNaN(u) || u < 0 ? { nextArgIndex: -2 } : { nextArgIndex: N10 + 1 };
            } else if (N10 + 1 < t10.length)
              return u = Number.parseInt(t10[N10 + 1], 10), Number.isNaN(u) || u < 0 ? { nextArgIndex: -2 } : { nextArgIndex: N10 + 2 };
            return { nextArgIndex: N10 + 1 };
          } else if (v === "t") {
            if (P + 1 < k.length) {
              let T = k.substring(P + 1);
              return f10 = Number.parseFloat(T), Number.isNaN(f10) && (f10 = 0), { nextArgIndex: N10 + 1 };
            } else if (N10 + 1 < t10.length)
              return f10 = Number.parseFloat(t10[N10 + 1]), Number.isNaN(f10) && (f10 = 0), { nextArgIndex: N10 + 2 };
            return { nextArgIndex: N10 + 1 };
          } else if (v === "e" || v === "i" || v === "P") {
            if (v === "i" && N10 + 1 < t10.length)
              return { nextArgIndex: N10 + 2 };
            P++;
          } else
            P++;
        }
      }
    }
    return { nextArgIndex: N10 + 1 };
  };
  for (; h < t10.length; ) {
    let k = t10[h];
    if (k.startsWith("-") && k.length > 1 && k !== "--") {
      let N10 = d(k, h);
      if (N10.nextArgIndex === -1)
        return { stdout: "", stderr: "", exitCode: 2 };
      if (N10.nextArgIndex === -2)
        return { stdout: "", stderr: "", exitCode: 1 };
      h = N10.nextArgIndex;
    } else if (k === "--")
      for (h++; h < t10.length; )
        p.push(t10[h]), h++;
    else
      p.push(k), h++;
  }
  if (m)
    return B("", "", 1);
  if (p.length === 0 && c === null && p.push("REPLY"), f10 === 0) {
    if (c)
      dn(e11, c);
    else {
      for (let k of p)
        e11.state.env.set(k, "");
      p.length === 0 && e11.state.env.set("REPLY", "");
    }
    return B("", "", 0);
  }
  if (f10 < 0 && f10 !== -1)
    return B("", "", 1);
  let g = n10;
  u >= 0 ? e11.state.fileDescriptors ? g = e11.state.fileDescriptors.get(u) || "" : g = "" : !g && e11.state.groupStdin !== void 0 && (g = e11.state.groupStdin);
  let y = i10 === "" ? "\0" : i10, w = "", b = 0, x = true, S = (k) => {
    if (u >= 0 && e11.state.fileDescriptors)
      e11.state.fileDescriptors.set(u, g.substring(k));
    else if (r10 >= 0 && e11.state.fileDescriptors) {
      let N10 = e11.state.fileDescriptors.get(r10);
      if (N10?.startsWith("__rw__:")) {
        let P = AE(N10);
        if (P) {
          let v = P.position + k;
          e11.state.fileDescriptors.set(r10, SE(P.path, v, P.content));
        }
      }
    } else
      e11.state.groupStdin !== void 0 && !n10 && (e11.state.groupStdin = g.substring(k));
  };
  if (l >= 0) {
    let k = Math.min(l, g.length);
    w = g.substring(0, k), b = k, x = k >= l, S(b);
    let N10 = p[0] || "REPLY";
    e11.state.env.set(N10, w);
    for (let P = 1; P < p.length; P++)
      e11.state.env.set(p[P], "");
    return B("", "", x ? 0 : 1);
  } else if (a >= 0) {
    let k = 0, N10 = 0, P = false;
    for (; N10 < g.length && k < a; ) {
      let v = g[N10];
      if (v === y) {
        b = N10 + 1, P = true;
        break;
      }
      if (!s10 && v === "\\" && N10 + 1 < g.length) {
        let T = g[N10 + 1];
        if (T === y && y === `
`) {
          N10 += 2, b = N10;
          continue;
        }
        if (T === y) {
          N10 += 2, k++, w += T, b = N10;
          continue;
        }
        w += T, N10 += 2, k++, b = N10;
      } else
        w += v, N10++, k++, b = N10;
    }
    x = k >= a || P, S(b);
  } else {
    b = 0;
    let k = 0;
    for (; k < g.length; ) {
      let N10 = g[k];
      if (N10 === y) {
        b = k + y.length, x = true;
        break;
      }
      if (!s10 && N10 === "\\" && k + 1 < g.length) {
        let P = g[k + 1];
        if (P === `
`) {
          k += 2;
          continue;
        }
        if (P === y) {
          w += P, k += 2;
          continue;
        }
        w += N10, w += P, k += 2;
        continue;
      }
      w += N10, k++;
    }
    if (k >= g.length && (x = false, b = k, w.length === 0 && g.length === 0)) {
      for (let N10 of p)
        e11.state.env.set(N10, "");
      return c && dn(e11, c), B("", "", 1);
    }
    S(b);
  }
  y === `
` && w.endsWith(`
`) && (w = w.slice(0, -1));
  let O = (k) => s10 ? k : k.replace(/\\(.)/g, "$1");
  if (p.length === 1 && p[0] === "REPLY")
    return e11.state.env.set("REPLY", O(w)), B("", "", x ? 0 : 1);
  let R10 = nt(e11.state.env);
  if (c) {
    let { words: k } = Kl(w, R10, void 0, s10), N10 = e11.limits?.maxArrayElements ?? 1e5;
    if (k.length > N10)
      return B("", `read: array element limit exceeded (${N10})
`, 1);
    dn(e11, c);
    for (let P = 0; P < k.length; P++)
      e11.state.env.set(`${c}_${P}`, O(k[P]));
    return B("", "", x ? 0 : 1);
  }
  let F4 = p.length, { words: $, wordStarts: z } = Kl(w, R10, F4, s10);
  for (let k = 0; k < p.length; k++) {
    let N10 = p[k];
    if (k < p.length - 1)
      e11.state.env.set(N10, O($[k] ?? ""));
    else if (k < z.length) {
      let P = w.substring(z[k]);
      P = Wm(P, R10, s10), P = O(P), e11.state.env.set(N10, P);
    } else
      e11.state.env.set(N10, "");
  }
  return B("", "", x ? 0 : 1);
}
ye();
function qc(e11, t10) {
  if (e11.state.callDepth === 0 && e11.state.sourceDepth === 0)
    return W("bash: return: can only `return' from a function or sourced script\n");
  let n10 = e11.state.lastExitCode;
  if (t10.length > 0) {
    let r10 = t10[0], s10 = Number.parseInt(r10, 10);
    if (r10 === "" || Number.isNaN(s10) || !/^-?\d+$/.test(r10))
      return W(`bash: return: ${r10}: numeric argument required
`, 2);
    n10 = (s10 % 256 + 256) % 256;
  }
  throw new at(n10);
}
ye();
Qt();
var Co = `set: usage: set [-eux] [+eux] [-o option] [+o option]
Options:
  -e            Exit immediately if a command exits with non-zero status
  +e            Disable -e
  -u            Treat unset variables as an error when substituting
  +u            Disable -u
  -x            Print commands and their arguments as they are executed
  +x            Disable -x
  -o errexit    Same as -e
  +o errexit    Disable errexit
  -o nounset    Same as -u
  +o nounset    Disable nounset
  -o pipefail   Return status of last failing command in pipeline
  +o pipefail   Disable pipefail
  -o xtrace     Same as -x
  +o xtrace     Disable xtrace
`;
var B6 = /* @__PURE__ */ new Map([["e", "errexit"], ["u", "nounset"], ["x", "xtrace"], ["v", "verbose"], ["f", "noglob"], ["C", "noclobber"], ["a", "allexport"], ["n", "noexec"], ["h", null], ["b", null], ["m", null], ["B", null], ["H", null], ["P", null], ["T", null], ["E", null], ["p", null]]);
var z6 = /* @__PURE__ */ new Map([["errexit", "errexit"], ["pipefail", "pipefail"], ["nounset", "nounset"], ["xtrace", "xtrace"], ["verbose", "verbose"], ["noclobber", "noclobber"], ["noglob", "noglob"], ["allexport", "allexport"], ["noexec", "noexec"], ["posix", "posix"], ["vi", "vi"], ["emacs", "emacs"], ["notify", null], ["monitor", null], ["braceexpand", null], ["histexpand", null], ["physical", null], ["functrace", null], ["errtrace", null], ["privileged", null], ["hashall", null], ["ignoreeof", null], ["interactive-comments", null], ["keyword", null], ["onecmd", null]]);
var H6 = ["errexit", "nounset", "pipefail", "verbose", "xtrace", "posix", "allexport", "noclobber", "noglob", "noexec", "vi", "emacs"];
var j6 = ["braceexpand", "errtrace", "functrace", "hashall", "histexpand", "history", "ignoreeof", "interactive-comments", "keyword", "monitor", "nolog", "notify", "onecmd", "physical", "privileged"];
function G6(e11, t10, n10) {
  t10 !== null && (n10 && (t10 === "vi" ? e11.state.options.emacs = false : t10 === "emacs" && (e11.state.options.vi = false)), e11.state.options[t10] = n10, Tr(e11));
}
function CE(e11, t10) {
  return t10 + 1 < e11.length && !e11[t10 + 1].startsWith("-") && !e11[t10 + 1].startsWith("+");
}
function NE(e11, t10) {
  let n10 = Xe(e11, t10);
  if (n10.length === 0)
    return `${t10}=()`;
  let r10 = n10.map((s10) => {
    let i10 = e11.state.env.get(`${t10}_${s10}`) ?? "";
    return `[${s10}]=${or(i10)}`;
  });
  return `${t10}=(${r10.join(" ")})`;
}
function kE(e11) {
  return /^[a-zA-Z0-9_]+$/.test(e11) ? e11 : `"${e11.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function vE(e11, t10) {
  let n10 = en(e11, t10);
  if (n10.length === 0)
    return `${t10}=()`;
  let r10 = n10.map((s10) => {
    let i10 = e11.state.env.get(`${t10}_${s10}`) ?? "";
    return `[${kE(s10)}]=${or(i10)}`;
  });
  return `${t10}=(${r10.join(" ")} )`;
}
function IE(e11) {
  let t10 = /* @__PURE__ */ new Set(), n10 = e11.state.associativeArrays ?? /* @__PURE__ */ new Set();
  for (let r10 of e11.state.env.keys()) {
    let s10 = r10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_(\d+)$/);
    if (s10) {
      let i10 = s10[1];
      n10.has(i10) || t10.add(i10);
    }
  }
  return t10;
}
function OE(e11) {
  return e11.state.associativeArrays ?? /* @__PURE__ */ new Set();
}
function Qc(e11, t10) {
  if (t10.includes("--help"))
    return ge(Co);
  if (t10.length === 0) {
    let r10 = IE(e11), s10 = OE(e11), i10 = (l) => {
      for (let c of s10) {
        let u = `${c}_`, f10 = `${c}__length`;
        if (l !== f10 && l.startsWith(u)) {
          if (l.slice(u.length).startsWith("_length"))
            continue;
          return true;
        }
      }
      return false;
    }, o10 = [];
    for (let [l, c] of e11.state.env) {
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(l) || r10.has(l) || s10.has(l))
        continue;
      let u = l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_(\d+)$/);
      if (u && r10.has(u[1]))
        continue;
      let f10 = l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
      f10 && r10.has(f10[1]) || i10(l) || f10 && s10.has(f10[1]) || o10.push([l, c]);
    }
    let a = [];
    for (let [l, c] of o10.sort(([u], [f10]) => u < f10 ? -1 : u > f10 ? 1 : 0))
      a.push(`${l}=${Eo(c)}`);
    for (let l of [...r10].sort((c, u) => c < u ? -1 : c > u ? 1 : 0))
      a.push(NE(e11, l));
    for (let l of [...s10].sort((c, u) => c < u ? -1 : c > u ? 1 : 0))
      a.push(vE(e11, l));
    return a.sort((l, c) => {
      let u = l.split("=")[0], f10 = c.split("=")[0];
      return u < f10 ? -1 : u > f10 ? 1 : 0;
    }), ge(a.length > 0 ? `${a.join(`
`)}
` : "");
  }
  let n10 = 0;
  for (; n10 < t10.length; ) {
    let r10 = t10[n10];
    if ((r10 === "-o" || r10 === "+o") && CE(t10, n10)) {
      let s10 = t10[n10 + 1];
      if (!z6.has(s10)) {
        let i10 = `bash: set: ${s10}: invalid option name
${Co}`;
        if (e11.state.options.posix)
          throw new Ut(1, "", i10);
        return W(i10);
      }
      G6(e11, z6.get(s10) ?? null, r10 === "-o"), n10 += 2;
      continue;
    }
    if (r10 === "-o") {
      let s10 = H6.map((a) => `${a.padEnd(16)}${e11.state.options[a] ? "on" : "off"}`), i10 = j6.map((a) => `${a.padEnd(16)}off`), o10 = [...s10, ...i10].sort();
      return ge(`${o10.join(`
`)}
`);
    }
    if (r10 === "+o") {
      let s10 = H6.map((a) => `set ${e11.state.options[a] ? "-o" : "+o"} ${a}`), i10 = j6.map((a) => `set +o ${a}`), o10 = [...s10, ...i10].sort();
      return ge(`${o10.join(`
`)}
`);
    }
    if (r10.length > 1 && (r10[0] === "-" || r10[0] === "+") && r10[1] !== "-") {
      let s10 = r10[0] === "-";
      for (let i10 = 1; i10 < r10.length; i10++) {
        let o10 = r10[i10];
        if (!B6.has(o10)) {
          let a = `bash: set: ${r10[0]}${o10}: invalid option
${Co}`;
          if (e11.state.options.posix)
            throw new Ut(1, "", a);
          return W(a);
        }
        G6(e11, B6.get(o10) ?? null, s10);
      }
      n10++;
      continue;
    }
    if (r10 === "--")
      return Zc(e11, t10.slice(n10 + 1)), de;
    if (r10 === "-") {
      if (e11.state.options.xtrace = false, e11.state.options.verbose = false, Tr(e11), n10 + 1 < t10.length)
        return Zc(e11, t10.slice(n10 + 1)), de;
      n10++;
      continue;
    }
    if (r10 === "+") {
      n10++;
      continue;
    }
    if (r10.startsWith("-") || r10.startsWith("+")) {
      let s10 = `bash: set: ${r10}: invalid option
${Co}`;
      if (e11.state.options.posix)
        throw new Ut(1, "", s10);
      return W(s10);
    }
    return Zc(e11, t10.slice(n10)), de;
  }
  return de;
}
function Zc(e11, t10) {
  let n10 = 1;
  for (; e11.state.env.has(String(n10)); )
    e11.state.env.delete(String(n10)), n10++;
  for (let r10 = 0; r10 < t10.length; r10++)
    e11.state.env.set(String(r10 + 1), t10[r10]);
  e11.state.env.set("#", String(t10.length)), e11.state.env.set("@", t10.join(" ")), e11.state.env.set("*", t10.join(" "));
}
ye();
function Kc(e11, t10) {
  let n10 = 1;
  if (t10.length > 0) {
    let o10 = Number.parseInt(t10[0], 10);
    if (Number.isNaN(o10) || o10 < 0) {
      let a = `bash: shift: ${t10[0]}: numeric argument required
`;
      if (e11.state.options.posix)
        throw new Ut(1, "", a);
      return W(a);
    }
    n10 = o10;
  }
  let r10 = Number.parseInt(e11.state.env.get("#") || "0", 10);
  if (n10 > r10) {
    let o10 = `bash: shift: shift count out of range
`;
    if (e11.state.options.posix)
      throw new Ut(1, "", o10);
    return W(o10);
  }
  if (n10 === 0)
    return de;
  let s10 = [];
  for (let o10 = 1; o10 <= r10; o10++)
    s10.push(e11.state.env.get(String(o10)) || "");
  let i10 = s10.slice(n10);
  for (let o10 = 1; o10 <= r10; o10++)
    e11.state.env.delete(String(o10));
  for (let o10 = 0; o10 < i10.length; o10++)
    e11.state.env.set(String(o10 + 1), i10[o10]);
  return e11.state.env.set("#", String(i10.length)), e11.state.env.set("@", i10.join(" ")), de;
}
Ke();
ye();
async function Xc(e11, t10) {
  let n10 = t10;
  if (n10.length > 0 && n10[0] === "--" && (n10 = n10.slice(1)), n10.length === 0)
    return B("", `bash: source: filename argument required
`, 2);
  let r10 = n10[0], s10 = null, i10 = null;
  if (r10.includes("/")) {
    let c = e11.fs.resolvePath(e11.state.cwd, r10);
    try {
      i10 = await e11.fs.readFile(c), s10 = c;
    } catch {
    }
  } else {
    let u = (e11.state.env.get("PATH") || "").split(":").filter((f10) => f10);
    for (let f10 of u) {
      let p = e11.fs.resolvePath(e11.state.cwd, `${f10}/${r10}`);
      try {
        if ((await e11.fs.stat(p)).isDirectory)
          continue;
        i10 = await e11.fs.readFile(p), s10 = p;
        break;
      } catch {
      }
    }
    if (i10 === null) {
      let f10 = e11.fs.resolvePath(e11.state.cwd, r10);
      try {
        i10 = await e11.fs.readFile(f10), s10 = f10;
      } catch {
      }
    }
  }
  if (i10 === null)
    return W(`bash: ${r10}: No such file or directory
`);
  let o10 = /* @__PURE__ */ new Map();
  if (n10.length > 1) {
    for (let u = 1; u <= 9; u++)
      o10.set(String(u), e11.state.env.get(String(u)));
    o10.set("#", e11.state.env.get("#")), o10.set("@", e11.state.env.get("@"));
    let c = n10.slice(1);
    e11.state.env.set("#", String(c.length)), e11.state.env.set("@", c.join(" "));
    for (let u = 0; u < c.length && u < 9; u++)
      e11.state.env.set(String(u + 1), c[u]);
    for (let u = c.length + 1; u <= 9; u++)
      e11.state.env.delete(String(u));
  }
  let a = e11.state.currentSource, l = () => {
    if (e11.state.sourceDepth--, e11.state.currentSource = a, n10.length > 1)
      for (let [c, u] of o10)
        u === void 0 ? e11.state.env.delete(c) : e11.state.env.set(c, u);
  };
  e11.state.sourceDepth++, e11.state.currentSource = r10;
  try {
    let c = hn(i10), u = await e11.executeScript(c);
    return l(), u;
  } catch (c) {
    if (l(), c instanceof pe)
      throw c;
    if (c instanceof at)
      return B(c.stdout, c.stderr, c.exitCode);
    if (c.name === "ParseException")
      return W(`bash: ${r10}: ${c.message}
`);
    throw c;
  }
}
dt();
Ke();
St();
Tt();
Ct();
tn();
Fn();
function V6(e11) {
  return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e11);
}
function RE(e11) {
  return e11.startsWith("'") && e11.endsWith("'") || e11.startsWith('"') && e11.endsWith('"');
}
async function q6(e11, t10) {
  if (RE(t10))
    return null;
  try {
    let n10 = new ce(), r10 = Ae(n10, t10);
    return await ne(e11, r10.expression);
  } catch {
    let n10 = parseInt(t10, 10);
    return Number.isNaN(n10) ? 0 : n10;
  }
}
function Z6(e11, t10) {
  if (e11.state.localVarStack?.has(t10)) {
    let r10 = wo(e11, t10);
    if (r10) {
      r10.value === void 0 ? e11.state.env.delete(t10) : e11.state.env.set(t10, r10.value);
      let s10 = e11.state.localVarStack?.get(t10);
      if (!s10 || s10.length === 0)
        yo(e11, t10), e11.state.localVarStack?.delete(t10), e11.state.fullyUnsetLocals = e11.state.fullyUnsetLocals || /* @__PURE__ */ new Map(), e11.state.fullyUnsetLocals.set(t10, r10.scopeIndex), Yc(e11, t10);
      else {
        let i10 = s10[s10.length - 1];
        e11.state.localVarDepth = e11.state.localVarDepth || /* @__PURE__ */ new Map(), e11.state.localVarDepth.set(t10, i10.scopeIndex + 1);
      }
      return true;
    }
    return e11.state.env.delete(t10), yo(e11, t10), e11.state.localVarStack?.delete(t10), e11.state.fullyUnsetLocals = e11.state.fullyUnsetLocals || /* @__PURE__ */ new Map(), e11.state.fullyUnsetLocals.set(t10, 0), true;
  }
  for (let r10 = e11.state.localScopes.length - 1; r10 >= 0; r10--) {
    let s10 = e11.state.localScopes[r10];
    if (s10.has(t10)) {
      let i10 = s10.get(t10);
      i10 === void 0 ? e11.state.env.delete(t10) : e11.state.env.set(t10, i10), s10.delete(t10);
      let o10 = false;
      for (let a = r10 - 1; a >= 0; a--)
        if (e11.state.localScopes[a].has(t10)) {
          e11.state.localVarDepth && e11.state.localVarDepth.set(t10, a + 1), o10 = true;
          break;
        }
      return o10 || yo(e11, t10), true;
    }
  }
  return false;
}
function Yc(e11, t10) {
  if (!e11.state.tempEnvBindings || e11.state.tempEnvBindings.length === 0)
    return false;
  for (let n10 = e11.state.tempEnvBindings.length - 1; n10 >= 0; n10--) {
    let r10 = e11.state.tempEnvBindings[n10];
    if (r10.has(t10)) {
      let s10 = r10.get(t10);
      return s10 === void 0 ? e11.state.env.delete(t10) : e11.state.env.set(t10, s10), r10.delete(t10), true;
    }
  }
  return false;
}
async function Q6(e11, t10) {
  if (t10.startsWith("'") && t10.endsWith("'"))
    return t10.slice(1, -1);
  if (t10.startsWith('"') && t10.endsWith('"')) {
    let n10 = t10.slice(1, -1), s10 = new ce().parseWordFromString(n10, true, false);
    return ie(e11, s10);
  }
  if (t10.includes("$")) {
    let r10 = new ce().parseWordFromString(t10, false, false);
    return ie(e11, r10);
  }
  return t10;
}
async function Jc(e11, t10) {
  let n10 = "both", r10 = "", s10 = 0;
  for (let i10 of t10) {
    if (i10 === "-v") {
      n10 = "variable";
      continue;
    }
    if (i10 === "-f") {
      n10 = "function";
      continue;
    }
    if (n10 === "function") {
      e11.state.functions.delete(i10);
      continue;
    }
    if (n10 === "variable") {
      let c = i10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
      if (c) {
        let p = c[1], h = c[2];
        if (h === "@" || h === "*") {
          let b = ae(e11, p);
          for (let [x] of b)
            e11.state.env.delete(`${p}_${x}`);
          e11.state.env.delete(p);
          continue;
        }
        let m = e11.state.associativeArrays?.has(p);
        if (m) {
          let b = await Q6(e11, h);
          e11.state.env.delete(`${p}_${b}`);
          continue;
        }
        let d = Cn(e11, p), g = e11.state.declaredVars?.has(p);
        if ((e11.state.env.has(p) || g) && !d && !m) {
          r10 += `bash: unset: ${p}: not an array variable
`, s10 = 1;
          continue;
        }
        let w = await q6(e11, h);
        if (w === null && d) {
          r10 += `bash: unset: ${h}: not a valid identifier
`, s10 = 1;
          continue;
        }
        if (w === null)
          continue;
        if (w < 0) {
          let b = ae(e11, p), x = b.length, S = e11.state.currentLine;
          if (x === 0) {
            r10 += `bash: line ${S}: unset: [${w}]: bad array subscript
`, s10 = 1;
            continue;
          }
          let O = x + w;
          if (O < 0) {
            r10 += `bash: line ${S}: unset: [${w}]: bad array subscript
`, s10 = 1;
            continue;
          }
          let R10 = b[O][0];
          e11.state.env.delete(`${p}_${R10}`);
          continue;
        }
        e11.state.env.delete(`${p}_${w}`);
        continue;
      }
      if (!V6(i10)) {
        r10 += `bash: unset: \`${i10}': not a valid identifier
`, s10 = 1;
        continue;
      }
      let u = i10;
      if (Te(e11, i10)) {
        let p = At(e11, i10);
        p && p !== i10 && (u = p);
      }
      if (yn(e11, u)) {
        r10 += `bash: unset: ${u}: cannot unset: readonly variable
`, s10 = 1;
        continue;
      }
      let f10 = Br(e11, u);
      if (f10 !== void 0 && f10 !== e11.state.callDepth)
        Z6(e11, u);
      else if (e11.state.fullyUnsetLocals?.has(u))
        e11.state.env.delete(u);
      else if (f10 !== void 0) {
        let p = e11.state.accessedTempEnvVars?.has(u), h = e11.state.mutatedTempEnvVars?.has(u);
        if ((p || h) && e11.state.localVarStack?.has(u)) {
          let m = wo(e11, u);
          m ? m.value === void 0 ? e11.state.env.delete(u) : e11.state.env.set(u, m.value) : e11.state.env.delete(u);
        } else
          e11.state.env.delete(u);
      } else
        Yc(e11, u) || e11.state.env.delete(u);
      e11.state.exportedVars?.delete(u);
      continue;
    }
    let o10 = i10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    if (o10) {
      let c = o10[1], u = o10[2];
      if (u === "@" || u === "*") {
        let d = ae(e11, c);
        for (let [g] of d)
          e11.state.env.delete(`${c}_${g}`);
        e11.state.env.delete(c);
        continue;
      }
      let f10 = e11.state.associativeArrays?.has(c);
      if (f10) {
        let d = await Q6(e11, u);
        e11.state.env.delete(`${c}_${d}`);
        continue;
      }
      let p = Cn(e11, c);
      if (e11.state.env.has(c) && !p && !f10) {
        r10 += `bash: unset: ${c}: not an array variable
`, s10 = 1;
        continue;
      }
      let m = await q6(e11, u);
      if (m === null && p) {
        r10 += `bash: unset: ${u}: not a valid identifier
`, s10 = 1;
        continue;
      }
      if (m === null)
        continue;
      if (m < 0) {
        let d = ae(e11, c), g = d.length, y = e11.state.currentLine;
        if (g === 0) {
          r10 += `bash: line ${y}: unset: [${m}]: bad array subscript
`, s10 = 1;
          continue;
        }
        let w = g + m;
        if (w < 0) {
          r10 += `bash: line ${y}: unset: [${m}]: bad array subscript
`, s10 = 1;
          continue;
        }
        let b = d[w][0];
        e11.state.env.delete(`${c}_${b}`);
        continue;
      }
      e11.state.env.delete(`${c}_${m}`);
      continue;
    }
    if (!V6(i10)) {
      r10 += `bash: unset: \`${i10}': not a valid identifier
`, s10 = 1;
      continue;
    }
    let a = i10;
    if (Te(e11, i10)) {
      let c = At(e11, i10);
      c && c !== i10 && (a = c);
    }
    if (yn(e11, a)) {
      r10 += `bash: unset: ${a}: cannot unset: readonly variable
`, s10 = 1;
      continue;
    }
    let l = Br(e11, a);
    if (l !== void 0 && l !== e11.state.callDepth)
      Z6(e11, a);
    else if (e11.state.fullyUnsetLocals?.has(a))
      e11.state.env.delete(a);
    else if (l !== void 0) {
      let c = e11.state.accessedTempEnvVars?.has(a), u = e11.state.mutatedTempEnvVars?.has(a);
      if ((c || u) && e11.state.localVarStack?.has(a)) {
        let f10 = wo(e11, a);
        f10 ? f10.value === void 0 ? e11.state.env.delete(a) : e11.state.env.set(a, f10.value) : e11.state.env.delete(a);
      } else
        e11.state.env.delete(a);
    } else
      Yc(e11, a) || e11.state.env.delete(a);
    e11.state.exportedVars?.delete(a), e11.state.functions.delete(i10);
  }
  return B("", r10, s10);
}
var eu = ["extglob", "dotglob", "nullglob", "failglob", "globstar", "globskipdots", "nocaseglob", "nocasematch", "expand_aliases", "lastpipe", "xpg_echo"];
var $E = ["autocd", "cdable_vars", "cdspell", "checkhash", "checkjobs", "checkwinsize", "cmdhist", "compat31", "compat32", "compat40", "compat41", "compat42", "compat43", "compat44", "complete_fullquote", "direxpand", "dirspell", "execfail", "extdebug", "extquote", "force_fignore", "globasciiranges", "gnu_errfmt", "histappend", "histreedit", "histverify", "hostcomplete", "huponexit", "inherit_errexit", "interactive_comments", "lithist", "localvar_inherit", "localvar_unset", "login_shell", "mailwarn", "no_empty_cmd_completion", "progcomp", "progcomp_alias", "promptvars", "restricted_shell", "shift_verbose", "sourcepath"];
function No(e11) {
  return eu.includes(e11);
}
function TE(e11) {
  return $E.includes(e11);
}
function K6(e11, t10) {
  let n10 = false, r10 = false, s10 = false, i10 = false, o10 = false, a = [], l = 0;
  for (; l < t10.length; ) {
    let p = t10[l];
    if (p === "--") {
      l++;
      break;
    }
    if (p.startsWith("-") && p.length > 1) {
      for (let h = 1; h < p.length; h++) {
        let m = p[h];
        switch (m) {
          case "s":
            n10 = true;
            break;
          case "u":
            r10 = true;
            break;
          case "p":
            s10 = true;
            break;
          case "q":
            i10 = true;
            break;
          case "o":
            o10 = true;
            break;
          default:
            return { exitCode: 2, stdout: "", stderr: `shopt: -${m}: invalid option
` };
        }
      }
      l++;
    } else
      break;
  }
  for (; l < t10.length; )
    a.push(t10[l]), l++;
  if (o10)
    return PE(e11, a, n10, r10, s10, i10);
  if (n10 && r10)
    return { exitCode: 1, stdout: "", stderr: `shopt: cannot set and unset shell options simultaneously
` };
  if (a.length === 0) {
    if (n10 || r10) {
      let h = [];
      for (let m of eu) {
        let d = e11.state.shoptOptions[m];
        n10 && d ? h.push(s10 ? `shopt -s ${m}` : `${m}		on`) : r10 && !d && h.push(s10 ? `shopt -u ${m}` : `${m}		off`);
      }
      return { exitCode: 0, stdout: h.length > 0 ? `${h.join(`
`)}
` : "", stderr: "" };
    }
    let p = [];
    for (let h of eu) {
      let m = e11.state.shoptOptions[h];
      p.push(s10 ? `shopt ${m ? "-s" : "-u"} ${h}` : `${h}		${m ? "on" : "off"}`);
    }
    return { exitCode: 0, stdout: `${p.join(`
`)}
`, stderr: "" };
  }
  let c = false, u = "", f10 = [];
  for (let p of a) {
    if (!No(p) && !TE(p)) {
      u += `shopt: ${p}: invalid shell option name
`, c = true;
      continue;
    }
    if (n10)
      No(p) && (e11.state.shoptOptions[p] = true, El(e11));
    else if (r10)
      No(p) && (e11.state.shoptOptions[p] = false, El(e11));
    else if (No(p)) {
      let h = e11.state.shoptOptions[p];
      i10 ? h || (c = true) : s10 ? (f10.push(`shopt ${h ? "-s" : "-u"} ${p}`), h || (c = true)) : (f10.push(`${p}		${h ? "on" : "off"}`), h || (c = true));
    } else
      i10 ? c = true : s10 ? (f10.push(`shopt -u ${p}`), c = true) : (f10.push(`${p}		off`), c = true);
  }
  return { exitCode: c ? 1 : 0, stdout: f10.length > 0 ? `${f10.join(`
`)}
` : "", stderr: u };
}
function PE(e11, t10, n10, r10, s10, i10) {
  let o10 = /* @__PURE__ */ new Map([["errexit", "errexit"], ["pipefail", "pipefail"], ["nounset", "nounset"], ["xtrace", "xtrace"], ["verbose", "verbose"], ["posix", "posix"], ["allexport", "allexport"], ["noclobber", "noclobber"], ["noglob", "noglob"], ["noexec", "noexec"], ["vi", "vi"], ["emacs", "emacs"]]), a = ["braceexpand", "errtrace", "functrace", "hashall", "histexpand", "history", "ignoreeof", "interactive-comments", "keyword", "monitor", "nolog", "notify", "onecmd", "physical", "privileged"], l = [...o10.keys(), ...a].sort();
  if (t10.length === 0) {
    let p = [];
    for (let h of l) {
      let m = a.includes(h), d = o10.get(h), g = m || !d ? false : e11.state.options[d];
      n10 && !g || r10 && g || p.push(s10 ? `set ${g ? "-o" : "+o"} ${h}` : `${h}		${g ? "on" : "off"}`);
    }
    return { exitCode: 0, stdout: p.length > 0 ? `${p.join(`
`)}
` : "", stderr: "" };
  }
  let c = false, u = "", f10 = [];
  for (let p of t10) {
    let h = o10.has(p), m = a.includes(p);
    if (!h && !m) {
      u += `shopt: ${p}: invalid option name
`, c = true;
      continue;
    }
    if (m) {
      n10 || r10 || (i10 ? c = true : s10 ? (f10.push(`set +o ${p}`), c = true) : (f10.push(`${p}		off`), c = true));
      continue;
    }
    let d = o10.get(p);
    if (d)
      if (n10)
        d === "vi" ? e11.state.options.emacs = false : d === "emacs" && (e11.state.options.vi = false), e11.state.options[d] = true, Tr(e11);
      else if (r10)
        e11.state.options[d] = false, Tr(e11);
      else {
        let g = e11.state.options[d];
        i10 ? g || (c = true) : s10 ? (f10.push(`set ${g ? "-o" : "+o"} ${p}`), g || (c = true)) : (f10.push(`${p}		${g ? "on" : "off"}`), g || (c = true));
      }
  }
  return { exitCode: c ? 1 : 0, stdout: f10.length > 0 ? `${f10.join(`
`)}
` : "", stderr: u };
}
async function X6(e11, t10, n10) {
  if (t10.includes("/")) {
    let o10 = e11.fs.resolvePath(e11.state.cwd, t10);
    if (!await e11.fs.exists(o10))
      return { error: "not_found", path: o10 };
    let a = o10.split("/").pop() || t10, l = e11.commands.get(a);
    try {
      let c = await e11.fs.stat(o10);
      return c.isDirectory ? { error: "permission_denied", path: o10 } : l ? { cmd: l, path: o10 } : (c.mode & 73) !== 0 ? { script: true, path: o10 } : { error: "permission_denied", path: o10 };
    } catch {
      return { error: "not_found", path: o10 };
    }
  }
  if (!n10 && e11.state.hashTable) {
    let o10 = e11.state.hashTable.get(t10);
    if (o10)
      if (await e11.fs.exists(o10)) {
        let a = e11.commands.get(t10);
        if (a)
          return { cmd: a, path: o10 };
        try {
          let l = await e11.fs.stat(o10);
          if (!l.isDirectory && (l.mode & 73) !== 0)
            return { script: true, path: o10 };
        } catch {
        }
      } else
        e11.state.hashTable.delete(t10);
  }
  let s10 = (n10 ?? e11.state.env.get("PATH") ?? "/usr/bin:/bin").split(":");
  for (let o10 of s10) {
    if (!o10)
      continue;
    let l = `${o10.startsWith("/") ? o10 : e11.fs.resolvePath(e11.state.cwd, o10)}/${t10}`;
    if (await e11.fs.exists(l))
      try {
        let c = await e11.fs.stat(l);
        if (c.isDirectory)
          continue;
        let u = (c.mode & 73) !== 0, f10 = e11.commands.get(t10), p = o10 === "/bin" || o10 === "/usr/bin";
        if (f10 && p)
          return { cmd: f10, path: l };
        if (u) {
          if (f10 && !p)
            return { script: true, path: l };
          if (!f10)
            return { script: true, path: l };
        }
      } catch {
      }
  }
  if (!await e11.fs.exists("/usr/bin")) {
    let o10 = e11.commands.get(t10);
    if (o10)
      return { cmd: o10, path: `/usr/bin/${t10}` };
  }
  return null;
}
async function ko(e11, t10) {
  let n10 = [];
  if (t10.includes("/")) {
    let i10 = e11.fs.resolvePath(e11.state.cwd, t10);
    if (await e11.fs.exists(i10))
      try {
        let o10 = await e11.fs.stat(i10);
        o10.isDirectory || (o10.mode & 73) !== 0 && n10.push(t10);
      } catch {
      }
    return n10;
  }
  let s10 = (e11.state.env.get("PATH") || "/usr/bin:/bin").split(":");
  for (let i10 of s10) {
    if (!i10)
      continue;
    let a = `${i10.startsWith("/") ? i10 : e11.fs.resolvePath(e11.state.cwd, i10)}/${t10}`;
    if (await e11.fs.exists(a)) {
      try {
        if ((await e11.fs.stat(a)).isDirectory)
          continue;
      } catch {
        continue;
      }
      n10.push(i10.startsWith("/") ? a : `${i10}/${t10}`);
    }
  }
  return n10;
}
ye();
Wt();
async function tg(e11, t10, n10, r10) {
  let s10 = false, i10 = false, o10 = false, a = false, l = false, c = [];
  for (let d of t10)
    if (d.startsWith("-") && d.length > 1)
      for (let g of d.slice(1))
        g === "t" ? s10 = true : g === "p" ? i10 = true : g === "P" ? o10 = true : g === "a" ? a = true : g === "f" && (l = true);
    else
      c.push(d);
  let u = "", f10 = "", p = 0, h = false, m = false;
  for (let d of c) {
    let g = false;
    if (o10) {
      if (a) {
        let O = await r10(d);
        if (O.length > 0) {
          for (let R10 of O)
            u += `${R10}
`;
          h = true, g = true;
        }
      } else {
        let O = await n10(d);
        O && (u += `${O}
`, h = true, g = true);
      }
      g || (m = true);
      continue;
    }
    let y = !l && e11.state.functions.has(d);
    if (a && y) {
      if (!i10)
        if (s10)
          u += `function
`;
        else {
          let O = e11.state.functions.get(d), R10 = O ? Y6(d, O) : `${d} is a function
`;
          u += R10;
        }
      g = true;
    }
    let w = e11.state.env.get(`BASH_ALIAS_${d}`);
    if (w !== void 0 && (a || !g) && (i10 || (s10 ? u += `alias
` : u += `${d} is aliased to \`${w}'
`), g = true, !a) || wc.has(d) && (a || !g) && (i10 || (s10 ? u += `keyword
` : u += `${d} is a shell keyword
`), g = true, !a))
      continue;
    if (!a && y && !g) {
      if (!i10)
        if (s10)
          u += `function
`;
        else {
          let O = e11.state.functions.get(d), R10 = O ? Y6(d, O) : `${d} is a function
`;
          u += R10;
        }
      g = true;
      continue;
    }
    if (!(zr.has(d) && (a || !g) && (i10 || (s10 ? u += `builtin
` : u += `${d} is a shell builtin
`), g = true, !a))) {
      if (a) {
        let O = await r10(d);
        for (let R10 of O)
          i10 ? u += `${R10}
` : s10 ? u += `file
` : u += `${d} is ${R10}
`, h = true, g = true;
      } else if (!g) {
        let O = await n10(d);
        O && (i10 ? u += `${O}
` : s10 ? u += `file
` : u += `${d} is ${O}
`, h = true, g = true);
      }
      if (!g && (m = true, !s10 && !i10)) {
        let O = true;
        if (d.includes("/")) {
          let R10 = e11.fs.resolvePath(e11.state.cwd, d);
          await e11.fs.exists(R10) && (O = false);
        }
        O && (f10 += `bash: type: ${d}: not found
`);
      }
    }
  }
  return i10 ? p = m && !h ? 1 : 0 : p = m ? 1 : 0, B(u, f10, p);
}
function Y6(e11, t10) {
  let n10;
  return t10.body.type === "Group" ? n10 = t10.body.body.map((s10) => Os(s10)).join("; ") : n10 = Os(t10.body), `${e11} is a function
${e11} () 
{ 
    ${n10}
}
`;
}
function Os(e11) {
  if (Array.isArray(e11))
    return e11.map((t10) => Os(t10)).join("; ");
  if (e11.type === "Statement") {
    let t10 = [];
    for (let n10 = 0; n10 < e11.pipelines.length; n10++) {
      let r10 = e11.pipelines[n10];
      t10.push(DE(r10)), e11.operators[n10] && t10.push(e11.operators[n10]);
    }
    return t10.join(" ");
  }
  if (e11.type === "SimpleCommand") {
    let t10 = e11, n10 = [];
    t10.name && n10.push(J6(t10.name));
    for (let r10 of t10.args)
      n10.push(J6(r10));
    return n10.join(" ");
  }
  return e11.type === "Group" ? `{ ${e11.body.map((r10) => Os(r10)).join("; ")}; }` : "...";
}
function DE(e11) {
  let t10 = e11.commands.map((n10) => Os(n10));
  return (e11.negated ? "! " : "") + t10.join(" | ");
}
function J6(e11) {
  let t10 = "";
  for (let n10 of e11.parts)
    n10.type === "Literal" ? t10 += n10.value : n10.type === "DoubleQuoted" ? t10 += `"${n10.parts.map((r10) => eg(r10)).join("")}"` : n10.type === "SingleQuoted" ? t10 += `'${n10.value}'` : t10 += eg(n10);
  return t10;
}
function eg(e11) {
  let t10 = e11;
  return t10.type === "Literal" ? t10.value ?? "" : t10.type === "Variable" ? `$${t10.name}` : "";
}
async function ng(e11, t10, n10, r10) {
  let s10 = "", i10 = "", o10 = 0;
  for (let a of t10) {
    if (!a) {
      o10 = 1;
      continue;
    }
    let l = e11.state.env.get(`BASH_ALIAS_${a}`);
    if (l !== void 0)
      r10 ? s10 += `${a} is an alias for "${l}"
` : s10 += `alias ${a}='${l}'
`;
    else if (wc.has(a))
      r10 ? s10 += `${a} is a shell keyword
` : s10 += `${a}
`;
    else if (zr.has(a))
      r10 ? s10 += `${a} is a shell builtin
` : s10 += `${a}
`;
    else if (e11.state.functions.has(a))
      r10 ? s10 += `${a} is a function
` : s10 += `${a}
`;
    else if (a.includes("/")) {
      let c = e11.fs.resolvePath(e11.state.cwd, a), u = false;
      if (await e11.fs.exists(c))
        try {
          let f10 = await e11.fs.stat(c);
          f10.isDirectory || (f10.mode & 73) !== 0 && (r10 ? s10 += `${a} is ${a}
` : s10 += `${a}
`, u = true);
        } catch {
        }
      u || (r10 && (i10 += `${a}: not found
`), o10 = 1);
    } else if (e11.commands.has(a)) {
      let u = (e11.state.env.get("PATH") ?? "/usr/bin:/bin").split(":"), f10 = null;
      for (let p of u) {
        if (!p)
          continue;
        let h = `${p}/${a}`;
        try {
          let m = await e11.fs.stat(h);
          if (!m.isDirectory && (m.mode & 73) !== 0) {
            f10 = h;
            break;
          }
        } catch {
        }
      }
      f10 || (f10 = `/usr/bin/${a}`), r10 ? s10 += `${a} is ${f10}
` : s10 += `${f10}
`;
    } else
      r10 && (i10 += `${a}: not found
`), o10 = 1;
  }
  return B(s10, i10, o10);
}
async function rg(e11, t10) {
  if (t10.includes("/")) {
    let s10 = e11.fs.resolvePath(e11.state.cwd, t10);
    if (await e11.fs.exists(s10)) {
      try {
        let i10 = await e11.fs.stat(s10);
        if (i10.isDirectory || !((i10.mode & 73) !== 0))
          return null;
      } catch {
        return null;
      }
      return t10;
    }
    return null;
  }
  let r10 = (e11.state.env.get("PATH") ?? "/usr/bin:/bin").split(":");
  for (let s10 of r10) {
    if (!s10)
      continue;
    let o10 = `${s10.startsWith("/") ? s10 : e11.fs.resolvePath(e11.state.cwd, s10)}/${t10}`;
    if (await e11.fs.exists(o10)) {
      try {
        if ((await e11.fs.stat(o10)).isDirectory)
          continue;
      } catch {
        continue;
      }
      return `${s10}/${t10}`;
    }
  }
  if (e11.commands.has(t10)) {
    for (let s10 of r10)
      if (s10 === "/usr/bin" || s10 === "/bin")
        return `${s10}/${t10}`;
    return `/usr/bin/${t10}`;
  }
  return null;
}
async function sg(e11, t10, n10, r10, s10, i10, o10, a) {
  let { ctx: l, runCommand: c } = e11;
  if (l.coverage && zr.has(t10) && l.coverage.hit(`bash:builtin:${t10}`), t10 === "export")
    return Wc(l, n10);
  if (t10 === "unset")
    return Jc(l, n10);
  if (t10 === "exit")
    return Uc(l, n10);
  if (t10 === "local")
    return jc(l, n10);
  if (t10 === "set")
    return Qc(l, n10);
  if (t10 === "break")
    return pc(l, n10);
  if (t10 === "continue")
    return Nc(l, n10);
  if (t10 === "return")
    return qc(l, n10);
  if (t10 === "eval" && l.state.options.posix)
    return Ao(l, n10, s10);
  if (t10 === "shift")
    return Kc(l, n10);
  if (t10 === "getopts")
    return So(l, n10);
  if (t10 === "compgen")
    return Ec(l, n10);
  if (t10 === "complete")
    return Sc(l, n10);
  if (t10 === "compopt")
    return Cc(l, n10);
  if (t10 === "pushd")
    return await Lc(l, n10);
  if (t10 === "popd")
    return Fc(l, n10);
  if (t10 === "dirs")
    return Mc(l, n10);
  if (t10 === "source" || t10 === ".")
    return Xc(l, n10);
  if (t10 === "read")
    return Vc(l, n10, s10, a);
  if (t10 === "mapfile" || t10 === "readarray")
    return Gc(l, n10, s10);
  if (t10 === "declare" || t10 === "typeset")
    return Pc(l, n10);
  if (t10 === "readonly")
    return Dc(l, n10);
  if (!i10) {
    let u = l.state.functions.get(t10);
    if (u)
      return xo(l, u, n10, s10);
  }
  if (t10 === "eval")
    return Ao(l, n10, s10);
  if (t10 === "cd")
    return await hc(l, n10);
  if (t10 === ":" || t10 === "true")
    return de;
  if (t10 === "false")
    return Ye(false);
  if (t10 === "let")
    return Hc(l, n10);
  if (t10 === "command")
    return _E(e11, n10, s10);
  if (t10 === "builtin")
    return LE(e11, n10, s10);
  if (t10 === "shopt")
    return K6(l, n10);
  if (t10 === "exec") {
    if (n10.length === 0)
      return de;
    let [u, ...f10] = n10;
    return c(u, f10, [], s10, false, false, -1);
  }
  if (t10 === "wait")
    return de;
  if (t10 === "type")
    return await tg(l, n10, (u) => rg(l, u), (u) => ko(l, u));
  if (t10 === "hash")
    return Bc(l, n10);
  if (t10 === "help")
    return zc(l, n10);
  if (t10 === "[" || t10 === "test") {
    let u = n10;
    if (t10 === "[") {
      if (n10[n10.length - 1] !== "]")
        return W("[: missing `]'\n", 2);
      u = n10.slice(0, -1);
    }
    return ks(l, u);
  }
  return null;
}
async function _E(e11, t10, n10) {
  let { ctx: r10, runCommand: s10 } = e11;
  if (t10.length === 0)
    return de;
  let i10 = false, o10 = false, a = false, l = t10;
  for (; l.length > 0 && l[0].startsWith("-"); ) {
    let f10 = l[0];
    if (f10 === "--") {
      l = l.slice(1);
      break;
    }
    for (let p of f10.slice(1))
      p === "p" ? i10 = true : p === "V" ? o10 = true : p === "v" && (a = true);
    l = l.slice(1);
  }
  if (l.length === 0)
    return de;
  if (a || o10)
    return await ng(r10, l, a, o10);
  let [c, ...u] = l;
  return s10(c, u, [], n10, true, i10, -1);
}
async function LE(e11, t10, n10) {
  let { runCommand: r10 } = e11;
  if (t10.length === 0)
    return de;
  let s10 = t10;
  if (s10[0] === "--" && (s10 = s10.slice(1), s10.length === 0))
    return de;
  let i10 = s10[0];
  if (!zr.has(i10))
    return W(`bash: builtin: ${i10}: not a shell builtin
`);
  let [, ...o10] = s10;
  return r10(i10, o10, [], n10, true, false, -1);
}
async function ig(e11, t10, n10, r10, s10) {
  let { ctx: i10, buildExportedEnv: o10, executeUserScript: a } = e11, c = await X6(i10, t10, s10 ? "/usr/bin:/bin" : void 0);
  if (!c)
    return h6(t10) ? W(`bash: ${t10}: command not available in browser environments. Exclude '${t10}' from your commands or use the Node.js bundle.
`, 127) : W(`bash: ${t10}: command not found
`, 127);
  if ("error" in c)
    return c.error === "permission_denied" ? W(`bash: ${t10}: Permission denied
`, 126) : W(`bash: ${t10}: No such file or directory
`, 127);
  if ("script" in c)
    return t10.includes("/") || (i10.state.hashTable || (i10.state.hashTable = /* @__PURE__ */ new Map()), i10.state.hashTable.set(t10, c.path)), await a(c.path, n10, r10);
  let { cmd: u, path: f10 } = c;
  t10.includes("/") || (i10.state.hashTable || (i10.state.hashTable = /* @__PURE__ */ new Map()), i10.state.hashTable.set(t10, f10));
  let p = r10 || i10.state.groupStdin || "", h = o10(), m = { fs: i10.fs, cwd: i10.state.cwd, env: i10.state.env, exportedEnv: h, stdin: p, limits: i10.limits, exec: i10.execFn, fetch: i10.fetch, getRegisteredCommands: () => Array.from(i10.commands.keys()), sleep: i10.sleep, trace: i10.trace, fileDescriptors: i10.state.fileDescriptors, xpgEcho: i10.state.shoptOptions.xpg_echo, coverage: i10.coverage };
  try {
    return await u.execute(n10, m);
  } catch (d) {
    if (d instanceof te)
      throw d;
    return W(`${t10}: ${Me(d)}
`);
  }
}
St();
ye();
Ct();
async function tu(e11, t10) {
  let n10 = e11.state.inCondition;
  e11.state.inCondition = true;
  let r10 = "", s10 = "", i10 = 0;
  try {
    for (let o10 of t10) {
      let a = await e11.executeStatement(o10);
      r10 += a.stdout, s10 += a.stderr, i10 = a.exitCode;
    }
  } finally {
    e11.state.inCondition = n10;
  }
  return { stdout: r10, stderr: s10, exitCode: i10 };
}
ye();
Wt();
function Rs(e11, t10, n10, r10) {
  if (e11 instanceof ft)
    return t10 += e11.stdout, n10 += e11.stderr, e11.levels > 1 && r10 > 1 ? (e11.levels--, e11.stdout = t10, e11.stderr = n10, { action: "rethrow", stdout: t10, stderr: n10, error: e11 }) : { action: "break", stdout: t10, stderr: n10 };
  if (e11 instanceof pt)
    return t10 += e11.stdout, n10 += e11.stderr, e11.levels > 1 && r10 > 1 ? (e11.levels--, e11.stdout = t10, e11.stderr = n10, { action: "rethrow", stdout: t10, stderr: n10, error: e11 }) : { action: "continue", stdout: t10, stderr: n10 };
  if (e11 instanceof at || e11 instanceof kt || e11 instanceof pe || e11 instanceof te)
    return e11.prependOutput(t10, n10), { action: "rethrow", stdout: t10, stderr: n10, error: e11 };
  let s10 = Me(e11);
  return { action: "error", stdout: t10, stderr: `${n10}${s10}
`, exitCode: 1 };
}
ye();
Wt();
async function vo(e11, t10, n10 = "", r10 = "") {
  let s10 = n10, i10 = r10, o10 = 0;
  try {
    for (let a of t10) {
      let l = await e11.executeStatement(a);
      s10 += l.stdout, i10 += l.stderr, o10 = l.exitCode;
    }
  } catch (a) {
    if (Fs(a) || a instanceof kt || a instanceof pe || a instanceof te || a instanceof an)
      throw a.prependOutput(s10, i10), a;
    return { stdout: s10, stderr: `${i10}${Me(a)}
`, exitCode: 1 };
  }
  return { stdout: s10, stderr: i10, exitCode: o10 };
}
async function og(e11, t10) {
  let n10 = "", r10 = "";
  for (let s10 of t10.clauses) {
    let i10 = await tu(e11, s10.condition);
    if (n10 += i10.stdout, r10 += i10.stderr, i10.exitCode === 0)
      return vo(e11, s10.body, n10, r10);
  }
  return t10.elseBody ? vo(e11, t10.elseBody, n10, r10) : B(n10, r10, 0);
}
async function ag(e11, t10) {
  let n10 = await bn(e11, t10.redirections);
  if (n10)
    return n10;
  let r10 = "", s10 = "", i10 = 0, o10 = 0;
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t10.variable))
    return W(`bash: \`${t10.variable}': not a valid identifier
`);
  let a = [];
  if (t10.words === null)
    a = (e11.state.env.get("@") || "").split(" ").filter(Boolean);
  else if (t10.words.length === 0)
    a = [];
  else
    try {
      for (let c of t10.words) {
        let u = await sn(e11, c);
        a.push(...u.values);
      }
    } catch (c) {
      if (c instanceof on2)
        return { stdout: "", stderr: c.stderr, exitCode: 1 };
      throw c;
    }
  e11.state.loopDepth++;
  try {
    for (let c of a) {
      o10++, o10 > e11.limits.maxLoopIterations && kn(`for loop: too many iterations (${e11.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", r10, s10), e11.state.env.set(t10.variable, c);
      try {
        for (let u of t10.body) {
          let f10 = await e11.executeStatement(u);
          r10 += f10.stdout, s10 += f10.stderr, i10 = f10.exitCode;
        }
      } catch (u) {
        let f10 = Rs(u, r10, s10, e11.state.loopDepth);
        if (r10 = f10.stdout, s10 = f10.stderr, f10.action === "break")
          break;
        if (f10.action === "continue")
          continue;
        if (f10.action === "error") {
          let p = B(r10, s10, f10.exitCode ?? 1);
          return Be(e11, p, t10.redirections);
        }
        throw f10.error;
      }
    }
  } finally {
    e11.state.loopDepth--;
  }
  let l = B(r10, s10, i10);
  return Be(e11, l, t10.redirections);
}
async function lg(e11, t10) {
  let n10 = await bn(e11, t10.redirections);
  if (n10)
    return n10;
  let r10 = t10.line;
  r10 !== void 0 && (e11.state.currentLine = r10);
  let s10 = "", i10 = "", o10 = 0, a = 0;
  t10.init && await ne(e11, t10.init.expression), e11.state.loopDepth++;
  try {
    for (; a++, a > e11.limits.maxLoopIterations && kn(`for loop: too many iterations (${e11.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", s10, i10), !(t10.condition && (r10 !== void 0 && (e11.state.currentLine = r10), await ne(e11, t10.condition.expression) === 0)); ) {
      try {
        for (let c of t10.body) {
          let u = await e11.executeStatement(c);
          s10 += u.stdout, i10 += u.stderr, o10 = u.exitCode;
        }
      } catch (c) {
        let u = Rs(c, s10, i10, e11.state.loopDepth);
        if (s10 = u.stdout, i10 = u.stderr, u.action === "break")
          break;
        if (u.action === "continue") {
          t10.update && await ne(e11, t10.update.expression);
          continue;
        }
        if (u.action === "error") {
          let f10 = B(s10, i10, u.exitCode ?? 1);
          return Be(e11, f10, t10.redirections);
        }
        throw u.error;
      }
      t10.update && await ne(e11, t10.update.expression);
    }
  } finally {
    e11.state.loopDepth--;
  }
  let l = B(s10, i10, o10);
  return Be(e11, l, t10.redirections);
}
async function cg(e11, t10, n10 = "") {
  let r10 = "", s10 = "", i10 = 0, o10 = 0, a = n10;
  for (let c of t10.redirections)
    if ((c.operator === "<<" || c.operator === "<<-") && c.target.type === "HereDoc") {
      let u = c.target, f10 = await ie(e11, u.content);
      u.stripTabs && (f10 = f10.split(`
`).map((p) => p.replace(/^\t+/, "")).join(`
`)), a = f10;
    } else if (c.operator === "<<<" && c.target.type === "Word")
      a = `${await ie(e11, c.target)}
`;
    else if (c.operator === "<" && c.target.type === "Word")
      try {
        let u = await ie(e11, c.target), f10 = e11.fs.resolvePath(e11.state.cwd, u);
        a = await e11.fs.readFile(f10);
      } catch {
        let u = await ie(e11, c.target);
        return W(`bash: ${u}: No such file or directory
`);
      }
  let l = e11.state.groupStdin;
  a && (e11.state.groupStdin = a), e11.state.loopDepth++;
  try {
    for (; ; ) {
      o10++, o10 > e11.limits.maxLoopIterations && kn(`while loop: too many iterations (${e11.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", r10, s10);
      let c = 0, u = false, f10 = false, p = e11.state.inCondition;
      e11.state.inCondition = true;
      try {
        for (let h of t10.condition) {
          let m = await e11.executeStatement(h);
          r10 += m.stdout, s10 += m.stderr, c = m.exitCode;
        }
      } catch (h) {
        if (h instanceof ft) {
          if (r10 += h.stdout, s10 += h.stderr, h.levels > 1 && e11.state.loopDepth > 1)
            throw h.levels--, h.stdout = r10, h.stderr = s10, e11.state.inCondition = p, h;
          u = true;
        } else if (h instanceof pt) {
          if (r10 += h.stdout, s10 += h.stderr, h.levels > 1 && e11.state.loopDepth > 1)
            throw h.levels--, h.stdout = r10, h.stderr = s10, e11.state.inCondition = p, h;
          f10 = true;
        } else
          throw e11.state.inCondition = p, h;
      } finally {
        e11.state.inCondition = p;
      }
      if (u)
        break;
      if (!f10) {
        if (c !== 0)
          break;
        try {
          for (let h of t10.body) {
            let m = await e11.executeStatement(h);
            r10 += m.stdout, s10 += m.stderr, i10 = m.exitCode;
          }
        } catch (h) {
          let m = Rs(h, r10, s10, e11.state.loopDepth);
          if (r10 = m.stdout, s10 = m.stderr, m.action === "break")
            break;
          if (m.action === "continue")
            continue;
          if (m.action === "error")
            return B(r10, s10, m.exitCode ?? 1);
          throw m.error;
        }
      }
    }
  } finally {
    e11.state.loopDepth--, e11.state.groupStdin = l;
  }
  return B(r10, s10, i10);
}
async function ug(e11, t10) {
  let n10 = "", r10 = "", s10 = 0, i10 = 0;
  e11.state.loopDepth++;
  try {
    for (; ; ) {
      i10++, i10 > e11.limits.maxLoopIterations && kn(`until loop: too many iterations (${e11.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", n10, r10);
      let o10 = await tu(e11, t10.condition);
      if (n10 += o10.stdout, r10 += o10.stderr, o10.exitCode === 0)
        break;
      try {
        for (let a of t10.body) {
          let l = await e11.executeStatement(a);
          n10 += l.stdout, r10 += l.stderr, s10 = l.exitCode;
        }
      } catch (a) {
        let l = Rs(a, n10, r10, e11.state.loopDepth);
        if (n10 = l.stdout, r10 = l.stderr, l.action === "break")
          break;
        if (l.action === "continue")
          continue;
        if (l.action === "error")
          return B(n10, r10, l.exitCode ?? 1);
        throw l.error;
      }
    }
  } finally {
    e11.state.loopDepth--;
  }
  return B(n10, r10, s10);
}
async function fg(e11, t10) {
  let n10 = await bn(e11, t10.redirections);
  if (n10)
    return n10;
  let r10 = "", s10 = "", i10 = 0, o10 = await ie(e11, t10.word), a = false;
  for (let c = 0; c < t10.items.length; c++) {
    let u = t10.items[c], f10 = a;
    if (!a)
      for (let p of u.patterns) {
        let h = await ie(e11, p);
        ic(p) && (h = Pt(h));
        let m = e11.state.shoptOptions.nocasematch, d = e11.state.shoptOptions.extglob;
        if (Wr(o10, h, m, d)) {
          f10 = true;
          break;
        }
      }
    if (f10) {
      let p = await vo(e11, u.body, r10, s10);
      if (r10 = p.stdout, s10 = p.stderr, i10 = p.exitCode, u.terminator === ";;")
        break;
      u.terminator === ";&" ? a = true : a = false;
    } else
      a = false;
  }
  let l = B(r10, s10, i10);
  return Be(e11, l, t10.redirections);
}
ye();
Ct();
function nu(e11, t10) {
  if (e11.parts.length !== 1)
    return false;
  let n10 = e11.parts[0];
  return n10.type !== "Literal" ? false : t10.includes(n10.value);
}
function pg(e11) {
  if (!e11.startsWith("__rw__:"))
    return null;
  let t10 = e11.slice(7), n10 = t10.indexOf(":");
  if (n10 === -1)
    return null;
  let r10 = Number.parseInt(t10.slice(0, n10), 10);
  if (Number.isNaN(r10) || r10 < 0)
    return null;
  let s10 = n10 + 1, i10 = t10.slice(s10, s10 + r10), o10 = s10 + r10 + 1, a = t10.slice(o10), l = a.indexOf(":");
  if (l === -1)
    return null;
  let c = Number.parseInt(a.slice(0, l), 10);
  if (Number.isNaN(c) || c < 0)
    return null;
  let u = a.slice(l + 1);
  return { path: i10, position: c, content: u };
}
Ke();
Ct();
var hg = "+ ";
async function dg(e11) {
  let t10 = e11.state.env.get("PS4");
  if (t10 === void 0)
    return hg;
  if (t10 === "")
    return "";
  try {
    let r10 = new ce().parseWordFromString(t10, false, false);
    return await ie(e11, r10);
  } catch {
    return e11.state.expansionStderr = `${e11.state.expansionStderr || ""}bash: ${t10}: bad substitution
`, t10 || hg;
  }
}
function FE(e11) {
  return e11.map((t10) => ME(t10)).join(" ");
}
function ME(e11) {
  if (e11 === "")
    return "''";
  if (!/[\s'"\\$`!*?[\]{}|&;<>()~#\n\t]/.test(e11))
    return e11;
  let n10 = /[\x00-\x1f\x7f]/.test(e11), r10 = e11.includes(`
`), s10 = e11.includes("	"), i10 = e11.includes("\\"), o10 = e11.includes("'");
  if (n10 || r10 || s10 || i10) {
    let l = "";
    for (let c of e11) {
      let u = c.charCodeAt(0);
      c === `
` ? l += "\\n" : c === "	" ? l += "\\t" : c === "\\" ? l += "\\\\" : c === "'" ? l += "'" : c === '"' ? l += '"' : u < 32 || u === 127 ? u < 256 ? l += `\\x${u.toString(16).padStart(2, "0")}` : l += `\\u${u.toString(16).padStart(4, "0")}` : l += c;
    }
    return `$'${l}'`;
  }
  return o10 ? `"${e11.replace(/([\\$`"])/g, "\\$1")}"` : `'${e11}'`;
}
async function mg(e11, t10, n10) {
  if (!e11.state.options.xtrace)
    return "";
  let r10 = await dg(e11), s10 = [t10, ...n10], i10 = FE(s10);
  return `${r10}${i10}
`;
}
async function gg(e11, t10, n10) {
  return e11.state.options.xtrace ? `${await dg(e11)}${t10}=${n10}
` : "";
}
ye();
async function yg(e11, t10, n10) {
  let r10 = t10.timed ? performance.now() : 0, s10 = "", i10 = de, o10 = 0, a = [], l = t10.commands.length > 1, c = e11.state.lastArg;
  for (let f10 = 0; f10 < t10.commands.length; f10++) {
    let p = t10.commands[f10], h = f10 === t10.commands.length - 1;
    l && (e11.state.lastArg = "");
    let d = l && (!h || !e11.state.shoptOptions.lastpipe) ? new Map(e11.state.env) : null, g;
    try {
      g = await n10(p, s10);
    } catch (y) {
      if (y instanceof wt)
        g = { stdout: y.stdout, stderr: y.stderr, exitCode: 1 };
      else if (y instanceof pe && t10.commands.length > 1)
        g = { stdout: y.stdout, stderr: y.stderr, exitCode: y.exitCode };
      else if (y instanceof kt && t10.commands.length > 1)
        g = { stdout: y.stdout, stderr: y.stderr, exitCode: y.exitCode };
      else
        throw d && (e11.state.env = d), y;
    }
    d && (e11.state.env = d), a.push(g.exitCode), g.exitCode !== 0 && (o10 = g.exitCode), h ? i10 = g : t10.pipeStderr?.[f10] ?? false ? (s10 = g.stderr + g.stdout, i10 = { stdout: "", stderr: "", exitCode: g.exitCode }) : (s10 = g.stdout, i10 = { stdout: "", stderr: g.stderr, exitCode: g.exitCode });
  }
  if (t10.commands.length > 1 || t10.commands.length === 1 && t10.commands[0].type === "SimpleCommand") {
    for (let f10 of e11.state.env.keys())
      f10.startsWith("PIPESTATUS_") && e11.state.env.delete(f10);
    for (let f10 = 0; f10 < a.length; f10++)
      e11.state.env.set(`PIPESTATUS_${f10}`, String(a[f10]));
    e11.state.env.set("PIPESTATUS__length", String(a.length));
  }
  if (e11.state.options.pipefail && o10 !== 0 && (i10 = { ...i10, exitCode: o10 }), t10.negated && (i10 = { ...i10, exitCode: i10.exitCode === 0 ? 1 : 0 }), t10.timed) {
    let p = (performance.now() - r10) / 1e3, h = Math.floor(p / 60), m = p % 60, d;
    t10.timePosix ? d = `real ${p.toFixed(2)}
user 0.00
sys 0.00
` : d = `
real	${`${h}m${m.toFixed(3)}s`}
user	0m0.000s
sys	0m0.000s
`, i10 = { ...i10, stderr: i10.stderr + d };
  }
  return l && !e11.state.shoptOptions.lastpipe && (e11.state.lastArg = c), i10;
}
dt();
Ke();
St();
ye();
Ct();
Qt();
tn();
Fn();
async function wg(e11, t10) {
  let n10 = /* @__PURE__ */ new Map(), r10 = "";
  for (let s10 of t10.assignments) {
    let i10 = s10.name;
    if (s10.array) {
      let u = await UE(e11, t10, i10, s10.array, s10.append, n10);
      if (u.error)
        return { continueToNext: false, xtraceOutput: r10, tempAssignments: n10, error: u.error };
      if (r10 += u.xtraceOutput, u.continueToNext)
        continue;
    }
    let o10 = s10.value ? await ie(e11, s10.value) : "";
    if (i10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[\]$/))
      return { continueToNext: false, xtraceOutput: r10, tempAssignments: n10, error: B("", `bash: ${i10}: bad array subscript
`, 1) };
    let l = i10.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    if (l) {
      let u = await jE(e11, t10, l[1], l[2], o10, s10.append, n10);
      if (u.error)
        return { continueToNext: false, xtraceOutput: r10, tempAssignments: n10, error: u.error };
      if (u.continueToNext)
        continue;
    }
    let c = await VE(e11, t10, i10, o10, s10.append, n10);
    if (c.error)
      return { continueToNext: false, xtraceOutput: r10, tempAssignments: n10, error: c.error };
    r10 += c.xtraceOutput, c.continueToNext;
  }
  return { continueToNext: false, xtraceOutput: r10, tempAssignments: n10 };
}
async function UE(e11, t10, n10, r10, s10, i10) {
  let o10 = "";
  if (/\[.+\]$/.test(n10))
    return { continueToNext: false, xtraceOutput: "", error: B("", `bash: ${n10}: cannot assign list to array member
`, 1) };
  if (Te(e11, n10)) {
    let u = rr(e11, n10);
    if (u === void 0 || u === "")
      throw new pe(1, "", "");
    let f10 = At(e11, n10);
    if (f10 && /^[a-zA-Z_][a-zA-Z0-9_]*\[@\]$/.test(f10))
      return { continueToNext: false, xtraceOutput: "", error: B("", `bash: ${n10}: cannot assign list to array member
`, 1) };
  }
  if (yn(e11, n10)) {
    if (t10.name)
      return o10 += `bash: ${n10}: readonly variable
`, { continueToNext: true, xtraceOutput: o10 };
    let u = st(e11, n10);
    if (u)
      return { continueToNext: false, xtraceOutput: "", error: u };
  }
  let a = e11.state.associativeArrays?.has(n10), l = WE(r10), c = () => {
    let u = `${n10}_`;
    for (let f10 of e11.state.env.keys())
      f10.startsWith(u) && !f10.includes("__") && e11.state.env.delete(f10);
    e11.state.env.delete(n10);
  };
  if (a && l ? await BE(e11, t10, n10, r10, s10, c, (u) => {
    o10 += u;
  }) : l ? await zE(e11, n10, r10, s10, c) : await HE(e11, n10, r10, s10, c), t10.name) {
    i10.set(n10, e11.state.env.get(n10));
    let f10 = `(${r10.map((p) => Pr(p)).join(" ")})`;
    e11.state.env.set(n10, f10);
  }
  return { continueToNext: true, xtraceOutput: o10 };
}
function WE(e11) {
  return e11.some((t10) => {
    if (t10.parts.length >= 2) {
      let n10 = t10.parts[0], r10 = t10.parts[1];
      if (n10.type !== "Glob" || !n10.pattern.startsWith("["))
        return false;
      if (n10.pattern === "[" && (r10.type === "DoubleQuoted" || r10.type === "SingleQuoted")) {
        if (t10.parts.length < 3)
          return false;
        let s10 = t10.parts[2];
        return s10.type !== "Literal" ? false : s10.value.startsWith("]=") || s10.value.startsWith("]+=");
      }
      return r10.type !== "Literal" ? false : r10.value.startsWith("]") ? r10.value.startsWith("]=") || r10.value.startsWith("]+=") : n10.pattern.endsWith("]") ? r10.value.startsWith("=") || r10.value.startsWith("+=") : false;
    }
    return false;
  });
}
async function BE(e11, t10, n10, r10, s10, i10, o10) {
  let a = [];
  for (let l of r10) {
    let c = Zl(l);
    if (c) {
      let { key: u, valueParts: f10, append: p } = c, h;
      f10.length > 0 ? h = await ie(e11, { type: "Word", parts: f10 }) : h = "", h = Ve(e11, h), a.push({ type: "keyed", key: u, value: h, append: p });
    } else {
      let u = await ie(e11, l);
      a.push({ type: "invalid", expandedValue: u });
    }
  }
  s10 || i10();
  for (let l of a)
    if (l.type === "keyed")
      if (l.append) {
        let c = e11.state.env.get(`${n10}_${l.key}`) ?? "";
        e11.state.env.set(`${n10}_${l.key}`, c + l.value);
      } else
        e11.state.env.set(`${n10}_${l.key}`, l.value);
    else {
      let c = t10.line ?? e11.state.currentLine ?? 1;
      o10(`bash: line ${c}: ${n10}: ${l.expandedValue}: must use subscript when assigning associative array
`);
    }
}
async function zE(e11, t10, n10, r10, s10) {
  let i10 = [];
  for (let a of n10) {
    let l = Zl(a);
    if (l) {
      let { key: c, valueParts: u, append: f10 } = l, p;
      u.length > 0 ? p = await ie(e11, { type: "Word", parts: u }) : p = "", p = Ve(e11, p), i10.push({ type: "keyed", indexExpr: c, value: p, append: f10 });
    } else {
      let c = await sn(e11, a);
      i10.push({ type: "non-keyed", values: c.values });
    }
  }
  r10 || s10();
  let o10 = 0;
  for (let a of i10)
    if (a.type === "keyed") {
      let l;
      try {
        let c = new ce(), u = Ae(c, a.indexExpr);
        l = await ne(e11, u.expression, false);
      } catch {
        if (/^-?\d+$/.test(a.indexExpr))
          l = Number.parseInt(a.indexExpr, 10);
        else {
          let c = e11.state.env.get(a.indexExpr);
          l = c ? Number.parseInt(c, 10) : 0, Number.isNaN(l) && (l = 0);
        }
      }
      if (a.append) {
        let c = e11.state.env.get(`${t10}_${l}`) ?? "";
        e11.state.env.set(`${t10}_${l}`, c + a.value);
      } else
        e11.state.env.set(`${t10}_${l}`, a.value);
      o10 = l + 1;
    } else
      for (let l of a.values)
        e11.state.env.set(`${t10}_${o10++}`, l);
}
async function HE(e11, t10, n10, r10, s10) {
  let i10 = [];
  for (let a of n10) {
    let l = await sn(e11, a);
    i10.push(...l.values);
  }
  let o10 = 0;
  if (r10) {
    let a = ae(e11, t10);
    if (a.length > 0)
      o10 = Math.max(...a.map(([c]) => typeof c == "number" ? c : 0)) + 1;
    else {
      let l = e11.state.env.get(t10);
      l !== void 0 && (e11.state.env.set(`${t10}_0`, l), e11.state.env.delete(t10), o10 = 1);
    }
  } else
    s10();
  for (let a = 0; a < i10.length; a++)
    e11.state.env.set(`${t10}_${o10 + a}`, i10[a]);
  r10 || e11.state.env.set(`${t10}__length`, String(i10.length));
}
async function jE(e11, t10, n10, r10, s10, i10, o10) {
  let a = n10;
  if (Te(e11, n10)) {
    let f10 = At(e11, n10);
    if (f10 && f10 !== n10) {
      if (f10.includes("["))
        return { continueToNext: false, xtraceOutput: "", error: B("", `bash: \`${f10}': not a valid identifier
`, 1) };
      a = f10;
    }
  }
  if (yn(e11, a)) {
    if (t10.name)
      return { continueToNext: true, xtraceOutput: "" };
    let f10 = st(e11, a);
    if (f10)
      return { continueToNext: false, xtraceOutput: "", error: f10 };
  }
  let l = e11.state.associativeArrays?.has(a), c;
  if (l)
    c = await bg(e11, a, r10);
  else {
    let f10 = await GE(e11, a, r10);
    if (f10.error)
      return { continueToNext: false, xtraceOutput: "", error: f10.error };
    c = `${a}_${f10.index}`;
  }
  let u = i10 ? (e11.state.env.get(c) || "") + s10 : s10;
  if (t10.name)
    o10.set(c, e11.state.env.get(c)), e11.state.env.set(c, u);
  else {
    let f10 = Br(e11, a);
    if (f10 !== void 0 && f10 === e11.state.callDepth && e11.state.localScopes.length > 0) {
      let p = e11.state.localScopes[e11.state.localScopes.length - 1];
      p.has(c) || p.set(c, e11.state.env.get(c));
    }
    e11.state.env.set(c, u);
  }
  return { continueToNext: true, xtraceOutput: "" };
}
async function bg(e11, t10, n10) {
  let r10;
  if (n10.startsWith("'") && n10.endsWith("'"))
    r10 = n10.slice(1, -1);
  else if (n10.startsWith('"') && n10.endsWith('"')) {
    let s10 = n10.slice(1, -1), o10 = new ce().parseWordFromString(s10, true, false);
    r10 = await ie(e11, o10);
  } else if (n10.includes("$")) {
    let i10 = new ce().parseWordFromString(n10, false, false);
    r10 = await ie(e11, i10);
  } else
    r10 = n10;
  return `${t10}_${r10}`;
}
async function GE(e11, t10, n10) {
  let r10 = n10;
  n10.startsWith('"') && n10.endsWith('"') && n10.length >= 2 && (r10 = n10.slice(1, -1));
  let s10;
  if (/^-?\d+$/.test(r10))
    s10 = Number.parseInt(r10, 10);
  else {
    try {
      let i10 = new ce(), o10 = Ae(i10, r10);
      s10 = await ne(e11, o10.expression, false);
    } catch (i10) {
      if (i10 instanceof $e) {
        let l = `bash: line ${e11.state.currentLine}: ${n10}: ${i10.message}
`;
        if (i10.fatal)
          throw new pe(1, "", l);
        return { index: 0, error: B("", l, 1) };
      }
      let o10 = e11.state.env.get(n10);
      s10 = o10 ? Number.parseInt(o10, 10) : 0;
    }
    Number.isNaN(s10) && (s10 = 0);
  }
  if (s10 < 0) {
    let i10 = ae(e11, t10);
    if (i10.length === 0) {
      let a = e11.state.currentLine;
      return { index: 0, error: B("", `bash: line ${a}: ${t10}[${n10}]: bad array subscript
`, 1) };
    }
    if (s10 = Math.max(...i10.map(([a]) => typeof a == "number" ? a : 0)) + 1 + s10, s10 < 0) {
      let a = e11.state.currentLine;
      return { index: 0, error: B("", `bash: line ${a}: ${t10}[${n10}]: bad array subscript
`, 1) };
    }
  }
  return { index: s10 };
}
async function VE(e11, t10, n10, r10, s10, i10) {
  let o10 = "", a = n10, l = null;
  if (Te(e11, n10)) {
    let f10 = jm(e11, n10, r10);
    if (f10 === void 0)
      return { continueToNext: false, xtraceOutput: "", error: B("", `bash: ${n10}: circular name reference
`, 1) };
    if (f10 === null)
      return { continueToNext: true, xtraceOutput: "" };
    a = f10;
    let p = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    p && (l = { arrayName: p[1], subscriptExpr: p[2] }, a = p[1]);
  }
  if (yn(e11, a)) {
    if (t10.name)
      return o10 += `bash: ${a}: readonly variable
`, { continueToNext: true, xtraceOutput: o10 };
    let f10 = st(e11, a);
    if (f10)
      return { continueToNext: false, xtraceOutput: "", error: f10 };
  }
  let c;
  if (vs(e11, a))
    try {
      let f10 = new ce();
      if (s10) {
        let h = `(${e11.state.env.get(a) || "0"}) + (${r10})`, m = Ae(f10, h);
        c = String(await ne(e11, m.expression));
      } else {
        let p = Ae(f10, r10);
        c = String(await ne(e11, p.expression));
      }
    } catch {
      c = "0";
    }
  else {
    let { isArray: f10 } = await Promise.resolve().then(() => (Ct(), cc)), p = f10(e11, a) ? `${a}_0` : a;
    c = s10 ? (e11.state.env.get(p) || "") + r10 : r10;
  }
  c = jr(e11, a, c), o10 += await gg(e11, a, c);
  let u = a;
  if (l)
    u = await qE(e11, l);
  else {
    let { isArray: f10 } = await Promise.resolve().then(() => (Ct(), cc));
    f10(e11, a) && (u = `${a}_0`);
  }
  return t10.name ? (i10.set(u, e11.state.env.get(u)), e11.state.env.set(u, c)) : (e11.state.env.set(u, c), e11.state.options.allexport && (e11.state.exportedVars = e11.state.exportedVars || /* @__PURE__ */ new Set(), e11.state.exportedVars.add(a)), e11.state.tempEnvBindings?.some((f10) => f10.has(a)) && (e11.state.mutatedTempEnvVars = e11.state.mutatedTempEnvVars || /* @__PURE__ */ new Set(), e11.state.mutatedTempEnvVars.add(a))), { continueToNext: false, xtraceOutput: o10 };
}
async function qE(e11, t10) {
  let { arrayName: n10, subscriptExpr: r10 } = t10;
  if (e11.state.associativeArrays?.has(n10))
    return bg(e11, n10, r10);
  let i10;
  if (/^-?\d+$/.test(r10))
    i10 = Number.parseInt(r10, 10);
  else {
    try {
      let o10 = new ce(), a = Ae(o10, r10);
      i10 = await ne(e11, a.expression, false);
    } catch {
      let o10 = e11.state.env.get(r10);
      i10 = o10 ? Number.parseInt(o10, 10) : 0;
    }
    Number.isNaN(i10) && (i10 = 0);
  }
  if (i10 < 0) {
    let o10 = ae(e11, n10);
    o10.length > 0 && (i10 = Math.max(...o10.map((l) => l[0])) + 1 + i10);
  }
  return `${n10}_${i10}`;
}
Ke();
ye();
Ct();
Wt();
async function xg(e11, t10, n10, r10) {
  let s10 = await bn(e11, t10.redirections);
  if (s10)
    return s10;
  let i10 = new Map(e11.state.env), o10 = e11.state.cwd, a = { ...e11.state.options }, l = new Map(e11.state.functions), c = e11.state.localScopes, u = e11.state.localVarStack, f10 = e11.state.localVarDepth, p = e11.state.fullyUnsetLocals;
  if (e11.state.localScopes = c.map((R10) => new Map(R10)), u) {
    e11.state.localVarStack = /* @__PURE__ */ new Map();
    for (let [R10, F4] of u.entries())
      e11.state.localVarStack.set(R10, F4.map(($) => ({ ...$ })));
  }
  f10 && (e11.state.localVarDepth = new Map(f10)), p && (e11.state.fullyUnsetLocals = new Map(p));
  let h = e11.state.loopDepth, m = e11.state.parentHasLoopContext;
  e11.state.parentHasLoopContext = h > 0, e11.state.loopDepth = 0;
  let d = e11.state.lastArg, g = e11.state.bashPid;
  e11.state.bashPid = e11.state.nextVirtualPid++;
  let y = e11.state.groupStdin;
  n10 && (e11.state.groupStdin = n10);
  let w = "", b = "", x = 0, S = () => {
    e11.state.env = i10, e11.state.cwd = o10, e11.state.options = a, e11.state.functions = l, e11.state.localScopes = c, e11.state.localVarStack = u, e11.state.localVarDepth = f10, e11.state.fullyUnsetLocals = p, e11.state.loopDepth = h, e11.state.parentHasLoopContext = m, e11.state.groupStdin = y, e11.state.bashPid = g, e11.state.lastArg = d;
  };
  try {
    for (let R10 of t10.body) {
      let F4 = await r10(R10);
      w += F4.stdout, b += F4.stderr, x = F4.exitCode;
    }
  } catch (R10) {
    if (S(), R10 instanceof te)
      throw R10;
    if (R10 instanceof an) {
      w += R10.stdout, b += R10.stderr;
      let $ = B(w, b, 0);
      return Be(e11, $, t10.redirections);
    }
    if (R10 instanceof ft || R10 instanceof pt) {
      w += R10.stdout, b += R10.stderr;
      let $ = B(w, b, 0);
      return Be(e11, $, t10.redirections);
    }
    if (R10 instanceof pe) {
      w += R10.stdout, b += R10.stderr;
      let $ = B(w, b, R10.exitCode);
      return Be(e11, $, t10.redirections);
    }
    if (R10 instanceof at) {
      w += R10.stdout, b += R10.stderr;
      let $ = B(w, b, R10.exitCode);
      return Be(e11, $, t10.redirections);
    }
    if (R10 instanceof kt) {
      let $ = B(w + R10.stdout, b + R10.stderr, R10.exitCode);
      return Be(e11, $, t10.redirections);
    }
    let F4 = B(w, `${b}${Me(R10)}
`, 1);
    return Be(e11, F4, t10.redirections);
  }
  S();
  let O = B(w, b, x);
  return Be(e11, O, t10.redirections);
}
async function Eg(e11, t10, n10, r10) {
  let s10 = "", i10 = "", o10 = 0, a = await bo(e11, t10.redirections);
  if (a)
    return a;
  let l = n10;
  for (let f10 of t10.redirections)
    if ((f10.operator === "<<" || f10.operator === "<<-") && f10.target.type === "HereDoc") {
      let p = f10.target, h = await ie(e11, p.content);
      p.stripTabs && (h = h.split(`
`).map((d) => d.replace(/^\t+/, "")).join(`
`));
      let m = f10.fd ?? 0;
      m !== 0 ? (e11.state.fileDescriptors || (e11.state.fileDescriptors = /* @__PURE__ */ new Map()), e11.state.fileDescriptors.set(m, h)) : l = h;
    } else if (f10.operator === "<<<" && f10.target.type === "Word")
      l = `${await ie(e11, f10.target)}
`;
    else if (f10.operator === "<" && f10.target.type === "Word")
      try {
        let p = await ie(e11, f10.target), h = e11.fs.resolvePath(e11.state.cwd, p);
        l = await e11.fs.readFile(h);
      } catch {
        let p = await ie(e11, f10.target);
        return B("", `bash: ${p}: No such file or directory
`, 1);
      }
  let c = e11.state.groupStdin;
  l && (e11.state.groupStdin = l);
  try {
    for (let f10 of t10.body) {
      let p = await r10(f10);
      s10 += p.stdout, i10 += p.stderr, o10 = p.exitCode;
    }
  } catch (f10) {
    if (e11.state.groupStdin = c, f10 instanceof te)
      throw f10;
    if (Fs(f10) || f10 instanceof kt || f10 instanceof pe)
      throw f10.prependOutput(s10, i10), f10;
    return B(s10, `${i10}${Me(f10)}
`, 1);
  }
  e11.state.groupStdin = c;
  let u = B(s10, i10, o10);
  return Be(e11, u, t10.redirections);
}
async function Ag(e11, t10, n10, r10, s10) {
  let i10;
  try {
    i10 = await e11.fs.readFile(t10);
  } catch {
    return W(`bash: ${t10}: No such file or directory
`, 127);
  }
  if (i10.startsWith("#!")) {
    let g = i10.indexOf(`
`);
    g !== -1 && (i10 = i10.slice(g + 1));
  }
  let o10 = new Map(e11.state.env), a = e11.state.cwd, l = { ...e11.state.options }, c = e11.state.loopDepth, u = e11.state.parentHasLoopContext, f10 = e11.state.lastArg, p = e11.state.bashPid, h = e11.state.groupStdin, m = e11.state.currentSource;
  e11.state.parentHasLoopContext = c > 0, e11.state.loopDepth = 0, e11.state.bashPid = e11.state.nextVirtualPid++, r10 && (e11.state.groupStdin = r10), e11.state.currentSource = t10, e11.state.env.set("0", t10), e11.state.env.set("#", String(n10.length)), e11.state.env.set("@", n10.join(" ")), e11.state.env.set("*", n10.join(" "));
  for (let g = 0; g < n10.length && g < 9; g++)
    e11.state.env.set(String(g + 1), n10[g]);
  for (let g = n10.length + 1; g <= 9; g++)
    e11.state.env.delete(String(g));
  let d = () => {
    e11.state.env = o10, e11.state.cwd = a, e11.state.options = l, e11.state.loopDepth = c, e11.state.parentHasLoopContext = u, e11.state.lastArg = f10, e11.state.bashPid = p, e11.state.groupStdin = h, e11.state.currentSource = m;
  };
  try {
    let y = new ce().parse(i10), w = await s10(y);
    return d(), w;
  } catch (g) {
    if (d(), g instanceof pe || g instanceof te)
      throw g;
    if (g.name === "ParseException")
      return W(`bash: ${t10}: ${g.message}
`);
    throw g;
  }
}
var $s = class {
  ctx;
  constructor(t10, n10) {
    this.ctx = { state: n10, fs: t10.fs, commands: t10.commands, limits: t10.limits, execFn: t10.exec, executeScript: this.executeScript.bind(this), executeStatement: this.executeStatement.bind(this), executeCommand: this.executeCommand.bind(this), fetch: t10.fetch, sleep: t10.sleep, trace: t10.trace, coverage: t10.coverage };
  }
  buildExportedEnv() {
    let t10 = this.ctx.state.exportedVars, n10 = this.ctx.state.tempExportedVars, r10 = /* @__PURE__ */ new Set();
    if (t10)
      for (let i10 of t10)
        r10.add(i10);
    if (n10)
      for (let i10 of n10)
        r10.add(i10);
    if (r10.size === 0)
      return /* @__PURE__ */ Object.create(null);
    let s10 = /* @__PURE__ */ Object.create(null);
    for (let i10 of r10) {
      let o10 = this.ctx.state.env.get(i10);
      o10 !== void 0 && (s10[i10] = o10);
    }
    return s10;
  }
  async executeScript(t10) {
    let n10 = "", r10 = "", s10 = 0;
    for (let i10 of t10.statements)
      try {
        let o10 = await this.executeStatement(i10);
        n10 += o10.stdout, r10 += o10.stderr, s10 = o10.exitCode, this.ctx.state.lastExitCode = s10, this.ctx.state.env.set("?", String(s10));
      } catch (o10) {
        if (o10 instanceof pe)
          throw o10.prependOutput(n10, r10), o10;
        if (o10 instanceof Ut)
          return n10 += o10.stdout, r10 += o10.stderr, s10 = o10.exitCode, this.ctx.state.lastExitCode = s10, this.ctx.state.env.set("?", String(s10)), { stdout: n10, stderr: r10, exitCode: s10, env: xt(this.ctx.state.env) };
        if (o10 instanceof te)
          throw o10;
        if (o10 instanceof kt)
          return n10 += o10.stdout, r10 += o10.stderr, s10 = o10.exitCode, this.ctx.state.lastExitCode = s10, this.ctx.state.env.set("?", String(s10)), { stdout: n10, stderr: r10, exitCode: s10, env: xt(this.ctx.state.env) };
        if (o10 instanceof yt)
          return n10 += o10.stdout, r10 += o10.stderr, s10 = 1, this.ctx.state.lastExitCode = s10, this.ctx.state.env.set("?", String(s10)), { stdout: n10, stderr: r10, exitCode: s10, env: xt(this.ctx.state.env) };
        if (o10 instanceof wt)
          return n10 += o10.stdout, r10 += o10.stderr, s10 = 1, this.ctx.state.lastExitCode = s10, this.ctx.state.env.set("?", String(s10)), { stdout: n10, stderr: r10, exitCode: s10, env: xt(this.ctx.state.env) };
        if (o10 instanceof $e) {
          n10 += o10.stdout, r10 += o10.stderr, s10 = 1, this.ctx.state.lastExitCode = s10, this.ctx.state.env.set("?", String(s10));
          continue;
        }
        if (o10 instanceof ur) {
          n10 += o10.stdout, r10 += o10.stderr, s10 = 1, this.ctx.state.lastExitCode = s10, this.ctx.state.env.set("?", String(s10));
          continue;
        }
        if (o10 instanceof ft || o10 instanceof pt) {
          if (this.ctx.state.loopDepth > 0)
            throw o10.prependOutput(n10, r10), o10;
          n10 += o10.stdout, r10 += o10.stderr;
          continue;
        }
        throw o10 instanceof at && o10.prependOutput(n10, r10), o10;
      }
    return { stdout: n10, stderr: r10, exitCode: s10, env: xt(this.ctx.state.env) };
  }
  async executeUserScript(t10, n10, r10 = "") {
    return Ag(this.ctx, t10, n10, r10, (s10) => this.executeScript(s10));
  }
  async executeStatement(t10) {
    if (this.ctx.state.commandCount++, this.ctx.state.commandCount > this.ctx.limits.maxCommandCount && kn(`too many commands executed (>${this.ctx.limits.maxCommandCount}), increase executionLimits.maxCommandCount`, "commands"), t10.deferredError)
      throw new ot(t10.deferredError.message, t10.line ?? 1, 1);
    if (this.ctx.state.options.noexec)
      return de;
    this.ctx.state.errexitSafe = false;
    let n10 = "", r10 = "";
    this.ctx.state.options.verbose && !this.ctx.state.suppressVerbose && t10.sourceText && (r10 += `${t10.sourceText}
`);
    let s10 = 0, i10 = -1, o10 = false;
    for (let c = 0; c < t10.pipelines.length; c++) {
      let u = t10.pipelines[c], f10 = c > 0 ? t10.operators[c - 1] : null;
      if (f10 === "&&" && s10 !== 0 || f10 === "||" && s10 === 0)
        continue;
      let p = await this.executePipeline(u);
      n10 += p.stdout, r10 += p.stderr, s10 = p.exitCode, i10 = c, o10 = u.negated, this.ctx.state.lastExitCode = s10, this.ctx.state.env.set("?", String(s10));
    }
    let a = i10 < t10.pipelines.length - 1, l = this.ctx.state.errexitSafe;
    if (this.ctx.state.errexitSafe = a || o10 || l, this.ctx.state.options.errexit && s10 !== 0 && i10 === t10.pipelines.length - 1 && !o10 && !this.ctx.state.inCondition && !l)
      throw new kt(s10, n10, r10);
    return B(n10, r10, s10);
  }
  async executePipeline(t10) {
    return yg(this.ctx, t10, (n10, r10) => this.executeCommand(n10, r10));
  }
  async executeCommand(t10, n10) {
    switch (this.ctx.coverage?.hit(`bash:cmd:${t10.type}`), t10.type) {
      case "SimpleCommand":
        return this.executeSimpleCommand(t10, n10);
      case "If":
        return og(this.ctx, t10);
      case "For":
        return ag(this.ctx, t10);
      case "CStyleFor":
        return lg(this.ctx, t10);
      case "While":
        return cg(this.ctx, t10, n10);
      case "Until":
        return ug(this.ctx, t10);
      case "Case":
        return fg(this.ctx, t10);
      case "Subshell":
        return this.executeSubshell(t10, n10);
      case "Group":
        return this.executeGroup(t10, n10);
      case "FunctionDef":
        return I6(this.ctx, t10);
      case "ArithmeticCommand":
        return this.executeArithmeticCommand(t10);
      case "ConditionalCommand":
        return this.executeConditionalCommand(t10);
      default:
        return de;
    }
  }
  async executeSimpleCommand(t10, n10) {
    try {
      return await this.executeSimpleCommandInner(t10, n10);
    } catch (r10) {
      if (r10 instanceof on2)
        return W(r10.stderr);
      throw r10;
    }
  }
  async executeSimpleCommandInner(t10, n10) {
    if (t10.line !== void 0 && (this.ctx.state.currentLine = t10.line), this.ctx.state.shoptOptions.expand_aliases && t10.name) {
      let x = t10, S = 100;
      for (; S > 0; ) {
        let O = this.expandAlias(x);
        if (O === x)
          break;
        x = O, S--;
      }
      this.aliasExpansionStack.clear(), x !== t10 && (t10 = x);
    }
    this.ctx.state.expansionStderr = "";
    let r10 = await wg(this.ctx, t10);
    if (r10.error)
      return r10.error;
    let s10 = r10.tempAssignments, i10 = r10.xtraceOutput;
    if (!t10.name) {
      if (t10.redirections.length > 0) {
        let S = await bn(this.ctx, t10.redirections);
        if (S)
          return S;
        let O = B("", i10, 0);
        return Be(this.ctx, O, t10.redirections);
      }
      this.ctx.state.lastArg = "";
      let x = (this.ctx.state.expansionStderr || "") + i10;
      return this.ctx.state.expansionStderr = "", B("", x, this.ctx.state.lastExitCode);
    }
    let o10 = t10.name && nu(t10.name, ["local", "declare", "typeset", "export", "readonly"]), a = Array.from(s10.keys());
    if (a.length > 0 && !o10) {
      this.ctx.state.tempExportedVars = this.ctx.state.tempExportedVars || /* @__PURE__ */ new Set();
      for (let x of a)
        this.ctx.state.tempExportedVars.add(x);
    }
    let l = await bo(this.ctx, t10.redirections);
    if (l) {
      for (let [x, S] of s10)
        S === void 0 ? this.ctx.state.env.delete(x) : this.ctx.state.env.set(x, S);
      return l;
    }
    let c = -1;
    for (let x of t10.redirections) {
      if ((x.operator === "<<" || x.operator === "<<-") && x.target.type === "HereDoc") {
        let S = x.target, O = await ie(this.ctx, S.content);
        S.stripTabs && (O = O.split(`
`).map((F4) => F4.replace(/^\t+/, "")).join(`
`));
        let R10 = x.fd ?? 0;
        R10 !== 0 ? (this.ctx.state.fileDescriptors || (this.ctx.state.fileDescriptors = /* @__PURE__ */ new Map()), this.ctx.state.fileDescriptors.set(R10, O)) : n10 = O;
        continue;
      }
      if (x.operator === "<<<" && x.target.type === "Word") {
        n10 = `${await ie(this.ctx, x.target)}
`;
        continue;
      }
      if (x.operator === "<" && x.target.type === "Word")
        try {
          let S = await ie(this.ctx, x.target), O = this.ctx.fs.resolvePath(this.ctx.state.cwd, S);
          n10 = await this.ctx.fs.readFile(O);
        } catch {
          let S = await ie(this.ctx, x.target);
          for (let [O, R10] of s10)
            R10 === void 0 ? this.ctx.state.env.delete(O) : this.ctx.state.env.set(O, R10);
          return W(`bash: ${S}: No such file or directory
`);
        }
      if (x.operator === "<&" && x.target.type === "Word") {
        let S = await ie(this.ctx, x.target), O = Number.parseInt(S, 10);
        if (!Number.isNaN(O) && this.ctx.state.fileDescriptors) {
          let R10 = this.ctx.state.fileDescriptors.get(O);
          if (R10 !== void 0)
            if (R10.startsWith("__rw__:")) {
              let F4 = pg(R10);
              F4 && (n10 = F4.content.slice(F4.position), c = O);
            } else
              R10.startsWith("__file__:") || R10.startsWith("__file_append__:") || (n10 = R10);
        }
      }
    }
    let u = await ie(this.ctx, t10.name), f10 = [], p = [];
    if (nu(t10.name, ["local", "declare", "typeset", "export", "readonly"]) && (u === "local" || u === "declare" || u === "typeset" || u === "export" || u === "readonly"))
      for (let x of t10.args) {
        let S = await f6(this.ctx, x);
        if (S)
          f10.push(S), p.push(true);
        else {
          let O = await p6(this.ctx, x);
          if (O !== null)
            f10.push(O), p.push(true);
          else {
            let R10 = await sn(this.ctx, x);
            for (let F4 of R10.values)
              f10.push(F4), p.push(R10.quoted);
          }
        }
      }
    else
      for (let x of t10.args) {
        let S = await sn(this.ctx, x);
        for (let O of S.values)
          f10.push(O), p.push(S.quoted);
      }
    if (!u) {
      if (t10.name.parts.every((S) => S.type === "CommandSubstitution" || S.type === "ParameterExpansion" || S.type === "ArithmeticExpansion")) {
        if (f10.length > 0) {
          let S = f10.shift();
          return p.shift(), await this.runCommand(S, f10, p, n10, false, false, c);
        }
        return B("", "", this.ctx.state.lastExitCode);
      }
      return W(`bash: : command not found
`, 127);
    }
    if (u === "exec" && (f10.length === 0 || f10[0] === "--")) {
      for (let x of t10.redirections) {
        if (x.target.type === "HereDoc" || x.fdVariable)
          continue;
        let S = await ie(this.ctx, x.target), O = x.fd ?? (x.operator === "<" || x.operator === "<>" ? 0 : 1);
        switch (this.ctx.state.fileDescriptors || (this.ctx.state.fileDescriptors = /* @__PURE__ */ new Map()), x.operator) {
          case ">":
          case ">|": {
            let R10 = this.ctx.fs.resolvePath(this.ctx.state.cwd, S);
            await this.ctx.fs.writeFile(R10, "", "utf8"), this.ctx.state.fileDescriptors.set(O, `__file__:${R10}`);
            break;
          }
          case ">>": {
            let R10 = this.ctx.fs.resolvePath(this.ctx.state.cwd, S);
            this.ctx.state.fileDescriptors.set(O, `__file_append__:${R10}`);
            break;
          }
          case "<": {
            let R10 = this.ctx.fs.resolvePath(this.ctx.state.cwd, S);
            try {
              let F4 = await this.ctx.fs.readFile(R10);
              this.ctx.state.fileDescriptors.set(O, F4);
            } catch {
              return W(`bash: ${S}: No such file or directory
`);
            }
            break;
          }
          case "<>": {
            let R10 = this.ctx.fs.resolvePath(this.ctx.state.cwd, S);
            try {
              let F4 = await this.ctx.fs.readFile(R10);
              this.ctx.state.fileDescriptors.set(O, `__rw__:${R10.length}:${R10}:0:${F4}`);
            } catch {
              await this.ctx.fs.writeFile(R10, "", "utf8"), this.ctx.state.fileDescriptors.set(O, `__rw__:${R10.length}:${R10}:0:`);
            }
            break;
          }
          case ">&": {
            if (S === "-")
              this.ctx.state.fileDescriptors.delete(O);
            else if (S.endsWith("-")) {
              let R10 = S.slice(0, -1), F4 = Number.parseInt(R10, 10);
              if (!Number.isNaN(F4)) {
                let $ = this.ctx.state.fileDescriptors.get(F4);
                $ !== void 0 ? this.ctx.state.fileDescriptors.set(O, $) : this.ctx.state.fileDescriptors.set(O, `__dupout__:${F4}`), this.ctx.state.fileDescriptors.delete(F4);
              }
            } else {
              let R10 = Number.parseInt(S, 10);
              Number.isNaN(R10) || this.ctx.state.fileDescriptors.set(O, `__dupout__:${R10}`);
            }
            break;
          }
          case "<&": {
            if (S === "-")
              this.ctx.state.fileDescriptors.delete(O);
            else if (S.endsWith("-")) {
              let R10 = S.slice(0, -1), F4 = Number.parseInt(R10, 10);
              if (!Number.isNaN(F4)) {
                let $ = this.ctx.state.fileDescriptors.get(F4);
                $ !== void 0 ? this.ctx.state.fileDescriptors.set(O, $) : this.ctx.state.fileDescriptors.set(O, `__dupin__:${F4}`), this.ctx.state.fileDescriptors.delete(F4);
              }
            } else {
              let R10 = Number.parseInt(S, 10);
              Number.isNaN(R10) || this.ctx.state.fileDescriptors.set(O, `__dupin__:${R10}`);
            }
            break;
          }
        }
      }
      for (let [x, S] of s10)
        S === void 0 ? this.ctx.state.env.delete(x) : this.ctx.state.env.set(x, S);
      if (this.ctx.state.tempExportedVars)
        for (let x of s10.keys())
          this.ctx.state.tempExportedVars.delete(x);
      return de;
    }
    let m = await mg(this.ctx, u, f10);
    s10.size > 0 && (this.ctx.state.tempEnvBindings = this.ctx.state.tempEnvBindings || [], this.ctx.state.tempEnvBindings.push(new Map(s10)));
    let d, g = null;
    try {
      d = await this.runCommand(u, f10, p, n10, false, false, c);
    } catch (x) {
      if (x instanceof ft || x instanceof pt)
        g = x, d = de;
      else
        throw x;
    }
    let y = i10 + m;
    if (y && (d = { ...d, stderr: y + d.stderr }), d = await Be(this.ctx, d, t10.redirections), g)
      throw g;
    if (f10.length > 0) {
      let x = f10[f10.length - 1];
      if ((u === "declare" || u === "local" || u === "typeset") && /^[a-zA-Z_][a-zA-Z0-9_]*=\(/.test(x)) {
        let S = x.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\(/);
        S && (x = S[1]);
      }
      this.ctx.state.lastArg = x;
    } else
      this.ctx.state.lastArg = u;
    let w = k6(u) && u !== "unset" && u !== "eval";
    if (!this.ctx.state.options.posix || !w)
      for (let [x, S] of s10)
        this.ctx.state.fullyUnsetLocals?.has(x) || (S === void 0 ? this.ctx.state.env.delete(x) : this.ctx.state.env.set(x, S));
    if (this.ctx.state.tempExportedVars)
      for (let x of s10.keys())
        this.ctx.state.tempExportedVars.delete(x);
    return s10.size > 0 && this.ctx.state.tempEnvBindings && this.ctx.state.tempEnvBindings.pop(), this.ctx.state.expansionStderr && (d = { ...d, stderr: this.ctx.state.expansionStderr + d.stderr }, this.ctx.state.expansionStderr = ""), d;
  }
  async runCommand(t10, n10, r10, s10, i10 = false, o10 = false, a = -1) {
    let l = { ctx: this.ctx, runCommand: (u, f10, p, h, m, d, g) => this.runCommand(u, f10, p, h, m, d, g), buildExportedEnv: () => this.buildExportedEnv(), executeUserScript: (u, f10, p) => this.executeUserScript(u, f10, p) }, c = await sg(l, t10, n10, r10, s10, i10, o10, a);
    return c !== null ? c : ig(l, t10, n10, s10, o10);
  }
  aliasExpansionStack = /* @__PURE__ */ new Set();
  expandAlias(t10) {
    return Hl(this.ctx.state, t10, this.aliasExpansionStack);
  }
  async findCommandInPath(t10) {
    return ko(this.ctx, t10);
  }
  async executeSubshell(t10, n10 = "") {
    return xg(this.ctx, t10, n10, (r10) => this.executeStatement(r10));
  }
  async executeGroup(t10, n10 = "") {
    return Eg(this.ctx, t10, n10, (r10) => this.executeStatement(r10));
  }
  async executeArithmeticCommand(t10) {
    t10.line !== void 0 && (this.ctx.state.currentLine = t10.line);
    let n10 = await bn(this.ctx, t10.redirections);
    if (n10)
      return n10;
    try {
      let r10 = await ne(this.ctx, t10.expression.expression), s10 = Ye(r10 !== 0);
      return this.ctx.state.expansionStderr && (s10 = { ...s10, stderr: this.ctx.state.expansionStderr + s10.stderr }, this.ctx.state.expansionStderr = ""), Be(this.ctx, s10, t10.redirections);
    } catch (r10) {
      let s10 = W(`bash: arithmetic expression: ${r10.message}
`);
      return Be(this.ctx, s10, t10.redirections);
    }
  }
  async executeConditionalCommand(t10) {
    t10.line !== void 0 && (this.ctx.state.currentLine = t10.line);
    let n10 = await bn(this.ctx, t10.redirections);
    if (n10)
      return n10;
    try {
      let r10 = await Un(this.ctx, t10.expression), s10 = Ye(r10);
      return this.ctx.state.expansionStderr && (s10 = { ...s10, stderr: this.ctx.state.expansionStderr + s10.stderr }, this.ctx.state.expansionStderr = ""), Be(this.ctx, s10, t10.redirections);
    } catch (r10) {
      let s10 = r10 instanceof $e ? 1 : 2, i10 = W(`bash: conditional expression: ${r10.message}
`, s10);
      return Be(this.ctx, i10, t10.redirections);
    }
  }
};
var _t = { maxCallDepth: 100, maxCommandCount: 1e4, maxLoopIterations: 1e4, maxAwkIterations: 1e4, maxSedIterations: 1e4, maxJqIterations: 1e4, maxSqliteTimeoutMs: 5e3, maxPythonTimeoutMs: 3e4, maxGlobOperations: 1e5, maxStringLength: 10485760, maxArrayElements: 1e5, maxHeredocSize: 10485760, maxSubstitutionDepth: 50 };
function Sg(e11) {
  return e11 ? { maxCallDepth: e11.maxCallDepth ?? _t.maxCallDepth, maxCommandCount: e11.maxCommandCount ?? _t.maxCommandCount, maxLoopIterations: e11.maxLoopIterations ?? _t.maxLoopIterations, maxAwkIterations: e11.maxAwkIterations ?? _t.maxAwkIterations, maxSedIterations: e11.maxSedIterations ?? _t.maxSedIterations, maxJqIterations: e11.maxJqIterations ?? _t.maxJqIterations, maxSqliteTimeoutMs: e11.maxSqliteTimeoutMs ?? _t.maxSqliteTimeoutMs, maxPythonTimeoutMs: e11.maxPythonTimeoutMs ?? _t.maxPythonTimeoutMs, maxGlobOperations: e11.maxGlobOperations ?? _t.maxGlobOperations, maxStringLength: e11.maxStringLength ?? _t.maxStringLength, maxArrayElements: e11.maxArrayElements ?? _t.maxArrayElements, maxHeredocSize: e11.maxHeredocSize ?? _t.maxHeredocSize, maxSubstitutionDepth: e11.maxSubstitutionDepth ?? _t.maxSubstitutionDepth } : { ..._t };
}
function Cg(e11) {
  try {
    let t10 = new URL(e11);
    return { origin: t10.origin, pathname: t10.pathname, href: t10.href };
  } catch {
    return null;
  }
}
function ZE(e11) {
  let t10 = Cg(e11);
  return t10 ? { origin: t10.origin, pathPrefix: t10.pathname } : null;
}
function QE(e11, t10) {
  let n10 = Cg(e11);
  if (!n10)
    return false;
  let r10 = ZE(t10);
  return !r10 || n10.origin !== r10.origin ? false : r10.pathPrefix === "/" || r10.pathPrefix === "" ? true : n10.pathname.startsWith(r10.pathPrefix);
}
function ru(e11, t10) {
  return !t10 || t10.length === 0 ? false : t10.some((n10) => QE(e11, n10));
}
var Gr = class extends Error {
  constructor(t10) {
    super(`Network access denied: URL not in allow-list: ${t10}`), this.name = "NetworkAccessDeniedError";
  }
};
var Vr = class extends Error {
  constructor(t10) {
    super(`Too many redirects (max: ${t10})`), this.name = "TooManyRedirectsError";
  }
};
var qr = class extends Error {
  constructor(t10) {
    super(`Redirect target not in allow-list: ${t10}`), this.name = "RedirectNotAllowedError";
  }
};
var Io = class extends Error {
  constructor(t10, n10) {
    super(`HTTP method '${t10}' not allowed. Allowed methods: ${n10.join(", ")}`), this.name = "MethodNotAllowedError";
  }
};
var Ts = class extends Error {
  constructor(t10) {
    super(`Response body too large (max: ${t10} bytes)`), this.name = "ResponseTooLargeError";
  }
};
var KE = 20;
var XE = 3e4;
var YE = 10485760;
var JE = ["GET", "HEAD"];
var eA = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
var tA = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
function su(e11) {
  let t10 = e11.maxRedirects ?? KE, n10 = e11.timeoutMs ?? XE, r10 = e11.maxResponseSize ?? YE, s10 = e11.dangerouslyAllowFullInternetAccess ? ["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"] : e11.allowedMethods ?? JE;
  function i10(l) {
    if (!e11.dangerouslyAllowFullInternetAccess && !ru(l, e11.allowedUrlPrefixes ?? []))
      throw new Gr(l);
  }
  function o10(l) {
    if (e11.dangerouslyAllowFullInternetAccess)
      return;
    let c = l.toUpperCase();
    if (!s10.includes(c))
      throw new Io(c, s10);
  }
  async function a(l, c = {}) {
    let u = c.method?.toUpperCase() ?? "GET";
    i10(l), o10(u);
    let f10 = l, p = 0, h = c.followRedirects ?? true, m = c.timeoutMs !== void 0 ? Math.min(c.timeoutMs, n10) : n10;
    for (; ; ) {
      let d = new AbortController(), g = setTimeout(() => d.abort(), m);
      try {
        let y = { method: u, headers: c.headers, signal: d.signal, redirect: "manual" };
        c.body && !eA.has(u) && (y.body = c.body);
        let w = await fetch(f10, y);
        if (tA.has(w.status) && h) {
          let b = w.headers.get("location");
          if (!b)
            return await Ng(w, f10, r10);
          let x = new URL(b, f10).href;
          if (!e11.dangerouslyAllowFullInternetAccess && !ru(x, e11.allowedUrlPrefixes ?? []))
            throw new qr(x);
          if (p++, p > t10)
            throw new Vr(t10);
          f10 = x;
          continue;
        }
        return await Ng(w, f10, r10);
      } finally {
        clearTimeout(g);
      }
    }
  }
  return a;
}
async function Ng(e11, t10, n10) {
  let r10 = /* @__PURE__ */ Object.create(null);
  if (e11.headers.forEach((i10, o10) => {
    r10[o10.toLowerCase()] = i10;
  }), n10 > 0) {
    let i10 = e11.headers.get("content-length");
    if (i10) {
      let o10 = parseInt(i10, 10);
      if (!Number.isNaN(o10) && o10 > n10)
        throw new Ts(n10);
    }
  }
  let s10;
  if (n10 > 0 && e11.body) {
    let i10 = e11.body.getReader(), o10 = new TextDecoder(), a = [], l = 0;
    for (; ; ) {
      let { done: c, value: u } = await i10.read();
      if (c)
        break;
      if (l += u.byteLength, l > n10)
        throw i10.cancel(), new Ts(n10);
      a.push(o10.decode(u, { stream: true }));
    }
    a.push(o10.decode()), s10 = a.join("");
  } else
    s10 = await e11.text();
  return { status: e11.status, statusText: e11.statusText, headers: r10, body: s10, url: t10 };
}
Pn();
Ke();
function kg() {
  let e11 = [{ prop: "Function", target: globalThis, violationType: "function_constructor", strategy: "throw", reason: "Function constructor allows arbitrary code execution" }, { prop: "eval", target: globalThis, violationType: "eval", strategy: "throw", reason: "eval() allows arbitrary code execution" }, { prop: "setTimeout", target: globalThis, violationType: "setTimeout", strategy: "throw", reason: "setTimeout with string argument allows code execution" }, { prop: "setInterval", target: globalThis, violationType: "setInterval", strategy: "throw", reason: "setInterval with string argument allows code execution" }, { prop: "setImmediate", target: globalThis, violationType: "setImmediate", strategy: "throw", reason: "setImmediate could be used to escape sandbox context" }, { prop: "env", target: process, violationType: "process_env", strategy: "throw", reason: "process.env could leak sensitive environment variables" }, { prop: "binding", target: process, violationType: "process_binding", strategy: "throw", reason: "process.binding provides access to native Node.js modules" }, { prop: "_linkedBinding", target: process, violationType: "process_binding", strategy: "throw", reason: "process._linkedBinding provides access to native Node.js modules" }, { prop: "dlopen", target: process, violationType: "process_dlopen", strategy: "throw", reason: "process.dlopen allows loading native addons" }, { prop: "WeakRef", target: globalThis, violationType: "weak_ref", strategy: "throw", reason: "WeakRef could be used to leak references outside sandbox" }, { prop: "FinalizationRegistry", target: globalThis, violationType: "finalization_registry", strategy: "throw", reason: "FinalizationRegistry could be used to leak references outside sandbox" }, { prop: "Reflect", target: globalThis, violationType: "reflect", strategy: "freeze", reason: "Reflect provides introspection capabilities" }, { prop: "Proxy", target: globalThis, violationType: "proxy", strategy: "throw", reason: "Proxy allows intercepting and modifying object behavior" }, { prop: "WebAssembly", target: globalThis, violationType: "webassembly", strategy: "throw", reason: "WebAssembly allows executing arbitrary compiled code" }, { prop: "SharedArrayBuffer", target: globalThis, violationType: "shared_array_buffer", strategy: "throw", reason: "SharedArrayBuffer could enable side-channel communication or timing attacks" }, { prop: "Atomics", target: globalThis, violationType: "atomics", strategy: "throw", reason: "Atomics could enable side-channel communication or timing attacks" }];
  try {
    let t10 = Object.getPrototypeOf(async () => {
    }).constructor;
    t10 && t10 !== Function && e11.push({ prop: "constructor", target: Object.getPrototypeOf(async () => {
    }), violationType: "async_function_constructor", strategy: "throw", reason: "AsyncFunction constructor allows arbitrary async code execution" });
  } catch {
  }
  try {
    let t10 = Object.getPrototypeOf(function* () {
    }).constructor;
    t10 && t10 !== Function && e11.push({ prop: "constructor", target: Object.getPrototypeOf(function* () {
    }), violationType: "generator_function_constructor", strategy: "throw", reason: "GeneratorFunction constructor allows arbitrary generator code execution" });
  } catch {
  }
  try {
    let t10 = Object.getPrototypeOf(async function* () {
    }).constructor;
    t10 && t10 !== Function && t10 !== Object.getPrototypeOf(async () => {
    }).constructor && e11.push({ prop: "constructor", target: Object.getPrototypeOf(async function* () {
    }), violationType: "async_generator_function_constructor", strategy: "throw", reason: "AsyncGeneratorFunction constructor allows arbitrary async generator code execution" });
  } catch {
  }
  return e11.filter((t10) => {
    try {
      return t10.target[t10.prop] !== void 0;
    } catch {
      return false;
    }
  });
}
var Ps = true;
function vg() {
  return typeof crypto < "u" && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e11) => {
    let t10 = Math.random() * 16 | 0;
    return (e11 === "x" ? t10 : t10 & 3 | 8).toString(16);
  });
}
var ou = null;
if (!Ps)
  try {
    let { createRequire: e11 } = await Promise.resolve().then(() => (init_node_module(), node_module_exports));
    ou = e11(import.meta.url)("node:async_hooks").AsyncLocalStorage;
  } catch (e11) {
    console.debug("[DefenseInDepthBox] AsyncLocalStorage not available, defense-in-depth disabled:", e11 instanceof Error ? e11.message : e11);
  }
var nA = `

This is a defense-in-depth measure and indicates a bug in just-bash. Please report this at security@vercel.com`;
var mt = class extends Error {
  violation;
  constructor(t10, n10) {
    super(t10 + nA), this.violation = n10, this.name = "SecurityViolationError";
  }
};
var Lt = !Ps && ou ? new ou() : null;
var rA = 1e3;
var iu = { enabled: true, auditMode: false };
function sA(e11) {
  return e11 === void 0 ? { ...iu, enabled: false } : typeof e11 == "boolean" ? { ...iu, enabled: e11 } : { ...iu, ...e11 };
}
var Oo = class e {
  static instance = null;
  config;
  refCount = 0;
  originalDescriptors = [];
  violations = [];
  activationTime = 0;
  totalActiveTimeMs = 0;
  constructor(t10) {
    this.config = t10;
  }
  static getInstance(t10) {
    return e.instance || (e.instance = new e(sA(t10))), e.instance;
  }
  static resetInstance() {
    e.instance && (e.instance.forceDeactivate(), e.instance = null);
  }
  static isInSandboxedContext() {
    return Lt ? Lt?.getStore()?.sandboxActive === true : false;
  }
  static getCurrentExecutionId() {
    if (Lt)
      return Lt?.getStore()?.executionId;
  }
  updateConfig(t10) {
    this.config = { ...this.config, ...t10 };
  }
  activate() {
    if (Ps || !this.config.enabled) {
      let n10 = vg();
      return { run: (r10) => r10(), deactivate: () => {
      }, executionId: n10 };
    }
    this.refCount++, this.refCount === 1 && (this.applyPatches(), this.activationTime = Date.now());
    let t10 = vg();
    return { run: (n10) => Lt.run({ sandboxActive: true, executionId: t10 }, n10), deactivate: () => {
      this.refCount--, this.refCount === 0 && (this.restorePatches(), this.totalActiveTimeMs += Date.now() - this.activationTime), this.refCount < 0 && (this.refCount = 0);
    }, executionId: t10 };
  }
  forceDeactivate() {
    this.refCount > 0 && (this.restorePatches(), this.totalActiveTimeMs += Date.now() - this.activationTime), this.refCount = 0;
  }
  isActive() {
    return this.refCount > 0;
  }
  getStats() {
    return { violationsBlocked: this.violations.length, violations: [...this.violations], activeTimeMs: this.totalActiveTimeMs + (this.refCount > 0 ? Date.now() - this.activationTime : 0), refCount: this.refCount };
  }
  clearViolations() {
    this.violations = [];
  }
  getPathForTarget(t10, n10) {
    return t10 === globalThis ? `globalThis.${n10}` : t10 === process ? `process.${n10}` : t10 === Error ? `Error.${n10}` : t10 === Function.prototype ? `Function.prototype.${n10}` : t10 === Object.prototype ? `Object.prototype.${n10}` : `<object>.${n10}`;
  }
  shouldBlock() {
    return Ps || this.config.auditMode || !Lt ? false : Lt?.getStore()?.sandboxActive === true;
  }
  recordViolation(t10, n10, r10) {
    let s10 = { timestamp: Date.now(), type: t10, message: r10, path: n10, stack: new Error().stack, executionId: Lt?.getStore()?.executionId };
    if (this.violations.length < rA && this.violations.push(s10), this.config.onViolation)
      try {
        this.config.onViolation(s10);
      } catch (i10) {
        console.debug("[DefenseInDepthBox] onViolation callback threw:", i10 instanceof Error ? i10.message : i10);
      }
    return s10;
  }
  createBlockingProxy(t10, n10, r10) {
    let s10 = this;
    return new Proxy(t10, { apply(i10, o10, a) {
      if (s10.shouldBlock()) {
        let l = `${n10} is blocked during script execution`, c = s10.recordViolation(r10, n10, l);
        throw new mt(l, c);
      }
      return s10.config.auditMode && Lt?.getStore()?.sandboxActive === true && s10.recordViolation(r10, n10, `${n10} called (audit mode)`), Reflect.apply(i10, o10, a);
    }, construct(i10, o10, a) {
      if (s10.shouldBlock()) {
        let l = `${n10} constructor is blocked during script execution`, c = s10.recordViolation(r10, n10, l);
        throw new mt(l, c);
      }
      return s10.config.auditMode && Lt?.getStore()?.sandboxActive === true && s10.recordViolation(r10, n10, `${n10} constructor called (audit mode)`), Reflect.construct(i10, o10, a);
    } });
  }
  createBlockingObjectProxy(t10, n10, r10) {
    let s10 = this;
    return new Proxy(t10, { get(i10, o10, a) {
      if (s10.shouldBlock()) {
        let l = `${n10}.${String(o10)}`, c = `${l} is blocked during script execution`, u = s10.recordViolation(r10, l, c);
        throw new mt(c, u);
      }
      if (s10.config.auditMode && Lt?.getStore()?.sandboxActive === true) {
        let l = `${n10}.${String(o10)}`;
        s10.recordViolation(r10, l, `${l} accessed (audit mode)`);
      }
      return Reflect.get(i10, o10, a);
    }, set(i10, o10, a, l) {
      if (s10.shouldBlock()) {
        let c = `${n10}.${String(o10)}`, u = `${c} modification is blocked during script execution`, f10 = s10.recordViolation(r10, c, u);
        throw new mt(u, f10);
      }
      return Reflect.set(i10, o10, a, l);
    }, ownKeys(i10) {
      if (s10.shouldBlock()) {
        let o10 = `${n10} enumeration is blocked during script execution`, a = s10.recordViolation(r10, n10, o10);
        throw new mt(o10, a);
      }
      return Reflect.ownKeys(i10);
    }, getOwnPropertyDescriptor(i10, o10) {
      if (s10.shouldBlock()) {
        let a = `${n10}.${String(o10)}`, l = `${a} descriptor access is blocked during script execution`, c = s10.recordViolation(r10, a, l);
        throw new mt(l, c);
      }
      return Reflect.getOwnPropertyDescriptor(i10, o10);
    }, has(i10, o10) {
      if (s10.shouldBlock()) {
        let a = `${n10}.${String(o10)}`, l = `${a} existence check is blocked during script execution`, c = s10.recordViolation(r10, a, l);
        throw new mt(l, c);
      }
      return Reflect.has(i10, o10);
    } });
  }
  applyPatches() {
    let t10 = kg();
    for (let n10 of t10)
      this.applyPatch(n10);
    this.protectConstructorChain(), this.protectErrorPrepareStackTrace(), this.protectModuleLoad(), this.protectProcessMainModule();
  }
  protectConstructorChain() {
    this.patchPrototypeConstructor(Function.prototype, "Function.prototype.constructor", "function_constructor");
    try {
      let t10 = Object.getPrototypeOf(async () => {
      }).constructor;
      t10 && t10 !== Function && this.patchPrototypeConstructor(t10.prototype, "AsyncFunction.prototype.constructor", "async_function_constructor");
    } catch (t10) {
      console.debug("[DefenseInDepthBox] Could not patch AsyncFunction.prototype.constructor:", t10 instanceof Error ? t10.message : t10);
    }
    try {
      let t10 = Object.getPrototypeOf(function* () {
      }).constructor;
      t10 && t10 !== Function && this.patchPrototypeConstructor(t10.prototype, "GeneratorFunction.prototype.constructor", "generator_function_constructor");
    } catch (t10) {
      console.debug("[DefenseInDepthBox] Could not patch GeneratorFunction.prototype.constructor:", t10 instanceof Error ? t10.message : t10);
    }
    try {
      let t10 = Object.getPrototypeOf(async function* () {
      }).constructor, n10 = Object.getPrototypeOf(async () => {
      }).constructor;
      t10 && t10 !== Function && t10 !== n10 && this.patchPrototypeConstructor(t10.prototype, "AsyncGeneratorFunction.prototype.constructor", "async_generator_function_constructor");
    } catch (t10) {
      console.debug("[DefenseInDepthBox] Could not patch AsyncGeneratorFunction.prototype.constructor:", t10 instanceof Error ? t10.message : t10);
    }
  }
  protectErrorPrepareStackTrace() {
    let t10 = this;
    try {
      let n10 = Object.getOwnPropertyDescriptor(Error, "prepareStackTrace");
      this.originalDescriptors.push({ target: Error, prop: "prepareStackTrace", descriptor: n10 });
      let r10 = n10?.value;
      Object.defineProperty(Error, "prepareStackTrace", { get() {
        return r10;
      }, set(s10) {
        if (t10.shouldBlock()) {
          let i10 = "Error.prepareStackTrace modification is blocked during script execution", o10 = t10.recordViolation("error_prepare_stack_trace", "Error.prepareStackTrace", i10);
          throw new mt(i10, o10);
        }
        t10.config.auditMode && Lt?.getStore()?.sandboxActive === true && t10.recordViolation("error_prepare_stack_trace", "Error.prepareStackTrace", "Error.prepareStackTrace set (audit mode)"), r10 = s10;
      }, configurable: true });
    } catch (n10) {
      console.debug("[DefenseInDepthBox] Could not protect Error.prepareStackTrace:", n10 instanceof Error ? n10.message : n10);
    }
  }
  patchPrototypeConstructor(t10, n10, r10) {
    let s10 = this;
    try {
      let i10 = Object.getOwnPropertyDescriptor(t10, "constructor");
      this.originalDescriptors.push({ target: t10, prop: "constructor", descriptor: i10 });
      let o10 = i10?.value;
      Object.defineProperty(t10, "constructor", { get() {
        if (s10.shouldBlock()) {
          let a = `${n10} access is blocked during script execution`, l = s10.recordViolation(r10, n10, a);
          throw new mt(a, l);
        }
        return s10.config.auditMode && Lt?.getStore()?.sandboxActive === true && s10.recordViolation(r10, n10, `${n10} accessed (audit mode)`), o10;
      }, set(a) {
        if (s10.shouldBlock()) {
          let l = `${n10} modification is blocked during script execution`, c = s10.recordViolation(r10, n10, l);
          throw new mt(l, c);
        }
        Object.defineProperty(this, "constructor", { value: a, writable: true, configurable: true });
      }, configurable: true });
    } catch (i10) {
      console.debug(`[DefenseInDepthBox] Could not patch ${n10}:`, i10 instanceof Error ? i10.message : i10);
    }
  }
  protectProcessMainModule() {
    if (typeof process > "u")
      return;
    let t10 = this;
    try {
      let n10 = Object.getOwnPropertyDescriptor(process, "mainModule");
      this.originalDescriptors.push({ target: process, prop: "mainModule", descriptor: n10 });
      let r10 = n10?.value;
      r10 !== void 0 && Object.defineProperty(process, "mainModule", { get() {
        if (t10.shouldBlock()) {
          let s10 = "process.mainModule access is blocked during script execution", i10 = t10.recordViolation("process_main_module", "process.mainModule", s10);
          throw new mt(s10, i10);
        }
        return t10.config.auditMode && Lt?.getStore()?.sandboxActive === true && t10.recordViolation("process_main_module", "process.mainModule", "process.mainModule accessed (audit mode)"), r10;
      }, set(s10) {
        if (t10.shouldBlock()) {
          let i10 = "process.mainModule modification is blocked during script execution", o10 = t10.recordViolation("process_main_module", "process.mainModule", i10);
          throw new mt(i10, o10);
        }
        Object.defineProperty(process, "mainModule", { value: s10, writable: true, configurable: true });
      }, configurable: true });
    } catch (n10) {
      console.debug("[DefenseInDepthBox] Could not protect process.mainModule:", n10 instanceof Error ? n10.message : n10);
    }
  }
  protectModuleLoad() {
    if (!Ps)
      try {
        let t10 = null;
        if (typeof process < "u") {
          let o10 = process.mainModule;
          o10 && typeof o10 == "object" && (t10 = o10.constructor);
        }
        if (!t10 && typeof _s < "u" && typeof _s.main < "u" && (t10 = _s.main.constructor), !t10 || typeof t10._load != "function")
          return;
        let n10 = t10._load, r10 = Object.getOwnPropertyDescriptor(t10, "_load");
        this.originalDescriptors.push({ target: t10, prop: "_load", descriptor: r10 });
        let i10 = this.createBlockingProxy(n10, "Module._load", "module_load");
        Object.defineProperty(t10, "_load", { value: i10, writable: true, configurable: true });
      } catch (t10) {
        console.debug("[DefenseInDepthBox] Could not protect Module._load:", t10 instanceof Error ? t10.message : t10);
      }
  }
  applyPatch(t10) {
    let { target: n10, prop: r10, violationType: s10, strategy: i10 } = t10;
    try {
      let o10 = n10[r10];
      if (o10 === void 0)
        return;
      let a = Object.getOwnPropertyDescriptor(n10, r10);
      if (this.originalDescriptors.push({ target: n10, prop: r10, descriptor: a }), i10 === "freeze")
        typeof o10 == "object" && o10 !== null && Object.freeze(o10);
      else {
        let l = this.getPathForTarget(n10, r10), c = typeof o10 == "function" ? this.createBlockingProxy(o10, l, s10) : this.createBlockingObjectProxy(o10, l, s10);
        Object.defineProperty(n10, r10, { value: c, writable: true, configurable: true });
      }
    } catch (o10) {
      let a = this.getPathForTarget(n10, r10);
      console.debug(`[DefenseInDepthBox] Could not patch ${a}:`, o10 instanceof Error ? o10.message : o10);
    }
  }
  restorePatches() {
    for (let t10 = this.originalDescriptors.length - 1; t10 >= 0; t10--) {
      let { target: n10, prop: r10, descriptor: s10 } = this.originalDescriptors[t10];
      try {
        s10 ? Object.defineProperty(n10, r10, s10) : delete n10[r10];
      } catch (i10) {
        let o10 = this.getPathForTarget(n10, r10);
        console.debug(`[DefenseInDepthBox] Could not restore ${o10}:`, i10 instanceof Error ? i10.message : i10);
      }
    }
    this.originalDescriptors = [];
  }
};
var au = class {
  fs;
  commands = /* @__PURE__ */ new Map();
  useDefaultLayout = false;
  limits;
  secureFetch;
  sleepFn;
  traceFn;
  logger;
  defenseInDepthConfig;
  coverageWriter;
  state;
  constructor(t10 = {}) {
    let n10 = t10.fs ?? new Jn(t10.files);
    this.fs = n10, this.useDefaultLayout = !t10.cwd && !t10.files;
    let r10 = t10.cwd || (this.useDefaultLayout ? "/home/user" : "/"), s10 = new Map([["HOME", this.useDefaultLayout ? "/home/user" : "/"], ["PATH", "/usr/bin:/bin"], ["IFS", ` 	
`], ["OSTYPE", "linux-gnu"], ["MACHTYPE", "x86_64-pc-linux-gnu"], ["HOSTTYPE", "x86_64"], ["HOSTNAME", "localhost"], ["PWD", r10], ["OLDPWD", r10], ["OPTIND", "1"], ...Object.entries(t10.env ?? {})]);
    if (this.limits = Sg({ ...t10.executionLimits, ...t10.maxCallDepth !== void 0 && { maxCallDepth: t10.maxCallDepth }, ...t10.maxCommandCount !== void 0 && { maxCommandCount: t10.maxCommandCount }, ...t10.maxLoopIterations !== void 0 && { maxLoopIterations: t10.maxLoopIterations } }), t10.network && (this.secureFetch = su(t10.network)), this.sleepFn = t10.sleep, this.traceFn = t10.trace, this.logger = t10.logger, this.defenseInDepthConfig = t10.defenseInDepth, this.coverageWriter = t10.coverage, this.state = { env: s10, cwd: r10, previousDir: "/home/user", functions: /* @__PURE__ */ new Map(), localScopes: [], callDepth: 0, sourceDepth: 0, commandCount: 0, lastExitCode: 0, lastArg: "", startTime: Date.now(), lastBackgroundPid: 0, bashPid: process.pid, nextVirtualPid: process.pid + 1, currentLine: 1, options: { errexit: false, pipefail: false, nounset: false, xtrace: false, verbose: false, posix: false, allexport: false, noclobber: false, noglob: false, noexec: false, vi: false, emacs: false }, shoptOptions: { extglob: false, dotglob: false, nullglob: false, failglob: false, globstar: false, globskipdots: true, nocaseglob: false, nocasematch: false, expand_aliases: false, lastpipe: false, xpg_echo: false }, inCondition: false, loopDepth: 0, exportedVars: /* @__PURE__ */ new Set(["HOME", "PATH", "PWD", "OLDPWD", ...Object.keys(t10.env || {})]), readonlyVars: /* @__PURE__ */ new Set(["SHELLOPTS", "BASHOPTS"]), hashTable: /* @__PURE__ */ new Map() }, this.state.env.set("SHELLOPTS", bl(this.state.options)), this.state.env.set("BASHOPTS", xl(this.state.shoptOptions)), W0(n10, this.useDefaultLayout), r10 !== "/" && n10 instanceof Jn)
      try {
        n10.mkdirSync(r10, { recursive: true });
      } catch {
      }
    for (let i10 of $0(t10.commands))
      this.registerCommand(i10);
    if (t10.network)
      for (let i10 of T0())
        this.registerCommand(i10);
    if (t10.python)
      for (let i10 of P0())
        this.registerCommand(i10);
    if (t10.customCommands)
      for (let i10 of t10.customCommands)
        D0(i10) ? this.registerCommand(_0(i10)) : this.registerCommand(i10);
  }
  registerCommand(t10) {
    this.commands.set(t10.name, t10);
    let n10 = this.fs;
    if (typeof n10.writeFileSync == "function") {
      let r10 = `#!/bin/bash
# Built-in command: ${t10.name}
`;
      try {
        n10.writeFileSync(`/bin/${t10.name}`, r10);
      } catch {
      }
      try {
        n10.writeFileSync(`/usr/bin/${t10.name}`, r10);
      } catch {
      }
    }
  }
  logResult(t10) {
    return this.logger && (t10.stdout && this.logger.debug("stdout", { output: t10.stdout }), t10.stderr && this.logger.info("stderr", { output: t10.stderr }), this.logger.info("exit", { exitCode: t10.exitCode })), t10;
  }
  async exec(t10, n10) {
    if (this.state.callDepth === 0 && (this.state.commandCount = 0), this.state.commandCount++, this.state.commandCount > this.limits.maxCommandCount)
      return { stdout: "", stderr: `bash: maximum command count (${this.limits.maxCommandCount}) exceeded (possible infinite loop). Increase with executionLimits.maxCommandCount option.
`, exitCode: 1, env: Jt(this.state.env, n10?.env) };
    if (!t10.trim())
      return { stdout: "", stderr: "", exitCode: 0, env: Jt(this.state.env, n10?.env) };
    this.logger?.info("exec", { command: t10 });
    let r10 = n10?.cwd ?? this.state.cwd, s10, i10 = r10;
    if (n10?.cwd)
      if (n10.env && "PWD" in n10.env)
        s10 = n10.env.PWD;
      else if (n10?.env && !("PWD" in n10.env))
        try {
          s10 = await this.fs.realpath(r10), i10 = s10;
        } catch {
          s10 = r10;
        }
      else
        s10 = r10;
    let o10 = new Map(this.state.env);
    if (n10?.env)
      for (let [f10, p] of Object.entries(n10.env))
        o10.set(f10, p);
    s10 !== void 0 && o10.set("PWD", s10);
    let a = { ...this.state, env: o10, cwd: i10, functions: new Map(this.state.functions), localScopes: [...this.state.localScopes], options: { ...this.state.options }, hashTable: this.state.hashTable }, l = t10;
    n10?.rawScript || (l = iA(t10));
    let u = (this.defenseInDepthConfig ? Oo.getInstance(this.defenseInDepthConfig) : null)?.activate();
    try {
      let f10 = async () => {
        let p = hn(l), h = { fs: this.fs, commands: this.commands, limits: this.limits, exec: this.exec.bind(this), fetch: this.secureFetch, sleep: this.sleepFn, trace: this.traceFn, coverage: this.coverageWriter }, d = await new $s(h, a).executeScript(p);
        return this.logResult(d);
      };
      return u ? await u.run(f10) : await f10();
    } catch (f10) {
      if (f10 instanceof pe)
        return this.logResult({ stdout: f10.stdout, stderr: f10.stderr, exitCode: f10.exitCode, env: Jt(this.state.env, n10?.env) });
      if (f10 instanceof Ut)
        return this.logResult({ stdout: f10.stdout, stderr: f10.stderr, exitCode: f10.exitCode, env: Jt(this.state.env, n10?.env) });
      if (f10 instanceof $e)
        return this.logResult({ stdout: f10.stdout, stderr: f10.stderr, exitCode: 1, env: Jt(this.state.env, n10?.env) });
      if (f10 instanceof te)
        return this.logResult({ stdout: f10.stdout, stderr: f10.stderr, exitCode: te.EXIT_CODE, env: Jt(this.state.env, n10?.env) });
      if (f10 instanceof mt)
        return this.logResult({ stdout: "", stderr: `bash: security violation: ${f10.message}
`, exitCode: 1, env: Jt(this.state.env, n10?.env) });
      if (f10.name === "ParseException")
        return this.logResult({ stdout: "", stderr: `bash: syntax error: ${f10.message}
`, exitCode: 2, env: Jt(this.state.env, n10?.env) });
      if (f10 instanceof Tn)
        return this.logResult({ stdout: "", stderr: `bash: ${f10.message}
`, exitCode: 2, env: Jt(this.state.env, n10?.env) });
      if (f10 instanceof RangeError)
        return this.logResult({ stdout: "", stderr: `bash: ${f10.message}
`, exitCode: 1, env: Jt(this.state.env, n10?.env) });
      throw f10;
    } finally {
      u?.deactivate();
    }
  }
  async readFile(t10) {
    return this.fs.readFile(this.fs.resolvePath(this.state.cwd, t10));
  }
  async writeFile(t10, n10) {
    return this.fs.writeFile(this.fs.resolvePath(this.state.cwd, t10), n10);
  }
  getCwd() {
    return this.state.cwd;
  }
  getEnv() {
    return xt(this.state.env);
  }
};
function iA(e11) {
  let t10 = e11.split(`
`), n10 = [], r10 = [];
  for (let s10 = 0; s10 < t10.length; s10++) {
    let i10 = t10[s10];
    if (r10.length > 0) {
      let l = r10[r10.length - 1];
      if ((l.stripTabs ? i10.replace(/^\t+/, "") : i10) === l.delimiter) {
        n10.push(i10.trimStart()), r10.pop();
        continue;
      }
      n10.push(i10);
      continue;
    }
    let o10 = i10.trimStart();
    n10.push(o10);
    let a = /<<(-?)\s*(['"]?)([\w-]+)\2/g;
    for (let l of o10.matchAll(a)) {
      let c = l[1] === "-", u = l[3];
      r10.push({ delimiter: u, stripTabs: c });
    }
  }
  return n10.join(`
`);
}

// node_modules/resolve.exports/dist/index.mjs
function e10(e11, n10, r10) {
  throw new Error(r10 ? `No known conditions for "${n10}" specifier in "${e11}" package` : `Missing "${n10}" specifier in "${e11}" package`);
}
function n(n10, i10, o10, f10) {
  let s10, u, l = r(n10, o10), c = function(e11) {
    let n11 = /* @__PURE__ */ new Set(["default", ...e11.conditions || []]);
    return e11.unsafe || n11.add(e11.require ? "require" : "import"), e11.unsafe || n11.add(e11.browser ? "browser" : "node"), n11;
  }(f10 || {}), a = i10[l];
  if (void 0 === a) {
    let e11, n11, r10, t10;
    for (t10 in i10)
      n11 && t10.length < n11.length || ("/" === t10[t10.length - 1] && l.startsWith(t10) ? (u = l.substring(t10.length), n11 = t10) : t10.length > 1 && (r10 = t10.indexOf("*", 1), ~r10 && (e11 = RegExp("^" + t10.substring(0, r10) + "(.*)" + t10.substring(1 + r10) + "$").exec(l), e11 && e11[1] && (u = e11[1], n11 = t10))));
    a = i10[n11];
  }
  return a || e10(n10, l), s10 = t(a, c), s10 || e10(n10, l, 1), u && function(e11, n11) {
    let r10, t10 = 0, i11 = e11.length, o11 = /[*]/g, f11 = /[/]$/;
    for (; t10 < i11; t10++)
      e11[t10] = o11.test(r10 = e11[t10]) ? r10.replace(o11, n11) : f11.test(r10) ? r10 + n11 : r10;
  }(s10, u), s10;
}
function r(e11, n10, r10) {
  if (e11 === n10 || "." === n10)
    return ".";
  let t10 = e11 + "/", i10 = t10.length, o10 = n10.slice(0, i10) === t10, f10 = o10 ? n10.slice(i10) : n10;
  return "#" === f10[0] ? f10 : o10 || !r10 ? "./" === f10.slice(0, 2) ? f10 : "./" + f10 : f10;
}
function t(e11, n10, r10) {
  if (e11) {
    if ("string" == typeof e11)
      return r10 && r10.add(e11), [e11];
    let i10, o10;
    if (Array.isArray(e11)) {
      for (o10 = r10 || /* @__PURE__ */ new Set(), i10 = 0; i10 < e11.length; i10++)
        t(e11[i10], n10, o10);
      if (!r10 && o10.size)
        return [...o10];
    } else
      for (i10 in e11)
        if (n10.has(i10))
          return t(e11[i10], n10, r10);
  }
}
function o(e11, r10, t10) {
  let i10, o10 = e11.exports;
  if (o10) {
    if ("string" == typeof o10)
      o10 = { ".": o10 };
    else
      for (i10 in o10) {
        "." !== i10[0] && (o10 = { ".": o10 });
        break;
      }
    return n(e11.name, o10, r10 || ".", t10);
  }
}
function f(e11, r10, t10) {
  if (e11.imports)
    return n(e11.name, e11.imports, r10, t10);
}
function s(e11, n10, t10) {
  return "#" === (n10 = r(e11.name, n10 || "."))[0] ? f(e11, n10, t10) : o(e11, n10, t10);
}

// node_modules/comlink/dist/esm/comlink.mjs
var proxyMarker = Symbol("Comlink.proxy");
var createEndpoint = Symbol("Comlink.endpoint");
var releaseProxy = Symbol("Comlink.releaseProxy");
var finalizer = Symbol("Comlink.finalizer");
var throwMarker = Symbol("Comlink.thrown");
var isObject2 = (val) => typeof val === "object" && val !== null || typeof val === "function";
var proxyTransferHandler = {
  canHandle: (val) => isObject2(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap(port);
  }
};
var throwTransferHandler = {
  canHandle: (value2) => isObject2(value2) && throwMarker in value2,
  serialize({ value: value2 }) {
    let serialized;
    if (value2 instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value2.message,
          name: value2.name,
          stack: value2.stack
        }
      };
    } else {
      serialized = { isError: false, value: value2 };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
var transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep2 = globalThis, allowedOrigins = ["*"]) {
  ep2.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id: id2, type: type2, path: path3 } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path3.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
      const rawValue = path3.reduce((obj2, prop) => obj2[prop], obj);
      switch (type2) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path3.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value2 = new rawValue(...argumentList);
            returnValue = proxy(value2);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value2) {
      returnValue = { value: value2, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value2) => {
      return { value: value2, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep2.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
      if (type2 === "RELEASE") {
        ep2.removeEventListener("message", callback);
        closeEndPoint(ep2);
        if (finalizer in obj && typeof obj[finalizer] === "function") {
          obj[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep2.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
    });
  });
  if (ep2.start) {
    ep2.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap(ep2, target) {
  const pendingListeners = /* @__PURE__ */ new Map();
  ep2.addEventListener("message", function handleMessage(ev) {
    const { data: data2 } = ev;
    if (!data2 || !data2.id) {
      return;
    }
    const resolver = pendingListeners.get(data2.id);
    if (!resolver) {
      return;
    }
    try {
      resolver(data2);
    } finally {
      pendingListeners.delete(data2.id);
    }
  });
  return createProxy(ep2, pendingListeners, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep2) {
  return requestResponseMessage(ep2, /* @__PURE__ */ new Map(), {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep2);
  });
}
var proxyCounter = /* @__PURE__ */ new WeakMap();
var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep2) => {
  const newCount = (proxyCounter.get(ep2) || 0) - 1;
  proxyCounter.set(ep2, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep2);
  }
});
function registerProxy(proxy2, ep2) {
  const newCount = (proxyCounter.get(ep2) || 0) + 1;
  proxyCounter.set(ep2, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep2, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep2, pendingListeners, path3 = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep2);
          pendingListeners.clear();
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path3.length === 0) {
          return { then: () => proxy2 };
        }
        const r10 = requestResponseMessage(ep2, pendingListeners, {
          type: "GET",
          path: path3.map((p) => p.toString())
        }).then(fromWireValue);
        return r10.then.bind(r10);
      }
      return createProxy(ep2, pendingListeners, [...path3, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value2, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep2, pendingListeners, {
        type: "SET",
        path: [...path3, prop].map((p) => p.toString()),
        value: value2
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path3[path3.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep2, pendingListeners, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep2, pendingListeners, path3.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep2, pendingListeners, {
        type: "APPLY",
        path: path3.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep2, pendingListeners, {
        type: "CONSTRUCT",
        path: path3.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep2);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
var transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value2) {
  for (const [name2, handler] of transferHandlers) {
    if (handler.canHandle(value2)) {
      const [serializedValue, transferables] = handler.serialize(value2);
      return [
        {
          type: "HANDLER",
          name: name2,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value: value2
    },
    transferCache.get(value2) || []
  ];
}
function fromWireValue(value2) {
  switch (value2.type) {
    case "HANDLER":
      return transferHandlers.get(value2.name).deserialize(value2.value);
    case "RAW":
      return value2.value;
  }
}
function requestResponseMessage(ep2, pendingListeners, msg, transfers) {
  return new Promise((resolve2) => {
    const id2 = generateUUID();
    pendingListeners.set(id2, resolve2);
    if (ep2.start) {
      ep2.start();
    }
    ep2.postMessage(Object.assign({ id: id2 }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}

// node_modules/almostnode/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
var DEMO_PACKAGES;
var PACKAGE_JSON;
var DevServer;
var NextDevServer;
var PackageManager;
var Runtime;
var SANDBOX_SETUP_INSTRUCTIONS;
var SandboxRuntime;
var ServerBridge;
var VirtualFS;
var ViteDevServer;
var WorkerRuntime;
var assert$1;
var chokidarShim;
var createContainer;
var createConvexAppProject;
var createFsShim;
var createProcess;
var createRuntime;
var esbuildShim;
var events$1;
var execute;
var fseventsShim;
var generateSandboxFiles;
var getSandboxHtml;
var getSandboxVercelConfig;
var getServerBridge;
var httpShim;
var initConvexAppDemo;
var install;
var moduleShim;
var netShim;
var index;
var pathShim;
var perfHooksShim;
var querystringShim;
var readdirpShim;
var resetServerBridge;
var rollupShim;
var startConvexAppDevServer;
var stream;
var urlShim;
var utilShim;
var workerThreadsShim;
var wsShim;
var __tla = (async () => {
  var _a, _b, _c;
  const CHUNK = 8192;
  function uint8ToBase64(bytes) {
    const parts = [];
    for (let i22 = 0; i22 < bytes.length; i22 += CHUNK) {
      parts.push(String.fromCharCode.apply(null, Array.from(bytes.subarray(i22, i22 + CHUNK))));
    }
    return btoa(parts.join(""));
  }
  function base64ToUint8(base642) {
    const binary = atob(base642);
    const bytes = new Uint8Array(binary.length);
    for (let i22 = 0; i22 < binary.length; i22++) {
      bytes[i22] = binary.charCodeAt(i22);
    }
    return bytes;
  }
  function uint8ToHex(bytes) {
    const hex = new Array(bytes.length);
    for (let i22 = 0; i22 < bytes.length; i22++) {
      hex[i22] = bytes[i22].toString(16).padStart(2, "0");
    }
    return hex.join("");
  }
  function uint8ToBinaryString(bytes) {
    const parts = [];
    for (let i22 = 0; i22 < bytes.length; i22 += CHUNK) {
      parts.push(String.fromCharCode.apply(null, Array.from(bytes.subarray(i22, i22 + CHUNK))));
    }
    return parts.join("");
  }
  function createNodeError(code2, syscall, path22, message) {
    const errno = {
      ENOENT: -2,
      ENOTDIR: -20,
      EISDIR: -21,
      EEXIST: -17,
      ENOTEMPTY: -39
    };
    const messages2 = {
      ENOENT: "no such file or directory",
      ENOTDIR: "not a directory",
      EISDIR: "is a directory",
      EEXIST: "file already exists",
      ENOTEMPTY: "directory not empty"
    };
    const err2 = new Error(`${code2}: ${messages2[code2]}, ${syscall} '${path22}'`);
    err2.code = code2;
    err2.errno = errno[code2];
    err2.syscall = syscall;
    err2.path = path22;
    return err2;
  }
  VirtualFS = class {
    constructor() {
      __publicField(this, "root");
      __publicField(this, "encoder", new TextEncoder());
      __publicField(this, "decoder", new TextDecoder());
      __publicField(this, "watchers", /* @__PURE__ */ new Map());
      __publicField(this, "eventListeners", /* @__PURE__ */ new Map());
      this.root = {
        type: "directory",
        children: /* @__PURE__ */ new Map(),
        mtime: Date.now()
      };
    }
    on(event, listener) {
      if (!this.eventListeners.has(event)) {
        this.eventListeners.set(event, /* @__PURE__ */ new Set());
      }
      this.eventListeners.get(event).add(listener);
      return this;
    }
    off(event, listener) {
      const listeners = this.eventListeners.get(event);
      if (listeners) {
        listeners.delete(listener);
      }
      return this;
    }
    emit(event, ...args) {
      const listeners = this.eventListeners.get(event);
      if (listeners) {
        for (const listener of listeners) {
          try {
            listener(...args);
          } catch (err2) {
            console.error("Error in VFS event listener:", err2);
          }
        }
      }
    }
    toSnapshot() {
      const files = [];
      this.serializeNode("/", this.root, files);
      return {
        files
      };
    }
    serializeNode(path22, node2, files) {
      if (node2.type === "file") {
        let content = "";
        if (node2.content && node2.content.length > 0) {
          content = uint8ToBase64(node2.content);
        }
        files.push({
          path: path22,
          type: "file",
          content
        });
      } else if (node2.type === "directory") {
        files.push({
          path: path22,
          type: "directory"
        });
        if (node2.children) {
          for (const [name2, child] of node2.children) {
            const childPath = path22 === "/" ? `/${name2}` : `${path22}/${name2}`;
            this.serializeNode(childPath, child, files);
          }
        }
      }
    }
    static fromSnapshot(snapshot) {
      const vfs2 = new VirtualFS();
      const sortedFiles = snapshot.files.map((entry, i22) => ({
        entry,
        depth: entry.path.split("/").length,
        i: i22
      })).sort((a, b) => a.depth - b.depth || a.i - b.i).map((x) => x.entry);
      for (const entry of sortedFiles) {
        if (entry.path === "/")
          continue;
        if (entry.type === "directory") {
          vfs2.mkdirSync(entry.path, {
            recursive: true
          });
        } else if (entry.type === "file") {
          let content;
          if (entry.content) {
            content = base64ToUint8(entry.content);
          } else {
            content = new Uint8Array(0);
          }
          const parentPath = entry.path.substring(0, entry.path.lastIndexOf("/")) || "/";
          if (parentPath !== "/" && !vfs2.existsSync(parentPath)) {
            vfs2.mkdirSync(parentPath, {
              recursive: true
            });
          }
          vfs2.writeFileSyncInternal(entry.path, content, false);
        }
      }
      return vfs2;
    }
    writeFileSyncInternal(path22, data2, emitEvent) {
      const normalized = this.normalizePath(path22);
      const parentPath = this.getParentPath(normalized);
      const basename2 = this.getBasename(normalized);
      if (!basename2) {
        throw new Error(`EISDIR: illegal operation on a directory, '${path22}'`);
      }
      const parent = this.ensureDirectory(parentPath);
      const existed = parent.children.has(basename2);
      const content = typeof data2 === "string" ? this.encoder.encode(data2) : data2;
      parent.children.set(basename2, {
        type: "file",
        content,
        mtime: Date.now()
      });
      if (emitEvent) {
        this.notifyWatchers(normalized, existed ? "change" : "rename");
        this.emit("change", normalized, typeof data2 === "string" ? data2 : this.decoder.decode(data2));
      }
    }
    normalizePath(path22) {
      if (!path22.startsWith("/")) {
        path22 = "/" + path22;
      }
      const parts = path22.split("/").filter(Boolean);
      const resolved = [];
      for (const part of parts) {
        if (part === "..") {
          resolved.pop();
        } else if (part !== ".") {
          resolved.push(part);
        }
      }
      return "/" + resolved.join("/");
    }
    getPathSegments(path22) {
      return this.normalizePath(path22).split("/").filter(Boolean);
    }
    getParentPath(path22) {
      const normalized = this.normalizePath(path22);
      const lastSlash = normalized.lastIndexOf("/");
      return lastSlash <= 0 ? "/" : normalized.slice(0, lastSlash);
    }
    getBasename(path22) {
      const normalized = this.normalizePath(path22);
      const lastSlash = normalized.lastIndexOf("/");
      return normalized.slice(lastSlash + 1);
    }
    getNode(path22) {
      const segments = this.getPathSegments(path22);
      let current = this.root;
      for (const segment of segments) {
        if (current.type !== "directory" || !current.children) {
          return void 0;
        }
        const child = current.children.get(segment);
        if (!child) {
          return void 0;
        }
        current = child;
      }
      return current;
    }
    ensureDirectory(path22) {
      const segments = this.getPathSegments(path22);
      let current = this.root;
      for (const segment of segments) {
        if (!current.children) {
          current.children = /* @__PURE__ */ new Map();
        }
        let child = current.children.get(segment);
        if (!child) {
          child = {
            type: "directory",
            children: /* @__PURE__ */ new Map(),
            mtime: Date.now()
          };
          current.children.set(segment, child);
        } else if (child.type !== "directory") {
          throw new Error(`ENOTDIR: not a directory, '${path22}'`);
        }
        current = child;
      }
      return current;
    }
    existsSync(path22) {
      return this.getNode(path22) !== void 0;
    }
    statSync(path22) {
      var _a22;
      const node2 = this.getNode(path22);
      if (!node2) {
        throw createNodeError("ENOENT", "stat", path22);
      }
      const size = node2.type === "file" ? ((_a22 = node2.content) == null ? void 0 : _a22.length) || 0 : 0;
      const mtime = node2.mtime;
      return {
        isFile: () => node2.type === "file",
        isDirectory: () => node2.type === "directory",
        isSymbolicLink: () => false,
        isBlockDevice: () => false,
        isCharacterDevice: () => false,
        isFIFO: () => false,
        isSocket: () => false,
        size,
        mode: node2.type === "directory" ? 493 : 420,
        mtime: new Date(mtime),
        atime: new Date(mtime),
        ctime: new Date(mtime),
        birthtime: new Date(mtime),
        mtimeMs: mtime,
        atimeMs: mtime,
        ctimeMs: mtime,
        birthtimeMs: mtime,
        nlink: 1,
        uid: 1e3,
        gid: 1e3,
        dev: 0,
        ino: 0,
        rdev: 0,
        blksize: 4096,
        blocks: Math.ceil(size / 512)
      };
    }
    lstatSync(path22) {
      return this.statSync(path22);
    }
    readFileSync(path22, encoding) {
      const node2 = this.getNode(path22);
      if (!node2) {
        throw createNodeError("ENOENT", "open", path22);
      }
      if (node2.type !== "file") {
        throw createNodeError("EISDIR", "read", path22);
      }
      const content = node2.content || new Uint8Array(0);
      if (encoding === "utf8" || encoding === "utf-8") {
        return this.decoder.decode(content);
      }
      return content;
    }
    writeFileSync(path22, data2) {
      this.writeFileSyncInternal(path22, data2, true);
    }
    mkdirSync(path22, options2) {
      const normalized = this.normalizePath(path22);
      if (options2 == null ? void 0 : options2.recursive) {
        this.ensureDirectory(normalized);
        return;
      }
      const parentPath = this.getParentPath(normalized);
      const basename2 = this.getBasename(normalized);
      if (!basename2) {
        return;
      }
      const parent = this.getNode(parentPath);
      if (!parent) {
        throw createNodeError("ENOENT", "mkdir", parentPath);
      }
      if (parent.type !== "directory") {
        throw createNodeError("ENOTDIR", "mkdir", parentPath);
      }
      if (parent.children.has(basename2)) {
        throw createNodeError("EEXIST", "mkdir", path22);
      }
      parent.children.set(basename2, {
        type: "directory",
        children: /* @__PURE__ */ new Map(),
        mtime: Date.now()
      });
    }
    readdirSync(path22) {
      const node2 = this.getNode(path22);
      if (!node2) {
        throw createNodeError("ENOENT", "scandir", path22);
      }
      if (node2.type !== "directory") {
        throw createNodeError("ENOTDIR", "scandir", path22);
      }
      return Array.from(node2.children.keys());
    }
    unlinkSync(path22) {
      const normalized = this.normalizePath(path22);
      const parentPath = this.getParentPath(normalized);
      const basename2 = this.getBasename(normalized);
      const parent = this.getNode(parentPath);
      if (!parent || parent.type !== "directory") {
        throw createNodeError("ENOENT", "unlink", path22);
      }
      const node2 = parent.children.get(basename2);
      if (!node2) {
        throw createNodeError("ENOENT", "unlink", path22);
      }
      if (node2.type !== "file") {
        throw createNodeError("EISDIR", "unlink", path22);
      }
      parent.children.delete(basename2);
      this.notifyWatchers(normalized, "rename");
      this.emit("delete", normalized);
    }
    rmdirSync(path22) {
      const normalized = this.normalizePath(path22);
      const parentPath = this.getParentPath(normalized);
      const basename2 = this.getBasename(normalized);
      if (!basename2) {
        throw new Error(`EPERM: operation not permitted, '${path22}'`);
      }
      const parent = this.getNode(parentPath);
      if (!parent || parent.type !== "directory") {
        throw createNodeError("ENOENT", "rmdir", path22);
      }
      const node2 = parent.children.get(basename2);
      if (!node2) {
        throw createNodeError("ENOENT", "rmdir", path22);
      }
      if (node2.type !== "directory") {
        throw createNodeError("ENOTDIR", "rmdir", path22);
      }
      if (node2.children.size > 0) {
        throw createNodeError("ENOTEMPTY", "rmdir", path22);
      }
      parent.children.delete(basename2);
    }
    renameSync(oldPath, newPath) {
      const normalizedOld = this.normalizePath(oldPath);
      const normalizedNew = this.normalizePath(newPath);
      const oldParentPath = this.getParentPath(normalizedOld);
      const oldBasename = this.getBasename(normalizedOld);
      const newParentPath = this.getParentPath(normalizedNew);
      const newBasename = this.getBasename(normalizedNew);
      const oldParent = this.getNode(oldParentPath);
      if (!oldParent || oldParent.type !== "directory") {
        throw createNodeError("ENOENT", "rename", oldPath);
      }
      const node2 = oldParent.children.get(oldBasename);
      if (!node2) {
        throw createNodeError("ENOENT", "rename", oldPath);
      }
      const newParent = this.ensureDirectory(newParentPath);
      oldParent.children.delete(oldBasename);
      newParent.children.set(newBasename, node2);
      this.notifyWatchers(normalizedOld, "rename");
      this.notifyWatchers(normalizedNew, "rename");
    }
    readFile(path22, optionsOrCallback, callback) {
      const actualCallback = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
      const options2 = typeof optionsOrCallback === "object" ? optionsOrCallback : void 0;
      try {
        const data2 = (options2 == null ? void 0 : options2.encoding) ? this.readFileSync(path22, options2.encoding) : this.readFileSync(path22);
        if (actualCallback) {
          setTimeout(() => actualCallback(null, data2), 0);
        }
      } catch (err2) {
        if (actualCallback) {
          setTimeout(() => actualCallback(err2), 0);
        }
      }
    }
    stat(path22, callback) {
      try {
        const stats = this.statSync(path22);
        setTimeout(() => callback(null, stats), 0);
      } catch (err2) {
        setTimeout(() => callback(err2), 0);
      }
    }
    lstat(path22, callback) {
      this.stat(path22, callback);
    }
    readdir(path22, optionsOrCallback, callback) {
      const actualCallback = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
      try {
        const files = this.readdirSync(path22);
        if (actualCallback) {
          setTimeout(() => actualCallback(null, files), 0);
        }
      } catch (err2) {
        if (actualCallback) {
          setTimeout(() => actualCallback(err2), 0);
        }
      }
    }
    realpath(path22, callback) {
      try {
        const resolved = this.realpathSync(path22);
        setTimeout(() => callback(null, resolved), 0);
      } catch (err2) {
        setTimeout(() => callback(err2), 0);
      }
    }
    realpathSync(path22) {
      const normalized = this.normalizePath(path22);
      if (!this.existsSync(normalized)) {
        throw createNodeError("ENOENT", "realpath", path22);
      }
      return normalized;
    }
    watch(filename2, optionsOrListener, listener) {
      const normalized = this.normalizePath(filename2);
      let options2 = {};
      let actualListener;
      if (typeof optionsOrListener === "function") {
        actualListener = optionsOrListener;
      } else if (optionsOrListener) {
        options2 = optionsOrListener;
        actualListener = listener;
      } else {
        actualListener = listener;
      }
      const entry = {
        listener: actualListener || (() => {
        }),
        recursive: options2.recursive || false,
        closed: false
      };
      if (!this.watchers.has(normalized)) {
        this.watchers.set(normalized, /* @__PURE__ */ new Set());
      }
      this.watchers.get(normalized).add(entry);
      const watcher = {
        close: () => {
          entry.closed = true;
          const watcherSet = this.watchers.get(normalized);
          if (watcherSet) {
            watcherSet.delete(entry);
            if (watcherSet.size === 0) {
              this.watchers.delete(normalized);
            }
          }
        },
        ref: () => watcher,
        unref: () => watcher
      };
      return watcher;
    }
    notifyWatchers(path22, eventType) {
      const normalized = this.normalizePath(path22);
      const basename2 = this.getBasename(normalized);
      const directWatchers = this.watchers.get(normalized);
      if (directWatchers) {
        for (const entry of directWatchers) {
          if (!entry.closed) {
            try {
              entry.listener(eventType, basename2);
            } catch (err2) {
              console.error("Error in file watcher:", err2);
            }
          }
        }
      }
      let currentPath = this.getParentPath(normalized);
      let relativePath = basename2;
      while (currentPath) {
        const parentWatchers = this.watchers.get(currentPath);
        if (parentWatchers) {
          for (const entry of parentWatchers) {
            if (!entry.closed) {
              const isDirectChild = this.getParentPath(normalized) === currentPath;
              if (entry.recursive || isDirectChild) {
                try {
                  entry.listener(eventType, relativePath);
                } catch (err2) {
                  console.error("Error in file watcher:", err2);
                }
              }
            }
          }
        }
        if (currentPath === "/")
          break;
        relativePath = this.getBasename(currentPath) + "/" + relativePath;
        currentPath = this.getParentPath(currentPath);
      }
    }
    accessSync(path22, mode) {
      if (!this.existsSync(path22)) {
        throw createNodeError("ENOENT", "access", path22);
      }
    }
    access(path22, modeOrCallback, callback) {
      const actualCallback = typeof modeOrCallback === "function" ? modeOrCallback : callback;
      try {
        this.accessSync(path22);
        if (actualCallback)
          setTimeout(() => actualCallback(null), 0);
      } catch (err2) {
        if (actualCallback)
          setTimeout(() => actualCallback(err2), 0);
      }
    }
    copyFileSync(src, dest) {
      const content = this.readFileSync(src);
      this.writeFileSync(dest, content);
    }
    createReadStream(path22) {
      const self = this;
      const listeners = {};
      const stream2 = {
        on(event, cb2) {
          if (!listeners[event])
            listeners[event] = [];
          listeners[event].push(cb2);
          return stream2;
        },
        pipe(dest) {
          return dest;
        }
      };
      setTimeout(() => {
        var _a22, _b22, _c22;
        try {
          const data2 = self.readFileSync(path22);
          (_a22 = listeners["data"]) == null ? void 0 : _a22.forEach((cb2) => cb2(data2));
          (_b22 = listeners["end"]) == null ? void 0 : _b22.forEach((cb2) => cb2());
        } catch (err2) {
          (_c22 = listeners["error"]) == null ? void 0 : _c22.forEach((cb2) => cb2(err2));
        }
      }, 0);
      return stream2;
    }
    createWriteStream(path22) {
      const self = this;
      const chunks = [];
      const listeners = {};
      const encoder = new TextEncoder();
      return {
        write(data2) {
          const chunk = typeof data2 === "string" ? encoder.encode(data2) : data2;
          chunks.push(chunk);
          return true;
        },
        end(data2) {
          var _a22, _b22;
          if (data2) {
            const chunk = typeof data2 === "string" ? encoder.encode(data2) : data2;
            chunks.push(chunk);
          }
          const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
          const combined = new Uint8Array(totalLength);
          let offset = 0;
          for (const chunk of chunks) {
            combined.set(chunk, offset);
            offset += chunk.length;
          }
          self.writeFileSync(path22, combined);
          (_a22 = listeners["finish"]) == null ? void 0 : _a22.forEach((cb2) => cb2());
          (_b22 = listeners["close"]) == null ? void 0 : _b22.forEach((cb2) => cb2());
        },
        on(event, cb2) {
          if (!listeners[event])
            listeners[event] = [];
          listeners[event].push(cb2);
          return this;
        }
      };
    }
  };
  function simpleHash(str) {
    let hash = 0;
    for (let i22 = 0; i22 < str.length; i22++) {
      hash = (hash << 5) - hash + str.charCodeAt(i22);
      hash |= 0;
    }
    return hash.toString(36);
  }
  const _decoder$2 = new TextDecoder();
  const _encoder$2 = new TextEncoder();
  class Dirent {
    constructor(name2, isDirectory, isFile) {
      __publicField(this, "name");
      __publicField(this, "_isDirectory");
      __publicField(this, "_isFile");
      this.name = name2;
      this._isDirectory = isDirectory;
      this._isFile = isFile;
    }
    isDirectory() {
      return this._isDirectory;
    }
    isFile() {
      return this._isFile;
    }
    isBlockDevice() {
      return false;
    }
    isCharacterDevice() {
      return false;
    }
    isFIFO() {
      return false;
    }
    isSocket() {
      return false;
    }
    isSymbolicLink() {
      return false;
    }
  }
  function createBuffer(data2) {
    const buffer2 = data2;
    Object.defineProperty(buffer2, "toString", {
      value: function(encoding) {
        if (encoding === "utf8" || encoding === "utf-8" || !encoding) {
          return _decoder$2.decode(this);
        }
        if (encoding === "base64") {
          return uint8ToBase64(this);
        }
        if (encoding === "hex") {
          return uint8ToHex(this);
        }
        throw new Error(`Unsupported encoding: ${encoding}`);
      },
      writable: true,
      configurable: true
    });
    return buffer2;
  }
  const pathRemaps = [
    {
      from: "/convex/",
      to: "/project/convex/"
    }
  ];
  function remapPath(path22) {
    if (path22.includes("vfs:")) {
      const cleanPath = path22.replace(/vfs:/g, "");
      if (!remapPath.logged)
        remapPath.logged = /* @__PURE__ */ new Set();
      if (!remapPath.logged.has(path22)) {
        console.log(`[fs] Stripping vfs: prefix: ${path22} -> ${cleanPath}`);
        remapPath.logged.add(path22);
      }
      path22 = cleanPath;
    }
    for (const remap of pathRemaps) {
      if (path22 === remap.from.slice(0, -1) || path22.startsWith(remap.from)) {
        const remapped = remap.to + path22.slice(remap.from.length);
        if (!remapPath.logged)
          remapPath.logged = /* @__PURE__ */ new Set();
        if (!remapPath.logged.has(path22)) {
          console.log(`[fs] Remapping path: ${path22} -> ${remapped}`);
          remapPath.logged.add(path22);
        }
        return remapped;
      }
    }
    return path22;
  }
  remapPath.logged = /* @__PURE__ */ new Set();
  function toPath(pathLike, getCwd) {
    let path22;
    if (typeof pathLike === "string") {
      path22 = pathLike;
    } else if (pathLike instanceof URL) {
      if (pathLike.protocol === "file:") {
        path22 = decodeURIComponent(pathLike.pathname);
      } else {
        throw new Error(`Unsupported URL protocol: ${pathLike.protocol}`);
      }
    } else if (Buffer.isBuffer(pathLike)) {
      path22 = pathLike.toString("utf8");
    } else if (pathLike && typeof pathLike === "object" && "toString" in pathLike) {
      path22 = String(pathLike);
    } else {
      throw new TypeError(`Path must be a string, URL, or Buffer. Received: ${typeof pathLike}`);
    }
    if (!path22.startsWith("/") && getCwd) {
      const cwd = getCwd();
      path22 = cwd.endsWith("/") ? cwd + path22 : cwd + "/" + path22;
    }
    path22 = remapPath(path22);
    return path22;
  }
  const fdMap = /* @__PURE__ */ new Map();
  let nextFd = 3;
  const callTracker = {
    statSync: /* @__PURE__ */ new Map(),
    readdirSync: /* @__PURE__ */ new Map(),
    lastReset: Date.now()
  };
  function trackCall(method, path22) {
    var _a22;
    const now = Date.now();
    if (now - callTracker.lastReset > 500) {
      callTracker.statSync.clear();
      callTracker.readdirSync.clear();
      callTracker.lastReset = now;
    }
    const map = callTracker[method];
    const count = (map.get(path22) || 0) + 1;
    map.set(path22, count);
    if (count === 10 && path22.includes("_generated")) {
      console.warn(`[fs] ${method} called ${count}x on ${path22}`);
      const err2 = new Error();
      console.log(`[fs] Stack at ${count} calls:`, (_a22 = err2.stack) == null ? void 0 : _a22.split("\n").slice(1, 10).join("\n"));
    }
    if (count === 50) {
      console.warn(`[fs] Potential infinite loop: ${method} called ${count}+ times on ${path22}`);
    }
  }
  createFsShim = function(vfs2, getCwd) {
    const resolvePath = (pathLike) => toPath(pathLike, getCwd);
    const constants22 = {
      F_OK: 0,
      R_OK: 4,
      W_OK: 2,
      X_OK: 1
    };
    const promises2 = {
      readFile(pathLike, encodingOrOptions) {
        return new Promise((resolve2, reject) => {
          try {
            const path22 = resolvePath(pathLike);
            let encoding;
            if (typeof encodingOrOptions === "string") {
              encoding = encodingOrOptions;
            } else if (encodingOrOptions == null ? void 0 : encodingOrOptions.encoding) {
              encoding = encodingOrOptions.encoding;
            }
            if (encoding === "utf8" || encoding === "utf-8") {
              resolve2(vfs2.readFileSync(path22, "utf8"));
            } else {
              resolve2(createBuffer(vfs2.readFileSync(path22)));
            }
          } catch (err2) {
            reject(err2);
          }
        });
      },
      writeFile(pathLike, data2) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.writeFileSync(resolvePath(pathLike), data2);
            resolve2();
          } catch (err2) {
            reject(err2);
          }
        });
      },
      stat(pathLike) {
        return new Promise((resolve2, reject) => {
          try {
            const path22 = typeof pathLike === "string" ? pathLike : resolvePath(pathLike);
            resolve2(vfs2.statSync(path22));
          } catch (err2) {
            reject(err2);
          }
        });
      },
      lstat(pathLike) {
        return this.stat(resolvePath(pathLike));
      },
      readdir(pathLike) {
        return new Promise((resolve2, reject) => {
          try {
            resolve2(vfs2.readdirSync(resolvePath(pathLike)));
          } catch (err2) {
            reject(err2);
          }
        });
      },
      mkdir(pathLike, options2) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.mkdirSync(resolvePath(pathLike), options2);
            resolve2();
          } catch (err2) {
            reject(err2);
          }
        });
      },
      unlink(pathLike) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.unlinkSync(resolvePath(pathLike));
            resolve2();
          } catch (err2) {
            reject(err2);
          }
        });
      },
      rmdir(path22) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.rmdirSync(path22);
            resolve2();
          } catch (err2) {
            reject(err2);
          }
        });
      },
      rename(oldPath, newPath) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.renameSync(oldPath, newPath);
            resolve2();
          } catch (err2) {
            reject(err2);
          }
        });
      },
      access(path22, mode) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.accessSync(path22, mode);
            resolve2();
          } catch (err2) {
            reject(err2);
          }
        });
      },
      realpath(path22) {
        return new Promise((resolve2, reject) => {
          try {
            resolve2(vfs2.realpathSync(path22));
          } catch (err2) {
            reject(err2);
          }
        });
      },
      copyFile(src, dest) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.copyFileSync(src, dest);
            resolve2();
          } catch (err2) {
            reject(err2);
          }
        });
      }
    };
    return {
      readFileSync(pathLike, encodingOrOptions) {
        const path22 = resolvePath(pathLike);
        let encoding;
        if (typeof encodingOrOptions === "string") {
          encoding = encodingOrOptions;
        } else if (encodingOrOptions == null ? void 0 : encodingOrOptions.encoding) {
          encoding = encodingOrOptions.encoding;
        }
        if (encoding === "utf8" || encoding === "utf-8") {
          return vfs2.readFileSync(path22, "utf8");
        }
        const data2 = vfs2.readFileSync(path22);
        return createBuffer(data2);
      },
      writeFileSync(pathLike, data2) {
        if (typeof pathLike === "number") {
          const fd2 = pathLike;
          const entry = fdMap.get(fd2);
          if (!entry) {
            const err2 = new Error(`EBADF: bad file descriptor, write`);
            err2.code = "EBADF";
            err2.errno = -9;
            throw err2;
          }
          const bytes = typeof data2 === "string" ? _encoder$2.encode(data2) : data2;
          entry.content = new Uint8Array(bytes);
          entry.position = bytes.length;
          return;
        }
        const path22 = resolvePath(pathLike);
        if (path22.includes("convex") || path22.includes("_generated")) {
          console.log("[fs] writeFileSync:", path22);
        }
        vfs2.writeFileSync(path22, data2);
      },
      existsSync(pathLike) {
        return vfs2.existsSync(resolvePath(pathLike));
      },
      mkdirSync(pathLike, options2) {
        const path22 = resolvePath(pathLike);
        if (path22.includes("convex") || path22.includes("_generated")) {
          console.log("[fs] mkdirSync:", path22, options2);
        }
        vfs2.mkdirSync(path22, options2);
      },
      readdirSync(pathLike, options2) {
        const path22 = resolvePath(pathLike);
        trackCall("readdirSync", path22);
        const entries = vfs2.readdirSync(path22);
        const opts = typeof options2 === "string" ? {} : options2;
        if (opts == null ? void 0 : opts.withFileTypes) {
          const dirents = entries.map((name2) => {
            const entryPath = path22.endsWith("/") ? path22 + name2 : path22 + "/" + name2;
            let isDir = false;
            let isFile = false;
            try {
              const stat = vfs2.statSync(entryPath);
              isDir = stat.isDirectory();
              isFile = stat.isFile();
            } catch {
              isFile = true;
            }
            return new Dirent(name2, isDir, isFile);
          });
          if (path22.includes("_generated")) {
            console.log(`[fs] readdirSync(${path22}, withFileTypes) -> [${dirents.map((d) => d.name).join(", ")}]`);
          }
          return dirents;
        }
        if (path22.includes("_generated")) {
          console.log(`[fs] readdirSync(${path22}) -> [${entries.join(", ")}]`);
        }
        return entries;
      },
      statSync(pathLike) {
        const origPath = typeof pathLike === "string" ? pathLike : String(pathLike);
        const path22 = resolvePath(pathLike);
        trackCall("statSync", path22);
        const result = vfs2.statSync(path22);
        if (path22.includes("_generated")) {
          const wasRemapped = origPath !== path22;
          console.log(`[fs] statSync(${origPath}${wasRemapped ? " -> " + path22 : ""}) -> isDir: ${result.isDirectory()}`);
        }
        return result;
      },
      lstatSync(pathLike) {
        return vfs2.lstatSync(resolvePath(pathLike));
      },
      fstatSync(fd2) {
        const entry = fdMap.get(fd2);
        if (!entry) {
          const err2 = new Error(`EBADF: bad file descriptor, fstat`);
          err2.code = "EBADF";
          err2.errno = -9;
          throw err2;
        }
        return vfs2.statSync(entry.path);
      },
      openSync(pathLike, flags, _mode) {
        const path22 = resolvePath(pathLike);
        const flagStr = typeof flags === "number" ? "r" : flags;
        const exists = vfs2.existsSync(path22);
        const isWriteMode = flagStr.includes("w") || flagStr.includes("a");
        const isReadMode = flagStr.includes("r") && !flagStr.includes("+");
        if (!exists && isReadMode) {
          const err2 = new Error(`ENOENT: no such file or directory, open '${path22}'`);
          err2.code = "ENOENT";
          err2.errno = -2;
          err2.path = path22;
          throw err2;
        }
        let content;
        if (exists && !flagStr.includes("w")) {
          content = vfs2.readFileSync(path22);
        } else {
          content = new Uint8Array(0);
          if (isWriteMode) {
            const parentPath = path22.substring(0, path22.lastIndexOf("/")) || "/";
            if (!vfs2.existsSync(parentPath)) {
              vfs2.mkdirSync(parentPath, {
                recursive: true
              });
            }
          }
        }
        const fd2 = nextFd++;
        fdMap.set(fd2, {
          path: path22,
          position: flagStr.includes("a") ? content.length : 0,
          flags: flagStr,
          content: new Uint8Array(content)
        });
        return fd2;
      },
      closeSync(fd2) {
        const entry = fdMap.get(fd2);
        if (!entry) {
          return;
        }
        if (entry.flags.includes("w") || entry.flags.includes("a") || entry.flags.includes("+")) {
          vfs2.writeFileSync(entry.path, entry.content);
        }
        fdMap.delete(fd2);
      },
      readSync(fd2, buffer2, offset, length2, position) {
        const entry = fdMap.get(fd2);
        if (!entry) {
          const err2 = new Error(`EBADF: bad file descriptor, read`);
          err2.code = "EBADF";
          err2.errno = -9;
          throw err2;
        }
        const readPos = position !== null ? position : entry.position;
        const bytesToRead = Math.min(length2, entry.content.length - readPos);
        if (bytesToRead <= 0) {
          return 0;
        }
        for (let i22 = 0; i22 < bytesToRead; i22++) {
          buffer2[offset + i22] = entry.content[readPos + i22];
        }
        if (position === null) {
          entry.position += bytesToRead;
        }
        return bytesToRead;
      },
      writeSync(fd2, buffer2, offset, length2, position) {
        const entry = fdMap.get(fd2);
        if (!entry) {
          const err2 = new Error(`EBADF: bad file descriptor, write`);
          err2.code = "EBADF";
          err2.errno = -9;
          throw err2;
        }
        let data2;
        if (typeof buffer2 === "string") {
          data2 = _encoder$2.encode(buffer2);
          offset = 0;
          length2 = data2.length;
        } else {
          data2 = buffer2;
          offset = offset ?? 0;
          length2 = length2 ?? data2.length - offset;
        }
        const writePos = position !== null && position !== void 0 ? position : entry.position;
        const endPos = writePos + length2;
        if (endPos > entry.content.length) {
          const newContent = new Uint8Array(endPos);
          newContent.set(entry.content);
          entry.content = newContent;
        }
        for (let i22 = 0; i22 < length2; i22++) {
          entry.content[writePos + i22] = data2[offset + i22];
        }
        if (position === null || position === void 0) {
          entry.position = endPos;
        }
        return length2;
      },
      ftruncateSync(fd2, len = 0) {
        const entry = fdMap.get(fd2);
        if (!entry) {
          const err2 = new Error(`EBADF: bad file descriptor, ftruncate`);
          err2.code = "EBADF";
          err2.errno = -9;
          throw err2;
        }
        if (len < entry.content.length) {
          entry.content = entry.content.slice(0, len);
        } else if (len > entry.content.length) {
          const newContent = new Uint8Array(len);
          newContent.set(entry.content);
          entry.content = newContent;
        }
      },
      fsyncSync(_fd) {
      },
      fdatasyncSync(_fd) {
      },
      mkdtempSync(prefix) {
        const suffix = Math.random().toString(36).slice(2, 8);
        const tempDir = `${prefix}${suffix}`;
        const resolvedPath2 = resolvePath(tempDir);
        vfs2.mkdirSync(resolvedPath2, {
          recursive: true
        });
        return resolvedPath2;
      },
      rmSync(pathLike, options2) {
        const path22 = resolvePath(pathLike);
        if (!vfs2.existsSync(path22)) {
          if (options2 == null ? void 0 : options2.force)
            return;
          throw createNodeError("ENOENT", "rm", path22);
        }
        const stats = vfs2.statSync(path22);
        if (stats.isDirectory()) {
          if (options2 == null ? void 0 : options2.recursive) {
            const entries = vfs2.readdirSync(path22);
            for (const entry of entries) {
              const entryPath = path22.endsWith("/") ? path22 + entry : path22 + "/" + entry;
              this.rmSync(entryPath, options2);
            }
            vfs2.rmdirSync(path22);
          } else {
            throw createNodeError("EISDIR", "rm", path22);
          }
        } else {
          vfs2.unlinkSync(path22);
        }
      },
      unlinkSync(pathLike) {
        const path22 = resolvePath(pathLike);
        if (path22.includes("_generated")) {
          console.log(`[fs] unlinkSync(${path22})`);
        }
        vfs2.unlinkSync(path22);
      },
      rmdirSync(pathLike) {
        vfs2.rmdirSync(resolvePath(pathLike));
      },
      renameSync(oldPathLike, newPathLike) {
        vfs2.renameSync(resolvePath(oldPathLike), resolvePath(newPathLike));
      },
      realpathSync(pathLike) {
        return vfs2.realpathSync(resolvePath(pathLike));
      },
      accessSync(pathLike, _mode) {
        vfs2.accessSync(resolvePath(pathLike));
      },
      copyFileSync(srcLike, destLike) {
        const src = resolvePath(srcLike);
        const dest = resolvePath(destLike);
        const data2 = vfs2.readFileSync(src);
        vfs2.writeFileSync(dest, data2);
      },
      watch(pathLike, optionsOrListener, listener) {
        return vfs2.watch(resolvePath(pathLike), optionsOrListener, listener);
      },
      readFile(pathLike, optionsOrCallback, callback) {
        const path22 = resolvePath(pathLike);
        vfs2.readFile(path22, optionsOrCallback, callback);
      },
      stat(pathLike, callback) {
        vfs2.stat(resolvePath(pathLike), callback);
      },
      lstat(pathLike, callback) {
        vfs2.lstat(resolvePath(pathLike), callback);
      },
      readdir(pathLike, optionsOrCallback, callback) {
        vfs2.readdir(resolvePath(pathLike), optionsOrCallback, callback);
      },
      realpath(pathLike, callback) {
        vfs2.realpath(resolvePath(pathLike), callback);
      },
      access(pathLike, modeOrCallback, callback) {
        vfs2.access(resolvePath(pathLike), modeOrCallback, callback);
      },
      createReadStream(pathLike) {
        return vfs2.createReadStream(resolvePath(pathLike));
      },
      createWriteStream(pathLike) {
        return vfs2.createWriteStream(resolvePath(pathLike));
      },
      promises: promises2,
      constants: constants22
    };
  };
  const fs = Object.freeze(Object.defineProperty({
    __proto__: null,
    Dirent,
    createFsShim,
    default: createFsShim
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const sep = "/";
  const delimiter = ":";
  function normalize(path22) {
    if (!path22)
      return ".";
    const isAbsolute2 = path22.startsWith("/");
    const parts = path22.split("/").filter(Boolean);
    const resolved = [];
    for (const part of parts) {
      if (part === "..") {
        if (resolved.length > 0 && resolved[resolved.length - 1] !== "..") {
          resolved.pop();
        } else if (!isAbsolute2) {
          resolved.push("..");
        }
      } else if (part !== ".") {
        resolved.push(part);
      }
    }
    let result = resolved.join("/");
    if (isAbsolute2) {
      result = "/" + result;
    }
    return result || ".";
  }
  function join(...paths) {
    if (paths.length === 0)
      return ".";
    return normalize(paths.filter(Boolean).join("/"));
  }
  function resolve$2(...paths) {
    let resolvedPath2 = "";
    for (let i22 = paths.length - 1; i22 >= 0 && !resolvedPath2.startsWith("/"); i22--) {
      const path22 = paths[i22];
      if (!path22)
        continue;
      resolvedPath2 = path22 + (resolvedPath2 ? "/" + resolvedPath2 : "");
    }
    if (!resolvedPath2.startsWith("/")) {
      const cwd = typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/";
      resolvedPath2 = cwd + (resolvedPath2 ? "/" + resolvedPath2 : "");
    }
    return normalize(resolvedPath2);
  }
  function isAbsolute(path22) {
    return path22.startsWith("/");
  }
  function dirname(path22) {
    if (!path22)
      return ".";
    const normalized = normalize(path22);
    const lastSlash = normalized.lastIndexOf("/");
    if (lastSlash === -1)
      return ".";
    if (lastSlash === 0)
      return "/";
    return normalized.slice(0, lastSlash);
  }
  function basename(path22, ext2) {
    if (!path22)
      return "";
    const normalized = normalize(path22);
    let base = normalized.slice(normalized.lastIndexOf("/") + 1);
    if (ext2 && base.endsWith(ext2)) {
      base = base.slice(0, -ext2.length);
    }
    return base;
  }
  function extname(path22) {
    const base = basename(path22);
    const dotIndex = base.lastIndexOf(".");
    if (dotIndex <= 0)
      return "";
    return base.slice(dotIndex);
  }
  function relative(from, to2) {
    from = resolve$2(from);
    to2 = resolve$2(to2);
    if (from === to2)
      return "";
    const fromParts = from.split("/").filter(Boolean);
    const toParts = to2.split("/").filter(Boolean);
    let commonLength = 0;
    for (let i22 = 0; i22 < Math.min(fromParts.length, toParts.length); i22++) {
      if (fromParts[i22] !== toParts[i22])
        break;
      commonLength++;
    }
    const upCount = fromParts.length - commonLength;
    const remainingPath = toParts.slice(commonLength);
    const result = [
      ...Array(upCount).fill(".."),
      ...remainingPath
    ];
    return result.join("/") || ".";
  }
  function parse$R(path22) {
    const normalized = normalize(path22);
    const isAbs = isAbsolute(normalized);
    const dir = dirname(normalized);
    const base = basename(normalized);
    const ext2 = extname(normalized);
    const name2 = base.slice(0, base.length - ext2.length);
    return {
      root: isAbs ? "/" : "",
      dir,
      base,
      ext: ext2,
      name: name2
    };
  }
  function format$2(pathObject) {
    const dir = pathObject.dir || pathObject.root || "";
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir)
      return base;
    if (dir === pathObject.root)
      return dir + base;
    return dir + "/" + base;
  }
  const posix = {
    sep,
    delimiter,
    normalize,
    join,
    resolve: resolve$2,
    isAbsolute,
    dirname,
    basename,
    extname,
    relative,
    parse: parse$R,
    format: format$2
  };
  const path = {
    sep,
    delimiter,
    normalize,
    join,
    resolve: resolve$2,
    isAbsolute,
    dirname,
    basename,
    extname,
    relative,
    parse: parse$R,
    format: format$2,
    posix
  };
  pathShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    basename,
    default: path,
    delimiter,
    dirname,
    extname,
    format: format$2,
    isAbsolute,
    join,
    normalize,
    parse: parse$R,
    posix,
    relative,
    resolve: resolve$2,
    sep
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const kEvents = Symbol("events");
  const kMaxListeners = Symbol("maxListeners");
  _b = kEvents, _a = kMaxListeners;
  class EventEmitter {
    constructor() {
      __publicField(this, _b);
      __publicField(this, _a);
    }
    _getEvents() {
      const self = this;
      if (!self[kEvents]) {
        self[kEvents] = /* @__PURE__ */ new Map();
      }
      return self[kEvents];
    }
    on(event, listener) {
      return this.addListener(event, listener);
    }
    addListener(event, listener) {
      const events2 = this._getEvents();
      if (!events2.has(event)) {
        events2.set(event, []);
      }
      events2.get(event).push(listener);
      return this;
    }
    once(event, listener) {
      const onceWrapper = (...args) => {
        this.removeListener(event, onceWrapper);
        listener.apply(this, args);
      };
      return this.addListener(event, onceWrapper);
    }
    off(event, listener) {
      return this.removeListener(event, listener);
    }
    removeListener(event, listener) {
      const events2 = this._getEvents();
      const listeners = events2.get(event);
      if (listeners) {
        const index2 = listeners.indexOf(listener);
        if (index2 !== -1) {
          listeners.splice(index2, 1);
        }
      }
      return this;
    }
    removeAllListeners(event) {
      const events2 = this._getEvents();
      if (event) {
        events2.delete(event);
      } else {
        events2.clear();
      }
      return this;
    }
    emit(event, ...args) {
      const events2 = this._getEvents();
      const listeners = events2.get(event);
      if (!listeners || listeners.length === 0) {
        if (event === "error") {
          const err2 = args[0];
          if (err2 instanceof Error) {
            throw err2;
          }
          throw new Error("Unhandled error event");
        }
        return false;
      }
      for (const listener of [
        ...listeners
      ]) {
        try {
          listener.apply(this, args);
        } catch (err2) {
          console.error("Error in event listener:", err2);
        }
      }
      return true;
    }
    listeners(event) {
      const events2 = this._getEvents();
      return [
        ...events2.get(event) || []
      ];
    }
    rawListeners(event) {
      return this.listeners(event);
    }
    listenerCount(event) {
      var _a22;
      const events2 = this._getEvents();
      return ((_a22 = events2.get(event)) == null ? void 0 : _a22.length) || 0;
    }
    eventNames() {
      const events2 = this._getEvents();
      return [
        ...events2.keys()
      ];
    }
    setMaxListeners(n10) {
      this[kMaxListeners] = n10;
      return this;
    }
    getMaxListeners() {
      return this[kMaxListeners] || 10;
    }
    prependListener(event, listener) {
      const events2 = this._getEvents();
      if (!events2.has(event)) {
        events2.set(event, []);
      }
      events2.get(event).unshift(listener);
      return this;
    }
    prependOnceListener(event, listener) {
      const onceWrapper = (...args) => {
        this.removeListener(event, onceWrapper);
        listener.apply(this, args);
      };
      return this.prependListener(event, onceWrapper);
    }
    static listenerCount(emitter, event) {
      return emitter.listenerCount(event);
    }
  }
  const events = EventEmitter;
  events.EventEmitter = EventEmitter;
  events.once = async (emitter, event) => {
    return new Promise((resolve2, reject) => {
      const onEvent = (...args) => {
        emitter.removeListener("error", onError);
        resolve2(args);
      };
      const onError = (...args) => {
        emitter.removeListener(event, onEvent);
        reject(args[0]);
      };
      emitter.once(event, onEvent);
      emitter.once("error", onError);
    });
  };
  events.on = (emitter, event) => {
    const iterator = {
      async next() {
        return new Promise((resolve2) => {
          emitter.once(event, (...args) => resolve2({
            value: args,
            done: false
          }));
        });
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
    return iterator;
  };
  events.getEventListeners = (emitter, event) => emitter.listeners(event);
  events.listenerCount = (emitter, event) => emitter.listenerCount(event);
  events$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    EventEmitter,
    default: events
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function createProcessStream(isWritable, writeImpl) {
    const emitter = new EventEmitter();
    const stream2 = {
      isTTY: false,
      on(event, listener) {
        emitter.on(event, listener);
        return stream2;
      },
      once(event, listener) {
        emitter.once(event, listener);
        return stream2;
      },
      off(event, listener) {
        emitter.off(event, listener);
        return stream2;
      },
      emit(event, ...args) {
        return emitter.emit(event, ...args);
      },
      addListener(event, listener) {
        emitter.addListener(event, listener);
        return stream2;
      },
      removeListener(event, listener) {
        emitter.removeListener(event, listener);
        return stream2;
      },
      removeAllListeners(event) {
        emitter.removeAllListeners(event);
        return stream2;
      },
      setMaxListeners(n10) {
        emitter.setMaxListeners(n10);
        return stream2;
      },
      pause() {
        return stream2;
      },
      resume() {
        return stream2;
      },
      setEncoding(_encoding) {
        return stream2;
      },
      write(_data, _encoding, callback) {
        if (callback)
          queueMicrotask(callback);
        return true;
      },
      end(_data, callback) {
        if (callback)
          queueMicrotask(callback);
      },
      read() {
        return null;
      },
      setRawMode(_mode) {
        return stream2;
      }
    };
    if (isWritable && writeImpl) {
      stream2.write = (data2, _encoding, callback) => {
        const result = writeImpl(typeof data2 === "string" ? data2 : data2.toString());
        if (callback)
          queueMicrotask(callback);
        return result;
      };
    }
    return stream2;
  }
  createProcess = function(options2) {
    let currentDir2 = (options2 == null ? void 0 : options2.cwd) || "/";
    const env = {
      NODE_ENV: "development",
      PATH: "/usr/local/bin:/usr/bin:/bin",
      HOME: "/",
      ...options2 == null ? void 0 : options2.env
    };
    const emitter = new EventEmitter();
    const startTime = Date.now();
    const proc = {
      env,
      cwd() {
        if (!proc._cwdCallCount)
          proc._cwdCallCount = 0;
        proc._cwdCallCount++;
        if (proc._cwdCallCount <= 5 || proc._cwdCallCount % 100 === 0) {
          console.log(`[process] cwd() called (${proc._cwdCallCount}x), returning:`, currentDir2);
        }
        return currentDir2;
      },
      chdir(directory) {
        console.log("[process] chdir called:", directory, "from:", currentDir2);
        if (!directory.startsWith("/")) {
          directory = currentDir2 + "/" + directory;
        }
        currentDir2 = directory;
        console.log("[process] chdir result:", currentDir2);
      },
      platform: "linux",
      version: "v20.0.0",
      versions: {
        node: "20.0.0",
        v8: "11.3.244.8",
        uv: "1.44.2"
      },
      argv: [
        "node",
        "/index.js"
      ],
      argv0: "node",
      execPath: "/usr/local/bin/node",
      execArgv: [],
      pid: 1,
      ppid: 0,
      exit(code2 = 0) {
        emitter.emit("exit", code2);
        if (options2 == null ? void 0 : options2.onExit) {
          options2.onExit(code2);
        }
        throw new Error(`Process exited with code ${code2}`);
      },
      nextTick(callback, ...args) {
        queueMicrotask(() => callback(...args));
      },
      stdout: createProcessStream(true, (data2) => {
        console.log(data2);
        return true;
      }),
      stderr: createProcessStream(true, (data2) => {
        console.error(data2);
        return true;
      }),
      stdin: createProcessStream(false),
      hrtime: Object.assign(function hrtime(time2) {
        const now = performance.now();
        const seconds = Math.floor(now / 1e3);
        const nanoseconds = Math.floor(now % 1e3 * 1e6);
        if (time2) {
          const diffSeconds = seconds - time2[0];
          const diffNanos = nanoseconds - time2[1];
          return [
            diffSeconds,
            diffNanos
          ];
        }
        return [
          seconds,
          nanoseconds
        ];
      }, {
        bigint: () => BigInt(Math.floor(performance.now() * 1e6))
      }),
      memoryUsage() {
        return {
          rss: 50 * 1024 * 1024,
          heapTotal: 30 * 1024 * 1024,
          heapUsed: 20 * 1024 * 1024,
          external: 1 * 1024 * 1024,
          arrayBuffers: 0
        };
      },
      uptime() {
        return (Date.now() - startTime) / 1e3;
      },
      cpuUsage() {
        return {
          user: 0,
          system: 0
        };
      },
      on(event, listener) {
        emitter.on(event, listener);
        return proc;
      },
      once(event, listener) {
        emitter.once(event, listener);
        return proc;
      },
      off(event, listener) {
        emitter.off(event, listener);
        return proc;
      },
      emit(event, ...args) {
        return emitter.emit(event, ...args);
      },
      addListener(event, listener) {
        emitter.addListener(event, listener);
        return proc;
      },
      removeListener(event, listener) {
        emitter.removeListener(event, listener);
        return proc;
      },
      removeAllListeners(event) {
        emitter.removeAllListeners(event);
        return proc;
      },
      listeners(event) {
        return emitter.listeners(event);
      },
      listenerCount(event) {
        return emitter.listenerCount(event);
      },
      prependListener(event, listener) {
        emitter.prependListener(event, listener);
        return proc;
      },
      prependOnceListener(event, listener) {
        emitter.prependOnceListener(event, listener);
        return proc;
      },
      eventNames() {
        return emitter.eventNames();
      },
      setMaxListeners(n10) {
        emitter.setMaxListeners(n10);
        return proc;
      },
      getMaxListeners() {
        return emitter.getMaxListeners();
      }
    };
    return proc;
  };
  createProcess();
  const _encoder$1 = new TextEncoder();
  const _decoder$1 = new TextDecoder("utf-8");
  class Readable extends EventEmitter {
    constructor() {
      super();
      __publicField(this, "_buffer", []);
      __publicField(this, "_ended", false);
      __publicField(this, "_flowing", false);
      __publicField(this, "_endEmitted", false);
      __publicField(this, "readable", true);
      __publicField(this, "readableEnded", false);
      __publicField(this, "readableFlowing", null);
    }
    _addListenerInternal(event, listener) {
      EventEmitter.prototype.addListener.call(this, event, listener);
      return this;
    }
    on(event, listener) {
      this._addListenerInternal(event, listener);
      if (event === "data" && !this._flowing) {
        queueMicrotask(() => {
          if (this.listenerCount("data") > 0 && !this._flowing) {
            this.resume();
          }
        });
      }
      return this;
    }
    addListener(event, listener) {
      return this.on(event, listener);
    }
    push(chunk) {
      if (chunk === null) {
        this._ended = true;
        this.readableEnded = true;
        this.readable = false;
        if (this._flowing && this._buffer.length === 0 && !this._endEmitted) {
          this._endEmitted = true;
          queueMicrotask(() => this.emit("end"));
        }
        return false;
      }
      const buffer2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
      this._buffer.push(buffer2);
      if (this._flowing) {
        queueMicrotask(() => {
          this._flushBuffer();
        });
      }
      return true;
    }
    _flushBuffer() {
      while (this._buffer.length > 0 && this._flowing) {
        const data2 = this._buffer.shift();
        this.emit("data", data2);
      }
      if (this._ended && this._buffer.length === 0 && !this._endEmitted) {
        this._endEmitted = true;
        this.emit("end");
      }
    }
    read(size) {
      if (this._buffer.length === 0) {
        return null;
      }
      if (size === void 0) {
        const result = Buffer.concat(this._buffer);
        this._buffer = [];
        return result;
      }
      const chunks = [];
      let remaining = size;
      while (remaining > 0 && this._buffer.length > 0) {
        const chunk = this._buffer[0];
        if (chunk.length <= remaining) {
          chunks.push(this._buffer.shift());
          remaining -= chunk.length;
        } else {
          chunks.push(chunk.slice(0, remaining));
          this._buffer[0] = chunk.slice(remaining);
          remaining = 0;
        }
      }
      return chunks.length > 0 ? Buffer.concat(chunks) : null;
    }
    resume() {
      this._flowing = true;
      this.readableFlowing = true;
      this._flushBuffer();
      return this;
    }
    pause() {
      this._flowing = false;
      this.readableFlowing = false;
      return this;
    }
    pipe(destination) {
      this.on("data", (chunk) => {
        destination.write(chunk);
      });
      this.on("end", () => {
        destination.end();
      });
      this.resume();
      return destination;
    }
    unpipe(destination) {
      this.removeAllListeners("data");
      this.removeAllListeners("end");
      return this;
    }
    setEncoding(encoding) {
      return this;
    }
    destroy(error) {
      this._buffer = [];
      this._ended = true;
      this.readable = false;
      if (error) {
        this.emit("error", error);
      }
      this.emit("close");
      return this;
    }
    static from(iterable, options2) {
      const readable = new Readable();
      (async () => {
        try {
          for await (const chunk of iterable) {
            if (chunk !== null && chunk !== void 0) {
              const data2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
              readable.push(data2);
            }
          }
          readable.push(null);
        } catch (err2) {
          readable.destroy(err2);
        }
      })();
      return readable;
    }
  }
  class Writable extends EventEmitter {
    constructor() {
      super();
      __publicField(this, "_chunks", []);
      __publicField(this, "_ended", false);
      __publicField(this, "writable", true);
      __publicField(this, "writableEnded", false);
      __publicField(this, "writableFinished", false);
    }
    write(chunk, encodingOrCallback, callback) {
      if (this._ended) {
        const error = new Error("write after end");
        if (typeof encodingOrCallback === "function") {
          encodingOrCallback(error);
        } else if (callback) {
          callback(error);
        }
        return false;
      }
      const buffer2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
      this._chunks.push(buffer2);
      const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      if (cb2) {
        queueMicrotask(() => cb2(null));
      }
      return true;
    }
    end(chunkOrCallback, encodingOrCallback, callback) {
      if (typeof chunkOrCallback === "function") {
        callback = chunkOrCallback;
      } else if (chunkOrCallback !== void 0) {
        this.write(chunkOrCallback);
      }
      if (typeof encodingOrCallback === "function") {
        callback = encodingOrCallback;
      }
      this._ended = true;
      this.writable = false;
      this.writableEnded = true;
      queueMicrotask(() => {
        this.writableFinished = true;
        this.emit("finish");
        if (callback) {
          callback();
        }
      });
      return this;
    }
    getBuffer() {
      return Buffer.concat(this._chunks);
    }
    getBufferAsString(encoding = "utf8") {
      return this.getBuffer().toString(encoding);
    }
    destroy(error) {
      this._chunks = [];
      this._ended = true;
      this.writable = false;
      if (error) {
        this.emit("error", error);
      }
      this.emit("close");
      return this;
    }
    cork() {
    }
    uncork() {
    }
    setDefaultEncoding(encoding) {
      return this;
    }
  }
  class Duplex extends Readable {
    constructor() {
      super(...arguments);
      __publicField(this, "_writeChunks", []);
      __publicField(this, "_writeEnded", false);
      __publicField(this, "writable", true);
      __publicField(this, "writableEnded", false);
      __publicField(this, "writableFinished", false);
    }
    write(chunk, encodingOrCallback, callback) {
      if (this._writeEnded) {
        return false;
      }
      const buffer2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
      this._writeChunks.push(buffer2);
      const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      if (cb2) {
        queueMicrotask(() => cb2(null));
      }
      return true;
    }
    end(chunkOrCallback, encodingOrCallback, callback) {
      if (typeof chunkOrCallback === "function") {
        callback = chunkOrCallback;
      } else if (chunkOrCallback !== void 0) {
        this.write(chunkOrCallback);
      }
      this._writeEnded = true;
      this.writable = false;
      this.writableEnded = true;
      queueMicrotask(() => {
        this.writableFinished = true;
        this.emit("finish");
        if (callback) {
          callback();
        }
      });
      return this;
    }
  }
  class PassThrough extends Duplex {
    constructor() {
      super();
    }
    write(chunk, encodingOrCallback, callback) {
      const buffer2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
      this.push(buffer2);
      const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      if (cb2) {
        queueMicrotask(() => cb2(null));
      }
      return true;
    }
  }
  class Transform extends Duplex {
    constructor() {
      super();
    }
    _transform(chunk, encoding, callback) {
      callback(null, chunk);
    }
    _flush(callback) {
      callback(null);
    }
    write(chunk, encodingOrCallback, callback) {
      const buffer2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
      const encoding = typeof encodingOrCallback === "string" ? encodingOrCallback : "utf8";
      const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      this._transform(buffer2, encoding, (error, data2) => {
        if (error) {
          if (cb2)
            cb2(error);
          return;
        }
        if (data2) {
          this.push(data2);
        }
        if (cb2)
          cb2(null);
      });
      return true;
    }
    end(chunkOrCallback, encodingOrCallback, callback) {
      this._flush((error, data2) => {
        if (data2) {
          this.push(data2);
        }
      });
      return super.end(chunkOrCallback, encodingOrCallback, callback);
    }
  }
  class Stream extends EventEmitter {
    pipe(destination) {
      return destination;
    }
  }
  Stream.Readable = Readable;
  Stream.Writable = Writable;
  Stream.Duplex = Duplex;
  Stream.Transform = Transform;
  Stream.PassThrough = PassThrough;
  Stream.Stream = Stream;
  Stream.from = Readable.from;
  const promises$2 = {
    pipeline: async (...streams) => {
      return Promise.resolve();
    },
    finished: async (stream2) => {
      return Promise.resolve();
    }
  };
  function pipeline(...args) {
    const callback = args[args.length - 1];
    if (typeof callback === "function") {
      setTimeout(() => callback(), 0);
    }
    return args[args.length - 2] || args[0];
  }
  function finished(stream2, callback) {
    setTimeout(() => callback(), 0);
    return () => {
    };
  }
  const _BufferPolyfill = class _BufferPolyfill2 extends Uint8Array {
    static from(value2, encodingOrMapfn, thisArg) {
      if (typeof encodingOrMapfn === "function") {
        const arrayLike = value2;
        const mapped = Array.from(arrayLike, encodingOrMapfn, thisArg);
        return new _BufferPolyfill2(mapped);
      }
      const data2 = value2;
      const encoding = encodingOrMapfn;
      if (Array.isArray(data2)) {
        return new _BufferPolyfill2(data2);
      }
      if (typeof data2 === "string") {
        const enc = (encoding || "utf8").toLowerCase();
        if (enc === "base64" || enc === "base64url") {
          let base642 = data2;
          if (enc === "base64url") {
            base642 = data2.replace(/-/g, "+").replace(/_/g, "/");
            while (base642.length % 4 !== 0) {
              base642 += "=";
            }
          }
          const binary = atob(base642);
          const bytes2 = new Uint8Array(binary.length);
          for (let i22 = 0; i22 < binary.length; i22++) {
            bytes2[i22] = binary.charCodeAt(i22);
          }
          return new _BufferPolyfill2(bytes2);
        }
        if (enc === "hex") {
          const bytes2 = new Uint8Array(data2.length / 2);
          for (let i22 = 0; i22 < data2.length; i22 += 2) {
            bytes2[i22 / 2] = parseInt(data2.slice(i22, i22 + 2), 16);
          }
          return new _BufferPolyfill2(bytes2);
        }
        if (enc === "latin1" || enc === "binary") {
          const bytes2 = new Uint8Array(data2.length);
          for (let i22 = 0; i22 < data2.length; i22++) {
            bytes2[i22] = data2.charCodeAt(i22) & 255;
          }
          return new _BufferPolyfill2(bytes2);
        }
        const bytes = _encoder$1.encode(data2);
        return new _BufferPolyfill2(bytes);
      }
      if (data2 instanceof ArrayBuffer) {
        return new _BufferPolyfill2(data2);
      }
      return new _BufferPolyfill2(data2);
    }
    static alloc(size, fill) {
      const buffer2 = new _BufferPolyfill2(size);
      if (fill !== void 0) {
        buffer2.fill(fill);
      }
      return buffer2;
    }
    static allocUnsafe(size) {
      return new _BufferPolyfill2(size);
    }
    static allocUnsafeSlow(size) {
      return new _BufferPolyfill2(size);
    }
    static concat(buffers) {
      const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0);
      const result = new _BufferPolyfill2(totalLength);
      let offset = 0;
      for (const buf of buffers) {
        result.set(buf, offset);
        offset += buf.length;
      }
      return result;
    }
    static isBuffer(obj) {
      return obj instanceof _BufferPolyfill2 || obj instanceof Uint8Array;
    }
    static isEncoding(encoding) {
      return [
        "utf8",
        "utf-8",
        "ascii",
        "latin1",
        "binary",
        "base64",
        "base64url",
        "hex"
      ].includes(encoding.toLowerCase());
    }
    static byteLength(string, encoding) {
      const enc = (encoding || "utf8").toLowerCase();
      if (enc === "base64" || enc === "base64url") {
        const base642 = string.replace(/[=]/g, "");
        return Math.floor(base642.length * 3 / 4);
      }
      if (enc === "hex") {
        return string.length / 2;
      }
      return _encoder$1.encode(string).length;
    }
    toString(encoding = "utf8") {
      const enc = (encoding || "utf8").toLowerCase();
      if (enc === "base64") {
        return uint8ToBase64(this);
      }
      if (enc === "base64url") {
        return uint8ToBase64(this).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      }
      if (enc === "hex") {
        return uint8ToHex(this);
      }
      if (enc === "latin1" || enc === "binary") {
        return uint8ToBinaryString(this);
      }
      return _decoder$1.decode(this);
    }
    slice(start, end) {
      return new _BufferPolyfill2(super.slice(start, end));
    }
    subarray(start, end) {
      return new _BufferPolyfill2(super.subarray(start, end));
    }
    write(string, offset) {
      const bytes = _encoder$1.encode(string);
      this.set(bytes, offset || 0);
      return bytes.length;
    }
    copy(target, targetStart, sourceStart, sourceEnd) {
      const src = this.subarray(sourceStart || 0, sourceEnd);
      target.set(src, targetStart || 0);
      return src.length;
    }
    compare(otherBuffer) {
      const len = Math.min(this.length, otherBuffer.length);
      for (let i22 = 0; i22 < len; i22++) {
        if (this[i22] < otherBuffer[i22])
          return -1;
        if (this[i22] > otherBuffer[i22])
          return 1;
      }
      if (this.length < otherBuffer.length)
        return -1;
      if (this.length > otherBuffer.length)
        return 1;
      return 0;
    }
    equals(otherBuffer) {
      return this.compare(otherBuffer) === 0;
    }
    toJSON() {
      return {
        type: "Buffer",
        data: Array.from(this)
      };
    }
    hasOwnProperty(prop) {
      return Object.prototype.hasOwnProperty.call(this, prop);
    }
    readUInt8(offset) {
      return this[offset];
    }
    readUInt16BE(offset) {
      return this[offset] << 8 | this[offset + 1];
    }
    readUInt16LE(offset) {
      return this[offset] | this[offset + 1] << 8;
    }
    readUInt32BE(offset) {
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    }
    readUInt32LE(offset) {
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    }
    writeUInt8(value2, offset) {
      this[offset] = value2 & 255;
      return offset + 1;
    }
    writeUInt16BE(value2, offset) {
      this[offset] = value2 >> 8 & 255;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    }
    writeUInt16LE(value2, offset) {
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >> 8 & 255;
      return offset + 2;
    }
    writeUInt32BE(value2, offset) {
      this[offset] = value2 >> 24 & 255;
      this[offset + 1] = value2 >> 16 & 255;
      this[offset + 2] = value2 >> 8 & 255;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    }
    writeUInt32LE(value2, offset) {
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >> 8 & 255;
      this[offset + 2] = value2 >> 16 & 255;
      this[offset + 3] = value2 >> 24 & 255;
      return offset + 4;
    }
    readUint8(offset) {
      return this.readUInt8(offset);
    }
    readUint16BE(offset) {
      return this.readUInt16BE(offset);
    }
    readUint16LE(offset) {
      return this.readUInt16LE(offset);
    }
    readUint32BE(offset) {
      return this.readUInt32BE(offset);
    }
    readUint32LE(offset) {
      return this.readUInt32LE(offset);
    }
    writeUint8(value2, offset) {
      return this.writeUInt8(value2, offset);
    }
    writeUint16BE(value2, offset) {
      return this.writeUInt16BE(value2, offset);
    }
    writeUint16LE(value2, offset) {
      return this.writeUInt16LE(value2, offset);
    }
    writeUint32BE(value2, offset) {
      return this.writeUInt32BE(value2, offset);
    }
    writeUint32LE(value2, offset) {
      return this.writeUInt32LE(value2, offset);
    }
    readInt8(offset) {
      const val = this[offset];
      return val & 128 ? val - 256 : val;
    }
    readInt16BE(offset) {
      const val = this.readUInt16BE(offset);
      return val & 32768 ? val - 65536 : val;
    }
    readInt16LE(offset) {
      const val = this.readUInt16LE(offset);
      return val & 32768 ? val - 65536 : val;
    }
    readInt32BE(offset) {
      const val = this.readUInt32BE(offset);
      return val | 0;
    }
    readInt32LE(offset) {
      const val = this.readUInt32LE(offset);
      return val | 0;
    }
    writeInt8(value2, offset) {
      this[offset] = value2 & 255;
      return offset + 1;
    }
    writeInt16BE(value2, offset) {
      return this.writeUInt16BE(value2 & 65535, offset);
    }
    writeInt16LE(value2, offset) {
      return this.writeUInt16LE(value2 & 65535, offset);
    }
    writeInt32BE(value2, offset) {
      return this.writeUInt32BE(value2 >>> 0, offset);
    }
    writeInt32LE(value2, offset) {
      return this.writeUInt32LE(value2 >>> 0, offset);
    }
    readBigUInt64LE(offset) {
      const lo2 = BigInt(this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24) & 0xffffffffn;
      const hi2 = BigInt(this[offset + 4] | this[offset + 5] << 8 | this[offset + 6] << 16 | this[offset + 7] << 24) & 0xffffffffn;
      return lo2 | hi2 << 32n;
    }
    readBigUInt64BE(offset) {
      const hi2 = BigInt(this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]) & 0xffffffffn;
      const lo2 = BigInt(this[offset + 4] << 24 | this[offset + 5] << 16 | this[offset + 6] << 8 | this[offset + 7]) & 0xffffffffn;
      return lo2 | hi2 << 32n;
    }
    readBigInt64LE(offset) {
      const val = this.readBigUInt64LE(offset);
      if (val >= 0x8000000000000000n) {
        return val - 0x10000000000000000n;
      }
      return val;
    }
    readBigInt64BE(offset) {
      const val = this.readBigUInt64BE(offset);
      if (val >= 0x8000000000000000n) {
        return val - 0x10000000000000000n;
      }
      return val;
    }
    writeBigUInt64LE(value2, offset) {
      const lo2 = value2 & 0xffffffffn;
      const hi2 = value2 >> 32n & 0xffffffffn;
      this[offset] = Number(lo2 & 0xffn);
      this[offset + 1] = Number(lo2 >> 8n & 0xffn);
      this[offset + 2] = Number(lo2 >> 16n & 0xffn);
      this[offset + 3] = Number(lo2 >> 24n & 0xffn);
      this[offset + 4] = Number(hi2 & 0xffn);
      this[offset + 5] = Number(hi2 >> 8n & 0xffn);
      this[offset + 6] = Number(hi2 >> 16n & 0xffn);
      this[offset + 7] = Number(hi2 >> 24n & 0xffn);
      return offset + 8;
    }
    writeBigUInt64BE(value2, offset) {
      const lo2 = value2 & 0xffffffffn;
      const hi2 = value2 >> 32n & 0xffffffffn;
      this[offset] = Number(hi2 >> 24n & 0xffn);
      this[offset + 1] = Number(hi2 >> 16n & 0xffn);
      this[offset + 2] = Number(hi2 >> 8n & 0xffn);
      this[offset + 3] = Number(hi2 & 0xffn);
      this[offset + 4] = Number(lo2 >> 24n & 0xffn);
      this[offset + 5] = Number(lo2 >> 16n & 0xffn);
      this[offset + 6] = Number(lo2 >> 8n & 0xffn);
      this[offset + 7] = Number(lo2 & 0xffn);
      return offset + 8;
    }
    writeBigInt64LE(value2, offset) {
      const unsigned = value2 < 0n ? value2 + 0x10000000000000000n : value2;
      return this.writeBigUInt64LE(unsigned, offset);
    }
    writeBigInt64BE(value2, offset) {
      const unsigned = value2 < 0n ? value2 + 0x10000000000000000n : value2;
      return this.writeBigUInt64BE(unsigned, offset);
    }
    readBigUint64LE(offset) {
      return this.readBigUInt64LE(offset);
    }
    readBigUint64BE(offset) {
      return this.readBigUInt64BE(offset);
    }
    writeBigUint64LE(value2, offset) {
      return this.writeBigUInt64LE(value2, offset);
    }
    writeBigUint64BE(value2, offset) {
      return this.writeBigUInt64BE(value2, offset);
    }
    readFloatLE(offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 4);
      return view.getFloat32(0, true);
    }
    readFloatBE(offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 4);
      return view.getFloat32(0, false);
    }
    readDoubleLE(offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 8);
      return view.getFloat64(0, true);
    }
    readDoubleBE(offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 8);
      return view.getFloat64(0, false);
    }
    writeFloatLE(value2, offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 4);
      view.setFloat32(0, value2, true);
      return offset + 4;
    }
    writeFloatBE(value2, offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 4);
      view.setFloat32(0, value2, false);
      return offset + 4;
    }
    writeDoubleLE(value2, offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 8);
      view.setFloat64(0, value2, true);
      return offset + 8;
    }
    writeDoubleBE(value2, offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 8);
      view.setFloat64(0, value2, false);
      return offset + 8;
    }
    readUIntLE(offset, byteLength) {
      let val = 0;
      let mul = 1;
      for (let i22 = 0; i22 < byteLength; i22++) {
        val += this[offset + i22] * mul;
        mul *= 256;
      }
      return val;
    }
    readUintLE(offset, byteLength) {
      return this.readUIntLE(offset, byteLength);
    }
    readUIntBE(offset, byteLength) {
      let val = 0;
      let mul = 1;
      for (let i22 = byteLength - 1; i22 >= 0; i22--) {
        val += this[offset + i22] * mul;
        mul *= 256;
      }
      return val;
    }
    readUintBE(offset, byteLength) {
      return this.readUIntBE(offset, byteLength);
    }
    readIntLE(offset, byteLength) {
      let val = this.readUIntLE(offset, byteLength);
      const limit = Math.pow(2, byteLength * 8 - 1);
      if (val >= limit) {
        val -= Math.pow(2, byteLength * 8);
      }
      return val;
    }
    readIntBE(offset, byteLength) {
      let val = this.readUIntBE(offset, byteLength);
      const limit = Math.pow(2, byteLength * 8 - 1);
      if (val >= limit) {
        val -= Math.pow(2, byteLength * 8);
      }
      return val;
    }
    writeUIntLE(value2, offset, byteLength) {
      let val = value2;
      for (let i22 = 0; i22 < byteLength; i22++) {
        this[offset + i22] = val & 255;
        val = Math.floor(val / 256);
      }
      return offset + byteLength;
    }
    writeUintLE(value2, offset, byteLength) {
      return this.writeUIntLE(value2, offset, byteLength);
    }
    writeUIntBE(value2, offset, byteLength) {
      let val = value2;
      for (let i22 = byteLength - 1; i22 >= 0; i22--) {
        this[offset + i22] = val & 255;
        val = Math.floor(val / 256);
      }
      return offset + byteLength;
    }
    writeUintBE(value2, offset, byteLength) {
      return this.writeUIntBE(value2, offset, byteLength);
    }
    writeIntLE(value2, offset, byteLength) {
      let val = value2;
      if (val < 0) {
        val += Math.pow(2, byteLength * 8);
      }
      return this.writeUIntLE(val, offset, byteLength);
    }
    writeIntBE(value2, offset, byteLength) {
      let val = value2;
      if (val < 0) {
        val += Math.pow(2, byteLength * 8);
      }
      return this.writeUIntBE(val, offset, byteLength);
    }
    swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i22 = 0; i22 < len; i22 += 2) {
        const a = this[i22];
        this[i22] = this[i22 + 1];
        this[i22 + 1] = a;
      }
      return this;
    }
    swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i22 = 0; i22 < len; i22 += 4) {
        const a = this[i22];
        const b = this[i22 + 1];
        this[i22] = this[i22 + 3];
        this[i22 + 1] = this[i22 + 2];
        this[i22 + 2] = b;
        this[i22 + 3] = a;
      }
      return this;
    }
    swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i22 = 0; i22 < len; i22 += 8) {
        const a = this[i22];
        const b = this[i22 + 1];
        const c = this[i22 + 2];
        const d = this[i22 + 3];
        this[i22] = this[i22 + 7];
        this[i22 + 1] = this[i22 + 6];
        this[i22 + 2] = this[i22 + 5];
        this[i22 + 3] = this[i22 + 4];
        this[i22 + 4] = d;
        this[i22 + 5] = c;
        this[i22 + 6] = b;
        this[i22 + 7] = a;
      }
      return this;
    }
  };
  __publicField(_BufferPolyfill, "BYTES_PER_ELEMENT", 1);
  let BufferPolyfill = _BufferPolyfill;
  if (typeof globalThis.Buffer === "undefined") {
    globalThis.Buffer = BufferPolyfill;
  }
  Stream.pipeline = pipeline;
  Stream.finished = finished;
  Stream.promises = promises$2;
  stream = Object.freeze(Object.defineProperty({
    __proto__: null,
    Buffer: BufferPolyfill,
    Duplex,
    PassThrough,
    Readable,
    Stream,
    Transform,
    Writable,
    default: Stream,
    finished,
    pipeline,
    promises: promises$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  let Socket$1 = class Socket extends Duplex {
    constructor(options2) {
      super();
      __publicField(this, "_connecting", false);
      __publicField(this, "_connected", false);
      __publicField(this, "_destroyed", false);
      __publicField(this, "_remoteAddress", "");
      __publicField(this, "_remotePort", 0);
      __publicField(this, "_localAddress", "127.0.0.1");
      __publicField(this, "_localPort", 0);
      __publicField(this, "localAddress", "127.0.0.1");
      __publicField(this, "localPort", 0);
      __publicField(this, "remoteAddress");
      __publicField(this, "remotePort");
      __publicField(this, "remoteFamily");
      __publicField(this, "connecting", false);
      __publicField(this, "destroyed", false);
      __publicField(this, "readyState", "closed");
    }
    connect(portOrOptions, hostOrCallback, callback) {
      let port;
      let host = "127.0.0.1";
      let cb2;
      if (typeof portOrOptions === "number") {
        port = portOrOptions;
        if (typeof hostOrCallback === "string") {
          host = hostOrCallback;
          cb2 = callback;
        } else {
          cb2 = hostOrCallback;
        }
      } else {
        port = portOrOptions.port;
        host = portOrOptions.host || "127.0.0.1";
        cb2 = typeof hostOrCallback === "function" ? hostOrCallback : callback;
      }
      this._connecting = true;
      this.connecting = true;
      this._remoteAddress = host;
      this._remotePort = port;
      this.remoteAddress = host;
      this.remotePort = port;
      this.remoteFamily = "IPv4";
      this.readyState = "opening";
      queueMicrotask(() => {
        this._connecting = false;
        this._connected = true;
        this.connecting = false;
        this.readyState = "open";
        this.emit("connect");
        if (cb2)
          cb2();
      });
      return this;
    }
    address() {
      if (!this._connected)
        return null;
      return {
        address: this._localAddress,
        family: "IPv4",
        port: this._localPort
      };
    }
    setEncoding(encoding) {
      return this;
    }
    setTimeout(timeout, callback) {
      if (callback) {
        this.once("timeout", callback);
      }
      return this;
    }
    setNoDelay(noDelay) {
      return this;
    }
    setKeepAlive(enable, initialDelay) {
      return this;
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    destroy(error) {
      if (this._destroyed)
        return this;
      this._destroyed = true;
      this._connected = false;
      this.destroyed = true;
      this.readyState = "closed";
      if (error) {
        this.emit("error", error);
      }
      queueMicrotask(() => {
        this.emit("close", !!error);
      });
      return this;
    }
    _receiveData(data2) {
      const buffer2 = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
      this.push(buffer2);
    }
    _receiveEnd() {
      this.push(null);
    }
  };
  let Server$3 = class Server extends EventEmitter {
    constructor(optionsOrConnectionListener, connectionListener) {
      super();
      __publicField(this, "_listening", false);
      __publicField(this, "_address", null);
      __publicField(this, "_connections", /* @__PURE__ */ new Set());
      __publicField(this, "_maxConnections", Infinity);
      __publicField(this, "listening", false);
      __publicField(this, "maxConnections");
      let listener;
      if (typeof optionsOrConnectionListener === "function") {
        listener = optionsOrConnectionListener;
      } else {
        listener = connectionListener;
      }
      if (listener) {
        this.on("connection", listener);
      }
    }
    listen(portOrOptions, hostOrCallback, backlogOrCallback, callback) {
      let port = 0;
      let host = "0.0.0.0";
      let cb2;
      if (typeof portOrOptions === "number") {
        port = portOrOptions;
        if (typeof hostOrCallback === "string") {
          host = hostOrCallback;
          if (typeof backlogOrCallback === "function") {
            cb2 = backlogOrCallback;
          } else {
            cb2 = callback;
          }
        } else if (typeof hostOrCallback === "function") {
          cb2 = hostOrCallback;
        } else if (typeof hostOrCallback === "number") {
          cb2 = typeof backlogOrCallback === "function" ? backlogOrCallback : callback;
        } else {
          if (typeof backlogOrCallback === "function") {
            cb2 = backlogOrCallback;
          } else if (typeof callback === "function") {
            cb2 = callback;
          }
        }
      } else if (portOrOptions) {
        port = portOrOptions.port || 0;
        host = portOrOptions.host || "0.0.0.0";
        cb2 = typeof hostOrCallback === "function" ? hostOrCallback : callback;
      }
      if (port === 0) {
        port = 3e3 + Math.floor(Math.random() * 1e3);
      }
      this._address = {
        address: host,
        family: "IPv4",
        port
      };
      this._listening = true;
      this.listening = true;
      queueMicrotask(() => {
        this.emit("listening");
        if (cb2)
          cb2();
      });
      return this;
    }
    address() {
      return this._address;
    }
    close(callback) {
      this._listening = false;
      this.listening = false;
      for (const socket of this._connections) {
        socket.destroy();
      }
      this._connections.clear();
      queueMicrotask(() => {
        this.emit("close");
        if (callback)
          callback();
      });
      return this;
    }
    getConnections(callback) {
      callback(null, this._connections.size);
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    _handleConnection(socket) {
      if (!this._listening) {
        socket.destroy();
        return;
      }
      this._connections.add(socket);
      socket.on("close", () => {
        this._connections.delete(socket);
      });
      this.emit("connection", socket);
    }
  };
  function createServer$3(optionsOrConnectionListener, connectionListener) {
    return new Server$3(optionsOrConnectionListener, connectionListener);
  }
  function createConnection(portOrOptions, hostOrCallback, callback) {
    const socket = new Socket$1();
    return socket.connect(portOrOptions, hostOrCallback, callback);
  }
  const connect$2 = createConnection;
  function isIP(input) {
    if (/^(\d{1,3}\.){3}\d{1,3}$/.test(input)) {
      return 4;
    }
    if (/^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/.test(input)) {
      return 6;
    }
    return 0;
  }
  function isIPv4(input) {
    return isIP(input) === 4;
  }
  function isIPv6(input) {
    return isIP(input) === 6;
  }
  const net = {
    Socket: Socket$1,
    Server: Server$3,
    createServer: createServer$3,
    createConnection,
    connect: connect$2,
    isIP,
    isIPv4,
    isIPv6
  };
  netShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Server: Server$3,
    Socket: Socket$1,
    connect: connect$2,
    createConnection,
    createServer: createServer$3,
    default: net,
    isIP,
    isIPv4,
    isIPv6
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function randomBytes(size) {
    const array = new Uint8Array(size);
    crypto.getRandomValues(array);
    return BufferPolyfill.from(array);
  }
  function randomFillSync(buffer2, offset, size) {
    const start = offset || 0;
    const len = size !== void 0 ? size : buffer2.length - start;
    const view = new Uint8Array(buffer2.buffer, buffer2.byteOffset + start, len);
    crypto.getRandomValues(view);
    return buffer2;
  }
  function randomUUID() {
    return crypto.randomUUID();
  }
  function randomInt(min, max) {
    if (max === void 0) {
      max = min;
      min = 0;
    }
    const range2 = max - min;
    const array = new Uint32Array(1);
    crypto.getRandomValues(array);
    return min + array[0] % range2;
  }
  function getRandomValues(array) {
    return crypto.getRandomValues(array);
  }
  function createHash(algorithm) {
    return new Hash$2(algorithm);
  }
  let Hash$2 = class Hash {
    constructor(algorithm) {
      __publicField(this, "algorithm");
      __publicField(this, "data", []);
      this.algorithm = normalizeHashAlgorithm(algorithm);
    }
    update(data2, encoding) {
      let buffer2;
      if (typeof data2 === "string") {
        if (encoding === "base64") {
          buffer2 = BufferPolyfill.from(atob(data2));
        } else {
          buffer2 = BufferPolyfill.from(data2);
        }
      } else {
        buffer2 = data2;
      }
      this.data.push(buffer2);
      return this;
    }
    async digestAsync(encoding) {
      const combined = concatBuffers(this.data);
      const dataBuffer = new Uint8Array(combined).buffer;
      const hashBuffer = await crypto.subtle.digest(this.algorithm, dataBuffer);
      return encodeResult(new Uint8Array(hashBuffer), encoding);
    }
    digest(encoding) {
      const combined = concatBuffers(this.data);
      const hash = syncHash(combined, this.algorithm);
      return encodeResult(hash, encoding);
    }
  };
  function createHmac(algorithm, key) {
    return new Hmac(algorithm, key);
  }
  class Hmac {
    constructor(algorithm, key) {
      __publicField(this, "algorithm");
      __publicField(this, "key");
      __publicField(this, "data", []);
      this.algorithm = normalizeHashAlgorithm(algorithm);
      this.key = typeof key === "string" ? BufferPolyfill.from(key) : key;
    }
    update(data2, encoding) {
      const buffer2 = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
      this.data.push(buffer2);
      return this;
    }
    async digestAsync(encoding) {
      const combined = concatBuffers(this.data);
      const keyBuffer = new Uint8Array(this.key).buffer;
      const dataBuffer = new Uint8Array(combined).buffer;
      const cryptoKey = await crypto.subtle.importKey("raw", keyBuffer, {
        name: "HMAC",
        hash: this.algorithm
      }, false, [
        "sign"
      ]);
      const signature = await crypto.subtle.sign("HMAC", cryptoKey, dataBuffer);
      return encodeResult(new Uint8Array(signature), encoding);
    }
    digest(encoding) {
      const combined = concatBuffers(this.data);
      const hash = syncHmac(combined, this.key, this.algorithm);
      return encodeResult(hash, encoding);
    }
  }
  async function pbkdf2Async(password, salt, iterations, keylen, digest) {
    const passwordBuffer = typeof password === "string" ? BufferPolyfill.from(password) : password instanceof Uint8Array ? password : BufferPolyfill.from(password);
    const saltBuffer = typeof salt === "string" ? BufferPolyfill.from(salt) : salt instanceof Uint8Array ? salt : BufferPolyfill.from(salt);
    const passwordArrayBuffer = new Uint8Array(passwordBuffer).buffer;
    const saltArrayBuffer = new Uint8Array(saltBuffer).buffer;
    const key = await crypto.subtle.importKey("raw", passwordArrayBuffer, "PBKDF2", false, [
      "deriveBits"
    ]);
    const derivedBits = await crypto.subtle.deriveBits({
      name: "PBKDF2",
      salt: saltArrayBuffer,
      iterations,
      hash: normalizeHashAlgorithm(digest)
    }, key, keylen * 8);
    return BufferPolyfill.from(derivedBits);
  }
  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
    pbkdf2Async(password, salt, iterations, keylen, digest).then((key) => callback(null, key)).catch((err2) => callback(err2, BufferPolyfill.alloc(0)));
  }
  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
    const passwordBuffer = typeof password === "string" ? BufferPolyfill.from(password) : password;
    const saltBuffer = typeof salt === "string" ? BufferPolyfill.from(salt) : salt;
    const hashAlg = normalizeHashAlgorithm(digest);
    let hashLen;
    if (hashAlg.includes("512")) {
      hashLen = 64;
    } else if (hashAlg.includes("384")) {
      hashLen = 48;
    } else if (hashAlg.includes("1") || hashAlg === "SHA-1") {
      hashLen = 20;
    } else {
      hashLen = 32;
    }
    const numBlocks = Math.ceil(keylen / hashLen);
    const derivedKey = new Uint8Array(numBlocks * hashLen);
    for (let blockNum = 1; blockNum <= numBlocks; blockNum++) {
      const blockNumBuf = new Uint8Array(4);
      blockNumBuf[0] = blockNum >>> 24 & 255;
      blockNumBuf[1] = blockNum >>> 16 & 255;
      blockNumBuf[2] = blockNum >>> 8 & 255;
      blockNumBuf[3] = blockNum & 255;
      const saltWithBlock = new Uint8Array(saltBuffer.length + 4);
      saltWithBlock.set(saltBuffer);
      saltWithBlock.set(blockNumBuf, saltBuffer.length);
      let u = syncHmac(saltWithBlock, passwordBuffer, hashAlg);
      const block = new Uint8Array(u);
      for (let i22 = 1; i22 < iterations; i22++) {
        u = syncHmac(u, passwordBuffer, hashAlg);
        for (let j = 0; j < block.length; j++) {
          block[j] ^= u[j];
        }
      }
      derivedKey.set(block, (blockNum - 1) * hashLen);
    }
    return BufferPolyfill.from(derivedKey.slice(0, keylen));
  }
  function sign(algorithm, data2, key, callback) {
    const keyInfo = extractKeyInfo(key);
    const alg = algorithm || keyInfo.algorithm;
    if (!alg) {
      const error = new Error("Algorithm must be specified");
      if (callback) {
        callback(error, null);
        return;
      }
      throw error;
    }
    if (callback) {
      signAsync(alg, data2, keyInfo).then((sig) => callback(null, sig)).catch((err2) => callback(err2, null));
      return;
    }
    const result = signSync(alg, data2, keyInfo);
    return result;
  }
  function verify(algorithm, data2, key, signature, callback) {
    const keyInfo = extractKeyInfo(key);
    const alg = algorithm || keyInfo.algorithm;
    if (!alg) {
      const error = new Error("Algorithm must be specified");
      if (callback) {
        callback(error, false);
        return;
      }
      throw error;
    }
    if (callback) {
      verifyAsync(alg, data2, keyInfo, signature).then((result) => callback(null, result)).catch((err2) => callback(err2, false));
      return;
    }
    return verifySync(alg, data2, keyInfo, signature);
  }
  function createSign(algorithm) {
    return new Sign(algorithm);
  }
  function createVerify(algorithm) {
    return new Verify(algorithm);
  }
  class Sign extends EventEmitter {
    constructor(algorithm) {
      super();
      __publicField(this, "algorithm");
      __publicField(this, "data", []);
      this.algorithm = algorithm;
    }
    update(data2, encoding) {
      const buffer2 = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
      this.data.push(buffer2);
      return this;
    }
    sign(privateKey, outputEncoding) {
      const combined = concatBuffers(this.data);
      const keyInfo = extractKeyInfo(privateKey);
      const signature = signSync(this.algorithm, combined, keyInfo);
      if (outputEncoding === "base64") {
        return btoa(String.fromCharCode(...signature));
      }
      if (outputEncoding === "hex") {
        return Array.from(signature).map((b) => b.toString(16).padStart(2, "0")).join("");
      }
      return signature;
    }
  }
  class Verify extends EventEmitter {
    constructor(algorithm) {
      super();
      __publicField(this, "algorithm");
      __publicField(this, "data", []);
      this.algorithm = algorithm;
    }
    update(data2, encoding) {
      const buffer2 = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
      this.data.push(buffer2);
      return this;
    }
    verify(publicKey, signature, signatureEncoding) {
      const combined = concatBuffers(this.data);
      const keyInfo = extractKeyInfo(publicKey);
      let sig;
      if (typeof signature === "string") {
        if (signatureEncoding === "base64") {
          sig = BufferPolyfill.from(atob(signature));
        } else if (signatureEncoding === "hex") {
          sig = BufferPolyfill.from(signature.match(/.{2}/g).map((byte) => parseInt(byte, 16)));
        } else {
          sig = BufferPolyfill.from(signature);
        }
      } else {
        sig = signature;
      }
      return verifySync(this.algorithm, combined, keyInfo, sig);
    }
  }
  class KeyObject {
    constructor(type2, keyData, algorithm) {
      __publicField(this, "_keyData");
      __publicField(this, "_type");
      __publicField(this, "_algorithm");
      this._type = type2;
      this._keyData = keyData;
      this._algorithm = algorithm;
    }
    get type() {
      return this._type;
    }
    get asymmetricKeyType() {
      var _a22, _b22, _c22, _d2;
      if (this._type === "secret")
        return void 0;
      if ((_a22 = this._algorithm) == null ? void 0 : _a22.includes("RSA"))
        return "rsa";
      if (((_b22 = this._algorithm) == null ? void 0 : _b22.includes("EC")) || ((_c22 = this._algorithm) == null ? void 0 : _c22.includes("ES")))
        return "ec";
      if ((_d2 = this._algorithm) == null ? void 0 : _d2.includes("Ed"))
        return "ed25519";
      return void 0;
    }
    get symmetricKeySize() {
      if (this._type !== "secret")
        return void 0;
      if (this._keyData instanceof Uint8Array) {
        return this._keyData.length * 8;
      }
      return void 0;
    }
    export(options2) {
      if (this._keyData instanceof Uint8Array) {
        return BufferPolyfill.from(this._keyData);
      }
      throw new Error("Cannot export CryptoKey synchronously");
    }
  }
  function createSecretKey(key, encoding) {
    const keyBuffer = typeof key === "string" ? BufferPolyfill.from(key, encoding) : key;
    return new KeyObject("secret", keyBuffer);
  }
  function createPublicKey(key) {
    const keyInfo = extractKeyInfo(key);
    return new KeyObject("public", keyInfo.keyData, keyInfo.algorithm);
  }
  function createPrivateKey(key) {
    const keyInfo = extractKeyInfo(key);
    return new KeyObject("private", keyInfo.keyData, keyInfo.algorithm);
  }
  function timingSafeEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    let result = 0;
    for (let i22 = 0; i22 < a.length; i22++) {
      result |= a[i22] ^ b[i22];
    }
    return result === 0;
  }
  function getCiphers$1() {
    return [
      "aes-128-cbc",
      "aes-256-cbc",
      "aes-128-gcm",
      "aes-256-gcm"
    ];
  }
  function getHashes() {
    return [
      "sha1",
      "sha256",
      "sha384",
      "sha512"
    ];
  }
  const constants$5 = {
    SSL_OP_ALL: 0,
    RSA_PKCS1_PADDING: 1,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_PKCS1_PSS_PADDING: 6
  };
  function normalizeHashAlgorithm(alg) {
    const normalized = alg.toUpperCase().replace(/[^A-Z0-9]/g, "");
    switch (normalized) {
      case "SHA1":
        return "SHA-1";
      case "SHA256":
        return "SHA-256";
      case "SHA384":
        return "SHA-384";
      case "SHA512":
        return "SHA-512";
      case "MD5":
        return "MD5";
      default:
        return alg;
    }
  }
  function getWebCryptoAlgorithm(nodeAlgorithm) {
    var _a22, _b22, _c22, _d2;
    const alg = nodeAlgorithm.toUpperCase().replace(/[^A-Z0-9]/g, "");
    if (alg.includes("RSA")) {
      if (alg.includes("PSS")) {
        const hash2 = ((_a22 = alg.match(/SHA(\d+)/)) == null ? void 0 : _a22[0]) || "SHA-256";
        return {
          name: "RSA-PSS",
          hash: `SHA-${hash2.replace("SHA", "")}`
        };
      }
      const hash = ((_b22 = alg.match(/SHA(\d+)/)) == null ? void 0 : _b22[0]) || "SHA-256";
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: `SHA-${hash.replace("SHA", "")}`
      };
    }
    if (alg.startsWith("ES") || alg.includes("ECDSA")) {
      const bits = ((_c22 = alg.match(/\d+/)) == null ? void 0 : _c22[0]) || "256";
      const hash = bits === "512" ? "SHA-512" : bits === "384" ? "SHA-384" : "SHA-256";
      return {
        name: "ECDSA",
        hash
      };
    }
    if (alg.includes("ED25519") || alg === "EDDSA") {
      return {
        name: "Ed25519"
      };
    }
    if (alg.includes("HS") || alg.includes("HMAC")) {
      const bits = ((_d2 = alg.match(/\d+/)) == null ? void 0 : _d2[0]) || "256";
      return {
        name: "HMAC",
        hash: `SHA-${bits}`
      };
    }
    return {
      name: "RSASSA-PKCS1-v1_5",
      hash: "SHA-256"
    };
  }
  function extractKeyInfo(key) {
    if (key instanceof KeyObject) {
      return {
        keyData: key._keyData,
        algorithm: key._algorithm,
        type: key._type,
        format: "raw"
      };
    }
    if (typeof key === "object" && "key" in key) {
      return extractKeyInfo(key.key);
    }
    const keyStr = typeof key === "string" ? key : key.toString();
    if (keyStr.includes("-----BEGIN")) {
      const isPrivate = keyStr.includes("PRIVATE");
      const isPublic = keyStr.includes("PUBLIC");
      const base642 = keyStr.replace(/-----BEGIN [^-]+-----/, "").replace(/-----END [^-]+-----/, "").replace(/\s/g, "");
      const keyData2 = BufferPolyfill.from(atob(base642));
      let algorithm;
      if (keyStr.includes("RSA"))
        algorithm = "RSA-SHA256";
      else if (keyStr.includes("EC"))
        algorithm = "ES256";
      else if (keyStr.includes("ED25519"))
        algorithm = "Ed25519";
      return {
        keyData: keyData2,
        algorithm,
        type: isPrivate ? "private" : isPublic ? "public" : "secret",
        format: "pem"
      };
    }
    const keyData = typeof key === "string" ? BufferPolyfill.from(key) : key;
    return {
      keyData,
      type: "secret",
      format: "raw"
    };
  }
  function concatBuffers(buffers) {
    const totalLength = buffers.reduce((acc, arr) => acc + arr.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const buf of buffers) {
      result.set(buf, offset);
      offset += buf.length;
    }
    return result;
  }
  function encodeResult(data2, encoding) {
    if (encoding === "hex") {
      return Array.from(data2).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    if (encoding === "base64") {
      return btoa(String.fromCharCode(...data2));
    }
    return BufferPolyfill.from(data2);
  }
  function syncHash(data2, algorithm) {
    let size;
    if (algorithm.includes("512")) {
      size = 64;
    } else if (algorithm.includes("384")) {
      size = 48;
    } else if (algorithm.includes("1") || algorithm === "SHA-1") {
      size = 20;
    } else {
      size = 32;
    }
    const result = new Uint8Array(size);
    let h12 = 3735928559;
    let h22 = 1103547991;
    for (let i22 = 0; i22 < data2.length; i22++) {
      h12 = Math.imul(h12 ^ data2[i22], 2654435761);
      h22 = Math.imul(h22 ^ data2[i22], 1597334677);
    }
    h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507) ^ Math.imul(h22 ^ h22 >>> 13, 3266489909);
    h22 = Math.imul(h22 ^ h22 >>> 16, 2246822507) ^ Math.imul(h12 ^ h12 >>> 13, 3266489909);
    for (let i22 = 0; i22 < size; i22++) {
      const mix2 = i22 < size / 2 ? h12 : h22;
      result[i22] = mix2 >>> i22 % 4 * 8 & 255;
      h12 = Math.imul(h12, 1103515245) + 12345;
      h22 = Math.imul(h22, 1103515245) + 12345;
    }
    return result;
  }
  function syncHmac(data2, key, algorithm) {
    const combined = new Uint8Array(key.length + data2.length);
    combined.set(key, 0);
    combined.set(data2, key.length);
    return syncHash(combined, algorithm);
  }
  async function signAsync(algorithm, data2, keyInfo) {
    const webCryptoAlg = getWebCryptoAlgorithm(algorithm);
    try {
      const cryptoKey = await importKey(keyInfo, webCryptoAlg, [
        "sign"
      ]);
      const signatureAlg = webCryptoAlg.hash ? {
        name: webCryptoAlg.name,
        hash: webCryptoAlg.hash
      } : {
        name: webCryptoAlg.name
      };
      const dataBuffer = new Uint8Array(data2).buffer;
      const signature = await crypto.subtle.sign(signatureAlg, cryptoKey, dataBuffer);
      return BufferPolyfill.from(signature);
    } catch (error) {
      console.warn("WebCrypto sign failed, using fallback:", error);
      return signSync(algorithm, data2, keyInfo);
    }
  }
  async function verifyAsync(algorithm, data2, keyInfo, signature) {
    const webCryptoAlg = getWebCryptoAlgorithm(algorithm);
    try {
      const cryptoKey = await importKey(keyInfo, webCryptoAlg, [
        "verify"
      ]);
      const verifyAlg = webCryptoAlg.hash ? {
        name: webCryptoAlg.name,
        hash: webCryptoAlg.hash
      } : {
        name: webCryptoAlg.name
      };
      const sigBuffer = new Uint8Array(signature).buffer;
      const dataBuffer = new Uint8Array(data2).buffer;
      return await crypto.subtle.verify(verifyAlg, cryptoKey, sigBuffer, dataBuffer);
    } catch (error) {
      console.warn("WebCrypto verify failed, using fallback:", error);
      return verifySync(algorithm, data2, keyInfo, signature);
    }
  }
  function signSync(algorithm, data2, keyInfo) {
    const keyData = keyInfo.keyData instanceof Uint8Array ? keyInfo.keyData : new Uint8Array(0);
    const combined = new Uint8Array(keyData.length + data2.length);
    combined.set(keyData, 0);
    combined.set(data2, keyData.length);
    const hash = syncHash(combined, algorithm);
    return BufferPolyfill.from(hash);
  }
  function verifySync(algorithm, data2, keyInfo, signature) {
    const expectedSig = signSync(algorithm, data2, keyInfo);
    return timingSafeEqual(BufferPolyfill.from(signature), expectedSig);
  }
  async function importKey(keyInfo, algorithm, usages) {
    if (keyInfo.keyData instanceof CryptoKey) {
      return keyInfo.keyData;
    }
    const keyData = keyInfo.keyData;
    const keyBuffer = new Uint8Array(keyData).buffer;
    if (keyInfo.format === "pem") {
      const format2 = keyInfo.type === "private" ? "pkcs8" : "spki";
      const importAlg = algorithm.name === "ECDSA" ? {
        name: "ECDSA",
        namedCurve: "P-256"
      } : algorithm.name === "Ed25519" ? {
        name: "Ed25519"
      } : {
        name: algorithm.name,
        hash: algorithm.hash || "SHA-256"
      };
      return await crypto.subtle.importKey(format2, keyBuffer, importAlg, true, usages);
    }
    if (keyInfo.type === "secret") {
      return await crypto.subtle.importKey("raw", keyBuffer, {
        name: algorithm.name,
        hash: algorithm.hash
      }, true, usages);
    }
    throw new Error(`Unsupported key format: ${keyInfo.format}`);
  }
  const crypto$1 = {
    randomBytes,
    randomFillSync,
    randomUUID,
    randomInt,
    getRandomValues,
    createHash,
    createHmac,
    createSign,
    createVerify,
    sign,
    verify,
    pbkdf2,
    pbkdf2Sync,
    timingSafeEqual,
    getCiphers: getCiphers$1,
    getHashes,
    constants: constants$5,
    KeyObject,
    createSecretKey,
    createPublicKey,
    createPrivateKey
  };
  const cryptoShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    KeyObject,
    constants: constants$5,
    createHash,
    createHmac,
    createPrivateKey,
    createPublicKey,
    createSecretKey,
    createSign,
    createVerify,
    default: crypto$1,
    getCiphers: getCiphers$1,
    getHashes,
    getRandomValues,
    pbkdf2,
    pbkdf2Sync,
    randomBytes,
    randomFillSync,
    randomInt,
    randomUUID,
    sign,
    timingSafeEqual,
    verify
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const _isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  const _BrowserWebSocket = _isBrowser && typeof globalThis.WebSocket === "function" ? globalThis.WebSocket : null;
  class IncomingMessage extends Readable {
    constructor(socket) {
      super();
      __publicField(this, "httpVersion", "1.1");
      __publicField(this, "httpVersionMajor", 1);
      __publicField(this, "httpVersionMinor", 1);
      __publicField(this, "complete", false);
      __publicField(this, "headers", {});
      __publicField(this, "rawHeaders", []);
      __publicField(this, "trailers", {});
      __publicField(this, "rawTrailers", []);
      __publicField(this, "method");
      __publicField(this, "url");
      __publicField(this, "statusCode");
      __publicField(this, "statusMessage");
      __publicField(this, "socket");
      __publicField(this, "_body", null);
      this.socket = socket || new Socket$1();
    }
    setTimeout(msecs, callback) {
      if (callback) {
        this.once("timeout", callback);
      }
      return this;
    }
    destroy(error) {
      super.destroy(error);
      return this;
    }
    _setBody(body) {
      if (body === null) {
        this._body = null;
      } else {
        this._body = typeof body === "string" ? BufferPolyfill.from(body) : body;
      }
      if (this._body) {
        this.push(this._body);
      }
      this.push(null);
      this.complete = true;
    }
    static fromRequest(method, url2, headers, body) {
      const msg = new IncomingMessage();
      msg.method = method;
      msg.url = url2;
      msg.headers = {
        ...headers
      };
      for (const [key, value2] of Object.entries(headers)) {
        msg.rawHeaders.push(key, value2);
      }
      if (body) {
        msg._setBody(body);
      } else {
        msg.push(null);
        msg.complete = true;
      }
      return msg;
    }
  }
  class ServerResponse extends Writable {
    constructor(req) {
      super();
      __publicField(this, "statusCode", 200);
      __publicField(this, "statusMessage", "OK");
      __publicField(this, "headersSent", false);
      __publicField(this, "finished", false);
      __publicField(this, "sendDate", true);
      __publicField(this, "socket");
      __publicField(this, "_headers", /* @__PURE__ */ new Map());
      __publicField(this, "_body", []);
      __publicField(this, "_resolve");
      this.socket = req.socket;
    }
    _setResolver(resolve2) {
      this._resolve = resolve2;
    }
    setHeader(name2, value2) {
      if (this.headersSent) {
        throw new Error("Cannot set headers after they are sent");
      }
      this._headers.set(name2.toLowerCase(), String(value2));
      return this;
    }
    getHeader(name2) {
      return this._headers.get(name2.toLowerCase());
    }
    getHeaders() {
      const headers = {};
      for (const [key, value2] of this._headers) {
        headers[key] = value2;
      }
      return headers;
    }
    getHeaderNames() {
      return [
        ...this._headers.keys()
      ];
    }
    hasHeader(name2) {
      return this._headers.has(name2.toLowerCase());
    }
    removeHeader(name2) {
      if (this.headersSent) {
        throw new Error("Cannot remove headers after they are sent");
      }
      this._headers.delete(name2.toLowerCase());
    }
    writeHead(statusCode, statusMessageOrHeaders, headers) {
      this.statusCode = statusCode;
      if (typeof statusMessageOrHeaders === "string") {
        this.statusMessage = statusMessageOrHeaders;
        if (headers) {
          for (const [key, value2] of Object.entries(headers)) {
            this.setHeader(key, value2);
          }
        }
      } else if (statusMessageOrHeaders) {
        for (const [key, value2] of Object.entries(statusMessageOrHeaders)) {
          this.setHeader(key, value2);
        }
      }
      return this;
    }
    write(chunk, encodingOrCallback, callback) {
      this.headersSent = true;
      const buffer2 = typeof chunk === "string" ? BufferPolyfill.from(chunk) : chunk;
      this._body.push(buffer2);
      const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      if (cb2) {
        queueMicrotask(() => cb2(null));
      }
      return true;
    }
    end(chunkOrCallback, encodingOrCallback, callback) {
      if (typeof chunkOrCallback === "function") {
        callback = chunkOrCallback;
      } else if (chunkOrCallback !== void 0) {
        this.write(chunkOrCallback);
      }
      if (typeof encodingOrCallback === "function") {
        callback = encodingOrCallback;
      }
      this.headersSent = true;
      this.finished = true;
      if (this._resolve) {
        const headers = {};
        for (const [key, value2] of this._headers) {
          headers[key] = Array.isArray(value2) ? value2.join(", ") : value2;
        }
        this._resolve({
          statusCode: this.statusCode,
          statusMessage: this.statusMessage,
          headers,
          body: BufferPolyfill.concat(this._body)
        });
      }
      queueMicrotask(() => {
        this.emit("finish");
        if (callback)
          callback();
      });
      return this;
    }
    send(data2) {
      if (typeof data2 === "object" && !BufferPolyfill.isBuffer(data2)) {
        this.setHeader("Content-Type", "application/json");
        data2 = JSON.stringify(data2);
      }
      if (!this.hasHeader("Content-Type")) {
        this.setHeader("Content-Type", "text/html");
      }
      this.write(typeof data2 === "string" ? data2 : data2);
      return this.end();
    }
    json(data2) {
      this.setHeader("Content-Type", "application/json");
      return this.end(JSON.stringify(data2));
    }
    status(code2) {
      this.statusCode = code2;
      return this;
    }
    redirect(urlOrStatus, url2) {
      if (typeof urlOrStatus === "number") {
        this.statusCode = urlOrStatus;
        this.setHeader("Location", url2);
      } else {
        this.statusCode = 302;
        this.setHeader("Location", urlOrStatus);
      }
      this.end();
    }
    _getBody() {
      return BufferPolyfill.concat(this._body);
    }
    _getBodyAsString() {
      return this._getBody().toString("utf8");
    }
  }
  let Server$2 = class Server extends EventEmitter {
    constructor(requestListener) {
      super();
      __publicField(this, "_netServer");
      __publicField(this, "_requestListener");
      __publicField(this, "_pendingRequests", /* @__PURE__ */ new Map());
      __publicField(this, "listening", false);
      __publicField(this, "maxHeadersCount", null);
      __publicField(this, "timeout", 0);
      __publicField(this, "keepAliveTimeout", 5e3);
      __publicField(this, "headersTimeout", 6e4);
      __publicField(this, "requestTimeout", 0);
      this._requestListener = requestListener;
      this._netServer = new Server$3();
      this._netServer.on("listening", () => {
        this.listening = true;
        this.emit("listening");
      });
      this._netServer.on("close", () => {
        this.listening = false;
        this.emit("close");
      });
      this._netServer.on("error", (err2) => {
        this.emit("error", err2);
      });
    }
    listen(portOrOptions, hostOrCallback, callback) {
      let port;
      let host;
      let cb2;
      if (typeof portOrOptions === "number") {
        port = portOrOptions;
        if (typeof hostOrCallback === "string") {
          host = hostOrCallback;
          cb2 = callback;
        } else {
          cb2 = hostOrCallback;
        }
      } else if (portOrOptions) {
        port = portOrOptions.port;
        host = portOrOptions.host;
        cb2 = typeof hostOrCallback === "function" ? hostOrCallback : callback;
      }
      const originalCb = cb2;
      const self = this;
      cb2 = function() {
        const addr = self._netServer.address();
        if (addr) {
          _registerServer(addr.port, self);
        }
        if (originalCb)
          originalCb();
      };
      this._netServer.listen(port, host, cb2);
      return this;
    }
    close(callback) {
      const addr = this._netServer.address();
      if (addr) {
        _unregisterServer(addr.port);
      }
      this._netServer.close(callback);
      return this;
    }
    address() {
      return this._netServer.address();
    }
    setTimeout(msecs, callback) {
      this.timeout = msecs || 0;
      if (callback) {
        this.on("timeout", callback);
      }
      return this;
    }
    ref() {
      this._netServer.ref();
      return this;
    }
    unref() {
      this._netServer.unref();
      return this;
    }
    async handleRequest(method, url2, headers, body) {
      return new Promise((resolve2, reject) => {
        const req = IncomingMessage.fromRequest(method, url2, headers, body);
        const res = new ServerResponse(req);
        res._setResolver(resolve2);
        const timeoutId = this.timeout ? setTimeout(() => {
          reject(new Error("Request timeout"));
        }, this.timeout) : null;
        res.on("finish", () => {
          if (timeoutId)
            clearTimeout(timeoutId);
        });
        try {
          this.emit("request", req, res);
          if (this._requestListener) {
            this._requestListener(req, res);
          }
        } catch (error) {
          if (timeoutId)
            clearTimeout(timeoutId);
          reject(error);
        }
      });
    }
  };
  function createServer$2(requestListener) {
    return new Server$2(requestListener);
  }
  const STATUS_CODES = {
    100: "Continue",
    101: "Switching Protocols",
    200: "OK",
    201: "Created",
    202: "Accepted",
    204: "No Content",
    301: "Moved Permanently",
    302: "Found",
    304: "Not Modified",
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    408: "Request Timeout",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable"
  };
  const METHODS = [
    "GET",
    "POST",
    "PUT",
    "DELETE",
    "PATCH",
    "HEAD",
    "OPTIONS",
    "CONNECT",
    "TRACE"
  ];
  function getCorsProxy() {
    if (typeof localStorage !== "undefined") {
      return localStorage.getItem("__corsProxyUrl") || null;
    }
    return null;
  }
  class ClientRequest extends Writable {
    constructor(options2, protocol = "http") {
      super();
      __publicField(this, "method");
      __publicField(this, "path");
      __publicField(this, "headers");
      __publicField(this, "_options");
      __publicField(this, "_protocol");
      __publicField(this, "_bodyChunks", []);
      __publicField(this, "_aborted", false);
      __publicField(this, "_timeout", null);
      __publicField(this, "_timeoutId", null);
      __publicField(this, "_requestEnded", false);
      this._options = options2;
      this._protocol = protocol;
      this.method = options2.method || "GET";
      this.path = options2.path || "/";
      this.headers = {};
      if (options2.headers) {
        for (const [key, value2] of Object.entries(options2.headers)) {
          this.headers[key.toLowerCase()] = Array.isArray(value2) ? value2.join(", ") : value2;
        }
      }
    }
    setHeader(name2, value2) {
      this.headers[name2.toLowerCase()] = value2;
    }
    getHeader(name2) {
      return this.headers[name2.toLowerCase()];
    }
    removeHeader(name2) {
      delete this.headers[name2.toLowerCase()];
    }
    write(chunk, encodingOrCallback, callback) {
      const buffer2 = typeof chunk === "string" ? BufferPolyfill.from(chunk) : chunk;
      this._bodyChunks.push(buffer2);
      const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      if (cb2) {
        queueMicrotask(() => cb2(null));
      }
      return true;
    }
    end(dataOrCallback, encodingOrCallback, callback) {
      if (this._requestEnded)
        return this;
      this._requestEnded = true;
      let finalCallback = callback;
      if (typeof dataOrCallback === "function") {
        finalCallback = dataOrCallback;
      } else if (dataOrCallback !== void 0) {
        this.write(dataOrCallback);
      }
      if (typeof encodingOrCallback === "function") {
        finalCallback = encodingOrCallback;
      }
      this._performRequest().then(() => {
        if (finalCallback)
          finalCallback();
      }).catch((error) => {
        this.emit("error", error);
      });
      return this;
    }
    abort() {
      this._aborted = true;
      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
      }
      this.emit("abort");
    }
    setTimeout(ms2, callback) {
      this._timeout = ms2;
      if (callback) {
        this.once("timeout", callback);
      }
      return this;
    }
    async _performRequest() {
      var _a22;
      if (this._aborted)
        return;
      try {
        const protocol = this._protocol === "https" ? "https:" : "http:";
        let hostname2 = this._options.hostname || "";
        let port = this._options.port ? `:${this._options.port}` : "";
        if (!hostname2 && this._options.host) {
          const hostParts = this._options.host.split(":");
          hostname2 = hostParts[0];
          if (!port && hostParts[1]) {
            port = `:${hostParts[1]}`;
          }
        }
        if (!hostname2)
          hostname2 = "localhost";
        const path22 = this._options.path || "/";
        const url2 = `${protocol}//${hostname2}${port}${path22}`;
        if (((_a22 = this.headers["upgrade"]) == null ? void 0 : _a22.toLowerCase()) === "websocket") {
          this._handleWebSocketUpgrade(url2);
          return;
        }
        const corsProxy = getCorsProxy();
        const fetchUrl = corsProxy ? corsProxy + encodeURIComponent(url2) : url2;
        const fetchOptions = {
          method: this.method,
          headers: this.headers
        };
        if (this._bodyChunks.length > 0 && this.method !== "GET" && this.method !== "HEAD") {
          fetchOptions.body = BufferPolyfill.concat(this._bodyChunks);
        }
        const controller = new AbortController();
        fetchOptions.signal = controller.signal;
        if (this._timeout) {
          this._timeoutId = setTimeout(() => {
            controller.abort();
            this.emit("timeout");
          }, this._timeout);
        }
        const response = await fetch(fetchUrl, fetchOptions);
        if (this._timeoutId) {
          clearTimeout(this._timeoutId);
          this._timeoutId = null;
        }
        if (this._aborted)
          return;
        const incomingMessage = await this._responseToIncomingMessage(response);
        this.emit("response", incomingMessage);
      } catch (error) {
        if (this._timeoutId) {
          clearTimeout(this._timeoutId);
        }
        if (this._aborted)
          return;
        if (error instanceof Error && error.name === "AbortError") {
          return;
        }
        this.emit("error", error);
      }
    }
    async _responseToIncomingMessage(response) {
      const msg = new IncomingMessage();
      msg.statusCode = response.status;
      msg.statusMessage = response.statusText || STATUS_CODES[response.status] || "";
      response.headers.forEach((value2, key) => {
        msg.headers[key.toLowerCase()] = value2;
        msg.rawHeaders.push(key, value2);
      });
      const body = await response.arrayBuffer();
      msg._setBody(BufferPolyfill.from(body));
      return msg;
    }
    _handleWebSocketUpgrade(url2) {
      const wsUrl = url2.replace(/^https:/, "wss:").replace(/^http:/, "ws:");
      const wsKey = this.headers["sec-websocket-key"] || "";
      const NativeWS = _BrowserWebSocket;
      if (!NativeWS) {
        setTimeout(() => {
          this.emit("error", new TypeError("Failed to fetch"));
        }, 0);
        return;
      }
      const GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
      const acceptValue = createHash("sha1").update(wsKey + GUID).digest("base64");
      let nativeWs;
      try {
        nativeWs = new NativeWS(wsUrl);
        nativeWs.binaryType = "arraybuffer";
      } catch (e11) {
        setTimeout(() => {
          this.emit("error", e11 instanceof Error ? e11 : new Error(String(e11)));
        }, 0);
        return;
      }
      const socket = new Socket$1();
      if (typeof socket.cork !== "function")
        socket.cork = () => {
        };
      if (typeof socket.uncork !== "function")
        socket.uncork = () => {
        };
      socket._readableState = {
        endEmitted: false
      };
      socket._writableState = {
        finished: false,
        errorEmitted: false
      };
      let writeBuffer = new Uint8Array(0);
      socket.write = (chunk, encodingOrCallback, callback) => {
        const data2 = typeof chunk === "string" ? BufferPolyfill.from(chunk) : new Uint8Array(chunk);
        const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
        const newBuf = new Uint8Array(writeBuffer.length + data2.length);
        newBuf.set(writeBuffer, 0);
        newBuf.set(data2, writeBuffer.length);
        writeBuffer = newBuf;
        while (writeBuffer.length >= 2) {
          const parsed = _parseWsFrame(writeBuffer);
          if (!parsed)
            break;
          const { opcode, payload, totalLength } = parsed;
          writeBuffer = writeBuffer.slice(totalLength);
          if (nativeWs.readyState !== NativeWS.OPEN)
            continue;
          if (opcode === 8) {
            nativeWs.close();
          } else if (opcode === 9) {
            nativeWs.send(payload);
          } else if (opcode === 10)
            ;
          else if (opcode === 1) {
            const text = new TextDecoder().decode(payload);
            nativeWs.send(text);
          } else if (opcode === 2) {
            nativeWs.send(payload);
          }
        }
        if (cb2)
          queueMicrotask(() => cb2(null));
        return true;
      };
      nativeWs.onopen = () => {
        const response = new IncomingMessage(socket);
        response.statusCode = 101;
        response.statusMessage = "Switching Protocols";
        response.headers = {
          "upgrade": "websocket",
          "connection": "Upgrade",
          "sec-websocket-accept": acceptValue
        };
        response.complete = true;
        response.push(null);
        this.emit("upgrade", response, socket, BufferPolyfill.alloc(0));
      };
      nativeWs.onmessage = (event) => {
        let payload;
        let opcode;
        if (typeof event.data === "string") {
          payload = new TextEncoder().encode(event.data);
          opcode = 1;
        } else if (event.data instanceof ArrayBuffer) {
          payload = new Uint8Array(event.data);
          opcode = 2;
        } else {
          return;
        }
        const frame = _createWsFrame(opcode, payload, false);
        socket._receiveData(BufferPolyfill.from(frame));
      };
      nativeWs.onclose = (event) => {
        const code2 = event.code || 1e3;
        const closePayload = new Uint8Array(2);
        closePayload[0] = code2 >> 8 & 255;
        closePayload[1] = code2 & 255;
        const frame = _createWsFrame(8, closePayload, false);
        socket._receiveData(BufferPolyfill.from(frame));
        setTimeout(() => {
          socket._readableState.endEmitted = true;
          socket._receiveEnd();
          socket.emit("close", false);
        }, 10);
      };
      nativeWs.onerror = () => {
        socket.emit("error", new Error("WebSocket connection error"));
        socket.destroy();
      };
      const origDestroy = socket.destroy.bind(socket);
      socket.destroy = (error) => {
        if (nativeWs.readyState === NativeWS.OPEN || nativeWs.readyState === NativeWS.CONNECTING) {
          nativeWs.close();
        }
        return origDestroy(error);
      };
    }
  }
  function parseRequestArgs(urlOrOptions, optionsOrCallback, callback) {
    let options2;
    let cb2 = callback;
    if (typeof urlOrOptions === "string" || urlOrOptions instanceof URL) {
      const parsed = new URL(urlOrOptions.toString());
      options2 = {
        hostname: parsed.hostname,
        port: parsed.port ? parseInt(parsed.port) : void 0,
        path: parsed.pathname + parsed.search,
        method: "GET"
      };
      if (typeof optionsOrCallback === "function") {
        cb2 = optionsOrCallback;
      } else if (optionsOrCallback) {
        options2 = {
          ...options2,
          ...optionsOrCallback
        };
      }
    } else {
      options2 = urlOrOptions;
      if (typeof optionsOrCallback === "function") {
        cb2 = optionsOrCallback;
      }
    }
    return {
      options: options2,
      callback: cb2
    };
  }
  function request$1(urlOrOptions, optionsOrCallback, callback) {
    const { options: options2, callback: cb2 } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
    const req = new ClientRequest(options2, "http");
    if (cb2) {
      req.once("response", cb2);
    }
    return req;
  }
  function get$1(urlOrOptions, optionsOrCallback, callback) {
    const { options: options2, callback: cb2 } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
    const req = new ClientRequest({
      ...options2,
      method: "GET"
    }, "http");
    if (cb2) {
      req.once("response", cb2);
    }
    req.end();
    return req;
  }
  function _createClientRequest(urlOrOptions, optionsOrCallback, callback, protocol) {
    const { options: options2, callback: cb2 } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
    const req = new ClientRequest(options2, protocol);
    if (cb2) {
      req.once("response", cb2);
    }
    return req;
  }
  const serverRegistry = /* @__PURE__ */ new Map();
  let onServerListenCallback = null;
  let onServerCloseCallback = null;
  function _registerServer(port, server) {
    serverRegistry.set(port, server);
    if (onServerListenCallback) {
      onServerListenCallback(port, server);
    }
  }
  function _unregisterServer(port) {
    serverRegistry.delete(port);
    if (onServerCloseCallback) {
      onServerCloseCallback(port);
    }
  }
  function getServer(port) {
    return serverRegistry.get(port);
  }
  function getAllServers() {
    return new Map(serverRegistry);
  }
  function setServerListenCallback(callback) {
    onServerListenCallback = callback;
  }
  function setServerCloseCallback(callback) {
    onServerCloseCallback = callback;
  }
  class Agent extends EventEmitter {
    constructor(opts) {
      super();
      __publicField(this, "maxSockets");
      __publicField(this, "maxFreeSockets");
      __publicField(this, "maxTotalSockets");
      __publicField(this, "sockets");
      __publicField(this, "freeSockets");
      __publicField(this, "requests");
      __publicField(this, "options");
      this.options = opts || {};
      this.maxSockets = (opts == null ? void 0 : opts.maxSockets) ?? Infinity;
      this.maxFreeSockets = (opts == null ? void 0 : opts.maxFreeSockets) ?? 256;
      this.maxTotalSockets = (opts == null ? void 0 : opts.maxTotalSockets) ?? Infinity;
      this.sockets = {};
      this.freeSockets = {};
      this.requests = {};
    }
    createConnection(_options2, callback) {
      const socket = new Socket$1();
      if (callback) {
        callback(null, socket);
      }
      return socket;
    }
    getName(options2) {
      const host = options2.host || "localhost";
      const port = options2.port || 80;
      return `${host}:${port}:${options2.localAddress || ""}`;
    }
    addRequest(_req, _options2) {
    }
    destroy() {
      this.sockets = {};
      this.freeSockets = {};
      this.requests = {};
    }
  }
  const globalAgent = new Agent();
  function _parseWsFrame(data2) {
    if (data2.length < 2)
      return null;
    const opcode = data2[0] & 15;
    const masked = (data2[1] & 128) !== 0;
    let payloadLength = data2[1] & 127;
    let offset = 2;
    if (payloadLength === 126) {
      if (data2.length < 4)
        return null;
      payloadLength = data2[2] << 8 | data2[3];
      offset = 4;
    } else if (payloadLength === 127) {
      if (data2.length < 10)
        return null;
      payloadLength = data2[6] << 24 | data2[7] << 16 | data2[8] << 8 | data2[9];
      offset = 10;
    }
    if (masked) {
      if (data2.length < offset + 4 + payloadLength)
        return null;
      const maskKey = data2.slice(offset, offset + 4);
      offset += 4;
      const payload = new Uint8Array(payloadLength);
      for (let i22 = 0; i22 < payloadLength; i22++) {
        payload[i22] = data2[offset + i22] ^ maskKey[i22 % 4];
      }
      return {
        opcode,
        payload,
        totalLength: offset + payloadLength
      };
    } else {
      if (data2.length < offset + payloadLength)
        return null;
      const payload = data2.slice(offset, offset + payloadLength);
      return {
        opcode,
        payload,
        totalLength: offset + payloadLength
      };
    }
  }
  function _createWsFrame(opcode, payload, masked) {
    const length2 = payload.length;
    let headerSize = 2;
    if (length2 > 125 && length2 <= 65535) {
      headerSize += 2;
    } else if (length2 > 65535) {
      headerSize += 8;
    }
    if (masked) {
      headerSize += 4;
    }
    const frame = new Uint8Array(headerSize + length2);
    frame[0] = 128 | opcode;
    let offset = 2;
    if (length2 <= 125) {
      frame[1] = (masked ? 128 : 0) | length2;
    } else if (length2 <= 65535) {
      frame[1] = (masked ? 128 : 0) | 126;
      frame[2] = length2 >> 8 & 255;
      frame[3] = length2 & 255;
      offset = 4;
    } else {
      frame[1] = (masked ? 128 : 0) | 127;
      frame[2] = 0;
      frame[3] = 0;
      frame[4] = 0;
      frame[5] = 0;
      frame[6] = length2 >> 24 & 255;
      frame[7] = length2 >> 16 & 255;
      frame[8] = length2 >> 8 & 255;
      frame[9] = length2 & 255;
      offset = 10;
    }
    if (masked) {
      const maskKey = new Uint8Array(4);
      if (typeof crypto !== "undefined" && crypto.getRandomValues) {
        crypto.getRandomValues(maskKey);
      } else {
        for (let i22 = 0; i22 < 4; i22++)
          maskKey[i22] = Math.floor(Math.random() * 256);
      }
      frame.set(maskKey, offset);
      offset += 4;
      for (let i22 = 0; i22 < length2; i22++) {
        frame[offset + i22] = payload[i22] ^ maskKey[i22 % 4];
      }
    } else {
      frame.set(payload, offset);
    }
    return frame;
  }
  const http = {
    Server: Server$2,
    IncomingMessage,
    ServerResponse,
    ClientRequest,
    createServer: createServer$2,
    request: request$1,
    get: get$1,
    STATUS_CODES,
    METHODS,
    getServer,
    getAllServers,
    setServerListenCallback,
    setServerCloseCallback,
    _createClientRequest,
    Agent,
    globalAgent,
    _parseWsFrame,
    _createWsFrame
  };
  httpShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Agent,
    ClientRequest,
    IncomingMessage,
    METHODS,
    STATUS_CODES,
    Server: Server$2,
    ServerResponse,
    _createClientRequest,
    _createWsFrame,
    _parseWsFrame,
    _registerServer,
    _unregisterServer,
    createServer: createServer$2,
    default: http,
    get: get$1,
    getAllServers,
    getServer,
    globalAgent,
    request: request$1,
    setServerCloseCallback,
    setServerListenCallback
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function request(urlOrOptions, optionsOrCallback, callback) {
    return _createClientRequest(urlOrOptions, optionsOrCallback, callback, "https");
  }
  function get(urlOrOptions, optionsOrCallback, callback) {
    const req = _createClientRequest(urlOrOptions, optionsOrCallback, callback, "https");
    req.end();
    return req;
  }
  const https = {
    Server: Server$2,
    IncomingMessage,
    ServerResponse,
    ClientRequest,
    createServer: createServer$2,
    request,
    get,
    STATUS_CODES,
    METHODS,
    getServer,
    getAllServers,
    setServerListenCallback,
    setServerCloseCallback,
    Agent,
    globalAgent
  };
  const httpsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Agent,
    ClientRequest,
    IncomingMessage,
    METHODS,
    STATUS_CODES,
    Server: Server$2,
    ServerResponse,
    createServer: createServer$2,
    default: https,
    get,
    getAllServers,
    getServer,
    globalAgent,
    request,
    setServerCloseCallback,
    setServerListenCallback
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function parse$Q(urlString, parseQueryString = false, slashesDenoteHost = false) {
    var _a22;
    try {
      const url2 = new URL$1(urlString, "http://localhost");
      const result = {
        protocol: url2.protocol,
        slashes: url2.protocol.endsWith(":"),
        auth: url2.username ? `${url2.username}:${url2.password}` : null,
        host: url2.host,
        port: url2.port || null,
        hostname: url2.hostname,
        hash: url2.hash || null,
        search: url2.search || null,
        query: parseQueryString ? Object.fromEntries(url2.searchParams) : ((_a22 = url2.search) == null ? void 0 : _a22.slice(1)) || null,
        pathname: url2.pathname,
        path: url2.pathname + url2.search,
        href: url2.href
      };
      return result;
    } catch {
      return {
        protocol: null,
        slashes: null,
        auth: null,
        host: null,
        port: null,
        hostname: null,
        hash: null,
        search: null,
        query: null,
        pathname: urlString,
        path: urlString,
        href: urlString
      };
    }
  }
  function format$1(urlObject) {
    if (urlObject.href) {
      return urlObject.href;
    }
    let result = "";
    if (urlObject.protocol) {
      result += urlObject.protocol;
      if (!urlObject.protocol.endsWith(":")) {
        result += ":";
      }
    }
    if (urlObject.slashes || urlObject.protocol === "http:" || urlObject.protocol === "https:") {
      result += "//";
    }
    if (urlObject.auth) {
      result += urlObject.auth + "@";
    }
    if (urlObject.hostname) {
      result += urlObject.hostname;
    } else if (urlObject.host) {
      result += urlObject.host;
    }
    if (urlObject.port) {
      result += ":" + urlObject.port;
    }
    if (urlObject.pathname) {
      result += urlObject.pathname;
    }
    if (urlObject.search) {
      result += urlObject.search;
    } else if (urlObject.query) {
      if (typeof urlObject.query === "string") {
        result += "?" + urlObject.query;
      } else {
        const params = new URLSearchParams();
        for (const [key, value2] of Object.entries(urlObject.query)) {
          if (Array.isArray(value2)) {
            for (const v of value2) {
              params.append(key, v);
            }
          } else {
            params.set(key, value2);
          }
        }
        const search = params.toString();
        if (search) {
          result += "?" + search;
        }
      }
    }
    if (urlObject.hash) {
      result += urlObject.hash;
    }
    return result;
  }
  function resolve$1(from, to2) {
    try {
      return new URL$1(to2, from).href;
    } catch {
      return to2;
    }
  }
  const URL$1 = globalThis.URL;
  const URLSearchParams = globalThis.URLSearchParams;
  function fileURLToPath(url2) {
    const urlObj = typeof url2 === "string" ? new globalThis.URL(url2) : url2;
    if (urlObj.protocol !== "file:") {
      throw new TypeError("The URL must be of scheme file");
    }
    return decodeURIComponent(urlObj.pathname);
  }
  function pathToFileURL(path22) {
    const encoded = encodeURIComponent(path22).replace(/%2F/g, "/");
    return new globalThis.URL("file://" + encoded);
  }
  const url$1 = {
    parse: parse$Q,
    format: format$1,
    resolve: resolve$1,
    URL: URL$1,
    URLSearchParams,
    fileURLToPath,
    pathToFileURL
  };
  urlShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    URL: URL$1,
    URLSearchParams,
    default: url$1,
    fileURLToPath,
    format: format$1,
    parse: parse$Q,
    pathToFileURL,
    resolve: resolve$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function parse$P(str, sep22 = "&", eq = "=", options2) {
    const result = {};
    if (!str || typeof str !== "string") {
      return result;
    }
    const maxKeys = (options2 == null ? void 0 : options2.maxKeys) || 1e3;
    const pairs = str.split(sep22).slice(0, maxKeys > 0 ? maxKeys : void 0);
    for (const pair of pairs) {
      const idx = pair.indexOf(eq);
      let key;
      let value2;
      if (idx >= 0) {
        key = decodeURIComponent(pair.slice(0, idx).replace(/\+/g, " "));
        value2 = decodeURIComponent(pair.slice(idx + 1).replace(/\+/g, " "));
      } else {
        key = decodeURIComponent(pair.replace(/\+/g, " "));
        value2 = "";
      }
      if (key in result) {
        const existing = result[key];
        if (Array.isArray(existing)) {
          existing.push(value2);
        } else {
          result[key] = [
            existing,
            value2
          ];
        }
      } else {
        result[key] = value2;
      }
    }
    return result;
  }
  function stringify(obj, sep22 = "&", eq = "=") {
    if (!obj || typeof obj !== "object") {
      return "";
    }
    const pairs = [];
    for (const [key, value2] of Object.entries(obj)) {
      if (value2 === void 0)
        continue;
      const encodedKey = encodeURIComponent(key);
      if (Array.isArray(value2)) {
        for (const v of value2) {
          pairs.push(`${encodedKey}${eq}${encodeURIComponent(String(v))}`);
        }
      } else {
        pairs.push(`${encodedKey}${eq}${encodeURIComponent(String(value2))}`);
      }
    }
    return pairs.join(sep22);
  }
  function escape(str) {
    return encodeURIComponent(str);
  }
  function unescape(str) {
    return decodeURIComponent(str.replace(/\+/g, " "));
  }
  const encode$2 = stringify;
  const decode$2 = parse$P;
  const querystring = {
    parse: parse$P,
    stringify,
    escape,
    unescape,
    encode: encode$2,
    decode: decode$2
  };
  querystringShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    decode: decode$2,
    default: querystring,
    encode: encode$2,
    escape,
    parse: parse$P,
    stringify,
    unescape
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  var define_process_env_default = {};
  function format(fmt, ...args) {
    if (typeof fmt !== "string") {
      return args.map((arg) => inspect(arg)).join(" ");
    }
    let i22 = 0;
    return fmt.replace(/%[sdjifoO%]/g, (match2) => {
      if (match2 === "%%")
        return "%";
      if (i22 >= args.length)
        return match2;
      const arg = args[i22++];
      switch (match2) {
        case "%s":
          return String(arg);
        case "%d":
        case "%i":
          return String(parseInt(String(arg), 10));
        case "%f":
          return String(parseFloat(String(arg)));
        case "%j":
          try {
            return JSON.stringify(arg);
          } catch {
            return "[Circular]";
          }
        case "%o":
        case "%O":
          return inspect(arg);
        default:
          return match2;
      }
    });
  }
  function inspect(obj, options2) {
    const seen = /* @__PURE__ */ new WeakSet();
    const depth = (options2 == null ? void 0 : options2.depth) ?? 2;
    function inspectValue(value2, currentDepth) {
      if (value2 === null)
        return "null";
      if (value2 === void 0)
        return "undefined";
      const type2 = typeof value2;
      if (type2 === "string") {
        return `'${value2}'`;
      }
      if (type2 === "number" || type2 === "boolean" || type2 === "bigint") {
        return String(value2);
      }
      if (type2 === "symbol") {
        return value2.toString();
      }
      if (type2 === "function") {
        const name2 = value2.name || "anonymous";
        return `[Function: ${name2}]`;
      }
      if (type2 !== "object") {
        return String(value2);
      }
      if (seen.has(value2)) {
        return "[Circular]";
      }
      seen.add(value2);
      if (currentDepth > depth) {
        return Array.isArray(value2) ? "[Array]" : "[Object]";
      }
      if (Array.isArray(value2)) {
        if (value2.length === 0)
          return "[]";
        const items = value2.map((v) => inspectValue(v, currentDepth + 1));
        return `[ ${items.join(", ")} ]`;
      }
      if (value2 instanceof Date) {
        return value2.toISOString();
      }
      if (value2 instanceof RegExp) {
        return value2.toString();
      }
      if (value2 instanceof Error) {
        return `${value2.name}: ${value2.message}`;
      }
      if (value2 instanceof Map) {
        const entries2 = [
          ...value2.entries()
        ].map(([k, v]) => `${inspectValue(k, currentDepth + 1)} => ${inspectValue(v, currentDepth + 1)}`);
        return `Map(${value2.size}) { ${entries2.join(", ")} }`;
      }
      if (value2 instanceof Set) {
        const items = [
          ...value2
        ].map((v) => inspectValue(v, currentDepth + 1));
        return `Set(${value2.size}) { ${items.join(", ")} }`;
      }
      const keys = Object.keys(value2);
      if (keys.length === 0)
        return "{}";
      const entries = keys.map((key) => {
        const val = value2[key];
        return `${key}: ${inspectValue(val, currentDepth + 1)}`;
      });
      return `{ ${entries.join(", ")} }`;
    }
    return inspectValue(obj, 0);
  }
  function inherits(ctor, superCtor) {
    if (ctor === void 0 || ctor === null) {
      throw new TypeError("inherits: ctor must be a function");
    }
    if (superCtor === void 0 || superCtor === null) {
      return;
    }
    if (superCtor.prototype === void 0) {
      return;
    }
    ctor.super_ = superCtor;
    Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
  }
  function deprecate(fn22, msg, code2) {
    let warned = false;
    const deprecated = function(...args) {
      if (!warned) {
        console.warn(`DeprecationWarning: ${msg}${code2 ? ` (${code2})` : ""}`);
        warned = true;
      }
      return fn22.apply(this, args);
    };
    return deprecated;
  }
  function promisify(fn22) {
    return (...args) => {
      return new Promise((resolve2, reject) => {
        fn22(...args, (err2, result) => {
          if (err2) {
            reject(err2);
          } else {
            resolve2(result);
          }
        });
      });
    };
  }
  function callbackify(fn22) {
    return (...args) => {
      const callback = args.pop();
      fn22(...args).then((result) => callback(null, result)).catch((err2) => callback(err2, void 0));
    };
  }
  function isArray$1(value2) {
    return Array.isArray(value2);
  }
  function isBoolean(value2) {
    return typeof value2 === "boolean";
  }
  function isNull(value2) {
    return value2 === null;
  }
  function isNullOrUndefined(value2) {
    return value2 === null || value2 === void 0;
  }
  function isNumber(value2) {
    return typeof value2 === "number";
  }
  function isString(value2) {
    return typeof value2 === "string";
  }
  function isUndefined(value2) {
    return value2 === void 0;
  }
  function isRegExp(value2) {
    return value2 instanceof RegExp;
  }
  function isObject(value2) {
    return typeof value2 === "object" && value2 !== null;
  }
  function isDate(value2) {
    return value2 instanceof Date;
  }
  function isError(value2) {
    return value2 instanceof Error;
  }
  function isFunction(value2) {
    return typeof value2 === "function";
  }
  function isPrimitive(value2) {
    return value2 === null || typeof value2 !== "object" && typeof value2 !== "function";
  }
  function isBuffer(value2) {
    return value2 instanceof Uint8Array;
  }
  function debuglog(section) {
    const nodeDebug = typeof process !== "undefined" && (define_process_env_default == null ? void 0 : define_process_env_default.NODE_DEBUG) || "";
    const enabled = nodeDebug.toLowerCase().includes(section.toLowerCase());
    if (enabled) {
      return (...args) => {
        console.error(`${section.toUpperCase()} ${(process == null ? void 0 : process.pid) || 0}:`, ...args);
      };
    }
    return () => {
    };
  }
  const debug = debuglog;
  const types$2 = {
    isArray: isArray$1,
    isBoolean,
    isNull,
    isNullOrUndefined,
    isNumber,
    isString,
    isUndefined,
    isRegExp,
    isObject,
    isDate,
    isError,
    isFunction,
    isPrimitive,
    isBuffer
  };
  const TextEncoder$1 = globalThis.TextEncoder;
  const TextDecoder$1 = globalThis.TextDecoder;
  const util$4 = {
    format,
    inspect,
    inherits,
    deprecate,
    promisify,
    callbackify,
    debuglog,
    debug,
    isArray: isArray$1,
    isBoolean,
    isNull,
    isNullOrUndefined,
    isNumber,
    isString,
    isUndefined,
    isRegExp,
    isObject,
    isDate,
    isError,
    isFunction,
    isPrimitive,
    isBuffer,
    types: types$2,
    TextEncoder: TextEncoder$1,
    TextDecoder: TextDecoder$1
  };
  utilShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    TextDecoder: TextDecoder$1,
    TextEncoder: TextEncoder$1,
    callbackify,
    debug,
    debuglog,
    default: util$4,
    deprecate,
    format,
    inherits,
    inspect,
    isArray: isArray$1,
    isBoolean,
    isBuffer,
    isDate,
    isError,
    isFunction,
    isNull,
    isNullOrUndefined,
    isNumber,
    isObject,
    isPrimitive,
    isRegExp,
    isString,
    isUndefined,
    promisify,
    types: types$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class ReadStream extends Readable {
    constructor() {
      super(...arguments);
      __publicField(this, "isTTY", false);
      __publicField(this, "isRaw", false);
    }
    setRawMode(mode) {
      this.isRaw = mode;
      return this;
    }
  }
  class WriteStream extends Writable {
    constructor() {
      super(...arguments);
      __publicField(this, "isTTY", false);
      __publicField(this, "columns", 80);
      __publicField(this, "rows", 24);
    }
    clearLine(dir, callback) {
      if (callback)
        callback();
      return true;
    }
    clearScreenDown(callback) {
      if (callback)
        callback();
      return true;
    }
    cursorTo(x, y, callback) {
      if (callback)
        callback();
      return true;
    }
    moveCursor(dx2, dy2, callback) {
      if (callback)
        callback();
      return true;
    }
    getColorDepth(env) {
      return 1;
    }
    hasColors(count, env) {
      return false;
    }
    getWindowSize() {
      return [
        this.columns,
        this.rows
      ];
    }
  }
  function isatty(fd2) {
    return false;
  }
  const tty = {
    ReadStream,
    WriteStream,
    isatty
  };
  const ttyShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    ReadStream,
    WriteStream,
    default: tty,
    isatty
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function hostname() {
    return "localhost";
  }
  function platform() {
    return "linux";
  }
  function arch() {
    return "x64";
  }
  function type() {
    return "Linux";
  }
  function release() {
    return "5.10.0";
  }
  function version$2() {
    return "#1 SMP";
  }
  function machine() {
    return "x86_64";
  }
  function tmpdir() {
    return "/tmp";
  }
  function homedir() {
    return "/home/user";
  }
  function cpus() {
    const cpu = {
      model: "Virtual CPU",
      speed: 2400,
      times: {
        user: 0,
        nice: 0,
        sys: 0,
        idle: 0,
        irq: 0
      }
    };
    return [
      cpu,
      cpu
    ];
  }
  function totalmem() {
    return 4 * 1024 * 1024 * 1024;
  }
  function freemem() {
    return 2 * 1024 * 1024 * 1024;
  }
  function uptime() {
    return Math.floor(performance.now() / 1e3);
  }
  function loadavg() {
    return [
      0.5,
      0.5,
      0.5
    ];
  }
  function networkInterfaces() {
    return {
      lo: [
        {
          address: "127.0.0.1",
          netmask: "255.0.0.0",
          family: "IPv4",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "127.0.0.1/8"
        }
      ]
    };
  }
  function userInfo() {
    return {
      username: "user",
      uid: 1e3,
      gid: 1e3,
      shell: "/bin/bash",
      homedir: "/home/user"
    };
  }
  function endianness() {
    return "LE";
  }
  function getPriority(pid) {
    return 0;
  }
  function setPriority(pid, priority) {
  }
  const EOL = "\n";
  const constants$4 = {
    signals: {
      SIGHUP: 1,
      SIGINT: 2,
      SIGQUIT: 3,
      SIGILL: 4,
      SIGTRAP: 5,
      SIGABRT: 6,
      SIGBUS: 7,
      SIGFPE: 8,
      SIGKILL: 9,
      SIGUSR1: 10,
      SIGSEGV: 11,
      SIGUSR2: 12,
      SIGPIPE: 13,
      SIGALRM: 14,
      SIGTERM: 15,
      SIGCHLD: 17,
      SIGCONT: 18,
      SIGSTOP: 19,
      SIGTSTP: 20,
      SIGTTIN: 21,
      SIGTTOU: 22,
      SIGURG: 23,
      SIGXCPU: 24,
      SIGXFSZ: 25,
      SIGVTALRM: 26,
      SIGPROF: 27,
      SIGWINCH: 28,
      SIGIO: 29,
      SIGPWR: 30,
      SIGSYS: 31
    },
    errno: {},
    priority: {
      PRIORITY_LOW: 19,
      PRIORITY_BELOW_NORMAL: 10,
      PRIORITY_NORMAL: 0,
      PRIORITY_ABOVE_NORMAL: -7,
      PRIORITY_HIGH: -14,
      PRIORITY_HIGHEST: -20
    }
  };
  const devNull = "/dev/null";
  const os = {
    hostname,
    platform,
    arch,
    type,
    release,
    version: version$2,
    machine,
    tmpdir,
    homedir,
    cpus,
    totalmem,
    freemem,
    uptime,
    loadavg,
    networkInterfaces,
    userInfo,
    endianness,
    getPriority,
    setPriority,
    EOL,
    constants: constants$4,
    devNull
  };
  const osShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    EOL,
    arch,
    constants: constants$4,
    cpus,
    default: os,
    devNull,
    endianness,
    freemem,
    getPriority,
    homedir,
    hostname,
    loadavg,
    machine,
    networkInterfaces,
    platform,
    release,
    setPriority,
    tmpdir,
    totalmem,
    type,
    uptime,
    userInfo,
    version: version$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  let brotliModule = null;
  let brotliLoadPromise = null;
  async function loadBrotli() {
    if (brotliModule)
      return brotliModule;
    if (!brotliLoadPromise) {
      brotliLoadPromise = (async () => {
        try {
          const brotliWasmModule = await Promise.resolve().then(() => (init_index_web(), index_web_exports)).then(async (m) => {
            await m.__tla;
            return m;
          });
          brotliModule = await brotliWasmModule.default;
          console.log("[zlib] brotli-wasm loaded successfully");
          return brotliModule;
        } catch (error) {
          console.error("[zlib] Failed to load brotli-wasm:", error);
          return null;
        }
      })();
    }
    return brotliLoadPromise;
  }
  function gzip(buffer2, callback) {
    try {
      const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
      const result = pako.gzip(input);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function gunzip(buffer2, callback) {
    try {
      const result = pako.ungzip(buffer2);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function deflate(buffer2, callback) {
    try {
      const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
      const result = pako.deflate(input);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function inflate(buffer2, callback) {
    try {
      const result = pako.inflate(buffer2);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function deflateRaw(buffer2, callback) {
    try {
      const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
      const result = pako.deflateRaw(input);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function inflateRaw(buffer2, callback) {
    try {
      const result = pako.inflateRaw(buffer2);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function brotliCompress(buffer2, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
    }
    loadBrotli().then((brotli) => {
      if (!brotli) {
        callback(new Error("Brotli WASM failed to load"), BufferPolyfill.alloc(0));
        return;
      }
      try {
        const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
        const result = brotli.compress(new Uint8Array(input));
        callback(null, BufferPolyfill.from(result));
      } catch (error) {
        callback(error, BufferPolyfill.alloc(0));
      }
    }).catch((error) => {
      callback(error, BufferPolyfill.alloc(0));
    });
  }
  function brotliDecompress(buffer2, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
    }
    loadBrotli().then((brotli) => {
      if (!brotli) {
        callback(new Error("Brotli WASM failed to load"), BufferPolyfill.alloc(0));
        return;
      }
      try {
        const result = brotli.decompress(new Uint8Array(buffer2));
        callback(null, BufferPolyfill.from(result));
      } catch (error) {
        callback(error, BufferPolyfill.alloc(0));
      }
    }).catch((error) => {
      callback(error, BufferPolyfill.alloc(0));
    });
  }
  function brotliCompressSync(buffer2, _options2) {
    if (!brotliModule) {
      throw new Error("Brotli WASM not loaded. Call brotliCompress first to initialize.");
    }
    const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
    return BufferPolyfill.from(brotliModule.compress(new Uint8Array(input)));
  }
  function brotliDecompressSync(buffer2, _options2) {
    if (!brotliModule) {
      throw new Error("Brotli WASM not loaded. Call brotliDecompress first to initialize.");
    }
    return BufferPolyfill.from(brotliModule.decompress(new Uint8Array(buffer2)));
  }
  function gzipSync(buffer2) {
    const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
    return BufferPolyfill.from(pako.gzip(input));
  }
  function gunzipSync(buffer2) {
    return BufferPolyfill.from(pako.ungzip(buffer2));
  }
  function deflateSync(buffer2) {
    const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
    return BufferPolyfill.from(pako.deflate(input));
  }
  function inflateSync(buffer2) {
    return BufferPolyfill.from(pako.inflate(buffer2));
  }
  function deflateRawSync(buffer2) {
    const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
    return BufferPolyfill.from(pako.deflateRaw(input));
  }
  function inflateRawSync(buffer2) {
    return BufferPolyfill.from(pako.inflateRaw(buffer2));
  }
  const constants$3 = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4784,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_DECODE: 0,
    BROTLI_ENCODE: 1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24
  };
  const zlib = {
    gzip,
    gunzip,
    deflate,
    inflate,
    deflateRaw,
    inflateRaw,
    gzipSync,
    gunzipSync,
    deflateSync,
    inflateSync,
    deflateRawSync,
    inflateRawSync,
    brotliCompress,
    brotliDecompress,
    brotliCompressSync,
    brotliDecompressSync,
    constants: constants$3
  };
  const zlibShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    brotliCompress,
    brotliCompressSync,
    brotliDecompress,
    brotliDecompressSync,
    constants: constants$3,
    default: zlib,
    deflate,
    deflateRaw,
    deflateRawSync,
    deflateSync,
    gunzip,
    gunzipSync,
    gzip,
    gzipSync,
    inflate,
    inflateRaw,
    inflateRawSync,
    inflateSync
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function lookup(hostname2, optionsOrCallback, callback) {
    const cb2 = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
    const options2 = typeof optionsOrCallback === "object" ? optionsOrCallback : {};
    setImmediate(() => {
      if (hostname2 === "localhost" || hostname2 === "127.0.0.1") {
        if (options2.all) {
          cb2(null, [
            {
              address: "127.0.0.1",
              family: 4
            }
          ]);
        } else {
          cb2(null, "127.0.0.1", 4);
        }
      } else {
        if (options2.all) {
          cb2(null, [
            {
              address: "0.0.0.0",
              family: 4
            }
          ]);
        } else {
          cb2(null, "0.0.0.0", 4);
        }
      }
    });
  }
  function resolve(hostname2, callback) {
    setImmediate(() => {
      callback(null, [
        "0.0.0.0"
      ]);
    });
  }
  function resolve4(hostname2, callback) {
    resolve(hostname2, callback);
  }
  function resolve6(hostname2, callback) {
    setImmediate(() => {
      callback(null, [
        "::1"
      ]);
    });
  }
  function reverse(ip2, callback) {
    setImmediate(() => {
      callback(null, [
        "localhost"
      ]);
    });
  }
  function setServers(_servers) {
  }
  function getServers() {
    return [];
  }
  function setDefaultResultOrder(_order) {
  }
  function getDefaultResultOrder() {
    return "verbatim";
  }
  const promises$1 = {
    lookup: (hostname2, options2) => {
      return new Promise((resolve2, reject) => {
        if (options2 == null ? void 0 : options2.all) {
          lookup(hostname2, options2, (err2, addresses) => {
            if (err2)
              reject(err2);
            else
              resolve2(addresses || []);
          });
          return;
        }
        lookup(hostname2, options2 || {}, (err2, address, family) => {
          if (err2)
            reject(err2);
          else
            resolve2({
              address,
              family
            });
        });
      });
    },
    resolve: (hostname2) => {
      return new Promise((promiseResolve, promiseReject) => {
        resolve(hostname2, (err2, addresses) => {
          if (err2)
            promiseReject(err2);
          else
            promiseResolve(addresses || []);
        });
      });
    },
    resolve4: (hostname2) => promises$1.resolve(hostname2),
    resolve6: (hostname2) => {
      return new Promise((resolve2) => {
        resolve2([
          "::1"
        ]);
      });
    },
    reverse: (ip2) => {
      return new Promise((resolve2) => {
        resolve2([
          "localhost"
        ]);
      });
    },
    setServers: (_servers) => {
    },
    getServers: () => []
  };
  const ADDRCONFIG = 0;
  const V4MAPPED = 0;
  const ALL = 0;
  const dns = {
    lookup,
    resolve,
    resolve4,
    resolve6,
    reverse,
    setServers,
    getServers,
    setDefaultResultOrder,
    getDefaultResultOrder,
    promises: promises$1,
    ADDRCONFIG,
    V4MAPPED,
    ALL
  };
  const dnsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    ADDRCONFIG,
    ALL,
    V4MAPPED,
    default: dns,
    getDefaultResultOrder,
    getServers,
    lookup,
    promises: promises$1,
    resolve,
    resolve4,
    resolve6,
    reverse,
    setDefaultResultOrder,
    setServers
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const Buffer$1 = BufferPolyfill;
  const SlowBuffer = BufferPolyfill;
  const kMaxLength = 2147483647;
  const INSPECT_MAX_BYTES = 50;
  const constants$2 = {
    MAX_LENGTH: kMaxLength,
    MAX_STRING_LENGTH: 536870888
  };
  function transcode(source, _fromEnc, _toEnc) {
    return Buffer$1.from(source);
  }
  function resolveObjectURL(id2) {
    return void 0;
  }
  function atob$1(data2) {
    return globalThis.atob(data2);
  }
  function btoa$1(data2) {
    return globalThis.btoa(data2);
  }
  const bufferModule = {
    Buffer: Buffer$1,
    SlowBuffer,
    kMaxLength,
    INSPECT_MAX_BYTES,
    constants: constants$2,
    transcode,
    resolveObjectURL,
    atob: atob$1,
    btoa: btoa$1
  };
  Object.defineProperty(bufferModule, "hasOwnProperty", {
    value: Object.prototype.hasOwnProperty,
    enumerable: false,
    configurable: true,
    writable: true
  });
  const buffer = Object.freeze(Object.defineProperty({
    __proto__: null,
    Buffer: Buffer$1,
    INSPECT_MAX_BYTES,
    SlowBuffer,
    atob: atob$1,
    btoa: btoa$1,
    constants: constants$2,
    default: bufferModule,
    kMaxLength,
    resolveObjectURL,
    transcode
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const _decoder = new TextDecoder();
  class VirtualFSAdapter {
    constructor(vfs2) {
      this.vfs = vfs2;
    }
    async readFile(path22, options2) {
      const encoding = typeof options2 === "string" ? options2 : options2 == null ? void 0 : options2.encoding;
      if (!encoding || encoding === "utf8" || encoding === "utf-8") {
        return this.vfs.readFileSync(path22, "utf8");
      }
      if (encoding === "binary" || encoding === "latin1") {
        const buffer2 = this.vfs.readFileSync(path22);
        return uint8ToBinaryString(buffer2);
      }
      return this.vfs.readFileSync(path22, "utf8");
    }
    async readFileBuffer(path22) {
      return this.vfs.readFileSync(path22);
    }
    async writeFile(path22, content, _options2) {
      this.vfs.writeFileSync(path22, content);
    }
    async appendFile(path22, content, _options2) {
      let existing = "";
      try {
        existing = this.vfs.readFileSync(path22, "utf8");
      } catch {
      }
      const newContent = typeof content === "string" ? content : _decoder.decode(content);
      this.vfs.writeFileSync(path22, existing + newContent);
    }
    async exists(path22) {
      return this.vfs.existsSync(path22);
    }
    async stat(path22) {
      const stats = this.vfs.statSync(path22);
      const isFile = stats.isFile();
      const isDirectory = stats.isDirectory();
      let size = 0;
      if (isFile) {
        try {
          const content = this.vfs.readFileSync(path22);
          size = content.length;
        } catch {
        }
      }
      return {
        isFile,
        isDirectory,
        isSymbolicLink: false,
        mode: isDirectory ? 493 : 420,
        size,
        mtime: /* @__PURE__ */ new Date()
      };
    }
    async mkdir(path22, options2) {
      this.vfs.mkdirSync(path22, options2);
    }
    async readdir(path22) {
      return this.vfs.readdirSync(path22);
    }
    async readdirWithFileTypes(path22) {
      const entries = this.vfs.readdirSync(path22);
      const result = [];
      for (const name2 of entries) {
        const fullPath = path22 === "/" ? `/${name2}` : `${path22}/${name2}`;
        try {
          const stats = this.vfs.statSync(fullPath);
          result.push({
            name: name2,
            isFile: stats.isFile(),
            isDirectory: stats.isDirectory(),
            isSymbolicLink: false
          });
        } catch {
        }
      }
      return result;
    }
    async rm(path22, options2) {
      const exists = this.vfs.existsSync(path22);
      if (!exists) {
        if (options2 == null ? void 0 : options2.force) {
          return;
        }
        throw createNodeError("ENOENT", "rm", path22);
      }
      const stats = this.vfs.statSync(path22);
      if (stats.isFile()) {
        this.vfs.unlinkSync(path22);
      } else if (stats.isDirectory()) {
        if (options2 == null ? void 0 : options2.recursive) {
          await this.rmRecursive(path22);
        } else {
          this.vfs.rmdirSync(path22);
        }
      }
    }
    async rmRecursive(path22) {
      const entries = this.vfs.readdirSync(path22);
      for (const entry of entries) {
        const fullPath = path22 === "/" ? `/${entry}` : `${path22}/${entry}`;
        const stats = this.vfs.statSync(fullPath);
        if (stats.isDirectory()) {
          await this.rmRecursive(fullPath);
        } else {
          this.vfs.unlinkSync(fullPath);
        }
      }
      this.vfs.rmdirSync(path22);
    }
    async cp(src, dest, options2) {
      const stats = this.vfs.statSync(src);
      if (stats.isFile()) {
        const content = this.vfs.readFileSync(src);
        this.vfs.writeFileSync(dest, content);
      } else if (stats.isDirectory()) {
        if (!(options2 == null ? void 0 : options2.recursive)) {
          throw new Error(`EISDIR: illegal operation on a directory, cannot copy '${src}'`);
        }
        await this.cpRecursive(src, dest);
      }
    }
    async cpRecursive(src, dest) {
      this.vfs.mkdirSync(dest, {
        recursive: true
      });
      const entries = this.vfs.readdirSync(src);
      for (const entry of entries) {
        const srcPath = src === "/" ? `/${entry}` : `${src}/${entry}`;
        const destPath = dest === "/" ? `/${entry}` : `${dest}/${entry}`;
        const stats = this.vfs.statSync(srcPath);
        if (stats.isDirectory()) {
          await this.cpRecursive(srcPath, destPath);
        } else {
          const content = this.vfs.readFileSync(srcPath);
          this.vfs.writeFileSync(destPath, content);
        }
      }
    }
    async mv(src, dest) {
      this.vfs.renameSync(src, dest);
    }
    resolvePath(base, path22) {
      if (path22.startsWith("/")) {
        return this.normalizePath(path22);
      }
      const combined = base.endsWith("/") ? `${base}${path22}` : `${base}/${path22}`;
      return this.normalizePath(combined);
    }
    normalizePath(path22) {
      if (!path22.startsWith("/")) {
        path22 = "/" + path22;
      }
      const parts = path22.split("/").filter(Boolean);
      const resolved = [];
      for (const part of parts) {
        if (part === "..") {
          resolved.pop();
        } else if (part !== ".") {
          resolved.push(part);
        }
      }
      return "/" + resolved.join("/");
    }
    getAllPaths() {
      const paths = [];
      this.collectPaths("/", paths);
      return paths;
    }
    collectPaths(dir, paths) {
      try {
        const entries = this.vfs.readdirSync(dir);
        for (const entry of entries) {
          const fullPath = dir === "/" ? `/${entry}` : `${dir}/${entry}`;
          paths.push(fullPath);
          try {
            const stats = this.vfs.statSync(fullPath);
            if (stats.isDirectory()) {
              this.collectPaths(fullPath, paths);
            }
          } catch {
          }
        }
      } catch {
      }
    }
    async chmod(_path, _mode) {
      if (!this.vfs.existsSync(_path)) {
        throw createNodeError("ENOENT", "chmod", _path);
      }
    }
    async symlink(_target, _linkPath) {
      throw new Error("Symbolic links are not supported in VirtualFS");
    }
    async link(_existingPath, _newPath) {
      throw new Error("Hard links are not supported in VirtualFS");
    }
    async readlink(_path) {
      throw new Error("Symbolic links are not supported in VirtualFS");
    }
    async lstat(path22) {
      return this.stat(path22);
    }
    async realpath(path22) {
      if (!this.vfs.existsSync(path22)) {
        throw createNodeError("ENOENT", "realpath", path22);
      }
      return this.normalizePath(path22);
    }
    async utimes(path22, _atime, _mtime) {
      if (!this.vfs.existsSync(path22)) {
        throw createNodeError("ENOENT", "utimes", path22);
      }
    }
  }
  if (typeof globalThis.process === "undefined") {
    globalThis.process = {
      env: {
        HOME: "/home/user",
        USER: "user",
        PATH: "/usr/local/bin:/usr/bin:/bin",
        NODE_ENV: "development"
      },
      cwd: () => "/",
      platform: "linux",
      version: "v18.0.0",
      versions: {
        node: "18.0.0"
      },
      stdout: {
        write: () => {
        }
      },
      stderr: {
        write: () => {
        }
      }
    };
  }
  let bashInstance = null;
  let vfsAdapter = null;
  let currentVfs = null;
  function initChildProcess(vfs2) {
    currentVfs = vfs2;
    vfsAdapter = new VirtualFSAdapter(vfs2);
    const nodeCommand = lb("node", async (args, ctx) => {
      if (!currentVfs) {
        return {
          stdout: "",
          stderr: "VFS not initialized\n",
          exitCode: 1
        };
      }
      const scriptPath = args[0];
      if (!scriptPath) {
        return {
          stdout: "",
          stderr: "Usage: node <script.js> [args...]\n",
          exitCode: 1
        };
      }
      const resolvedPath2 = scriptPath.startsWith("/") ? scriptPath : `${ctx.cwd}/${scriptPath}`.replace(/\/+/g, "/");
      try {
        if (!currentVfs.existsSync(resolvedPath2)) {
          return {
            stdout: "",
            stderr: `Error: Cannot find module '${resolvedPath2}'
`,
            exitCode: 1
          };
        }
        let stdout = "";
        let stderr = "";
        const runtime = new Runtime(currentVfs, {
          cwd: ctx.cwd,
          env: ctx.env,
          onConsole: (method, consoleArgs) => {
            const msg = consoleArgs.map((a) => String(a)).join(" ") + "\n";
            if (method === "error") {
              stderr += msg;
            } else {
              stdout += msg;
            }
          }
        });
        const processShim = globalThis.process || {};
        const originalArgv = processShim.argv;
        processShim.argv = [
          "node",
          resolvedPath2,
          ...args.slice(1)
        ];
        globalThis.process = processShim;
        try {
          runtime.runFile(resolvedPath2);
          return {
            stdout,
            stderr,
            exitCode: 0
          };
        } finally {
          processShim.argv = originalArgv;
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        return {
          stdout: "",
          stderr: `Error: ${errorMsg}
`,
          exitCode: 1
        };
      }
    });
    const convexCommand = lb("convex", async (args, ctx) => {
      if (!currentVfs) {
        return {
          stdout: "",
          stderr: "VFS not initialized\n",
          exitCode: 1
        };
      }
      const cliBundlePath = "/node_modules/convex/dist/cli.bundle.cjs";
      if (!currentVfs.existsSync(cliBundlePath)) {
        return {
          stdout: "",
          stderr: "Convex CLI not found. Run: npm install convex\n",
          exitCode: 1
        };
      }
      let stdout = "";
      let stderr = "";
      try {
        const runtime = new Runtime(currentVfs, {
          cwd: ctx.cwd,
          env: ctx.env,
          onConsole: (method, consoleArgs) => {
            const msg = consoleArgs.map((a) => String(a)).join(" ") + "\n";
            if (method === "error") {
              stderr += msg;
            } else {
              stdout += msg;
            }
          }
        });
        const processShim = globalThis.process || {};
        const originalArgv = processShim.argv;
        const originalEnv = {
          ...processShim.env
        };
        processShim.argv = [
          "node",
          "convex",
          ...args
        ];
        processShim.env = {
          ...processShim.env,
          ...ctx.env
        };
        globalThis.process = processShim;
        try {
          runtime.runFile(cliBundlePath);
          return {
            stdout,
            stderr,
            exitCode: 0
          };
        } finally {
          processShim.argv = originalArgv;
          processShim.env = originalEnv;
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        return {
          stdout,
          stderr: stderr + `Error: ${errorMsg}
`,
          exitCode: 1
        };
      }
    });
    bashInstance = new au({
      fs: vfsAdapter,
      cwd: "/",
      env: {
        HOME: "/home/user",
        USER: "user",
        PATH: "/usr/local/bin:/usr/bin:/bin:/node_modules/.bin",
        NODE_ENV: "development"
      },
      customCommands: [
        nodeCommand,
        convexCommand
      ]
    });
  }
  function exec(command, optionsOrCallback, callback) {
    let options2 = {};
    let cb2;
    if (typeof optionsOrCallback === "function") {
      cb2 = optionsOrCallback;
    } else if (optionsOrCallback) {
      options2 = optionsOrCallback;
      cb2 = callback;
    }
    const child = new ChildProcess();
    (async () => {
      var _a22, _b22, _c22, _d2;
      if (!bashInstance) {
        const error = new Error("child_process not initialized");
        child.emit("error", error);
        if (cb2)
          cb2(error, "", "");
        return;
      }
      try {
        const result = await bashInstance.exec(command, {
          cwd: options2.cwd,
          env: options2.env
        });
        const stdout = result.stdout || "";
        const stderr = result.stderr || "";
        if (stdout) {
          (_a22 = child.stdout) == null ? void 0 : _a22.push(BufferPolyfill.from(stdout));
        }
        (_b22 = child.stdout) == null ? void 0 : _b22.push(null);
        if (stderr) {
          (_c22 = child.stderr) == null ? void 0 : _c22.push(BufferPolyfill.from(stderr));
        }
        (_d2 = child.stderr) == null ? void 0 : _d2.push(null);
        child.emit("close", result.exitCode, null);
        child.emit("exit", result.exitCode, null);
        if (cb2) {
          if (result.exitCode !== 0) {
            const error = new Error(`Command failed: ${command}`);
            error.code = result.exitCode;
            cb2(error, stdout, stderr);
          } else {
            cb2(null, stdout, stderr);
          }
        }
      } catch (error) {
        child.emit("error", error);
        if (cb2)
          cb2(error, "", "");
      }
    })();
    return child;
  }
  function execSync(command, options2) {
    if (!bashInstance) {
      throw new Error("child_process not initialized");
    }
    throw new Error("execSync is not supported in browser environment. Use exec() with async/await or callbacks instead.");
  }
  function spawn(command, args, options2) {
    let spawnArgs = [];
    let spawnOptions = {};
    if (Array.isArray(args)) {
      spawnArgs = args;
      spawnOptions = options2 || {};
    } else if (args) {
      spawnOptions = args;
    }
    const child = new ChildProcess();
    const fullCommand = spawnArgs.length > 0 ? `${command} ${spawnArgs.map((arg) => arg.includes(" ") ? `"${arg}"` : arg).join(" ")}` : command;
    (async () => {
      var _a22, _b22, _c22, _d2;
      if (!bashInstance) {
        const error = new Error("child_process not initialized");
        child.emit("error", error);
        return;
      }
      try {
        const result = await bashInstance.exec(fullCommand, {
          cwd: spawnOptions.cwd,
          env: spawnOptions.env
        });
        const stdout = result.stdout || "";
        const stderr = result.stderr || "";
        if (stdout) {
          (_a22 = child.stdout) == null ? void 0 : _a22.push(BufferPolyfill.from(stdout));
        }
        (_b22 = child.stdout) == null ? void 0 : _b22.push(null);
        if (stderr) {
          (_c22 = child.stderr) == null ? void 0 : _c22.push(BufferPolyfill.from(stderr));
        }
        (_d2 = child.stderr) == null ? void 0 : _d2.push(null);
        child.emit("close", result.exitCode, null);
        child.emit("exit", result.exitCode, null);
      } catch (error) {
        child.emit("error", error);
      }
    })();
    return child;
  }
  function spawnSync(command, args, options2) {
    throw new Error("spawnSync is not supported in browser environment. Use spawn() instead.");
  }
  function execFile(file, args, options2, callback) {
    let execArgs = [];
    let execOptions = {};
    let cb2;
    if (Array.isArray(args)) {
      execArgs = args;
      if (typeof options2 === "function") {
        cb2 = options2;
      } else if (options2) {
        execOptions = options2;
        cb2 = callback;
      }
    } else if (typeof args === "function") {
      cb2 = args;
    } else if (args) {
      execOptions = args;
      cb2 = options2;
    }
    const command = execArgs.length > 0 ? `${file} ${execArgs.join(" ")}` : file;
    return exec(command, execOptions, cb2);
  }
  function fork$2() {
    throw new Error("fork is not supported in browser environment");
  }
  class ChildProcess extends EventEmitter {
    constructor() {
      super();
      __publicField(this, "pid");
      __publicField(this, "connected", false);
      __publicField(this, "killed", false);
      __publicField(this, "exitCode", null);
      __publicField(this, "signalCode", null);
      __publicField(this, "spawnargs", []);
      __publicField(this, "spawnfile", "");
      __publicField(this, "stdin");
      __publicField(this, "stdout");
      __publicField(this, "stderr");
      this.pid = Math.floor(Math.random() * 1e4) + 1e3;
      this.stdin = new Writable();
      this.stdout = new Readable();
      this.stderr = new Readable();
    }
    kill(signal) {
      this.killed = true;
      this.emit("exit", null, signal || "SIGTERM");
      return true;
    }
    disconnect() {
      this.connected = false;
    }
    send(message, callback) {
      if (callback)
        callback(new Error("IPC not supported"));
      return false;
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
  }
  const child_process = {
    exec,
    execSync,
    execFile,
    spawn,
    spawnSync,
    fork: fork$2,
    ChildProcess,
    initChildProcess
  };
  const childProcessShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    ChildProcess,
    default: child_process,
    exec,
    execFile,
    execSync,
    fork: fork$2,
    initChildProcess,
    spawn,
    spawnSync
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  let globalVFS$2 = null;
  function setVFS$2(vfs2) {
    globalVFS$2 = vfs2;
  }
  class FSWatcher extends EventEmitter {
    constructor(options2 = {}) {
      super();
      __publicField(this, "vfs");
      __publicField(this, "watched", /* @__PURE__ */ new Map());
      __publicField(this, "options");
      __publicField(this, "closed", false);
      __publicField(this, "ready", false);
      __publicField(this, "_eventCounts");
      if (!globalVFS$2) {
        throw new Error("chokidar: VirtualFS not initialized. Call setVFS first.");
      }
      this.vfs = globalVFS$2;
      this.options = options2;
    }
    shouldIgnore(path22) {
      const { ignored } = this.options;
      if (!ignored)
        return false;
      const ignoreList = Array.isArray(ignored) ? ignored : [
        ignored
      ];
      for (const pattern of ignoreList) {
        if (typeof pattern === "string") {
          if (path22 === pattern || path22.startsWith(pattern + "/"))
            return true;
        } else if (pattern instanceof RegExp) {
          if (pattern.test(path22))
            return true;
        } else if (typeof pattern === "function") {
          if (pattern(path22))
            return true;
        }
      }
      return false;
    }
    normalizePath(path22) {
      if (this.options.cwd && !path22.startsWith("/")) {
        path22 = this.options.cwd + "/" + path22;
      }
      if (!path22.startsWith("/")) {
        path22 = "/" + path22;
      }
      return path22;
    }
    add(paths) {
      if (this.closed)
        return this;
      const pathArray = Array.isArray(paths) ? paths : [
        paths
      ];
      const pendingEmits = [];
      console.log("[chokidar] add:", pathArray);
      for (const p of pathArray) {
        const normalized = this.normalizePath(p);
        if (this.shouldIgnore(normalized))
          continue;
        if (this.watched.has(normalized))
          continue;
        try {
          if (!this.vfs.existsSync(normalized)) {
            const parentPath = normalized.substring(0, normalized.lastIndexOf("/")) || "/";
            if (this.vfs.existsSync(parentPath)) {
              this.watchPath(parentPath, normalized);
            }
            continue;
          }
          const stats = this.vfs.statSync(normalized);
          if (!this.options.ignoreInitial) {
            if (stats.isDirectory()) {
              this.collectDirContents(normalized, pendingEmits);
            } else {
              pendingEmits.push(() => this.emit("add", normalized, stats));
            }
          }
          this.watchPath(normalized);
          if (stats.isDirectory()) {
            this.watchDirRecursive(normalized);
          }
        } catch (err2) {
          this.emit("error", err2);
        }
      }
      if (!this.ready) {
        this.ready = true;
        setTimeout(() => {
          for (const emitFn of pendingEmits) {
            emitFn();
          }
          this.emit("ready");
        }, 0);
      }
      return this;
    }
    collectDirContents(dirPath, pendingEmits) {
      try {
        const entries = this.vfs.readdirSync(dirPath);
        for (const entry of entries) {
          const fullPath = dirPath === "/" ? "/" + entry : dirPath + "/" + entry;
          if (this.shouldIgnore(fullPath))
            continue;
          const stats = this.vfs.statSync(fullPath);
          if (stats.isDirectory()) {
            pendingEmits.push(() => this.emit("addDir", fullPath, stats));
            this.collectDirContents(fullPath, pendingEmits);
          } else {
            pendingEmits.push(() => this.emit("add", fullPath, stats));
          }
        }
      } catch {
      }
    }
    watchPath(path22, watchFor) {
      if (this.watched.has(path22))
        return;
      const watcher = this.vfs.watch(path22, {
        recursive: true
      }, (eventType, filename2) => {
        if (this.closed)
          return;
        let fullPath;
        if (filename2) {
          fullPath = path22 === "/" ? "/" + filename2 : path22 + "/" + filename2;
        } else {
          fullPath = path22;
        }
        const eventKey = `${eventType}:${fullPath}`;
        if (!this._eventCounts)
          this._eventCounts = /* @__PURE__ */ new Map();
        const count = (this._eventCounts.get(eventKey) || 0) + 1;
        this._eventCounts.set(eventKey, count);
        if (count === 5) {
          console.warn(`[chokidar] Repeated event: ${eventType} on ${fullPath} (${count}+ times)`);
        }
        console.log("[chokidar] event:", eventType, fullPath);
        if (watchFor && fullPath !== watchFor && !fullPath.startsWith(watchFor + "/")) {
          return;
        }
        if (this.shouldIgnore(fullPath)) {
          console.log("[chokidar] ignored:", fullPath);
          return;
        }
        if (eventType === "rename") {
          if (this.vfs.existsSync(fullPath)) {
            try {
              const stats = this.vfs.statSync(fullPath);
              if (stats.isDirectory()) {
                console.log("[chokidar] emit addDir:", fullPath);
                this.emit("addDir", fullPath, stats);
              } else {
                console.log("[chokidar] emit add:", fullPath);
                this.emit("add", fullPath, stats);
              }
            } catch {
            }
          } else {
            console.log("[chokidar] emit unlink:", fullPath);
            this.emit("unlink", fullPath);
          }
        } else if (eventType === "change") {
          try {
            const stats = this.vfs.statSync(fullPath);
            console.log("[chokidar] emit change:", fullPath);
            this.emit("change", fullPath, stats);
          } catch {
            this.emit("unlink", fullPath);
          }
        }
      });
      this.watched.set(path22, watcher);
    }
    watchDirRecursive(dirPath, depth = 0) {
      if (this.options.depth !== void 0 && depth > this.options.depth)
        return;
      try {
        const entries = this.vfs.readdirSync(dirPath);
        for (const entry of entries) {
          const fullPath = dirPath === "/" ? "/" + entry : dirPath + "/" + entry;
          if (this.shouldIgnore(fullPath))
            continue;
          try {
            const stats = this.vfs.statSync(fullPath);
            if (stats.isDirectory()) {
              this.watchPath(fullPath);
              this.watchDirRecursive(fullPath, depth + 1);
            }
          } catch {
          }
        }
      } catch {
      }
    }
    unwatch(paths) {
      const pathArray = Array.isArray(paths) ? paths : [
        paths
      ];
      for (const p of pathArray) {
        const normalized = this.normalizePath(p);
        const watcher = this.watched.get(normalized);
        if (watcher) {
          watcher.close();
          this.watched.delete(normalized);
        }
      }
      return this;
    }
    close() {
      this.closed = true;
      for (const watcher of this.watched.values()) {
        watcher.close();
      }
      this.watched.clear();
      this.emit("close");
      return Promise.resolve();
    }
    getWatched() {
      const result = {};
      for (const path22 of this.watched.keys()) {
        const dir = path22.substring(0, path22.lastIndexOf("/")) || "/";
        const basename2 = path22.substring(path22.lastIndexOf("/") + 1);
        if (!result[dir]) {
          result[dir] = [];
        }
        result[dir].push(basename2);
      }
      return result;
    }
  }
  function watch$2(paths, options2) {
    const watcher = new FSWatcher(options2);
    watcher.add(paths);
    return watcher;
  }
  const chokidar = {
    watch: watch$2,
    FSWatcher,
    setVFS: setVFS$2
  };
  chokidarShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    FSWatcher,
    default: chokidar,
    setVFS: setVFS$2,
    watch: watch$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const CloseEventPolyfill = typeof CloseEvent !== "undefined" ? CloseEvent : class CloseEvent2 extends Event {
    constructor(type2, init22) {
      super(type2);
      __publicField(this, "code");
      __publicField(this, "reason");
      __publicField(this, "wasClean");
      this.code = (init22 == null ? void 0 : init22.code) ?? 1e3;
      this.reason = (init22 == null ? void 0 : init22.reason) ?? "";
      this.wasClean = (init22 == null ? void 0 : init22.wasClean) ?? true;
    }
  };
  const MessageEventPolyfill = typeof MessageEvent !== "undefined" ? MessageEvent : class MessageEvent2 extends Event {
    constructor(type2, init22) {
      super(type2);
      __publicField(this, "data");
      this.data = init22 == null ? void 0 : init22.data;
    }
  };
  let messageChannel = null;
  try {
    messageChannel = new BroadcastChannel("vite-ws-channel");
  } catch {
  }
  const servers = /* @__PURE__ */ new Map();
  let clientIdCounter = 0;
  const _WebSocket = class _WebSocket2 extends EventEmitter {
    constructor(url2, protocols) {
      super();
      __publicField(this, "CONNECTING", _WebSocket2.CONNECTING);
      __publicField(this, "OPEN", _WebSocket2.OPEN);
      __publicField(this, "CLOSING", _WebSocket2.CLOSING);
      __publicField(this, "CLOSED", _WebSocket2.CLOSED);
      __publicField(this, "readyState", _WebSocket2.CONNECTING);
      __publicField(this, "url");
      __publicField(this, "protocol", "");
      __publicField(this, "extensions", "");
      __publicField(this, "bufferedAmount", 0);
      __publicField(this, "binaryType", "blob");
      __publicField(this, "_id");
      __publicField(this, "_server", null);
      __publicField(this, "_nativeWs", null);
      __publicField(this, "onopen", null);
      __publicField(this, "onclose", null);
      __publicField(this, "onerror", null);
      __publicField(this, "onmessage", null);
      this.url = url2;
      this._id = `client-${++clientIdCounter}`;
      if (protocols) {
        this.protocol = Array.isArray(protocols) ? protocols[0] : protocols;
      }
      setTimeout(() => this._connect(), 0);
    }
    _connect() {
      if (this.url.startsWith("internal://")) {
        this.readyState = _WebSocket2.OPEN;
        this.emit("open");
        if (this.onopen)
          this.onopen(new Event("open"));
        return;
      }
      if (this.url.startsWith("ws://") || this.url.startsWith("wss://")) {
        this._connectNative();
        return;
      }
      if (!messageChannel) {
        setTimeout(() => {
          this.readyState = _WebSocket2.OPEN;
          this.emit("open");
          if (this.onopen)
            this.onopen(new Event("open"));
        }, 0);
        return;
      }
      messageChannel.postMessage({
        type: "connect",
        clientId: this._id,
        url: this.url
      });
      const channel2 = messageChannel;
      const handler = (event) => {
        const data2 = event.data;
        if (data2.targetClient !== this._id)
          return;
        switch (data2.type) {
          case "connected":
            this.readyState = _WebSocket2.OPEN;
            this.emit("open");
            if (this.onopen)
              this.onopen(new Event("open"));
            break;
          case "message":
            const msgEvent = new MessageEventPolyfill("message", {
              data: data2.payload
            });
            this.emit("message", msgEvent);
            if (this.onmessage)
              this.onmessage(msgEvent);
            break;
          case "close":
            this.readyState = _WebSocket2.CLOSED;
            const closeEvent = new CloseEventPolyfill("close", {
              code: data2.code || 1e3,
              reason: data2.reason || "",
              wasClean: true
            });
            this.emit("close", closeEvent);
            if (this.onclose)
              this.onclose(closeEvent);
            channel2.removeEventListener("message", handler);
            break;
          case "error":
            const errorEvent = new Event("error");
            this.emit("error", errorEvent);
            if (this.onerror)
              this.onerror(errorEvent);
            break;
        }
      };
      channel2.addEventListener("message", handler);
      setTimeout(() => {
        if (this.readyState === _WebSocket2.CONNECTING) {
          this.readyState = _WebSocket2.OPEN;
          this.emit("open");
          if (this.onopen)
            this.onopen(new Event("open"));
        }
      }, 100);
    }
    _connectNative() {
      const isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
      const NativeWS = isBrowser2 && typeof globalThis.WebSocket === "function" && globalThis.WebSocket !== _WebSocket2 ? globalThis.WebSocket : null;
      if (!NativeWS) {
        setTimeout(() => {
          this.readyState = _WebSocket2.OPEN;
          this.emit("open");
          if (this.onopen)
            this.onopen(new Event("open"));
        }, 0);
        return;
      }
      try {
        this._nativeWs = new NativeWS(this.url);
        this._nativeWs.binaryType = this.binaryType === "arraybuffer" ? "arraybuffer" : "blob";
      } catch {
        this.readyState = _WebSocket2.CLOSED;
        const errorEvent = new Event("error");
        this.emit("error", errorEvent);
        if (this.onerror)
          this.onerror(errorEvent);
        return;
      }
      this._nativeWs.onopen = () => {
        this.readyState = _WebSocket2.OPEN;
        this.emit("open");
        if (this.onopen)
          this.onopen(new Event("open"));
      };
      this._nativeWs.onmessage = (event) => {
        const msgEvent = new MessageEventPolyfill("message", {
          data: event.data
        });
        this.emit("message", msgEvent);
        if (this.onmessage)
          this.onmessage(msgEvent);
      };
      this._nativeWs.onclose = (event) => {
        this.readyState = _WebSocket2.CLOSED;
        this._nativeWs = null;
        const closeEvent = new CloseEventPolyfill("close", {
          code: event.code,
          reason: event.reason,
          wasClean: event.wasClean
        });
        this.emit("close", closeEvent);
        if (this.onclose)
          this.onclose(closeEvent);
      };
      this._nativeWs.onerror = () => {
        const errorEvent = new Event("error");
        this.emit("error", errorEvent);
        if (this.onerror)
          this.onerror(errorEvent);
      };
    }
    send(data2) {
      if (this.readyState !== _WebSocket2.OPEN) {
        throw new Error("WebSocket is not open");
      }
      if (this._nativeWs) {
        this._nativeWs.send(data2);
        return;
      }
      if (this._server) {
        this._server._handleClientMessage(this, data2);
        return;
      }
      if (messageChannel) {
        messageChannel.postMessage({
          type: "message",
          clientId: this._id,
          url: this.url,
          payload: data2
        });
      }
    }
    close(code2, reason) {
      if (this.readyState === _WebSocket2.CLOSED || this.readyState === _WebSocket2.CLOSING) {
        return;
      }
      this.readyState = _WebSocket2.CLOSING;
      if (this._nativeWs) {
        this._nativeWs.close(code2, reason);
        return;
      }
      if (messageChannel) {
        messageChannel.postMessage({
          type: "disconnect",
          clientId: this._id,
          url: this.url,
          code: code2,
          reason
        });
      }
      setTimeout(() => {
        this.readyState = _WebSocket2.CLOSED;
        const closeEvent = new CloseEventPolyfill("close", {
          code: code2 || 1e3,
          reason: reason || "",
          wasClean: true
        });
        this.emit("close", closeEvent);
        if (this.onclose)
          this.onclose(closeEvent);
      }, 0);
    }
    ping() {
    }
    pong() {
    }
    terminate() {
      if (this._nativeWs) {
        this._nativeWs.close();
        this._nativeWs = null;
      }
      this.readyState = _WebSocket2.CLOSED;
      const closeEvent = new CloseEventPolyfill("close", {
        code: 1006,
        reason: "Connection terminated",
        wasClean: false
      });
      this.emit("close", closeEvent);
      if (this.onclose)
        this.onclose(closeEvent);
    }
    _setServer(server) {
      this._server = server;
    }
    _receiveMessage(data2) {
      const msgEvent = new MessageEventPolyfill("message", {
        data: data2
      });
      this.emit("message", msgEvent);
      if (this.onmessage)
        this.onmessage(msgEvent);
    }
  };
  __publicField(_WebSocket, "CONNECTING", 0);
  __publicField(_WebSocket, "OPEN", 1);
  __publicField(_WebSocket, "CLOSING", 2);
  __publicField(_WebSocket, "CLOSED", 3);
  let WebSocket = _WebSocket;
  class WebSocketServer extends EventEmitter {
    constructor(options2 = {}) {
      super();
      __publicField(this, "clients", /* @__PURE__ */ new Set());
      __publicField(this, "options");
      __publicField(this, "_path");
      __publicField(this, "_channelHandler", null);
      this.options = options2;
      this._path = options2.path || "/";
      if (!options2.noServer) {
        this._setupListener();
      }
      servers.set(this._path, this);
    }
    _setupListener() {
      if (!messageChannel)
        return;
      const channel2 = messageChannel;
      this._channelHandler = (event) => {
        const data2 = event.data;
        if (data2.type === "connect") {
          const ws2 = new WebSocket("internal://" + this._path);
          ws2._setServer(this);
          ws2._clientId = data2.clientId;
          this.clients.add(ws2);
          channel2.postMessage({
            type: "connected",
            targetClient: data2.clientId
          });
          this.emit("connection", ws2, {
            url: data2.url
          });
        }
        if (data2.type === "message") {
          for (const client of this.clients) {
            if (client._clientId === data2.clientId) {
              client._receiveMessage(data2.payload);
              break;
            }
          }
        }
        if (data2.type === "disconnect") {
          for (const client of this.clients) {
            if (client._clientId === data2.clientId) {
              client.close(data2.code, data2.reason);
              this.clients.delete(client);
              break;
            }
          }
        }
      };
      channel2.addEventListener("message", this._channelHandler);
    }
    _handleClientMessage(client, data2) {
      const msgEvent = new MessageEventPolyfill("message", {
        data: data2
      });
      client.emit("message", msgEvent);
    }
    handleUpgrade(request2, socket, head, callback) {
      const ws2 = new WebSocket("internal://" + this._path);
      ws2._setServer(this);
      if (this.options.clientTracking !== false) {
        this.clients.add(ws2);
      }
      setTimeout(() => {
        callback(ws2, request2);
        this.emit("connection", ws2, request2);
      }, 0);
    }
    close(callback) {
      for (const client of this.clients) {
        client.close(1001, "Server shutting down");
      }
      this.clients.clear();
      servers.delete(this._path);
      if (this._channelHandler && messageChannel) {
        messageChannel.removeEventListener("message", this._channelHandler);
        this._channelHandler = null;
      }
      this.emit("close");
      if (callback) {
        setTimeout(callback, 0);
      }
    }
    address() {
      return {
        port: this.options.port || 0,
        family: "IPv4",
        address: this.options.host || "0.0.0.0"
      };
    }
  }
  const Server$1 = WebSocketServer;
  const createWebSocketStream = () => {
    throw new Error("createWebSocketStream is not supported in browser");
  };
  wsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Server: Server$1,
    WebSocket,
    WebSocketServer,
    createWebSocketStream,
    default: WebSocket
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const constants$1 = {
    kFSEventStreamEventFlagNone: 0,
    kFSEventStreamEventFlagMustScanSubDirs: 1,
    kFSEventStreamEventFlagUserDropped: 2,
    kFSEventStreamEventFlagKernelDropped: 4,
    kFSEventStreamEventFlagEventIdsWrapped: 8,
    kFSEventStreamEventFlagHistoryDone: 16,
    kFSEventStreamEventFlagRootChanged: 32,
    kFSEventStreamEventFlagMount: 64,
    kFSEventStreamEventFlagUnmount: 128,
    kFSEventStreamEventFlagItemCreated: 256,
    kFSEventStreamEventFlagItemRemoved: 512,
    kFSEventStreamEventFlagItemInodeMetaMod: 1024,
    kFSEventStreamEventFlagItemRenamed: 2048,
    kFSEventStreamEventFlagItemModified: 4096,
    kFSEventStreamEventFlagItemFinderInfoMod: 8192,
    kFSEventStreamEventFlagItemChangeOwner: 16384,
    kFSEventStreamEventFlagItemXattrMod: 32768,
    kFSEventStreamEventFlagItemIsFile: 65536,
    kFSEventStreamEventFlagItemIsDir: 131072,
    kFSEventStreamEventFlagItemIsSymlink: 262144
  };
  function watch$1(path22, handler) {
    return () => Promise.resolve();
  }
  function getInfo(path22, flags) {
    return {
      event: "unknown",
      path: path22,
      type: "file",
      changes: {
        inode: false,
        finder: false,
        access: false,
        xattrs: false
      },
      flags
    };
  }
  const fsevents = {
    watch: watch$1,
    getInfo,
    constants: constants$1
  };
  fseventsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    constants: constants$1,
    default: fsevents,
    getInfo,
    watch: watch$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  let globalVFS$1 = null;
  function setVFS$1(vfs2) {
    globalVFS$1 = vfs2;
  }
  class ReaddirpStream {
    constructor(root2, options2 = {}) {
      __publicField(this, "options");
      __publicField(this, "root");
      __publicField(this, "entries", []);
      __publicField(this, "index", 0);
      __publicField(this, "collected", false);
      __publicField(this, "listeners", /* @__PURE__ */ new Map());
      this.root = root2;
      this.options = options2;
    }
    matchFilter(entry, filter2) {
      if (!filter2)
        return true;
      if (typeof filter2 === "function") {
        return filter2(entry);
      }
      const patterns = Array.isArray(filter2) ? filter2 : [
        filter2
      ];
      for (const pattern of patterns) {
        if (pattern.startsWith("!")) {
          const posPattern = pattern.slice(1);
          if (this.matchGlob(entry.basename, posPattern)) {
            return false;
          }
        } else if (this.matchGlob(entry.basename, pattern)) {
          return true;
        }
      }
      return patterns.length === 0 || patterns.every((p) => p.startsWith("!"));
    }
    matchGlob(name2, pattern) {
      if (pattern === "*")
        return true;
      if (pattern.startsWith("*.")) {
        const ext2 = pattern.slice(1);
        return name2.endsWith(ext2);
      }
      if (pattern.endsWith("*")) {
        const prefix = pattern.slice(0, -1);
        return name2.startsWith(prefix);
      }
      return name2 === pattern;
    }
    collect(dir, depth, relativePath = "") {
      if (!globalVFS$1)
        return;
      if (this.options.depth !== void 0 && depth > this.options.depth)
        return;
      try {
        const entries = globalVFS$1.readdirSync(dir);
        for (const name2 of entries) {
          const fullPath = dir === "/" ? "/" + name2 : dir + "/" + name2;
          const relPath = relativePath ? relativePath + "/" + name2 : name2;
          try {
            const stats = globalVFS$1.statSync(fullPath);
            const isDir = stats.isDirectory();
            const entry = {
              path: relPath,
              fullPath,
              basename: name2,
              stats: this.options.alwaysStat ? stats : void 0,
              dirent: {
                isFile: () => !isDir,
                isDirectory: () => isDir,
                name: name2
              }
            };
            const type2 = this.options.type || "files";
            if (isDir) {
              if (!this.matchFilter(entry, this.options.directoryFilter)) {
                continue;
              }
              if (type2 === "directories" || type2 === "files_directories" || type2 === "all") {
                this.entries.push(entry);
              }
              this.collect(fullPath, depth + 1, relPath);
            } else {
              if (type2 === "files" || type2 === "files_directories" || type2 === "all") {
                if (this.matchFilter(entry, this.options.fileFilter)) {
                  this.entries.push(entry);
                }
              }
            }
          } catch {
          }
        }
      } catch {
      }
    }
    async *[Symbol.asyncIterator]() {
      if (!this.collected) {
        this.collect(this.root, 0);
        this.collected = true;
      }
      for (const entry of this.entries) {
        yield entry;
      }
    }
    async toArray() {
      if (!this.collected) {
        this.collect(this.root, 0);
        this.collected = true;
      }
      return [
        ...this.entries
      ];
    }
    on(event, callback) {
      if (event === "data") {
        setTimeout(async () => {
          if (!this.collected) {
            this.collect(this.root, 0);
            this.collected = true;
          }
          for (const entry of this.entries) {
            callback(entry);
          }
          this.emit("end");
        }, 0);
      }
      return this;
    }
    emit(event, ...args) {
      const handlers = this.listeners.get(event);
      if (handlers) {
        for (const handler of handlers) {
          handler(...args);
        }
      }
    }
    once(event, callback) {
      const wrapper = (...args) => {
        callback(...args);
        this.off(event, wrapper);
      };
      return this.on(event, wrapper);
    }
    off(event, callback) {
      const handlers = this.listeners.get(event);
      if (handlers) {
        const index2 = handlers.indexOf(callback);
        if (index2 !== -1) {
          handlers.splice(index2, 1);
        }
      }
      return this;
    }
  }
  function readdirp(root2, options2) {
    return new ReaddirpStream(root2, options2);
  }
  async function readdirpPromise(root2, options2) {
    const stream2 = new ReaddirpStream(root2, options2);
    return stream2.toArray();
  }
  readdirpShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    ReaddirpStream,
    default: readdirp,
    readdirp,
    readdirpPromise,
    setVFS: setVFS$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function createRequire$1(filename2) {
    return function require2(id2) {
      throw new Error(`Cannot find module '${id2}' from '${filename2}'`);
    };
  }
  const builtinModules$1 = [
    "assert",
    "buffer",
    "child_process",
    "cluster",
    "console",
    "constants",
    "crypto",
    "dgram",
    "dns",
    "domain",
    "events",
    "fs",
    "http",
    "https",
    "module",
    "net",
    "os",
    "path",
    "perf_hooks",
    "process",
    "punycode",
    "querystring",
    "readline",
    "repl",
    "stream",
    "string_decoder",
    "sys",
    "timers",
    "tls",
    "tty",
    "url",
    "util",
    "v8",
    "vm",
    "worker_threads",
    "zlib"
  ];
  function isBuiltin(moduleName) {
    const name2 = moduleName.startsWith("node:") ? moduleName.slice(5) : moduleName;
    return builtinModules$1.includes(name2);
  }
  const _cache = {};
  const _extensions = {
    ".js": () => {
    },
    ".json": () => {
    },
    ".node": () => {
    }
  };
  const _pathCache = {};
  function syncBuiltinESMExports() {
  }
  const Module$1 = {
    createRequire: createRequire$1,
    builtinModules: builtinModules$1,
    isBuiltin,
    _cache,
    _extensions,
    _pathCache,
    syncBuiltinESMExports
  };
  moduleShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Module: Module$1,
    _cache,
    _extensions,
    _pathCache,
    builtinModules: builtinModules$1,
    createRequire: createRequire$1,
    default: Module$1,
    isBuiltin,
    syncBuiltinESMExports
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const performance$1 = globalThis.performance || {
    now: () => Date.now(),
    timeOrigin: Date.now(),
    mark: () => {
    },
    measure: () => {
    },
    getEntries: () => [],
    getEntriesByName: () => [],
    getEntriesByType: () => [],
    clearMarks: () => {
    },
    clearMeasures: () => {
    },
    clearResourceTimings: () => {
    }
  };
  class PerformanceObserver {
    constructor(callback) {
      __publicField(this, "callback");
      __publicField(this, "entryTypes", []);
      this.callback = callback;
    }
    observe(options2) {
      this.entryTypes = options2.entryTypes || (options2.type ? [
        options2.type
      ] : []);
    }
    disconnect() {
      this.entryTypes = [];
    }
    takeRecords() {
      return [];
    }
  }
  __publicField(PerformanceObserver, "supportedEntryTypes", [
    "mark",
    "measure",
    "resource",
    "navigation"
  ]);
  class Histogram {
    constructor() {
      __publicField(this, "min", 0);
      __publicField(this, "max", 0);
      __publicField(this, "mean", 0);
      __publicField(this, "stddev", 0);
      __publicField(this, "percentiles", /* @__PURE__ */ new Map());
      __publicField(this, "exceeds", 0);
    }
    reset() {
      this.min = 0;
      this.max = 0;
      this.mean = 0;
      this.stddev = 0;
      this.percentiles.clear();
      this.exceeds = 0;
    }
    percentile(percentile) {
      return this.percentiles.get(percentile) || 0;
    }
  }
  function createHistogram() {
    return new Histogram();
  }
  function monitorEventLoopDelay(options2) {
    const histogram = new Histogram();
    return histogram;
  }
  const perf_hooks = {
    performance: performance$1,
    PerformanceObserver,
    createHistogram,
    monitorEventLoopDelay
  };
  perfHooksShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Histogram,
    PerformanceObserver,
    createHistogram,
    default: perf_hooks,
    monitorEventLoopDelay,
    performance: performance$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const isMainThread = true;
  const parentPort = null;
  const workerData = null;
  const threadId = 0;
  let Worker$2 = class Worker extends EventEmitter {
    constructor(filename2, options2) {
      super();
      __publicField(this, "threadId", 0);
      __publicField(this, "resourceLimits", {});
      console.warn("Worker threads are not fully supported in browser environment");
    }
    postMessage(value2, transferList) {
    }
    terminate() {
      return Promise.resolve(0);
    }
    ref() {
    }
    unref() {
    }
    getHeapSnapshot() {
      return Promise.resolve({});
    }
  };
  let MessageChannel$1 = class MessageChannel {
    constructor() {
      __publicField(this, "port1", new MessagePort());
      __publicField(this, "port2", new MessagePort());
    }
  };
  class MessagePort extends EventEmitter {
    postMessage(value2, transferList) {
    }
    start() {
    }
    close() {
    }
    ref() {
    }
    unref() {
    }
  }
  let BroadcastChannel$1 = class BroadcastChannel extends EventEmitter {
    constructor(name2) {
      super();
      __publicField(this, "name");
      this.name = name2;
    }
    postMessage(message) {
    }
    close() {
    }
    ref() {
    }
    unref() {
    }
  };
  function moveMessagePortToContext(port, contextifiedSandbox) {
    return port;
  }
  function receiveMessageOnPort(port) {
    return void 0;
  }
  const SHARE_ENV = Symbol.for("nodejs.worker_threads.SHARE_ENV");
  function markAsUntransferable(object) {
  }
  function getEnvironmentData(key) {
    return void 0;
  }
  function setEnvironmentData(key, value2) {
  }
  const worker_threads = {
    isMainThread,
    parentPort,
    workerData,
    threadId,
    Worker: Worker$2,
    MessageChannel: MessageChannel$1,
    MessagePort,
    BroadcastChannel: BroadcastChannel$1,
    moveMessagePortToContext,
    receiveMessageOnPort,
    SHARE_ENV,
    markAsUntransferable,
    getEnvironmentData,
    setEnvironmentData
  };
  workerThreadsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    BroadcastChannel: BroadcastChannel$1,
    MessageChannel: MessageChannel$1,
    MessagePort,
    SHARE_ENV,
    Worker: Worker$2,
    default: worker_threads,
    getEnvironmentData,
    isMainThread,
    markAsUntransferable,
    moveMessagePortToContext,
    parentPort,
    receiveMessageOnPort,
    setEnvironmentData,
    threadId,
    workerData
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const EXPORT_CONDITION_PRIORITY = [
    "convex",
    "module",
    "import",
    "require",
    "default"
  ];
  function resolveExportConditions(entry) {
    if (typeof entry === "string") {
      return entry;
    }
    if (typeof entry === "object" && entry !== null) {
      for (const condition of EXPORT_CONDITION_PRIORITY) {
        const conditionValue = entry[condition];
        if (conditionValue !== void 0) {
          const result = resolveExportConditions(conditionValue);
          if (result) {
            return result;
          }
        }
      }
    }
    return void 0;
  }
  function resolveNodeModuleImport(vfs2, importPath, extensions) {
    const pathParts = importPath.split("/");
    const isScoped = pathParts[0].startsWith("@");
    const moduleName = isScoped ? pathParts.slice(0, 2).join("/") : pathParts[0];
    const subPath = isScoped ? pathParts.slice(2).join("/") : pathParts.slice(1).join("/");
    const nodeModulesBase = "/project/node_modules/" + moduleName;
    if (!vfs2.existsSync(nodeModulesBase)) {
      return null;
    }
    const packageJsonPath = nodeModulesBase + "/package.json";
    if (!vfs2.existsSync(packageJsonPath)) {
      return null;
    }
    try {
      const packageJsonContent = vfs2.readFileSync(packageJsonPath, "utf8");
      const packageJson = JSON.parse(packageJsonContent);
      let resolvedPath2 = null;
      if (subPath) {
        resolvedPath2 = resolveSubpathImport(vfs2, packageJson, nodeModulesBase, subPath, extensions);
      } else {
        resolvedPath2 = resolveMainImport(vfs2, packageJson, nodeModulesBase, extensions);
      }
      if (resolvedPath2) {
        return {
          path: resolvedPath2,
          pluginData: {
            fromVFS: true
          }
        };
      }
    } catch {
    }
    return null;
  }
  function resolveSubpathImport(vfs2, packageJson, nodeModulesBase, subPath, extensions) {
    if (packageJson.exports && typeof packageJson.exports === "object") {
      const exportKey = "./" + subPath;
      const exportsMap = packageJson.exports;
      const exportEntry = exportsMap[exportKey];
      if (exportEntry) {
        const exportPath = resolveExportConditions(exportEntry);
        if (exportPath) {
          const resolvedPath2 = nodeModulesBase + "/" + exportPath.replace(/^\.\//, "");
          const foundPath = findVFSFile(vfs2, resolvedPath2, [
            "",
            ".js",
            ".ts",
            ".mjs"
          ]);
          if (foundPath) {
            return foundPath;
          }
        }
      }
    }
    const directPath = nodeModulesBase + "/" + subPath;
    return findVFSFile(vfs2, directPath, extensions);
  }
  function resolveMainImport(vfs2, packageJson, nodeModulesBase, extensions) {
    if (packageJson.exports) {
      const mainExport = typeof packageJson.exports === "object" && !Array.isArray(packageJson.exports) ? packageJson.exports["."] || packageJson.exports : packageJson.exports;
      const exportPath = resolveExportConditions(mainExport);
      if (exportPath) {
        const resolvedPath22 = nodeModulesBase + "/" + exportPath.replace(/^\.\//, "");
        const foundPath = findVFSFile(vfs2, resolvedPath22, [
          "",
          ".js",
          ".ts",
          ".mjs"
        ]);
        if (foundPath) {
          return foundPath;
        }
      }
    }
    const mainField = packageJson.module || packageJson.main || "index.js";
    const resolvedPath2 = nodeModulesBase + "/" + mainField.replace(/^\.\//, "");
    return findVFSFile(vfs2, resolvedPath2, extensions);
  }
  let esbuildInstance = null;
  let initPromise = null;
  let wasmURL = "https://unpkg.com/esbuild-wasm@0.20.0/esbuild.wasm";
  let globalVFS = null;
  function setVFS(vfs2) {
    globalVFS = vfs2;
  }
  function setWasmURL(url2) {
    wasmURL = url2;
  }
  async function initialize(options2) {
    if (esbuildInstance) {
      return;
    }
    if (typeof window !== "undefined" && window.__esbuild) {
      esbuildInstance = window.__esbuild;
      return;
    }
    if (typeof window !== "undefined" && window.__esbuildInitPromise) {
      await window.__esbuildInitPromise;
      if (window.__esbuild) {
        esbuildInstance = window.__esbuild;
        return;
      }
    }
    if (initPromise) {
      return initPromise;
    }
    initPromise = (async () => {
      try {
        const esbuild2 = await import("https://unpkg.com/esbuild-wasm@0.20.0/esm/browser.min.js").then(async (m) => {
          await m.__tla;
          return m;
        });
        await esbuild2.initialize({
          wasmURL: (options2 == null ? void 0 : options2.wasmURL) || wasmURL
        });
        esbuildInstance = esbuild2;
      } catch (error) {
        initPromise = null;
        throw new Error(`Failed to initialize esbuild-wasm: ${error}`);
      }
    })();
    return initPromise;
  }
  function isInitialized() {
    return esbuildInstance !== null;
  }
  async function transform(code2, options2) {
    if (!esbuildInstance) {
      await initialize();
    }
    if (!esbuildInstance) {
      throw new Error("esbuild not initialized");
    }
    return esbuildInstance.transform(code2, options2);
  }
  function transformSync(code2, options2) {
    if (!esbuildInstance) {
      throw new Error("esbuild not initialized. Call initialize() first.");
    }
    throw new Error("transformSync is not available in browser. Use transform() instead.");
  }
  async function transformToCommonJS(code2, options2) {
    const result = await transform(code2, {
      loader: (options2 == null ? void 0 : options2.loader) || "js",
      format: "cjs",
      target: "es2020"
    });
    return result.code;
  }
  function remapVFSPath(path22) {
    if (path22 === "/convex" || path22.startsWith("/convex/")) {
      return "/project" + path22;
    }
    return path22;
  }
  function findVFSFile(vfs2, originalPath, extensions) {
    for (const ext2 of extensions) {
      const pathWithExt = originalPath + ext2;
      if (vfs2.existsSync(pathWithExt)) {
        return pathWithExt;
      }
      const remapped = remapVFSPath(pathWithExt);
      if (remapped !== pathWithExt && vfs2.existsSync(remapped)) {
        return pathWithExt;
      }
    }
    return null;
  }
  function createVFSPlugin() {
    if (!globalVFS) {
      return null;
    }
    const vfs2 = globalVFS;
    return {
      name: "vfs-loader",
      setup(build2) {
        const b = build2;
        b.onResolve({
          filter: /.*/
        }, (args) => {
          const { path: importPath, importer } = args;
          if (importPath.startsWith("node_modules/")) {
            return {
              external: true
            };
          }
          const extensions = [
            "",
            ".ts",
            ".tsx",
            ".js",
            ".jsx",
            ".json"
          ];
          if (importPath.startsWith("/")) {
            const foundPath = findVFSFile(vfs2, importPath, extensions);
            if (foundPath) {
              return {
                path: foundPath,
                pluginData: {
                  fromVFS: true
                }
              };
            }
            return {
              external: true
            };
          }
          if (importPath.startsWith(".")) {
            let resolved = importPath;
            if (importer) {
              const importerDir = importer.substring(0, importer.lastIndexOf("/"));
              resolved = importerDir + "/" + importPath;
            }
            const parts = resolved.split("/").filter(Boolean);
            const normalized = [];
            for (const part of parts) {
              if (part === "..") {
                normalized.pop();
              } else if (part !== ".") {
                normalized.push(part);
              }
            }
            resolved = "/" + normalized.join("/");
            const foundPath = findVFSFile(vfs2, resolved, extensions);
            if (foundPath) {
              return {
                path: foundPath,
                pluginData: {
                  fromVFS: true
                }
              };
            }
            for (const ext2 of [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]) {
              const indexPath = resolved + "/index" + ext2;
              const foundIndex = findVFSFile(vfs2, indexPath, [
                ""
              ]);
              if (foundIndex) {
                return {
                  path: foundIndex,
                  pluginData: {
                    fromVFS: true
                  }
                };
              }
            }
          }
          const resolution2 = resolveNodeModuleImport(vfs2, importPath, extensions);
          if (resolution2) {
            return resolution2;
          }
          return {
            external: true
          };
        });
        b.onLoad({
          filter: /^\/.*/
        }, (args) => {
          var _a22;
          if (!((_a22 = args.pluginData) == null ? void 0 : _a22.fromVFS)) {
            return null;
          }
          try {
            let contents;
            const originalPath = args.path;
            const remappedPath = remapVFSPath(originalPath);
            if (vfs2.existsSync(originalPath)) {
              contents = vfs2.readFileSync(originalPath, "utf8");
            } else if (remappedPath !== originalPath && vfs2.existsSync(remappedPath)) {
              contents = vfs2.readFileSync(remappedPath, "utf8");
            } else {
              throw new Error(`File not found: ${originalPath} (tried ${remappedPath})`);
            }
            const ext2 = originalPath.substring(originalPath.lastIndexOf("."));
            let loader = "ts";
            if (ext2 === ".tsx")
              loader = "tsx";
            else if (ext2 === ".js")
              loader = "js";
            else if (ext2 === ".jsx")
              loader = "jsx";
            else if (ext2 === ".json")
              loader = "json";
            return {
              contents,
              loader
            };
          } catch (err2) {
            return {
              errors: [
                {
                  text: `Failed to load ${args.path}: ${err2}`
                }
              ]
            };
          }
        });
      }
    };
  }
  async function build(options2) {
    if (!esbuildInstance) {
      await initialize();
    }
    if (!esbuildInstance) {
      throw new Error("esbuild not initialized");
    }
    const vfsPlugin = createVFSPlugin();
    const plugins = [
      ...options2.plugins || []
    ];
    if (vfsPlugin) {
      plugins.unshift(vfsPlugin);
    }
    let entryPoints = options2.entryPoints;
    if (entryPoints && globalVFS) {
      const absWorkingDir = options2.absWorkingDir || (typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/");
      entryPoints = entryPoints.map((ep2) => {
        if (ep2.includes("vfs:")) {
          const vfsIndex = ep2.indexOf("vfs:");
          ep2 = ep2.substring(vfsIndex + 4);
        }
        if (ep2.startsWith("/")) {
          return ep2;
        }
        if (ep2.startsWith("./")) {
          const base = absWorkingDir.endsWith("/") ? absWorkingDir.slice(0, -1) : absWorkingDir;
          const relative2 = ep2.slice(2);
          const resolved = base + "/" + relative2;
          return resolved;
        }
        if (ep2.startsWith("../")) {
          const base = absWorkingDir.endsWith("/") ? absWorkingDir.slice(0, -1) : absWorkingDir;
          const parts = base.split("/").filter(Boolean);
          parts.pop();
          const relative2 = ep2.slice(3);
          const resolved = "/" + parts.join("/") + "/" + relative2;
          return resolved;
        }
        return ep2;
      });
    }
    const resolvedAbsWorkingDir = options2.absWorkingDir || (typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/");
    const result = await esbuildInstance.build({
      ...options2,
      entryPoints,
      plugins,
      write: false,
      absWorkingDir: resolvedAbsWorkingDir
    });
    if (result.outputFiles) {
      for (const file of result.outputFiles) {
        if (file.path.includes("vfs:")) {
          file.path = file.path.replace(/vfs:/g, "");
        }
      }
    }
    return result;
  }
  function buildSync(_options2) {
    throw new Error("buildSync is not available in browser. Use build() instead.");
  }
  function version$1() {
    return "0.20.0";
  }
  async function context(_options2) {
    throw new Error("esbuild context API is not supported in browser");
  }
  const esbuild = {
    initialize,
    isInitialized,
    transform,
    transformSync,
    transformToCommonJS,
    build,
    buildSync,
    context,
    version: version$1,
    setWasmURL,
    setVFS
  };
  esbuildShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    build,
    buildSync,
    context,
    default: esbuild,
    initialize,
    isInitialized,
    setVFS,
    setWasmURL,
    transform,
    transformSync,
    transformToCommonJS,
    version: version$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  let rollupInstance = null;
  let loadPromise = null;
  async function loadRollup() {
    if (rollupInstance)
      return rollupInstance;
    if (loadPromise)
      return loadPromise;
    loadPromise = (async () => {
      try {
        const rollup2 = await import("https://esm.sh/@rollup/browser@4.9.0").then(async (m) => {
          await m.__tla;
          return m;
        });
        rollupInstance = rollup2;
        console.log("[rollup] Browser version loaded");
        return rollup2;
      } catch (error) {
        console.error("[rollup] Failed to load browser version:", error);
        loadPromise = null;
        throw error;
      }
    })();
    return loadPromise;
  }
  const VERSION = "4.9.0";
  async function rollup(options2) {
    const r10 = await loadRollup();
    return r10.rollup(options2);
  }
  async function watch(options2) {
    const r10 = await loadRollup();
    return r10.watch(options2);
  }
  function getPackageBase() {
    return "";
  }
  const rollup_default = {
    VERSION,
    rollup,
    watch,
    loadRollup
  };
  rollupShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    VERSION,
    default: rollup_default,
    getPackageBase,
    loadRollup,
    rollup,
    watch
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function getHeapStatistics() {
    return {
      total_heap_size: 0,
      total_heap_size_executable: 0,
      total_physical_size: 0,
      total_available_size: 0,
      used_heap_size: 0,
      heap_size_limit: 0,
      malloced_memory: 0,
      peak_malloced_memory: 0,
      does_zap_garbage: 0,
      number_of_native_contexts: 0,
      number_of_detached_contexts: 0
    };
  }
  function getHeapSpaceStatistics() {
    return [];
  }
  function getHeapCodeStatistics() {
    return {
      code_and_metadata_size: 0,
      bytecode_and_metadata_size: 0,
      external_script_source_size: 0
    };
  }
  function getHeapSnapshot() {
    return null;
  }
  function writeHeapSnapshot() {
    return "";
  }
  function setFlagsFromString(_flags) {
  }
  function takeCoverage() {
  }
  function stopCoverage() {
  }
  function serialize(value2) {
    const json = JSON.stringify(value2);
    return Buffer.from(json);
  }
  function deserialize(buffer2) {
    return JSON.parse(buffer2.toString());
  }
  class Serializer {
    writeHeader() {
    }
    writeValue(_value) {
    }
    releaseBuffer() {
      return Buffer.from("");
    }
  }
  class Deserializer {
    constructor(_buffer) {
    }
    readHeader() {
      return true;
    }
    readValue() {
      return null;
    }
  }
  class DefaultSerializer extends Serializer {
  }
  class DefaultDeserializer extends Deserializer {
  }
  function promiseHooks() {
    return {
      onInit: () => {
      },
      onSettled: () => {
      },
      onBefore: () => {
      },
      onAfter: () => {
      },
      createHook: () => ({
        enable: () => {
        },
        disable: () => {
        }
      })
    };
  }
  const v8 = {
    getHeapStatistics,
    getHeapSpaceStatistics,
    getHeapCodeStatistics,
    getHeapSnapshot,
    writeHeapSnapshot,
    setFlagsFromString,
    takeCoverage,
    stopCoverage,
    serialize,
    deserialize,
    Serializer,
    Deserializer,
    DefaultSerializer,
    DefaultDeserializer,
    promiseHooks
  };
  const v8Shim = Object.freeze(Object.defineProperty({
    __proto__: null,
    DefaultDeserializer,
    DefaultSerializer,
    Deserializer,
    Serializer,
    default: v8,
    deserialize,
    getHeapCodeStatistics,
    getHeapSnapshot,
    getHeapSpaceStatistics,
    getHeapStatistics,
    promiseHooks,
    serialize,
    setFlagsFromString,
    stopCoverage,
    takeCoverage,
    writeHeapSnapshot
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Interface extends EventEmitter {
    constructor(_options2) {
      super();
      __publicField(this, "promptText");
      __publicField(this, "line", "");
      __publicField(this, "cursor", 0);
      this.promptText = (_options2 == null ? void 0 : _options2.prompt) ?? "";
    }
    prompt(_preserveCursor) {
    }
    setPrompt(prompt) {
      this.promptText = prompt;
    }
    getPrompt() {
      return this.promptText;
    }
    question(_query, callback) {
      setTimeout(() => callback(""), 0);
    }
    pause() {
      return this;
    }
    resume() {
      return this;
    }
    close() {
      this.emit("close");
    }
    write(_data, _key) {
    }
    getCursorPos() {
      return {
        rows: 0,
        cols: 0
      };
    }
  }
  function createInterface(options2) {
    return new Interface(options2);
  }
  function clearLine(_stream, _dir, _callback) {
    _callback == null ? void 0 : _callback();
    return true;
  }
  function clearScreenDown(_stream, _callback) {
    _callback == null ? void 0 : _callback();
    return true;
  }
  function cursorTo(_stream, _x2, _y2, _callback) {
    _callback == null ? void 0 : _callback();
    return true;
  }
  function moveCursor(_stream, _dx, _dy, _callback) {
    _callback == null ? void 0 : _callback();
    return true;
  }
  function emitKeypressEvents(_stream, _interface) {
  }
  const promises = {
    createInterface: (options2) => {
      const rl2 = createInterface(options2);
      return {
        question: (query) => new Promise((resolve2) => {
          rl2.question(query, resolve2);
        }),
        close: () => rl2.close(),
        [Symbol.asyncIterator]: async function* () {
        }
      };
    }
  };
  const readline = {
    Interface,
    createInterface,
    clearLine,
    clearScreenDown,
    cursorTo,
    moveCursor,
    emitKeypressEvents,
    promises
  };
  const readlineShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Interface,
    clearLine,
    clearScreenDown,
    createInterface,
    cursorTo,
    default: readline,
    emitKeypressEvents,
    moveCursor,
    promises
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class TLSSocket extends EventEmitter {
    constructor(_socket, _options2) {
      super();
      __publicField(this, "authorized", false);
      __publicField(this, "encrypted", true);
    }
    getPeerCertificate(_detailed) {
      return {};
    }
    getCipher() {
      return null;
    }
    getProtocol() {
      return null;
    }
    setServername(_name) {
    }
    renegotiate(_options2, _callback) {
      return false;
    }
  }
  class Server extends EventEmitter {
    constructor(_options2, _connectionListener) {
      super();
    }
    listen(..._args) {
      return this;
    }
    close(_callback) {
      return this;
    }
    address() {
      return null;
    }
    getTicketKeys() {
      return Buffer.from("");
    }
    setTicketKeys(_keys) {
    }
    setSecureContext(_options2) {
    }
  }
  function createServer$1(_options2, _connectionListener) {
    return new Server(_options2, _connectionListener);
  }
  function connect$1(_options2, _callback) {
    const socket = new TLSSocket();
    if (_callback) {
      setTimeout(_callback, 0);
    }
    return socket;
  }
  const createSecureContext = (_options2) => ({});
  const getCiphers = () => [
    "TLS_AES_256_GCM_SHA384",
    "TLS_AES_128_GCM_SHA256"
  ];
  const DEFAULT_ECDH_CURVE = "auto";
  const DEFAULT_MAX_VERSION = "TLSv1.3";
  const DEFAULT_MIN_VERSION = "TLSv1.2";
  const rootCertificates = [];
  const tls = {
    TLSSocket,
    Server,
    createServer: createServer$1,
    connect: connect$1,
    createSecureContext,
    getCiphers,
    DEFAULT_ECDH_CURVE,
    DEFAULT_MAX_VERSION,
    DEFAULT_MIN_VERSION,
    rootCertificates
  };
  const tlsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    DEFAULT_ECDH_CURVE,
    DEFAULT_MAX_VERSION,
    DEFAULT_MIN_VERSION,
    Server,
    TLSSocket,
    connect: connect$1,
    createSecureContext,
    createServer: createServer$1,
    default: tls,
    getCiphers,
    rootCertificates
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Http2Session extends EventEmitter {
    close(_callback) {
      if (_callback)
        setTimeout(_callback, 0);
    }
    destroy(_error, _code) {
    }
    get destroyed() {
      return false;
    }
    get encrypted() {
      return false;
    }
    get closed() {
      return false;
    }
    ping(_callback) {
      return false;
    }
    ref() {
    }
    unref() {
    }
    setTimeout(_msecs, _callback) {
    }
  }
  class ClientHttp2Session extends Http2Session {
  }
  class ServerHttp2Session extends Http2Session {
  }
  class Http2Stream extends EventEmitter {
    close(_code, _callback) {
    }
    get id() {
      return 0;
    }
    get pending() {
      return false;
    }
    get destroyed() {
      return false;
    }
    get closed() {
      return false;
    }
    priority(_options2) {
    }
    setTimeout(_msecs, _callback) {
    }
    end(_data, _encoding, _callback) {
    }
  }
  class Http2ServerRequest extends EventEmitter {
  }
  class Http2ServerResponse extends EventEmitter {
    writeHead(_statusCode, _headers) {
      return this;
    }
    end(_data) {
    }
  }
  function createServer(_options2, _onRequestHandler) {
    return new EventEmitter();
  }
  function createSecureServer(_options2, _onRequestHandler) {
    return new EventEmitter();
  }
  function connect(_authority, _options2, _listener) {
    return new ClientHttp2Session();
  }
  const constants = {
    NGHTTP2_SESSION_SERVER: 0,
    NGHTTP2_SESSION_CLIENT: 1,
    HTTP2_HEADER_STATUS: ":status",
    HTTP2_HEADER_METHOD: ":method",
    HTTP2_HEADER_AUTHORITY: ":authority",
    HTTP2_HEADER_SCHEME: ":scheme",
    HTTP2_HEADER_PATH: ":path",
    HTTP_STATUS_OK: 200,
    HTTP_STATUS_NOT_FOUND: 404
  };
  function getDefaultSettings() {
    return {};
  }
  function getPackedSettings(_settings) {
    return Buffer.from("");
  }
  function getUnpackedSettings(_buf) {
    return {};
  }
  const sensitiveHeaders = Symbol("sensitiveHeaders");
  const http2 = {
    Http2Session,
    ClientHttp2Session,
    ServerHttp2Session,
    Http2Stream,
    Http2ServerRequest,
    Http2ServerResponse,
    createServer,
    createSecureServer,
    connect,
    constants,
    getDefaultSettings,
    getPackedSettings,
    getUnpackedSettings,
    sensitiveHeaders
  };
  const http2Shim = Object.freeze(Object.defineProperty({
    __proto__: null,
    ClientHttp2Session,
    Http2ServerRequest,
    Http2ServerResponse,
    Http2Session,
    Http2Stream,
    ServerHttp2Session,
    connect,
    constants,
    createSecureServer,
    createServer,
    default: http2,
    getDefaultSettings,
    getPackedSettings,
    getUnpackedSettings,
    sensitiveHeaders
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const isMaster = true;
  const isPrimary = true;
  const isWorker = false;
  let Worker$1 = class Worker extends EventEmitter {
    constructor() {
      super(...arguments);
      __publicField(this, "id", 0);
      __publicField(this, "process", null);
    }
    send(_message, _callback) {
      return false;
    }
    kill(_signal) {
    }
    disconnect() {
    }
    isDead() {
      return false;
    }
    isConnected() {
      return false;
    }
  };
  const worker = null;
  const workers = {};
  function fork$1(_env) {
    return new Worker$1();
  }
  function disconnect(_callback) {
    if (_callback)
      setTimeout(_callback, 0);
  }
  const settings = {};
  const SCHED_NONE = 1;
  const SCHED_RR = 2;
  let schedulingPolicy = SCHED_RR;
  function setupMaster(_settings) {
  }
  function setupPrimary(_settings) {
  }
  const clusterEmitter = new EventEmitter();
  const on = clusterEmitter.on.bind(clusterEmitter);
  const once = clusterEmitter.once.bind(clusterEmitter);
  const emit = clusterEmitter.emit.bind(clusterEmitter);
  const removeListener = clusterEmitter.removeListener.bind(clusterEmitter);
  const cluster = {
    isMaster,
    isPrimary,
    isWorker,
    Worker: Worker$1,
    worker,
    workers,
    fork: fork$1,
    disconnect,
    settings,
    SCHED_NONE,
    SCHED_RR,
    schedulingPolicy,
    setupMaster,
    setupPrimary,
    on,
    once,
    emit,
    removeListener
  };
  const clusterShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    SCHED_NONE,
    SCHED_RR,
    Worker: Worker$1,
    default: cluster,
    disconnect,
    emit,
    fork: fork$1,
    isMaster,
    isPrimary,
    isWorker,
    on,
    once,
    removeListener,
    schedulingPolicy,
    settings,
    setupMaster,
    setupPrimary,
    worker,
    workers
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Socket extends EventEmitter {
    bind(_port, _address, _callback) {
      if (_callback)
        setTimeout(_callback, 0);
      return this;
    }
    close(_callback) {
      if (_callback)
        setTimeout(_callback, 0);
    }
    send(_msg, _offset, _length, _port, _address, _callback) {
      if (_callback)
        setTimeout(() => _callback(null, 0), 0);
    }
    address() {
      return {
        address: "0.0.0.0",
        family: "IPv4",
        port: 0
      };
    }
    setBroadcast(_flag) {
    }
    setTTL(_ttl) {
      return _ttl;
    }
    setMulticastTTL(_ttl) {
      return _ttl;
    }
    setMulticastLoopback(_flag) {
      return _flag;
    }
    setMulticastInterface(_multicastInterface) {
    }
    addMembership(_multicastAddress, _multicastInterface) {
    }
    dropMembership(_multicastAddress, _multicastInterface) {
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    setRecvBufferSize(_size) {
    }
    setSendBufferSize(_size) {
    }
    getRecvBufferSize() {
      return 0;
    }
    getSendBufferSize() {
      return 0;
    }
  }
  function createSocket(_type, _callback) {
    return new Socket();
  }
  const dgram = {
    Socket,
    createSocket
  };
  const dgramShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Socket,
    createSocket,
    default: dgram
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Script {
    constructor(code2, _options2) {
      __publicField(this, "code");
      this.code = code2;
    }
    runInThisContext(_options) {
      return eval(this.code);
    }
    runInNewContext(contextObject, _options2) {
      const keys = contextObject ? Object.keys(contextObject) : [];
      const values = contextObject ? Object.values(contextObject) : [];
      const fn22 = new Function(...keys, `return eval(${JSON.stringify(this.code)})`);
      return fn22(...values);
    }
    runInContext(_context, _options2) {
      return this.runInNewContext(_context, _options2);
    }
    createCachedData() {
      return Buffer.from("");
    }
  }
  function createContext(contextObject, _options2) {
    return contextObject || {};
  }
  function isContext(_sandbox) {
    return true;
  }
  function runInThisContext(code, _options) {
    return eval(code);
  }
  function runInNewContext(code2, contextObject, _options2) {
    const script = new Script(code2);
    return script.runInNewContext(contextObject);
  }
  function runInContext(code2, context2, _options2) {
    return runInNewContext(code2, context2);
  }
  function compileFunction(code2, params, _options2) {
    return new Function(...params || [], code2);
  }
  class Module {
    constructor(_code, _options2) {
    }
    link(_linker) {
      return Promise.resolve();
    }
    evaluate(_options2) {
      return Promise.resolve();
    }
    get status() {
      return "unlinked";
    }
    get identifier() {
      return "";
    }
    get context() {
      return {};
    }
    get namespace() {
      return {};
    }
  }
  class SourceTextModule extends Module {
  }
  class SyntheticModule extends Module {
    setExport(_name, _value) {
    }
  }
  const vm = {
    Script,
    createContext,
    isContext,
    runInThisContext,
    runInNewContext,
    runInContext,
    compileFunction,
    Module,
    SourceTextModule,
    SyntheticModule
  };
  const vmShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Module,
    Script,
    SourceTextModule,
    SyntheticModule,
    compileFunction,
    createContext,
    default: vm,
    isContext,
    runInContext,
    runInNewContext,
    runInThisContext
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Session extends EventEmitter {
    connect() {
    }
    connectToMainThread() {
    }
    disconnect() {
    }
    post(_method, _params, _callback) {
      if (_callback)
        setTimeout(() => _callback(null, {}), 0);
    }
  }
  function open(_port, _host, _wait) {
  }
  function close$1() {
  }
  function url() {
    return void 0;
  }
  function waitForDebugger() {
  }
  const console$1 = globalThis.console;
  const inspector = {
    Session,
    open,
    close: close$1,
    url,
    waitForDebugger,
    console: console$1
  };
  const inspectorShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Session,
    close: close$1,
    console: console$1,
    default: inspector,
    open,
    url,
    waitForDebugger
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class AsyncResource {
    constructor(_type, _options2) {
    }
    runInAsyncScope(fn22, thisArg, ...args) {
      return fn22.apply(thisArg, args);
    }
    emitDestroy() {
      return this;
    }
    asyncId() {
      return 0;
    }
    triggerAsyncId() {
      return 0;
    }
    static bind(fn22, _type) {
      return fn22;
    }
  }
  class AsyncLocalStorage {
    constructor() {
      __publicField(this, "store");
    }
    disable() {
    }
    getStore() {
      return this.store;
    }
    run(store, callback) {
      const prev = this.store;
      this.store = store;
      try {
        return callback();
      } finally {
        this.store = prev;
      }
    }
    exit(callback) {
      const prev = this.store;
      this.store = void 0;
      try {
        return callback();
      } finally {
        this.store = prev;
      }
    }
    enterWith(store) {
      this.store = store;
    }
  }
  function createHook(_callbacks) {
    return {
      enable() {
        return this;
      },
      disable() {
        return this;
      }
    };
  }
  function executionAsyncId() {
    return 0;
  }
  function executionAsyncResource() {
    return {};
  }
  function triggerAsyncId() {
    return 0;
  }
  const async_hooks = {
    AsyncResource,
    AsyncLocalStorage,
    createHook,
    executionAsyncId,
    executionAsyncResource,
    triggerAsyncId
  };
  const asyncHooksShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    AsyncLocalStorage,
    AsyncResource,
    createHook,
    default: async_hooks,
    executionAsyncId,
    executionAsyncResource,
    triggerAsyncId
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Domain extends EventEmitter {
    constructor() {
      super(...arguments);
      __publicField(this, "members", []);
    }
    add(emitter) {
      this.members.push(emitter);
    }
    remove(emitter) {
      const index2 = this.members.indexOf(emitter);
      if (index2 !== -1) {
        this.members.splice(index2, 1);
      }
    }
    bind(callback) {
      return callback;
    }
    intercept(callback) {
      return callback;
    }
    run(fn22) {
      return fn22();
    }
    dispose() {
      this.members = [];
    }
    enter() {
    }
    exit() {
    }
  }
  function create() {
    return new Domain();
  }
  let active = null;
  const domain = {
    Domain,
    create,
    active
  };
  const domainShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Domain,
    active,
    create,
    default: domain
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Channel {
    constructor(name2) {
      __publicField(this, "name");
      __publicField(this, "_subscribers", /* @__PURE__ */ new Set());
      this.name = name2;
    }
    get hasSubscribers() {
      return this._subscribers.size > 0;
    }
    publish(message) {
      for (const subscriber of this._subscribers) {
        try {
          subscriber(message, this.name);
        } catch (err2) {
          console.error("Error in diagnostics channel subscriber:", err2);
        }
      }
    }
    subscribe(onMessage) {
      this._subscribers.add(onMessage);
    }
    unsubscribe(onMessage) {
      return this._subscribers.delete(onMessage);
    }
    bindStore(store, transform2) {
    }
    unbindStore(store) {
      return false;
    }
  }
  const channels = /* @__PURE__ */ new Map();
  function channel(name2) {
    let ch2 = channels.get(name2);
    if (!ch2) {
      ch2 = new Channel(name2);
      channels.set(name2, ch2);
    }
    return ch2;
  }
  function hasSubscribers(name2) {
    const ch2 = channels.get(name2);
    return ch2 ? ch2.hasSubscribers : false;
  }
  function subscribe(name2, onMessage) {
    channel(name2).subscribe(onMessage);
  }
  function unsubscribe(name2, onMessage) {
    const ch2 = channels.get(name2);
    return ch2 ? ch2.unsubscribe(onMessage) : false;
  }
  class TracingChannel {
    constructor(nameOrChannels) {
      __publicField(this, "channels");
      if (typeof nameOrChannels === "string") {
        this.channels = {
          start: channel(`tracing:${nameOrChannels}:start`),
          end: channel(`tracing:${nameOrChannels}:end`),
          asyncStart: channel(`tracing:${nameOrChannels}:asyncStart`),
          asyncEnd: channel(`tracing:${nameOrChannels}:asyncEnd`),
          error: channel(`tracing:${nameOrChannels}:error`)
        };
      } else {
        this.channels = nameOrChannels;
      }
    }
    get hasSubscribers() {
      return Object.values(this.channels).some((ch2) => ch2.hasSubscribers);
    }
    subscribe(handlers) {
      if (handlers.start)
        this.channels.start.subscribe(handlers.start);
      if (handlers.end)
        this.channels.end.subscribe(handlers.end);
      if (handlers.asyncStart)
        this.channels.asyncStart.subscribe(handlers.asyncStart);
      if (handlers.asyncEnd)
        this.channels.asyncEnd.subscribe(handlers.asyncEnd);
      if (handlers.error)
        this.channels.error.subscribe(handlers.error);
    }
    unsubscribe(handlers) {
      if (handlers.start)
        this.channels.start.unsubscribe(handlers.start);
      if (handlers.end)
        this.channels.end.unsubscribe(handlers.end);
      if (handlers.asyncStart)
        this.channels.asyncStart.unsubscribe(handlers.asyncStart);
      if (handlers.asyncEnd)
        this.channels.asyncEnd.unsubscribe(handlers.asyncEnd);
      if (handlers.error)
        this.channels.error.unsubscribe(handlers.error);
    }
    traceSync(fn22, context2, thisArg) {
      this.channels.start.publish(context2);
      try {
        const result = fn22.call(thisArg);
        this.channels.end.publish(context2);
        return result;
      } catch (error) {
        this.channels.error.publish({
          error,
          ...context2
        });
        throw error;
      }
    }
    async tracePromise(fn22, context2, thisArg) {
      this.channels.start.publish(context2);
      try {
        const result = await fn22.call(thisArg);
        this.channels.asyncEnd.publish(context2);
        return result;
      } catch (error) {
        this.channels.error.publish({
          error,
          ...context2
        });
        throw error;
      }
    }
    traceCallback(fn22, position, context2, thisArg) {
      return fn22;
    }
  }
  function tracingChannel(name2) {
    return new TracingChannel(name2);
  }
  const diagnostics_channel = {
    channel,
    hasSubscribers,
    subscribe,
    unsubscribe,
    tracingChannel,
    Channel,
    TracingChannel
  };
  const diagnosticsChannelShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Channel,
    TracingChannel,
    channel,
    default: diagnostics_channel,
    hasSubscribers,
    subscribe,
    tracingChannel,
    unsubscribe
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const noop$3 = () => {
  };
  const noopPromise = () => Promise.resolve();
  let Scope$2 = class Scope2 {
    constructor() {
      __publicField(this, "setTag", noop$3);
      __publicField(this, "setTags", noop$3);
      __publicField(this, "setUser", noop$3);
      __publicField(this, "setContext", noop$3);
      __publicField(this, "setExtra", noop$3);
      __publicField(this, "setExtras", noop$3);
      __publicField(this, "setLevel", noop$3);
      __publicField(this, "setTransactionName", noop$3);
      __publicField(this, "setFingerprint", noop$3);
      __publicField(this, "addBreadcrumb", noop$3);
      __publicField(this, "clearBreadcrumbs", noop$3);
      __publicField(this, "addEventProcessor", noop$3);
      __publicField(this, "addAttachment", noop$3);
      __publicField(this, "clear", noop$3);
      __publicField(this, "update", () => this);
      __publicField(this, "clone", () => new Scope2());
    }
  };
  class Hub {
    constructor() {
      __publicField(this, "getClient", () => void 0);
      __publicField(this, "getScope", () => new Scope$2());
      __publicField(this, "pushScope", () => new Scope$2());
      __publicField(this, "popScope", noop$3);
      __publicField(this, "withScope", (callback) => callback(new Scope$2()));
      __publicField(this, "captureException", () => "");
      __publicField(this, "captureMessage", () => "");
      __publicField(this, "captureEvent", () => "");
      __publicField(this, "addBreadcrumb", noop$3);
      __publicField(this, "setUser", noop$3);
      __publicField(this, "setTags", noop$3);
      __publicField(this, "setTag", noop$3);
      __publicField(this, "setExtra", noop$3);
      __publicField(this, "setExtras", noop$3);
      __publicField(this, "setContext", noop$3);
    }
  }
  class Transaction {
    constructor() {
      __publicField(this, "name", "");
      __publicField(this, "spanId", "");
      __publicField(this, "traceId", "");
      __publicField(this, "op", "");
      __publicField(this, "finish", noop$3);
      __publicField(this, "setTag", noop$3);
      __publicField(this, "setData", noop$3);
      __publicField(this, "setStatus", noop$3);
      __publicField(this, "startChild", () => new Transaction());
      __publicField(this, "toTraceparent", () => "");
    }
  }
  const currentHub = new Hub();
  const init = noop$3;
  const close = noopPromise;
  const flush = noopPromise;
  const captureException = () => "";
  const captureMessage = () => "";
  const captureEvent = () => "";
  const addBreadcrumb = noop$3;
  const setUser = noop$3;
  const setTag = noop$3;
  const setTags = noop$3;
  const setExtra = noop$3;
  const setExtras = noop$3;
  const setContext = noop$3;
  const configureScope = (callback) => callback(new Scope$2());
  const withScope = (callback) => callback(new Scope$2());
  const getCurrentHub = () => currentHub;
  const getHubFromCarrier = () => currentHub;
  const startTransaction = () => new Transaction();
  const lastEventId = () => void 0;
  const Integrations = {
    Http: class {
    },
    OnUncaughtException: class {
    },
    OnUnhandledRejection: class {
    },
    Console: class {
    },
    Context: class {
    },
    ContextLines: class {
    },
    Modules: class {
    },
    RequestData: class {
    },
    LinkedErrors: class {
    }
  };
  const Handlers = {
    requestHandler: () => (_req, _res, next2) => next2(),
    errorHandler: () => (_err, _req, _res, next2) => next2(),
    tracingHandler: () => (_req, _res, next2) => next2()
  };
  const sentry = {
    init,
    close,
    flush,
    captureException,
    captureMessage,
    captureEvent,
    addBreadcrumb,
    setUser,
    setTag,
    setTags,
    setExtra,
    setExtras,
    setContext,
    configureScope,
    withScope,
    getCurrentHub,
    startTransaction,
    lastEventId,
    Scope: Scope$2,
    Hub,
    Integrations,
    Handlers
  };
  const sentryShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Handlers,
    Hub,
    Integrations,
    Scope: Scope$2,
    addBreadcrumb,
    captureEvent,
    captureException,
    captureMessage,
    close,
    configureScope,
    default: sentry,
    flush,
    getCurrentHub,
    getHubFromCarrier,
    init,
    lastEventId,
    setContext,
    setExtra,
    setExtras,
    setTag,
    setTags,
    setUser,
    startTransaction,
    withScope
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class AssertionError extends Error {
    constructor(options2) {
      const message = options2.message || `${JSON.stringify(options2.actual)} ${options2.operator || "=="} ${JSON.stringify(options2.expected)}`;
      super(message);
      __publicField(this, "actual");
      __publicField(this, "expected");
      __publicField(this, "operator");
      __publicField(this, "generatedMessage");
      __publicField(this, "code", "ERR_ASSERTION");
      this.name = "AssertionError";
      this.actual = options2.actual;
      this.expected = options2.expected;
      this.operator = options2.operator || "";
      this.generatedMessage = !options2.message;
      if (Error.captureStackTrace && options2.stackStartFn) {
        Error.captureStackTrace(this, options2.stackStartFn);
      }
    }
  }
  function isDeepStrictEqual(actual, expected) {
    if (actual === expected) {
      return true;
    }
    if (actual === null || expected === null || actual === void 0 || expected === void 0) {
      return actual === expected;
    }
    if (typeof actual !== typeof expected) {
      return false;
    }
    if (typeof actual === "number" && Number.isNaN(actual) && Number.isNaN(expected)) {
      return true;
    }
    if (actual instanceof Date && expected instanceof Date) {
      return actual.getTime() === expected.getTime();
    }
    if (actual instanceof RegExp && expected instanceof RegExp) {
      return actual.source === expected.source && actual.flags === expected.flags;
    }
    if (Array.isArray(actual) && Array.isArray(expected)) {
      if (actual.length !== expected.length) {
        return false;
      }
      for (let i22 = 0; i22 < actual.length; i22++) {
        if (!isDeepStrictEqual(actual[i22], expected[i22])) {
          return false;
        }
      }
      return true;
    }
    if (actual instanceof Uint8Array && expected instanceof Uint8Array) {
      if (actual.length !== expected.length) {
        return false;
      }
      for (let i22 = 0; i22 < actual.length; i22++) {
        if (actual[i22] !== expected[i22]) {
          return false;
        }
      }
      return true;
    }
    if (actual instanceof Map && expected instanceof Map) {
      if (actual.size !== expected.size) {
        return false;
      }
      const actualEntries = Array.from(actual.entries());
      for (let i22 = 0; i22 < actualEntries.length; i22++) {
        const [key, value2] = actualEntries[i22];
        if (!expected.has(key) || !isDeepStrictEqual(value2, expected.get(key))) {
          return false;
        }
      }
      return true;
    }
    if (actual instanceof Set && expected instanceof Set) {
      if (actual.size !== expected.size) {
        return false;
      }
      const actualValues = Array.from(actual.values());
      const expectedValues = Array.from(expected.values());
      for (let i22 = 0; i22 < actualValues.length; i22++) {
        const value2 = actualValues[i22];
        if (!expected.has(value2)) {
          let found = false;
          for (let j = 0; j < expectedValues.length; j++) {
            if (isDeepStrictEqual(value2, expectedValues[j])) {
              found = true;
              break;
            }
          }
          if (!found)
            return false;
        }
      }
      return true;
    }
    if (typeof actual === "object" && typeof expected === "object") {
      const actualKeys = Object.keys(actual);
      const expectedKeys = Object.keys(expected);
      if (actualKeys.length !== expectedKeys.length) {
        return false;
      }
      for (const key of actualKeys) {
        if (!Object.prototype.hasOwnProperty.call(expected, key)) {
          return false;
        }
        if (!isDeepStrictEqual(actual[key], expected[key])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function assert(value2, message) {
    if (!value2) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message: message || "The expression evaluated to a falsy value",
        actual: value2,
        expected: true,
        operator: "==",
        stackStartFn: assert
      });
    }
  }
  assert.ok = function ok(value2, message) {
    if (!value2) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message: message || "The expression evaluated to a falsy value",
        actual: value2,
        expected: true,
        operator: "==",
        stackStartFn: ok
      });
    }
  };
  assert.strictEqual = function strictEqual(actual, expected, message) {
    if (actual !== expected) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message,
        actual,
        expected,
        operator: "===",
        stackStartFn: strictEqual
      });
    }
  };
  assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (actual === expected) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message,
        actual,
        expected,
        operator: "!==",
        stackStartFn: notStrictEqual
      });
    }
  };
  assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
    if (!isDeepStrictEqual(actual, expected)) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message,
        actual,
        expected,
        operator: "deepStrictEqual",
        stackStartFn: deepStrictEqual
      });
    }
  };
  assert.notDeepStrictEqual = function notDeepStrictEqual(actual, expected, message) {
    if (isDeepStrictEqual(actual, expected)) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message,
        actual,
        expected,
        operator: "notDeepStrictEqual",
        stackStartFn: notDeepStrictEqual
      });
    }
  };
  assert.throws = function throws(fn22, errorOrMessage, message) {
    let threw = false;
    let thrownError;
    try {
      fn22();
    } catch (err2) {
      threw = true;
      thrownError = err2;
    }
    if (!threw) {
      throw new AssertionError({
        message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected function to throw",
        actual: void 0,
        expected: errorOrMessage,
        operator: "throws",
        stackStartFn: throws
      });
    }
    if (errorOrMessage !== void 0 && typeof errorOrMessage !== "string") {
      if (errorOrMessage instanceof RegExp) {
        const errMessage = thrownError instanceof Error ? thrownError.message : String(thrownError);
        if (!errorOrMessage.test(errMessage)) {
          throw new AssertionError({
            message: message || `The error message did not match the regular expression`,
            actual: thrownError,
            expected: errorOrMessage,
            operator: "throws",
            stackStartFn: throws
          });
        }
      } else if (typeof errorOrMessage === "function") {
        if (!(thrownError instanceof errorOrMessage)) {
          throw new AssertionError({
            message: message || `The error is not an instance of the expected type`,
            actual: thrownError,
            expected: errorOrMessage,
            operator: "throws",
            stackStartFn: throws
          });
        }
      } else if (typeof errorOrMessage === "object") {
        const expected = errorOrMessage;
        const err2 = thrownError;
        if (expected.message !== void 0) {
          const errMsg = err2.message || String(thrownError);
          if (expected.message instanceof RegExp) {
            if (!expected.message.test(errMsg)) {
              throw new AssertionError({
                message: message || `The error message did not match`,
                actual: errMsg,
                expected: expected.message,
                operator: "throws",
                stackStartFn: throws
              });
            }
          } else if (errMsg !== expected.message) {
            throw new AssertionError({
              message: message || `The error message did not match`,
              actual: errMsg,
              expected: expected.message,
              operator: "throws",
              stackStartFn: throws
            });
          }
        }
        if (expected.code !== void 0 && err2.code !== expected.code) {
          throw new AssertionError({
            message: message || `The error code did not match`,
            actual: err2.code,
            expected: expected.code,
            operator: "throws",
            stackStartFn: throws
          });
        }
      }
    }
  };
  assert.doesNotThrow = function doesNotThrow(fn22, errorOrMessage, message) {
    try {
      fn22();
    } catch (err2) {
      if (errorOrMessage === void 0 || typeof errorOrMessage === "string") {
        throw new AssertionError({
          message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected function not to throw",
          actual: err2,
          expected: void 0,
          operator: "doesNotThrow",
          stackStartFn: doesNotThrow
        });
      }
      if (errorOrMessage instanceof RegExp) {
        const errMessage = err2 instanceof Error ? err2.message : String(err2);
        if (errorOrMessage.test(errMessage)) {
          throw new AssertionError({
            message: message || "Expected function not to throw matching error",
            actual: err2,
            expected: errorOrMessage,
            operator: "doesNotThrow",
            stackStartFn: doesNotThrow
          });
        }
      } else if (typeof errorOrMessage === "function") {
        if (err2 instanceof errorOrMessage) {
          throw new AssertionError({
            message: message || "Expected function not to throw error of this type",
            actual: err2,
            expected: errorOrMessage,
            operator: "doesNotThrow",
            stackStartFn: doesNotThrow
          });
        }
      }
    }
  };
  assert.rejects = async function rejects(asyncFn, errorOrMessage, message) {
    const promise = typeof asyncFn === "function" ? asyncFn() : asyncFn;
    let rejected = false;
    let rejectionReason;
    try {
      await promise;
    } catch (err2) {
      rejected = true;
      rejectionReason = err2;
    }
    if (!rejected) {
      throw new AssertionError({
        message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected promise to reject",
        actual: void 0,
        expected: errorOrMessage,
        operator: "rejects",
        stackStartFn: rejects
      });
    }
    if (errorOrMessage !== void 0 && typeof errorOrMessage !== "string") {
      if (errorOrMessage instanceof RegExp) {
        const errMessage = rejectionReason instanceof Error ? rejectionReason.message : String(rejectionReason);
        if (!errorOrMessage.test(errMessage)) {
          throw new AssertionError({
            message: message || "The rejection message did not match the regular expression",
            actual: rejectionReason,
            expected: errorOrMessage,
            operator: "rejects",
            stackStartFn: rejects
          });
        }
      } else if (typeof errorOrMessage === "function") {
        if (!(rejectionReason instanceof errorOrMessage)) {
          throw new AssertionError({
            message: message || "The rejection is not an instance of the expected type",
            actual: rejectionReason,
            expected: errorOrMessage,
            operator: "rejects",
            stackStartFn: rejects
          });
        }
      } else if (typeof errorOrMessage === "object") {
        const expected = errorOrMessage;
        const err2 = rejectionReason;
        if (expected.message !== void 0) {
          const errMsg = err2.message || String(rejectionReason);
          if (expected.message instanceof RegExp) {
            if (!expected.message.test(errMsg)) {
              throw new AssertionError({
                message: message || "The rejection message did not match",
                actual: errMsg,
                expected: expected.message,
                operator: "rejects",
                stackStartFn: rejects
              });
            }
          } else if (errMsg !== expected.message) {
            throw new AssertionError({
              message: message || "The rejection message did not match",
              actual: errMsg,
              expected: expected.message,
              operator: "rejects",
              stackStartFn: rejects
            });
          }
        }
        if (expected.code !== void 0 && err2.code !== expected.code) {
          throw new AssertionError({
            message: message || "The rejection code did not match",
            actual: err2.code,
            expected: expected.code,
            operator: "rejects",
            stackStartFn: rejects
          });
        }
      }
    }
  };
  assert.doesNotReject = async function doesNotReject(asyncFn, errorOrMessage, message) {
    const promise = typeof asyncFn === "function" ? asyncFn() : asyncFn;
    try {
      await promise;
    } catch (err2) {
      if (errorOrMessage === void 0 || typeof errorOrMessage === "string") {
        throw new AssertionError({
          message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected promise not to reject",
          actual: err2,
          expected: void 0,
          operator: "doesNotReject",
          stackStartFn: doesNotReject
        });
      }
      if (errorOrMessage instanceof RegExp) {
        const errMessage = err2 instanceof Error ? err2.message : String(err2);
        if (errorOrMessage.test(errMessage)) {
          throw new AssertionError({
            message: message || "Expected promise not to reject with matching error",
            actual: err2,
            expected: errorOrMessage,
            operator: "doesNotReject",
            stackStartFn: doesNotReject
          });
        }
      } else if (typeof errorOrMessage === "function") {
        if (err2 instanceof errorOrMessage) {
          throw new AssertionError({
            message: message || "Expected promise not to reject with error of this type",
            actual: err2,
            expected: errorOrMessage,
            operator: "doesNotReject",
            stackStartFn: doesNotReject
          });
        }
      }
    }
  };
  assert.fail = function fail(messageOrActual, expected, message, operator) {
    if (arguments.length === 0 || arguments.length === 1) {
      throw new AssertionError({
        message: typeof messageOrActual === "string" ? messageOrActual : "Failed",
        stackStartFn: fail
      });
    }
    throw new AssertionError({
      message,
      actual: messageOrActual,
      expected,
      operator: operator || "fail",
      stackStartFn: fail
    });
  };
  assert.match = function match2(string, regexp, message) {
    if (!regexp.test(string)) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message: message || `The input did not match the regular expression`,
        actual: string,
        expected: regexp,
        operator: "match",
        stackStartFn: match2
      });
    }
  };
  assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
    if (regexp.test(string)) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message: message || `The input was expected not to match the regular expression`,
        actual: string,
        expected: regexp,
        operator: "doesNotMatch",
        stackStartFn: doesNotMatch
      });
    }
  };
  assert.ifError = function ifError(value2) {
    if (value2 !== null && value2 !== void 0) {
      if (value2 instanceof Error) {
        throw value2;
      }
      throw new AssertionError({
        message: `ifError got unwanted exception: ${value2}`,
        actual: value2,
        expected: null,
        operator: "ifError",
        stackStartFn: ifError
      });
    }
  };
  assert.AssertionError = AssertionError;
  assert.strict = assert;
  assert$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    AssertionError,
    assert,
    default: assert
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function transformDynamicImports(code2) {
    return code2.replace(new RegExp("(?<![.$\\w])import\\s*\\(", "g"), "__dynamicImport(");
  }
  function transformEsmToCjs(code2, filename2) {
    const hasImport = /\bimport\s+[\w{*'"]/m.test(code2);
    const hasExport = /\bexport\s+(?:default|const|let|var|function|class|{|\*)/m.test(code2);
    const hasImportMeta = /\bimport\.meta\b/.test(code2);
    if (!hasImport && !hasExport && !hasImportMeta) {
      return code2;
    }
    let transformed = code2;
    transformed = transformed.replace(/\bimport\.meta\.url\b/g, `"file://${filename2}"`);
    transformed = transformed.replace(/\bimport\.meta\.dirname\b/g, `"${dirname(filename2)}"`);
    transformed = transformed.replace(/\bimport\.meta\.filename\b/g, `"${filename2}"`);
    transformed = transformed.replace(/\bimport\.meta\b/g, `({ url: "file://${filename2}", dirname: "${dirname(filename2)}", filename: "${filename2}" })`);
    transformed = transformed.replace(/\bimport\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"]\s*;?/g, (_10, imports, module2) => {
      const cleanImports = imports.replace(/\s+as\s+/g, ": ");
      return `const {${cleanImports}} = require("${module2}");`;
    });
    transformed = transformed.replace(/\bimport\s+(\w+)\s+from\s+['"]([^'"]+)['"]\s*;?/g, (_10, name2, module2) => {
      return `const ${name2} = (function() { const m = require("${module2}"); return m && m.__esModule ? m.default : m; })();`;
    });
    transformed = transformed.replace(/\bimport\s+\*\s+as\s+(\w+)\s+from\s+['"]([^'"]+)['"]\s*;?/g, 'const $1 = require("$2");');
    transformed = transformed.replace(/\bimport\s+['"]([^'"]+)['"]\s*;?/g, 'require("$1");');
    transformed = transformed.replace(/\bexport\s+default\s+/g, "module.exports = module.exports.default = ");
    transformed = transformed.replace(/\bexport\s+\{([^}]+)\}\s*;?/g, (_10, exports$1) => {
      const items = exports$1.split(",").map((item) => {
        const [local, exported] = item.trim().split(/\s+as\s+/);
        const exportName = exported || local;
        return `module.exports.${exportName.trim()} = ${local.trim()};`;
      });
      return items.join("\n");
    });
    transformed = transformed.replace(/\bexport\s+(const|let|var)\s+(\w+)\s*=/g, "$1 $2 = module.exports.$2 =");
    transformed = transformed.replace(/\bexport\s+function\s+(\w+)/g, "function $1");
    transformed = transformed.replace(/\bexport\s+class\s+(\w+)/g, "class $1");
    if (hasExport) {
      transformed = 'Object.defineProperty(exports, "__esModule", { value: true });\n' + transformed;
    }
    return transformed;
  }
  function createDynamicImport(moduleRequire2) {
    return async (specifier) => {
      try {
        const mod = moduleRequire2(specifier);
        if (mod && typeof mod === "object" && ("default" in mod || "__esModule" in mod)) {
          return mod;
        }
        return {
          default: mod,
          ...mod && typeof mod === "object" ? mod : {}
        };
      } catch (error) {
        throw error;
      }
    };
  }
  function createStringDecoderModule() {
    class StringDecoder {
      constructor(encoding) {
        __publicField(this, "encoding");
        this.encoding = encoding || "utf8";
      }
      write(buffer2) {
        return new TextDecoder(this.encoding).decode(buffer2);
      }
      end(buffer2) {
        if (buffer2)
          return this.write(buffer2);
        return "";
      }
    }
    return {
      StringDecoder
    };
  }
  function createTimersModule() {
    return {
      setTimeout: globalThis.setTimeout.bind(globalThis),
      setInterval: globalThis.setInterval.bind(globalThis),
      setImmediate: (fn22) => setTimeout(fn22, 0),
      clearTimeout: globalThis.clearTimeout.bind(globalThis),
      clearInterval: globalThis.clearInterval.bind(globalThis),
      clearImmediate: globalThis.clearTimeout.bind(globalThis)
    };
  }
  const prettierShim = {
    format: (source, _options2) => Promise.resolve(source),
    formatWithCursor: (source, _options2) => Promise.resolve({
      formatted: source,
      cursorOffset: 0
    }),
    check: (_source, _options2) => Promise.resolve(true),
    resolveConfig: () => Promise.resolve(null),
    resolveConfigFile: () => Promise.resolve(null),
    clearConfigCache: () => {
    },
    getFileInfo: () => Promise.resolve({
      ignored: false,
      inferredParser: null
    }),
    getSupportInfo: () => Promise.resolve({
      languages: [],
      options: []
    }),
    version: "3.0.0",
    doc: {
      builders: {},
      printer: {},
      utils: {}
    }
  };
  function makeMutable(mod) {
    const mutable = {};
    for (const key of Object.keys(mod)) {
      mutable[key] = mod[key];
    }
    return mutable;
  }
  const builtinModules = {
    path: pathShim,
    http: makeMutable(httpShim),
    https: makeMutable(httpsShim),
    net: netShim,
    events,
    stream: Stream,
    buffer: bufferModule,
    url: urlShim,
    querystring: querystringShim,
    util: utilShim,
    tty: ttyShim,
    os: osShim,
    crypto: cryptoShim,
    zlib: zlibShim,
    dns: dnsShim,
    child_process: childProcessShim,
    assert,
    string_decoder: createStringDecoderModule(),
    timers: createTimersModule(),
    _http_common: {},
    _http_incoming: {},
    _http_outgoing: {},
    chokidar: chokidarShim,
    ws: wsShim,
    fsevents: fseventsShim,
    readdirp: readdirpShim,
    module: moduleShim,
    perf_hooks: perfHooksShim,
    worker_threads: workerThreadsShim,
    esbuild: esbuildShim,
    rollup: rollupShim,
    v8: v8Shim,
    readline: readlineShim,
    tls: tlsShim,
    http2: http2Shim,
    cluster: clusterShim,
    dgram: dgramShim,
    vm: vmShim,
    inspector: inspectorShim,
    "inspector/promises": inspectorShim,
    async_hooks: asyncHooksShim,
    domain: domainShim,
    diagnostics_channel: diagnosticsChannelShim,
    prettier: prettierShim,
    console,
    "util/types": types$2,
    "@sentry/node": sentryShim,
    "@sentry/core": sentryShim
  };
  function createRequire(vfs, fsShim, process, currentDir, moduleCache, options, processedCodeCache) {
    const resolutionCache = /* @__PURE__ */ new Map();
    const packageJsonCache = /* @__PURE__ */ new Map();
    const getParsedPackageJson = (pkgPath) => {
      if (packageJsonCache.has(pkgPath)) {
        return packageJsonCache.get(pkgPath);
      }
      try {
        const content = vfs.readFileSync(pkgPath, "utf8");
        const parsed = JSON.parse(content);
        packageJsonCache.set(pkgPath, parsed);
        return parsed;
      } catch {
        packageJsonCache.set(pkgPath, null);
        return null;
      }
    };
    const resolveModule = (id2, fromDir) => {
      if (id2.startsWith("node:")) {
        id2 = id2.slice(5);
      }
      if (builtinModules[id2] || id2 === "fs" || id2 === "process" || id2 === "url" || id2 === "querystring" || id2 === "util") {
        return id2;
      }
      const cacheKey = `${fromDir}|${id2}`;
      const cached = resolutionCache.get(cacheKey);
      if (cached !== void 0) {
        if (cached === null) {
          throw new Error(`Cannot find module '${id2}'`);
        }
        return cached;
      }
      if (id2.startsWith("./") || id2.startsWith("../") || id2.startsWith("/")) {
        const resolved = id2.startsWith("/") ? id2 : resolve$2(fromDir, id2);
        if (vfs.existsSync(resolved)) {
          const stats = vfs.statSync(resolved);
          if (stats.isFile()) {
            resolutionCache.set(cacheKey, resolved);
            return resolved;
          }
          const indexPath = join(resolved, "index.js");
          if (vfs.existsSync(indexPath)) {
            resolutionCache.set(cacheKey, indexPath);
            return indexPath;
          }
        }
        const extensions = [
          ".js",
          ".json"
        ];
        for (const ext2 of extensions) {
          const withExt = resolved + ext2;
          if (vfs.existsSync(withExt)) {
            resolutionCache.set(cacheKey, withExt);
            return withExt;
          }
        }
        resolutionCache.set(cacheKey, null);
        throw new Error(`Cannot find module '${id2}' from '${fromDir}'`);
      }
      const tryResolveFile = (basePath) => {
        if (vfs.existsSync(basePath)) {
          const stats = vfs.statSync(basePath);
          if (stats.isFile()) {
            return basePath;
          }
          const indexPath = join(basePath, "index.js");
          if (vfs.existsSync(indexPath)) {
            return indexPath;
          }
        }
        const extensions = [
          ".js",
          ".json",
          ".node"
        ];
        for (const ext2 of extensions) {
          const withExt = basePath + ext2;
          if (vfs.existsSync(withExt)) {
            return withExt;
          }
        }
        return null;
      };
      const tryResolveFromNodeModules = (nodeModulesDir, moduleId) => {
        const parts = moduleId.split("/");
        const pkgName = parts[0].startsWith("@") && parts.length > 1 ? `${parts[0]}/${parts[1]}` : parts[0];
        const pkgRoot = join(nodeModulesDir, pkgName);
        const pkgPath = join(pkgRoot, "package.json");
        const pkg = getParsedPackageJson(pkgPath);
        if (pkg) {
          if (pkg.exports) {
            try {
              const resolved2 = s(pkg, moduleId, {
                require: true
              });
              if (resolved2 && resolved2.length > 0) {
                const exportPath = resolved2[0];
                const fullExportPath = join(pkgRoot, exportPath);
                const resolvedFile = tryResolveFile(fullExportPath);
                if (resolvedFile)
                  return resolvedFile;
              }
            } catch {
            }
          }
          if (pkgName === moduleId) {
            let main;
            if (typeof pkg.browser === "string") {
              main = pkg.browser;
            }
            if (!main) {
              main = pkg.main || "index.js";
            }
            const mainPath = join(pkgRoot, main);
            const resolvedMain = tryResolveFile(mainPath);
            if (resolvedMain)
              return resolvedMain;
          }
        }
        const fullPath = join(nodeModulesDir, moduleId);
        const resolved = tryResolveFile(fullPath);
        if (resolved)
          return resolved;
        return null;
      };
      let searchDir = fromDir;
      while (searchDir !== "/") {
        const nodeModulesDir = join(searchDir, "node_modules");
        const resolved = tryResolveFromNodeModules(nodeModulesDir, id2);
        if (resolved) {
          resolutionCache.set(cacheKey, resolved);
          return resolved;
        }
        searchDir = dirname(searchDir);
      }
      const rootResolved = tryResolveFromNodeModules("/node_modules", id2);
      if (rootResolved) {
        resolutionCache.set(cacheKey, rootResolved);
        return rootResolved;
      }
      resolutionCache.set(cacheKey, null);
      throw new Error(`Cannot find module '${id2}'`);
    };
    const loadModule = (resolvedPath) => {
      if (moduleCache[resolvedPath]) {
        return moduleCache[resolvedPath];
      }
      const module = {
        id: resolvedPath,
        filename: resolvedPath,
        exports: {},
        loaded: false,
        children: [],
        paths: []
      };
      moduleCache[resolvedPath] = module;
      const cacheKeys = Object.keys(moduleCache);
      if (cacheKeys.length > 2e3) {
        delete moduleCache[cacheKeys[0]];
      }
      if (resolvedPath.endsWith(".json")) {
        const content = vfs.readFileSync(resolvedPath, "utf8");
        module.exports = JSON.parse(content);
        module.loaded = true;
        return module;
      }
      const rawCode = vfs.readFileSync(resolvedPath, "utf8");
      const dirname$1 = dirname(resolvedPath);
      const codeCacheKey = `${resolvedPath}|${simpleHash(rawCode)}`;
      let code = processedCodeCache == null ? void 0 : processedCodeCache.get(codeCacheKey);
      if (!code) {
        code = rawCode;
        const isCjsFile = resolvedPath.endsWith(".cjs");
        const isAlreadyBundledCjs = code.startsWith('"use strict";\nvar __') || code.startsWith("'use strict';\nvar __");
        const hasEsmImport = /\bimport\s+[\w{*'"]/m.test(code);
        const hasEsmExport = /\bexport\s+(?:default|const|let|var|function|class|{|\*)/m.test(code);
        if (!isCjsFile && !isAlreadyBundledCjs) {
          if (resolvedPath.endsWith(".mjs") || resolvedPath.includes("/esm/") || hasEsmImport || hasEsmExport) {
            code = transformEsmToCjs(code, resolvedPath);
          }
        }
        code = transformDynamicImports(code);
        processedCodeCache == null ? void 0 : processedCodeCache.set(codeCacheKey, code);
      }
      const moduleRequire = createRequire(vfs, fsShim, process, dirname$1, moduleCache, options, processedCodeCache);
      moduleRequire.cache = moduleCache;
      const consoleWrapper = createConsoleWrapper(options.onConsole);
      try {
        const importMetaUrl = "file://" + resolvedPath;
        const wrappedCode = `(function($exports, $require, $module, $filename, $dirname, $process, $console, $importMeta, $dynamicImport) {
var exports = $exports;
var require = $require;
var module = $module;
var __filename = $filename;
var __dirname = $dirname;
var process = $process;
var console = $console;
var import_meta = $importMeta;
var __dynamicImport = $dynamicImport;
// Set up global.process and globalThis.process for code that accesses them directly
var global = globalThis;
globalThis.process = $process;
global.process = $process;
return (function() {
${code}
}).call(this);
})`;
        let fn;
        try {
          fn = eval(wrappedCode);
        } catch (evalError) {
          console.error("[runtime] Eval failed for:", resolvedPath);
          console.error("[runtime] First 500 chars of code:", code.substring(0, 500));
          throw evalError;
        }
        const dynamicImport = createDynamicImport(moduleRequire);
        fn(module.exports, moduleRequire, module, resolvedPath, dirname$1, process, consoleWrapper, {
          url: importMetaUrl,
          dirname: dirname$1,
          filename: resolvedPath
        }, dynamicImport);
        module.loaded = true;
      } catch (error) {
        delete moduleCache[resolvedPath];
        throw error;
      }
      return module;
    };
    const require = (id2) => {
      if (id2.startsWith("node:")) {
        id2 = id2.slice(5);
      }
      if (id2 === "fs") {
        return fsShim;
      }
      if (id2 === "fs/promises") {
        return fsShim.promises;
      }
      if (id2 === "process") {
        return process;
      }
      if (id2 === "module") {
        return {
          ...moduleShim,
          createRequire: (filenameOrUrl) => {
            let fromPath = filenameOrUrl;
            if (filenameOrUrl.startsWith("file://")) {
              fromPath = filenameOrUrl.slice(7);
              if (fromPath.startsWith("/") && fromPath[2] === ":") {
                fromPath = fromPath.slice(1);
              }
            }
            const fromDir = dirname(fromPath);
            const newRequire = createRequire(vfs, fsShim, process, fromDir, moduleCache, options);
            newRequire.cache = moduleCache;
            return newRequire;
          }
        };
      }
      if (builtinModules[id2]) {
        return builtinModules[id2];
      }
      if (id2 === "rollup" || id2.startsWith("rollup/") || id2.startsWith("@rollup/")) {
        console.log("[runtime] Intercepted rollup:", id2);
        return builtinModules["rollup"];
      }
      if (id2 === "esbuild" || id2.startsWith("esbuild/") || id2.startsWith("@esbuild/")) {
        console.log("[runtime] Intercepted esbuild:", id2);
        return builtinModules["esbuild"];
      }
      if (id2 === "prettier" || id2.startsWith("prettier/")) {
        return builtinModules["prettier"];
      }
      if (id2.startsWith("@sentry/")) {
        return builtinModules["@sentry/node"];
      }
      const resolved = resolveModule(id2, currentDir);
      if (builtinModules[resolved]) {
        return builtinModules[resolved];
      }
      if (resolved.includes("/node_modules/rollup/") || resolved.includes("/node_modules/@rollup/")) {
        return builtinModules["rollup"];
      }
      if (resolved.includes("/node_modules/esbuild/") || resolved.includes("/node_modules/@esbuild/")) {
        return builtinModules["esbuild"];
      }
      if (resolved.includes("/node_modules/prettier/")) {
        return builtinModules["prettier"];
      }
      if (resolved.includes("/node_modules/@sentry/")) {
        return builtinModules["@sentry/node"];
      }
      return loadModule(resolved).exports;
    };
    require.resolve = (id2) => {
      if (id2 === "fs" || id2 === "process" || builtinModules[id2]) {
        return id2;
      }
      return resolveModule(id2, currentDir);
    };
    require.cache = moduleCache;
    return require;
  }
  function createConsoleWrapper(onConsole) {
    const wrapper = {
      log: (...args) => {
        console.log(...args);
        onConsole == null ? void 0 : onConsole("log", args);
      },
      error: (...args) => {
        console.error(...args);
        onConsole == null ? void 0 : onConsole("error", args);
      },
      warn: (...args) => {
        console.warn(...args);
        onConsole == null ? void 0 : onConsole("warn", args);
      },
      info: (...args) => {
        console.info(...args);
        onConsole == null ? void 0 : onConsole("info", args);
      },
      debug: (...args) => {
        console.debug(...args);
        onConsole == null ? void 0 : onConsole("debug", args);
      },
      trace: (...args) => {
        console.trace(...args);
        onConsole == null ? void 0 : onConsole("trace", args);
      },
      dir: (obj) => {
        console.dir(obj);
        onConsole == null ? void 0 : onConsole("dir", [
          obj
        ]);
      },
      time: console.time.bind(console),
      timeEnd: console.timeEnd.bind(console),
      timeLog: console.timeLog.bind(console),
      assert: console.assert.bind(console),
      clear: console.clear.bind(console),
      count: console.count.bind(console),
      countReset: console.countReset.bind(console),
      group: console.group.bind(console),
      groupCollapsed: console.groupCollapsed.bind(console),
      groupEnd: console.groupEnd.bind(console),
      table: console.table.bind(console)
    };
    return wrapper;
  }
  Runtime = class {
    constructor(vfs2, options2 = {}) {
      __publicField(this, "vfs");
      __publicField(this, "fsShim");
      __publicField(this, "process");
      __publicField(this, "moduleCache", {});
      __publicField(this, "options");
      __publicField(this, "processedCodeCache", /* @__PURE__ */ new Map());
      __publicField(this, "executeSync", this.execute);
      __publicField(this, "runFileSync", this.runFile);
      this.vfs = vfs2;
      this.process = createProcess({
        cwd: options2.cwd || "/",
        env: options2.env
      });
      this.fsShim = createFsShim(vfs2, () => this.process.cwd());
      this.options = options2;
      initChildProcess(vfs2);
      setVFS$2(vfs2);
      setVFS$1(vfs2);
      setVFS(vfs2);
      this.setupStackTracePolyfill();
      this.setupTextDecoderPolyfill();
    }
    setupTextDecoderPolyfill() {
      const OriginalTextDecoder = globalThis.TextDecoder;
      class PolyfillTextDecoder {
        constructor(encoding = "utf-8", options2) {
          __publicField(this, "encoding");
          __publicField(this, "decoder", null);
          this.encoding = encoding.toLowerCase();
          const validTextEncodings = [
            "utf-8",
            "utf8",
            "utf-16le",
            "utf-16be",
            "utf-16",
            "ascii",
            "iso-8859-1",
            "latin1",
            "windows-1252"
          ];
          if (validTextEncodings.includes(this.encoding)) {
            try {
              this.decoder = new OriginalTextDecoder(encoding, options2);
            } catch {
              this.decoder = new OriginalTextDecoder("utf-8", options2);
            }
          }
        }
        decode(input, options2) {
          if (this.decoder) {
            return this.decoder.decode(input, options2);
          }
          if (!input)
            return "";
          const bytes = input instanceof ArrayBuffer ? new Uint8Array(input) : new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
          if (this.encoding === "base64") {
            return uint8ToBase64(bytes);
          }
          if (this.encoding === "base64url") {
            return uint8ToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
          }
          if (this.encoding === "hex") {
            return uint8ToHex(bytes);
          }
          return new OriginalTextDecoder("utf-8").decode(input, options2);
        }
        get fatal() {
          var _a22;
          return ((_a22 = this.decoder) == null ? void 0 : _a22.fatal) ?? false;
        }
        get ignoreBOM() {
          var _a22;
          return ((_a22 = this.decoder) == null ? void 0 : _a22.ignoreBOM) ?? false;
        }
      }
      globalThis.TextDecoder = PolyfillTextDecoder;
    }
    setupStackTracePolyfill() {
      if (typeof Error.captureStackTrace === "function")
        return;
      if (Error.stackTraceLimit === void 0) {
        Error.stackTraceLimit = 10;
      }
      function parseStack(stack) {
        if (!stack)
          return [];
        const frames = [];
        const lines = stack.split("\n");
        for (const raw of lines) {
          const line = raw.trim();
          if (!line || line.startsWith("Error") || line.startsWith("TypeError"))
            continue;
          let fn22 = "", file = "", lineNo = 0, colNo = 0;
          const safariMatch = line.match(/^(.*)@(.*?):(\d+):(\d+)$/);
          if (safariMatch) {
            fn22 = safariMatch[1] || "";
            file = safariMatch[2];
            lineNo = parseInt(safariMatch[3], 10);
            colNo = parseInt(safariMatch[4], 10);
            frames.push({
              fn: fn22,
              file,
              line: lineNo,
              col: colNo
            });
            continue;
          }
          const chromeMatch = line.match(/^at\s+(?:(.+?)\s+\()?(.*?):(\d+):(\d+)\)?$/);
          if (chromeMatch) {
            fn22 = chromeMatch[1] || "";
            file = chromeMatch[2];
            lineNo = parseInt(chromeMatch[3], 10);
            colNo = parseInt(chromeMatch[4], 10);
            frames.push({
              fn: fn22,
              file,
              line: lineNo,
              col: colNo
            });
            continue;
          }
        }
        return frames;
      }
      function createCallSite(frame) {
        return {
          getFileName: () => frame.file || null,
          getLineNumber: () => frame.line || null,
          getColumnNumber: () => frame.col || null,
          getFunctionName: () => frame.fn || null,
          getMethodName: () => frame.fn || null,
          getTypeName: () => null,
          getThis: () => void 0,
          getFunction: () => void 0,
          getEvalOrigin: () => void 0,
          isNative: () => false,
          isConstructor: () => false,
          isToplevel: () => !frame.fn,
          isEval: () => false,
          toString: () => frame.fn ? `${frame.fn} (${frame.file}:${frame.line}:${frame.col})` : `${frame.file}:${frame.line}:${frame.col}`
        };
      }
      function buildCallSites(stack, constructorOpt) {
        const frames = parseStack(stack);
        let startIdx = 0;
        if (constructorOpt && constructorOpt.name) {
          for (let i22 = 0; i22 < frames.length; i22++) {
            if (frames[i22].fn === constructorOpt.name) {
              startIdx = i22 + 1;
              break;
            }
          }
        }
        return frames.slice(startIdx).map(createCallSite);
      }
      const stackSymbol = Symbol("rawStack");
      Object.defineProperty(Error.prototype, "stack", {
        get() {
          const rawStack = this[stackSymbol];
          if (rawStack !== void 0 && typeof Error.prepareStackTrace === "function") {
            const callSites = buildCallSites(rawStack);
            try {
              return Error.prepareStackTrace(this, callSites);
            } catch {
              return rawStack;
            }
          }
          return rawStack;
        },
        set(value2) {
          this[stackSymbol] = value2;
        },
        configurable: true,
        enumerable: false
      });
      Error.captureStackTrace = function(target, constructorOpt) {
        const savedPrepare = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        const err2 = new Error();
        const rawStack = err2.stack || "";
        Error.prepareStackTrace = savedPrepare;
        if (typeof savedPrepare === "function") {
          const callSites = buildCallSites(rawStack, constructorOpt);
          try {
            target.stack = savedPrepare(target, callSites);
          } catch (e11) {
            console.warn("[almostnode] Error.prepareStackTrace threw:", e11);
            target.stack = rawStack;
          }
        } else {
          target.stack = rawStack;
        }
      };
    }
    execute(code, filename = "/index.js") {
      const dirname$1 = dirname(filename);
      this.vfs.writeFileSync(filename, code);
      const require = createRequire(this.vfs, this.fsShim, this.process, dirname$1, this.moduleCache, this.options, this.processedCodeCache);
      const module = {
        id: filename,
        filename,
        exports: {},
        loaded: false,
        children: [],
        paths: []
      };
      this.moduleCache[filename] = module;
      const consoleWrapper = createConsoleWrapper(this.options.onConsole);
      try {
        const importMetaUrl = "file://" + filename;
        const wrappedCode = `(function($exports, $require, $module, $filename, $dirname, $process, $console, $importMeta) {
var exports = $exports;
var require = $require;
var module = $module;
var __filename = $filename;
var __dirname = $dirname;
var process = $process;
var console = $console;
var import_meta = $importMeta;
// Set up global.process and globalThis.process for code that accesses them directly
var global = globalThis;
globalThis.process = $process;
global.process = $process;

return (function() {
${code}
}).call(this);
})`;
        const fn = eval(wrappedCode);
        fn(module.exports, require, module, filename, dirname$1, this.process, consoleWrapper, {
          url: importMetaUrl,
          dirname: dirname$1,
          filename
        });
        module.loaded = true;
      } catch (error) {
        delete this.moduleCache[filename];
        throw error;
      }
      return {
        exports: module.exports,
        module
      };
    }
    async executeAsync(code2, filename2 = "/index.js") {
      return Promise.resolve(this.execute(code2, filename2));
    }
    runFile(filename2) {
      const code2 = this.vfs.readFileSync(filename2, "utf8");
      return this.execute(code2, filename2);
    }
    async runFileAsync(filename2) {
      return Promise.resolve(this.runFile(filename2));
    }
    clearCache() {
      this.moduleCache = {};
    }
    getVFS() {
      return this.vfs;
    }
    getProcess() {
      return this.process;
    }
    createREPL() {
      const require2 = createRequire(this.vfs, this.fsShim, this.process, "/", this.moduleCache, this.options, this.processedCodeCache);
      const consoleWrapper2 = createConsoleWrapper(this.options.onConsole);
      const process22 = this.process;
      const buffer2 = bufferModule.Buffer;
      const GeneratorFunction = Object.getPrototypeOf(function* () {
      }).constructor;
      const replGen = new GeneratorFunction("require", "console", "process", "Buffer", `var __code, __result;
while (true) {
  __code = yield;
  try {
    __result = eval(__code);
    yield { value: __result, error: null };
  } catch (e) {
    yield { value: undefined, error: e };
  }
}`)(require2, consoleWrapper2, process22, buffer2);
      replGen.next();
      return {
        eval(code2) {
          const transformed = code2.replace(/^\s*(const|let)\s+/gm, "var ");
          const exprResult = replGen.next("(" + transformed + ")").value;
          if (!exprResult.error) {
            replGen.next();
            return exprResult.value;
          }
          replGen.next();
          const stmtResult = replGen.next(transformed).value;
          if (stmtResult.error) {
            replGen.next();
            throw stmtResult.error;
          }
          replGen.next();
          return stmtResult.value;
        }
      };
    }
  };
  execute = function(code2, vfs2, options2) {
    const runtime = new Runtime(vfs2, options2);
    return runtime.execute(code2);
  };
  WorkerRuntime = class {
    constructor(vfs2, options2 = {}) {
      __publicField(this, "worker");
      __publicField(this, "workerApi");
      __publicField(this, "vfs");
      __publicField(this, "options");
      __publicField(this, "initialized");
      __publicField(this, "changeListener", null);
      __publicField(this, "deleteListener", null);
      this.vfs = vfs2;
      this.options = options2;
      this.worker = new Worker(new URL("/assets/runtime-worker-6nZdzFoC.js", import.meta.url), {
        type: "module"
      });
      this.workerApi = wrap(this.worker);
      this.initialized = this.initWorker();
      this.setupVFSListeners();
    }
    async initWorker() {
      const snapshot = this.vfs.toSnapshot();
      const workerOptions = {
        cwd: this.options.cwd,
        env: this.options.env
      };
      await this.workerApi.init(snapshot, workerOptions);
      if (this.options.onConsole) {
        await this.workerApi.setConsoleCallback(proxy(this.options.onConsole));
      }
      console.log("[WorkerRuntime] Worker initialized");
    }
    setupVFSListeners() {
      this.changeListener = (path22, content) => {
        this.workerApi.syncFile(path22, content);
      };
      this.vfs.on("change", this.changeListener);
      this.deleteListener = (path22) => {
        this.workerApi.syncFile(path22, null);
      };
      this.vfs.on("delete", this.deleteListener);
    }
    async execute(code2, filename2) {
      await this.initialized;
      return this.workerApi.execute(code2, filename2);
    }
    async runFile(filename2) {
      await this.initialized;
      return this.workerApi.runFile(filename2);
    }
    clearCache() {
      this.workerApi.clearCache();
    }
    getVFS() {
      return this.vfs;
    }
    terminate() {
      if (this.changeListener) {
        this.vfs.off("change", this.changeListener);
      }
      if (this.deleteListener) {
        this.vfs.off("delete", this.deleteListener);
      }
      this.worker.terminate();
      console.log("[WorkerRuntime] Worker terminated");
    }
  };
  SandboxRuntime = class {
    constructor(sandboxUrl, vfs2, options2 = {}) {
      __publicField(this, "iframe");
      __publicField(this, "sandboxOrigin");
      __publicField(this, "vfs");
      __publicField(this, "options");
      __publicField(this, "initialized");
      __publicField(this, "pending", /* @__PURE__ */ new Map());
      __publicField(this, "messageId", 0);
      __publicField(this, "changeListener", null);
      __publicField(this, "deleteListener", null);
      __publicField(this, "messageHandler", null);
      this.sandboxOrigin = new URL(sandboxUrl).origin;
      this.vfs = vfs2;
      this.options = options2;
      this.iframe = document.createElement("iframe");
      this.iframe.src = sandboxUrl;
      this.iframe.style.display = "none";
      this.iframe.credentialless = true;
      this.iframe.setAttribute("credentialless", "");
      document.body.appendChild(this.iframe);
      this.setupMessageHandler();
      this.initialized = this.waitForReady().then(() => this.initSandbox());
      this.setupVFSListeners();
    }
    setupMessageHandler() {
      this.messageHandler = (event) => {
        if (event.origin !== this.sandboxOrigin)
          return;
        const message = event.data;
        if (message.type === "result" && message.id) {
          const pending = this.pending.get(message.id);
          if (pending && message.result) {
            pending.resolve(message.result);
            this.pending.delete(message.id);
          }
        } else if (message.type === "error" && message.id) {
          const pending = this.pending.get(message.id);
          if (pending) {
            pending.reject(new Error(message.error || "Unknown sandbox error"));
            this.pending.delete(message.id);
          }
        } else if (message.type === "console" && this.options.onConsole) {
          this.options.onConsole(message.consoleMethod || "log", message.consoleArgs || []);
        }
      };
      window.addEventListener("message", this.messageHandler);
    }
    waitForReady() {
      return new Promise((resolve2) => {
        const handler = (event) => {
          if (event.origin !== this.sandboxOrigin)
            return;
          const message = event.data;
          if (message.type === "ready") {
            window.removeEventListener("message", handler);
            resolve2();
          }
        };
        window.addEventListener("message", handler);
      });
    }
    async initSandbox() {
      var _a22;
      const snapshot = this.vfs.toSnapshot();
      const message = {
        type: "init",
        vfsSnapshot: snapshot,
        options: {
          cwd: this.options.cwd,
          env: this.options.env
        }
      };
      (_a22 = this.iframe.contentWindow) == null ? void 0 : _a22.postMessage(message, this.sandboxOrigin);
      console.log("[SandboxRuntime] Sandbox initialized");
    }
    setupVFSListeners() {
      this.changeListener = (path22, content) => {
        var _a22;
        const message = {
          type: "syncFile",
          path: path22,
          content
        };
        (_a22 = this.iframe.contentWindow) == null ? void 0 : _a22.postMessage(message, this.sandboxOrigin);
      };
      this.vfs.on("change", this.changeListener);
      this.deleteListener = (path22) => {
        var _a22;
        const message = {
          type: "syncFile",
          path: path22,
          content: null
        };
        (_a22 = this.iframe.contentWindow) == null ? void 0 : _a22.postMessage(message, this.sandboxOrigin);
      };
      this.vfs.on("delete", this.deleteListener);
    }
    sendAndWait(message) {
      return new Promise((resolve2, reject) => {
        var _a22;
        const id2 = String(this.messageId++);
        this.pending.set(id2, {
          resolve: resolve2,
          reject
        });
        (_a22 = this.iframe.contentWindow) == null ? void 0 : _a22.postMessage({
          ...message,
          id: id2
        }, this.sandboxOrigin);
        setTimeout(() => {
          if (this.pending.has(id2)) {
            this.pending.delete(id2);
            reject(new Error("Sandbox execution timeout"));
          }
        }, 6e4);
      });
    }
    async execute(code2, filename2) {
      await this.initialized;
      return this.sendAndWait({
        type: "execute",
        code: code2,
        filename: filename2
      });
    }
    async runFile(filename2) {
      await this.initialized;
      return this.sendAndWait({
        type: "runFile",
        filename: filename2
      });
    }
    clearCache() {
      var _a22;
      const message = {
        type: "clearCache"
      };
      (_a22 = this.iframe.contentWindow) == null ? void 0 : _a22.postMessage(message, this.sandboxOrigin);
    }
    getVFS() {
      return this.vfs;
    }
    terminate() {
      if (this.changeListener) {
        this.vfs.off("change", this.changeListener);
      }
      if (this.deleteListener) {
        this.vfs.off("delete", this.deleteListener);
      }
      if (this.messageHandler) {
        window.removeEventListener("message", this.messageHandler);
      }
      this.iframe.remove();
      for (const [id2, { reject }] of this.pending) {
        reject(new Error("Sandbox terminated"));
        this.pending.delete(id2);
      }
      console.log("[SandboxRuntime] Sandbox terminated");
    }
  };
  function isWorkerAvailable() {
    return typeof Worker !== "undefined";
  }
  class AsyncRuntimeWrapper {
    constructor(vfs2, options2 = {}) {
      __publicField(this, "runtime");
      this.runtime = new Runtime(vfs2, options2);
    }
    async execute(code2, filename2) {
      return Promise.resolve(this.runtime.execute(code2, filename2));
    }
    async runFile(filename2) {
      return Promise.resolve(this.runtime.runFile(filename2));
    }
    clearCache() {
      this.runtime.clearCache();
    }
    getVFS() {
      return this.runtime.getVFS();
    }
    getSyncRuntime() {
      return this.runtime;
    }
  }
  createRuntime = async function(vfs2, options2 = {}) {
    const { sandbox, dangerouslyAllowSameOrigin, useWorker = false, ...runtimeOptions } = options2;
    if (sandbox) {
      console.log("[createRuntime] Creating SandboxRuntime (cross-origin isolated)");
      const sandboxRuntime = new SandboxRuntime(sandbox, vfs2, runtimeOptions);
      await sandboxRuntime.execute("/* sandbox ready check */", "/__sandbox_init__.js");
      return sandboxRuntime;
    }
    if (!dangerouslyAllowSameOrigin) {
      throw new Error('almostnode: For security, you must either:\n  1. Use sandbox mode: { sandbox: "https://your-sandbox.vercel.app" }\n  2. Explicitly opt-in to same-origin: { dangerouslyAllowSameOrigin: true }\n\nSame-origin execution allows code to access cookies, localStorage, and IndexedDB.\nOnly use dangerouslyAllowSameOrigin for trusted code or demos.\n\nFor sandbox setup instructions, see: https://github.com/anthropics/almostnode#sandbox-setup');
    }
    let shouldUseWorker = false;
    if (useWorker === true) {
      shouldUseWorker = isWorkerAvailable();
      if (!shouldUseWorker) {
        console.warn("[createRuntime] Worker requested but not available, falling back to main thread");
      }
    } else if (useWorker === "auto") {
      shouldUseWorker = isWorkerAvailable();
      console.log(`[createRuntime] Auto mode: using ${shouldUseWorker ? "worker" : "main thread"}`);
    }
    if (shouldUseWorker) {
      console.log("[createRuntime] Creating WorkerRuntime (same-origin, thread-isolated)");
      const workerRuntime = new WorkerRuntime(vfs2, runtimeOptions);
      await workerRuntime.execute("/* worker ready check */", "/__worker_init__.js");
      return workerRuntime;
    }
    console.log("[createRuntime] Creating main-thread Runtime (same-origin, least secure)");
    return new AsyncRuntimeWrapper(vfs2, runtimeOptions);
  };
  function getServiceWorkerContent() {
    if (typeof __require === "undefined") {
      return null;
    }
    try {
      const fs22 = __require("fs");
      const path22 = __require("path");
      let dirname2;
      try {
        const url2 = __require("url");
        dirname2 = path22.dirname(url2.fileURLToPath(import.meta.url));
      } catch {
        dirname2 = __dirname;
      }
      let swPath = path22.join(dirname2, "__sw__.js");
      if (fs22.existsSync(swPath)) {
        return fs22.readFileSync(swPath, "utf-8");
      }
      swPath = path22.join(dirname2, "../dist/__sw__.js");
      if (fs22.existsSync(swPath)) {
        return fs22.readFileSync(swPath, "utf-8");
      }
      return null;
    } catch {
      return null;
    }
  }
  getSandboxHtml = function(options2 = {}) {
    const opts = typeof options2 === "string" ? {
      almostnodeUrl: options2
    } : options2;
    const almostnodeUrl = opts.almostnodeUrl ?? "https://unpkg.com/almostnode/dist/index.js";
    const includeServiceWorker = opts.includeServiceWorker ?? true;
    const serviceWorkerScript = includeServiceWorker ? `
  // Register service worker for dev server support
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/__sw__.js', { scope: '/' })
      .then(reg => console.log('[Sandbox] Service worker registered'))
      .catch(err => console.warn('[Sandbox] Service worker registration failed:', err));
  }
` : "";
    return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>almostnode Sandbox</title>
</head>
<body>
<script type="module">
  import { VirtualFS, Runtime } from '${almostnodeUrl}';
${serviceWorkerScript}

  let vfs = null;
  let runtime = null;
  let consoleCallback = null;

  // Handle messages from parent
  window.addEventListener('message', async (event) => {
    const { type, id, code, filename, vfsSnapshot, options, path, content } = event.data;

    try {
      switch (type) {
        case 'init':
          // Initialize VFS from snapshot
          vfs = VirtualFS.fromSnapshot(vfsSnapshot);

          // Create runtime with options
          runtime = new Runtime(vfs, {
            cwd: options?.cwd,
            env: options?.env,
            onConsole: (method, args) => {
              // Forward console to parent
              parent.postMessage({
                type: 'console',
                consoleMethod: method,
                consoleArgs: args,
              }, '*');
            },
          });
          break;

        case 'syncFile':
          // Sync file changes from parent
          if (vfs) {
            if (content === null) {
              try { vfs.unlinkSync(path); } catch {}
            } else {
              vfs.writeFileSync(path, content);
            }
          }
          break;

        case 'execute':
          if (!runtime) {
            parent.postMessage({ type: 'error', id, error: 'Runtime not initialized' }, '*');
            return;
          }
          const execResult = runtime.execute(code, filename);
          parent.postMessage({ type: 'result', id, result: execResult }, '*');
          break;

        case 'runFile':
          if (!runtime) {
            parent.postMessage({ type: 'error', id, error: 'Runtime not initialized' }, '*');
            return;
          }
          const runResult = runtime.runFile(filename);
          parent.postMessage({ type: 'result', id, result: runResult }, '*');
          break;

        case 'clearCache':
          if (runtime) {
            runtime.clearCache();
          }
          break;
      }
    } catch (error) {
      if (id) {
        parent.postMessage({
          type: 'error',
          id,
          error: error instanceof Error ? error.message : String(error),
        }, '*');
      }
    }
  });

  // Signal ready to parent
  parent.postMessage({ type: 'ready' }, '*');
<\/script>
</body>
</html>`;
  };
  getSandboxVercelConfig = function() {
    return {
      headers: [
        {
          source: "/(.*)",
          headers: [
            {
              key: "Access-Control-Allow-Origin",
              value: "*"
            },
            {
              key: "Cross-Origin-Resource-Policy",
              value: "cross-origin"
            }
          ]
        }
      ]
    };
  };
  generateSandboxFiles = function(options2 = {}) {
    const opts = typeof options2 === "string" ? {
      almostnodeUrl: options2
    } : options2;
    const includeServiceWorker = opts.includeServiceWorker ?? true;
    const swContent = includeServiceWorker ? getServiceWorkerContent() : null;
    const files = {
      "index.html": getSandboxHtml(opts),
      "vercel.json": JSON.stringify(getSandboxVercelConfig(), null, 2)
    };
    if (swContent) {
      files["__sw__.js"] = swContent;
    }
    return files;
  };
  SANDBOX_SETUP_INSTRUCTIONS = `
# Setting up a almostnode Sandbox on Vercel

## 1. Create sandbox directory
   mkdir sandbox

## 2. Generate sandbox files
   Use generateSandboxFiles() or copy the templates manually.

## 3. Deploy to Vercel
   cd sandbox
   vercel --prod

## 4. Use in your app
   const runtime = await createRuntime(vfs, {
     sandbox: 'https://your-sandbox.vercel.app'
   });

For more details, see: https://github.com/anthropics/almostnode#sandbox-setup
`.trim();
  const DEFAULT_REGISTRY = "https://registry.npmjs.org";
  class Registry {
    constructor(options2 = {}) {
      __publicField(this, "registryUrl");
      __publicField(this, "cache");
      this.registryUrl = options2.registry || DEFAULT_REGISTRY;
      this.cache = options2.cache || /* @__PURE__ */ new Map();
    }
    async getPackageManifest(packageName) {
      if (this.cache.has(packageName)) {
        return this.cache.get(packageName);
      }
      const url2 = `${this.registryUrl}/${encodePackageName(packageName)}`;
      const response = await fetch(url2, {
        headers: {
          Accept: "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8"
        }
      });
      if (!response.ok) {
        if (response.status === 404) {
          throw new Error(`Package not found: ${packageName}`);
        }
        throw new Error(`Failed to fetch package ${packageName}: ${response.status}`);
      }
      const manifest = await response.json();
      this.cache.set(packageName, manifest);
      return manifest;
    }
    async getPackageVersion(packageName, version2) {
      const manifest = await this.getPackageManifest(packageName);
      if (manifest["dist-tags"][version2]) {
        version2 = manifest["dist-tags"][version2];
      }
      const versionData = manifest.versions[version2];
      if (!versionData) {
        throw new Error(`Version ${version2} not found for package ${packageName}`);
      }
      return versionData;
    }
    async getLatestVersion(packageName) {
      const manifest = await this.getPackageManifest(packageName);
      return manifest["dist-tags"].latest;
    }
    async getVersions(packageName) {
      const manifest = await this.getPackageManifest(packageName);
      return Object.keys(manifest.versions);
    }
    async downloadTarball(tarballUrl) {
      const response = await fetch(tarballUrl);
      if (!response.ok) {
        throw new Error(`Failed to download tarball: ${response.status}`);
      }
      return response.arrayBuffer();
    }
    clearCache() {
      this.cache.clear();
    }
  }
  function encodePackageName(name2) {
    return name2.replace("/", "%2f");
  }
  new Registry();
  function parseVersion(version2) {
    const match2 = version2.match(/^(\d+)\.(\d+)\.(\d+)(?:-(.+))?$/);
    if (!match2)
      return null;
    return {
      major: parseInt(match2[1], 10),
      minor: parseInt(match2[2], 10),
      patch: parseInt(match2[3], 10),
      prerelease: match2[4]
    };
  }
  function compareVersions(a, b) {
    const parsedA = parseVersion(a);
    const parsedB = parseVersion(b);
    if (!parsedA || !parsedB) {
      return a.localeCompare(b);
    }
    if (parsedA.major !== parsedB.major) {
      return parsedA.major - parsedB.major;
    }
    if (parsedA.minor !== parsedB.minor) {
      return parsedA.minor - parsedB.minor;
    }
    if (parsedA.patch !== parsedB.patch) {
      return parsedA.patch - parsedB.patch;
    }
    if (parsedA.prerelease && !parsedB.prerelease)
      return -1;
    if (!parsedA.prerelease && parsedB.prerelease)
      return 1;
    if (parsedA.prerelease && parsedB.prerelease) {
      return parsedA.prerelease.localeCompare(parsedB.prerelease);
    }
    return 0;
  }
  function satisfies(version2, range2) {
    const parsed = parseVersion(version2);
    if (!parsed)
      return false;
    if (parsed.prerelease && !range2.includes("-")) {
      return false;
    }
    range2 = range2.trim();
    if (/^\d+\.\d+\.\d+/.test(range2) && !range2.includes(" ")) {
      const rangeMatch = range2.match(/^(\d+\.\d+\.\d+(?:-[^\s]+)?)/);
      if (rangeMatch) {
        return compareVersions(version2, rangeMatch[1]) === 0;
      }
    }
    if (range2 === "*" || range2 === "latest" || range2 === "") {
      return true;
    }
    if (range2.includes("||")) {
      return range2.split("||").some((r10) => satisfies(version2, r10.trim()));
    }
    if (range2.includes(" - ")) {
      const [min, max] = range2.split(" - ").map((s10) => s10.trim());
      return compareVersions(version2, min) >= 0 && compareVersions(version2, max) <= 0;
    }
    const operatorMatches = range2.match(/(>=|<=|>|<|=)?\s*(\d+\.\d+\.\d+(?:-[^\s]*)?)/g);
    if (operatorMatches && operatorMatches.length > 1) {
      return operatorMatches.every((match2) => {
        const m = match2.match(/^(>=|<=|>|<|=)?\s*(\d+\.\d+\.\d+(?:-[^\s]*)?)$/);
        if (!m)
          return true;
        const op2 = m[1] || "=";
        const ver = m[2];
        switch (op2) {
          case ">=":
            return compareVersions(version2, ver) >= 0;
          case "<=":
            return compareVersions(version2, ver) <= 0;
          case ">":
            return compareVersions(version2, ver) > 0;
          case "<":
            return compareVersions(version2, ver) < 0;
          case "=":
            return compareVersions(version2, ver) === 0;
          default:
            return compareVersions(version2, ver) === 0;
        }
      });
    }
    if (range2.startsWith("^")) {
      const base = range2.slice(1);
      const baseParsed = parseVersion(base);
      if (!baseParsed)
        return false;
      if (parsed.major !== baseParsed.major) {
        return false;
      }
      if (baseParsed.major === 0) {
        if (baseParsed.minor !== 0 && parsed.minor !== baseParsed.minor) {
          return false;
        }
        if (baseParsed.minor === 0 && parsed.minor !== 0) {
          return false;
        }
      }
      return compareVersions(version2, base) >= 0;
    }
    if (range2.startsWith("~")) {
      const base = range2.slice(1);
      const baseParsed = parseVersion(base);
      if (!baseParsed)
        return false;
      if (parsed.major !== baseParsed.major || parsed.minor !== baseParsed.minor) {
        return false;
      }
      return compareVersions(version2, base) >= 0;
    }
    if (range2.startsWith(">=")) {
      const base = range2.slice(2).trim();
      return compareVersions(version2, base) >= 0;
    }
    if (range2.startsWith(">")) {
      const base = range2.slice(1).trim();
      return compareVersions(version2, base) > 0;
    }
    if (range2.startsWith("<=")) {
      const base = range2.slice(2).trim();
      return compareVersions(version2, base) <= 0;
    }
    if (range2.startsWith("<")) {
      const base = range2.slice(1).trim();
      return compareVersions(version2, base) < 0;
    }
    if (range2.includes("x") || range2.includes("X") || /^\d+$/.test(range2) || /^\d+\.\d+$/.test(range2)) {
      const parts = range2.replace(/[xX]/g, "").split(".").filter(Boolean);
      if (parts.length === 1) {
        return parsed.major === parseInt(parts[0], 10);
      }
      if (parts.length === 2) {
        return parsed.major === parseInt(parts[0], 10) && parsed.minor === parseInt(parts[1], 10);
      }
    }
    if (range2.includes(" ")) {
      const conditions = range2.split(/\s+/).filter(Boolean);
      return conditions.every((r10) => satisfies(version2, r10));
    }
    return compareVersions(version2, range2) === 0;
  }
  function findBestVersion(versions, range2) {
    const sorted = [
      ...versions
    ].sort((a, b) => compareVersions(b, a));
    for (const version2 of sorted) {
      if (satisfies(version2, range2)) {
        return version2;
      }
    }
    return null;
  }
  async function resolveDependencies(packageName, versionRange = "latest", options2 = {}) {
    const registry = options2.registry || new Registry();
    const context2 = {
      registry,
      resolved: /* @__PURE__ */ new Map(),
      resolving: /* @__PURE__ */ new Set(),
      options: options2
    };
    await resolvePackage(packageName, versionRange, context2);
    return context2.resolved;
  }
  async function resolveFromPackageJson(packageJson, options2 = {}) {
    const registry = options2.registry || new Registry();
    const context2 = {
      registry,
      resolved: /* @__PURE__ */ new Map(),
      resolving: /* @__PURE__ */ new Set(),
      options: options2
    };
    const deps = {
      ...packageJson.dependencies
    };
    if (options2.includeDev && packageJson.devDependencies) {
      Object.assign(deps, packageJson.devDependencies);
    }
    for (const [name2, range2] of Object.entries(deps)) {
      await resolvePackage(name2, range2, context2);
    }
    return context2.resolved;
  }
  async function resolvePackage(packageName, versionRange, context2) {
    var _a22;
    const { registry, resolved, resolving, options: options2 } = context2;
    const key = `${packageName}@${versionRange}`;
    if (resolving.has(key)) {
      return;
    }
    if (resolved.has(packageName)) {
      const existing = resolved.get(packageName);
      if (satisfies(existing.version, versionRange)) {
        return;
      }
      return;
    }
    resolving.add(key);
    try {
      (_a22 = options2.onProgress) == null ? void 0 : _a22.call(options2, `Resolving ${packageName}@${versionRange}`);
      const manifest = await registry.getPackageManifest(packageName);
      const versions = Object.keys(manifest.versions);
      let targetVersion;
      if (versionRange === "latest" || versionRange === "*") {
        targetVersion = manifest["dist-tags"].latest;
      } else if (manifest["dist-tags"][versionRange]) {
        targetVersion = manifest["dist-tags"][versionRange];
      } else {
        const best = findBestVersion(versions, versionRange);
        if (!best) {
          throw new Error(`No matching version found for ${packageName}@${versionRange}`);
        }
        targetVersion = best;
      }
      const versionData = manifest.versions[targetVersion];
      const resolvedPackage = {
        name: packageName,
        version: targetVersion,
        tarballUrl: versionData.dist.tarball,
        dependencies: versionData.dependencies || {}
      };
      resolved.set(packageName, resolvedPackage);
      const deps = {
        ...versionData.dependencies
      };
      if (options2.includeOptional && versionData.optionalDependencies) {
        Object.assign(deps, versionData.optionalDependencies);
      }
      const depEntries = Object.entries(deps);
      if (depEntries.length > 0) {
        const CONCURRENCY = 8;
        for (let i22 = 0; i22 < depEntries.length; i22 += CONCURRENCY) {
          const batch = depEntries.slice(i22, i22 + CONCURRENCY);
          await Promise.all(batch.map(([depName, depRange]) => resolvePackage(depName, depRange, context2)));
        }
      }
    } finally {
      resolving.delete(key);
    }
  }
  function* parseTar(data2) {
    new TextDecoder();
    let offset = 0;
    while (offset < data2.length - 512) {
      const header = data2.slice(offset, offset + 512);
      offset += 512;
      if (header.every((b) => b === 0)) {
        break;
      }
      const name2 = parseString(header, 0, 100);
      const mode = parseOctal(header, 100, 8);
      const size = parseOctal(header, 124, 12);
      const typeFlag = String.fromCharCode(header[156]);
      const linkName = parseString(header, 157, 100);
      const prefix = parseString(header, 345, 155);
      if (!name2) {
        continue;
      }
      const fullName = prefix ? `${prefix}/${name2}` : name2;
      let type2;
      switch (typeFlag) {
        case "0":
        case "\0":
        case "":
          type2 = "file";
          break;
        case "5":
          type2 = "directory";
          break;
        case "1":
        case "2":
          type2 = "symlink";
          break;
        default:
          type2 = "unknown";
      }
      let content;
      if (type2 === "file" && size > 0) {
        content = data2.slice(offset, offset + size);
        offset += Math.ceil(size / 512) * 512;
      }
      yield {
        name: fullName,
        type: type2,
        size,
        mode,
        content,
        linkTarget: type2 === "symlink" ? linkName : void 0
      };
    }
  }
  function parseString(data2, offset, length2) {
    const bytes = data2.slice(offset, offset + length2);
    const nullIndex = bytes.indexOf(0);
    const actualBytes = nullIndex >= 0 ? bytes.slice(0, nullIndex) : bytes;
    return new TextDecoder().decode(actualBytes);
  }
  function parseOctal(data2, offset, length2) {
    const str = parseString(data2, offset, length2).trim();
    return parseInt(str, 8) || 0;
  }
  function decompress(data2) {
    const input = data2 instanceof Uint8Array ? data2 : new Uint8Array(data2);
    return pako.inflate(input);
  }
  function extractTarball(tarballData, vfs2, destPath, options2 = {}) {
    const { stripComponents = 1, filter: filter2, onProgress } = options2;
    onProgress == null ? void 0 : onProgress("Decompressing...");
    const tarData = decompress(tarballData);
    const extractedFiles = [];
    for (const entry of parseTar(tarData)) {
      if (entry.type !== "file" && entry.type !== "directory") {
        continue;
      }
      let entryPath = entry.name;
      if (stripComponents > 0) {
        const parts = entryPath.split("/").filter(Boolean);
        if (parts.length <= stripComponents) {
          continue;
        }
        entryPath = parts.slice(stripComponents).join("/");
      }
      if (filter2 && !filter2(entryPath)) {
        continue;
      }
      const fullPath = join(destPath, entryPath);
      if (entry.type === "directory") {
        vfs2.mkdirSync(fullPath, {
          recursive: true
        });
      } else if (entry.type === "file" && entry.content) {
        const parentDir = dirname(fullPath);
        vfs2.mkdirSync(parentDir, {
          recursive: true
        });
        vfs2.writeFileSync(fullPath, entry.content);
        extractedFiles.push(fullPath);
      }
    }
    onProgress == null ? void 0 : onProgress(`Extracted ${extractedFiles.length} files`);
    return extractedFiles;
  }
  async function downloadAndExtract(url2, vfs2, destPath, options2 = {}) {
    const { onProgress } = options2;
    onProgress == null ? void 0 : onProgress(`Downloading ${url2}...`);
    const response = await fetch(url2);
    if (!response.ok) {
      throw new Error(`Failed to download tarball: ${response.status}`);
    }
    const data2 = await response.arrayBuffer();
    return extractTarball(data2, vfs2, destPath, options2);
  }
  const isBrowser$2 = typeof window !== "undefined";
  async function initTransformer() {
    if (!isBrowser$2) {
      console.log("[transform] Skipping esbuild init (not in browser)");
      return;
    }
    if (window.__esbuild) {
      console.log("[transform] Reusing existing esbuild instance");
      return;
    }
    if (window.__esbuildInitPromise) {
      return window.__esbuildInitPromise;
    }
    window.__esbuildInitPromise = (async () => {
      try {
        console.log("[transform] Loading esbuild-wasm...");
        const mod = await import("https://esm.sh/esbuild-wasm@0.20.0").then(async (m) => {
          await m.__tla;
          return m;
        });
        const esbuildMod = mod.default || mod;
        try {
          await esbuildMod.initialize({
            wasmURL: "https://unpkg.com/esbuild-wasm@0.20.0/esbuild.wasm"
          });
          console.log("[transform] esbuild-wasm initialized");
        } catch (initError) {
          if (initError instanceof Error && initError.message.includes('Cannot call "initialize" more than once')) {
            console.log("[transform] esbuild-wasm already initialized, reusing");
          } else {
            throw initError;
          }
        }
        window.__esbuild = esbuildMod;
      } catch (error) {
        console.error("[transform] Failed to initialize esbuild:", error);
        window.__esbuildInitPromise = void 0;
        throw error;
      }
    })();
    return window.__esbuildInitPromise;
  }
  function isTransformerReady() {
    if (!isBrowser$2)
      return true;
    return window.__esbuild !== void 0;
  }
  async function transformFile(code2, filename2) {
    if (!isBrowser$2) {
      return code2;
    }
    if (!window.__esbuild) {
      await initTransformer();
    }
    const esbuild2 = window.__esbuild;
    if (!esbuild2) {
      throw new Error("esbuild not initialized");
    }
    let loader = "js";
    if (filename2.endsWith(".jsx"))
      loader = "jsx";
    else if (filename2.endsWith(".ts"))
      loader = "ts";
    else if (filename2.endsWith(".tsx"))
      loader = "tsx";
    else if (filename2.endsWith(".mjs"))
      loader = "js";
    try {
      const result = await esbuild2.transform(code2, {
        loader,
        format: "cjs",
        target: "esnext",
        platform: "neutral",
        define: {
          "import.meta.url": "import_meta.url",
          "import.meta.dirname": "import_meta.dirname",
          "import.meta.filename": "import_meta.filename",
          "import.meta": "import_meta"
        }
      });
      let transformed = result.code;
      transformed = transformed.replace(/\bimport\s*\(\s*["']node:([^"']+)["']\s*\)/g, 'Promise.resolve(require("node:$1"))');
      const nodeBuiltins = [
        "assert",
        "buffer",
        "child_process",
        "cluster",
        "crypto",
        "dgram",
        "dns",
        "events",
        "fs",
        "http",
        "http2",
        "https",
        "net",
        "os",
        "path",
        "perf_hooks",
        "querystring",
        "readline",
        "stream",
        "string_decoder",
        "timers",
        "tls",
        "url",
        "util",
        "v8",
        "vm",
        "worker_threads",
        "zlib",
        "async_hooks",
        "inspector",
        "module"
      ];
      for (const builtin of nodeBuiltins) {
        const pattern = new RegExp(`\\bimport\\s*\\(\\s*["']${builtin}["']\\s*\\)`, "g");
        transformed = transformed.replace(pattern, `Promise.resolve(require("${builtin}"))`);
      }
      return transformed;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      if (errorMsg.includes("Top-level await")) {
        console.log(`[transform] Skipping ${filename2} (has top-level await, likely CLI entry point)`);
        return code2;
      }
      console.warn(`[transform] Failed to transform ${filename2}:`, error);
      return code2;
    }
  }
  function needsTransform$1(filename2, code2) {
    if (filename2.endsWith(".mjs")) {
      return true;
    }
    if (filename2.endsWith(".cjs")) {
      return false;
    }
    const hasImport = /\bimport\s+[\w{*'"]/m.test(code2);
    const hasExport = /\bexport\s+(?:default|const|let|var|function|class|{|\*)/m.test(code2);
    const hasImportMeta = /\bimport\.meta\b/.test(code2);
    return hasImport || hasExport || hasImportMeta;
  }
  function hasDynamicNodeImports(code2) {
    if (/\bimport\s*\(\s*["']node:/.test(code2)) {
      return true;
    }
    if (/\bimport\s*\(\s*["'](fs|path|http|https|net|url|util|events|stream|os|crypto)["']/.test(code2)) {
      return true;
    }
    return false;
  }
  function patchDynamicImports(code2) {
    let patched = code2;
    patched = patched.replace(/\bimport\s*\(\s*["']node:([^"']+)["']\s*\)/g, 'Promise.resolve(require("node:$1"))');
    const nodeBuiltins = [
      "assert",
      "buffer",
      "child_process",
      "cluster",
      "crypto",
      "dgram",
      "dns",
      "events",
      "fs",
      "http",
      "http2",
      "https",
      "net",
      "os",
      "path",
      "perf_hooks",
      "querystring",
      "readline",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "url",
      "util",
      "v8",
      "vm",
      "worker_threads",
      "zlib",
      "async_hooks",
      "inspector",
      "module"
    ];
    for (const builtin of nodeBuiltins) {
      const pattern = new RegExp(`\\bimport\\s*\\(\\s*["']${builtin}["']\\s*\\)`, "g");
      patched = patched.replace(pattern, `Promise.resolve(require("${builtin}"))`);
    }
    return patched;
  }
  async function transformPackage(vfs2, pkgPath, onProgress) {
    let transformedCount = 0;
    const jsFiles = findJsFiles(vfs2, pkgPath);
    onProgress == null ? void 0 : onProgress(`  Transforming ${jsFiles.length} files in ${pkgPath}...`);
    const BATCH_SIZE = 10;
    for (let i22 = 0; i22 < jsFiles.length; i22 += BATCH_SIZE) {
      const batch = jsFiles.slice(i22, i22 + BATCH_SIZE);
      await Promise.all(batch.map(async (filePath) => {
        try {
          const code2 = vfs2.readFileSync(filePath, "utf8");
          if (needsTransform$1(filePath, code2)) {
            const transformed = await transformFile(code2, filePath);
            vfs2.writeFileSync(filePath, transformed);
            transformedCount++;
          } else if (hasDynamicNodeImports(code2)) {
            const patched = patchDynamicImports(code2);
            vfs2.writeFileSync(filePath, patched);
            transformedCount++;
          }
        } catch (error) {
          console.warn(`[transform] Skipping ${filePath}:`, error);
        }
      }));
    }
    return transformedCount;
  }
  function findJsFiles(vfs2, dir) {
    const files = [];
    try {
      const entries = vfs2.readdirSync(dir);
      for (const entry of entries) {
        const fullPath = dir + "/" + entry;
        try {
          const stat = vfs2.statSync(fullPath);
          if (stat.isDirectory()) {
            if (entry !== "node_modules") {
              files.push(...findJsFiles(vfs2, fullPath));
            }
          } else if (entry.endsWith(".js") || entry.endsWith(".mjs") || entry.endsWith(".jsx")) {
            files.push(fullPath);
          }
        } catch {
        }
      }
    } catch {
    }
    return files;
  }
  PackageManager = class {
    constructor(vfs2, options2 = {}) {
      __publicField(this, "vfs");
      __publicField(this, "registry");
      __publicField(this, "cwd");
      this.vfs = vfs2;
      this.registry = new Registry(options2);
      this.cwd = options2.cwd || "/";
    }
    async install(packageSpec, options2 = {}) {
      const { onProgress } = options2;
      const { name: name2, version: version2 } = parsePackageSpec(packageSpec);
      onProgress == null ? void 0 : onProgress(`Resolving ${name2}@${version2 || "latest"}...`);
      const resolved = await resolveDependencies(name2, version2 || "latest", {
        registry: this.registry,
        includeDev: options2.includeDev,
        includeOptional: options2.includeOptional,
        onProgress
      });
      const added = await this.installResolved(resolved, options2);
      if (options2.save || options2.saveDev) {
        const pkgToAdd = resolved.get(name2);
        if (pkgToAdd) {
          await this.updatePackageJson(name2, `^${pkgToAdd.version}`, options2.saveDev || false);
        }
      }
      onProgress == null ? void 0 : onProgress(`Installed ${resolved.size} packages`);
      return {
        installed: resolved,
        added
      };
    }
    async installFromPackageJson(options2 = {}) {
      const { onProgress } = options2;
      const pkgJsonPath = join(this.cwd, "package.json");
      if (!this.vfs.existsSync(pkgJsonPath)) {
        throw new Error("No package.json found");
      }
      const pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
      onProgress == null ? void 0 : onProgress("Resolving dependencies...");
      const resolved = await resolveFromPackageJson(pkgJson, {
        registry: this.registry,
        includeDev: options2.includeDev,
        includeOptional: options2.includeOptional,
        onProgress
      });
      const added = await this.installResolved(resolved, options2);
      onProgress == null ? void 0 : onProgress(`Installed ${resolved.size} packages`);
      return {
        installed: resolved,
        added
      };
    }
    async installResolved(resolved, options2) {
      const { onProgress } = options2;
      const added = [];
      const nodeModulesPath = join(this.cwd, "node_modules");
      this.vfs.mkdirSync(nodeModulesPath, {
        recursive: true
      });
      const toInstall = [];
      for (const [name2, pkg] of resolved) {
        const pkgPath = join(nodeModulesPath, name2);
        const existingPkgJson = join(pkgPath, "package.json");
        if (this.vfs.existsSync(existingPkgJson)) {
          try {
            const existing = JSON.parse(this.vfs.readFileSync(existingPkgJson, "utf8"));
            if (existing.version === pkg.version) {
              onProgress == null ? void 0 : onProgress(`Skipping ${name2}@${pkg.version} (already installed)`);
              continue;
            }
          } catch {
          }
        }
        toInstall.push({
          name: name2,
          pkg,
          pkgPath
        });
      }
      const shouldTransform = options2.transform !== false;
      if (shouldTransform && !isTransformerReady()) {
        onProgress == null ? void 0 : onProgress("Initializing ESM transformer...");
        await initTransformer();
      }
      const CONCURRENCY = 6;
      onProgress == null ? void 0 : onProgress(`Installing ${toInstall.length} packages...`);
      for (let i22 = 0; i22 < toInstall.length; i22 += CONCURRENCY) {
        const batch = toInstall.slice(i22, i22 + CONCURRENCY);
        await Promise.all(batch.map(async ({ name: name2, pkg, pkgPath }) => {
          onProgress == null ? void 0 : onProgress(`  Downloading ${name2}@${pkg.version}...`);
          await downloadAndExtract(pkg.tarballUrl, this.vfs, pkgPath, {
            stripComponents: 1
          });
          if (shouldTransform) {
            try {
              const count = await transformPackage(this.vfs, pkgPath, onProgress);
              if (count > 0) {
                onProgress == null ? void 0 : onProgress(`  Transformed ${count} files in ${name2}`);
              }
            } catch (transformError) {
              onProgress == null ? void 0 : onProgress(`  Warning: Transform failed for ${name2}: ${transformError}`);
            }
          }
          added.push(name2);
        }));
      }
      await this.writeLockfile(resolved);
      return added;
    }
    async writeLockfile(resolved) {
      const lockfile = {};
      for (const [name2, pkg] of resolved) {
        lockfile[name2] = {
          version: pkg.version,
          resolved: pkg.tarballUrl
        };
      }
      const lockfilePath = join(this.cwd, "node_modules", ".package-lock.json");
      this.vfs.writeFileSync(lockfilePath, JSON.stringify(lockfile, null, 2));
    }
    async updatePackageJson(packageName, version2, isDev) {
      const pkgJsonPath = join(this.cwd, "package.json");
      let pkgJson = {};
      if (this.vfs.existsSync(pkgJsonPath)) {
        pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
      }
      const field = isDev ? "devDependencies" : "dependencies";
      if (!pkgJson[field]) {
        pkgJson[field] = {};
      }
      pkgJson[field][packageName] = version2;
      this.vfs.writeFileSync(pkgJsonPath, JSON.stringify(pkgJson, null, 2));
    }
    list() {
      const nodeModulesPath = join(this.cwd, "node_modules");
      if (!this.vfs.existsSync(nodeModulesPath)) {
        return {};
      }
      const packages = {};
      const entries = this.vfs.readdirSync(nodeModulesPath);
      for (const entry of entries) {
        if (entry.startsWith("."))
          continue;
        if (entry.startsWith("@")) {
          const scopePath = join(nodeModulesPath, entry);
          const scopedPkgs = this.vfs.readdirSync(scopePath);
          for (const scopedPkg of scopedPkgs) {
            const pkgJsonPath = join(scopePath, scopedPkg, "package.json");
            if (this.vfs.existsSync(pkgJsonPath)) {
              const pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
              packages[`${entry}/${scopedPkg}`] = pkgJson.version;
            }
          }
        } else {
          const pkgJsonPath = join(nodeModulesPath, entry, "package.json");
          if (this.vfs.existsSync(pkgJsonPath)) {
            const pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
            packages[entry] = pkgJson.version;
          }
        }
      }
      return packages;
    }
  };
  function parsePackageSpec(spec2) {
    if (spec2.startsWith("@")) {
      const slashIndex = spec2.indexOf("/");
      if (slashIndex === -1) {
        throw new Error(`Invalid package spec: ${spec2}`);
      }
      const afterSlash = spec2.slice(slashIndex + 1);
      const atIndex2 = afterSlash.indexOf("@");
      if (atIndex2 === -1) {
        return {
          name: spec2
        };
      }
      return {
        name: spec2.slice(0, slashIndex + 1 + atIndex2),
        version: afterSlash.slice(atIndex2 + 1)
      };
    }
    const atIndex = spec2.indexOf("@");
    if (atIndex === -1) {
      return {
        name: spec2
      };
    }
    return {
      name: spec2.slice(0, atIndex),
      version: spec2.slice(atIndex + 1)
    };
  }
  install = async function(packageSpec, vfs2, options2) {
    const pm2 = new PackageManager(vfs2);
    return pm2.install(packageSpec, options2);
  };
  index = Object.freeze(Object.defineProperty({
    __proto__: null,
    PackageManager,
    Registry,
    install,
    parsePackageSpec
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const _encoder = new TextEncoder();
  ServerBridge = (_c = class extends EventEmitter {
    constructor(options2 = {}) {
      super();
      __publicField(this, "servers", /* @__PURE__ */ new Map());
      __publicField(this, "baseUrl");
      __publicField(this, "options");
      __publicField(this, "messageChannel", null);
      __publicField(this, "serviceWorkerReady", false);
      __publicField(this, "keepaliveInterval", null);
      this.options = options2;
      if (typeof location !== "undefined") {
        this.baseUrl = options2.baseUrl || `${location.protocol}//${location.host}`;
      } else {
        this.baseUrl = options2.baseUrl || "http://localhost";
      }
      setServerListenCallback((port, server) => {
        this.registerServer(server, port);
      });
      setServerCloseCallback((port) => {
        this.unregisterServer(port);
      });
    }
    registerServer(server, port, hostname2 = "0.0.0.0") {
      this.servers.set(port, {
        server,
        port,
        hostname: hostname2
      });
      const url2 = this.getServerUrl(port);
      this.emit("server-ready", port, url2);
      if (this.options.onServerReady) {
        this.options.onServerReady(port, url2);
      }
      this.notifyServiceWorker("server-registered", {
        port,
        hostname: hostname2
      });
    }
    unregisterServer(port) {
      this.servers.delete(port);
      this.notifyServiceWorker("server-unregistered", {
        port
      });
    }
    getServerUrl(port) {
      return `${this.baseUrl}/__virtual__/${port}`;
    }
    getServerPorts() {
      return [
        ...this.servers.keys()
      ];
    }
    async handleRequest(port, method, url2, headers, body) {
      const virtualServer = this.servers.get(port);
      if (!virtualServer) {
        return {
          statusCode: 503,
          statusMessage: "Service Unavailable",
          headers: {
            "Content-Type": "text/plain"
          },
          body: BufferPolyfill.from(`No server listening on port ${port}`)
        };
      }
      try {
        const bodyBuffer = body ? BufferPolyfill.from(new Uint8Array(body)) : void 0;
        return await virtualServer.server.handleRequest(method, url2, headers, bodyBuffer);
      } catch (error) {
        const message = error instanceof Error ? error.message : "Internal Server Error";
        return {
          statusCode: 500,
          statusMessage: "Internal Server Error",
          headers: {
            "Content-Type": "text/plain"
          },
          body: BufferPolyfill.from(message)
        };
      }
    }
    async initServiceWorker(options2) {
      if (!("serviceWorker" in navigator)) {
        throw new Error("Service Workers not supported");
      }
      const swUrl = (options2 == null ? void 0 : options2.swUrl) ?? "/__sw__.js";
      const controllerReady = navigator.serviceWorker.controller ? Promise.resolve() : new Promise((resolve2) => {
        navigator.serviceWorker.addEventListener("controllerchange", () => resolve2(), {
          once: true
        });
      });
      const registration = await navigator.serviceWorker.register(swUrl, {
        scope: "/"
      });
      const sw = registration.active || registration.waiting || registration.installing;
      if (!sw) {
        throw new Error("Service Worker registration failed");
      }
      await new Promise((resolve2) => {
        if (sw.state === "activated") {
          resolve2();
        } else {
          const handler = () => {
            if (sw.state === "activated") {
              sw.removeEventListener("statechange", handler);
              resolve2();
            }
          };
          sw.addEventListener("statechange", handler);
        }
      });
      this.messageChannel = new MessageChannel();
      this.messageChannel.port1.onmessage = this.handleServiceWorkerMessage.bind(this);
      sw.postMessage({
        type: "init",
        port: this.messageChannel.port2
      }, [
        this.messageChannel.port2
      ]);
      await controllerReady;
      const reinit = () => {
        if (navigator.serviceWorker.controller) {
          this.messageChannel = new MessageChannel();
          this.messageChannel.port1.onmessage = this.handleServiceWorkerMessage.bind(this);
          navigator.serviceWorker.controller.postMessage({
            type: "init",
            port: this.messageChannel.port2
          }, [
            this.messageChannel.port2
          ]);
        }
      };
      navigator.serviceWorker.addEventListener("controllerchange", reinit);
      navigator.serviceWorker.addEventListener("message", (event) => {
        var _a22;
        if (((_a22 = event.data) == null ? void 0 : _a22.type) === "sw-needs-init") {
          reinit();
        }
      });
      this.keepaliveInterval = setInterval(() => {
        var _a22;
        (_a22 = this.messageChannel) == null ? void 0 : _a22.port1.postMessage({
          type: "keepalive"
        });
      }, 2e4);
      this.serviceWorkerReady = true;
      this.emit("sw-ready");
    }
    async handleServiceWorkerMessage(event) {
      var _a22, _b22, _c22;
      const { type: type2, id: id2, data: data2 } = event.data;
      ServerBridge.DEBUG && console.log("[ServerBridge] SW message:", type2, id2, data2 == null ? void 0 : data2.url);
      if (type2 === "request") {
        const { port, method, url: url2, headers, body, streaming } = data2;
        ServerBridge.DEBUG && console.log("[ServerBridge] Handling request:", port, method, url2, "streaming:", streaming);
        if (streaming) {
          ServerBridge.DEBUG && console.log("[ServerBridge] \u{1F534} Will use streaming handler");
        }
        try {
          if (streaming) {
            await this.handleStreamingRequest(id2, port, method, url2, headers, body);
          } else {
            const response = await this.handleRequest(port, method, url2, headers, body);
            ServerBridge.DEBUG && console.log("[ServerBridge] Response:", response.statusCode, "body length:", (_a22 = response.body) == null ? void 0 : _a22.length);
            let bodyBase64 = "";
            if (response.body && response.body.length > 0) {
              const bytes = response.body instanceof Uint8Array ? response.body : new Uint8Array(0);
              bodyBase64 = uint8ToBase64(bytes);
            }
            ServerBridge.DEBUG && console.log("[ServerBridge] Sending response to SW, body base64 length:", bodyBase64.length);
            (_b22 = this.messageChannel) == null ? void 0 : _b22.port1.postMessage({
              type: "response",
              id: id2,
              data: {
                statusCode: response.statusCode,
                statusMessage: response.statusMessage,
                headers: response.headers,
                bodyBase64
              }
            });
          }
        } catch (error) {
          (_c22 = this.messageChannel) == null ? void 0 : _c22.port1.postMessage({
            type: "response",
            id: id2,
            error: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    }
    async handleStreamingRequest(id2, port, method, url2, headers, body) {
      var _a22, _b22, _c22, _d2, _e2;
      const virtualServer = this.servers.get(port);
      if (!virtualServer) {
        (_a22 = this.messageChannel) == null ? void 0 : _a22.port1.postMessage({
          type: "stream-start",
          id: id2,
          data: {
            statusCode: 503,
            statusMessage: "Service Unavailable",
            headers: {}
          }
        });
        (_b22 = this.messageChannel) == null ? void 0 : _b22.port1.postMessage({
          type: "stream-end",
          id: id2
        });
        return;
      }
      const server = virtualServer.server;
      if (typeof server.handleStreamingRequest === "function") {
        ServerBridge.DEBUG && console.log("[ServerBridge] \u{1F7E2} Server has streaming support, calling handleStreamingRequest");
        const bodyBuffer = body ? BufferPolyfill.from(new Uint8Array(body)) : void 0;
        await server.handleStreamingRequest(method, url2, headers, bodyBuffer, (statusCode, statusMessage, respHeaders) => {
          var _a3;
          ServerBridge.DEBUG && console.log("[ServerBridge] \u{1F7E2} onStart called, sending stream-start");
          (_a3 = this.messageChannel) == null ? void 0 : _a3.port1.postMessage({
            type: "stream-start",
            id: id2,
            data: {
              statusCode,
              statusMessage,
              headers: respHeaders
            }
          });
        }, (chunk) => {
          var _a3;
          const bytes = typeof chunk === "string" ? _encoder.encode(chunk) : chunk;
          const chunkBase64 = uint8ToBase64(bytes);
          ServerBridge.DEBUG && console.log("[ServerBridge] \u{1F7E1} onChunk called, sending stream-chunk, size:", chunkBase64.length);
          (_a3 = this.messageChannel) == null ? void 0 : _a3.port1.postMessage({
            type: "stream-chunk",
            id: id2,
            data: {
              chunkBase64
            }
          });
        }, () => {
          var _a3;
          ServerBridge.DEBUG && console.log("[ServerBridge] \u{1F7E2} onEnd called, sending stream-end");
          (_a3 = this.messageChannel) == null ? void 0 : _a3.port1.postMessage({
            type: "stream-end",
            id: id2
          });
        });
      } else {
        const bodyBuffer = body ? BufferPolyfill.from(new Uint8Array(body)) : void 0;
        const response = await virtualServer.server.handleRequest(method, url2, headers, bodyBuffer);
        (_c22 = this.messageChannel) == null ? void 0 : _c22.port1.postMessage({
          type: "stream-start",
          id: id2,
          data: {
            statusCode: response.statusCode,
            statusMessage: response.statusMessage,
            headers: response.headers
          }
        });
        if (response.body && response.body.length > 0) {
          const bytes = response.body instanceof Uint8Array ? response.body : new Uint8Array(0);
          (_d2 = this.messageChannel) == null ? void 0 : _d2.port1.postMessage({
            type: "stream-chunk",
            id: id2,
            data: {
              chunkBase64: uint8ToBase64(bytes)
            }
          });
        }
        (_e2 = this.messageChannel) == null ? void 0 : _e2.port1.postMessage({
          type: "stream-end",
          id: id2
        });
      }
    }
    notifyServiceWorker(type2, data2) {
      if (this.serviceWorkerReady && this.messageChannel) {
        this.messageChannel.port1.postMessage({
          type: type2,
          data: data2
        });
      }
    }
    createFetchHandler() {
      return async (request2) => {
        const url2 = new URL(request2.url);
        const match2 = url2.pathname.match(/^\/__virtual__\/(\d+)(\/.*)?$/);
        if (!match2) {
          throw new Error("Not a virtual server request");
        }
        const port = parseInt(match2[1], 10);
        const path22 = match2[2] || "/";
        const headers = {};
        request2.headers.forEach((value2, key) => {
          headers[key] = value2;
        });
        let body;
        if (request2.method !== "GET" && request2.method !== "HEAD") {
          body = await request2.arrayBuffer();
        }
        const response = await this.handleRequest(port, request2.method, path22 + url2.search, headers, body);
        return new Response(response.body, {
          status: response.statusCode,
          statusText: response.statusMessage,
          headers: response.headers
        });
      };
    }
  }, __publicField(_c, "DEBUG", false), _c);
  let globalBridge = null;
  getServerBridge = function(options2) {
    if (!globalBridge) {
      globalBridge = new ServerBridge(options2);
    }
    return globalBridge;
  };
  resetServerBridge = function() {
    globalBridge = null;
  };
  const MIME_TYPES = {
    html: "text/html; charset=utf-8",
    htm: "text/html; charset=utf-8",
    css: "text/css; charset=utf-8",
    js: "application/javascript; charset=utf-8",
    mjs: "application/javascript; charset=utf-8",
    cjs: "application/javascript; charset=utf-8",
    jsx: "application/javascript; charset=utf-8",
    ts: "application/javascript; charset=utf-8",
    tsx: "application/javascript; charset=utf-8",
    json: "application/json; charset=utf-8",
    png: "image/png",
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    gif: "image/gif",
    svg: "image/svg+xml",
    ico: "image/x-icon",
    webp: "image/webp",
    woff: "font/woff",
    woff2: "font/woff2",
    ttf: "font/ttf",
    otf: "font/otf",
    eot: "application/vnd.ms-fontobject",
    mp3: "audio/mpeg",
    mp4: "video/mp4",
    webm: "video/webm",
    ogg: "audio/ogg",
    wav: "audio/wav",
    pdf: "application/pdf",
    xml: "application/xml",
    txt: "text/plain; charset=utf-8",
    md: "text/markdown; charset=utf-8",
    wasm: "application/wasm",
    map: "application/json"
  };
  DevServer = class extends EventEmitter {
    constructor(vfs2, options2) {
      super();
      __publicField(this, "vfs");
      __publicField(this, "port");
      __publicField(this, "root");
      __publicField(this, "running", false);
      this.vfs = vfs2;
      this.port = options2.port;
      this.root = options2.root || "/";
    }
    stop() {
      this.running = false;
      this.emit("close");
    }
    start() {
      this.running = true;
      this.startWatching();
      this.emit("listening", this.port);
    }
    isRunning() {
      return this.running;
    }
    getPort() {
      return this.port;
    }
    serveFile(filePath) {
      try {
        const normalizedPath = this.resolvePath(filePath);
        const content = this.vfs.readFileSync(normalizedPath);
        const buffer2 = typeof content === "string" ? BufferPolyfill.from(content) : BufferPolyfill.from(content);
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": this.getMimeType(filePath),
            "Content-Length": String(buffer2.length),
            "Cache-Control": "no-cache"
          },
          body: buffer2
        };
      } catch (error) {
        if (error.code === "ENOENT") {
          return this.notFound(filePath);
        }
        return this.serverError(error);
      }
    }
    resolvePath(urlPath) {
      let path22 = urlPath.split("?")[0].split("#")[0];
      if (!path22.startsWith("/")) {
        path22 = "/" + path22;
      }
      if (this.root !== "/") {
        path22 = this.root + path22;
      }
      return path22;
    }
    notFound(path22) {
      const body = `Not found: ${path22}`;
      return {
        statusCode: 404,
        statusMessage: "Not Found",
        headers: {
          "Content-Type": "text/plain; charset=utf-8",
          "Content-Length": String(BufferPolyfill.byteLength(body))
        },
        body: BufferPolyfill.from(body)
      };
    }
    serverError(error) {
      const message = error instanceof Error ? error.message : "Internal Server Error";
      const body = `Server Error: ${message}`;
      return {
        statusCode: 500,
        statusMessage: "Internal Server Error",
        headers: {
          "Content-Type": "text/plain; charset=utf-8",
          "Content-Length": String(BufferPolyfill.byteLength(body))
        },
        body: BufferPolyfill.from(body)
      };
    }
    redirect(location2, status = 302) {
      return {
        statusCode: status,
        statusMessage: status === 301 ? "Moved Permanently" : "Found",
        headers: {
          Location: location2,
          "Content-Type": "text/plain; charset=utf-8",
          "Content-Length": "0"
        },
        body: BufferPolyfill.from("")
      };
    }
    getMimeType(path22) {
      var _a22;
      const ext2 = ((_a22 = path22.split(".").pop()) == null ? void 0 : _a22.toLowerCase()) || "";
      return MIME_TYPES[ext2] || "application/octet-stream";
    }
    exists(path22) {
      try {
        this.vfs.statSync(path22);
        return true;
      } catch {
        return false;
      }
    }
    isDirectory(path22) {
      try {
        return this.vfs.statSync(path22).isDirectory();
      } catch {
        return false;
      }
    }
    emitHMRUpdate(update) {
      this.emit("hmr-update", {
        ...update,
        timestamp: update.timestamp || Date.now()
      });
    }
  };
  var astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    7,
    9,
    32,
    4,
    318,
    1,
    80,
    3,
    71,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    3,
    0,
    158,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    68,
    8,
    2,
    0,
    3,
    0,
    2,
    3,
    2,
    4,
    2,
    0,
    15,
    1,
    83,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    7,
    19,
    58,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    343,
    9,
    54,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    10,
    1,
    2,
    0,
    49,
    6,
    4,
    4,
    14,
    10,
    5350,
    0,
    7,
    14,
    11465,
    27,
    2343,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    535,
    9,
    470,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4178,
    9,
    519,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    101,
    0,
    161,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    499,
    13,
    245,
    1,
    2,
    9,
    726,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
  ];
  var astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    4,
    51,
    13,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    39,
    27,
    10,
    22,
    251,
    41,
    7,
    1,
    17,
    2,
    60,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    20,
    1,
    64,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    31,
    9,
    2,
    0,
    3,
    0,
    2,
    37,
    2,
    0,
    26,
    0,
    2,
    0,
    45,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    200,
    32,
    32,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    16,
    0,
    2,
    12,
    2,
    33,
    125,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1071,
    18,
    5,
    26,
    3994,
    6,
    582,
    6842,
    29,
    1763,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    433,
    44,
    212,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    42,
    9,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    16,
    0,
    30,
    2,
    3,
    0,
    15,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    7,
    5,
    262,
    61,
    147,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    485,
    27,
    229,
    29,
    3,
    0,
    496,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4153,
    7,
    221,
    3,
    5761,
    15,
    7472,
    16,
    621,
    2467,
    541,
    1507,
    4938,
    6,
    4191
  ];
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };
  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
  var keywords$1 = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };
  var keywordRelationalOperator = /^in(stanceof)?$/;
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  function isInAstralSet(code2, set) {
    var pos = 65536;
    for (var i22 = 0; i22 < set.length; i22 += 2) {
      pos += set[i22];
      if (pos > code2) {
        return false;
      }
      pos += set[i22 + 1];
      if (pos >= code2) {
        return true;
      }
    }
    return false;
  }
  function isIdentifierStart$1(code2, astral) {
    if (code2 < 65) {
      return code2 === 36;
    }
    if (code2 < 91) {
      return true;
    }
    if (code2 < 97) {
      return code2 === 95;
    }
    if (code2 < 123) {
      return true;
    }
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
    }
    if (astral === false) {
      return false;
    }
    return isInAstralSet(code2, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code2, astral) {
    if (code2 < 48) {
      return code2 === 36;
    }
    if (code2 < 58) {
      return true;
    }
    if (code2 < 65) {
      return false;
    }
    if (code2 < 91) {
      return true;
    }
    if (code2 < 97) {
      return code2 === 95;
    }
    if (code2 < 123) {
      return true;
    }
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
    }
    if (astral === false) {
      return false;
    }
    return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
  }
  var TokenType = function TokenType2(label, conf) {
    if (conf === void 0)
      conf = {};
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };
  function binop(name2, prec) {
    return new TokenType(name2, {
      beforeExpr: true,
      binop: prec
    });
  }
  var beforeExpr = {
    beforeExpr: true
  }, startsExpr = {
    startsExpr: true
  };
  var keywords$2 = {};
  function kw(name2, options2) {
    if (options2 === void 0)
      options2 = {};
    options2.keyword = name2;
    return keywords$2[name2] = new TokenType(name2, options2);
  }
  var types$1 = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    privateId: new TokenType("privateId", startsExpr),
    eof: new TokenType("eof"),
    bracketL: new TokenType("[", {
      beforeExpr: true,
      startsExpr: true
    }),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {
      beforeExpr: true,
      startsExpr: true
    }),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {
      beforeExpr: true,
      startsExpr: true
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {
      beforeExpr: true,
      startsExpr: true
    }),
    eq: new TokenType("=", {
      beforeExpr: true,
      isAssign: true
    }),
    assign: new TokenType("_=", {
      beforeExpr: true,
      isAssign: true
    }),
    incDec: new TokenType("++/--", {
      prefix: true,
      postfix: true,
      startsExpr: true
    }),
    prefix: new TokenType("!/~", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr: true,
      binop: 9,
      prefix: true,
      startsExpr: true
    }),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {
      beforeExpr: true
    }),
    coalesce: binop("??", 1),
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {
      isLoop: true,
      beforeExpr: true
    }),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {
      isLoop: true
    }),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {
      isLoop: true
    }),
    _with: kw("with"),
    _new: kw("new", {
      beforeExpr: true,
      startsExpr: true
    }),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {
      beforeExpr: true,
      binop: 7
    }),
    _instanceof: kw("instanceof", {
      beforeExpr: true,
      binop: 7
    }),
    _typeof: kw("typeof", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    _void: kw("void", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    _delete: kw("delete", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    })
  };
  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code2) {
    return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
  }
  function nextLineBreak(code2, from, end) {
    if (end === void 0)
      end = code2.length;
    for (var i22 = from; i22 < end; i22++) {
      var next2 = code2.charCodeAt(i22);
      if (isNewLine(next2)) {
        return i22 < end - 1 && next2 === 13 && code2.charCodeAt(i22 + 1) === 10 ? i22 + 2 : i22 + 1;
      }
    }
    return -1;
  }
  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  var ref = Object.prototype;
  var hasOwnProperty$4 = ref.hasOwnProperty;
  var toString = ref.toString;
  var hasOwn = Object.hasOwn || function(obj, propName) {
    return hasOwnProperty$4.call(obj, propName);
  };
  var isArray = Array.isArray || function(obj) {
    return toString.call(obj) === "[object Array]";
  };
  var regexpCache = /* @__PURE__ */ Object.create(null);
  function wordsRegexp(words) {
    return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
  }
  function codePointToString(code2) {
    if (code2 <= 65535) {
      return String.fromCharCode(code2);
    }
    code2 -= 65536;
    return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
  }
  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
  var Position = function Position2(line, col) {
    this.line = line;
    this.column = col;
  };
  Position.prototype.offset = function offset(n10) {
    return new Position(this.line, this.column + n10);
  };
  var SourceLocation = function SourceLocation2(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) {
      this.source = p.sourceFile;
    }
  };
  function getLineInfo(input, offset2) {
    for (var line = 1, cur = 0; ; ) {
      var nextBreak = nextLineBreak(input, cur, offset2);
      if (nextBreak < 0) {
        return new Position(line, offset2 - cur);
      }
      ++line;
      cur = nextBreak;
    }
  }
  var defaultOptions = {
    ecmaVersion: null,
    sourceType: "script",
    onInsertedSemicolon: null,
    onTrailingComma: null,
    allowReserved: null,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowAwaitOutsideFunction: null,
    allowSuperOutsideMethod: null,
    allowHashBang: false,
    checkPrivateFields: true,
    locations: false,
    onToken: null,
    onComment: null,
    ranges: false,
    program: null,
    sourceFile: null,
    directSourceFile: null,
    preserveParens: false
  };
  var warnedAboutEcmaVersion = false;
  function getOptions(opts) {
    var options2 = {};
    for (var opt in defaultOptions) {
      options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
    }
    if (options2.ecmaVersion === "latest") {
      options2.ecmaVersion = 1e8;
    } else if (options2.ecmaVersion == null) {
      if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
        warnedAboutEcmaVersion = true;
        console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
      }
      options2.ecmaVersion = 11;
    } else if (options2.ecmaVersion >= 2015) {
      options2.ecmaVersion -= 2009;
    }
    if (options2.allowReserved == null) {
      options2.allowReserved = options2.ecmaVersion < 5;
    }
    if (!opts || opts.allowHashBang == null) {
      options2.allowHashBang = options2.ecmaVersion >= 14;
    }
    if (isArray(options2.onToken)) {
      var tokens = options2.onToken;
      options2.onToken = function(token) {
        return tokens.push(token);
      };
    }
    if (isArray(options2.onComment)) {
      options2.onComment = pushComment(options2, options2.onComment);
    }
    return options2;
  }
  function pushComment(options2, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start,
        end
      };
      if (options2.locations) {
        comment.loc = new SourceLocation(this, startLoc, endLoc);
      }
      if (options2.ranges) {
        comment.range = [
          start,
          end
        ];
      }
      array.push(comment);
    };
  }
  var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
  }
  var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
  var Parser = function Parser2(options2, input, startPos) {
    this.options = options2 = getOptions(options2);
    this.sourceFile = options2.sourceFile;
    this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options2.allowReserved !== true) {
      reserved = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
      if (options2.sourceType === "module") {
        reserved += " await";
      }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);
    this.containsEsc = false;
    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }
    this.type = types$1.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;
    this.context = this.initialContext();
    this.exprAllowed = true;
    this.inModule = options2.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);
    this.potentialArrowAt = -1;
    this.potentialArrowInForAwait = false;
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    this.labels = [];
    this.undefinedExports = /* @__PURE__ */ Object.create(null);
    if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
      this.skipLineComment(2);
    }
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);
    this.regexpState = null;
    this.privateNameStack = [];
  };
  var prototypeAccessors = {
    inFunction: {
      configurable: true
    },
    inGenerator: {
      configurable: true
    },
    inAsync: {
      configurable: true
    },
    canAwait: {
      configurable: true
    },
    allowSuper: {
      configurable: true
    },
    allowDirectSuper: {
      configurable: true
    },
    treatFunctionsAsVar: {
      configurable: true
    },
    allowNewDotTarget: {
      configurable: true
    },
    inClassStaticBlock: {
      configurable: true
    }
  };
  Parser.prototype.parse = function parse2() {
    var node2 = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node2);
  };
  prototypeAccessors.inFunction.get = function() {
    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
  };
  prototypeAccessors.inGenerator.get = function() {
    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
  };
  prototypeAccessors.inAsync.get = function() {
    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
  };
  prototypeAccessors.canAwait.get = function() {
    for (var i22 = this.scopeStack.length - 1; i22 >= 0; i22--) {
      var ref2 = this.scopeStack[i22];
      var flags = ref2.flags;
      if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
        return false;
      }
      if (flags & SCOPE_FUNCTION) {
        return (flags & SCOPE_ASYNC) > 0;
      }
    }
    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
  };
  prototypeAccessors.allowSuper.get = function() {
    var ref2 = this.currentThisScope();
    var flags = ref2.flags;
    return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
  };
  prototypeAccessors.allowDirectSuper.get = function() {
    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
  };
  prototypeAccessors.treatFunctionsAsVar.get = function() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  };
  prototypeAccessors.allowNewDotTarget.get = function() {
    for (var i22 = this.scopeStack.length - 1; i22 >= 0; i22--) {
      var ref2 = this.scopeStack[i22];
      var flags = ref2.flags;
      if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
        return true;
      }
    }
    return false;
  };
  prototypeAccessors.inClassStaticBlock.get = function() {
    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
  };
  Parser.extend = function extend2() {
    var plugins = [], len = arguments.length;
    while (len--)
      plugins[len] = arguments[len];
    var cls = this;
    for (var i22 = 0; i22 < plugins.length; i22++) {
      cls = plugins[i22](cls);
    }
    return cls;
  };
  Parser.parse = function parse2(input, options2) {
    return new this(options2, input).parse();
  };
  Parser.parseExpressionAt = function parseExpressionAt(input, pos, options2) {
    var parser = new this(options2, input, pos);
    parser.nextToken();
    return parser.parseExpression();
  };
  Parser.tokenizer = function tokenizer(input, options2) {
    return new this(options2, input);
  };
  Object.defineProperties(Parser.prototype, prototypeAccessors);
  var pp$9 = Parser.prototype;
  var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
  pp$9.strictDirective = function(start) {
    if (this.options.ecmaVersion < 5) {
      return false;
    }
    for (; ; ) {
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match2 = literal.exec(this.input.slice(start));
      if (!match2) {
        return false;
      }
      if ((match2[1] || match2[2]) === "use strict") {
        skipWhiteSpace.lastIndex = start + match2[0].length;
        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
        var next2 = this.input.charAt(end);
        return next2 === ";" || next2 === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next2) || next2 === "!" && this.input.charAt(end + 1) === "=");
      }
      start += match2[0].length;
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";") {
        start++;
      }
    }
  };
  pp$9.eat = function(type2) {
    if (this.type === type2) {
      this.next();
      return true;
    } else {
      return false;
    }
  };
  pp$9.isContextual = function(name2) {
    return this.type === types$1.name && this.value === name2 && !this.containsEsc;
  };
  pp$9.eatContextual = function(name2) {
    if (!this.isContextual(name2)) {
      return false;
    }
    this.next();
    return true;
  };
  pp$9.expectContextual = function(name2) {
    if (!this.eatContextual(name2)) {
      this.unexpected();
    }
  };
  pp$9.canInsertSemicolon = function() {
    return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  };
  pp$9.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon) {
        this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
      }
      return true;
    }
  };
  pp$9.semicolon = function() {
    if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
      this.unexpected();
    }
  };
  pp$9.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma) {
        this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
      }
      if (!notNext) {
        this.next();
      }
      return true;
    }
  };
  pp$9.expect = function(type2) {
    this.eat(type2) || this.unexpected();
  };
  pp$9.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };
  var DestructuringErrors = function DestructuringErrors2() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  };
  pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) {
      return;
    }
    if (refDestructuringErrors.trailingComma > -1) {
      this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
    }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) {
      this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
    }
  };
  pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) {
      return false;
    }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) {
      return shorthandAssign >= 0 || doubleProto >= 0;
    }
    if (shorthandAssign >= 0) {
      this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
    }
    if (doubleProto >= 0) {
      this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
    }
  };
  pp$9.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
      this.raise(this.yieldPos, "Yield expression cannot be a default value");
    }
    if (this.awaitPos) {
      this.raise(this.awaitPos, "Await expression cannot be a default value");
    }
  };
  pp$9.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression") {
      return this.isSimpleAssignTarget(expr.expression);
    }
    return expr.type === "Identifier" || expr.type === "MemberExpression";
  };
  var pp$8 = Parser.prototype;
  pp$8.parseTopLevel = function(node2) {
    var exports$1 = /* @__PURE__ */ Object.create(null);
    if (!node2.body) {
      node2.body = [];
    }
    while (this.type !== types$1.eof) {
      var stmt = this.parseStatement(null, true, exports$1);
      node2.body.push(stmt);
    }
    if (this.inModule) {
      for (var i22 = 0, list2 = Object.keys(this.undefinedExports); i22 < list2.length; i22 += 1) {
        var name2 = list2[i22];
        this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
      }
    }
    this.adaptDirectivePrologue(node2.body);
    this.next();
    node2.sourceType = this.options.sourceType;
    return this.finishNode(node2, "Program");
  };
  var loopLabel = {
    kind: "loop"
  }, switchLabel = {
    kind: "switch"
  };
  pp$8.isLet = function(context2) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
      return false;
    }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
    if (nextCh === 91 || nextCh === 92) {
      return true;
    }
    if (context2) {
      return false;
    }
    if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    if (isIdentifierStart$1(nextCh, true)) {
      var pos = next2 + 1;
      while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
        ++pos;
      }
      if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
        return true;
      }
      var ident = this.input.slice(next2, pos);
      if (!keywordRelationalOperator.test(ident)) {
        return true;
      }
    }
    return false;
  };
  pp$8.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
      return false;
    }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next2 = this.pos + skip[0].length, after;
    return !lineBreak.test(this.input.slice(this.pos, next2)) && this.input.slice(next2, next2 + 8) === "function" && (next2 + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next2 + 8)) || after > 55295 && after < 56320));
  };
  pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
    if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
      return false;
    }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next2 = this.pos + skip[0].length;
    if (lineBreak.test(this.input.slice(this.pos, next2))) {
      return false;
    }
    if (isAwaitUsing) {
      var awaitEndPos = next2 + 5, after;
      if (this.input.slice(next2, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
        return false;
      }
      skipWhiteSpace.lastIndex = awaitEndPos;
      var skipAfterUsing = skipWhiteSpace.exec(this.input);
      if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
        return false;
      }
    }
    if (isFor) {
      var ofEndPos = next2 + 2, after$1;
      if (this.input.slice(next2, ofEndPos) === "of") {
        if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
          return false;
        }
      }
    }
    var ch2 = this.input.charCodeAt(next2);
    return isIdentifierStart$1(ch2, true) || ch2 === 92;
  };
  pp$8.isAwaitUsing = function(isFor) {
    return this.isUsingKeyword(true, isFor);
  };
  pp$8.isUsing = function(isFor) {
    return this.isUsingKeyword(false, isFor);
  };
  pp$8.parseStatement = function(context2, topLevel, exports$1) {
    var starttype = this.type, node2 = this.startNode(), kind;
    if (this.isLet(context2)) {
      starttype = types$1._var;
      kind = "let";
    }
    switch (starttype) {
      case types$1._break:
      case types$1._continue:
        return this.parseBreakContinueStatement(node2, starttype.keyword);
      case types$1._debugger:
        return this.parseDebuggerStatement(node2);
      case types$1._do:
        return this.parseDoStatement(node2);
      case types$1._for:
        return this.parseForStatement(node2);
      case types$1._function:
        if (context2 && (this.strict || context2 !== "if" && context2 !== "label") && this.options.ecmaVersion >= 6) {
          this.unexpected();
        }
        return this.parseFunctionStatement(node2, false, !context2);
      case types$1._class:
        if (context2) {
          this.unexpected();
        }
        return this.parseClass(node2, true);
      case types$1._if:
        return this.parseIfStatement(node2);
      case types$1._return:
        return this.parseReturnStatement(node2);
      case types$1._switch:
        return this.parseSwitchStatement(node2);
      case types$1._throw:
        return this.parseThrowStatement(node2);
      case types$1._try:
        return this.parseTryStatement(node2);
      case types$1._const:
      case types$1._var:
        kind = kind || this.value;
        if (context2 && kind !== "var") {
          this.unexpected();
        }
        return this.parseVarStatement(node2, kind);
      case types$1._while:
        return this.parseWhileStatement(node2);
      case types$1._with:
        return this.parseWithStatement(node2);
      case types$1.braceL:
        return this.parseBlock(true, node2);
      case types$1.semi:
        return this.parseEmptyStatement(node2);
      case types$1._export:
      case types$1._import:
        if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
          if (nextCh === 40 || nextCh === 46) {
            return this.parseExpressionStatement(node2, this.parseExpression());
          }
        }
        if (!this.options.allowImportExportEverywhere) {
          if (!topLevel) {
            this.raise(this.start, "'import' and 'export' may only appear at the top level");
          }
          if (!this.inModule) {
            this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
          }
        }
        return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports$1);
      default:
        if (this.isAsyncFunction()) {
          if (context2) {
            this.unexpected();
          }
          this.next();
          return this.parseFunctionStatement(node2, true, !context2);
        }
        var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
        if (usingKind) {
          if (topLevel && this.options.sourceType === "script") {
            this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
          }
          if (usingKind === "await using") {
            if (!this.canAwait) {
              this.raise(this.start, "Await using cannot appear outside of async function");
            }
            this.next();
          }
          this.next();
          this.parseVar(node2, false, usingKind);
          this.semicolon();
          return this.finishNode(node2, "VariableDeclaration");
        }
        var maybeName = this.value, expr = this.parseExpression();
        if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
          return this.parseLabeledStatement(node2, maybeName, expr, context2);
        } else {
          return this.parseExpressionStatement(node2, expr);
        }
    }
  };
  pp$8.parseBreakContinueStatement = function(node2, keyword2) {
    var isBreak = keyword2 === "break";
    this.next();
    if (this.eat(types$1.semi) || this.insertSemicolon()) {
      node2.label = null;
    } else if (this.type !== types$1.name) {
      this.unexpected();
    } else {
      node2.label = this.parseIdent();
      this.semicolon();
    }
    var i22 = 0;
    for (; i22 < this.labels.length; ++i22) {
      var lab = this.labels[i22];
      if (node2.label == null || lab.name === node2.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) {
          break;
        }
        if (node2.label && isBreak) {
          break;
        }
      }
    }
    if (i22 === this.labels.length) {
      this.raise(node2.start, "Unsyntactic " + keyword2);
    }
    return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
  };
  pp$8.parseDebuggerStatement = function(node2) {
    this.next();
    this.semicolon();
    return this.finishNode(node2, "DebuggerStatement");
  };
  pp$8.parseDoStatement = function(node2) {
    this.next();
    this.labels.push(loopLabel);
    node2.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types$1._while);
    node2.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6) {
      this.eat(types$1.semi);
    } else {
      this.semicolon();
    }
    return this.finishNode(node2, "DoWhileStatement");
  };
  pp$8.parseForStatement = function(node2) {
    this.next();
    var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types$1.parenL);
    if (this.type === types$1.semi) {
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node2, null);
    }
    var isLet = this.isLet();
    if (this.type === types$1._var || this.type === types$1._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      return this.parseForAfterInit(node2, init$1, awaitAt);
    }
    var startsWithLet = this.isContextual("let"), isForOf = false;
    var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
    if (usingKind) {
      var init$2 = this.startNode();
      this.next();
      if (usingKind === "await using") {
        this.next();
      }
      this.parseVar(init$2, true, usingKind);
      this.finishNode(init$2, "VariableDeclaration");
      return this.parseForAfterInit(node2, init$2, awaitAt);
    }
    var containsEsc = this.containsEsc;
    var refDestructuringErrors = new DestructuringErrors();
    var initPos = this.start;
    var init22 = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (awaitAt > -1) {
        if (this.type === types$1._in) {
          this.unexpected(awaitAt);
        }
        node2.await = true;
      } else if (isForOf && this.options.ecmaVersion >= 8) {
        if (init22.start === initPos && !containsEsc && init22.type === "Identifier" && init22.name === "async") {
          this.unexpected();
        } else if (this.options.ecmaVersion >= 9) {
          node2.await = false;
        }
      }
      if (startsWithLet && isForOf) {
        this.raise(init22.start, "The left-hand side of a for-of loop may not start with 'let'.");
      }
      this.toAssignable(init22, false, refDestructuringErrors);
      this.checkLValPattern(init22);
      return this.parseForIn(node2, init22);
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, init22);
  };
  pp$8.parseForAfterInit = function(node2, init22, awaitAt) {
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init22.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node2.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node2, init22);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, init22);
  };
  pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
  };
  pp$8.parseIfStatement = function(node2) {
    this.next();
    node2.test = this.parseParenExpression();
    node2.consequent = this.parseStatement("if");
    node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
    return this.finishNode(node2, "IfStatement");
  };
  pp$8.parseReturnStatement = function(node2) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
      this.raise(this.start, "'return' outside of function");
    }
    this.next();
    if (this.eat(types$1.semi) || this.insertSemicolon()) {
      node2.argument = null;
    } else {
      node2.argument = this.parseExpression();
      this.semicolon();
    }
    return this.finishNode(node2, "ReturnStatement");
  };
  pp$8.parseSwitchStatement = function(node2) {
    this.next();
    node2.discriminant = this.parseParenExpression();
    node2.cases = [];
    this.expect(types$1.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);
    var cur;
    for (var sawDefault = false; this.type !== types$1.braceR; ) {
      if (this.type === types$1._case || this.type === types$1._default) {
        var isCase = this.type === types$1._case;
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        node2.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) {
            this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
          }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types$1.colon);
      } else {
        if (!cur) {
          this.unexpected();
        }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) {
      this.finishNode(cur, "SwitchCase");
    }
    this.next();
    this.labels.pop();
    return this.finishNode(node2, "SwitchStatement");
  };
  pp$8.parseThrowStatement = function(node2) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
      this.raise(this.lastTokEnd, "Illegal newline after throw");
    }
    node2.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node2, "ThrowStatement");
  };
  var empty$1 = [];
  pp$8.parseCatchClauseParam = function() {
    var param = this.parseBindingAtom();
    var simple = param.type === "Identifier";
    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
    this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
    this.expect(types$1.parenR);
    return param;
  };
  pp$8.parseTryStatement = function(node2) {
    this.next();
    node2.block = this.parseBlock();
    node2.handler = null;
    if (this.type === types$1._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types$1.parenL)) {
        clause.param = this.parseCatchClauseParam();
      } else {
        if (this.options.ecmaVersion < 10) {
          this.unexpected();
        }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node2.handler = this.finishNode(clause, "CatchClause");
    }
    node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
    if (!node2.handler && !node2.finalizer) {
      this.raise(node2.start, "Missing catch or finally clause");
    }
    return this.finishNode(node2, "TryStatement");
  };
  pp$8.parseVarStatement = function(node2, kind, allowMissingInitializer) {
    this.next();
    this.parseVar(node2, false, kind, allowMissingInitializer);
    this.semicolon();
    return this.finishNode(node2, "VariableDeclaration");
  };
  pp$8.parseWhileStatement = function(node2) {
    this.next();
    node2.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node2.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node2, "WhileStatement");
  };
  pp$8.parseWithStatement = function(node2) {
    if (this.strict) {
      this.raise(this.start, "'with' in strict mode");
    }
    this.next();
    node2.object = this.parseParenExpression();
    node2.body = this.parseStatement("with");
    return this.finishNode(node2, "WithStatement");
  };
  pp$8.parseEmptyStatement = function(node2) {
    this.next();
    return this.finishNode(node2, "EmptyStatement");
  };
  pp$8.parseLabeledStatement = function(node2, maybeName, expr, context2) {
    for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
      var label = list2[i$1];
      if (label.name === maybeName) {
        this.raise(expr.start, "Label '" + maybeName + "' is already declared");
      }
    }
    var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
    for (var i22 = this.labels.length - 1; i22 >= 0; i22--) {
      var label$1 = this.labels[i22];
      if (label$1.statementStart === node2.start) {
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else {
        break;
      }
    }
    this.labels.push({
      name: maybeName,
      kind,
      statementStart: this.start
    });
    node2.body = this.parseStatement(context2 ? context2.indexOf("label") === -1 ? context2 + "label" : context2 : "label");
    this.labels.pop();
    node2.label = expr;
    return this.finishNode(node2, "LabeledStatement");
  };
  pp$8.parseExpressionStatement = function(node2, expr) {
    node2.expression = expr;
    this.semicolon();
    return this.finishNode(node2, "ExpressionStatement");
  };
  pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
    if (createNewLexicalScope === void 0)
      createNewLexicalScope = true;
    if (node2 === void 0)
      node2 = this.startNode();
    node2.body = [];
    this.expect(types$1.braceL);
    if (createNewLexicalScope) {
      this.enterScope(0);
    }
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node2.body.push(stmt);
    }
    if (exitStrict) {
      this.strict = false;
    }
    this.next();
    if (createNewLexicalScope) {
      this.exitScope();
    }
    return this.finishNode(node2, "BlockStatement");
  };
  pp$8.parseFor = function(node2, init22) {
    node2.init = init22;
    this.expect(types$1.semi);
    node2.test = this.type === types$1.semi ? null : this.parseExpression();
    this.expect(types$1.semi);
    node2.update = this.type === types$1.parenR ? null : this.parseExpression();
    this.expect(types$1.parenR);
    node2.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node2, "ForStatement");
  };
  pp$8.parseForIn = function(node2, init22) {
    var isForIn = this.type === types$1._in;
    this.next();
    if (init22.type === "VariableDeclaration" && init22.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init22.kind !== "var" || init22.declarations[0].id.type !== "Identifier")) {
      this.raise(init22.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
    }
    node2.left = init22;
    node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types$1.parenR);
    node2.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
  };
  pp$8.parseVar = function(node2, isFor, kind, allowMissingInitializer) {
    node2.declarations = [];
    node2.kind = kind;
    for (; ; ) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types$1.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        this.unexpected();
      } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
        this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
      } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types$1.comma)) {
        break;
      }
    }
    return node2;
  };
  pp$8.parseVarId = function(decl, kind) {
    decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
    this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };
  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
  pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
    this.initFunction(node2);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
        this.unexpected();
      }
      node2.generator = this.eat(types$1.star);
    }
    if (this.options.ecmaVersion >= 8) {
      node2.async = !!isAsync;
    }
    if (statement & FUNC_STATEMENT) {
      node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
      if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
        this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
      }
    }
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node2.async, node2.generator));
    if (!(statement & FUNC_STATEMENT)) {
      node2.id = this.type === types$1.name ? this.parseIdent() : null;
    }
    this.parseFunctionParams(node2);
    this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
  };
  pp$8.parseFunctionParams = function(node2) {
    this.expect(types$1.parenL);
    node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };
  pp$8.parseClass = function(node2, isStatement) {
    this.next();
    var oldStrict = this.strict;
    this.strict = true;
    this.parseClassId(node2, isStatement);
    this.parseClassSuper(node2);
    var privateNameMap = this.enterClassBody();
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types$1.braceL);
    while (this.type !== types$1.braceR) {
      var element = this.parseClassElement(node2.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) {
            this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
          }
          hadConstructor = true;
        } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
          this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
        }
      }
    }
    this.strict = oldStrict;
    this.next();
    node2.body = this.finishNode(classBody, "ClassBody");
    this.exitClassBody();
    return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
  };
  pp$8.parseClassElement = function(constructorAllowsSuper) {
    if (this.eat(types$1.semi)) {
      return null;
    }
    var ecmaVersion2 = this.options.ecmaVersion;
    var node2 = this.startNode();
    var keyName = "";
    var isGenerator = false;
    var isAsync = false;
    var kind = "method";
    var isStatic = false;
    if (this.eatContextual("static")) {
      if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
        this.parseClassStaticBlock(node2);
        return node2;
      }
      if (this.isClassElementNameStart() || this.type === types$1.star) {
        isStatic = true;
      } else {
        keyName = "static";
      }
    }
    node2.static = isStatic;
    if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
      if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
        isAsync = true;
      } else {
        keyName = "async";
      }
    }
    if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
      isGenerator = true;
    }
    if (!keyName && !isAsync && !isGenerator) {
      var lastValue = this.value;
      if (this.eatContextual("get") || this.eatContextual("set")) {
        if (this.isClassElementNameStart()) {
          kind = lastValue;
        } else {
          keyName = lastValue;
        }
      }
    }
    if (keyName) {
      node2.computed = false;
      node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
      node2.key.name = keyName;
      this.finishNode(node2.key, "Identifier");
    } else {
      this.parseClassElementName(node2);
    }
    if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
      var isConstructor = !node2.static && checkKeyName(node2, "constructor");
      var allowsDirectSuper = isConstructor && constructorAllowsSuper;
      if (isConstructor && kind !== "method") {
        this.raise(node2.key.start, "Constructor can't have get/set modifier");
      }
      node2.kind = isConstructor ? "constructor" : kind;
      this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
    } else {
      this.parseClassField(node2);
    }
    return node2;
  };
  pp$8.isClassElementNameStart = function() {
    return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
  };
  pp$8.parseClassElementName = function(element) {
    if (this.type === types$1.privateId) {
      if (this.value === "constructor") {
        this.raise(this.start, "Classes can't have an element named '#constructor'");
      }
      element.computed = false;
      element.key = this.parsePrivateIdent();
    } else {
      this.parsePropertyName(element);
    }
  };
  pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    var key = method.key;
    if (method.kind === "constructor") {
      if (isGenerator) {
        this.raise(key.start, "Constructor can't be a generator");
      }
      if (isAsync) {
        this.raise(key.start, "Constructor can't be an async method");
      }
    } else if (method.static && checkKeyName(method, "prototype")) {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && value2.params.length !== 0) {
      this.raiseRecoverable(value2.start, "getter should have no params");
    }
    if (method.kind === "set" && value2.params.length !== 1) {
      this.raiseRecoverable(value2.start, "setter should have exactly one param");
    }
    if (method.kind === "set" && value2.params[0].type === "RestElement") {
      this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
    }
    return this.finishNode(method, "MethodDefinition");
  };
  pp$8.parseClassField = function(field) {
    if (checkKeyName(field, "constructor")) {
      this.raise(field.key.start, "Classes can't have a field named 'constructor'");
    } else if (field.static && checkKeyName(field, "prototype")) {
      this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
    }
    if (this.eat(types$1.eq)) {
      this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
      field.value = this.parseMaybeAssign();
      this.exitScope();
    } else {
      field.value = null;
    }
    this.semicolon();
    return this.finishNode(field, "PropertyDefinition");
  };
  pp$8.parseClassStaticBlock = function(node2) {
    node2.body = [];
    var oldLabels = this.labels;
    this.labels = [];
    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node2.body.push(stmt);
    }
    this.next();
    this.exitScope();
    this.labels = oldLabels;
    return this.finishNode(node2, "StaticBlock");
  };
  pp$8.parseClassId = function(node2, isStatement) {
    if (this.type === types$1.name) {
      node2.id = this.parseIdent();
      if (isStatement) {
        this.checkLValSimple(node2.id, BIND_LEXICAL, false);
      }
    } else {
      if (isStatement === true) {
        this.unexpected();
      }
      node2.id = null;
    }
  };
  pp$8.parseClassSuper = function(node2) {
    node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
  };
  pp$8.enterClassBody = function() {
    var element = {
      declared: /* @__PURE__ */ Object.create(null),
      used: []
    };
    this.privateNameStack.push(element);
    return element.declared;
  };
  pp$8.exitClassBody = function() {
    var ref2 = this.privateNameStack.pop();
    var declared = ref2.declared;
    var used = ref2.used;
    if (!this.options.checkPrivateFields) {
      return;
    }
    var len = this.privateNameStack.length;
    var parent = len === 0 ? null : this.privateNameStack[len - 1];
    for (var i22 = 0; i22 < used.length; ++i22) {
      var id2 = used[i22];
      if (!hasOwn(declared, id2.name)) {
        if (parent) {
          parent.used.push(id2);
        } else {
          this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
        }
      }
    }
  };
  function isPrivateNameConflicted(privateNameMap, element) {
    var name2 = element.key.name;
    var curr = privateNameMap[name2];
    var next2 = "true";
    if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
      next2 = (element.static ? "s" : "i") + element.kind;
    }
    if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
      privateNameMap[name2] = "true";
      return false;
    } else if (!curr) {
      privateNameMap[name2] = next2;
      return false;
    } else {
      return true;
    }
  }
  function checkKeyName(node2, name2) {
    var computed = node2.computed;
    var key = node2.key;
    return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
  }
  pp$8.parseExportAllDeclaration = function(node2, exports$1) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node2.exported = this.parseModuleExportName();
        this.checkExport(exports$1, node2.exported, this.lastTokStart);
      } else {
        node2.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node2.source = this.parseExprAtom();
    if (this.options.ecmaVersion >= 16) {
      node2.attributes = this.parseWithClause();
    }
    this.semicolon();
    return this.finishNode(node2, "ExportAllDeclaration");
  };
  pp$8.parseExport = function(node2, exports$1) {
    this.next();
    if (this.eat(types$1.star)) {
      return this.parseExportAllDeclaration(node2, exports$1);
    }
    if (this.eat(types$1._default)) {
      this.checkExport(exports$1, "default", this.lastTokStart);
      node2.declaration = this.parseExportDefaultDeclaration();
      return this.finishNode(node2, "ExportDefaultDeclaration");
    }
    if (this.shouldParseExportStatement()) {
      node2.declaration = this.parseExportDeclaration(node2);
      if (node2.declaration.type === "VariableDeclaration") {
        this.checkVariableExport(exports$1, node2.declaration.declarations);
      } else {
        this.checkExport(exports$1, node2.declaration.id, node2.declaration.id.start);
      }
      node2.specifiers = [];
      node2.source = null;
      if (this.options.ecmaVersion >= 16) {
        node2.attributes = [];
      }
    } else {
      node2.declaration = null;
      node2.specifiers = this.parseExportSpecifiers(exports$1);
      if (this.eatContextual("from")) {
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node2.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16) {
          node2.attributes = this.parseWithClause();
        }
      } else {
        for (var i22 = 0, list2 = node2.specifiers; i22 < list2.length; i22 += 1) {
          var spec2 = list2[i22];
          this.checkUnreserved(spec2.local);
          this.checkLocalExport(spec2.local);
          if (spec2.local.type === "Literal") {
            this.raise(spec2.local.start, "A string literal cannot be used as an exported binding without `from`.");
          }
        }
        node2.source = null;
        if (this.options.ecmaVersion >= 16) {
          node2.attributes = [];
        }
      }
      this.semicolon();
    }
    return this.finishNode(node2, "ExportNamedDeclaration");
  };
  pp$8.parseExportDeclaration = function(node2) {
    return this.parseStatement(null);
  };
  pp$8.parseExportDefaultDeclaration = function() {
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) {
        this.next();
      }
      return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      return this.parseClass(cNode, "nullableID");
    } else {
      var declaration = this.parseMaybeAssign();
      this.semicolon();
      return declaration;
    }
  };
  pp$8.checkExport = function(exports$1, name2, pos) {
    if (!exports$1) {
      return;
    }
    if (typeof name2 !== "string") {
      name2 = name2.type === "Identifier" ? name2.name : name2.value;
    }
    if (hasOwn(exports$1, name2)) {
      this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
    }
    exports$1[name2] = true;
  };
  pp$8.checkPatternExport = function(exports$1, pat) {
    var type2 = pat.type;
    if (type2 === "Identifier") {
      this.checkExport(exports$1, pat, pat.start);
    } else if (type2 === "ObjectPattern") {
      for (var i22 = 0, list2 = pat.properties; i22 < list2.length; i22 += 1) {
        var prop = list2[i22];
        this.checkPatternExport(exports$1, prop);
      }
    } else if (type2 === "ArrayPattern") {
      for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];
        if (elt) {
          this.checkPatternExport(exports$1, elt);
        }
      }
    } else if (type2 === "Property") {
      this.checkPatternExport(exports$1, pat.value);
    } else if (type2 === "AssignmentPattern") {
      this.checkPatternExport(exports$1, pat.left);
    } else if (type2 === "RestElement") {
      this.checkPatternExport(exports$1, pat.argument);
    }
  };
  pp$8.checkVariableExport = function(exports$1, decls) {
    if (!exports$1) {
      return;
    }
    for (var i22 = 0, list2 = decls; i22 < list2.length; i22 += 1) {
      var decl = list2[i22];
      this.checkPatternExport(exports$1, decl.id);
    }
  };
  pp$8.shouldParseExportStatement = function() {
    return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
  };
  pp$8.parseExportSpecifier = function(exports$1) {
    var node2 = this.startNode();
    node2.local = this.parseModuleExportName();
    node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
    this.checkExport(exports$1, node2.exported, node2.exported.start);
    return this.finishNode(node2, "ExportSpecifier");
  };
  pp$8.parseExportSpecifiers = function(exports$1) {
    var nodes = [], first = true;
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      nodes.push(this.parseExportSpecifier(exports$1));
    }
    return nodes;
  };
  pp$8.parseImport = function(node2) {
    this.next();
    if (this.type === types$1.string) {
      node2.specifiers = empty$1;
      node2.source = this.parseExprAtom();
    } else {
      node2.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
    }
    if (this.options.ecmaVersion >= 16) {
      node2.attributes = this.parseWithClause();
    }
    this.semicolon();
    return this.finishNode(node2, "ImportDeclaration");
  };
  pp$8.parseImportSpecifier = function() {
    var node2 = this.startNode();
    node2.imported = this.parseModuleExportName();
    if (this.eatContextual("as")) {
      node2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node2.imported);
      node2.local = node2.imported;
    }
    this.checkLValSimple(node2.local, BIND_LEXICAL);
    return this.finishNode(node2, "ImportSpecifier");
  };
  pp$8.parseImportDefaultSpecifier = function() {
    var node2 = this.startNode();
    node2.local = this.parseIdent();
    this.checkLValSimple(node2.local, BIND_LEXICAL);
    return this.finishNode(node2, "ImportDefaultSpecifier");
  };
  pp$8.parseImportNamespaceSpecifier = function() {
    var node2 = this.startNode();
    this.next();
    this.expectContextual("as");
    node2.local = this.parseIdent();
    this.checkLValSimple(node2.local, BIND_LEXICAL);
    return this.finishNode(node2, "ImportNamespaceSpecifier");
  };
  pp$8.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types$1.name) {
      nodes.push(this.parseImportDefaultSpecifier());
      if (!this.eat(types$1.comma)) {
        return nodes;
      }
    }
    if (this.type === types$1.star) {
      nodes.push(this.parseImportNamespaceSpecifier());
      return nodes;
    }
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      nodes.push(this.parseImportSpecifier());
    }
    return nodes;
  };
  pp$8.parseWithClause = function() {
    var nodes = [];
    if (!this.eat(types$1._with)) {
      return nodes;
    }
    this.expect(types$1.braceL);
    var attributeKeys = {};
    var first = true;
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      var attr = this.parseImportAttribute();
      var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
      if (hasOwn(attributeKeys, keyName)) {
        this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
      }
      attributeKeys[keyName] = true;
      nodes.push(attr);
    }
    return nodes;
  };
  pp$8.parseImportAttribute = function() {
    var node2 = this.startNode();
    node2.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    this.expect(types$1.colon);
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node2.value = this.parseExprAtom();
    return this.finishNode(node2, "ImportAttribute");
  };
  pp$8.parseModuleExportName = function() {
    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
      var stringLiteral = this.parseLiteral(this.value);
      if (loneSurrogate.test(stringLiteral.value)) {
        this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
      }
      return stringLiteral;
    }
    return this.parseIdent(true);
  };
  pp$8.adaptDirectivePrologue = function(statements) {
    for (var i22 = 0; i22 < statements.length && this.isDirectiveCandidate(statements[i22]); ++i22) {
      statements[i22].directive = statements[i22].expression.raw.slice(1, -1);
    }
  };
  pp$8.isDirectiveCandidate = function(statement) {
    return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
  };
  var pp$7 = Parser.prototype;
  pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node2) {
      switch (node2.type) {
        case "Identifier":
          if (this.inAsync && node2.name === "await") {
            this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
          }
          break;
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          node2.type = "ObjectPattern";
          if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
          }
          for (var i22 = 0, list2 = node2.properties; i22 < list2.length; i22 += 1) {
            var prop = list2[i22];
            this.toAssignable(prop, isBinding);
            if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
              this.raise(prop.argument.start, "Unexpected token");
            }
          }
          break;
        case "Property":
          if (node2.kind !== "init") {
            this.raise(node2.key.start, "Object pattern can't contain getter or setter");
          }
          this.toAssignable(node2.value, isBinding);
          break;
        case "ArrayExpression":
          node2.type = "ArrayPattern";
          if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
          }
          this.toAssignableList(node2.elements, isBinding);
          break;
        case "SpreadElement":
          node2.type = "RestElement";
          this.toAssignable(node2.argument, isBinding);
          if (node2.argument.type === "AssignmentPattern") {
            this.raise(node2.argument.start, "Rest elements cannot have a default value");
          }
          break;
        case "AssignmentExpression":
          if (node2.operator !== "=") {
            this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
          }
          node2.type = "AssignmentPattern";
          delete node2.operator;
          this.toAssignable(node2.left, isBinding);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
          break;
        case "ChainExpression":
          this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (!isBinding) {
            break;
          }
        default:
          this.raise(node2.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) {
      this.checkPatternErrors(refDestructuringErrors, true);
    }
    return node2;
  };
  pp$7.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i22 = 0; i22 < end; i22++) {
      var elt = exprList[i22];
      if (elt) {
        this.toAssignable(elt, isBinding);
      }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
        this.unexpected(last.argument.start);
      }
    }
    return exprList;
  };
  pp$7.parseSpread = function(refDestructuringErrors) {
    var node2 = this.startNode();
    this.next();
    node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node2, "SpreadElement");
  };
  pp$7.parseRestBinding = function() {
    var node2 = this.startNode();
    this.next();
    if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
      this.unexpected();
    }
    node2.argument = this.parseBindingAtom();
    return this.finishNode(node2, "RestElement");
  };
  pp$7.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
        case types$1.bracketL:
          var node2 = this.startNode();
          this.next();
          node2.elements = this.parseBindingList(types$1.bracketR, true, true);
          return this.finishNode(node2, "ArrayPattern");
        case types$1.braceL:
          return this.parseObj(true);
      }
    }
    return this.parseIdent();
  };
  pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
    var elts = [], first = true;
    while (!this.eat(close2)) {
      if (first) {
        first = false;
      } else {
        this.expect(types$1.comma);
      }
      if (allowEmpty && this.type === types$1.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      } else if (this.type === types$1.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types$1.comma) {
          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        }
        this.expect(close2);
        break;
      } else {
        elts.push(this.parseAssignableListItem(allowModifiers));
      }
    }
    return elts;
  };
  pp$7.parseAssignableListItem = function(allowModifiers) {
    var elem = this.parseMaybeDefault(this.start, this.startLoc);
    this.parseBindingListItem(elem);
    return elem;
  };
  pp$7.parseBindingListItem = function(param) {
    return param;
  };
  pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
      return left;
    }
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.left = left;
    node2.right = this.parseMaybeAssign();
    return this.finishNode(node2, "AssignmentPattern");
  };
  pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0)
      bindingType = BIND_NONE;
    var isBind = bindingType !== BIND_NONE;
    switch (expr.type) {
      case "Identifier":
        if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
          this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
        }
        if (isBind) {
          if (bindingType === BIND_LEXICAL && expr.name === "let") {
            this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
          }
          if (checkClashes) {
            if (hasOwn(checkClashes, expr.name)) {
              this.raiseRecoverable(expr.start, "Argument name clash");
            }
            checkClashes[expr.name] = true;
          }
          if (bindingType !== BIND_OUTSIDE) {
            this.declareName(expr.name, bindingType, expr.start);
          }
        }
        break;
      case "ChainExpression":
        this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (isBind) {
          this.raiseRecoverable(expr.start, "Binding member expression");
        }
        break;
      case "ParenthesizedExpression":
        if (isBind) {
          this.raiseRecoverable(expr.start, "Binding parenthesized expression");
        }
        return this.checkLValSimple(expr.expression, bindingType, checkClashes);
      default:
        this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
    }
  };
  pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0)
      bindingType = BIND_NONE;
    switch (expr.type) {
      case "ObjectPattern":
        for (var i22 = 0, list2 = expr.properties; i22 < list2.length; i22 += 1) {
          var prop = list2[i22];
          this.checkLValInnerPattern(prop, bindingType, checkClashes);
        }
        break;
      case "ArrayPattern":
        for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
          var elem = list$1[i$1];
          if (elem) {
            this.checkLValInnerPattern(elem, bindingType, checkClashes);
          }
        }
        break;
      default:
        this.checkLValSimple(expr, bindingType, checkClashes);
    }
  };
  pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0)
      bindingType = BIND_NONE;
    switch (expr.type) {
      case "Property":
        this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
        break;
      case "AssignmentPattern":
        this.checkLValPattern(expr.left, bindingType, checkClashes);
        break;
      case "RestElement":
        this.checkLValPattern(expr.argument, bindingType, checkClashes);
        break;
      default:
        this.checkLValPattern(expr, bindingType, checkClashes);
    }
  };
  var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };
  var types = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function(p) {
      return p.tryReadTemplateToken();
    }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };
  var pp$6 = Parser.prototype;
  pp$6.initialContext = function() {
    return [
      types.b_stat
    ];
  };
  pp$6.curContext = function() {
    return this.context[this.context.length - 1];
  };
  pp$6.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types.f_expr || parent === types.f_stat) {
      return true;
    }
    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
      return !parent.isExpr;
    }
    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
      return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    }
    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
      return true;
    }
    if (prevType === types$1.braceL) {
      return parent === types.b_stat;
    }
    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
      return false;
    }
    return !this.exprAllowed;
  };
  pp$6.inGeneratorContext = function() {
    for (var i22 = this.context.length - 1; i22 >= 1; i22--) {
      var context2 = this.context[i22];
      if (context2.token === "function") {
        return context2.generator;
      }
    }
    return false;
  };
  pp$6.updateContext = function(prevType) {
    var update, type2 = this.type;
    if (type2.keyword && prevType === types$1.dot) {
      this.exprAllowed = false;
    } else if (update = type2.updateContext) {
      update.call(this, prevType);
    } else {
      this.exprAllowed = type2.beforeExpr;
    }
  };
  pp$6.overrideContext = function(tokenCtx) {
    if (this.curContext() !== tokenCtx) {
      this.context[this.context.length - 1] = tokenCtx;
    }
  };
  types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return;
    }
    var out = this.context.pop();
    if (out === types.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };
  types$1.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
    this.exprAllowed = true;
  };
  types$1.dollarBraceL.updateContext = function() {
    this.context.push(types.b_tmpl);
    this.exprAllowed = true;
  };
  types$1.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
    this.context.push(statementParens ? types.p_stat : types.p_expr);
    this.exprAllowed = true;
  };
  types$1.incDec.updateContext = function() {
  };
  types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
      this.context.push(types.f_expr);
    } else {
      this.context.push(types.f_stat);
    }
    this.exprAllowed = false;
  };
  types$1.colon.updateContext = function() {
    if (this.curContext().token === "function") {
      this.context.pop();
    }
    this.exprAllowed = true;
  };
  types$1.backQuote.updateContext = function() {
    if (this.curContext() === types.q_tmpl) {
      this.context.pop();
    } else {
      this.context.push(types.q_tmpl);
    }
    this.exprAllowed = false;
  };
  types$1.star.updateContext = function(prevType) {
    if (prevType === types$1._function) {
      var index2 = this.context.length - 1;
      if (this.context[index2] === types.f_expr) {
        this.context[index2] = types.f_expr_gen;
      } else {
        this.context[index2] = types.f_gen;
      }
    }
    this.exprAllowed = true;
  };
  types$1.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
      if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
        allowed = true;
      }
    }
    this.exprAllowed = allowed;
  };
  var pp$5 = Parser.prototype;
  pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
      return;
    }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
      return;
    }
    var key = prop.key;
    var name2;
    switch (key.type) {
      case "Identifier":
        name2 = key.name;
        break;
      case "Literal":
        name2 = String(key.value);
        break;
      default:
        return;
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name2 === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0) {
              refDestructuringErrors.doubleProto = key.start;
            }
          } else {
            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
          }
        }
        propHash.proto = true;
      }
      return;
    }
    name2 = "$" + name2;
    var other = propHash[name2];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition) {
        this.raiseRecoverable(key.start, "Redefinition of property");
      }
    } else {
      other = propHash[name2] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };
  pp$5.parseExpression = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
    if (this.type === types$1.comma) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.expressions = [
        expr
      ];
      while (this.eat(types$1.comma)) {
        node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
      }
      return this.finishNode(node2, "SequenceExpression");
    }
    return expr;
  };
  pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) {
        return this.parseYield(forInit);
      } else {
        this.exprAllowed = false;
      }
    }
    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      oldDoubleProto = refDestructuringErrors.doubleProto;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors();
      ownDestructuringErrors = true;
    }
    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types$1.parenL || this.type === types$1.name) {
      this.potentialArrowAt = this.start;
      this.potentialArrowInForAwait = forInit === "await";
    }
    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
    if (afterLeftParse) {
      left = afterLeftParse.call(this, left, startPos, startLoc);
    }
    if (this.type.isAssign) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.operator = this.value;
      if (this.type === types$1.eq) {
        left = this.toAssignable(left, false, refDestructuringErrors);
      }
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= left.start) {
        refDestructuringErrors.shorthandAssign = -1;
      }
      if (this.type === types$1.eq) {
        this.checkLValPattern(left);
      } else {
        this.checkLValSimple(left);
      }
      node2.left = left;
      this.next();
      node2.right = this.parseMaybeAssign(forInit);
      if (oldDoubleProto > -1) {
        refDestructuringErrors.doubleProto = oldDoubleProto;
      }
      return this.finishNode(node2, "AssignmentExpression");
    } else {
      if (ownDestructuringErrors) {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
    }
    if (oldParenAssign > -1) {
      refDestructuringErrors.parenthesizedAssign = oldParenAssign;
    }
    if (oldTrailingComma > -1) {
      refDestructuringErrors.trailingComma = oldTrailingComma;
    }
    return left;
  };
  pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(forInit, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    if (this.eat(types$1.question)) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.test = expr;
      node2.consequent = this.parseMaybeAssign();
      this.expect(types$1.colon);
      node2.alternate = this.parseMaybeAssign(forInit);
      return this.finishNode(node2, "ConditionalExpression");
    }
    return expr;
  };
  pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
  };
  pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
    var prec = this.type.binop;
    if (prec != null && (!forInit || this.type !== types$1._in)) {
      if (prec > minPrec) {
        var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
        var coalesce = this.type === types$1.coalesce;
        if (coalesce) {
          prec = types$1.logicalAND.binop;
        }
        var op2 = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
        var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op2, logical || coalesce);
        if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
        }
        return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
      }
    }
    return left;
  };
  pp$5.buildBinary = function(startPos, startLoc, left, right, op2, logical) {
    if (right.type === "PrivateIdentifier") {
      this.raise(right.start, "Private identifier can only be left side of binary expression");
    }
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.left = left;
    node2.operator = op2;
    node2.right = right;
    return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
  };
  pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && this.canAwait) {
      expr = this.parseAwait(forInit);
      sawUnary = true;
    } else if (this.type.prefix) {
      var node2 = this.startNode(), update = this.type === types$1.incDec;
      node2.operator = this.value;
      node2.prefix = true;
      this.next();
      node2.argument = this.parseMaybeUnary(null, true, update, forInit);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) {
        this.checkLValSimple(node2.argument);
      } else if (this.strict && node2.operator === "delete" && isLocalVariableAccess(node2.argument)) {
        this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
      } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
        this.raiseRecoverable(node2.start, "Private fields can not be deleted");
      } else {
        sawUnary = true;
      }
      expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
    } else if (!sawUnary && this.type === types$1.privateId) {
      if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
        this.unexpected();
      }
      expr = this.parsePrivateIdent();
      if (this.type !== types$1._in) {
        this.unexpected();
      }
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$12 = this.startNodeAt(startPos, startLoc);
        node$12.operator = this.value;
        node$12.prefix = false;
        node$12.argument = expr;
        this.checkLValSimple(expr);
        this.next();
        expr = this.finishNode(node$12, "UpdateExpression");
      }
    }
    if (!incDec && this.eat(types$1.starstar)) {
      if (sawUnary) {
        this.unexpected(this.lastTokStart);
      } else {
        return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
      }
    } else {
      return expr;
    }
  };
  function isLocalVariableAccess(node2) {
    return node2.type === "Identifier" || node2.type === "ParenthesizedExpression" && isLocalVariableAccess(node2.expression);
  }
  function isPrivateFieldAccess(node2) {
    return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression) || node2.type === "ParenthesizedExpression" && isPrivateFieldAccess(node2.expression);
  }
  pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors, forInit);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
      return expr;
    }
    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) {
        refDestructuringErrors.parenthesizedAssign = -1;
      }
      if (refDestructuringErrors.parenthesizedBind >= result.start) {
        refDestructuringErrors.parenthesizedBind = -1;
      }
      if (refDestructuringErrors.trailingComma >= result.start) {
        refDestructuringErrors.trailingComma = -1;
      }
    }
    return result;
  };
  pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
    var optionalChained = false;
    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
      if (element.optional) {
        optionalChained = true;
      }
      if (element === base || element.type === "ArrowFunctionExpression") {
        if (optionalChained) {
          var chainNode = this.startNodeAt(startPos, startLoc);
          chainNode.expression = element;
          element = this.finishNode(chainNode, "ChainExpression");
        }
        return element;
      }
      base = element;
    }
  };
  pp$5.shouldParseAsyncArrow = function() {
    return !this.canInsertSemicolon() && this.eat(types$1.arrow);
  };
  pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
  };
  pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types$1.questionDot);
    if (noCalls && optional) {
      this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
    }
    var computed = this.eat(types$1.bracketL);
    if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.object = base;
      if (computed) {
        node2.property = this.parseExpression();
        this.expect(types$1.bracketR);
      } else if (this.type === types$1.privateId && base.type !== "Super") {
        node2.property = this.parsePrivateIdent();
      } else {
        node2.property = this.parseIdent(this.options.allowReserved !== "never");
      }
      node2.computed = !!computed;
      if (optionalSupported) {
        node2.optional = optional;
      }
      base = this.finishNode(node2, "MemberExpression");
    } else if (!noCalls && this.eat(types$1.parenL)) {
      var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0) {
          this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
        }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$12 = this.startNodeAt(startPos, startLoc);
      node$12.callee = base;
      node$12.arguments = exprList;
      if (optionalSupported) {
        node$12.optional = optional;
      }
      base = this.finishNode(node$12, "CallExpression");
    } else if (this.type === types$1.backQuote) {
      if (optional || optionalChained) {
        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      }
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({
        isTagged: true
      });
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base;
  };
  pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
    if (this.type === types$1.slash) {
      this.readRegexp();
    }
    var node2, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
      case types$1._super:
        if (!this.allowSuper) {
          this.raise(this.start, "'super' keyword outside a method");
        }
        node2 = this.startNode();
        this.next();
        if (this.type === types$1.parenL && !this.allowDirectSuper) {
          this.raise(node2.start, "super() call outside constructor of a subclass");
        }
        if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
          this.unexpected();
        }
        return this.finishNode(node2, "Super");
      case types$1._this:
        node2 = this.startNode();
        this.next();
        return this.finishNode(node2, "ThisExpression");
      case types$1.name:
        var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
        var id2 = this.parseIdent(false);
        if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
          this.overrideContext(types.f_expr);
          return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
        }
        if (canBeArrow && !this.canInsertSemicolon()) {
          if (this.eat(types$1.arrow)) {
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
              id2
            ], false, forInit);
          }
          if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
            id2 = this.parseIdent(false);
            if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
              this.unexpected();
            }
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
              id2
            ], true, forInit);
          }
        }
        return id2;
      case types$1.regexp:
        var value2 = this.value;
        node2 = this.parseLiteral(value2.value);
        node2.regex = {
          pattern: value2.pattern,
          flags: value2.flags
        };
        return node2;
      case types$1.num:
      case types$1.string:
        return this.parseLiteral(this.value);
      case types$1._null:
      case types$1._true:
      case types$1._false:
        node2 = this.startNode();
        node2.value = this.type === types$1._null ? null : this.type === types$1._true;
        node2.raw = this.type.keyword;
        this.next();
        return this.finishNode(node2, "Literal");
      case types$1.parenL:
        var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
        if (refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
            refDestructuringErrors.parenthesizedAssign = start;
          }
          if (refDestructuringErrors.parenthesizedBind < 0) {
            refDestructuringErrors.parenthesizedBind = start;
          }
        }
        return expr;
      case types$1.bracketL:
        node2 = this.startNode();
        this.next();
        node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
        return this.finishNode(node2, "ArrayExpression");
      case types$1.braceL:
        this.overrideContext(types.b_expr);
        return this.parseObj(false, refDestructuringErrors);
      case types$1._function:
        node2 = this.startNode();
        this.next();
        return this.parseFunction(node2, 0);
      case types$1._class:
        return this.parseClass(this.startNode(), false);
      case types$1._new:
        return this.parseNew();
      case types$1.backQuote:
        return this.parseTemplate();
      case types$1._import:
        if (this.options.ecmaVersion >= 11) {
          return this.parseExprImport(forNew);
        } else {
          return this.unexpected();
        }
      default:
        return this.parseExprAtomDefault();
    }
  };
  pp$5.parseExprAtomDefault = function() {
    this.unexpected();
  };
  pp$5.parseExprImport = function(forNew) {
    var node2 = this.startNode();
    if (this.containsEsc) {
      this.raiseRecoverable(this.start, "Escape sequence in keyword import");
    }
    this.next();
    if (this.type === types$1.parenL && !forNew) {
      return this.parseDynamicImport(node2);
    } else if (this.type === types$1.dot) {
      var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
      meta.name = "import";
      node2.meta = this.finishNode(meta, "Identifier");
      return this.parseImportMeta(node2);
    } else {
      this.unexpected();
    }
  };
  pp$5.parseDynamicImport = function(node2) {
    this.next();
    node2.source = this.parseMaybeAssign();
    if (this.options.ecmaVersion >= 16) {
      if (!this.eat(types$1.parenR)) {
        this.expect(types$1.comma);
        if (!this.afterTrailingComma(types$1.parenR)) {
          node2.options = this.parseMaybeAssign();
          if (!this.eat(types$1.parenR)) {
            this.expect(types$1.comma);
            if (!this.afterTrailingComma(types$1.parenR)) {
              this.unexpected();
            }
          }
        } else {
          node2.options = null;
        }
      } else {
        node2.options = null;
      }
    } else {
      if (!this.eat(types$1.parenR)) {
        var errorPos = this.start;
        if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }
    }
    return this.finishNode(node2, "ImportExpression");
  };
  pp$5.parseImportMeta = function(node2) {
    this.next();
    var containsEsc = this.containsEsc;
    node2.property = this.parseIdent(true);
    if (node2.property.name !== "meta") {
      this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
    }
    if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
      this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
    }
    return this.finishNode(node2, "MetaProperty");
  };
  pp$5.parseLiteral = function(value2) {
    var node2 = this.startNode();
    node2.value = value2;
    node2.raw = this.input.slice(this.start, this.end);
    if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
      node2.bigint = node2.value != null ? node2.value.toString() : node2.raw.slice(0, -1).replace(/_/g, "");
    }
    this.next();
    return this.finishNode(node2, "Literal");
  };
  pp$5.parseParenExpression = function() {
    this.expect(types$1.parenL);
    var val = this.parseExpression();
    this.expect(types$1.parenR);
    return val;
  };
  pp$5.shouldParseArrow = function(exprList) {
    return !this.canInsertSemicolon();
  };
  pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();
      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      while (this.type !== types$1.parenR) {
        first ? first = false : this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
          lastIsComma = true;
          break;
        } else if (this.type === types$1.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types$1.comma) {
            this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
          }
          break;
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
      this.expect(types$1.parenR);
      if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
      }
      if (!exprList.length || lastIsComma) {
        this.unexpected(this.lastTokStart);
      }
      if (spreadStart) {
        this.unexpected(spreadStart);
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }
    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression");
    } else {
      return val;
    }
  };
  pp$5.parseParenItem = function(item) {
    return item;
  };
  pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
  };
  var empty = [];
  pp$5.parseNew = function() {
    if (this.containsEsc) {
      this.raiseRecoverable(this.start, "Escape sequence in keyword new");
    }
    var node2 = this.startNode();
    this.next();
    if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
      var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
      meta.name = "new";
      node2.meta = this.finishNode(meta, "Identifier");
      this.next();
      var containsEsc = this.containsEsc;
      node2.property = this.parseIdent(true);
      if (node2.property.name !== "target") {
        this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
      }
      if (!this.allowNewDotTarget) {
        this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
      }
      return this.finishNode(node2, "MetaProperty");
    }
    var startPos = this.start, startLoc = this.startLoc;
    node2.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
    if (this.eat(types$1.parenL)) {
      node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
    } else {
      node2.arguments = empty;
    }
    return this.finishNode(node2, "NewExpression");
  };
  pp$5.parseTemplateElement = function(ref2) {
    var isTagged = ref2.isTagged;
    var elem = this.startNode();
    if (this.type === types$1.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value.replace(/\r\n?/g, "\n"),
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types$1.backQuote;
    return this.finishNode(elem, "TemplateElement");
  };
  pp$5.parseTemplate = function(ref2) {
    if (ref2 === void 0)
      ref2 = {};
    var isTagged = ref2.isTagged;
    if (isTagged === void 0)
      isTagged = false;
    var node2 = this.startNode();
    this.next();
    node2.expressions = [];
    var curElt = this.parseTemplateElement({
      isTagged
    });
    node2.quasis = [
      curElt
    ];
    while (!curElt.tail) {
      if (this.type === types$1.eof) {
        this.raise(this.pos, "Unterminated template literal");
      }
      this.expect(types$1.dollarBraceL);
      node2.expressions.push(this.parseExpression());
      this.expect(types$1.braceR);
      node2.quasis.push(curElt = this.parseTemplateElement({
        isTagged
      }));
    }
    this.next();
    return this.finishNode(node2, "TemplateLiteral");
  };
  pp$5.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  };
  pp$5.parseObj = function(isPattern, refDestructuringErrors) {
    var node2 = this.startNode(), first = true, propHash = {};
    node2.properties = [];
    this.next();
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) {
        this.checkPropClash(prop, propHash, refDestructuringErrors);
      }
      node2.properties.push(prop);
    }
    return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
  };
  pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types$1.comma) {
          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement");
      }
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      return this.finishNode(prop, "SpreadElement");
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern) {
        isGenerator = this.eat(types$1.star);
      }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
      this.parsePropertyName(prop);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property");
  };
  pp$5.parseGetterSetter = function(prop) {
    var kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    prop.kind = kind;
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") {
        this.raiseRecoverable(start, "getter should have no params");
      } else {
        this.raiseRecoverable(start, "setter should have exactly one param");
      }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
      }
    }
  };
  pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types$1.colon) {
      this.unexpected();
    }
    if (this.eat(types$1.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
      if (isPattern) {
        this.unexpected();
      }
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
      prop.kind = "init";
    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
      if (isGenerator || isAsync) {
        this.unexpected();
      }
      this.parseGetterSetter(prop);
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) {
        this.unexpected();
      }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos) {
        this.awaitIdentPos = startPos;
      }
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      } else if (this.type === types$1.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0) {
          refDestructuringErrors.shorthandAssign = this.start;
        }
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      } else {
        prop.value = this.copyNode(prop.key);
      }
      prop.kind = "init";
      prop.shorthand = true;
    } else {
      this.unexpected();
    }
  };
  pp$5.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types$1.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types$1.bracketR);
        return prop.key;
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  };
  pp$5.initFunction = function(node2) {
    node2.id = null;
    if (this.options.ecmaVersion >= 6) {
      node2.generator = node2.expression = false;
    }
    if (this.options.ecmaVersion >= 8) {
      node2.async = false;
    }
  };
  pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.initFunction(node2);
    if (this.options.ecmaVersion >= 6) {
      node2.generator = isGenerator;
    }
    if (this.options.ecmaVersion >= 8) {
      node2.async = !!isAsync;
    }
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
    this.expect(types$1.parenL);
    node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node2, false, true, false);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node2, "FunctionExpression");
  };
  pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node2);
    if (this.options.ecmaVersion >= 8) {
      node2.async = !!isAsync;
    }
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    node2.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node2, true, false, forInit);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node2, "ArrowFunctionExpression");
  };
  pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
    var isExpression = isArrowFunction && this.type !== types$1.braceL;
    var oldStrict = this.strict, useStrict = false;
    if (isExpression) {
      node2.body = this.parseMaybeAssign(forInit);
      node2.expression = true;
      this.checkParams(node2, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        if (useStrict && nonSimple) {
          this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
        }
      }
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) {
        this.strict = true;
      }
      this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
      if (this.strict && node2.id) {
        this.checkLValSimple(node2.id, BIND_OUTSIDE);
      }
      node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
      node2.expression = false;
      this.adaptDirectivePrologue(node2.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();
  };
  pp$5.isSimpleParamList = function(params) {
    for (var i22 = 0, list2 = params; i22 < list2.length; i22 += 1) {
      var param = list2[i22];
      if (param.type !== "Identifier") {
        return false;
      }
    }
    return true;
  };
  pp$5.checkParams = function(node2, allowDuplicates) {
    var nameHash = /* @__PURE__ */ Object.create(null);
    for (var i22 = 0, list2 = node2.params; i22 < list2.length; i22 += 1) {
      var param = list2[i22];
      this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };
  pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close2)) {
      if (!first) {
        this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(close2)) {
          break;
        }
      } else {
        first = false;
      }
      var elt = void 0;
      if (allowEmpty && this.type === types$1.comma) {
        elt = null;
      } else if (this.type === types$1.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts;
  };
  pp$5.checkUnreserved = function(ref2) {
    var start = ref2.start;
    var end = ref2.end;
    var name2 = ref2.name;
    if (this.inGenerator && name2 === "yield") {
      this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
    }
    if (this.inAsync && name2 === "await") {
      this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
    }
    if (!(this.currentThisScope().flags & SCOPE_VAR) && name2 === "arguments") {
      this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
    }
    if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
      this.raise(start, "Cannot use " + name2 + " in class static initialization block");
    }
    if (this.keywords.test(name2)) {
      this.raise(start, "Unexpected keyword '" + name2 + "'");
    }
    if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
      return;
    }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name2)) {
      if (!this.inAsync && name2 === "await") {
        this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
      }
      this.raiseRecoverable(start, "The keyword '" + name2 + "' is reserved");
    }
  };
  pp$5.parseIdent = function(liberal) {
    var node2 = this.parseIdentNode();
    this.next(!!liberal);
    this.finishNode(node2, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node2);
      if (node2.name === "await" && !this.awaitIdentPos) {
        this.awaitIdentPos = node2.start;
      }
    }
    return node2;
  };
  pp$5.parseIdentNode = function() {
    var node2 = this.startNode();
    if (this.type === types$1.name) {
      node2.name = this.value;
    } else if (this.type.keyword) {
      node2.name = this.type.keyword;
      if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
      this.type = types$1.name;
    } else {
      this.unexpected();
    }
    return node2;
  };
  pp$5.parsePrivateIdent = function() {
    var node2 = this.startNode();
    if (this.type === types$1.privateId) {
      node2.name = this.value;
    } else {
      this.unexpected();
    }
    this.next();
    this.finishNode(node2, "PrivateIdentifier");
    if (this.options.checkPrivateFields) {
      if (this.privateNameStack.length === 0) {
        this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
      } else {
        this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
      }
    }
    return node2;
  };
  pp$5.parseYield = function(forInit) {
    if (!this.yieldPos) {
      this.yieldPos = this.start;
    }
    var node2 = this.startNode();
    this.next();
    if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
      node2.delegate = false;
      node2.argument = null;
    } else {
      node2.delegate = this.eat(types$1.star);
      node2.argument = this.parseMaybeAssign(forInit);
    }
    return this.finishNode(node2, "YieldExpression");
  };
  pp$5.parseAwait = function(forInit) {
    if (!this.awaitPos) {
      this.awaitPos = this.start;
    }
    var node2 = this.startNode();
    this.next();
    node2.argument = this.parseMaybeUnary(null, true, false, forInit);
    return this.finishNode(node2, "AwaitExpression");
  };
  var pp$4 = Parser.prototype;
  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    if (this.sourceFile) {
      message += " in " + this.sourceFile;
    }
    var err2 = new SyntaxError(message);
    err2.pos = pos;
    err2.loc = loc;
    err2.raisedAt = this.pos;
    throw err2;
  };
  pp$4.raiseRecoverable = pp$4.raise;
  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart);
    }
  };
  var pp$3 = Parser.prototype;
  var Scope$1 = function Scope2(flags) {
    this.flags = flags;
    this.var = [];
    this.lexical = [];
    this.functions = [];
  };
  pp$3.enterScope = function(flags) {
    this.scopeStack.push(new Scope$1(flags));
  };
  pp$3.exitScope = function() {
    this.scopeStack.pop();
  };
  pp$3.treatFunctionsAsVarInScope = function(scope2) {
    return scope2.flags & SCOPE_FUNCTION || !this.inModule && scope2.flags & SCOPE_TOP;
  };
  pp$3.declareName = function(name2, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope2 = this.currentScope();
      redeclared = scope2.lexical.indexOf(name2) > -1 || scope2.functions.indexOf(name2) > -1 || scope2.var.indexOf(name2) > -1;
      scope2.lexical.push(name2);
      if (this.inModule && scope2.flags & SCOPE_TOP) {
        delete this.undefinedExports[name2];
      }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$12 = this.currentScope();
      scope$12.lexical.push(name2);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar) {
        redeclared = scope$2.lexical.indexOf(name2) > -1;
      } else {
        redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
      }
      scope$2.functions.push(name2);
    } else {
      for (var i22 = this.scopeStack.length - 1; i22 >= 0; --i22) {
        var scope$3 = this.scopeStack[i22];
        if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
          redeclared = true;
          break;
        }
        scope$3.var.push(name2);
        if (this.inModule && scope$3.flags & SCOPE_TOP) {
          delete this.undefinedExports[name2];
        }
        if (scope$3.flags & SCOPE_VAR) {
          break;
        }
      }
    }
    if (redeclared) {
      this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
    }
  };
  pp$3.checkLocalExport = function(id2) {
    if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
      this.undefinedExports[id2.name] = id2;
    }
  };
  pp$3.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1];
  };
  pp$3.currentVarScope = function() {
    for (var i22 = this.scopeStack.length - 1; ; i22--) {
      var scope2 = this.scopeStack[i22];
      if (scope2.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
        return scope2;
      }
    }
  };
  pp$3.currentThisScope = function() {
    for (var i22 = this.scopeStack.length - 1; ; i22--) {
      var scope2 = this.scopeStack[i22];
      if (scope2.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope2.flags & SCOPE_ARROW)) {
        return scope2;
      }
    }
  };
  var Node = function Node22(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations) {
      this.loc = new SourceLocation(parser, loc);
    }
    if (parser.options.directSourceFile) {
      this.sourceFile = parser.options.directSourceFile;
    }
    if (parser.options.ranges) {
      this.range = [
        pos,
        0
      ];
    }
  };
  var pp$2 = Parser.prototype;
  pp$2.startNode = function() {
    return new Node(this, this.start, this.startLoc);
  };
  pp$2.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc);
  };
  function finishNodeAt(node2, type2, pos, loc) {
    node2.type = type2;
    node2.end = pos;
    if (this.options.locations) {
      node2.loc.end = loc;
    }
    if (this.options.ranges) {
      node2.range[1] = pos;
    }
    return node2;
  }
  pp$2.finishNode = function(node2, type2) {
    return finishNodeAt.call(this, node2, type2, this.lastTokEnd, this.lastTokEndLoc);
  };
  pp$2.finishNodeAt = function(node2, type2, pos, loc) {
    return finishNodeAt.call(this, node2, type2, pos, loc);
  };
  pp$2.copyNode = function(node2) {
    var newNode = new Node(this, node2.start, this.startLoc);
    for (var prop in node2) {
      newNode[prop] = node2[prop];
    }
    return newNode;
  };
  var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
  var ecma13BinaryProperties = ecma12BinaryProperties;
  var ecma14BinaryProperties = ecma13BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties,
    12: ecma12BinaryProperties,
    13: ecma13BinaryProperties,
    14: ecma14BinaryProperties
  };
  var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
  var unicodeBinaryPropertiesOfStrings = {
    9: "",
    10: "",
    11: "",
    12: "",
    13: "",
    14: ecma14BinaryPropertiesOfStrings
  };
  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
  var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
  var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
  var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues,
    12: ecma12ScriptValues,
    13: ecma13ScriptValues,
    14: ecma14ScriptValues
  };
  var data = {};
  function buildUnicodeData(ecmaVersion2) {
    var d = data[ecmaVersion2] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
      binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;
    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  for (var i = 0, list = [
    9,
    10,
    11,
    12,
    13,
    14
  ]; i < list.length; i += 1) {
    var ecmaVersion = list[i];
    buildUnicodeData(ecmaVersion);
  }
  var pp$1 = Parser.prototype;
  var BranchID = function BranchID2(parent, base) {
    this.parent = parent;
    this.base = base || this;
  };
  BranchID.prototype.separatedFrom = function separatedFrom(alt) {
    for (var self = this; self; self = self.parent) {
      for (var other = alt; other; other = other.parent) {
        if (self.base === other.base && self !== other) {
          return true;
        }
      }
    }
    return false;
  };
  BranchID.prototype.sibling = function sibling() {
    return new BranchID(this.parent, this.base);
  };
  var RegExpValidationState = function RegExpValidationState2(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchV = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = /* @__PURE__ */ Object.create(null);
    this.backReferenceNames = [];
    this.branchID = null;
  };
  RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
    var unicodeSets = flags.indexOf("v") !== -1;
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
      this.switchU = true;
      this.switchV = true;
      this.switchN = true;
    } else {
      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
      this.switchV = false;
      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    }
  };
  RegExpValidationState.prototype.raise = function raise(message) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
  };
  RegExpValidationState.prototype.at = function at2(i22, forceU) {
    if (forceU === void 0)
      forceU = false;
    var s10 = this.source;
    var l = s10.length;
    if (i22 >= l) {
      return -1;
    }
    var c = s10.charCodeAt(i22);
    if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i22 + 1 >= l) {
      return c;
    }
    var next2 = s10.charCodeAt(i22 + 1);
    return next2 >= 56320 && next2 <= 57343 ? (c << 10) + next2 - 56613888 : c;
  };
  RegExpValidationState.prototype.nextIndex = function nextIndex(i22, forceU) {
    if (forceU === void 0)
      forceU = false;
    var s10 = this.source;
    var l = s10.length;
    if (i22 >= l) {
      return l;
    }
    var c = s10.charCodeAt(i22), next2;
    if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i22 + 1 >= l || (next2 = s10.charCodeAt(i22 + 1)) < 56320 || next2 > 57343) {
      return i22 + 1;
    }
    return i22 + 2;
  };
  RegExpValidationState.prototype.current = function current(forceU) {
    if (forceU === void 0)
      forceU = false;
    return this.at(this.pos, forceU);
  };
  RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
    if (forceU === void 0)
      forceU = false;
    return this.at(this.nextIndex(this.pos, forceU), forceU);
  };
  RegExpValidationState.prototype.advance = function advance(forceU) {
    if (forceU === void 0)
      forceU = false;
    this.pos = this.nextIndex(this.pos, forceU);
  };
  RegExpValidationState.prototype.eat = function eat(ch2, forceU) {
    if (forceU === void 0)
      forceU = false;
    if (this.current(forceU) === ch2) {
      this.advance(forceU);
      return true;
    }
    return false;
  };
  RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
    if (forceU === void 0)
      forceU = false;
    var pos = this.pos;
    for (var i22 = 0, list2 = chs; i22 < list2.length; i22 += 1) {
      var ch2 = list2[i22];
      var current2 = this.at(pos, forceU);
      if (current2 === -1 || current2 !== ch2) {
        return false;
      }
      pos = this.nextIndex(pos, forceU);
    }
    this.pos = pos;
    return true;
  };
  pp$1.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;
    var u = false;
    var v = false;
    for (var i22 = 0; i22 < flags.length; i22++) {
      var flag = flags.charAt(i22);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i22 + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
      if (flag === "u") {
        u = true;
      }
      if (flag === "v") {
        v = true;
      }
    }
    if (this.options.ecmaVersion >= 15 && u && v) {
      this.raise(state.start, "Invalid regular expression flag");
    }
  };
  function hasProp(obj) {
    for (var _10 in obj) {
      return true;
    }
    return false;
  }
  pp$1.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);
    if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };
  pp$1.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames = /* @__PURE__ */ Object.create(null);
    state.backReferenceNames.length = 0;
    state.branchID = null;
    this.regexp_disjunction(state);
    if (state.pos !== state.source.length) {
      if (state.eat(41)) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(93) || state.eat(125)) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i22 = 0, list2 = state.backReferenceNames; i22 < list2.length; i22 += 1) {
      var name2 = list2[i22];
      if (!state.groupNames[name2]) {
        state.raise("Invalid named capture referenced");
      }
    }
  };
  pp$1.regexp_disjunction = function(state) {
    var trackDisjunction = this.options.ecmaVersion >= 16;
    if (trackDisjunction) {
      state.branchID = new BranchID(state.branchID, null);
    }
    this.regexp_alternative(state);
    while (state.eat(124)) {
      if (trackDisjunction) {
        state.branchID = state.branchID.sibling();
      }
      this.regexp_alternative(state);
    }
    if (trackDisjunction) {
      state.branchID = state.branchID.parent;
    }
    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(123)) {
      state.raise("Lone quantifier brackets");
    }
  };
  pp$1.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
    }
  };
  pp$1.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true;
    }
    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true;
    }
    return false;
  };
  pp$1.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;
    if (state.eat(94) || state.eat(36)) {
      return true;
    }
    if (state.eat(92)) {
      if (state.eat(66) || state.eat(98)) {
        return true;
      }
      state.pos = start;
    }
    if (state.eat(40) && state.eat(63)) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(60);
      }
      if (state.eat(61) || state.eat(33)) {
        this.regexp_disjunction(state);
        if (!state.eat(41)) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true;
      }
    }
    state.pos = start;
    return false;
  };
  pp$1.regexp_eatQuantifier = function(state, noError) {
    if (noError === void 0)
      noError = false;
    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(63);
      return true;
    }
    return false;
  };
  pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
    return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
  };
  pp$1.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(123)) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(125)) {
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true;
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatAtom = function(state) {
    return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
  };
  pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(92)) {
      if (this.regexp_eatAtomEscape(state)) {
        return true;
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(40)) {
      if (state.eat(63)) {
        if (this.options.ecmaVersion >= 16) {
          var addModifiers = this.regexp_eatModifiers(state);
          var hasHyphen = state.eat(45);
          if (addModifiers || hasHyphen) {
            for (var i22 = 0; i22 < addModifiers.length; i22++) {
              var modifier = addModifiers.charAt(i22);
              if (addModifiers.indexOf(modifier, i22 + 1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
            if (hasHyphen) {
              var removeModifiers = this.regexp_eatModifiers(state);
              if (!addModifiers && !removeModifiers && state.current() === 58) {
                state.raise("Invalid regular expression modifiers");
              }
              for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                var modifier$1 = removeModifiers.charAt(i$1);
                if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                  state.raise("Duplicate regular expression modifiers");
                }
              }
            }
          }
        }
        if (state.eat(58)) {
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            return true;
          }
          state.raise("Unterminated group");
        }
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatCapturingGroup = function(state) {
    if (state.eat(40)) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 63) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(41)) {
        state.numCapturingParens += 1;
        return true;
      }
      state.raise("Unterminated group");
    }
    return false;
  };
  pp$1.regexp_eatModifiers = function(state) {
    var modifiers = "";
    var ch2 = 0;
    while ((ch2 = state.current()) !== -1 && isRegularExpressionModifier(ch2)) {
      modifiers += codePointToString(ch2);
      state.advance();
    }
    return modifiers;
  };
  function isRegularExpressionModifier(ch2) {
    return ch2 === 105 || ch2 === 109 || ch2 === 115;
  }
  pp$1.regexp_eatExtendedAtom = function(state) {
    return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
  };
  pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false;
  };
  pp$1.regexp_eatSyntaxCharacter = function(state) {
    var ch2 = state.current();
    if (isSyntaxCharacter(ch2)) {
      state.lastIntValue = ch2;
      state.advance();
      return true;
    }
    return false;
  };
  function isSyntaxCharacter(ch2) {
    return ch2 === 36 || ch2 >= 40 && ch2 <= 43 || ch2 === 46 || ch2 === 63 || ch2 >= 91 && ch2 <= 94 || ch2 >= 123 && ch2 <= 125;
  }
  pp$1.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch2 = 0;
    while ((ch2 = state.current()) !== -1 && !isSyntaxCharacter(ch2)) {
      state.advance();
    }
    return state.pos !== start;
  };
  pp$1.regexp_eatExtendedPatternCharacter = function(state) {
    var ch2 = state.current();
    if (ch2 !== -1 && ch2 !== 36 && !(ch2 >= 40 && ch2 <= 43) && ch2 !== 46 && ch2 !== 63 && ch2 !== 91 && ch2 !== 94 && ch2 !== 124) {
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_groupSpecifier = function(state) {
    if (state.eat(63)) {
      if (!this.regexp_eatGroupName(state)) {
        state.raise("Invalid group");
      }
      var trackDisjunction = this.options.ecmaVersion >= 16;
      var known = state.groupNames[state.lastStringValue];
      if (known) {
        if (trackDisjunction) {
          for (var i22 = 0, list2 = known; i22 < list2.length; i22 += 1) {
            var altID = list2[i22];
            if (!altID.separatedFrom(state.branchID)) {
              state.raise("Duplicate capture group name");
            }
          }
        } else {
          state.raise("Duplicate capture group name");
        }
      }
      if (trackDisjunction) {
        (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
      } else {
        state.groupNames[state.lastStringValue] = true;
      }
    }
  };
  pp$1.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(60)) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
        return true;
      }
      state.raise("Invalid capture group name");
    }
    return false;
  };
  pp$1.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true;
    }
    return false;
  };
  pp$1.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch2 = state.current(forceU);
    state.advance(forceU);
    if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch2 = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch2)) {
      state.lastIntValue = ch2;
      return true;
    }
    state.pos = start;
    return false;
  };
  function isRegExpIdentifierStart(ch2) {
    return isIdentifierStart$1(ch2, true) || ch2 === 36 || ch2 === 95;
  }
  pp$1.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch2 = state.current(forceU);
    state.advance(forceU);
    if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch2 = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch2)) {
      state.lastIntValue = ch2;
      return true;
    }
    state.pos = start;
    return false;
  };
  function isRegExpIdentifierPart(ch2) {
    return isIdentifierChar(ch2, true) || ch2 === 36 || ch2 === 95 || ch2 === 8204 || ch2 === 8205;
  }
  pp$1.regexp_eatAtomEscape = function(state) {
    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
      return true;
    }
    if (state.switchU) {
      if (state.current() === 99) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false;
  };
  pp$1.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n10 = state.lastIntValue;
      if (state.switchU) {
        if (n10 > state.maxBackReference) {
          state.maxBackReference = n10;
        }
        return true;
      }
      if (n10 <= state.numCapturingParens) {
        return true;
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatKGroupName = function(state) {
    if (state.eat(107)) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true;
      }
      state.raise("Invalid named reference");
    }
    return false;
  };
  pp$1.regexp_eatCharacterEscape = function(state) {
    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
  };
  pp$1.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(99)) {
      if (this.regexp_eatControlLetter(state)) {
        return true;
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatZero = function(state) {
    if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatControlEscape = function(state) {
    var ch2 = state.current();
    if (ch2 === 116) {
      state.lastIntValue = 9;
      state.advance();
      return true;
    }
    if (ch2 === 110) {
      state.lastIntValue = 10;
      state.advance();
      return true;
    }
    if (ch2 === 118) {
      state.lastIntValue = 11;
      state.advance();
      return true;
    }
    if (ch2 === 102) {
      state.lastIntValue = 12;
      state.advance();
      return true;
    }
    if (ch2 === 114) {
      state.lastIntValue = 13;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatControlLetter = function(state) {
    var ch2 = state.current();
    if (isControlLetter(ch2)) {
      state.lastIntValue = ch2 % 32;
      state.advance();
      return true;
    }
    return false;
  };
  function isControlLetter(ch2) {
    return ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122;
  }
  pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if (forceU === void 0)
      forceU = false;
    var start = state.pos;
    var switchU = forceU || state.switchU;
    if (state.eat(117)) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (switchU && lead >= 55296 && lead <= 56319) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 56320 && trail <= 57343) {
              state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
              return true;
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true;
      }
      if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
        return true;
      }
      if (switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }
    return false;
  };
  function isValidUnicode(ch2) {
    return ch2 >= 0 && ch2 <= 1114111;
  }
  pp$1.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true;
      }
      if (state.eat(47)) {
        state.lastIntValue = 47;
        return true;
      }
      return false;
    }
    var ch2 = state.current();
    if (ch2 !== 99 && (!state.switchN || ch2 !== 107)) {
      state.lastIntValue = ch2;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch2 = state.current();
    if (ch2 >= 49 && ch2 <= 57) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
        state.advance();
      } while ((ch2 = state.current()) >= 48 && ch2 <= 57);
      return true;
    }
    return false;
  };
  var CharSetNone = 0;
  var CharSetOk = 1;
  var CharSetString = 2;
  pp$1.regexp_eatCharacterClassEscape = function(state) {
    var ch2 = state.current();
    if (isCharacterClassEscape(ch2)) {
      state.lastIntValue = -1;
      state.advance();
      return CharSetOk;
    }
    var negate = false;
    if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch2 === 80) || ch2 === 112)) {
      state.lastIntValue = -1;
      state.advance();
      var result;
      if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
        if (negate && result === CharSetString) {
          state.raise("Invalid property name");
        }
        return result;
      }
      state.raise("Invalid property name");
    }
    return CharSetNone;
  };
  function isCharacterClassEscape(ch2) {
    return ch2 === 100 || ch2 === 68 || ch2 === 115 || ch2 === 83 || ch2 === 119 || ch2 === 87;
  }
  pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
      var name2 = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value2 = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name2, value2);
        return CharSetOk;
      }
    }
    state.pos = start;
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    }
    return CharSetNone;
  };
  pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value2) {
    if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
      state.raise("Invalid property name");
    }
    if (!state.unicodeProperties.nonBinary[name2].test(value2)) {
      state.raise("Invalid property value");
    }
  };
  pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (state.unicodeProperties.binary.test(nameOrValue)) {
      return CharSetOk;
    }
    if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
      return CharSetString;
    }
    state.raise("Invalid property name");
  };
  pp$1.regexp_eatUnicodePropertyName = function(state) {
    var ch2 = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch2 = state.current())) {
      state.lastStringValue += codePointToString(ch2);
      state.advance();
    }
    return state.lastStringValue !== "";
  };
  function isUnicodePropertyNameCharacter(ch2) {
    return isControlLetter(ch2) || ch2 === 95;
  }
  pp$1.regexp_eatUnicodePropertyValue = function(state) {
    var ch2 = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch2 = state.current())) {
      state.lastStringValue += codePointToString(ch2);
      state.advance();
    }
    return state.lastStringValue !== "";
  };
  function isUnicodePropertyValueCharacter(ch2) {
    return isUnicodePropertyNameCharacter(ch2) || isDecimalDigit(ch2);
  }
  pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state);
  };
  pp$1.regexp_eatCharacterClass = function(state) {
    if (state.eat(91)) {
      var negate = state.eat(94);
      var result = this.regexp_classContents(state);
      if (!state.eat(93)) {
        state.raise("Unterminated character class");
      }
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return true;
    }
    return false;
  };
  pp$1.regexp_classContents = function(state) {
    if (state.current() === 93) {
      return CharSetOk;
    }
    if (state.switchV) {
      return this.regexp_classSetExpression(state);
    }
    this.regexp_nonEmptyClassRanges(state);
    return CharSetOk;
  };
  pp$1.regexp_nonEmptyClassRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(45) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };
  pp$1.regexp_eatClassAtom = function(state) {
    var start = state.pos;
    if (state.eat(92)) {
      if (this.regexp_eatClassEscape(state)) {
        return true;
      }
      if (state.switchU) {
        var ch$1 = state.current();
        if (ch$1 === 99 || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    var ch2 = state.current();
    if (ch2 !== 93) {
      state.lastIntValue = ch2;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatClassEscape = function(state) {
    var start = state.pos;
    if (state.eat(98)) {
      state.lastIntValue = 8;
      return true;
    }
    if (state.switchU && state.eat(45)) {
      state.lastIntValue = 45;
      return true;
    }
    if (!state.switchU && state.eat(99)) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true;
      }
      state.pos = start;
    }
    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
  };
  pp$1.regexp_classSetExpression = function(state) {
    var result = CharSetOk, subResult;
    if (this.regexp_eatClassSetRange(state))
      ;
    else if (subResult = this.regexp_eatClassSetOperand(state)) {
      if (subResult === CharSetString) {
        result = CharSetString;
      }
      var start = state.pos;
      while (state.eatChars([
        38,
        38
      ])) {
        if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
          if (subResult !== CharSetString) {
            result = CharSetOk;
          }
          continue;
        }
        state.raise("Invalid character in character class");
      }
      if (start !== state.pos) {
        return result;
      }
      while (state.eatChars([
        45,
        45
      ])) {
        if (this.regexp_eatClassSetOperand(state)) {
          continue;
        }
        state.raise("Invalid character in character class");
      }
      if (start !== state.pos) {
        return result;
      }
    } else {
      state.raise("Invalid character in character class");
    }
    for (; ; ) {
      if (this.regexp_eatClassSetRange(state)) {
        continue;
      }
      subResult = this.regexp_eatClassSetOperand(state);
      if (!subResult) {
        return result;
      }
      if (subResult === CharSetString) {
        result = CharSetString;
      }
    }
  };
  pp$1.regexp_eatClassSetRange = function(state) {
    var start = state.pos;
    if (this.regexp_eatClassSetCharacter(state)) {
      var left = state.lastIntValue;
      if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
        var right = state.lastIntValue;
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
        return true;
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatClassSetOperand = function(state) {
    if (this.regexp_eatClassSetCharacter(state)) {
      return CharSetOk;
    }
    return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
  };
  pp$1.regexp_eatNestedClass = function(state) {
    var start = state.pos;
    if (state.eat(91)) {
      var negate = state.eat(94);
      var result = this.regexp_classContents(state);
      if (state.eat(93)) {
        if (negate && result === CharSetString) {
          state.raise("Negated character class may contain strings");
        }
        return result;
      }
      state.pos = start;
    }
    if (state.eat(92)) {
      var result$1 = this.regexp_eatCharacterClassEscape(state);
      if (result$1) {
        return result$1;
      }
      state.pos = start;
    }
    return null;
  };
  pp$1.regexp_eatClassStringDisjunction = function(state) {
    var start = state.pos;
    if (state.eatChars([
      92,
      113
    ])) {
      if (state.eat(123)) {
        var result = this.regexp_classStringDisjunctionContents(state);
        if (state.eat(125)) {
          return result;
        }
      } else {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return null;
  };
  pp$1.regexp_classStringDisjunctionContents = function(state) {
    var result = this.regexp_classString(state);
    while (state.eat(124)) {
      if (this.regexp_classString(state) === CharSetString) {
        result = CharSetString;
      }
    }
    return result;
  };
  pp$1.regexp_classString = function(state) {
    var count = 0;
    while (this.regexp_eatClassSetCharacter(state)) {
      count++;
    }
    return count === 1 ? CharSetOk : CharSetString;
  };
  pp$1.regexp_eatClassSetCharacter = function(state) {
    var start = state.pos;
    if (state.eat(92)) {
      if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
        return true;
      }
      if (state.eat(98)) {
        state.lastIntValue = 8;
        return true;
      }
      state.pos = start;
      return false;
    }
    var ch2 = state.current();
    if (ch2 < 0 || ch2 === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch2)) {
      return false;
    }
    if (isClassSetSyntaxCharacter(ch2)) {
      return false;
    }
    state.advance();
    state.lastIntValue = ch2;
    return true;
  };
  function isClassSetReservedDoublePunctuatorCharacter(ch2) {
    return ch2 === 33 || ch2 >= 35 && ch2 <= 38 || ch2 >= 42 && ch2 <= 44 || ch2 === 46 || ch2 >= 58 && ch2 <= 64 || ch2 === 94 || ch2 === 96 || ch2 === 126;
  }
  function isClassSetSyntaxCharacter(ch2) {
    return ch2 === 40 || ch2 === 41 || ch2 === 45 || ch2 === 47 || ch2 >= 91 && ch2 <= 93 || ch2 >= 123 && ch2 <= 125;
  }
  pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
    var ch2 = state.current();
    if (isClassSetReservedPunctuator(ch2)) {
      state.lastIntValue = ch2;
      state.advance();
      return true;
    }
    return false;
  };
  function isClassSetReservedPunctuator(ch2) {
    return ch2 === 33 || ch2 === 35 || ch2 === 37 || ch2 === 38 || ch2 === 44 || ch2 === 45 || ch2 >= 58 && ch2 <= 62 || ch2 === 64 || ch2 === 96 || ch2 === 126;
  }
  pp$1.regexp_eatClassControlLetter = function(state) {
    var ch2 = state.current();
    if (isDecimalDigit(ch2) || ch2 === 95) {
      state.lastIntValue = ch2 % 32;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(120)) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true;
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch2 = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch2 = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
      state.advance();
    }
    return state.pos !== start;
  };
  function isDecimalDigit(ch2) {
    return ch2 >= 48 && ch2 <= 57;
  }
  pp$1.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch2 = 0;
    state.lastIntValue = 0;
    while (isHexDigit$1(ch2 = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
      state.advance();
    }
    return state.pos !== start;
  };
  function isHexDigit$1(ch2) {
    return ch2 >= 48 && ch2 <= 57 || ch2 >= 65 && ch2 <= 70 || ch2 >= 97 && ch2 <= 102;
  }
  function hexToInt(ch2) {
    if (ch2 >= 65 && ch2 <= 70) {
      return 10 + (ch2 - 65);
    }
    if (ch2 >= 97 && ch2 <= 102) {
      return 10 + (ch2 - 97);
    }
    return ch2 - 48;
  }
  pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n12 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n22 = state.lastIntValue;
        if (n12 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n12 * 64 + n22 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n12 * 8 + n22;
        }
      } else {
        state.lastIntValue = n12;
      }
      return true;
    }
    return false;
  };
  pp$1.regexp_eatOctalDigit = function(state) {
    var ch2 = state.current();
    if (isOctalDigit(ch2)) {
      state.lastIntValue = ch2 - 48;
      state.advance();
      return true;
    }
    state.lastIntValue = 0;
    return false;
  };
  function isOctalDigit(ch2) {
    return ch2 >= 48 && ch2 <= 55;
  }
  pp$1.regexp_eatFixedHexDigits = function(state, length2) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i22 = 0; i22 < length2; ++i22) {
      var ch2 = state.current();
      if (!isHexDigit$1(ch2)) {
        state.pos = start;
        return false;
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
      state.advance();
    }
    return true;
  };
  var Token = function Token2(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations) {
      this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
    }
    if (p.options.ranges) {
      this.range = [
        p.start,
        p.end
      ];
    }
  };
  var pp = Parser.prototype;
  pp.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
      this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
    }
    if (this.options.onToken) {
      this.options.onToken(new Token(this));
    }
    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };
  pp.getToken = function() {
    this.next();
    return new Token(this);
  };
  if (typeof Symbol !== "undefined") {
    pp[Symbol.iterator] = function() {
      var this$1$1 = this;
      return {
        next: function() {
          var token = this$1$1.getToken();
          return {
            done: token.type === types$1.eof,
            value: token
          };
        }
      };
    };
  }
  pp.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) {
      this.skipSpace();
    }
    this.start = this.pos;
    if (this.options.locations) {
      this.startLoc = this.curPosition();
    }
    if (this.pos >= this.input.length) {
      return this.finishToken(types$1.eof);
    }
    if (curContext.override) {
      return curContext.override(this);
    } else {
      this.readToken(this.fullCharCodeAtPos());
    }
  };
  pp.readToken = function(code2) {
    if (isIdentifierStart$1(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
      return this.readWord();
    }
    return this.getTokenFromCode(code2);
  };
  pp.fullCharCodeAtPos = function() {
    var code2 = this.input.charCodeAt(this.pos);
    if (code2 <= 55295 || code2 >= 56320) {
      return code2;
    }
    var next2 = this.input.charCodeAt(this.pos + 1);
    return next2 <= 56319 || next2 >= 57344 ? code2 : (code2 << 10) + next2 - 56613888;
  };
  pp.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) {
      this.raise(this.pos - 2, "Unterminated comment");
    }
    this.pos = end + 2;
    if (this.options.locations) {
      for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
        ++this.curLine;
        pos = this.lineStart = nextBreak;
      }
    }
    if (this.options.onComment) {
      this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
    }
  };
  pp.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch2 = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch2)) {
      ch2 = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment) {
      this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
    }
  };
  pp.skipSpace = function() {
    loop:
      while (this.pos < this.input.length) {
        var ch2 = this.input.charCodeAt(this.pos);
        switch (ch2) {
          case 32:
          case 160:
            ++this.pos;
            break;
          case 13:
            if (this.input.charCodeAt(this.pos + 1) === 10) {
              ++this.pos;
            }
          case 10:
          case 8232:
          case 8233:
            ++this.pos;
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            break;
          case 47:
            switch (this.input.charCodeAt(this.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;
              case 47:
                this.skipLineComment(2);
                break;
              default:
                break loop;
            }
            break;
          default:
            if (ch2 > 8 && ch2 < 14 || ch2 >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch2))) {
              ++this.pos;
            } else {
              break loop;
            }
        }
      }
  };
  pp.finishToken = function(type2, val) {
    this.end = this.pos;
    if (this.options.locations) {
      this.endLoc = this.curPosition();
    }
    var prevType = this.type;
    this.type = type2;
    this.value = val;
    this.updateContext(prevType);
  };
  pp.readToken_dot = function() {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 >= 48 && next2 <= 57) {
      return this.readNumber(true);
    }
    var next22 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next2 === 46 && next22 === 46) {
      this.pos += 3;
      return this.finishToken(types$1.ellipsis);
    } else {
      ++this.pos;
      return this.finishToken(types$1.dot);
    }
  };
  pp.readToken_slash = function() {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) {
      ++this.pos;
      return this.readRegexp();
    }
    if (next2 === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(types$1.slash, 1);
  };
  pp.readToken_mult_modulo_exp = function(code2) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
    if (this.options.ecmaVersion >= 7 && code2 === 42 && next2 === 42) {
      ++size;
      tokentype = types$1.starstar;
      next2 = this.input.charCodeAt(this.pos + 2);
    }
    if (next2 === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(tokentype, size);
  };
  pp.readToken_pipe_amp = function(code2) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 === code2) {
      if (this.options.ecmaVersion >= 12) {
        var next22 = this.input.charCodeAt(this.pos + 2);
        if (next22 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
    }
    if (next2 === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
  };
  pp.readToken_caret = function() {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(types$1.bitwiseXOR, 1);
  };
  pp.readToken_plus_min = function(code2) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 === code2) {
      if (next2 === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken();
      }
      return this.finishOp(types$1.incDec, 2);
    }
    if (next2 === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(types$1.plusMin, 1);
  };
  pp.readToken_lt_gt = function(code2) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next2 === code2) {
      size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) {
        return this.finishOp(types$1.assign, size + 1);
      }
      return this.finishOp(types$1.bitShift, size);
    }
    if (next2 === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken();
    }
    if (next2 === 61) {
      size = 2;
    }
    return this.finishOp(types$1.relational, size);
  };
  pp.readToken_eq_excl = function(code2) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 === 61) {
      return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
    }
    if (code2 === 61 && next2 === 62 && this.options.ecmaVersion >= 6) {
      this.pos += 2;
      return this.finishToken(types$1.arrow);
    }
    return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
  };
  pp.readToken_question = function() {
    var ecmaVersion2 = this.options.ecmaVersion;
    if (ecmaVersion2 >= 11) {
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === 46) {
        var next22 = this.input.charCodeAt(this.pos + 2);
        if (next22 < 48 || next22 > 57) {
          return this.finishOp(types$1.questionDot, 2);
        }
      }
      if (next2 === 63) {
        if (ecmaVersion2 >= 12) {
          var next2$1 = this.input.charCodeAt(this.pos + 2);
          if (next2$1 === 61) {
            return this.finishOp(types$1.assign, 3);
          }
        }
        return this.finishOp(types$1.coalesce, 2);
      }
    }
    return this.finishOp(types$1.question, 1);
  };
  pp.readToken_numberSign = function() {
    var ecmaVersion2 = this.options.ecmaVersion;
    var code2 = 35;
    if (ecmaVersion2 >= 13) {
      ++this.pos;
      code2 = this.fullCharCodeAtPos();
      if (isIdentifierStart$1(code2, true) || code2 === 92) {
        return this.finishToken(types$1.privateId, this.readWord1());
      }
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
  };
  pp.getTokenFromCode = function(code2) {
    switch (code2) {
      case 46:
        return this.readToken_dot();
      case 40:
        ++this.pos;
        return this.finishToken(types$1.parenL);
      case 41:
        ++this.pos;
        return this.finishToken(types$1.parenR);
      case 59:
        ++this.pos;
        return this.finishToken(types$1.semi);
      case 44:
        ++this.pos;
        return this.finishToken(types$1.comma);
      case 91:
        ++this.pos;
        return this.finishToken(types$1.bracketL);
      case 93:
        ++this.pos;
        return this.finishToken(types$1.bracketR);
      case 123:
        ++this.pos;
        return this.finishToken(types$1.braceL);
      case 125:
        ++this.pos;
        return this.finishToken(types$1.braceR);
      case 58:
        ++this.pos;
        return this.finishToken(types$1.colon);
      case 96:
        if (this.options.ecmaVersion < 6) {
          break;
        }
        ++this.pos;
        return this.finishToken(types$1.backQuote);
      case 48:
        var next2 = this.input.charCodeAt(this.pos + 1);
        if (next2 === 120 || next2 === 88) {
          return this.readRadixNumber(16);
        }
        if (this.options.ecmaVersion >= 6) {
          if (next2 === 111 || next2 === 79) {
            return this.readRadixNumber(8);
          }
          if (next2 === 98 || next2 === 66) {
            return this.readRadixNumber(2);
          }
        }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.readNumber(false);
      case 34:
      case 39:
        return this.readString(code2);
      case 47:
        return this.readToken_slash();
      case 37:
      case 42:
        return this.readToken_mult_modulo_exp(code2);
      case 124:
      case 38:
        return this.readToken_pipe_amp(code2);
      case 94:
        return this.readToken_caret();
      case 43:
      case 45:
        return this.readToken_plus_min(code2);
      case 60:
      case 62:
        return this.readToken_lt_gt(code2);
      case 61:
      case 33:
        return this.readToken_eq_excl(code2);
      case 63:
        return this.readToken_question();
      case 126:
        return this.finishOp(types$1.prefix, 1);
      case 35:
        return this.readToken_numberSign();
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
  };
  pp.finishOp = function(type2, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type2, str);
  };
  pp.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length) {
        this.raise(start, "Unterminated regular expression");
      }
      var ch2 = this.input.charAt(this.pos);
      if (lineBreak.test(ch2)) {
        this.raise(start, "Unterminated regular expression");
      }
      if (!escaped) {
        if (ch2 === "[") {
          inClass = true;
        } else if (ch2 === "]" && inClass) {
          inClass = false;
        } else if (ch2 === "/" && !inClass) {
          break;
        }
        escaped = ch2 === "\\";
      } else {
        escaped = false;
      }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) {
      this.unexpected(flagsStart);
    }
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);
    var value2 = null;
    try {
      value2 = new RegExp(pattern, flags);
    } catch (e11) {
    }
    return this.finishToken(types$1.regexp, {
      pattern,
      flags,
      value: value2
    });
  };
  pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
    var start = this.pos, total = 0, lastCode = 0;
    for (var i22 = 0, e11 = len == null ? Infinity : len; i22 < e11; ++i22, ++this.pos) {
      var code2 = this.input.charCodeAt(this.pos), val = void 0;
      if (allowSeparators && code2 === 95) {
        if (isLegacyOctalNumericLiteral) {
          this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
        }
        if (lastCode === 95) {
          this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
        }
        if (i22 === 0) {
          this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
        }
        lastCode = code2;
        continue;
      }
      if (code2 >= 97) {
        val = code2 - 97 + 10;
      } else if (code2 >= 65) {
        val = code2 - 65 + 10;
      } else if (code2 >= 48 && code2 <= 57) {
        val = code2 - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        break;
      }
      lastCode = code2;
      total = total * radix + val;
    }
    if (allowSeparators && lastCode === 95) {
      this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
    }
    if (this.pos === start || len != null && this.pos - start !== len) {
      return null;
    }
    return total;
  };
  function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral) {
      return parseInt(str, 8);
    }
    return parseFloat(str.replace(/_/g, ""));
  }
  function stringToBigInt(str) {
    if (typeof BigInt !== "function") {
      return null;
    }
    return BigInt(str.replace(/_/g, ""));
  }
  pp.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2;
    var val = this.readInt(radix);
    if (val == null) {
      this.raise(this.start + 2, "Expected number in radix " + radix);
    }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
    } else if (isIdentifierStart$1(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val);
  };
  pp.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10, void 0, true) === null) {
      this.raise(start, "Invalid number");
    }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) {
      this.raise(start, "Invalid number");
    }
    var next2 = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next2 === 110) {
      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
      if (isIdentifierStart$1(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types$1.num, val$1);
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
      octal = false;
    }
    if (next2 === 46 && !octal) {
      ++this.pos;
      this.readInt(10);
      next2 = this.input.charCodeAt(this.pos);
    }
    if ((next2 === 69 || next2 === 101) && !octal) {
      next2 = this.input.charCodeAt(++this.pos);
      if (next2 === 43 || next2 === 45) {
        ++this.pos;
      }
      if (this.readInt(10) === null) {
        this.raise(start, "Invalid number");
      }
    }
    if (isIdentifierStart$1(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    var val = stringToNumber(this.input.slice(start, this.pos), octal);
    return this.finishToken(types$1.num, val);
  };
  pp.readCodePoint = function() {
    var ch2 = this.input.charCodeAt(this.pos), code2;
    if (ch2 === 123) {
      if (this.options.ecmaVersion < 6) {
        this.unexpected();
      }
      var codePos = ++this.pos;
      code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code2 > 1114111) {
        this.invalidStringToken(codePos, "Code point out of bounds");
      }
    } else {
      code2 = this.readHexChar(4);
    }
    return code2;
  };
  pp.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length) {
        this.raise(this.start, "Unterminated string constant");
      }
      var ch2 = this.input.charCodeAt(this.pos);
      if (ch2 === quote) {
        break;
      }
      if (ch2 === 92) {
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else if (ch2 === 8232 || ch2 === 8233) {
        if (this.options.ecmaVersion < 10) {
          this.raise(this.start, "Unterminated string constant");
        }
        ++this.pos;
        if (this.options.locations) {
          this.curLine++;
          this.lineStart = this.pos;
        }
      } else {
        if (isNewLine(ch2)) {
          this.raise(this.start, "Unterminated string constant");
        }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types$1.string, out);
  };
  var INVALID_TEMPLATE_ESCAPE_ERROR = {};
  pp.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err2) {
      if (err2 === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err2;
      }
    }
    this.inTemplateElement = false;
  };
  pp.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR;
    } else {
      this.raise(position, message);
    }
  };
  pp.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length) {
        this.raise(this.start, "Unterminated template");
      }
      var ch2 = this.input.charCodeAt(this.pos);
      if (ch2 === 96 || ch2 === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
        if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
          if (ch2 === 36) {
            this.pos += 2;
            return this.finishToken(types$1.dollarBraceL);
          } else {
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types$1.template, out);
      }
      if (ch2 === 92) {
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch2)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch2) {
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch2);
            break;
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };
  pp.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break;
        case "$":
          if (this.input[this.pos + 1] !== "{") {
            break;
          }
        case "`":
          return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
        case "\r":
          if (this.input[this.pos + 1] === "\n") {
            ++this.pos;
          }
        case "\n":
        case "\u2028":
        case "\u2029":
          ++this.curLine;
          this.lineStart = this.pos + 1;
          break;
      }
    }
    this.raise(this.start, "Unterminated template");
  };
  pp.readEscapedChar = function(inTemplate) {
    var ch2 = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch2) {
      case 110:
        return "\n";
      case 114:
        return "\r";
      case 120:
        return String.fromCharCode(this.readHexChar(2));
      case 117:
        return codePointToString(this.readCodePoint());
      case 116:
        return "	";
      case 98:
        return "\b";
      case 118:
        return "\v";
      case 102:
        return "\f";
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) {
          ++this.pos;
        }
      case 10:
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      case 56:
      case 57:
        if (this.strict) {
          this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
        }
        if (inTemplate) {
          var codePos = this.pos - 1;
          this.invalidStringToken(codePos, "Invalid escape sequence in template string");
        }
      default:
        if (ch2 >= 48 && ch2 <= 55) {
          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          this.pos += octalStr.length - 1;
          ch2 = this.input.charCodeAt(this.pos);
          if ((octalStr !== "0" || ch2 === 56 || ch2 === 57) && (this.strict || inTemplate)) {
            this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
          }
          return String.fromCharCode(octal);
        }
        if (isNewLine(ch2)) {
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        }
        return String.fromCharCode(ch2);
    }
  };
  pp.readHexChar = function(len) {
    var codePos = this.pos;
    var n10 = this.readInt(16, len);
    if (n10 === null) {
      this.invalidStringToken(codePos, "Bad character escape sequence");
    }
    return n10;
  };
  pp.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch2 = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch2, astral)) {
        this.pos += ch2 <= 65535 ? 1 : 2;
      } else if (ch2 === 92) {
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) {
          this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
        }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart$1 : isIdentifierChar)(esc, astral)) {
          this.invalidStringToken(escStart, "Invalid Unicode escape");
        }
        word += codePointToString(esc);
        chunkStart = this.pos;
      } else {
        break;
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos);
  };
  pp.readWord = function() {
    var word = this.readWord1();
    var type2 = types$1.name;
    if (this.keywords.test(word)) {
      type2 = keywords$2[word];
    }
    return this.finishToken(type2, word);
  };
  var version = "8.15.0";
  Parser.acorn = {
    Parser,
    version,
    defaultOptions,
    Position,
    SourceLocation,
    getLineInfo,
    Node,
    TokenType,
    tokTypes: types$1,
    keywordTypes: keywords$2,
    TokContext,
    tokContexts: types,
    isIdentifierChar,
    isIdentifierStart: isIdentifierStart$1,
    Token,
    isNewLine,
    lineBreak,
    lineBreakG,
    nonASCIIwhitespace
  };
  function parse3(input, options2) {
    return Parser.parse(input, options2);
  }
  const EOF$1 = 0;
  const Ident = 1;
  const Function$2 = 2;
  const AtKeyword = 3;
  const Hash$1 = 4;
  const String$2 = 5;
  const BadString = 6;
  const Url$1 = 7;
  const BadUrl = 8;
  const Delim = 9;
  const Number$2 = 10;
  const Percentage$1 = 11;
  const Dimension$1 = 12;
  const WhiteSpace$1 = 13;
  const CDO$1 = 14;
  const CDC$1 = 15;
  const Colon = 16;
  const Semicolon = 17;
  const Comma = 18;
  const LeftSquareBracket = 19;
  const RightSquareBracket = 20;
  const LeftParenthesis = 21;
  const RightParenthesis = 22;
  const LeftCurlyBracket = 23;
  const RightCurlyBracket = 24;
  const Comment$1 = 25;
  const EOF = 0;
  function isDigit(code2) {
    return code2 >= 48 && code2 <= 57;
  }
  function isHexDigit(code2) {
    return isDigit(code2) || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102;
  }
  function isUppercaseLetter(code2) {
    return code2 >= 65 && code2 <= 90;
  }
  function isLowercaseLetter(code2) {
    return code2 >= 97 && code2 <= 122;
  }
  function isLetter(code2) {
    return isUppercaseLetter(code2) || isLowercaseLetter(code2);
  }
  function isNonAscii(code2) {
    return code2 >= 128;
  }
  function isNameStart(code2) {
    return isLetter(code2) || isNonAscii(code2) || code2 === 95;
  }
  function isName(code2) {
    return isNameStart(code2) || isDigit(code2) || code2 === 45;
  }
  function isNonPrintable(code2) {
    return code2 >= 0 && code2 <= 8 || code2 === 11 || code2 >= 14 && code2 <= 31 || code2 === 127;
  }
  function isNewline(code2) {
    return code2 === 10 || code2 === 13 || code2 === 12;
  }
  function isWhiteSpace(code2) {
    return isNewline(code2) || code2 === 32 || code2 === 9;
  }
  function isValidEscape(first, second) {
    if (first !== 92) {
      return false;
    }
    if (isNewline(second) || second === EOF) {
      return false;
    }
    return true;
  }
  function isIdentifierStart(first, second, third) {
    if (first === 45) {
      return isNameStart(second) || second === 45 || isValidEscape(second, third);
    }
    if (isNameStart(first)) {
      return true;
    }
    if (first === 92) {
      return isValidEscape(first, second);
    }
    return false;
  }
  function isNumberStart(first, second, third) {
    if (first === 43 || first === 45) {
      if (isDigit(second)) {
        return 2;
      }
      return second === 46 && isDigit(third) ? 3 : 0;
    }
    if (first === 46) {
      return isDigit(second) ? 2 : 0;
    }
    if (isDigit(first)) {
      return 1;
    }
    return 0;
  }
  function isBOM(code2) {
    if (code2 === 65279) {
      return 1;
    }
    if (code2 === 65534) {
      return 1;
    }
    return 0;
  }
  const CATEGORY = new Array(128);
  const EofCategory = 128;
  const WhiteSpaceCategory = 130;
  const DigitCategory = 131;
  const NameStartCategory = 132;
  const NonPrintableCategory = 133;
  for (let i22 = 0; i22 < CATEGORY.length; i22++) {
    CATEGORY[i22] = isWhiteSpace(i22) && WhiteSpaceCategory || isDigit(i22) && DigitCategory || isNameStart(i22) && NameStartCategory || isNonPrintable(i22) && NonPrintableCategory || i22 || EofCategory;
  }
  function charCodeCategory(code2) {
    return code2 < 128 ? CATEGORY[code2] : NameStartCategory;
  }
  function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
  }
  function getNewlineLength(source, offset, code2) {
    if (code2 === 13 && getCharCode(source, offset + 1) === 10) {
      return 2;
    }
    return 1;
  }
  function cmpChar(testStr, offset, referenceCode) {
    let code2 = testStr.charCodeAt(offset);
    if (isUppercaseLetter(code2)) {
      code2 = code2 | 32;
    }
    return code2 === referenceCode;
  }
  function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
      return false;
    }
    if (start < 0 || end > testStr.length) {
      return false;
    }
    for (let i22 = start; i22 < end; i22++) {
      const referenceCode = referenceStr.charCodeAt(i22 - start);
      let testCode = testStr.charCodeAt(i22);
      if (isUppercaseLetter(testCode)) {
        testCode = testCode | 32;
      }
      if (testCode !== referenceCode) {
        return false;
      }
    }
    return true;
  }
  function findWhiteSpaceStart(source, offset) {
    for (; offset >= 0; offset--) {
      if (!isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset + 1;
  }
  function findWhiteSpaceEnd(source, offset) {
    for (; offset < source.length; offset++) {
      if (!isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset;
  }
  function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
      if (!isDigit(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset;
  }
  function consumeEscaped(source, offset) {
    offset += 2;
    if (isHexDigit(getCharCode(source, offset - 1))) {
      for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
        if (!isHexDigit(getCharCode(source, offset))) {
          break;
        }
      }
      const code2 = getCharCode(source, offset);
      if (isWhiteSpace(code2)) {
        offset += getNewlineLength(source, offset, code2);
      }
    }
    return offset;
  }
  function consumeName(source, offset) {
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      if (isName(code2)) {
        continue;
      }
      if (isValidEscape(code2, getCharCode(source, offset + 1))) {
        offset = consumeEscaped(source, offset) - 1;
        continue;
      }
      break;
    }
    return offset;
  }
  function consumeNumber(source, offset) {
    let code2 = source.charCodeAt(offset);
    if (code2 === 43 || code2 === 45) {
      code2 = source.charCodeAt(offset += 1);
    }
    if (isDigit(code2)) {
      offset = findDecimalNumberEnd(source, offset + 1);
      code2 = source.charCodeAt(offset);
    }
    if (code2 === 46 && isDigit(source.charCodeAt(offset + 1))) {
      offset += 2;
      offset = findDecimalNumberEnd(source, offset);
    }
    if (cmpChar(source, offset, 101)) {
      let sign2 = 0;
      code2 = source.charCodeAt(offset + 1);
      if (code2 === 45 || code2 === 43) {
        sign2 = 1;
        code2 = source.charCodeAt(offset + 2);
      }
      if (isDigit(code2)) {
        offset = findDecimalNumberEnd(source, offset + 1 + sign2 + 1);
      }
    }
    return offset;
  }
  function consumeBadUrlRemnants(source, offset) {
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      if (code2 === 41) {
        offset++;
        break;
      }
      if (isValidEscape(code2, getCharCode(source, offset + 1))) {
        offset = consumeEscaped(source, offset);
      }
    }
    return offset;
  }
  function decodeEscaped(escaped) {
    if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {
      return escaped[0];
    }
    let code2 = parseInt(escaped, 16);
    if (code2 === 0 || code2 >= 55296 && code2 <= 57343 || code2 > 1114111) {
      code2 = 65533;
    }
    return String.fromCodePoint(code2);
  }
  const tokenNames = [
    "EOF-token",
    "ident-token",
    "function-token",
    "at-keyword-token",
    "hash-token",
    "string-token",
    "bad-string-token",
    "url-token",
    "bad-url-token",
    "delim-token",
    "number-token",
    "percentage-token",
    "dimension-token",
    "whitespace-token",
    "CDO-token",
    "CDC-token",
    "colon-token",
    "semicolon-token",
    "comma-token",
    "[-token",
    "]-token",
    "(-token",
    ")-token",
    "{-token",
    "}-token",
    "comment-token"
  ];
  const MIN_SIZE = 16 * 1024;
  function adoptBuffer(buffer2 = null, size) {
    if (buffer2 === null || buffer2.length < size) {
      return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
    }
    return buffer2;
  }
  const N$4 = 10;
  const F$2 = 12;
  const R$2 = 13;
  function computeLinesAndColumns(host) {
    const source = host.source;
    const sourceLength = source.length;
    const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
    const lines = adoptBuffer(host.lines, sourceLength);
    const columns = adoptBuffer(host.columns, sourceLength);
    let line = host.startLine;
    let column = host.startColumn;
    for (let i22 = startOffset; i22 < sourceLength; i22++) {
      const code2 = source.charCodeAt(i22);
      lines[i22] = line;
      columns[i22] = column++;
      if (code2 === N$4 || code2 === R$2 || code2 === F$2) {
        if (code2 === R$2 && i22 + 1 < sourceLength && source.charCodeAt(i22 + 1) === N$4) {
          i22++;
          lines[i22] = line;
          columns[i22] = column;
        }
        line++;
        column = 1;
      }
    }
    lines[sourceLength] = line;
    columns[sourceLength] = column;
    host.lines = lines;
    host.columns = columns;
    host.computed = true;
  }
  class OffsetToLocation {
    constructor(source, startOffset, startLine, startColumn) {
      this.setSource(source, startOffset, startLine, startColumn);
      this.lines = null;
      this.columns = null;
    }
    setSource(source = "", startOffset = 0, startLine = 1, startColumn = 1) {
      this.source = source;
      this.startOffset = startOffset;
      this.startLine = startLine;
      this.startColumn = startColumn;
      this.computed = false;
    }
    getLocation(offset, filename2) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }
      return {
        source: filename2,
        offset: this.startOffset + offset,
        line: this.lines[offset],
        column: this.columns[offset]
      };
    }
    getLocationRange(start, end, filename2) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }
      return {
        source: filename2,
        start: {
          offset: this.startOffset + start,
          line: this.lines[start],
          column: this.columns[start]
        },
        end: {
          offset: this.startOffset + end,
          line: this.lines[end],
          column: this.columns[end]
        }
      };
    }
  }
  const OFFSET_MASK = 16777215;
  const TYPE_SHIFT = 24;
  const balancePair$1 = new Uint8Array(32);
  balancePair$1[Function$2] = RightParenthesis;
  balancePair$1[LeftParenthesis] = RightParenthesis;
  balancePair$1[LeftSquareBracket] = RightSquareBracket;
  balancePair$1[LeftCurlyBracket] = RightCurlyBracket;
  function isBlockOpenerToken(tokenType2) {
    return balancePair$1[tokenType2] !== 0;
  }
  class TokenStream {
    constructor(source, tokenize22) {
      this.setSource(source, tokenize22);
    }
    reset() {
      this.eof = false;
      this.tokenIndex = -1;
      this.tokenType = 0;
      this.tokenStart = this.firstCharOffset;
      this.tokenEnd = this.firstCharOffset;
    }
    setSource(source = "", tokenize22 = () => {
    }) {
      source = String(source || "");
      const sourceLength = source.length;
      const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1);
      const balance = adoptBuffer(this.balance, source.length + 1);
      let tokenCount = 0;
      let firstCharOffset = -1;
      let balanceCloseType = 0;
      let balanceStart = source.length;
      this.offsetAndType = null;
      this.balance = null;
      balance.fill(0);
      tokenize22(source, (type2, start, end) => {
        const index2 = tokenCount++;
        offsetAndType[index2] = type2 << TYPE_SHIFT | end;
        if (firstCharOffset === -1) {
          firstCharOffset = start;
        }
        balance[index2] = balanceStart;
        if (type2 === balanceCloseType) {
          const prevBalanceStart = balance[balanceStart];
          balance[balanceStart] = index2;
          balanceStart = prevBalanceStart;
          balanceCloseType = balancePair$1[offsetAndType[prevBalanceStart] >> TYPE_SHIFT];
        } else if (isBlockOpenerToken(type2)) {
          balanceStart = index2;
          balanceCloseType = balancePair$1[type2];
        }
      });
      offsetAndType[tokenCount] = EOF$1 << TYPE_SHIFT | sourceLength;
      balance[tokenCount] = tokenCount;
      for (let i22 = 0; i22 < tokenCount; i22++) {
        const balanceStart2 = balance[i22];
        if (balanceStart2 <= i22) {
          const balanceEnd = balance[balanceStart2];
          if (balanceEnd !== i22) {
            balance[i22] = balanceEnd;
          }
        } else if (balanceStart2 > tokenCount) {
          balance[i22] = tokenCount;
        }
      }
      this.source = source;
      this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
      this.tokenCount = tokenCount;
      this.offsetAndType = offsetAndType;
      this.balance = balance;
      this.reset();
      this.next();
    }
    lookupType(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return this.offsetAndType[offset] >> TYPE_SHIFT;
      }
      return EOF$1;
    }
    lookupTypeNonSC(idx) {
      for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {
        const tokenType2 = this.offsetAndType[offset] >> TYPE_SHIFT;
        if (tokenType2 !== WhiteSpace$1 && tokenType2 !== Comment$1) {
          if (idx-- === 0) {
            return tokenType2;
          }
        }
      }
      return EOF$1;
    }
    lookupOffset(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return this.offsetAndType[offset - 1] & OFFSET_MASK;
      }
      return this.source.length;
    }
    lookupOffsetNonSC(idx) {
      for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {
        const tokenType2 = this.offsetAndType[offset] >> TYPE_SHIFT;
        if (tokenType2 !== WhiteSpace$1 && tokenType2 !== Comment$1) {
          if (idx-- === 0) {
            return offset - this.tokenIndex;
          }
        }
      }
      return EOF$1;
    }
    lookupValue(offset, referenceStr) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);
      }
      return false;
    }
    getTokenStart(tokenIndex) {
      if (tokenIndex === this.tokenIndex) {
        return this.tokenStart;
      }
      if (tokenIndex > 0) {
        return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
      }
      return this.firstCharOffset;
    }
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    }
    isBalanceEdge(pos) {
      return this.balance[this.tokenIndex] < pos;
    }
    isDelim(code2, offset) {
      if (offset) {
        return this.lookupType(offset) === Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code2;
      }
      return this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === code2;
    }
    skip(tokenCount) {
      let next2 = this.tokenIndex + tokenCount;
      if (next2 < this.tokenCount) {
        this.tokenIndex = next2;
        this.tokenStart = this.offsetAndType[next2 - 1] & OFFSET_MASK;
        next2 = this.offsetAndType[next2];
        this.tokenType = next2 >> TYPE_SHIFT;
        this.tokenEnd = next2 & OFFSET_MASK;
      } else {
        this.tokenIndex = this.tokenCount;
        this.next();
      }
    }
    next() {
      let next2 = this.tokenIndex + 1;
      if (next2 < this.tokenCount) {
        this.tokenIndex = next2;
        this.tokenStart = this.tokenEnd;
        next2 = this.offsetAndType[next2];
        this.tokenType = next2 >> TYPE_SHIFT;
        this.tokenEnd = next2 & OFFSET_MASK;
      } else {
        this.eof = true;
        this.tokenIndex = this.tokenCount;
        this.tokenType = EOF$1;
        this.tokenStart = this.tokenEnd = this.source.length;
      }
    }
    skipSC() {
      while (this.tokenType === WhiteSpace$1 || this.tokenType === Comment$1) {
        this.next();
      }
    }
    skipUntilBalanced(startToken, stopConsume) {
      let cursor = startToken;
      let balanceEnd = 0;
      let offset = 0;
      loop:
        for (; cursor < this.tokenCount; cursor++) {
          balanceEnd = this.balance[cursor];
          if (balanceEnd < startToken) {
            break loop;
          }
          offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
          switch (stopConsume(this.source.charCodeAt(offset))) {
            case 1:
              break loop;
            case 2:
              cursor++;
              break loop;
            default:
              if (isBlockOpenerToken(this.offsetAndType[cursor] >> TYPE_SHIFT)) {
                cursor = balanceEnd;
              }
          }
        }
      this.skip(cursor - this.tokenIndex);
    }
    forEachToken(fn22) {
      for (let i22 = 0, offset = this.firstCharOffset; i22 < this.tokenCount; i22++) {
        const start = offset;
        const item = this.offsetAndType[i22];
        const end = item & OFFSET_MASK;
        const type2 = item >> TYPE_SHIFT;
        offset = end;
        fn22(type2, start, end, i22);
      }
    }
    dump() {
      const tokens = new Array(this.tokenCount);
      this.forEachToken((type2, start, end, index2) => {
        tokens[index2] = {
          idx: index2,
          type: tokenNames[type2],
          chunk: this.source.substring(start, end),
          balance: this.balance[index2]
        };
      });
      return tokens;
    }
  }
  function tokenize$1(source, onToken) {
    function getCharCode2(offset2) {
      return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
    }
    function consumeNumericToken() {
      offset = consumeNumber(source, offset);
      if (isIdentifierStart(getCharCode2(offset), getCharCode2(offset + 1), getCharCode2(offset + 2))) {
        type2 = Dimension$1;
        offset = consumeName(source, offset);
        return;
      }
      if (getCharCode2(offset) === 37) {
        type2 = Percentage$1;
        offset++;
        return;
      }
      type2 = Number$2;
    }
    function consumeIdentLikeToken() {
      const nameStartOffset = offset;
      offset = consumeName(source, offset);
      if (cmpStr(source, nameStartOffset, offset, "url") && getCharCode2(offset) === 40) {
        offset = findWhiteSpaceEnd(source, offset + 1);
        if (getCharCode2(offset) === 34 || getCharCode2(offset) === 39) {
          type2 = Function$2;
          offset = nameStartOffset + 4;
          return;
        }
        consumeUrlToken();
        return;
      }
      if (getCharCode2(offset) === 40) {
        type2 = Function$2;
        offset++;
        return;
      }
      type2 = Ident;
    }
    function consumeStringToken(endingCodePoint) {
      if (!endingCodePoint) {
        endingCodePoint = getCharCode2(offset++);
      }
      type2 = String$2;
      for (; offset < source.length; offset++) {
        const code2 = source.charCodeAt(offset);
        switch (charCodeCategory(code2)) {
          case endingCodePoint:
            offset++;
            return;
          case WhiteSpaceCategory:
            if (isNewline(code2)) {
              offset += getNewlineLength(source, offset, code2);
              type2 = BadString;
              return;
            }
            break;
          case 92:
            if (offset === source.length - 1) {
              break;
            }
            const nextCode = getCharCode2(offset + 1);
            if (isNewline(nextCode)) {
              offset += getNewlineLength(source, offset + 1, nextCode);
            } else if (isValidEscape(code2, nextCode)) {
              offset = consumeEscaped(source, offset) - 1;
            }
            break;
        }
      }
    }
    function consumeUrlToken() {
      type2 = Url$1;
      offset = findWhiteSpaceEnd(source, offset);
      for (; offset < source.length; offset++) {
        const code2 = source.charCodeAt(offset);
        switch (charCodeCategory(code2)) {
          case 41:
            offset++;
            return;
          case WhiteSpaceCategory:
            offset = findWhiteSpaceEnd(source, offset);
            if (getCharCode2(offset) === 41 || offset >= source.length) {
              if (offset < source.length) {
                offset++;
              }
              return;
            }
            offset = consumeBadUrlRemnants(source, offset);
            type2 = BadUrl;
            return;
          case 34:
          case 39:
          case 40:
          case NonPrintableCategory:
            offset = consumeBadUrlRemnants(source, offset);
            type2 = BadUrl;
            return;
          case 92:
            if (isValidEscape(code2, getCharCode2(offset + 1))) {
              offset = consumeEscaped(source, offset) - 1;
              break;
            }
            offset = consumeBadUrlRemnants(source, offset);
            type2 = BadUrl;
            return;
        }
      }
    }
    source = String(source || "");
    const sourceLength = source.length;
    let start = isBOM(getCharCode2(0));
    let offset = start;
    let type2;
    while (offset < sourceLength) {
      const code2 = source.charCodeAt(offset);
      switch (charCodeCategory(code2)) {
        case WhiteSpaceCategory:
          type2 = WhiteSpace$1;
          offset = findWhiteSpaceEnd(source, offset + 1);
          break;
        case 34:
          consumeStringToken();
          break;
        case 35:
          if (isName(getCharCode2(offset + 1)) || isValidEscape(getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            type2 = Hash$1;
            offset = consumeName(source, offset + 1);
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 39:
          consumeStringToken();
          break;
        case 40:
          type2 = LeftParenthesis;
          offset++;
          break;
        case 41:
          type2 = RightParenthesis;
          offset++;
          break;
        case 43:
          if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            consumeNumericToken();
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 44:
          type2 = Comma;
          offset++;
          break;
        case 45:
          if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            consumeNumericToken();
          } else {
            if (getCharCode2(offset + 1) === 45 && getCharCode2(offset + 2) === 62) {
              type2 = CDC$1;
              offset = offset + 3;
            } else {
              if (isIdentifierStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
                consumeIdentLikeToken();
              } else {
                type2 = Delim;
                offset++;
              }
            }
          }
          break;
        case 46:
          if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            consumeNumericToken();
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 47:
          if (getCharCode2(offset + 1) === 42) {
            type2 = Comment$1;
            offset = source.indexOf("*/", offset + 2);
            offset = offset === -1 ? source.length : offset + 2;
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 58:
          type2 = Colon;
          offset++;
          break;
        case 59:
          type2 = Semicolon;
          offset++;
          break;
        case 60:
          if (getCharCode2(offset + 1) === 33 && getCharCode2(offset + 2) === 45 && getCharCode2(offset + 3) === 45) {
            type2 = CDO$1;
            offset = offset + 4;
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 64:
          if (isIdentifierStart(getCharCode2(offset + 1), getCharCode2(offset + 2), getCharCode2(offset + 3))) {
            type2 = AtKeyword;
            offset = consumeName(source, offset + 1);
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 91:
          type2 = LeftSquareBracket;
          offset++;
          break;
        case 92:
          if (isValidEscape(code2, getCharCode2(offset + 1))) {
            consumeIdentLikeToken();
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 93:
          type2 = RightSquareBracket;
          offset++;
          break;
        case 123:
          type2 = LeftCurlyBracket;
          offset++;
          break;
        case 125:
          type2 = RightCurlyBracket;
          offset++;
          break;
        case DigitCategory:
          consumeNumericToken();
          break;
        case NameStartCategory:
          consumeIdentLikeToken();
          break;
        default:
          type2 = Delim;
          offset++;
      }
      onToken(type2, start, start = offset);
    }
  }
  let releasedCursors = null;
  class List {
    static createItem(data2) {
      return {
        prev: null,
        next: null,
        data: data2
      };
    }
    constructor() {
      this.head = null;
      this.tail = null;
      this.cursor = null;
    }
    createItem(data2) {
      return List.createItem(data2);
    }
    allocateCursor(prev, next2) {
      let cursor;
      if (releasedCursors !== null) {
        cursor = releasedCursors;
        releasedCursors = releasedCursors.cursor;
        cursor.prev = prev;
        cursor.next = next2;
        cursor.cursor = this.cursor;
      } else {
        cursor = {
          prev,
          next: next2,
          cursor: this.cursor
        };
      }
      this.cursor = cursor;
      return cursor;
    }
    releaseCursor() {
      const { cursor } = this;
      this.cursor = cursor.cursor;
      cursor.prev = null;
      cursor.next = null;
      cursor.cursor = releasedCursors;
      releasedCursors = cursor;
    }
    updateCursors(prevOld, prevNew, nextOld, nextNew) {
      let { cursor } = this;
      while (cursor !== null) {
        if (cursor.prev === prevOld) {
          cursor.prev = prevNew;
        }
        if (cursor.next === nextOld) {
          cursor.next = nextNew;
        }
        cursor = cursor.cursor;
      }
    }
    *[Symbol.iterator]() {
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        yield cursor.data;
      }
    }
    get size() {
      let size = 0;
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        size++;
      }
      return size;
    }
    get isEmpty() {
      return this.head === null;
    }
    get first() {
      return this.head && this.head.data;
    }
    get last() {
      return this.tail && this.tail.data;
    }
    fromArray(array) {
      let cursor = null;
      this.head = null;
      for (let data2 of array) {
        const item = List.createItem(data2);
        if (cursor !== null) {
          cursor.next = item;
        } else {
          this.head = item;
        }
        item.prev = cursor;
        cursor = item;
      }
      this.tail = cursor;
      return this;
    }
    toArray() {
      return [
        ...this
      ];
    }
    toJSON() {
      return [
        ...this
      ];
    }
    forEach(fn22, thisArg = this) {
      const cursor = this.allocateCursor(null, this.head);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        fn22.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    forEachRight(fn22, thisArg = this) {
      const cursor = this.allocateCursor(this.tail, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        fn22.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    reduce(fn22, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(null, this.head);
      let acc = initialValue;
      let item;
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        acc = fn22.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    reduceRight(fn22, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(this.tail, null);
      let acc = initialValue;
      let item;
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        acc = fn22.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    some(fn22, thisArg = this) {
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        if (fn22.call(thisArg, cursor.data, cursor, this)) {
          return true;
        }
      }
      return false;
    }
    map(fn22, thisArg = this) {
      const result = new List();
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        result.appendData(fn22.call(thisArg, cursor.data, cursor, this));
      }
      return result;
    }
    filter(fn22, thisArg = this) {
      const result = new List();
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        if (fn22.call(thisArg, cursor.data, cursor, this)) {
          result.appendData(cursor.data);
        }
      }
      return result;
    }
    nextUntil(start, fn22, thisArg = this) {
      if (start === null) {
        return;
      }
      const cursor = this.allocateCursor(null, start);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        if (fn22.call(thisArg, item.data, item, this)) {
          break;
        }
      }
      this.releaseCursor();
    }
    prevUntil(start, fn22, thisArg = this) {
      if (start === null) {
        return;
      }
      const cursor = this.allocateCursor(start, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        if (fn22.call(thisArg, item.data, item, this)) {
          break;
        }
      }
      this.releaseCursor();
    }
    clear() {
      this.head = null;
      this.tail = null;
    }
    copy() {
      const result = new List();
      for (let data2 of this) {
        result.appendData(data2);
      }
      return result;
    }
    prepend(item) {
      this.updateCursors(null, item, this.head, item);
      if (this.head !== null) {
        this.head.prev = item;
        item.next = this.head;
      } else {
        this.tail = item;
      }
      this.head = item;
      return this;
    }
    prependData(data2) {
      return this.prepend(List.createItem(data2));
    }
    append(item) {
      return this.insert(item);
    }
    appendData(data2) {
      return this.insert(List.createItem(data2));
    }
    insert(item, before = null) {
      if (before !== null) {
        this.updateCursors(before.prev, item, before, item);
        if (before.prev === null) {
          if (this.head !== before) {
            throw new Error("before doesn't belong to list");
          }
          this.head = item;
          before.prev = item;
          item.next = before;
          this.updateCursors(null, item);
        } else {
          before.prev.next = item;
          item.prev = before.prev;
          before.prev = item;
          item.next = before;
        }
      } else {
        this.updateCursors(this.tail, item, null, item);
        if (this.tail !== null) {
          this.tail.next = item;
          item.prev = this.tail;
        } else {
          this.head = item;
        }
        this.tail = item;
      }
      return this;
    }
    insertData(data2, before) {
      return this.insert(List.createItem(data2), before);
    }
    remove(item) {
      this.updateCursors(item, item.prev, item, item.next);
      if (item.prev !== null) {
        item.prev.next = item.next;
      } else {
        if (this.head !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.head = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      } else {
        if (this.tail !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.tail = item.prev;
      }
      item.prev = null;
      item.next = null;
      return item;
    }
    push(data2) {
      this.insert(List.createItem(data2));
    }
    pop() {
      return this.tail !== null ? this.remove(this.tail) : null;
    }
    unshift(data2) {
      this.prepend(List.createItem(data2));
    }
    shift() {
      return this.head !== null ? this.remove(this.head) : null;
    }
    prependList(list2) {
      return this.insertList(list2, this.head);
    }
    appendList(list2) {
      return this.insertList(list2);
    }
    insertList(list2, before) {
      if (list2.head === null) {
        return this;
      }
      if (before !== void 0 && before !== null) {
        this.updateCursors(before.prev, list2.tail, before, list2.head);
        if (before.prev !== null) {
          before.prev.next = list2.head;
          list2.head.prev = before.prev;
        } else {
          this.head = list2.head;
        }
        before.prev = list2.tail;
        list2.tail.next = before;
      } else {
        this.updateCursors(this.tail, list2.tail, null, list2.head);
        if (this.tail !== null) {
          this.tail.next = list2.head;
          list2.head.prev = this.tail;
        } else {
          this.head = list2.head;
        }
        this.tail = list2.tail;
      }
      list2.head = null;
      list2.tail = null;
      return this;
    }
    replace(oldItem, newItemOrList) {
      if ("head" in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
      } else {
        this.insert(newItemOrList, oldItem);
      }
      this.remove(oldItem);
    }
  }
  function createCustomError(name2, message) {
    const error = Object.create(SyntaxError.prototype);
    const errorStack = new Error();
    return Object.assign(error, {
      name: name2,
      message,
      get stack() {
        return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name2}: ${message}
`);
      }
    });
  }
  const MAX_LINE_LENGTH = 100;
  const OFFSET_CORRECTION = 60;
  const TAB_REPLACEMENT = "    ";
  function sourceFragment({ source, line, column, baseLine, baseColumn }, extraLines) {
    function processLines(start, end) {
      return lines.slice(start, end).map((line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2).join("\n");
    }
    const prelines = "\n".repeat(Math.max(baseLine - 1, 0));
    const precolumns = " ".repeat(Math.max(baseColumn - 1, 0));
    const lines = (prelines + precolumns + source).split(/\r\n?|\n|\f/);
    const startLine = Math.max(1, line - extraLines) - 1;
    const endLine = Math.min(line + extraLines, lines.length + 1);
    const maxNumLength = Math.max(4, String(endLine).length) + 1;
    let cutLeft = 0;
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
    if (column > MAX_LINE_LENGTH) {
      cutLeft = column - OFFSET_CORRECTION + 3;
      column = OFFSET_CORRECTION - 2;
    }
    for (let i22 = startLine; i22 <= endLine; i22++) {
      if (i22 >= 0 && i22 < lines.length) {
        lines[i22] = lines[i22].replace(/\t/g, TAB_REPLACEMENT);
        lines[i22] = (cutLeft > 0 && lines[i22].length > cutLeft ? "\u2026" : "") + lines[i22].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i22].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
      }
    }
    return [
      processLines(startLine, line),
      new Array(column + maxNumLength + 2).join("-") + "^",
      processLines(line, endLine)
    ].filter(Boolean).join("\n").replace(/^(\s+\d+\s+\|\n)+/, "").replace(/\n(\s+\d+\s+\|)+$/, "");
  }
  function SyntaxError$2(message, source, offset, line, column, baseLine = 1, baseColumn = 1) {
    const error = Object.assign(createCustomError("SyntaxError", message), {
      source,
      offset,
      line,
      column,
      sourceFragment(extraLines) {
        return sourceFragment({
          source,
          line,
          column,
          baseLine,
          baseColumn
        }, isNaN(extraLines) ? 0 : extraLines);
      },
      get formattedMessage() {
        return `Parse error: ${message}
` + sourceFragment({
          source,
          line,
          column,
          baseLine,
          baseColumn
        }, 2);
      }
    });
    return error;
  }
  function readSequence(recognizer) {
    const children = this.createList();
    let space = false;
    const context2 = {
      recognizer
    };
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment$1:
          this.next();
          continue;
        case WhiteSpace$1:
          space = true;
          this.next();
          continue;
      }
      let child = recognizer.getNode.call(this, context2);
      if (child === void 0) {
        break;
      }
      if (space) {
        if (recognizer.onWhiteSpace) {
          recognizer.onWhiteSpace.call(this, child, children, context2);
        }
        space = false;
      }
      children.push(child);
    }
    if (space && recognizer.onWhiteSpace) {
      recognizer.onWhiteSpace.call(this, null, children, context2);
    }
    return children;
  }
  const NOOP = () => {
  };
  const EXCLAMATIONMARK$3 = 33;
  const NUMBERSIGN$4 = 35;
  const SEMICOLON = 59;
  const LEFTCURLYBRACKET$1 = 123;
  const NULL = 0;
  function createParseContext(name2) {
    return function() {
      return this[name2]();
    };
  }
  function fetchParseValues(dict) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const name2 of Object.keys(dict)) {
      const item = dict[name2];
      const fn22 = item.parse || item;
      if (fn22) {
        result[name2] = fn22;
      }
    }
    return result;
  }
  function processConfig(config) {
    const parseConfig = {
      context: /* @__PURE__ */ Object.create(null),
      features: Object.assign(/* @__PURE__ */ Object.create(null), config.features),
      scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
      atrule: fetchParseValues(config.atrule),
      pseudo: fetchParseValues(config.pseudo),
      node: fetchParseValues(config.node)
    };
    for (const [name2, context2] of Object.entries(config.parseContext)) {
      switch (typeof context2) {
        case "function":
          parseConfig.context[name2] = context2;
          break;
        case "string":
          parseConfig.context[name2] = createParseContext(context2);
          break;
      }
    }
    return {
      config: parseConfig,
      ...parseConfig,
      ...parseConfig.node
    };
  }
  function createParser(config) {
    let source = "";
    let filename2 = "<unknown>";
    let needPositions = false;
    let onParseError = NOOP;
    let onParseErrorThrow = false;
    const locationMap = new OffsetToLocation();
    const parser = Object.assign(new TokenStream(), processConfig(config || {}), {
      parseAtrulePrelude: true,
      parseRulePrelude: true,
      parseValue: true,
      parseCustomProperty: false,
      readSequence,
      consumeUntilBalanceEnd: () => 0,
      consumeUntilLeftCurlyBracket(code2) {
        return code2 === LEFTCURLYBRACKET$1 ? 1 : 0;
      },
      consumeUntilLeftCurlyBracketOrSemicolon(code2) {
        return code2 === LEFTCURLYBRACKET$1 || code2 === SEMICOLON ? 1 : 0;
      },
      consumeUntilExclamationMarkOrSemicolon(code2) {
        return code2 === EXCLAMATIONMARK$3 || code2 === SEMICOLON ? 1 : 0;
      },
      consumeUntilSemicolonIncluded(code2) {
        return code2 === SEMICOLON ? 2 : 0;
      },
      createList() {
        return new List();
      },
      createSingleNodeList(node2) {
        return new List().appendData(node2);
      },
      getFirstListNode(list2) {
        return list2 && list2.first;
      },
      getLastListNode(list2) {
        return list2 && list2.last;
      },
      parseWithFallback(consumer, fallback) {
        const startIndex = this.tokenIndex;
        try {
          return consumer.call(this);
        } catch (e11) {
          if (onParseErrorThrow) {
            throw e11;
          }
          this.skip(startIndex - this.tokenIndex);
          const fallbackNode = fallback.call(this);
          onParseErrorThrow = true;
          onParseError(e11, fallbackNode);
          onParseErrorThrow = false;
          return fallbackNode;
        }
      },
      lookupNonWSType(offset) {
        let type2;
        do {
          type2 = this.lookupType(offset++);
          if (type2 !== WhiteSpace$1 && type2 !== Comment$1) {
            return type2;
          }
        } while (type2 !== NULL);
        return NULL;
      },
      charCodeAt(offset) {
        return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
      },
      substring(offsetStart, offsetEnd) {
        return source.substring(offsetStart, offsetEnd);
      },
      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      },
      cmpChar(offset, charCode) {
        return cmpChar(source, offset, charCode);
      },
      cmpStr(offsetStart, offsetEnd, str) {
        return cmpStr(source, offsetStart, offsetEnd, str);
      },
      consume(tokenType2) {
        const start = this.tokenStart;
        this.eat(tokenType2);
        return this.substrToCursor(start);
      },
      consumeFunctionName() {
        const name2 = source.substring(this.tokenStart, this.tokenEnd - 1);
        this.eat(Function$2);
        return name2;
      },
      consumeNumber(type2) {
        const number2 = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));
        this.eat(type2);
        return number2;
      },
      eat(tokenType2) {
        if (this.tokenType !== tokenType2) {
          const tokenName = tokenNames[tokenType2].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
          let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
          let offset = this.tokenStart;
          switch (tokenType2) {
            case Ident:
              if (this.tokenType === Function$2 || this.tokenType === Url$1) {
                offset = this.tokenEnd - 1;
                message = "Identifier is expected but function found";
              } else {
                message = "Identifier is expected";
              }
              break;
            case Hash$1:
              if (this.isDelim(NUMBERSIGN$4)) {
                this.next();
                offset++;
                message = "Name is expected";
              }
              break;
            case Percentage$1:
              if (this.tokenType === Number$2) {
                offset = this.tokenEnd;
                message = "Percent sign is expected";
              }
              break;
          }
          this.error(message, offset);
        }
        this.next();
      },
      eatIdent(name2) {
        if (this.tokenType !== Ident || this.lookupValue(0, name2) === false) {
          this.error(`Identifier "${name2}" is expected`);
        }
        this.next();
      },
      eatDelim(code2) {
        if (!this.isDelim(code2)) {
          this.error(`Delim "${String.fromCharCode(code2)}" is expected`);
        }
        this.next();
      },
      getLocation(start, end) {
        if (needPositions) {
          return locationMap.getLocationRange(start, end, filename2);
        }
        return null;
      },
      getLocationFromList(list2) {
        if (needPositions) {
          const head = this.getFirstListNode(list2);
          const tail = this.getLastListNode(list2);
          return locationMap.getLocationRange(head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart, tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart, filename2);
        }
        return null;
      },
      error(message, offset) {
        const location2 = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
        throw new SyntaxError$2(message || "Unexpected input", source, location2.offset, location2.line, location2.column, locationMap.startLine, locationMap.startColumn);
      }
    });
    const parse2 = function(source_, options2) {
      source = source_;
      options2 = options2 || {};
      parser.setSource(source, tokenize$1);
      locationMap.setSource(source, options2.offset, options2.line, options2.column);
      filename2 = options2.filename || "<unknown>";
      needPositions = Boolean(options2.positions);
      onParseError = typeof options2.onParseError === "function" ? options2.onParseError : NOOP;
      onParseErrorThrow = false;
      parser.parseAtrulePrelude = "parseAtrulePrelude" in options2 ? Boolean(options2.parseAtrulePrelude) : true;
      parser.parseRulePrelude = "parseRulePrelude" in options2 ? Boolean(options2.parseRulePrelude) : true;
      parser.parseValue = "parseValue" in options2 ? Boolean(options2.parseValue) : true;
      parser.parseCustomProperty = "parseCustomProperty" in options2 ? Boolean(options2.parseCustomProperty) : false;
      const { context: context2 = "default", onComment } = options2;
      if (context2 in parser.context === false) {
        throw new Error("Unknown context `" + context2 + "`");
      }
      if (typeof onComment === "function") {
        parser.forEachToken((type2, start, end) => {
          if (type2 === Comment$1) {
            const loc = parser.getLocation(start, end);
            const value2 = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
            onComment(value2, loc);
          }
        });
      }
      const ast = parser.context[context2].call(parser, options2);
      if (!parser.eof) {
        parser.error();
      }
      return ast;
    };
    return Object.assign(parse2, {
      SyntaxError: SyntaxError$2,
      config: parser.config
    });
  }
  var base64Vlq = {};
  var base64$1 = {};
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  base64$1.encode = function(number2) {
    if (0 <= number2 && number2 < intToCharMap.length) {
      return intToCharMap[number2];
    }
    throw new TypeError("Must be between 0 and 63: " + number2);
  };
  base64$1.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero22 = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero22 <= charCode && charCode <= nine) {
      return charCode - zero22 + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
  var base64 = base64$1;
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  base64Vlq.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  var util$3 = {};
  (function(exports$1) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports$1.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match2 = aUrl.match(urlRegexp);
      if (!match2) {
        return null;
      }
      return {
        scheme: match2[1],
        auth: match2[2],
        host: match2[3],
        port: match2[4],
        path: match2[5]
      };
    }
    exports$1.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url2 = "";
      if (aParsedUrl.scheme) {
        url2 += aParsedUrl.scheme + ":";
      }
      url2 += "//";
      if (aParsedUrl.auth) {
        url2 += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url2 += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url2 += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url2 += aParsedUrl.path;
      }
      return url2;
    }
    exports$1.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f10) {
      var cache = [];
      return function(input) {
        for (var i22 = 0; i22 < cache.length; i22++) {
          if (cache[i22].input === input) {
            var temp = cache[0];
            cache[0] = cache[i22];
            cache[i22] = temp;
            return cache[0].result;
          }
        }
        var result = f10(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize2 = lruMemoize(function normalize3(aPath) {
      var path22 = aPath;
      var url2 = urlParse(aPath);
      if (url2) {
        if (!url2.path) {
          return aPath;
        }
        path22 = url2.path;
      }
      var isAbsolute2 = exports$1.isAbsolute(path22);
      var parts = [];
      var start = 0;
      var i22 = 0;
      while (true) {
        start = i22;
        i22 = path22.indexOf("/", start);
        if (i22 === -1) {
          parts.push(path22.slice(start));
          break;
        } else {
          parts.push(path22.slice(start, i22));
          while (i22 < path22.length && path22[i22] === "/") {
            i22++;
          }
        }
      }
      for (var part, up2 = 0, i22 = parts.length - 1; i22 >= 0; i22--) {
        part = parts[i22];
        if (part === ".") {
          parts.splice(i22, 1);
        } else if (part === "..") {
          up2++;
        } else if (up2 > 0) {
          if (part === "") {
            parts.splice(i22 + 1, up2);
            up2 = 0;
          } else {
            parts.splice(i22, 2);
            up2--;
          }
        }
      }
      path22 = parts.join("/");
      if (path22 === "") {
        path22 = isAbsolute2 ? "/" : ".";
      }
      if (url2) {
        url2.path = path22;
        return urlGenerate(url2);
      }
      return path22;
    });
    exports$1.normalize = normalize2;
    function join22(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports$1.join = join22;
    exports$1.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index2 = aRoot.lastIndexOf("/");
        if (index2 < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index2);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports$1.relative = relative2;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s10) {
      return s10;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports$1.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports$1.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s10) {
      if (!s10) {
        return false;
      }
      var length2 = s10.length;
      if (length2 < 9) {
        return false;
      }
      if (s10.charCodeAt(length2 - 1) !== 95 || s10.charCodeAt(length2 - 2) !== 95 || s10.charCodeAt(length2 - 3) !== 111 || s10.charCodeAt(length2 - 4) !== 116 || s10.charCodeAt(length2 - 5) !== 111 || s10.charCodeAt(length2 - 6) !== 114 || s10.charCodeAt(length2 - 7) !== 112 || s10.charCodeAt(length2 - 8) !== 95 || s10.charCodeAt(length2 - 9) !== 95) {
        return false;
      }
      for (var i22 = length2 - 10; i22 >= 0; i22--) {
        if (s10.charCodeAt(i22) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports$1.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index2 = parsed.path.lastIndexOf("/");
          if (index2 >= 0) {
            parsed.path = parsed.path.substring(0, index2 + 1);
          }
        }
        sourceURL = join22(urlGenerate(parsed), sourceURL);
      }
      return normalize2(sourceURL);
    }
    exports$1.computeSourceURL = computeSourceURL;
  })(util$3);
  var arraySet = {};
  var util$2 = util$3;
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet$1() {
    this._array = [];
    this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  ArraySet$1.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet$1();
    for (var i22 = 0, len = aArray.length; i22 < len; i22++) {
      set.add(aArray[i22], aAllowDuplicates);
    }
    return set;
  };
  ArraySet$1.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet$1.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util$2.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet$1.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util$2.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet$1.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util$2.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet$1.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet$1.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  arraySet.ArraySet = ArraySet$1;
  var mappingList = {};
  var util$1 = util$3;
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util$1.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList$1() {
    this._array = [];
    this._sorted = true;
    this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }
  MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList$1.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList$1.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util$1.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  mappingList.MappingList = MappingList$1;
  var base64VLQ = base64Vlq;
  var util = util$3;
  var ArraySet = arraySet.ArraySet;
  var MappingList = mappingList.MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
      file: aSourceMapConsumer.file,
      sourceRoot
    }));
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name2 = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      if (this._validateMapping(generated, original, source, name2) === false) {
        return;
      }
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name2 != null) {
      name2 = String(name2);
      if (!this._names.has(name2)) {
        this._names.add(name2);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name: name2
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = /* @__PURE__ */ Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name2 = mapping.name;
      if (name2 != null && !newNames.has(name2)) {
        newNames.add(name2);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
      if (this._ignoreInvalidMapping) {
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
        return false;
      } else {
        throw new Error(message);
      }
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      var message = "Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      });
      if (this._ignoreInvalidMapping) {
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
        return false;
      } else {
        throw new Error(message);
      }
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next2;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i22 = 0, len = mappings.length; i22 < len; i22++) {
      mapping = mappings[i22];
      next2 = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next2 += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i22 > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i22 - 1])) {
            continue;
          }
          next2 += ",";
        }
      }
      next2 += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next2 += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next2 += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next2 += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next2 += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next2;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  var SourceMapGenerator_1 = SourceMapGenerator;
  const trackNodes = /* @__PURE__ */ new Set([
    "Atrule",
    "Selector",
    "Declaration"
  ]);
  function generateSourceMap(handlers) {
    const map = new SourceMapGenerator_1();
    const generated = {
      line: 1,
      column: 0
    };
    const original = {
      line: 0,
      column: 0
    };
    const activatedGenerated = {
      line: 1,
      column: 0
    };
    const activatedMapping = {
      generated: activatedGenerated
    };
    let line = 1;
    let column = 0;
    let sourceMappingActive = false;
    const origHandlersNode = handlers.node;
    handlers.node = function(node2) {
      if (node2.loc && node2.loc.start && trackNodes.has(node2.type)) {
        const nodeLine = node2.loc.start.line;
        const nodeColumn = node2.loc.start.column - 1;
        if (original.line !== nodeLine || original.column !== nodeColumn) {
          original.line = nodeLine;
          original.column = nodeColumn;
          generated.line = line;
          generated.column = column;
          if (sourceMappingActive) {
            sourceMappingActive = false;
            if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
              map.addMapping(activatedMapping);
            }
          }
          sourceMappingActive = true;
          map.addMapping({
            source: node2.loc.source,
            original,
            generated
          });
        }
      }
      origHandlersNode.call(this, node2);
      if (sourceMappingActive && trackNodes.has(node2.type)) {
        activatedGenerated.line = line;
        activatedGenerated.column = column;
      }
    };
    const origHandlersEmit = handlers.emit;
    handlers.emit = function(value2, type2, auto) {
      for (let i22 = 0; i22 < value2.length; i22++) {
        if (value2.charCodeAt(i22) === 10) {
          line++;
          column = 0;
        } else {
          column++;
        }
      }
      origHandlersEmit(value2, type2, auto);
    };
    const origHandlersResult = handlers.result;
    handlers.result = function() {
      if (sourceMappingActive) {
        map.addMapping(activatedMapping);
      }
      return {
        css: origHandlersResult(),
        map
      };
    };
    return handlers;
  }
  const PLUSSIGN$9 = 43;
  const HYPHENMINUS$6 = 45;
  const code = (type2, value2) => {
    if (type2 === Delim) {
      type2 = value2;
    }
    if (typeof type2 === "string") {
      const charCode = type2.charCodeAt(0);
      return charCode > 127 ? 32768 : charCode << 8;
    }
    return type2;
  };
  const specPairs = [
    [
      Ident,
      Ident
    ],
    [
      Ident,
      Function$2
    ],
    [
      Ident,
      Url$1
    ],
    [
      Ident,
      BadUrl
    ],
    [
      Ident,
      "-"
    ],
    [
      Ident,
      Number$2
    ],
    [
      Ident,
      Percentage$1
    ],
    [
      Ident,
      Dimension$1
    ],
    [
      Ident,
      CDC$1
    ],
    [
      Ident,
      LeftParenthesis
    ],
    [
      AtKeyword,
      Ident
    ],
    [
      AtKeyword,
      Function$2
    ],
    [
      AtKeyword,
      Url$1
    ],
    [
      AtKeyword,
      BadUrl
    ],
    [
      AtKeyword,
      "-"
    ],
    [
      AtKeyword,
      Number$2
    ],
    [
      AtKeyword,
      Percentage$1
    ],
    [
      AtKeyword,
      Dimension$1
    ],
    [
      AtKeyword,
      CDC$1
    ],
    [
      Hash$1,
      Ident
    ],
    [
      Hash$1,
      Function$2
    ],
    [
      Hash$1,
      Url$1
    ],
    [
      Hash$1,
      BadUrl
    ],
    [
      Hash$1,
      "-"
    ],
    [
      Hash$1,
      Number$2
    ],
    [
      Hash$1,
      Percentage$1
    ],
    [
      Hash$1,
      Dimension$1
    ],
    [
      Hash$1,
      CDC$1
    ],
    [
      Dimension$1,
      Ident
    ],
    [
      Dimension$1,
      Function$2
    ],
    [
      Dimension$1,
      Url$1
    ],
    [
      Dimension$1,
      BadUrl
    ],
    [
      Dimension$1,
      "-"
    ],
    [
      Dimension$1,
      Number$2
    ],
    [
      Dimension$1,
      Percentage$1
    ],
    [
      Dimension$1,
      Dimension$1
    ],
    [
      Dimension$1,
      CDC$1
    ],
    [
      "#",
      Ident
    ],
    [
      "#",
      Function$2
    ],
    [
      "#",
      Url$1
    ],
    [
      "#",
      BadUrl
    ],
    [
      "#",
      "-"
    ],
    [
      "#",
      Number$2
    ],
    [
      "#",
      Percentage$1
    ],
    [
      "#",
      Dimension$1
    ],
    [
      "#",
      CDC$1
    ],
    [
      "-",
      Ident
    ],
    [
      "-",
      Function$2
    ],
    [
      "-",
      Url$1
    ],
    [
      "-",
      BadUrl
    ],
    [
      "-",
      "-"
    ],
    [
      "-",
      Number$2
    ],
    [
      "-",
      Percentage$1
    ],
    [
      "-",
      Dimension$1
    ],
    [
      "-",
      CDC$1
    ],
    [
      Number$2,
      Ident
    ],
    [
      Number$2,
      Function$2
    ],
    [
      Number$2,
      Url$1
    ],
    [
      Number$2,
      BadUrl
    ],
    [
      Number$2,
      Number$2
    ],
    [
      Number$2,
      Percentage$1
    ],
    [
      Number$2,
      Dimension$1
    ],
    [
      Number$2,
      "%"
    ],
    [
      Number$2,
      CDC$1
    ],
    [
      "@",
      Ident
    ],
    [
      "@",
      Function$2
    ],
    [
      "@",
      Url$1
    ],
    [
      "@",
      BadUrl
    ],
    [
      "@",
      "-"
    ],
    [
      "@",
      CDC$1
    ],
    [
      ".",
      Number$2
    ],
    [
      ".",
      Percentage$1
    ],
    [
      ".",
      Dimension$1
    ],
    [
      "+",
      Number$2
    ],
    [
      "+",
      Percentage$1
    ],
    [
      "+",
      Dimension$1
    ],
    [
      "/",
      "*"
    ]
  ];
  const safePairs = specPairs.concat([
    [
      Ident,
      Hash$1
    ],
    [
      Dimension$1,
      Hash$1
    ],
    [
      Hash$1,
      Hash$1
    ],
    [
      AtKeyword,
      LeftParenthesis
    ],
    [
      AtKeyword,
      String$2
    ],
    [
      AtKeyword,
      Colon
    ],
    [
      Percentage$1,
      Percentage$1
    ],
    [
      Percentage$1,
      Dimension$1
    ],
    [
      Percentage$1,
      Function$2
    ],
    [
      Percentage$1,
      "-"
    ],
    [
      RightParenthesis,
      Ident
    ],
    [
      RightParenthesis,
      Function$2
    ],
    [
      RightParenthesis,
      Percentage$1
    ],
    [
      RightParenthesis,
      Dimension$1
    ],
    [
      RightParenthesis,
      Hash$1
    ],
    [
      RightParenthesis,
      "-"
    ]
  ]);
  function createMap(pairs) {
    const isWhiteSpaceRequired = new Set(pairs.map(([prev, next2]) => code(prev) << 16 | code(next2)));
    return function(prevCode, type2, value2) {
      const nextCode = code(type2, value2);
      const nextCharCode = value2.charCodeAt(0);
      const emitWs = nextCharCode === HYPHENMINUS$6 && type2 !== Ident && type2 !== Function$2 && type2 !== CDC$1 || nextCharCode === PLUSSIGN$9 ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
      if (emitWs) {
        this.emit(" ", WhiteSpace$1, true);
      }
      return nextCode;
    };
  }
  const spec = createMap(specPairs);
  const safe = createMap(safePairs);
  const tokenBefore = Object.freeze(Object.defineProperty({
    __proto__: null,
    safe,
    spec
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const REVERSESOLIDUS = 92;
  function processChildren(node2, delimeter) {
    if (typeof delimeter === "function") {
      let prev = null;
      node2.children.forEach((node3) => {
        if (prev !== null) {
          delimeter.call(this, prev);
        }
        this.node(node3);
        prev = node3;
      });
      return;
    }
    node2.children.forEach(this.node, this);
  }
  function processChunk(chunk) {
    tokenize$1(chunk, (type2, start, end) => {
      this.token(type2, chunk.slice(start, end));
    });
  }
  function createGenerator(config) {
    const types22 = /* @__PURE__ */ new Map();
    for (let [name2, item] of Object.entries(config.node)) {
      const fn22 = item.generate || item;
      if (typeof fn22 === "function") {
        types22.set(name2, item.generate || item);
      }
    }
    return function(node2, options2) {
      let buffer2 = "";
      let prevCode = 0;
      let handlers = {
        node(node3) {
          if (types22.has(node3.type)) {
            types22.get(node3.type).call(publicApi, node3);
          } else {
            throw new Error("Unknown node type: " + node3.type);
          }
        },
        tokenBefore: safe,
        token(type2, value2) {
          prevCode = this.tokenBefore(prevCode, type2, value2);
          this.emit(value2, type2, false);
          if (type2 === Delim && value2.charCodeAt(0) === REVERSESOLIDUS) {
            this.emit("\n", WhiteSpace$1, true);
          }
        },
        emit(value2) {
          buffer2 += value2;
        },
        result() {
          return buffer2;
        }
      };
      if (options2) {
        if (typeof options2.decorator === "function") {
          handlers = options2.decorator(handlers);
        }
        if (options2.sourceMap) {
          handlers = generateSourceMap(handlers);
        }
        if (options2.mode in tokenBefore) {
          handlers.tokenBefore = tokenBefore[options2.mode];
        }
      }
      const publicApi = {
        node: (node3) => handlers.node(node3),
        children: processChildren,
        token: (type2, value2) => handlers.token(type2, value2),
        tokenize: processChunk
      };
      handlers.node(node2);
      return handlers.result();
    };
  }
  function createConvertor(walk2) {
    return {
      fromPlainObject(ast) {
        walk2(ast, {
          enter(node2) {
            if (node2.children && node2.children instanceof List === false) {
              node2.children = new List().fromArray(node2.children);
            }
          }
        });
        return ast;
      },
      toPlainObject(ast) {
        walk2(ast, {
          leave(node2) {
            if (node2.children && node2.children instanceof List) {
              node2.children = node2.children.toArray();
            }
          }
        });
        return ast;
      }
    };
  }
  const { hasOwnProperty: hasOwnProperty$3 } = Object.prototype;
  const noop$2 = function() {
  };
  function ensureFunction$1(value2) {
    return typeof value2 === "function" ? value2 : noop$2;
  }
  function invokeForType(fn22, type2) {
    return function(node2, item, list2) {
      if (node2.type === type2) {
        fn22.call(this, node2, item, list2);
      }
    };
  }
  function getWalkersFromStructure(name2, nodeType) {
    const structure2 = nodeType.structure;
    const walkers = [];
    for (const key in structure2) {
      if (hasOwnProperty$3.call(structure2, key) === false) {
        continue;
      }
      let fieldTypes = structure2[key];
      const walker = {
        name: key,
        type: false,
        nullable: false
      };
      if (!Array.isArray(fieldTypes)) {
        fieldTypes = [
          fieldTypes
        ];
      }
      for (const fieldType of fieldTypes) {
        if (fieldType === null) {
          walker.nullable = true;
        } else if (typeof fieldType === "string") {
          walker.type = "node";
        } else if (Array.isArray(fieldType)) {
          walker.type = "list";
        }
      }
      if (walker.type) {
        walkers.push(walker);
      }
    }
    if (walkers.length) {
      return {
        context: nodeType.walkContext,
        fields: walkers
      };
    }
    return null;
  }
  function getTypesFromConfig(config) {
    const types22 = {};
    for (const name2 in config.node) {
      if (hasOwnProperty$3.call(config.node, name2)) {
        const nodeType = config.node[name2];
        if (!nodeType.structure) {
          throw new Error("Missed `structure` field in `" + name2 + "` node type definition");
        }
        types22[name2] = getWalkersFromStructure(name2, nodeType);
      }
    }
    return types22;
  }
  function createTypeIterator(config, reverse2) {
    const fields = config.fields.slice();
    const contextName = config.context;
    const useContext = typeof contextName === "string";
    if (reverse2) {
      fields.reverse();
    }
    return function(node2, context2, walk2, walkReducer) {
      let prevContextValue;
      if (useContext) {
        prevContextValue = context2[contextName];
        context2[contextName] = node2;
      }
      for (const field of fields) {
        const ref2 = node2[field.name];
        if (!field.nullable || ref2) {
          if (field.type === "list") {
            const breakWalk = reverse2 ? ref2.reduceRight(walkReducer, false) : ref2.reduce(walkReducer, false);
            if (breakWalk) {
              return true;
            }
          } else if (walk2(ref2)) {
            return true;
          }
        }
      }
      if (useContext) {
        context2[contextName] = prevContextValue;
      }
    };
  }
  function createFastTraveralMap({ StyleSheet: StyleSheet2, Atrule: Atrule2, Rule: Rule2, Block: Block2, DeclarationList: DeclarationList2 }) {
    return {
      Atrule: {
        StyleSheet: StyleSheet2,
        Atrule: Atrule2,
        Rule: Rule2,
        Block: Block2
      },
      Rule: {
        StyleSheet: StyleSheet2,
        Atrule: Atrule2,
        Rule: Rule2,
        Block: Block2
      },
      Declaration: {
        StyleSheet: StyleSheet2,
        Atrule: Atrule2,
        Rule: Rule2,
        Block: Block2,
        DeclarationList: DeclarationList2
      }
    };
  }
  function createWalker(config) {
    const types22 = getTypesFromConfig(config);
    const iteratorsNatural = {};
    const iteratorsReverse = {};
    const breakWalk = Symbol("break-walk");
    const skipNode = Symbol("skip-node");
    for (const name2 in types22) {
      if (hasOwnProperty$3.call(types22, name2) && types22[name2] !== null) {
        iteratorsNatural[name2] = createTypeIterator(types22[name2], false);
        iteratorsReverse[name2] = createTypeIterator(types22[name2], true);
      }
    }
    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
    const walk2 = function(root2, options2) {
      function walkNode(node2, item, list2) {
        const enterRet = enter.call(context2, node2, item, list2);
        if (enterRet === breakWalk) {
          return true;
        }
        if (enterRet === skipNode) {
          return false;
        }
        if (iterators.hasOwnProperty(node2.type)) {
          if (iterators[node2.type](node2, context2, walkNode, walkReducer)) {
            return true;
          }
        }
        if (leave.call(context2, node2, item, list2) === breakWalk) {
          return true;
        }
        return false;
      }
      let enter = noop$2;
      let leave = noop$2;
      let iterators = iteratorsNatural;
      let walkReducer = (ret, data2, item, list2) => ret || walkNode(data2, item, list2);
      const context2 = {
        break: breakWalk,
        skip: skipNode,
        root: root2,
        stylesheet: null,
        atrule: null,
        atrulePrelude: null,
        rule: null,
        selector: null,
        block: null,
        declaration: null,
        function: null
      };
      if (typeof options2 === "function") {
        enter = options2;
      } else if (options2) {
        enter = ensureFunction$1(options2.enter);
        leave = ensureFunction$1(options2.leave);
        if (options2.reverse) {
          iterators = iteratorsReverse;
        }
        if (options2.visit) {
          if (fastTraversalIteratorsNatural.hasOwnProperty(options2.visit)) {
            iterators = options2.reverse ? fastTraversalIteratorsReverse[options2.visit] : fastTraversalIteratorsNatural[options2.visit];
          } else if (!types22.hasOwnProperty(options2.visit)) {
            throw new Error("Bad value `" + options2.visit + "` for `visit` option (should be: " + Object.keys(types22).sort().join(", ") + ")");
          }
          enter = invokeForType(enter, options2.visit);
          leave = invokeForType(leave, options2.visit);
        }
      }
      if (enter === noop$2 && leave === noop$2) {
        throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
      }
      walkNode(root2);
    };
    walk2.break = breakWalk;
    walk2.skip = skipNode;
    walk2.find = function(ast, fn22) {
      let found = null;
      walk2(ast, function(node2, item, list2) {
        if (fn22.call(this, node2, item, list2)) {
          found = node2;
          return breakWalk;
        }
      });
      return found;
    };
    walk2.findLast = function(ast, fn22) {
      let found = null;
      walk2(ast, {
        reverse: true,
        enter(node2, item, list2) {
          if (fn22.call(this, node2, item, list2)) {
            found = node2;
            return breakWalk;
          }
        }
      });
      return found;
    };
    walk2.findAll = function(ast, fn22) {
      const found = [];
      walk2(ast, function(node2, item, list2) {
        if (fn22.call(this, node2, item, list2)) {
          found.push(node2);
        }
      });
      return found;
    };
    return walk2;
  }
  function noop$1(value2) {
    return value2;
  }
  function generateMultiplier(multiplier) {
    const { min, max, comma } = multiplier;
    if (min === 0 && max === 0) {
      return comma ? "#?" : "*";
    }
    if (min === 0 && max === 1) {
      return "?";
    }
    if (min === 1 && max === 0) {
      return comma ? "#" : "+";
    }
    if (min === 1 && max === 1) {
      return "";
    }
    return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
  }
  function generateTypeOpts(node2) {
    switch (node2.type) {
      case "Range":
        return " [" + (node2.min === null ? "-\u221E" : node2.min) + "," + (node2.max === null ? "\u221E" : node2.max) + "]";
      default:
        throw new Error("Unknown node type `" + node2.type + "`");
    }
  }
  function generateSequence(node2, decorate, forceBraces, compact) {
    const combinator = node2.combinator === " " || compact ? node2.combinator : " " + node2.combinator + " ";
    const result = node2.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
    if (node2.explicit || forceBraces) {
      return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
    }
    return result;
  }
  function internalGenerate(node2, decorate, forceBraces, compact) {
    let result;
    switch (node2.type) {
      case "Group":
        result = generateSequence(node2, decorate, forceBraces, compact) + (node2.disallowEmpty ? "!" : "");
        break;
      case "Multiplier":
        return internalGenerate(node2.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node2), node2);
      case "Boolean":
        result = "<boolean-expr[" + internalGenerate(node2.term, decorate, forceBraces, compact) + "]>";
        break;
      case "Type":
        result = "<" + node2.name + (node2.opts ? decorate(generateTypeOpts(node2.opts), node2.opts) : "") + ">";
        break;
      case "Property":
        result = "<'" + node2.name + "'>";
        break;
      case "Keyword":
        result = node2.name;
        break;
      case "AtKeyword":
        result = "@" + node2.name;
        break;
      case "Function":
        result = node2.name + "(";
        break;
      case "String":
      case "Token":
        result = node2.value;
        break;
      case "Comma":
        result = ",";
        break;
      default:
        throw new Error("Unknown node type `" + node2.type + "`");
    }
    return decorate(result, node2);
  }
  function generate$O(node2, options2) {
    let decorate = noop$1;
    let forceBraces = false;
    let compact = false;
    if (typeof options2 === "function") {
      decorate = options2;
    } else if (options2) {
      forceBraces = Boolean(options2.forceBraces);
      compact = Boolean(options2.compact);
      if (typeof options2.decorate === "function") {
        decorate = options2.decorate;
      }
    }
    return internalGenerate(node2, decorate, forceBraces, compact);
  }
  const defaultLoc = {
    offset: 0,
    line: 1,
    column: 1
  };
  function locateMismatch(matchResult, node2) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node2 ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = "";
    let start;
    let end;
    for (let i22 = 0; i22 < tokens.length; i22++) {
      const token = tokens[i22].value;
      if (i22 === longestMatch) {
        mismatchLength = token.length;
        mismatchOffset = css.length;
      }
      if (badNode !== null && tokens[i22].node === badNode) {
        if (i22 <= longestMatch) {
          entries++;
        } else {
          entries = 0;
        }
      }
      css += token;
    }
    if (longestMatch === tokens.length || entries > 1) {
      start = fromLoc(badNode || node2, "end") || buildLoc(defaultLoc, css);
      end = buildLoc(start);
    } else {
      start = fromLoc(badNode, "start") || buildLoc(fromLoc(node2, "start") || defaultLoc, css.slice(0, mismatchOffset));
      end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }
    return {
      css,
      mismatchOffset,
      mismatchLength,
      start,
      end
    };
  }
  function fromLoc(node2, point) {
    const value2 = node2 && node2.loc && node2.loc[point];
    if (value2) {
      return "line" in value2 ? buildLoc(value2) : value2;
    }
    return null;
  }
  function buildLoc({ offset, line, column }, extra) {
    const loc = {
      offset,
      line,
      column
    };
    if (extra) {
      const lines = extra.split(/\n|\r\n?|\f/);
      loc.offset += extra.length;
      loc.line += lines.length - 1;
      loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }
    return loc;
  }
  const SyntaxReferenceError = function(type2, referenceName) {
    const error = createCustomError("SyntaxReferenceError", type2 + (referenceName ? " `" + referenceName + "`" : ""));
    error.reference = referenceName;
    return error;
  };
  const SyntaxMatchError = function(message, syntax2, node2, matchResult) {
    const error = createCustomError("SyntaxMatchError", message);
    const { css, mismatchOffset, mismatchLength, start, end } = locateMismatch(matchResult, node2);
    error.rawMessage = message;
    error.syntax = syntax2 ? generate$O(syntax2) : "<generic>";
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
    Object.assign(error, start);
    error.loc = {
      source: node2 && node2.loc && node2.loc.source || "<unknown>",
      start,
      end
    };
    return error;
  };
  const keywords = /* @__PURE__ */ new Map();
  const properties = /* @__PURE__ */ new Map();
  const HYPHENMINUS$5 = 45;
  const keyword = getKeywordDescriptor;
  const property = getPropertyDescriptor;
  function isCustomProperty(str, offset) {
    offset = offset || 0;
    return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS$5 && str.charCodeAt(offset + 1) === HYPHENMINUS$5;
  }
  function getVendorPrefix(str, offset) {
    offset = offset || 0;
    if (str.length - offset >= 3) {
      if (str.charCodeAt(offset) === HYPHENMINUS$5 && str.charCodeAt(offset + 1) !== HYPHENMINUS$5) {
        const secondDashIndex = str.indexOf("-", offset + 2);
        if (secondDashIndex !== -1) {
          return str.substring(offset, secondDashIndex + 1);
        }
      }
    }
    return "";
  }
  function getKeywordDescriptor(keyword2) {
    if (keywords.has(keyword2)) {
      return keywords.get(keyword2);
    }
    const name2 = keyword2.toLowerCase();
    let descriptor = keywords.get(name2);
    if (descriptor === void 0) {
      const custom = isCustomProperty(name2, 0);
      const vendor = !custom ? getVendorPrefix(name2, 0) : "";
      descriptor = Object.freeze({
        basename: name2.substr(vendor.length),
        name: name2,
        prefix: vendor,
        vendor,
        custom
      });
    }
    keywords.set(keyword2, descriptor);
    return descriptor;
  }
  function getPropertyDescriptor(property2) {
    if (properties.has(property2)) {
      return properties.get(property2);
    }
    let name2 = property2;
    let hack = property2[0];
    if (hack === "/") {
      hack = property2[1] === "/" ? "//" : "/";
    } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
      hack = "";
    }
    const custom = isCustomProperty(name2, hack.length);
    if (!custom) {
      name2 = name2.toLowerCase();
      if (properties.has(name2)) {
        const descriptor2 = properties.get(name2);
        properties.set(property2, descriptor2);
        return descriptor2;
      }
    }
    const vendor = !custom ? getVendorPrefix(name2, hack.length) : "";
    const prefix = name2.substr(0, hack.length + vendor.length);
    const descriptor = Object.freeze({
      basename: name2.substr(prefix.length),
      name: name2.substr(hack.length),
      hack,
      vendor,
      prefix,
      custom
    });
    properties.set(property2, descriptor);
    return descriptor;
  }
  const cssWideKeywords = [
    "initial",
    "inherit",
    "unset",
    "revert",
    "revert-layer"
  ];
  const PLUSSIGN$8 = 43;
  const HYPHENMINUS$4 = 45;
  const N$3 = 110;
  const DISALLOW_SIGN$1 = true;
  const ALLOW_SIGN$1 = false;
  function isDelim$1(token, code2) {
    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
  }
  function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === WhiteSpace$1 || token.type === Comment$1)) {
      token = getNextToken(++offset);
    }
    return offset;
  }
  function checkInteger$1(token, valueOffset, disallowSign, offset) {
    if (!token) {
      return 0;
    }
    const code2 = token.value.charCodeAt(valueOffset);
    if (code2 === PLUSSIGN$8 || code2 === HYPHENMINUS$4) {
      if (disallowSign) {
        return 0;
      }
      valueOffset++;
    }
    for (; valueOffset < token.value.length; valueOffset++) {
      if (!isDigit(token.value.charCodeAt(valueOffset))) {
        return 0;
      }
    }
    return offset + 1;
  }
  function consumeB$1(token, offset_, getNextToken) {
    let sign2 = false;
    let offset = skipSC(token, offset_, getNextToken);
    token = getNextToken(offset);
    if (token === null) {
      return offset_;
    }
    if (token.type !== Number$2) {
      if (isDelim$1(token, PLUSSIGN$8) || isDelim$1(token, HYPHENMINUS$4)) {
        sign2 = true;
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        if (token === null || token.type !== Number$2) {
          return 0;
        }
      } else {
        return offset_;
      }
    }
    if (!sign2) {
      const code2 = token.value.charCodeAt(0);
      if (code2 !== PLUSSIGN$8 && code2 !== HYPHENMINUS$4) {
        return 0;
      }
    }
    return checkInteger$1(token, sign2 ? 0 : 1, sign2, offset);
  }
  function anPlusB(token, getNextToken) {
    let offset = 0;
    if (!token) {
      return 0;
    }
    if (token.type === Number$2) {
      return checkInteger$1(token, 0, ALLOW_SIGN$1, offset);
    } else if (token.type === Ident && token.value.charCodeAt(0) === HYPHENMINUS$4) {
      if (!cmpChar(token.value, 1, N$3)) {
        return 0;
      }
      switch (token.value.length) {
        case 2:
          return consumeB$1(getNextToken(++offset), offset, getNextToken);
        case 3:
          if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
            return 0;
          }
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
        default:
          if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
            return 0;
          }
          return checkInteger$1(token, 3, DISALLOW_SIGN$1, offset);
      }
    } else if (token.type === Ident || isDelim$1(token, PLUSSIGN$8) && getNextToken(offset + 1).type === Ident) {
      if (token.type !== Ident) {
        token = getNextToken(++offset);
      }
      if (token === null || !cmpChar(token.value, 0, N$3)) {
        return 0;
      }
      switch (token.value.length) {
        case 1:
          return consumeB$1(getNextToken(++offset), offset, getNextToken);
        case 2:
          if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
            return 0;
          }
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
        default:
          if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
            return 0;
          }
          return checkInteger$1(token, 2, DISALLOW_SIGN$1, offset);
      }
    } else if (token.type === Dimension$1) {
      let code2 = token.value.charCodeAt(0);
      let sign2 = code2 === PLUSSIGN$8 || code2 === HYPHENMINUS$4 ? 1 : 0;
      let i22 = sign2;
      for (; i22 < token.value.length; i22++) {
        if (!isDigit(token.value.charCodeAt(i22))) {
          break;
        }
      }
      if (i22 === sign2) {
        return 0;
      }
      if (!cmpChar(token.value, i22, N$3)) {
        return 0;
      }
      if (i22 + 1 === token.value.length) {
        return consumeB$1(getNextToken(++offset), offset, getNextToken);
      } else {
        if (token.value.charCodeAt(i22 + 1) !== HYPHENMINUS$4) {
          return 0;
        }
        if (i22 + 2 === token.value.length) {
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
        } else {
          return checkInteger$1(token, i22 + 2, DISALLOW_SIGN$1, offset);
        }
      }
    }
    return 0;
  }
  const PLUSSIGN$7 = 43;
  const HYPHENMINUS$3 = 45;
  const QUESTIONMARK$2 = 63;
  const U$1 = 117;
  function isDelim(token, code2) {
    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
  }
  function startsWith$1(token, code2) {
    return token.value.charCodeAt(0) === code2;
  }
  function hexSequence(token, offset, allowDash) {
    let hexlen = 0;
    for (let pos = offset; pos < token.value.length; pos++) {
      const code2 = token.value.charCodeAt(pos);
      if (code2 === HYPHENMINUS$3 && allowDash && hexlen !== 0) {
        hexSequence(token, offset + hexlen + 1, false);
        return 6;
      }
      if (!isHexDigit(code2)) {
        return 0;
      }
      if (++hexlen > 6) {
        return 0;
      }
    }
    return hexlen;
  }
  function withQuestionMarkSequence(consumed, length2, getNextToken) {
    if (!consumed) {
      return 0;
    }
    while (isDelim(getNextToken(length2), QUESTIONMARK$2)) {
      if (++consumed > 6) {
        return 0;
      }
      length2++;
    }
    return length2;
  }
  function urange(token, getNextToken) {
    let length2 = 0;
    if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U$1)) {
      return 0;
    }
    token = getNextToken(++length2);
    if (token === null) {
      return 0;
    }
    if (isDelim(token, PLUSSIGN$7)) {
      token = getNextToken(++length2);
      if (token === null) {
        return 0;
      }
      if (token.type === Ident) {
        return withQuestionMarkSequence(hexSequence(token, 0, true), ++length2, getNextToken);
      }
      if (isDelim(token, QUESTIONMARK$2)) {
        return withQuestionMarkSequence(1, ++length2, getNextToken);
      }
      return 0;
    }
    if (token.type === Number$2) {
      const consumedHexLength = hexSequence(token, 1, true);
      if (consumedHexLength === 0) {
        return 0;
      }
      token = getNextToken(++length2);
      if (token === null) {
        return length2;
      }
      if (token.type === Dimension$1 || token.type === Number$2) {
        if (!startsWith$1(token, HYPHENMINUS$3) || !hexSequence(token, 1, false)) {
          return 0;
        }
        return length2 + 1;
      }
      return withQuestionMarkSequence(consumedHexLength, length2, getNextToken);
    }
    if (token.type === Dimension$1) {
      return withQuestionMarkSequence(hexSequence(token, 1, true), ++length2, getNextToken);
    }
    return 0;
  }
  const calcFunctionNames = [
    "calc(",
    "-moz-calc(",
    "-webkit-calc("
  ];
  const balancePair = /* @__PURE__ */ new Map([
    [
      Function$2,
      RightParenthesis
    ],
    [
      LeftParenthesis,
      RightParenthesis
    ],
    [
      LeftSquareBracket,
      RightSquareBracket
    ],
    [
      LeftCurlyBracket,
      RightCurlyBracket
    ]
  ]);
  function charCodeAt(str, index2) {
    return index2 < str.length ? str.charCodeAt(index2) : 0;
  }
  function eqStr(actual, expected) {
    return cmpStr(actual, 0, actual.length, expected);
  }
  function eqStrAny(actual, expected) {
    for (let i22 = 0; i22 < expected.length; i22++) {
      if (eqStr(actual, expected[i22])) {
        return true;
      }
    }
    return false;
  }
  function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
      return false;
    }
    return charCodeAt(str, offset) === 92 && isDigit(charCodeAt(str, offset + 1));
  }
  function outOfRange(opts, value2, numEnd) {
    if (opts && opts.type === "Range") {
      const num = Number(numEnd !== void 0 && numEnd !== value2.length ? value2.substr(0, numEnd) : value2);
      if (isNaN(num)) {
        return true;
      }
      if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
        return true;
      }
      if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
        return true;
      }
    }
    return false;
  }
  function consumeFunction(token, getNextToken) {
    let balanceCloseType = 0;
    let balanceStash = [];
    let length2 = 0;
    scan:
      do {
        switch (token.type) {
          case RightCurlyBracket:
          case RightParenthesis:
          case RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            if (balanceStash.length === 0) {
              length2++;
              break scan;
            }
            break;
          case Function$2:
          case LeftParenthesis:
          case LeftSquareBracket:
          case LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair.get(token.type);
            break;
        }
        length2++;
      } while (token = getNextToken(length2));
    return length2;
  }
  function calc(next2) {
    return function(token, getNextToken, opts) {
      if (token === null) {
        return 0;
      }
      if (token.type === Function$2 && eqStrAny(token.value, calcFunctionNames)) {
        return consumeFunction(token, getNextToken);
      }
      return next2(token, getNextToken, opts);
    };
  }
  function tokenType(expectedTokenType) {
    return function(token) {
      if (token === null || token.type !== expectedTokenType) {
        return 0;
      }
      return 1;
    };
  }
  function customIdent(token) {
    if (token === null || token.type !== Ident) {
      return 0;
    }
    const name2 = token.value.toLowerCase();
    if (eqStrAny(name2, cssWideKeywords)) {
      return 0;
    }
    if (eqStr(name2, "default")) {
      return 0;
    }
    return 1;
  }
  function dashedIdent(token) {
    if (token === null || token.type !== Ident) {
      return 0;
    }
    if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
      return 0;
    }
    return 1;
  }
  function customPropertyName(token) {
    if (!dashedIdent(token)) {
      return 0;
    }
    if (token.value === "--") {
      return 0;
    }
    return 1;
  }
  function hexColor(token) {
    if (token === null || token.type !== Hash$1) {
      return 0;
    }
    const length2 = token.value.length;
    if (length2 !== 4 && length2 !== 5 && length2 !== 7 && length2 !== 9) {
      return 0;
    }
    for (let i22 = 1; i22 < length2; i22++) {
      if (!isHexDigit(charCodeAt(token.value, i22))) {
        return 0;
      }
    }
    return 1;
  }
  function idSelector(token) {
    if (token === null || token.type !== Hash$1) {
      return 0;
    }
    if (!isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
      return 0;
    }
    return 1;
  }
  function declarationValue(token, getNextToken) {
    if (!token) {
      return 0;
    }
    let balanceCloseType = 0;
    let balanceStash = [];
    let length2 = 0;
    scan:
      do {
        switch (token.type) {
          case BadString:
          case BadUrl:
            break scan;
          case RightCurlyBracket:
          case RightParenthesis:
          case RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            break;
          case Semicolon:
            if (balanceCloseType === 0) {
              break scan;
            }
            break;
          case Delim:
            if (balanceCloseType === 0 && token.value === "!") {
              break scan;
            }
            break;
          case Function$2:
          case LeftParenthesis:
          case LeftSquareBracket:
          case LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair.get(token.type);
            break;
        }
        length2++;
      } while (token = getNextToken(length2));
    return length2;
  }
  function anyValue(token, getNextToken) {
    if (!token) {
      return 0;
    }
    let balanceCloseType = 0;
    let balanceStash = [];
    let length2 = 0;
    scan:
      do {
        switch (token.type) {
          case BadString:
          case BadUrl:
            break scan;
          case RightCurlyBracket:
          case RightParenthesis:
          case RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            break;
          case Function$2:
          case LeftParenthesis:
          case LeftSquareBracket:
          case LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair.get(token.type);
            break;
        }
        length2++;
      } while (token = getNextToken(length2));
    return length2;
  }
  function dimension(type2) {
    if (type2) {
      type2 = new Set(type2);
    }
    return function(token, getNextToken, opts) {
      if (token === null || token.type !== Dimension$1) {
        return 0;
      }
      const numberEnd = consumeNumber(token.value, 0);
      if (type2 !== null) {
        const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
        const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
        if (type2.has(unit.toLowerCase()) === false) {
          return 0;
        }
      }
      if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
      }
      return 1;
    };
  }
  function percentage(token, getNextToken, opts) {
    if (token === null || token.type !== Percentage$1) {
      return 0;
    }
    if (outOfRange(opts, token.value, token.value.length - 1)) {
      return 0;
    }
    return 1;
  }
  function zero(next2) {
    if (typeof next2 !== "function") {
      next2 = function() {
        return 0;
      };
    }
    return function(token, getNextToken, opts) {
      if (token !== null && token.type === Number$2) {
        if (Number(token.value) === 0) {
          return 1;
        }
      }
      return next2(token, getNextToken, opts);
    };
  }
  function number(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    const numberEnd = consumeNumber(token.value, 0);
    const isNumber2 = numberEnd === token.value.length;
    if (!isNumber2 && !isPostfixIeHack(token.value, numberEnd)) {
      return 0;
    }
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  }
  function integer(token, getNextToken, opts) {
    if (token === null || token.type !== Number$2) {
      return 0;
    }
    let i22 = charCodeAt(token.value, 0) === 43 || charCodeAt(token.value, 0) === 45 ? 1 : 0;
    for (; i22 < token.value.length; i22++) {
      if (!isDigit(charCodeAt(token.value, i22))) {
        return 0;
      }
    }
    if (outOfRange(opts, token.value, i22)) {
      return 0;
    }
    return 1;
  }
  const tokenTypes = {
    "ident-token": tokenType(Ident),
    "function-token": tokenType(Function$2),
    "at-keyword-token": tokenType(AtKeyword),
    "hash-token": tokenType(Hash$1),
    "string-token": tokenType(String$2),
    "bad-string-token": tokenType(BadString),
    "url-token": tokenType(Url$1),
    "bad-url-token": tokenType(BadUrl),
    "delim-token": tokenType(Delim),
    "number-token": tokenType(Number$2),
    "percentage-token": tokenType(Percentage$1),
    "dimension-token": tokenType(Dimension$1),
    "whitespace-token": tokenType(WhiteSpace$1),
    "CDO-token": tokenType(CDO$1),
    "CDC-token": tokenType(CDC$1),
    "colon-token": tokenType(Colon),
    "semicolon-token": tokenType(Semicolon),
    "comma-token": tokenType(Comma),
    "[-token": tokenType(LeftSquareBracket),
    "]-token": tokenType(RightSquareBracket),
    "(-token": tokenType(LeftParenthesis),
    ")-token": tokenType(RightParenthesis),
    "{-token": tokenType(LeftCurlyBracket),
    "}-token": tokenType(RightCurlyBracket)
  };
  const productionTypes = {
    "string": tokenType(String$2),
    "ident": tokenType(Ident),
    "percentage": calc(percentage),
    "zero": zero(),
    "number": calc(number),
    "integer": calc(integer),
    "custom-ident": customIdent,
    "dashed-ident": dashedIdent,
    "custom-property-name": customPropertyName,
    "hex-color": hexColor,
    "id-selector": idSelector,
    "an-plus-b": anPlusB,
    "urange": urange,
    "declaration-value": declarationValue,
    "any-value": anyValue
  };
  function createDemensionTypes(units2) {
    const { angle: angle2, decibel: decibel2, frequency: frequency2, flex: flex2, length: length2, resolution: resolution2, semitones: semitones2, time: time2 } = units2 || {};
    return {
      "dimension": calc(dimension(null)),
      "angle": calc(dimension(angle2)),
      "decibel": calc(dimension(decibel2)),
      "frequency": calc(dimension(frequency2)),
      "flex": calc(dimension(flex2)),
      "length": calc(zero(dimension(length2))),
      "resolution": calc(dimension(resolution2)),
      "semitones": calc(dimension(semitones2)),
      "time": calc(dimension(time2))
    };
  }
  function createGenericTypes(units2) {
    return {
      ...tokenTypes,
      ...productionTypes,
      ...createDemensionTypes(units2)
    };
  }
  const length = [
    "cm",
    "mm",
    "q",
    "in",
    "pt",
    "pc",
    "px",
    "em",
    "rem",
    "ex",
    "rex",
    "cap",
    "rcap",
    "ch",
    "rch",
    "ic",
    "ric",
    "lh",
    "rlh",
    "vw",
    "svw",
    "lvw",
    "dvw",
    "vh",
    "svh",
    "lvh",
    "dvh",
    "vi",
    "svi",
    "lvi",
    "dvi",
    "vb",
    "svb",
    "lvb",
    "dvb",
    "vmin",
    "svmin",
    "lvmin",
    "dvmin",
    "vmax",
    "svmax",
    "lvmax",
    "dvmax",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
  ];
  const angle = [
    "deg",
    "grad",
    "rad",
    "turn"
  ];
  const time = [
    "s",
    "ms"
  ];
  const frequency = [
    "hz",
    "khz"
  ];
  const resolution = [
    "dpi",
    "dpcm",
    "dppx",
    "x"
  ];
  const flex = [
    "fr"
  ];
  const decibel = [
    "db"
  ];
  const semitones = [
    "st"
  ];
  const units = Object.freeze(Object.defineProperty({
    __proto__: null,
    angle,
    decibel,
    flex,
    frequency,
    length,
    resolution,
    semitones,
    time
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function SyntaxError$1(message, input, offset) {
    return Object.assign(createCustomError("SyntaxError", message), {
      input,
      offset,
      rawMessage: message,
      message: message + "\n  " + input + "\n--" + new Array((offset || input.length) + 1).join("-") + "^"
    });
  }
  const TAB$1 = 9;
  const N$2 = 10;
  const F$1 = 12;
  const R$1 = 13;
  const SPACE$3 = 32;
  const NAME_CHAR = new Uint8Array(128).map((_10, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0);
  class Scanner {
    constructor(str) {
      this.str = str;
      this.pos = 0;
    }
    charCodeAt(pos) {
      return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    }
    charCode() {
      return this.charCodeAt(this.pos);
    }
    isNameCharCode(code2 = this.charCode()) {
      return code2 < 128 && NAME_CHAR[code2] === 1;
    }
    nextCharCode() {
      return this.charCodeAt(this.pos + 1);
    }
    nextNonWsCode(pos) {
      return this.charCodeAt(this.findWsEnd(pos));
    }
    skipWs() {
      this.pos = this.findWsEnd(this.pos);
    }
    findWsEnd(pos) {
      for (; pos < this.str.length; pos++) {
        const code2 = this.str.charCodeAt(pos);
        if (code2 !== R$1 && code2 !== N$2 && code2 !== F$1 && code2 !== SPACE$3 && code2 !== TAB$1) {
          break;
        }
      }
      return pos;
    }
    substringToPos(end) {
      return this.str.substring(this.pos, this.pos = end);
    }
    eat(code2) {
      if (this.charCode() !== code2) {
        this.error("Expect `" + String.fromCharCode(code2) + "`");
      }
      this.pos++;
    }
    peek() {
      return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
    }
    error(message) {
      throw new SyntaxError$1(message, this.str, this.pos);
    }
    scanSpaces() {
      return this.substringToPos(this.findWsEnd(this.pos));
    }
    scanWord() {
      let end = this.pos;
      for (; end < this.str.length; end++) {
        const code2 = this.str.charCodeAt(end);
        if (code2 >= 128 || NAME_CHAR[code2] === 0) {
          break;
        }
      }
      if (this.pos === end) {
        this.error("Expect a keyword");
      }
      return this.substringToPos(end);
    }
    scanNumber() {
      let end = this.pos;
      for (; end < this.str.length; end++) {
        const code2 = this.str.charCodeAt(end);
        if (code2 < 48 || code2 > 57) {
          break;
        }
      }
      if (this.pos === end) {
        this.error("Expect a number");
      }
      return this.substringToPos(end);
    }
    scanString() {
      const end = this.str.indexOf("'", this.pos + 1);
      if (end === -1) {
        this.pos = this.str.length;
        this.error("Expect an apostrophe");
      }
      return this.substringToPos(end + 1);
    }
  }
  const TAB = 9;
  const N$1 = 10;
  const F = 12;
  const R = 13;
  const SPACE$2 = 32;
  const EXCLAMATIONMARK$2 = 33;
  const NUMBERSIGN$3 = 35;
  const AMPERSAND$5 = 38;
  const APOSTROPHE$2 = 39;
  const LEFTPARENTHESIS$2 = 40;
  const RIGHTPARENTHESIS$2 = 41;
  const ASTERISK$6 = 42;
  const PLUSSIGN$6 = 43;
  const COMMA = 44;
  const HYPERMINUS = 45;
  const LESSTHANSIGN$1 = 60;
  const GREATERTHANSIGN$3 = 62;
  const QUESTIONMARK$1 = 63;
  const COMMERCIALAT = 64;
  const LEFTSQUAREBRACKET = 91;
  const RIGHTSQUAREBRACKET = 93;
  const LEFTCURLYBRACKET = 123;
  const VERTICALLINE$3 = 124;
  const RIGHTCURLYBRACKET = 125;
  const INFINITY = 8734;
  const COMBINATOR_PRECEDENCE = {
    " ": 1,
    "&&": 2,
    "||": 3,
    "|": 4
  };
  function readMultiplierRange(scanner) {
    let min = null;
    let max = null;
    scanner.eat(LEFTCURLYBRACKET);
    scanner.skipWs();
    min = scanner.scanNumber(scanner);
    scanner.skipWs();
    if (scanner.charCode() === COMMA) {
      scanner.pos++;
      scanner.skipWs();
      if (scanner.charCode() !== RIGHTCURLYBRACKET) {
        max = scanner.scanNumber(scanner);
        scanner.skipWs();
      }
    } else {
      max = min;
    }
    scanner.eat(RIGHTCURLYBRACKET);
    return {
      min: Number(min),
      max: max ? Number(max) : 0
    };
  }
  function readMultiplier(scanner) {
    let range2 = null;
    let comma = false;
    switch (scanner.charCode()) {
      case ASTERISK$6:
        scanner.pos++;
        range2 = {
          min: 0,
          max: 0
        };
        break;
      case PLUSSIGN$6:
        scanner.pos++;
        range2 = {
          min: 1,
          max: 0
        };
        break;
      case QUESTIONMARK$1:
        scanner.pos++;
        range2 = {
          min: 0,
          max: 1
        };
        break;
      case NUMBERSIGN$3:
        scanner.pos++;
        comma = true;
        if (scanner.charCode() === LEFTCURLYBRACKET) {
          range2 = readMultiplierRange(scanner);
        } else if (scanner.charCode() === QUESTIONMARK$1) {
          scanner.pos++;
          range2 = {
            min: 0,
            max: 0
          };
        } else {
          range2 = {
            min: 1,
            max: 0
          };
        }
        break;
      case LEFTCURLYBRACKET:
        range2 = readMultiplierRange(scanner);
        break;
      default:
        return null;
    }
    return {
      type: "Multiplier",
      comma,
      min: range2.min,
      max: range2.max,
      term: null
    };
  }
  function maybeMultiplied(scanner, node2) {
    const multiplier = readMultiplier(scanner);
    if (multiplier !== null) {
      multiplier.term = node2;
      if (scanner.charCode() === NUMBERSIGN$3 && scanner.charCodeAt(scanner.pos - 1) === PLUSSIGN$6) {
        return maybeMultiplied(scanner, multiplier);
      }
      return multiplier;
    }
    return node2;
  }
  function maybeToken(scanner) {
    const ch2 = scanner.peek();
    if (ch2 === "") {
      return null;
    }
    return maybeMultiplied(scanner, {
      type: "Token",
      value: ch2
    });
  }
  function readProperty$1(scanner) {
    let name2;
    scanner.eat(LESSTHANSIGN$1);
    scanner.eat(APOSTROPHE$2);
    name2 = scanner.scanWord();
    scanner.eat(APOSTROPHE$2);
    scanner.eat(GREATERTHANSIGN$3);
    return maybeMultiplied(scanner, {
      type: "Property",
      name: name2
    });
  }
  function readTypeRange(scanner) {
    let min = null;
    let max = null;
    let sign2 = 1;
    scanner.eat(LEFTSQUAREBRACKET);
    if (scanner.charCode() === HYPERMINUS) {
      scanner.peek();
      sign2 = -1;
    }
    if (sign2 == -1 && scanner.charCode() === INFINITY) {
      scanner.peek();
    } else {
      min = sign2 * Number(scanner.scanNumber(scanner));
      if (scanner.isNameCharCode()) {
        min += scanner.scanWord();
      }
    }
    scanner.skipWs();
    scanner.eat(COMMA);
    scanner.skipWs();
    if (scanner.charCode() === INFINITY) {
      scanner.peek();
    } else {
      sign2 = 1;
      if (scanner.charCode() === HYPERMINUS) {
        scanner.peek();
        sign2 = -1;
      }
      max = sign2 * Number(scanner.scanNumber(scanner));
      if (scanner.isNameCharCode()) {
        max += scanner.scanWord();
      }
    }
    scanner.eat(RIGHTSQUAREBRACKET);
    return {
      type: "Range",
      min,
      max
    };
  }
  function readType(scanner) {
    let name2;
    let opts = null;
    scanner.eat(LESSTHANSIGN$1);
    name2 = scanner.scanWord();
    if (name2 === "boolean-expr") {
      scanner.eat(LEFTSQUAREBRACKET);
      const implicitGroup = readImplicitGroup(scanner, RIGHTSQUAREBRACKET);
      scanner.eat(RIGHTSQUAREBRACKET);
      scanner.eat(GREATERTHANSIGN$3);
      return maybeMultiplied(scanner, {
        type: "Boolean",
        term: implicitGroup.terms.length === 1 ? implicitGroup.terms[0] : implicitGroup
      });
    }
    if (scanner.charCode() === LEFTPARENTHESIS$2 && scanner.nextCharCode() === RIGHTPARENTHESIS$2) {
      scanner.pos += 2;
      name2 += "()";
    }
    if (scanner.charCodeAt(scanner.findWsEnd(scanner.pos)) === LEFTSQUAREBRACKET) {
      scanner.skipWs();
      opts = readTypeRange(scanner);
    }
    scanner.eat(GREATERTHANSIGN$3);
    return maybeMultiplied(scanner, {
      type: "Type",
      name: name2,
      opts
    });
  }
  function readKeywordOrFunction(scanner) {
    const name2 = scanner.scanWord();
    if (scanner.charCode() === LEFTPARENTHESIS$2) {
      scanner.pos++;
      return {
        type: "Function",
        name: name2
      };
    }
    return maybeMultiplied(scanner, {
      type: "Keyword",
      name: name2
    });
  }
  function regroupTerms(terms, combinators) {
    function createGroup(terms2, combinator2) {
      return {
        type: "Group",
        terms: terms2,
        combinator: combinator2,
        disallowEmpty: false,
        explicit: false
      };
    }
    let combinator;
    combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);
    while (combinators.length > 0) {
      combinator = combinators.shift();
      let i22 = 0;
      let subgroupStart = 0;
      for (; i22 < terms.length; i22++) {
        const term = terms[i22];
        if (term.type === "Combinator") {
          if (term.value === combinator) {
            if (subgroupStart === -1) {
              subgroupStart = i22 - 1;
            }
            terms.splice(i22, 1);
            i22--;
          } else {
            if (subgroupStart !== -1 && i22 - subgroupStart > 1) {
              terms.splice(subgroupStart, i22 - subgroupStart, createGroup(terms.slice(subgroupStart, i22), combinator));
              i22 = subgroupStart + 1;
            }
            subgroupStart = -1;
          }
        }
      }
      if (subgroupStart !== -1 && combinators.length) {
        terms.splice(subgroupStart, i22 - subgroupStart, createGroup(terms.slice(subgroupStart, i22), combinator));
      }
    }
    return combinator;
  }
  function readImplicitGroup(scanner, stopCharCode) {
    const combinators = /* @__PURE__ */ Object.create(null);
    const terms = [];
    let token;
    let prevToken = null;
    let prevTokenPos = scanner.pos;
    while (scanner.charCode() !== stopCharCode && (token = peek(scanner, stopCharCode))) {
      if (token.type !== "Spaces") {
        if (token.type === "Combinator") {
          if (prevToken === null || prevToken.type === "Combinator") {
            scanner.pos = prevTokenPos;
            scanner.error("Unexpected combinator");
          }
          combinators[token.value] = true;
        } else if (prevToken !== null && prevToken.type !== "Combinator") {
          combinators[" "] = true;
          terms.push({
            type: "Combinator",
            value: " "
          });
        }
        terms.push(token);
        prevToken = token;
        prevTokenPos = scanner.pos;
      }
    }
    if (prevToken !== null && prevToken.type === "Combinator") {
      scanner.pos -= prevTokenPos;
      scanner.error("Unexpected combinator");
    }
    return {
      type: "Group",
      terms,
      combinator: regroupTerms(terms, combinators) || " ",
      disallowEmpty: false,
      explicit: false
    };
  }
  function readGroup(scanner, stopCharCode) {
    let result;
    scanner.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(scanner, stopCharCode);
    scanner.eat(RIGHTSQUAREBRACKET);
    result.explicit = true;
    if (scanner.charCode() === EXCLAMATIONMARK$2) {
      scanner.pos++;
      result.disallowEmpty = true;
    }
    return result;
  }
  function peek(scanner, stopCharCode) {
    let code2 = scanner.charCode();
    switch (code2) {
      case RIGHTSQUAREBRACKET:
        break;
      case LEFTSQUAREBRACKET:
        return maybeMultiplied(scanner, readGroup(scanner, stopCharCode));
      case LESSTHANSIGN$1:
        return scanner.nextCharCode() === APOSTROPHE$2 ? readProperty$1(scanner) : readType(scanner);
      case VERTICALLINE$3:
        return {
          type: "Combinator",
          value: scanner.substringToPos(scanner.pos + (scanner.nextCharCode() === VERTICALLINE$3 ? 2 : 1))
        };
      case AMPERSAND$5:
        scanner.pos++;
        scanner.eat(AMPERSAND$5);
        return {
          type: "Combinator",
          value: "&&"
        };
      case COMMA:
        scanner.pos++;
        return {
          type: "Comma"
        };
      case APOSTROPHE$2:
        return maybeMultiplied(scanner, {
          type: "String",
          value: scanner.scanString()
        });
      case SPACE$2:
      case TAB:
      case N$1:
      case R:
      case F:
        return {
          type: "Spaces",
          value: scanner.scanSpaces()
        };
      case COMMERCIALAT:
        code2 = scanner.nextCharCode();
        if (scanner.isNameCharCode(code2)) {
          scanner.pos++;
          return {
            type: "AtKeyword",
            name: scanner.scanWord()
          };
        }
        return maybeToken(scanner);
      case ASTERISK$6:
      case PLUSSIGN$6:
      case QUESTIONMARK$1:
      case NUMBERSIGN$3:
      case EXCLAMATIONMARK$2:
        break;
      case LEFTCURLYBRACKET:
        code2 = scanner.nextCharCode();
        if (code2 < 48 || code2 > 57) {
          return maybeToken(scanner);
        }
        break;
      default:
        if (scanner.isNameCharCode(code2)) {
          return readKeywordOrFunction(scanner);
        }
        return maybeToken(scanner);
    }
  }
  function parse$O(source) {
    const scanner = new Scanner(source);
    const result = readImplicitGroup(scanner);
    if (scanner.pos !== source.length) {
      scanner.error("Unexpected input");
    }
    if (result.terms.length === 1 && result.terms[0].type === "Group") {
      return result.terms[0];
    }
    return result;
  }
  const noop = function() {
  };
  function ensureFunction(value2) {
    return typeof value2 === "function" ? value2 : noop;
  }
  function walk$1(node2, options2, context2) {
    function walk2(node3) {
      enter.call(context2, node3);
      switch (node3.type) {
        case "Group":
          node3.terms.forEach(walk2);
          break;
        case "Multiplier":
        case "Boolean":
          walk2(node3.term);
          break;
        case "Type":
        case "Property":
        case "Keyword":
        case "AtKeyword":
        case "Function":
        case "String":
        case "Token":
        case "Comma":
          break;
        default:
          throw new Error("Unknown type: " + node3.type);
      }
      leave.call(context2, node3);
    }
    let enter = noop;
    let leave = noop;
    if (typeof options2 === "function") {
      enter = options2;
    } else if (options2) {
      enter = ensureFunction(options2.enter);
      leave = ensureFunction(options2.leave);
    }
    if (enter === noop && leave === noop) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walk2(node2);
  }
  const astToTokens = {
    decorator(handlers) {
      const tokens = [];
      let curNode = null;
      return {
        ...handlers,
        node(node2) {
          const tmp = curNode;
          curNode = node2;
          handlers.node.call(this, node2);
          curNode = tmp;
        },
        emit(value2, type2, auto) {
          tokens.push({
            type: type2,
            value: value2,
            node: auto ? null : curNode
          });
        },
        result() {
          return tokens;
        }
      };
    }
  };
  function stringToTokens(str) {
    const tokens = [];
    tokenize$1(str, (type2, start, end) => tokens.push({
      type: type2,
      value: str.slice(start, end),
      node: null
    }));
    return tokens;
  }
  function prepareTokens(value2, syntax2) {
    if (typeof value2 === "string") {
      return stringToTokens(value2);
    }
    return syntax2.generate(value2, astToTokens);
  }
  const MATCH = {
    type: "Match"
  };
  const MISMATCH = {
    type: "Mismatch"
  };
  const DISALLOW_EMPTY = {
    type: "DisallowEmpty"
  };
  const LEFTPARENTHESIS$1 = 40;
  const RIGHTPARENTHESIS$1 = 41;
  function createCondition(match2, thenBranch, elseBranch) {
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
      return match2;
    }
    if (match2 === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
      return match2;
    }
    if (match2.type === "If" && match2.else === MISMATCH && thenBranch === MATCH) {
      thenBranch = match2.then;
      match2 = match2.match;
    }
    return {
      type: "If",
      match: match2,
      then: thenBranch,
      else: elseBranch
    };
  }
  function isFunctionType(name2) {
    return name2.length > 2 && name2.charCodeAt(name2.length - 2) === LEFTPARENTHESIS$1 && name2.charCodeAt(name2.length - 1) === RIGHTPARENTHESIS$1;
  }
  function isEnumCapatible(term) {
    return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
  }
  function groupNode(terms, combinator = " ", explicit = false) {
    return {
      type: "Group",
      terms,
      combinator,
      disallowEmpty: false,
      explicit
    };
  }
  function replaceTypeInGraph(node2, replacements, visited = /* @__PURE__ */ new Set()) {
    if (!visited.has(node2)) {
      visited.add(node2);
      switch (node2.type) {
        case "If":
          node2.match = replaceTypeInGraph(node2.match, replacements, visited);
          node2.then = replaceTypeInGraph(node2.then, replacements, visited);
          node2.else = replaceTypeInGraph(node2.else, replacements, visited);
          break;
        case "Type":
          return replacements[node2.name] || node2;
      }
    }
    return node2;
  }
  function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
      case " ": {
        let result = MATCH;
        for (let i22 = terms.length - 1; i22 >= 0; i22--) {
          const term = terms[i22];
          result = createCondition(term, result, MISMATCH);
        }
        return result;
      }
      case "|": {
        let result = MISMATCH;
        let map = null;
        for (let i22 = terms.length - 1; i22 >= 0; i22--) {
          let term = terms[i22];
          if (isEnumCapatible(term)) {
            if (map === null && i22 > 0 && isEnumCapatible(terms[i22 - 1])) {
              map = /* @__PURE__ */ Object.create(null);
              result = createCondition({
                type: "Enum",
                map
              }, MATCH, result);
            }
            if (map !== null) {
              const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
              if (key in map === false) {
                map[key] = term;
                continue;
              }
            }
          }
          map = null;
          result = createCondition(term, MATCH, result);
        }
        return result;
      }
      case "&&": {
        if (terms.length > 5) {
          return {
            type: "MatchOnce",
            terms,
            all: true
          };
        }
        let result = MISMATCH;
        for (let i22 = terms.length - 1; i22 >= 0; i22--) {
          const term = terms[i22];
          let thenClause;
          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(combinator, terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }), false);
          } else {
            thenClause = MATCH;
          }
          result = createCondition(term, thenClause, result);
        }
        return result;
      }
      case "||": {
        if (terms.length > 5) {
          return {
            type: "MatchOnce",
            terms,
            all: false
          };
        }
        let result = atLeastOneTermMatched ? MATCH : MISMATCH;
        for (let i22 = terms.length - 1; i22 >= 0; i22--) {
          const term = terms[i22];
          let thenClause;
          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(combinator, terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }), true);
          } else {
            thenClause = MATCH;
          }
          result = createCondition(term, thenClause, result);
        }
        return result;
      }
    }
  }
  function buildMultiplierMatchGraph(node2) {
    let result = MATCH;
    let matchTerm = buildMatchGraphInternal(node2.term);
    if (node2.max === 0) {
      matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH);
      result = createCondition(matchTerm, null, MISMATCH);
      result.then = createCondition(MATCH, MATCH, result);
      if (node2.comma) {
        result.then.else = createCondition({
          type: "Comma",
          syntax: node2
        }, result, MISMATCH);
      }
    } else {
      for (let i22 = node2.min || 1; i22 <= node2.max; i22++) {
        if (node2.comma && result !== MATCH) {
          result = createCondition({
            type: "Comma",
            syntax: node2
          }, result, MISMATCH);
        }
        result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);
      }
    }
    if (node2.min === 0) {
      result = createCondition(MATCH, MATCH, result);
    } else {
      for (let i22 = 0; i22 < node2.min - 1; i22++) {
        if (node2.comma && result !== MATCH) {
          result = createCondition({
            type: "Comma",
            syntax: node2
          }, result, MISMATCH);
        }
        result = createCondition(matchTerm, result, MISMATCH);
      }
    }
    return result;
  }
  function buildMatchGraphInternal(node2) {
    if (typeof node2 === "function") {
      return {
        type: "Generic",
        fn: node2
      };
    }
    switch (node2.type) {
      case "Group": {
        let result = buildGroupMatchGraph(node2.combinator, node2.terms.map(buildMatchGraphInternal), false);
        if (node2.disallowEmpty) {
          result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
        }
        return result;
      }
      case "Multiplier":
        return buildMultiplierMatchGraph(node2);
      case "Boolean": {
        const term = buildMatchGraphInternal(node2.term);
        const matchNode = buildMatchGraphInternal(groupNode([
          groupNode([
            {
              type: "Keyword",
              name: "not"
            },
            {
              type: "Type",
              name: "!boolean-group"
            }
          ]),
          groupNode([
            {
              type: "Type",
              name: "!boolean-group"
            },
            groupNode([
              {
                type: "Multiplier",
                comma: false,
                min: 0,
                max: 0,
                term: groupNode([
                  {
                    type: "Keyword",
                    name: "and"
                  },
                  {
                    type: "Type",
                    name: "!boolean-group"
                  }
                ])
              },
              {
                type: "Multiplier",
                comma: false,
                min: 0,
                max: 0,
                term: groupNode([
                  {
                    type: "Keyword",
                    name: "or"
                  },
                  {
                    type: "Type",
                    name: "!boolean-group"
                  }
                ])
              }
            ], "|")
          ])
        ], "|"));
        const booleanGroup = buildMatchGraphInternal(groupNode([
          {
            type: "Type",
            name: "!term"
          },
          groupNode([
            {
              type: "Token",
              value: "("
            },
            {
              type: "Type",
              name: "!self"
            },
            {
              type: "Token",
              value: ")"
            }
          ]),
          {
            type: "Type",
            name: "general-enclosed"
          }
        ], "|"));
        replaceTypeInGraph(booleanGroup, {
          "!term": term,
          "!self": matchNode
        });
        replaceTypeInGraph(matchNode, {
          "!boolean-group": booleanGroup
        });
        return matchNode;
      }
      case "Type":
      case "Property":
        return {
          type: node2.type,
          name: node2.name,
          syntax: node2
        };
      case "Keyword":
        return {
          type: node2.type,
          name: node2.name.toLowerCase(),
          syntax: node2
        };
      case "AtKeyword":
        return {
          type: node2.type,
          name: "@" + node2.name.toLowerCase(),
          syntax: node2
        };
      case "Function":
        return {
          type: node2.type,
          name: node2.name.toLowerCase() + "(",
          syntax: node2
        };
      case "String":
        if (node2.value.length === 3) {
          return {
            type: "Token",
            value: node2.value.charAt(1),
            syntax: node2
          };
        }
        return {
          type: node2.type,
          value: node2.value.substr(1, node2.value.length - 2).replace(/\\'/g, "'"),
          syntax: node2
        };
      case "Token":
        return {
          type: node2.type,
          value: node2.value,
          syntax: node2
        };
      case "Comma":
        return {
          type: node2.type,
          syntax: node2
        };
      default:
        throw new Error("Unknown node type:", node2.type);
    }
  }
  function buildMatchGraph(syntaxTree, ref2) {
    if (typeof syntaxTree === "string") {
      syntaxTree = parse$O(syntaxTree);
    }
    return {
      type: "MatchGraph",
      match: buildMatchGraphInternal(syntaxTree),
      syntax: ref2 || null,
      source: syntaxTree
    };
  }
  const { hasOwnProperty: hasOwnProperty$2 } = Object.prototype;
  const STUB = 0;
  const TOKEN = 1;
  const OPEN_SYNTAX = 2;
  const CLOSE_SYNTAX = 3;
  const EXIT_REASON_MATCH = "Match";
  const EXIT_REASON_MISMATCH = "Mismatch";
  const EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
  const ITERATION_LIMIT = 15e3;
  function reverseList(list2) {
    let prev = null;
    let next2 = null;
    let item = list2;
    while (item !== null) {
      next2 = item.prev;
      item.prev = prev;
      prev = item;
      item = next2;
    }
    return prev;
  }
  function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
      return false;
    }
    for (let i22 = 0; i22 < testStr.length; i22++) {
      const referenceCode = referenceStr.charCodeAt(i22);
      let testCode = testStr.charCodeAt(i22);
      if (testCode >= 65 && testCode <= 90) {
        testCode = testCode | 32;
      }
      if (testCode !== referenceCode) {
        return false;
      }
    }
    return true;
  }
  function isContextEdgeDelim(token) {
    if (token.type !== Delim) {
      return false;
    }
    return token.value !== "?";
  }
  function isCommaContextStart(token) {
    if (token === null) {
      return true;
    }
    return token.type === Comma || token.type === Function$2 || token.type === LeftParenthesis || token.type === LeftSquareBracket || token.type === LeftCurlyBracket || isContextEdgeDelim(token);
  }
  function isCommaContextEnd(token) {
    if (token === null) {
      return true;
    }
    return token.type === RightParenthesis || token.type === RightSquareBracket || token.type === RightCurlyBracket || token.type === Delim && token.value === "/";
  }
  function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
      do {
        tokenIndex++;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
      } while (token !== null && (token.type === WhiteSpace$1 || token.type === Comment$1));
    }
    function getNextToken(offset) {
      const nextIndex = tokenIndex + offset;
      return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }
    function stateSnapshotFromSyntax(nextState, prev) {
      return {
        nextState,
        matchStack,
        syntaxStack,
        thenStack,
        tokenIndex,
        prev
      };
    }
    function pushThenStack(nextState) {
      thenStack = {
        nextState,
        matchStack,
        syntaxStack,
        prev: thenStack
      };
    }
    function pushElseStack(nextState) {
      elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }
    function addTokenToMatch() {
      matchStack = {
        type: TOKEN,
        syntax: state.syntax,
        token,
        prev: matchStack
      };
      moveToNextToken();
      syntaxStash = null;
      if (tokenIndex > longestMatch) {
        longestMatch = tokenIndex;
      }
    }
    function openSyntax() {
      syntaxStack = {
        syntax: state.syntax,
        opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
        prev: syntaxStack
      };
      matchStack = {
        type: OPEN_SYNTAX,
        syntax: state.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    function closeSyntax() {
      if (matchStack.type === OPEN_SYNTAX) {
        matchStack = matchStack.prev;
      } else {
        matchStack = {
          type: CLOSE_SYNTAX,
          syntax: syntaxStack.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }
      syntaxStack = syntaxStack.prev;
    }
    let syntaxStack = null;
    let thenStack = null;
    let elseStack = null;
    let syntaxStash = null;
    let iterationCount = 0;
    let exitReason = null;
    let token = null;
    let tokenIndex = -1;
    let longestMatch = 0;
    let matchStack = {
      type: STUB,
      syntax: null,
      token: null,
      prev: null
    };
    moveToNextToken();
    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
      switch (state.type) {
        case "Match":
          if (thenStack === null) {
            if (token !== null) {
              if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
                state = MISMATCH;
                break;
              }
            }
            exitReason = EXIT_REASON_MATCH;
            break;
          }
          state = thenStack.nextState;
          if (state === DISALLOW_EMPTY) {
            if (thenStack.matchStack === matchStack) {
              state = MISMATCH;
              break;
            } else {
              state = MATCH;
            }
          }
          while (thenStack.syntaxStack !== syntaxStack) {
            closeSyntax();
          }
          thenStack = thenStack.prev;
          break;
        case "Mismatch":
          if (syntaxStash !== null && syntaxStash !== false) {
            if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
              elseStack = syntaxStash;
              syntaxStash = false;
            }
          } else if (elseStack === null) {
            exitReason = EXIT_REASON_MISMATCH;
            break;
          }
          state = elseStack.nextState;
          thenStack = elseStack.thenStack;
          syntaxStack = elseStack.syntaxStack;
          matchStack = elseStack.matchStack;
          tokenIndex = elseStack.tokenIndex;
          token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
          elseStack = elseStack.prev;
          break;
        case "MatchGraph":
          state = state.match;
          break;
        case "If":
          if (state.else !== MISMATCH) {
            pushElseStack(state.else);
          }
          if (state.then !== MATCH) {
            pushThenStack(state.then);
          }
          state = state.match;
          break;
        case "MatchOnce":
          state = {
            type: "MatchOnceBuffer",
            syntax: state,
            index: 0,
            mask: 0
          };
          break;
        case "MatchOnceBuffer": {
          const terms = state.syntax.terms;
          if (state.index === terms.length) {
            if (state.mask === 0 || state.syntax.all) {
              state = MISMATCH;
              break;
            }
            state = MATCH;
            break;
          }
          if (state.mask === (1 << terms.length) - 1) {
            state = MATCH;
            break;
          }
          for (; state.index < terms.length; state.index++) {
            const matchFlag = 1 << state.index;
            if ((state.mask & matchFlag) === 0) {
              pushElseStack(state);
              pushThenStack({
                type: "AddMatchOnce",
                syntax: state.syntax,
                mask: state.mask | matchFlag
              });
              state = terms[state.index++];
              break;
            }
          }
          break;
        }
        case "AddMatchOnce":
          state = {
            type: "MatchOnceBuffer",
            syntax: state.syntax,
            index: 0,
            mask: state.mask
          };
          break;
        case "Enum":
          if (token !== null) {
            let name2 = token.value.toLowerCase();
            if (name2.indexOf("\\") !== -1) {
              name2 = name2.replace(/\\[09].*$/, "");
            }
            if (hasOwnProperty$2.call(state.map, name2)) {
              state = state.map[name2];
              break;
            }
          }
          state = MISMATCH;
          break;
        case "Generic": {
          const opts = syntaxStack !== null ? syntaxStack.opts : null;
          const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
          if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
            while (tokenIndex < lastTokenIndex2) {
              addTokenToMatch();
            }
            state = MATCH;
          } else {
            state = MISMATCH;
          }
          break;
        }
        case "Type":
        case "Property": {
          const syntaxDict = state.type === "Type" ? "types" : "properties";
          const dictSyntax = hasOwnProperty$2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
          if (!dictSyntax || !dictSyntax.match) {
            throw new Error("Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>"));
          }
          if (syntaxStash !== false && token !== null && state.type === "Type") {
            const lowPriorityMatching = state.name === "custom-ident" && token.type === Ident || state.name === "length" && token.value === "0";
            if (lowPriorityMatching) {
              if (syntaxStash === null) {
                syntaxStash = stateSnapshotFromSyntax(state, elseStack);
              }
              state = MISMATCH;
              break;
            }
          }
          openSyntax();
          state = dictSyntax.matchRef || dictSyntax.match;
          break;
        }
        case "Keyword": {
          const name2 = state.name;
          if (token !== null) {
            let keywordName = token.value;
            if (keywordName.indexOf("\\") !== -1) {
              keywordName = keywordName.replace(/\\[09].*$/, "");
            }
            if (areStringsEqualCaseInsensitive(keywordName, name2)) {
              addTokenToMatch();
              state = MATCH;
              break;
            }
          }
          state = MISMATCH;
          break;
        }
        case "AtKeyword":
        case "Function":
          if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
          state = MISMATCH;
          break;
        case "Token":
          if (token !== null && token.value === state.value) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
          state = MISMATCH;
          break;
        case "Comma":
          if (token !== null && token.type === Comma) {
            if (isCommaContextStart(matchStack.token)) {
              state = MISMATCH;
            } else {
              addTokenToMatch();
              state = isCommaContextEnd(token) ? MISMATCH : MATCH;
            }
          } else {
            state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
          }
          break;
        case "String":
          let string = "";
          let lastTokenIndex = tokenIndex;
          for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
            string += tokens[lastTokenIndex].value;
          }
          if (areStringsEqualCaseInsensitive(string, state.value)) {
            while (tokenIndex < lastTokenIndex) {
              addTokenToMatch();
            }
            state = MATCH;
          } else {
            state = MISMATCH;
          }
          break;
        default:
          throw new Error("Unknown node type: " + state.type);
      }
    }
    switch (exitReason) {
      case null:
        console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
        exitReason = EXIT_REASON_ITERATION_LIMIT;
        matchStack = null;
        break;
      case EXIT_REASON_MATCH:
        while (syntaxStack !== null) {
          closeSyntax();
        }
        break;
      default:
        matchStack = null;
    }
    return {
      tokens,
      reason: exitReason,
      iterations: iterationCount,
      match: matchStack,
      longestMatch
    };
  }
  function matchAsTree(tokens, matchGraph, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
    if (matchResult.match === null) {
      return matchResult;
    }
    let item = matchResult.match;
    let host = matchResult.match = {
      syntax: matchGraph.syntax || null,
      match: []
    };
    const hostStack = [
      host
    ];
    item = reverseList(item).prev;
    while (item !== null) {
      switch (item.type) {
        case OPEN_SYNTAX:
          host.match.push(host = {
            syntax: item.syntax,
            match: []
          });
          hostStack.push(host);
          break;
        case CLOSE_SYNTAX:
          hostStack.pop();
          host = hostStack[hostStack.length - 1];
          break;
        default:
          host.match.push({
            syntax: item.syntax || null,
            token: item.token.value,
            node: item.token.node
          });
      }
      item = item.prev;
    }
    return matchResult;
  }
  function getTrace(node2) {
    function shouldPutToTrace(syntax2) {
      if (syntax2 === null) {
        return false;
      }
      return syntax2.type === "Type" || syntax2.type === "Property" || syntax2.type === "Keyword";
    }
    function hasMatch(matchNode) {
      if (Array.isArray(matchNode.match)) {
        for (let i22 = 0; i22 < matchNode.match.length; i22++) {
          if (hasMatch(matchNode.match[i22])) {
            if (shouldPutToTrace(matchNode.syntax)) {
              result.unshift(matchNode.syntax);
            }
            return true;
          }
        }
      } else if (matchNode.node === node2) {
        result = shouldPutToTrace(matchNode.syntax) ? [
          matchNode.syntax
        ] : [];
        return true;
      }
      return false;
    }
    let result = null;
    if (this.matched !== null) {
      hasMatch(this.matched);
    }
    return result;
  }
  function isType(node2, type2) {
    return testNode(this, node2, (match2) => match2.type === "Type" && match2.name === type2);
  }
  function isProperty(node2, property2) {
    return testNode(this, node2, (match2) => match2.type === "Property" && match2.name === property2);
  }
  function isKeyword(node2) {
    return testNode(this, node2, (match2) => match2.type === "Keyword");
  }
  function testNode(match2, node2, fn22) {
    const trace2 = getTrace.call(match2, node2);
    if (trace2 === null) {
      return false;
    }
    return trace2.some(fn22);
  }
  const trace = Object.freeze(Object.defineProperty({
    __proto__: null,
    getTrace,
    isKeyword,
    isProperty,
    isType
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function getFirstMatchNode(matchNode) {
    if ("node" in matchNode) {
      return matchNode.node;
    }
    return getFirstMatchNode(matchNode.match[0]);
  }
  function getLastMatchNode(matchNode) {
    if ("node" in matchNode) {
      return matchNode.node;
    }
    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
  }
  function matchFragments(lexer2, ast, match2, type2, name2) {
    function findFragments(matchNode) {
      if (matchNode.syntax !== null && matchNode.syntax.type === type2 && matchNode.syntax.name === name2) {
        const start = getFirstMatchNode(matchNode);
        const end = getLastMatchNode(matchNode);
        lexer2.syntax.walk(ast, function(node2, item, list2) {
          if (node2 === start) {
            const nodes = new List();
            do {
              nodes.appendData(item.data);
              if (item.data === end) {
                break;
              }
              item = item.next;
            } while (item !== null);
            fragments.push({
              parent: list2,
              nodes
            });
          }
        });
      }
      if (Array.isArray(matchNode.match)) {
        matchNode.match.forEach(findFragments);
      }
    }
    const fragments = [];
    if (match2.matched !== null) {
      findFragments(match2.matched);
    }
    return fragments;
  }
  const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
  function isValidNumber(value2) {
    return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2 && value2 >= 0;
  }
  function isValidLocation(loc) {
    return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
  }
  function createNodeStructureChecker(type2, fields) {
    return function checkNode(node2, warn) {
      if (!node2 || node2.constructor !== Object) {
        return warn(node2, "Type of node should be an Object");
      }
      for (let key in node2) {
        let valid = true;
        if (hasOwnProperty$1.call(node2, key) === false) {
          continue;
        }
        if (key === "type") {
          if (node2.type !== type2) {
            warn(node2, "Wrong node type `" + node2.type + "`, expected `" + type2 + "`");
          }
        } else if (key === "loc") {
          if (node2.loc === null) {
            continue;
          } else if (node2.loc && node2.loc.constructor === Object) {
            if (typeof node2.loc.source !== "string") {
              key += ".source";
            } else if (!isValidLocation(node2.loc.start)) {
              key += ".start";
            } else if (!isValidLocation(node2.loc.end)) {
              key += ".end";
            } else {
              continue;
            }
          }
          valid = false;
        } else if (fields.hasOwnProperty(key)) {
          valid = false;
          for (let i22 = 0; !valid && i22 < fields[key].length; i22++) {
            const fieldType = fields[key][i22];
            switch (fieldType) {
              case String:
                valid = typeof node2[key] === "string";
                break;
              case Boolean:
                valid = typeof node2[key] === "boolean";
                break;
              case null:
                valid = node2[key] === null;
                break;
              default:
                if (typeof fieldType === "string") {
                  valid = node2[key] && node2[key].type === fieldType;
                } else if (Array.isArray(fieldType)) {
                  valid = node2[key] instanceof List;
                }
            }
          }
        } else {
          warn(node2, "Unknown field `" + key + "` for " + type2 + " node type");
        }
        if (!valid) {
          warn(node2, "Bad value for `" + type2 + "." + key + "`");
        }
      }
      for (const key in fields) {
        if (hasOwnProperty$1.call(fields, key) && hasOwnProperty$1.call(node2, key) === false) {
          warn(node2, "Field `" + type2 + "." + key + "` is missed");
        }
      }
    };
  }
  function genTypesList(fieldTypes, path22) {
    const docsTypes = [];
    for (let i22 = 0; i22 < fieldTypes.length; i22++) {
      const fieldType = fieldTypes[i22];
      if (fieldType === String || fieldType === Boolean) {
        docsTypes.push(fieldType.name.toLowerCase());
      } else if (fieldType === null) {
        docsTypes.push("null");
      } else if (typeof fieldType === "string") {
        docsTypes.push(fieldType);
      } else if (Array.isArray(fieldType)) {
        docsTypes.push("List<" + (genTypesList(fieldType, path22) || "any") + ">");
      } else {
        throw new Error("Wrong value `" + fieldType + "` in `" + path22 + "` structure definition");
      }
    }
    return docsTypes.join(" | ");
  }
  function processStructure(name2, nodeType) {
    const structure2 = nodeType.structure;
    const fields = {
      type: String,
      loc: true
    };
    const docs = {
      type: '"' + name2 + '"'
    };
    for (const key in structure2) {
      if (hasOwnProperty$1.call(structure2, key) === false) {
        continue;
      }
      const fieldTypes = fields[key] = Array.isArray(structure2[key]) ? structure2[key].slice() : [
        structure2[key]
      ];
      docs[key] = genTypesList(fieldTypes, name2 + "." + key);
    }
    return {
      docs,
      check: createNodeStructureChecker(name2, fields)
    };
  }
  function getStructureFromConfig(config) {
    const structure2 = {};
    if (config.node) {
      for (const name2 in config.node) {
        if (hasOwnProperty$1.call(config.node, name2)) {
          const nodeType = config.node[name2];
          if (nodeType.structure) {
            structure2[name2] = processStructure(name2, nodeType);
          } else {
            throw new Error("Missed `structure` field in `" + name2 + "` node type definition");
          }
        }
      }
    }
    return structure2;
  }
  function dumpMapSyntax(map, compact, syntaxAsAst) {
    const result = {};
    for (const name2 in map) {
      if (map[name2].syntax) {
        result[name2] = syntaxAsAst ? map[name2].syntax : generate$O(map[name2].syntax, {
          compact
        });
      }
    }
    return result;
  }
  function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};
    for (const [name2, atrule2] of Object.entries(map)) {
      result[name2] = {
        prelude: atrule2.prelude && (syntaxAsAst ? atrule2.prelude.syntax : generate$O(atrule2.prelude.syntax, {
          compact
        })),
        descriptors: atrule2.descriptors && dumpMapSyntax(atrule2.descriptors, compact, syntaxAsAst)
      };
    }
    return result;
  }
  function valueHasVar(tokens) {
    for (let i22 = 0; i22 < tokens.length; i22++) {
      if (tokens[i22].value.toLowerCase() === "var(") {
        return true;
      }
    }
    return false;
  }
  function syntaxHasTopLevelCommaMultiplier(syntax2) {
    const singleTerm = syntax2.terms[0];
    return syntax2.explicit === false && syntax2.terms.length === 1 && singleTerm.type === "Multiplier" && singleTerm.comma === true;
  }
  function buildMatchResult(matched, error, iterations) {
    return {
      matched,
      iterations,
      error,
      ...trace
    };
  }
  function matchSyntax(lexer2, syntax2, value2, useCssWideKeywords) {
    const tokens = prepareTokens(value2, lexer2.syntax);
    let result;
    if (valueHasVar(tokens)) {
      return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
    }
    if (useCssWideKeywords) {
      result = matchAsTree(tokens, lexer2.cssWideKeywordsSyntax, lexer2);
    }
    if (!useCssWideKeywords || !result.match) {
      result = matchAsTree(tokens, syntax2.match, lexer2);
      if (!result.match) {
        return buildMatchResult(null, new SyntaxMatchError(result.reason, syntax2.syntax, value2, result), result.iterations);
      }
    }
    return buildMatchResult(result.match, null, result.iterations);
  }
  class Lexer {
    constructor(config, syntax2, structure2) {
      this.cssWideKeywords = cssWideKeywords;
      this.syntax = syntax2;
      this.generic = false;
      this.units = {
        ...units
      };
      this.atrules = /* @__PURE__ */ Object.create(null);
      this.properties = /* @__PURE__ */ Object.create(null);
      this.types = /* @__PURE__ */ Object.create(null);
      this.structure = structure2 || getStructureFromConfig(config);
      if (config) {
        if (config.cssWideKeywords) {
          this.cssWideKeywords = config.cssWideKeywords;
        }
        if (config.units) {
          for (const group of Object.keys(units)) {
            if (Array.isArray(config.units[group])) {
              this.units[group] = config.units[group];
            }
          }
        }
        if (config.types) {
          for (const [name2, type2] of Object.entries(config.types)) {
            this.addType_(name2, type2);
          }
        }
        if (config.generic) {
          this.generic = true;
          for (const [name2, value2] of Object.entries(createGenericTypes(this.units))) {
            this.addType_(name2, value2);
          }
        }
        if (config.atrules) {
          for (const [name2, atrule2] of Object.entries(config.atrules)) {
            this.addAtrule_(name2, atrule2);
          }
        }
        if (config.properties) {
          for (const [name2, property2] of Object.entries(config.properties)) {
            this.addProperty_(name2, property2);
          }
        }
      }
      this.cssWideKeywordsSyntax = buildMatchGraph(this.cssWideKeywords.join(" |  "));
    }
    checkStructure(ast) {
      function collectWarning(node2, message) {
        warns.push({
          node: node2,
          message
        });
      }
      const structure2 = this.structure;
      const warns = [];
      this.syntax.walk(ast, function(node2) {
        if (structure2.hasOwnProperty(node2.type)) {
          structure2[node2.type].check(node2, collectWarning);
        } else {
          collectWarning(node2, "Unknown node type `" + node2.type + "`");
        }
      });
      return warns.length ? warns : false;
    }
    createDescriptor(syntax2, type2, name2, parent = null) {
      const ref2 = {
        type: type2,
        name: name2
      };
      const descriptor = {
        type: type2,
        name: name2,
        parent,
        serializable: typeof syntax2 === "string" || syntax2 && typeof syntax2.type === "string",
        syntax: null,
        match: null,
        matchRef: null
      };
      if (typeof syntax2 === "function") {
        descriptor.match = buildMatchGraph(syntax2, ref2);
      } else {
        if (typeof syntax2 === "string") {
          Object.defineProperty(descriptor, "syntax", {
            get() {
              Object.defineProperty(descriptor, "syntax", {
                value: parse$O(syntax2)
              });
              return descriptor.syntax;
            }
          });
        } else {
          descriptor.syntax = syntax2;
        }
        Object.defineProperty(descriptor, "match", {
          get() {
            Object.defineProperty(descriptor, "match", {
              value: buildMatchGraph(descriptor.syntax, ref2)
            });
            return descriptor.match;
          }
        });
        if (type2 === "Property") {
          Object.defineProperty(descriptor, "matchRef", {
            get() {
              const syntax3 = descriptor.syntax;
              const value2 = syntaxHasTopLevelCommaMultiplier(syntax3) ? buildMatchGraph({
                ...syntax3,
                terms: [
                  syntax3.terms[0].term
                ]
              }, ref2) : null;
              Object.defineProperty(descriptor, "matchRef", {
                value: value2
              });
              return value2;
            }
          });
        }
      }
      return descriptor;
    }
    addAtrule_(name2, syntax2) {
      if (!syntax2) {
        return;
      }
      this.atrules[name2] = {
        type: "Atrule",
        name: name2,
        prelude: syntax2.prelude ? this.createDescriptor(syntax2.prelude, "AtrulePrelude", name2) : null,
        descriptors: syntax2.descriptors ? Object.keys(syntax2.descriptors).reduce((map, descName) => {
          map[descName] = this.createDescriptor(syntax2.descriptors[descName], "AtruleDescriptor", descName, name2);
          return map;
        }, /* @__PURE__ */ Object.create(null)) : null
      };
    }
    addProperty_(name2, syntax2) {
      if (!syntax2) {
        return;
      }
      this.properties[name2] = this.createDescriptor(syntax2, "Property", name2);
    }
    addType_(name2, syntax2) {
      if (!syntax2) {
        return;
      }
      this.types[name2] = this.createDescriptor(syntax2, "Type", name2);
    }
    checkAtruleName(atruleName) {
      if (!this.getAtrule(atruleName)) {
        return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
      }
    }
    checkAtrulePrelude(atruleName, prelude) {
      const error = this.checkAtruleName(atruleName);
      if (error) {
        return error;
      }
      const atrule2 = this.getAtrule(atruleName);
      if (!atrule2.prelude && prelude) {
        return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
      }
      if (atrule2.prelude && !prelude) {
        if (!matchSyntax(this, atrule2.prelude, "", false).matched) {
          return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
        }
      }
    }
    checkAtruleDescriptorName(atruleName, descriptorName) {
      const error = this.checkAtruleName(atruleName);
      if (error) {
        return error;
      }
      const atrule2 = this.getAtrule(atruleName);
      const descriptor = keyword(descriptorName);
      if (!atrule2.descriptors) {
        return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
      }
      if (!atrule2.descriptors[descriptor.name] && !atrule2.descriptors[descriptor.basename]) {
        return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
      }
    }
    checkPropertyName(propertyName) {
      if (!this.getProperty(propertyName)) {
        return new SyntaxReferenceError("Unknown property", propertyName);
      }
    }
    matchAtrulePrelude(atruleName, prelude) {
      const error = this.checkAtrulePrelude(atruleName, prelude);
      if (error) {
        return buildMatchResult(null, error);
      }
      const atrule2 = this.getAtrule(atruleName);
      if (!atrule2.prelude) {
        return buildMatchResult(null, null);
      }
      return matchSyntax(this, atrule2.prelude, prelude || "", false);
    }
    matchAtruleDescriptor(atruleName, descriptorName, value2) {
      const error = this.checkAtruleDescriptorName(atruleName, descriptorName);
      if (error) {
        return buildMatchResult(null, error);
      }
      const atrule2 = this.getAtrule(atruleName);
      const descriptor = keyword(descriptorName);
      return matchSyntax(this, atrule2.descriptors[descriptor.name] || atrule2.descriptors[descriptor.basename], value2, false);
    }
    matchDeclaration(node2) {
      if (node2.type !== "Declaration") {
        return buildMatchResult(null, new Error("Not a Declaration node"));
      }
      return this.matchProperty(node2.property, node2.value);
    }
    matchProperty(propertyName, value2) {
      if (property(propertyName).custom) {
        return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
      }
      const error = this.checkPropertyName(propertyName);
      if (error) {
        return buildMatchResult(null, error);
      }
      return matchSyntax(this, this.getProperty(propertyName), value2, true);
    }
    matchType(typeName, value2) {
      const typeSyntax = this.getType(typeName);
      if (!typeSyntax) {
        return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
      }
      return matchSyntax(this, typeSyntax, value2, false);
    }
    match(syntax2, value2) {
      if (typeof syntax2 !== "string" && (!syntax2 || !syntax2.type)) {
        return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
      }
      if (typeof syntax2 === "string" || !syntax2.match) {
        syntax2 = this.createDescriptor(syntax2, "Type", "anonymous");
      }
      return matchSyntax(this, syntax2, value2, false);
    }
    findValueFragments(propertyName, value2, type2, name2) {
      return matchFragments(this, value2, this.matchProperty(propertyName, value2), type2, name2);
    }
    findDeclarationValueFragments(declaration, type2, name2) {
      return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type2, name2);
    }
    findAllFragments(ast, type2, name2) {
      const result = [];
      this.syntax.walk(ast, {
        visit: "Declaration",
        enter: (declaration) => {
          result.push.apply(result, this.findDeclarationValueFragments(declaration, type2, name2));
        }
      });
      return result;
    }
    getAtrule(atruleName, fallbackBasename = true) {
      const atrule2 = keyword(atruleName);
      const atruleEntry = atrule2.vendor && fallbackBasename ? this.atrules[atrule2.name] || this.atrules[atrule2.basename] : this.atrules[atrule2.name];
      return atruleEntry || null;
    }
    getAtrulePrelude(atruleName, fallbackBasename = true) {
      const atrule2 = this.getAtrule(atruleName, fallbackBasename);
      return atrule2 && atrule2.prelude || null;
    }
    getAtruleDescriptor(atruleName, name2) {
      return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name2] || null : null;
    }
    getProperty(propertyName, fallbackBasename = true) {
      const property$1 = property(propertyName);
      const propertyEntry = property$1.vendor && fallbackBasename ? this.properties[property$1.name] || this.properties[property$1.basename] : this.properties[property$1.name];
      return propertyEntry || null;
    }
    getType(name2) {
      return hasOwnProperty.call(this.types, name2) ? this.types[name2] : null;
    }
    validate() {
      function syntaxRef(name2, isType2) {
        return isType2 ? `<${name2}>` : `<'${name2}'>`;
      }
      function validate(syntax2, name2, broken, descriptor) {
        if (broken.has(name2)) {
          return broken.get(name2);
        }
        broken.set(name2, false);
        if (descriptor.syntax !== null) {
          walk$1(descriptor.syntax, function(node2) {
            if (node2.type !== "Type" && node2.type !== "Property") {
              return;
            }
            const map = node2.type === "Type" ? syntax2.types : syntax2.properties;
            const brokenMap = node2.type === "Type" ? brokenTypes : brokenProperties;
            if (!hasOwnProperty.call(map, node2.name)) {
              errors.push(`${syntaxRef(name2, broken === brokenTypes)} used missed syntax definition ${syntaxRef(node2.name, node2.type === "Type")}`);
              broken.set(name2, true);
            } else if (validate(syntax2, node2.name, brokenMap, map[node2.name])) {
              errors.push(`${syntaxRef(name2, broken === brokenTypes)} used broken syntax definition ${syntaxRef(node2.name, node2.type === "Type")}`);
              broken.set(name2, true);
            }
          }, this);
        }
      }
      const errors = [];
      let brokenTypes = /* @__PURE__ */ new Map();
      let brokenProperties = /* @__PURE__ */ new Map();
      for (const key in this.types) {
        validate(this, key, brokenTypes, this.types[key]);
      }
      for (const key in this.properties) {
        validate(this, key, brokenProperties, this.properties[key]);
      }
      const brokenTypesArray = [
        ...brokenTypes.keys()
      ].filter((name2) => brokenTypes.get(name2));
      const brokenPropertiesArray = [
        ...brokenProperties.keys()
      ].filter((name2) => brokenProperties.get(name2));
      if (brokenTypesArray.length || brokenPropertiesArray.length) {
        return {
          errors,
          types: brokenTypesArray,
          properties: brokenPropertiesArray
        };
      }
      return null;
    }
    dump(syntaxAsAst, pretty) {
      return {
        generic: this.generic,
        cssWideKeywords: this.cssWideKeywords,
        units: this.units,
        types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
        properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
        atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
      };
    }
    toString() {
      return JSON.stringify(this.dump());
    }
  }
  function appendOrSet(a, b) {
    if (typeof b === "string" && /^\s*\|/.test(b)) {
      return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
    }
    return b || null;
  }
  function sliceProps(obj, props) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const [key, value2] of Object.entries(obj)) {
      if (value2) {
        result[key] = {};
        for (const prop of Object.keys(value2)) {
          if (props.includes(prop)) {
            result[key][prop] = value2[prop];
          }
        }
      }
    }
    return result;
  }
  function mix(dest, src) {
    const result = {
      ...dest
    };
    for (const [prop, value2] of Object.entries(src)) {
      switch (prop) {
        case "generic":
          result[prop] = Boolean(value2);
          break;
        case "cssWideKeywords":
          result[prop] = dest[prop] ? [
            ...dest[prop],
            ...value2
          ] : value2 || [];
          break;
        case "units":
          result[prop] = {
            ...dest[prop]
          };
          for (const [name2, patch] of Object.entries(value2)) {
            result[prop][name2] = Array.isArray(patch) ? patch : [];
          }
          break;
        case "atrules":
          result[prop] = {
            ...dest[prop]
          };
          for (const [name2, atrule2] of Object.entries(value2)) {
            const exists = result[prop][name2] || {};
            const current = result[prop][name2] = {
              prelude: exists.prelude || null,
              descriptors: {
                ...exists.descriptors
              }
            };
            if (!atrule2) {
              continue;
            }
            current.prelude = atrule2.prelude ? appendOrSet(current.prelude, atrule2.prelude) : current.prelude || null;
            for (const [descriptorName, descriptorValue] of Object.entries(atrule2.descriptors || {})) {
              current.descriptors[descriptorName] = descriptorValue ? appendOrSet(current.descriptors[descriptorName], descriptorValue) : null;
            }
            if (!Object.keys(current.descriptors).length) {
              current.descriptors = null;
            }
          }
          break;
        case "types":
        case "properties":
          result[prop] = {
            ...dest[prop]
          };
          for (const [name2, syntax2] of Object.entries(value2)) {
            result[prop][name2] = appendOrSet(result[prop][name2], syntax2);
          }
          break;
        case "scope":
        case "features":
          result[prop] = {
            ...dest[prop]
          };
          for (const [name2, props] of Object.entries(value2)) {
            result[prop][name2] = {
              ...result[prop][name2],
              ...props
            };
          }
          break;
        case "parseContext":
          result[prop] = {
            ...dest[prop],
            ...value2
          };
          break;
        case "atrule":
        case "pseudo":
          result[prop] = {
            ...dest[prop],
            ...sliceProps(value2, [
              "parse"
            ])
          };
          break;
        case "node":
          result[prop] = {
            ...dest[prop],
            ...sliceProps(value2, [
              "name",
              "structure",
              "parse",
              "generate",
              "walkContext"
            ])
          };
          break;
      }
    }
    return result;
  }
  function createSyntax(config) {
    const parse2 = createParser(config);
    const walk2 = createWalker(config);
    const generate2 = createGenerator(config);
    const { fromPlainObject: fromPlainObject2, toPlainObject: toPlainObject2 } = createConvertor(walk2);
    const syntax2 = {
      lexer: null,
      createLexer: (config2) => new Lexer(config2, syntax2, syntax2.lexer.structure),
      tokenize: tokenize$1,
      parse: parse2,
      generate: generate2,
      walk: walk2,
      find: walk2.find,
      findLast: walk2.findLast,
      findAll: walk2.findAll,
      fromPlainObject: fromPlainObject2,
      toPlainObject: toPlainObject2,
      fork(extension) {
        const base = mix({}, config);
        return createSyntax(typeof extension === "function" ? extension(base) : mix(base, extension));
      }
    };
    syntax2.lexer = new Lexer({
      generic: config.generic,
      cssWideKeywords: config.cssWideKeywords,
      units: config.units,
      types: config.types,
      atrules: config.atrules,
      properties: config.properties,
      node: config.node
    }, syntax2);
    return syntax2;
  }
  const createSyntax$1 = (config) => createSyntax(mix({}, config));
  const definitions = {
    "generic": true,
    "cssWideKeywords": [
      "initial",
      "inherit",
      "unset",
      "revert",
      "revert-layer"
    ],
    "units": {
      "angle": [
        "deg",
        "grad",
        "rad",
        "turn"
      ],
      "decibel": [
        "db"
      ],
      "flex": [
        "fr"
      ],
      "frequency": [
        "hz",
        "khz"
      ],
      "length": [
        "cm",
        "mm",
        "q",
        "in",
        "pt",
        "pc",
        "px",
        "em",
        "rem",
        "ex",
        "rex",
        "cap",
        "rcap",
        "ch",
        "rch",
        "ic",
        "ric",
        "lh",
        "rlh",
        "vw",
        "svw",
        "lvw",
        "dvw",
        "vh",
        "svh",
        "lvh",
        "dvh",
        "vi",
        "svi",
        "lvi",
        "dvi",
        "vb",
        "svb",
        "lvb",
        "dvb",
        "vmin",
        "svmin",
        "lvmin",
        "dvmin",
        "vmax",
        "svmax",
        "lvmax",
        "dvmax",
        "cqw",
        "cqh",
        "cqi",
        "cqb",
        "cqmin",
        "cqmax"
      ],
      "resolution": [
        "dpi",
        "dpcm",
        "dppx",
        "x"
      ],
      "semitones": [
        "st"
      ],
      "time": [
        "s",
        "ms"
      ]
    },
    "types": {
      "abs()": "abs( <calc-sum> )",
      "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
      "acos()": "acos( <calc-sum> )",
      "alpha-value": "<number>|<percentage>",
      "angle-percentage": "<angle>|<percentage>",
      "angular-color-hint": "<angle-percentage>",
      "angular-color-stop": "<color>&&<color-stop-angle>?",
      "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
      "animateable-feature": "scroll-position|contents|<custom-ident>",
      "asin()": "asin( <calc-sum> )",
      "atan()": "atan( <calc-sum> )",
      "atan2()": "atan2( <calc-sum> , <calc-sum> )",
      "attachment": "scroll|fixed|local",
      "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
      "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
      "attr-modifier": "i|s",
      "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
      "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
      "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
      "axis": "block|inline|x|y",
      "baseline-position": "[first|last]? baseline",
      "basic-shape": "<inset()>|<xywh()>|<rect()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
      "bg-image": "none|<image>",
      "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
      "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
      "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
      "blur()": "blur( <length> )",
      "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
      "box": "border-box|padding-box|content-box",
      "brightness()": "brightness( <number-percentage> )",
      "calc()": "calc( <calc-sum> )",
      "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
      "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
      "calc-value": "<number>|<dimension>|<percentage>|<calc-constant>|( <calc-sum> )",
      "calc-constant": "e|pi|infinity|-infinity|NaN",
      "cf-final-image": "<image>|<color>",
      "cf-mixing-image": "<percentage>?&&<image>",
      "circle()": "circle( [<shape-radius>]? [at <position>]? )",
      "clamp()": "clamp( <calc-sum>#{3} )",
      "class-selector": "'.' <ident-token>",
      "clip-source": "<url>",
      "color": "<color-base>|currentColor|<system-color>|<device-cmyk()>|<light-dark()>|<-non-standard-color>",
      "color-stop": "<color-stop-length>|<color-stop-angle>",
      "color-stop-angle": "<angle-percentage>{1,2}",
      "color-stop-length": "<length-percentage>{1,2}",
      "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
      "color-interpolation-method": "in [<rectangular-color-space>|<polar-color-space> <hue-interpolation-method>?|<custom-color-space>]",
      "combinator": "'>'|'+'|'~'|['|' '|']",
      "common-lig-values": "[common-ligatures|no-common-ligatures]",
      "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
      "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
      "compositing-operator": "add|subtract|intersect|exclude",
      "compound-selector": "[<type-selector>? <subclass-selector>*]!",
      "compound-selector-list": "<compound-selector>#",
      "complex-selector": "<complex-selector-unit> [<combinator>? <complex-selector-unit>]*",
      "complex-selector-list": "<complex-selector>#",
      "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
      "contextual-alt-values": "[contextual|no-contextual]",
      "content-distribution": "space-between|space-around|space-evenly|stretch",
      "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+",
      "content-position": "center|start|end|flex-start|flex-end",
      "content-replacement": "<image>",
      "contrast()": "contrast( [<number-percentage>] )",
      "cos()": "cos( <calc-sum> )",
      "counter": "<counter()>|<counters()>",
      "counter()": "counter( <counter-name> , <counter-style>? )",
      "counter-name": "<custom-ident>",
      "counter-style": "<counter-style-name>|symbols( )",
      "counter-style-name": "<custom-ident>",
      "counters()": "counters( <counter-name> , <string> , <counter-style>? )",
      "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
      "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
      "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
      "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
      "display-box": "contents|none",
      "display-inside": "flow|flow-root|table|flex|grid|ruby",
      "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
      "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
      "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
      "display-outside": "block|inline|run-in",
      "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
      "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
      "east-asian-width-values": "[full-width|proportional-width]",
      "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
      "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
      "ending-shape": "circle|ellipse",
      "env()": "env( <custom-ident> , <declaration-value>? )",
      "exp()": "exp( <calc-sum> )",
      "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
      "family-name": "<string>|<custom-ident>+",
      "feature-tag-value": "<string> [<integer>|on|off]?",
      "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
      "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
      "feature-value-block-list": "<feature-value-block>+",
      "feature-value-declaration": "<custom-ident> : <integer>+ ;",
      "feature-value-declaration-list": "<feature-value-declaration>",
      "feature-value-name": "<custom-ident>",
      "fill-rule": "nonzero|evenodd",
      "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
      "filter-function-list": "[<filter-function>|<url>]+",
      "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
      "fixed-breadth": "<length-percentage>",
      "fixed-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
      "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
      "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
      "font-variant-css21": "[normal|small-caps]",
      "font-weight-absolute": "normal|bold|<number [1,1000]>",
      "frequency-percentage": "<frequency>|<percentage>",
      "general-enclosed": "[<function-token> <any-value>? )]|[( <any-value>? )]",
      "generic-family": "<generic-script-specific>|<generic-complete>|<generic-incomplete>|<-non-standard-generic-family>",
      "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
      "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
      "gradient": "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>",
      "grayscale()": "grayscale( <number-percentage> )",
      "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
      "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
      "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
      "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
      "hue": "<number>|<angle>",
      "hue-rotate()": "hue-rotate( <angle> )",
      "hue-interpolation-method": "[shorter|longer|increasing|decreasing] hue",
      "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )",
      "hypot()": "hypot( <calc-sum># )",
      "image": "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
      "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
      "image-set()": "image-set( <image-set-option># )",
      "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
      "image-src": "<url>|<string>",
      "image-tags": "ltr|rtl",
      "inflexible-breadth": "<length-percentage>|min-content|max-content|auto",
      "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
      "invert()": "invert( <number-percentage> )",
      "keyframes-name": "<custom-ident>|<string>",
      "keyframe-block": "<keyframe-selector># { <declaration-list> }",
      "keyframe-block-list": "<keyframe-block>+",
      "keyframe-selector": "from|to|<percentage>|<timeline-range-name> <percentage>",
      "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
      "layer()": "layer( <layer-name> )",
      "layer-name": "<ident> ['.' <ident>]*",
      "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
      "leader()": "leader( <leader-type> )",
      "leader-type": "dotted|solid|space|<string>",
      "length-percentage": "<length>|<percentage>",
      "light-dark()": "light-dark( <color> , <color> )",
      "line-names": "'[' <custom-ident>* ']'",
      "line-name-list": "[<line-names>|<name-repeat>]+",
      "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
      "line-width": "<length>|thin|medium|thick",
      "linear-color-hint": "<length-percentage>",
      "linear-color-stop": "<color> <color-stop-length>?",
      "linear-gradient()": "linear-gradient( [[<angle>|to <side-or-corner>]||<color-interpolation-method>]? , <color-stop-list> )",
      "log()": "log( <calc-sum> , <calc-sum>? )",
      "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
      "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
      "mask-reference": "none|<image>|<mask-source>",
      "mask-source": "<url>",
      "masking-mode": "alpha|luminance|match-source",
      "matrix()": "matrix( <number>#{6} )",
      "matrix3d()": "matrix3d( <number>#{16} )",
      "max()": "max( <calc-sum># )",
      "media-and": "<media-in-parens> [and <media-in-parens>]+",
      "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
      "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
      "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
      "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
      "media-not": "not <media-in-parens>",
      "media-or": "<media-in-parens> [or <media-in-parens>]+",
      "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
      "media-query-list": "<media-query>#",
      "media-type": "<ident>",
      "mf-boolean": "<mf-name>",
      "mf-name": "<ident>",
      "mf-plain": "<mf-name> : <mf-value>",
      "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
      "mf-value": "<number>|<dimension>|<ident>|<ratio>",
      "min()": "min( <calc-sum># )",
      "minmax()": "minmax( [<length-percentage>|min-content|max-content|auto] , [<length-percentage>|<flex>|min-content|max-content|auto] )",
      "mod()": "mod( <calc-sum> , <calc-sum> )",
      "name-repeat": "repeat( [<integer [1,\u221E]>|auto-fill] , <line-names>+ )",
      "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen",
      "namespace-prefix": "<ident>",
      "ns-prefix": "[<ident-token>|'*']? '|'",
      "number-percentage": "<number>|<percentage>",
      "numeric-figure-values": "[lining-nums|oldstyle-nums]",
      "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
      "numeric-spacing-values": "[proportional-nums|tabular-nums]",
      "nth": "<an-plus-b>|even|odd",
      "opacity()": "opacity( [<number-percentage>] )",
      "overflow-position": "unsafe|safe",
      "outline-radius": "<length>|<percentage>",
      "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
      "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
      "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
      "page-selector-list": "[<page-selector>#]?",
      "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
      "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
      "path()": "path( [<fill-rule> ,]? <string> )",
      "paint()": "paint( <ident> , <declaration-value>? )",
      "perspective()": "perspective( [<length [0,\u221E]>|none] )",
      "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
      "polar-color-space": "hsl|hwb|lch|oklch",
      "position": "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
      "pow()": "pow( <calc-sum> , <calc-sum> )",
      "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
      "pseudo-element-selector": "':' <pseudo-class-selector>|<legacy-pseudo-element-selector>",
      "pseudo-page": ": [left|right|first|blank]",
      "quote": "open-quote|close-quote|no-open-quote|no-close-quote",
      "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
      "ratio": "<number [0,\u221E]> [/ <number [0,\u221E]>]?",
      "ray()": "ray( <angle>&&<ray-size>?&&contain?&&[at <position>]? )",
      "ray-size": "closest-side|closest-corner|farthest-side|farthest-corner|sides",
      "rectangular-color-space": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020|lab|oklab|xyz|xyz-d50|xyz-d65",
      "relative-selector": "<combinator>? <complex-selector>",
      "relative-selector-list": "<relative-selector>#",
      "relative-size": "larger|smaller",
      "rem()": "rem( <calc-sum> , <calc-sum> )",
      "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
      "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
      "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
      "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
      "reversed-counter-name": "reversed( <counter-name> )",
      "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
      "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
      "rotate()": "rotate( [<angle>|<zero>] )",
      "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
      "rotateX()": "rotateX( [<angle>|<zero>] )",
      "rotateY()": "rotateY( [<angle>|<zero>] )",
      "rotateZ()": "rotateZ( [<angle>|<zero>] )",
      "round()": "round( <rounding-strategy>? , <calc-sum> , <calc-sum> )",
      "rounding-strategy": "nearest|up|down|to-zero",
      "saturate()": "saturate( <number-percentage> )",
      "scale()": "scale( [<number>|<percentage>]#{1,2} )",
      "scale3d()": "scale3d( [<number>|<percentage>]#{3} )",
      "scaleX()": "scaleX( [<number>|<percentage>] )",
      "scaleY()": "scaleY( [<number>|<percentage>] )",
      "scaleZ()": "scaleZ( [<number>|<percentage>] )",
      "scroll()": "scroll( [<axis>||<scroller>]? )",
      "scroller": "root|nearest|self",
      "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
      "shape-radius": "<length-percentage>|closest-side|farthest-side",
      "sign()": "sign( <calc-sum> )",
      "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
      "skewX()": "skewX( [<angle>|<zero>] )",
      "skewY()": "skewY( [<angle>|<zero>] )",
      "sepia()": "sepia( <number-percentage> )",
      "shadow": "inset?&&<length>{2,4}&&<color>?",
      "shadow-t": "[<length>{2,3}&&<color>?]",
      "shape": "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
      "shape-box": "<box>|margin-box",
      "side-or-corner": "[left|right]||[top|bottom]",
      "sin()": "sin( <calc-sum> )",
      "single-animation": "<'animation-duration'>||<easing-function>||<'animation-delay'>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]||<single-animation-timeline>",
      "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
      "single-animation-fill-mode": "none|forwards|backwards|both",
      "single-animation-iteration-count": "infinite|<number>",
      "single-animation-play-state": "running|paused",
      "single-animation-timeline": "auto|none|<dashed-ident>|<scroll()>|<view()>",
      "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>||<transition-behavior-value>",
      "single-transition-property": "all|<custom-ident>",
      "size": "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
      "sqrt()": "sqrt( <calc-sum> )",
      "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
      "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
      "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
      "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
      "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
      "supports-feature": "<supports-decl>|<supports-selector-fn>",
      "supports-decl": "( <declaration> )",
      "supports-selector-fn": "selector( <complex-selector> )",
      "symbol": "<string>|<image>|<custom-ident>",
      "system-color": "AccentColor|AccentColorText|ActiveText|ButtonBorder|ButtonFace|ButtonText|Canvas|CanvasText|Field|FieldText|GrayText|Highlight|HighlightText|LinkText|Mark|MarkText|SelectedItem|SelectedItemText|VisitedText",
      "tan()": "tan( <calc-sum> )",
      "target": "<target-counter()>|<target-counters()>|<target-text()>",
      "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
      "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
      "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
      "time-percentage": "<time>|<percentage>",
      "timeline-range-name": "cover|contain|entry|exit|entry-crossing|exit-crossing",
      "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
      "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
      "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
      "track-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <track-size>]+ <line-names>? )",
      "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( <length-percentage> )",
      "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
      "transform-list": "<transform-function>+",
      "transition-behavior-value": "normal|allow-discrete",
      "translate()": "translate( <length-percentage> , <length-percentage>? )",
      "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
      "translateX()": "translateX( <length-percentage> )",
      "translateY()": "translateY( <length-percentage> )",
      "translateZ()": "translateZ( <length> )",
      "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
      "type-selector": "<wq-name>|<ns-prefix>? '*'",
      "var()": "var( <custom-property-name> , <declaration-value>? )",
      "view()": "view( [<axis>||<'view-timeline-inset'>]? )",
      "viewport-length": "auto|<length-percentage>",
      "visual-box": "content-box|padding-box|border-box",
      "wq-name": "<ns-prefix>? <ident-token>",
      "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
      "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
      "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
      "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
      "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
      "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
      "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
      "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
      "-legacy-radial-gradient-shape": "circle|ellipse",
      "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
      "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
      "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
      "-non-standard-overflow": "overlay|-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
      "-non-standard-size": "intrinsic|min-intrinsic|-webkit-fill-available|-webkit-fit-content|-webkit-min-content|-webkit-max-content|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content",
      "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
      "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
      "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
      "-webkit-gradient-radius": "<length>|<percentage>",
      "-webkit-gradient-type": "linear|radial",
      "-webkit-mask-box-repeat": "repeat|stretch|round",
      "-ms-filter-function-list": "<-ms-filter-function>+",
      "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
      "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
      "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
      "absolute-color-base": "<hex-color>|<absolute-color-function>|<named-color>|transparent",
      "absolute-color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
      "age": "child|young|old",
      "anchor-name": "<dashed-ident>",
      "attr-name": "<wq-name>",
      "attr-fallback": "<any-value>",
      "bg-clip": "<box>|border|text",
      "bottom": "<length>|auto",
      "container-name": "<custom-ident>",
      "container-condition": "not <query-in-parens>|<query-in-parens> [[and <query-in-parens>]*|[or <query-in-parens>]*]",
      "coord-box": "content-box|padding-box|border-box|fill-box|stroke-box|view-box",
      "generic-voice": "[<age>? <gender> <integer>?]",
      "gender": "male|female|neutral",
      "generic-script-specific": "generic( kai )|generic( fangsong )|generic( nastaliq )",
      "generic-complete": "serif|sans-serif|system-ui|cursive|fantasy|math|monospace",
      "generic-incomplete": "ui-serif|ui-sans-serif|ui-monospace|ui-rounded",
      "-non-standard-generic-family": "-apple-system|BlinkMacSystemFont",
      "left": "<length>|auto",
      "color-base": "<hex-color>|<color-function>|<named-color>|<color-mix()>|transparent",
      "color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
      "device-cmyk()": "<legacy-device-cmyk-syntax>|<modern-device-cmyk-syntax>",
      "legacy-device-cmyk-syntax": "device-cmyk( <number>#{4} )",
      "modern-device-cmyk-syntax": "device-cmyk( <cmyk-component>{4} [/ [<alpha-value>|none]]? )",
      "cmyk-component": "<number>|<percentage>|none",
      "color-mix()": "color-mix( <color-interpolation-method> , [<color>&&<percentage [0,100]>?]#{2} )",
      "color-space": "<rectangular-color-space>|<polar-color-space>|<custom-color-space>",
      "custom-color-space": "<dashed-ident>",
      "paint": "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
      "palette-identifier": "<dashed-ident>",
      "right": "<length>|auto",
      "scope-start": "<forgiving-selector-list>",
      "scope-end": "<forgiving-selector-list>",
      "forgiving-selector-list": "<complex-real-selector-list>",
      "forgiving-relative-selector-list": "<relative-real-selector-list>",
      "selector-list": "<complex-selector-list>",
      "complex-real-selector-list": "<complex-real-selector>#",
      "simple-selector-list": "<simple-selector>#",
      "relative-real-selector-list": "<relative-real-selector>#",
      "complex-selector-unit": "[<compound-selector>? <pseudo-compound-selector>*]!",
      "complex-real-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
      "relative-real-selector": "<combinator>? <complex-real-selector>",
      "pseudo-compound-selector": "<pseudo-element-selector> <pseudo-class-selector>*",
      "simple-selector": "<type-selector>|<subclass-selector>",
      "legacy-pseudo-element-selector": "':' [before|after|first-line|first-letter]",
      "single-animation-composition": "replace|add|accumulate",
      "svg-length": "<percentage>|<length>|<number>",
      "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
      "top": "<length>|auto",
      "x": "<number>",
      "y": "<number>",
      "declaration": "<ident-token> : <declaration-value>? ['!' important]?",
      "declaration-list": "[<declaration>? ';']* <declaration>?",
      "url": "url( <string> <url-modifier>* )|<url-token>",
      "url-modifier": "<ident>|<function-token> <any-value> )",
      "number-zero-one": "<number [0,1]>",
      "number-one-or-greater": "<number [1,\u221E]>",
      "color()": "color( <colorspace-params> [/ [<alpha-value>|none]]? )",
      "colorspace-params": "[<predefined-rgb-params>|<xyz-params>]",
      "predefined-rgb-params": "<predefined-rgb> [<number>|<percentage>|none]{3}",
      "predefined-rgb": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020",
      "xyz-params": "<xyz-space> [<number>|<percentage>|none]{3}",
      "xyz-space": "xyz|xyz-d50|xyz-d65",
      "oklab()": "oklab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
      "oklch()": "oklch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
      "offset-path": "<ray()>|<url>|<basic-shape>",
      "rect()": "rect( [<length-percentage>|auto]{4} [round <'border-radius'>]? )",
      "xywh()": "xywh( <length-percentage>{2} <length-percentage [0,\u221E]>{2} [round <'border-radius'>]? )",
      "query-in-parens": "( <container-condition> )|( <size-feature> )|style( <style-query> )|<general-enclosed>",
      "size-feature": "<mf-plain>|<mf-boolean>|<mf-range>",
      "style-feature": "<declaration>",
      "style-query": "<style-condition>|<style-feature>",
      "style-condition": "not <style-in-parens>|<style-in-parens> [[and <style-in-parens>]*|[or <style-in-parens>]*]",
      "style-in-parens": "( <style-condition> )|( <style-feature> )|<general-enclosed>",
      "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box",
      "inset-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
      "position-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|center|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|center|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
      "anchor()": "anchor( <anchor-element>?&&<anchor-side> , <length-percentage>? )",
      "anchor-side": "inside|outside|top|left|right|bottom|start|end|self-start|self-end|<percentage>|center",
      "anchor-size()": "anchor-size( [<anchor-element>||<anchor-size>]? , <length-percentage>? )",
      "anchor-size": "width|height|block|inline|self-block|self-inline",
      "anchor-element": "<dashed-ident>",
      "try-size": "most-width|most-height|most-block-size|most-inline-size",
      "try-tactic": "flip-block||flip-inline||flip-start",
      "font-variant-css2": "normal|small-caps",
      "font-width-css3": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded",
      "system-family-name": "caption|icon|menu|message-box|small-caption|status-bar"
    },
    "properties": {
      "--*": "<declaration-value>",
      "-ms-accelerator": "false|true",
      "-ms-block-progression": "tb|rl|bt|lr",
      "-ms-content-zoom-chaining": "none|chained",
      "-ms-content-zooming": "none|zoom",
      "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
      "-ms-content-zoom-limit-max": "<percentage>",
      "-ms-content-zoom-limit-min": "<percentage>",
      "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
      "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
      "-ms-content-zoom-snap-type": "none|proximity|mandatory",
      "-ms-filter": "<string>",
      "-ms-flow-from": "[none|<custom-ident>]#",
      "-ms-flow-into": "[none|<custom-ident>]#",
      "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
      "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
      "-ms-high-contrast-adjust": "auto|none",
      "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
      "-ms-hyphenate-limit-lines": "no-limit|<integer>",
      "-ms-hyphenate-limit-zone": "<percentage>|<length>",
      "-ms-ime-align": "auto|after",
      "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
      "-ms-scrollbar-3dlight-color": "<color>",
      "-ms-scrollbar-arrow-color": "<color>",
      "-ms-scrollbar-base-color": "<color>",
      "-ms-scrollbar-darkshadow-color": "<color>",
      "-ms-scrollbar-face-color": "<color>",
      "-ms-scrollbar-highlight-color": "<color>",
      "-ms-scrollbar-shadow-color": "<color>",
      "-ms-scrollbar-track-color": "<color>",
      "-ms-scroll-chaining": "chained|none",
      "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
      "-ms-scroll-limit-x-max": "auto|<length>",
      "-ms-scroll-limit-x-min": "<length>",
      "-ms-scroll-limit-y-max": "auto|<length>",
      "-ms-scroll-limit-y-min": "<length>",
      "-ms-scroll-rails": "none|railed",
      "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
      "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
      "-ms-scroll-snap-type": "none|proximity|mandatory",
      "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
      "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
      "-ms-scroll-translation": "none|vertical-to-horizontal",
      "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
      "-ms-touch-select": "grippers|none",
      "-ms-user-select": "none|element|text",
      "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
      "-ms-wrap-margin": "<length>",
      "-ms-wrap-through": "wrap|none",
      "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
      "-moz-binding": "<url>|none",
      "-moz-border-bottom-colors": "<color>+|none",
      "-moz-border-left-colors": "<color>+|none",
      "-moz-border-right-colors": "<color>+|none",
      "-moz-border-top-colors": "<color>+|none",
      "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
      "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
      "-moz-force-broken-image-icon": "0|1",
      "-moz-image-region": "<shape>|auto",
      "-moz-orient": "inline|block|horizontal|vertical",
      "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
      "-moz-outline-radius-bottomleft": "<outline-radius>",
      "-moz-outline-radius-bottomright": "<outline-radius>",
      "-moz-outline-radius-topleft": "<outline-radius>",
      "-moz-outline-radius-topright": "<outline-radius>",
      "-moz-stack-sizing": "ignore|stretch-to-fit",
      "-moz-text-blink": "none|blink",
      "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
      "-moz-user-input": "auto|none|enabled|disabled",
      "-moz-user-modify": "read-only|read-write|write-only",
      "-moz-window-dragging": "drag|no-drag",
      "-moz-window-shadow": "default|menu|tooltip|sheet|none",
      "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
      "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
      "-webkit-border-before-color": "<color>",
      "-webkit-border-before-style": "<'border-style'>",
      "-webkit-border-before-width": "<'border-width'>",
      "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
      "-webkit-line-clamp": "none|<integer>",
      "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
      "-webkit-mask-attachment": "<attachment>#",
      "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
      "-webkit-mask-composite": "<composite-style>#",
      "-webkit-mask-image": "<mask-reference>#",
      "-webkit-mask-origin": "[<box>|border|padding|content]#",
      "-webkit-mask-position": "<position>#",
      "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
      "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
      "-webkit-mask-repeat": "<repeat-style>#",
      "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
      "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
      "-webkit-mask-size": "<bg-size>#",
      "-webkit-overflow-scrolling": "auto|touch",
      "-webkit-tap-highlight-color": "<color>",
      "-webkit-text-fill-color": "<color>",
      "-webkit-text-stroke": "<length>||<color>",
      "-webkit-text-stroke-color": "<color>",
      "-webkit-text-stroke-width": "<length>",
      "-webkit-touch-callout": "default|none",
      "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
      "accent-color": "auto|<color>",
      "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
      "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
      "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
      "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
      "all": "initial|inherit|unset|revert|revert-layer",
      "anchor-name": "none|<dashed-ident>#",
      "anchor-scope": "none|all|<dashed-ident>#",
      "animation": "<single-animation>#",
      "animation-composition": "<single-animation-composition>#",
      "animation-delay": "<time>#",
      "animation-direction": "<single-animation-direction>#",
      "animation-duration": "<time>#",
      "animation-fill-mode": "<single-animation-fill-mode>#",
      "animation-iteration-count": "<single-animation-iteration-count>#",
      "animation-name": "[none|<keyframes-name>]#",
      "animation-play-state": "<single-animation-play-state>#",
      "animation-range": "[<'animation-range-start'> <'animation-range-end'>?]#",
      "animation-range-end": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
      "animation-range-start": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
      "animation-timing-function": "<easing-function>#",
      "animation-timeline": "<single-animation-timeline>#",
      "appearance": "none|auto|textfield|menulist-button|<compat-auto>",
      "aspect-ratio": "auto||<ratio>",
      "azimuth": "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
      "backdrop-filter": "none|<filter-function-list>",
      "backface-visibility": "visible|hidden",
      "background": "[<bg-layer> ,]* <final-bg-layer>",
      "background-attachment": "<attachment>#",
      "background-blend-mode": "<blend-mode>#",
      "background-clip": "<bg-clip>#",
      "background-color": "<color>",
      "background-image": "<bg-image>#",
      "background-origin": "<box>#",
      "background-position": "<bg-position>#",
      "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
      "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
      "background-repeat": "<repeat-style>#",
      "background-size": "<bg-size>#",
      "block-size": "<'width'>",
      "border": "<line-width>||<line-style>||<color>",
      "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-block-color": "<'border-top-color'>{1,2}",
      "border-block-style": "<'border-top-style'>",
      "border-block-width": "<'border-top-width'>",
      "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-block-end-color": "<'border-top-color'>",
      "border-block-end-style": "<'border-top-style'>",
      "border-block-end-width": "<'border-top-width'>",
      "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-block-start-color": "<'border-top-color'>",
      "border-block-start-style": "<'border-top-style'>",
      "border-block-start-width": "<'border-top-width'>",
      "border-bottom": "<line-width>||<line-style>||<color>",
      "border-bottom-color": "<'border-top-color'>",
      "border-bottom-left-radius": "<length-percentage>{1,2}",
      "border-bottom-right-radius": "<length-percentage>{1,2}",
      "border-bottom-style": "<line-style>",
      "border-bottom-width": "<line-width>",
      "border-collapse": "collapse|separate",
      "border-color": "<color>{1,4}",
      "border-end-end-radius": "<length-percentage>{1,2}",
      "border-end-start-radius": "<length-percentage>{1,2}",
      "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
      "border-image-outset": "[<length>|<number>]{1,4}",
      "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
      "border-image-slice": "<number-percentage>{1,4}&&fill?",
      "border-image-source": "none|<image>",
      "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
      "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-inline-color": "<'border-top-color'>{1,2}",
      "border-inline-style": "<'border-top-style'>",
      "border-inline-width": "<'border-top-width'>",
      "border-inline-end-color": "<'border-top-color'>",
      "border-inline-end-style": "<'border-top-style'>",
      "border-inline-end-width": "<'border-top-width'>",
      "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-inline-start-color": "<'border-top-color'>",
      "border-inline-start-style": "<'border-top-style'>",
      "border-inline-start-width": "<'border-top-width'>",
      "border-left": "<line-width>||<line-style>||<color>",
      "border-left-color": "<color>",
      "border-left-style": "<line-style>",
      "border-left-width": "<line-width>",
      "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
      "border-right": "<line-width>||<line-style>||<color>",
      "border-right-color": "<color>",
      "border-right-style": "<line-style>",
      "border-right-width": "<line-width>",
      "border-spacing": "<length> <length>?",
      "border-start-end-radius": "<length-percentage>{1,2}",
      "border-start-start-radius": "<length-percentage>{1,2}",
      "border-style": "<line-style>{1,4}",
      "border-top": "<line-width>||<line-style>||<color>",
      "border-top-color": "<color>",
      "border-top-left-radius": "<length-percentage>{1,2}",
      "border-top-right-radius": "<length-percentage>{1,2}",
      "border-top-style": "<line-style>",
      "border-top-width": "<line-width>",
      "border-width": "<line-width>{1,4}",
      "bottom": "<length>|<percentage>|auto",
      "box-align": "start|center|end|baseline|stretch",
      "box-decoration-break": "slice|clone",
      "box-direction": "normal|reverse|inherit",
      "box-flex": "<number>",
      "box-flex-group": "<integer>",
      "box-lines": "single|multiple",
      "box-ordinal-group": "<integer>",
      "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
      "box-pack": "start|center|end|justify",
      "box-shadow": "none|<shadow>#",
      "box-sizing": "content-box|border-box",
      "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
      "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
      "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
      "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
      "caret": "<'caret-color'>||<'caret-shape'>",
      "caret-color": "auto|<color>",
      "caret-shape": "auto|bar|block|underscore",
      "clear": "none|left|right|both|inline-start|inline-end",
      "clip": "<shape>|auto",
      "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
      "clip-rule": "nonzero|evenodd",
      "color": "<color>",
      "color-interpolation-filters": "auto|sRGB|linearRGB",
      "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?",
      "column-count": "<integer>|auto",
      "column-fill": "auto|balance",
      "column-gap": "normal|<length-percentage>",
      "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
      "column-rule-color": "<color>",
      "column-rule-style": "<'border-style'>",
      "column-rule-width": "<'border-width'>",
      "column-span": "none|all",
      "column-width": "<length>|auto",
      "columns": "<'column-width'>||<'column-count'>",
      "contain": "none|strict|content|[[size||inline-size]||layout||style||paint]",
      "contain-intrinsic-size": "[auto? [none|<length>]]{1,2}",
      "contain-intrinsic-block-size": "auto? [none|<length>]",
      "contain-intrinsic-height": "auto? [none|<length>]",
      "contain-intrinsic-inline-size": "auto? [none|<length>]",
      "contain-intrinsic-width": "auto? [none|<length>]",
      "container": "<'container-name'> [/ <'container-type'>]?",
      "container-name": "none|<custom-ident>+",
      "container-type": "normal||[size|inline-size]",
      "content": "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?",
      "content-visibility": "visible|auto|hidden",
      "counter-increment": "[<counter-name> <integer>?]+|none",
      "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none",
      "counter-set": "[<counter-name> <integer>?]+|none",
      "cursor": "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
      "d": "none|path( <string> )",
      "cx": "<length>|<percentage>",
      "cy": "<length>|<percentage>",
      "direction": "ltr|rtl",
      "display": "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
      "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
      "empty-cells": "show|hide",
      "field-sizing": "content|fixed",
      "fill": "<paint>",
      "fill-opacity": "<number-zero-one>",
      "fill-rule": "nonzero|evenodd",
      "filter": "none|<filter-function-list>|<-ms-filter-function-list>",
      "flex": "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
      "flex-basis": "content|<'width'>",
      "flex-direction": "row|row-reverse|column|column-reverse",
      "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
      "flex-grow": "<number>",
      "flex-shrink": "<number>",
      "flex-wrap": "nowrap|wrap|wrap-reverse",
      "float": "left|right|none|inline-start|inline-end",
      "font": "[[<'font-style'>||<font-variant-css2>||<'font-weight'>||<font-width-css3>]? <'font-size'> [/ <'line-height'>]? <'font-family'>#]|<system-family-name>|<-non-standard-font>",
      "font-family": "[<family-name>|<generic-family>]#",
      "font-feature-settings": "normal|<feature-tag-value>#",
      "font-kerning": "auto|normal|none",
      "font-language-override": "normal|<string>",
      "font-optical-sizing": "auto|none",
      "font-palette": "normal|light|dark|<palette-identifier>",
      "font-variation-settings": "normal|[<string> <number>]#",
      "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
      "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
      "font-smooth": "auto|never|always|<absolute-size>|<length>",
      "font-stretch": "<font-stretch-absolute>",
      "font-style": "normal|italic|oblique <angle>?",
      "font-synthesis": "none|[weight||style||small-caps||position]",
      "font-synthesis-position": "auto|none",
      "font-synthesis-small-caps": "auto|none",
      "font-synthesis-style": "auto|none",
      "font-synthesis-weight": "auto|none",
      "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
      "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
      "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
      "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
      "font-variant-emoji": "normal|text|emoji|unicode",
      "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
      "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
      "font-variant-position": "normal|sub|super",
      "font-weight": "<font-weight-absolute>|bolder|lighter",
      "forced-color-adjust": "auto|none|preserve-parent-color",
      "gap": "<'row-gap'> <'column-gap'>?",
      "grid": "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
      "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
      "grid-auto-columns": "<track-size>+",
      "grid-auto-flow": "[row|column]||dense",
      "grid-auto-rows": "<track-size>+",
      "grid-column": "<grid-line> [/ <grid-line>]?",
      "grid-column-end": "<grid-line>",
      "grid-column-gap": "<length-percentage>",
      "grid-column-start": "<grid-line>",
      "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
      "grid-row": "<grid-line> [/ <grid-line>]?",
      "grid-row-end": "<grid-line>",
      "grid-row-gap": "<length-percentage>",
      "grid-row-start": "<grid-line>",
      "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
      "grid-template-areas": "none|<string>+",
      "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
      "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
      "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
      "height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "hyphenate-character": "auto|<string>",
      "hyphenate-limit-chars": "[auto|<integer>]{1,3}",
      "hyphens": "none|manual|auto",
      "image-orientation": "from-image|<angle>|[<angle>? flip]",
      "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
      "image-resolution": "[from-image||<resolution>]&&snap?",
      "ime-mode": "auto|normal|active|inactive|disabled",
      "initial-letter": "normal|[<number> <integer>?]",
      "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
      "inline-size": "<'width'>",
      "input-security": "auto|none",
      "inset": "<'top'>{1,4}",
      "inset-block": "<'top'>{1,2}",
      "inset-block-end": "<'top'>",
      "inset-block-start": "<'top'>",
      "inset-inline": "<'top'>{1,2}",
      "inset-inline-end": "<'top'>",
      "inset-inline-start": "<'top'>",
      "interpolate-size": "numeric-only|allow-keywords",
      "isolation": "auto|isolate",
      "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
      "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
      "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
      "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
      "left": "<length>|<percentage>|auto",
      "letter-spacing": "normal|<length-percentage>",
      "line-break": "auto|loose|normal|strict|anywhere",
      "line-clamp": "none|<integer>",
      "line-height": "normal|<number>|<length>|<percentage>",
      "line-height-step": "<length>",
      "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
      "list-style-image": "<image>|none",
      "list-style-position": "inside|outside",
      "list-style-type": "<counter-style>|<string>|none",
      "margin": "[<length>|<percentage>|auto]{1,4}",
      "margin-block": "<'margin-left'>{1,2}",
      "margin-block-end": "<'margin-left'>",
      "margin-block-start": "<'margin-left'>",
      "margin-bottom": "<length>|<percentage>|auto",
      "margin-inline": "<'margin-left'>{1,2}",
      "margin-inline-end": "<'margin-left'>",
      "margin-inline-start": "<'margin-left'>",
      "margin-left": "<length>|<percentage>|auto",
      "margin-right": "<length>|<percentage>|auto",
      "margin-top": "<length>|<percentage>|auto",
      "margin-trim": "none|in-flow|all",
      "marker": "none|<url>",
      "marker-end": "none|<url>",
      "marker-mid": "none|<url>",
      "marker-start": "none|<url>",
      "mask": "<mask-layer>#",
      "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
      "mask-border-mode": "luminance|alpha",
      "mask-border-outset": "[<length>|<number>]{1,4}",
      "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
      "mask-border-slice": "<number-percentage>{1,4} fill?",
      "mask-border-source": "none|<image>",
      "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
      "mask-clip": "[<geometry-box>|no-clip]#",
      "mask-composite": "<compositing-operator>#",
      "mask-image": "<mask-reference>#",
      "mask-mode": "<masking-mode>#",
      "mask-origin": "<geometry-box>#",
      "mask-position": "<position>#",
      "mask-repeat": "<repeat-style>#",
      "mask-size": "<bg-size>#",
      "mask-type": "luminance|alpha",
      "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
      "math-depth": "auto-add|add( <integer> )|<integer>",
      "math-shift": "normal|compact",
      "math-style": "normal|compact",
      "max-block-size": "<'max-width'>",
      "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "max-inline-size": "<'max-width'>",
      "max-lines": "none|<integer>",
      "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "min-block-size": "<'min-width'>",
      "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "min-inline-size": "<'min-width'>",
      "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "mix-blend-mode": "<blend-mode>|plus-lighter",
      "object-fit": "fill|contain|cover|none|scale-down",
      "object-position": "<position>",
      "offset": "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
      "offset-anchor": "auto|<position>",
      "offset-distance": "<length-percentage>",
      "offset-path": "none|<offset-path>||<coord-box>",
      "offset-position": "normal|auto|<position>",
      "offset-rotate": "[auto|reverse]||<angle>",
      "opacity": "<alpha-value>",
      "order": "<integer>",
      "orphans": "<integer>",
      "outline": "[<'outline-width'>||<'outline-style'>||<'outline-color'>]",
      "outline-color": "auto|<color>",
      "outline-offset": "<length>",
      "outline-style": "auto|<'border-style'>",
      "outline-width": "<line-width>",
      "overflow": "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
      "overflow-anchor": "auto|none",
      "overflow-block": "visible|hidden|clip|scroll|auto",
      "overflow-clip-box": "padding-box|content-box",
      "overflow-clip-margin": "<visual-box>||<length [0,\u221E]>",
      "overflow-inline": "visible|hidden|clip|scroll|auto",
      "overflow-wrap": "normal|break-word|anywhere",
      "overflow-x": "visible|hidden|clip|scroll|auto",
      "overflow-y": "visible|hidden|clip|scroll|auto",
      "overlay": "none|auto",
      "overscroll-behavior": "[contain|none|auto]{1,2}",
      "overscroll-behavior-block": "contain|none|auto",
      "overscroll-behavior-inline": "contain|none|auto",
      "overscroll-behavior-x": "contain|none|auto",
      "overscroll-behavior-y": "contain|none|auto",
      "padding": "[<length>|<percentage>]{1,4}",
      "padding-block": "<'padding-left'>{1,2}",
      "padding-block-end": "<'padding-left'>",
      "padding-block-start": "<'padding-left'>",
      "padding-bottom": "<length>|<percentage>",
      "padding-inline": "<'padding-left'>{1,2}",
      "padding-inline-end": "<'padding-left'>",
      "padding-inline-start": "<'padding-left'>",
      "padding-left": "<length>|<percentage>",
      "padding-right": "<length>|<percentage>",
      "padding-top": "<length>|<percentage>",
      "page": "auto|<custom-ident>",
      "page-break-after": "auto|always|avoid|left|right|recto|verso",
      "page-break-before": "auto|always|avoid|left|right|recto|verso",
      "page-break-inside": "auto|avoid",
      "paint-order": "normal|[fill||stroke||markers]",
      "perspective": "none|<length>",
      "perspective-origin": "<position>",
      "place-content": "<'align-content'> <'justify-content'>?",
      "place-items": "<'align-items'> <'justify-items'>?",
      "place-self": "<'align-self'> <'justify-self'>?",
      "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
      "position": "static|relative|absolute|sticky|fixed|-webkit-sticky",
      "position-anchor": "auto|<anchor-name>",
      "position-area": "none|<position-area>",
      "position-try": "<'position-try-order'>? <'position-try-fallbacks'>",
      "position-try-fallbacks": "none|[[<dashed-ident>||<try-tactic>]|<'position-area'>]#",
      "position-try-order": "normal|<try-size>",
      "position-visibility": "always|[anchors-valid||anchors-visible||no-overflow]",
      "print-color-adjust": "economy|exact",
      "quotes": "none|auto|[<string> <string>]+",
      "r": "<length>|<percentage>",
      "resize": "none|both|horizontal|vertical|block|inline",
      "right": "<length>|<percentage>|auto",
      "rotate": "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
      "row-gap": "normal|<length-percentage>",
      "ruby-align": "start|center|space-between|space-around",
      "ruby-merge": "separate|collapse|auto",
      "ruby-position": "[alternate||[over|under]]|inter-character",
      "rx": "<length>|<percentage>",
      "ry": "<length>|<percentage>",
      "scale": "none|[<number>|<percentage>]{1,3}",
      "scrollbar-color": "auto|<color>{2}",
      "scrollbar-gutter": "auto|stable&&both-edges?",
      "scrollbar-width": "auto|thin|none",
      "scroll-behavior": "auto|smooth",
      "scroll-margin": "<length>{1,4}",
      "scroll-margin-block": "<length>{1,2}",
      "scroll-margin-block-start": "<length>",
      "scroll-margin-block-end": "<length>",
      "scroll-margin-bottom": "<length>",
      "scroll-margin-inline": "<length>{1,2}",
      "scroll-margin-inline-start": "<length>",
      "scroll-margin-inline-end": "<length>",
      "scroll-margin-left": "<length>",
      "scroll-margin-right": "<length>",
      "scroll-margin-top": "<length>",
      "scroll-padding": "[auto|<length-percentage>]{1,4}",
      "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
      "scroll-padding-block-start": "auto|<length-percentage>",
      "scroll-padding-block-end": "auto|<length-percentage>",
      "scroll-padding-bottom": "auto|<length-percentage>",
      "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
      "scroll-padding-inline-start": "auto|<length-percentage>",
      "scroll-padding-inline-end": "auto|<length-percentage>",
      "scroll-padding-left": "auto|<length-percentage>",
      "scroll-padding-right": "auto|<length-percentage>",
      "scroll-padding-top": "auto|<length-percentage>",
      "scroll-snap-align": "[none|start|end|center]{1,2}",
      "scroll-snap-coordinate": "none|<position>#",
      "scroll-snap-destination": "<position>",
      "scroll-snap-points-x": "none|repeat( <length-percentage> )",
      "scroll-snap-points-y": "none|repeat( <length-percentage> )",
      "scroll-snap-stop": "normal|always",
      "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
      "scroll-snap-type-x": "none|mandatory|proximity",
      "scroll-snap-type-y": "none|mandatory|proximity",
      "scroll-timeline": "[<'scroll-timeline-name'>||<'scroll-timeline-axis'>]#",
      "scroll-timeline-axis": "[block|inline|x|y]#",
      "scroll-timeline-name": "[none|<dashed-ident>]#",
      "shape-image-threshold": "<alpha-value>",
      "shape-margin": "<length-percentage>",
      "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
      "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
      "stroke": "<paint>",
      "stroke-dasharray": "none|[<svg-length>+]#",
      "stroke-dashoffset": "<svg-length>",
      "stroke-linecap": "butt|round|square",
      "stroke-linejoin": "miter|round|bevel",
      "stroke-miterlimit": "<number-one-or-greater>",
      "stroke-opacity": "<'opacity'>",
      "stroke-width": "<svg-length>",
      "tab-size": "<integer>|<length>",
      "table-layout": "auto|fixed",
      "text-align": "start|end|left|right|center|justify|match-parent",
      "text-align-last": "auto|start|end|left|right|center|justify",
      "text-anchor": "start|middle|end",
      "text-combine-upright": "none|all|[digits <integer>?]",
      "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
      "text-decoration-color": "<color>",
      "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
      "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
      "text-decoration-skip-ink": "auto|all|none",
      "text-decoration-style": "solid|double|dotted|dashed|wavy",
      "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
      "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
      "text-emphasis-color": "<color>",
      "text-emphasis-position": "auto|[over|under]&&[right|left]?",
      "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
      "text-indent": "<length-percentage>&&hanging?&&each-line?",
      "text-justify": "auto|inter-character|inter-word|none",
      "text-orientation": "mixed|upright|sideways",
      "text-overflow": "[clip|ellipsis|<string>]{1,2}",
      "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
      "text-shadow": "none|<shadow-t>#",
      "text-size-adjust": "none|auto|<percentage>",
      "text-spacing-trim": "space-all|normal|space-first|trim-start|trim-both|trim-all|auto",
      "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
      "text-underline-offset": "auto|<length>|<percentage>",
      "text-underline-position": "auto|from-font|[under||[left|right]]",
      "text-wrap": "<'text-wrap-mode'>||<'text-wrap-style'>",
      "text-wrap-mode": "auto|wrap|nowrap",
      "text-wrap-style": "auto|balance|stable|pretty",
      "timeline-scope": "none|<dashed-ident>#",
      "top": "<length>|<percentage>|auto",
      "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
      "transform": "none|<transform-list>",
      "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
      "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
      "transform-style": "flat|preserve-3d",
      "transition": "<single-transition>#",
      "transition-behavior": "<transition-behavior-value>#",
      "transition-delay": "<time>#",
      "transition-duration": "<time>#",
      "transition-property": "none|<single-transition-property>#",
      "transition-timing-function": "<easing-function>#",
      "translate": "none|<length-percentage> [<length-percentage> <length>?]?",
      "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
      "user-select": "auto|text|none|contain|all",
      "vector-effect": "none|non-scaling-stroke|non-scaling-size|non-rotation|fixed-position",
      "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
      "view-timeline": "[<'view-timeline-name'> <'view-timeline-axis'>?]#",
      "view-timeline-axis": "[block|inline|x|y]#",
      "view-timeline-inset": "[[auto|<length-percentage>]{1,2}]#",
      "view-timeline-name": "none|<dashed-ident>#",
      "view-transition-name": "none|<custom-ident>",
      "visibility": "visible|hidden|collapse",
      "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces|[<'white-space-collapse'>||<'text-wrap'>||<'white-space-trim'>]",
      "white-space-collapse": "collapse|discard|preserve|preserve-breaks|preserve-spaces|break-spaces",
      "widows": "<integer>",
      "width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "will-change": "auto|<animateable-feature>#",
      "word-break": "normal|break-all|keep-all|break-word|auto-phrase",
      "word-spacing": "normal|<length>",
      "word-wrap": "normal|break-word",
      "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
      "x": "<length>|<percentage>",
      "y": "<length>|<percentage>",
      "z-index": "auto|<integer>",
      "zoom": "normal|reset|<number>|<percentage>",
      "-moz-background-clip": "padding|border",
      "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
      "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
      "-moz-border-radius-topleft": "<'border-top-left-radius'>",
      "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
      "-moz-control-character-visibility": "visible|hidden",
      "-moz-osx-font-smoothing": "auto|grayscale",
      "-moz-user-select": "none|text|all|-moz-none",
      "-ms-flex-align": "start|end|center|baseline|stretch",
      "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
      "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
      "-ms-flex-negative": "<'flex-shrink'>",
      "-ms-flex-pack": "start|end|center|justify|distribute",
      "-ms-flex-order": "<integer>",
      "-ms-flex-positive": "<'flex-grow'>",
      "-ms-flex-preferred-size": "<'flex-basis'>",
      "-ms-interpolation-mode": "nearest-neighbor|bicubic",
      "-ms-grid-column-align": "start|end|center|stretch",
      "-ms-grid-row-align": "start|end|center|stretch",
      "-ms-hyphenate-limit-last": "none|always|column|page|spread",
      "-webkit-background-clip": "[<box>|border|padding|content|text]#",
      "-webkit-column-break-after": "always|auto|avoid",
      "-webkit-column-break-before": "always|auto|avoid",
      "-webkit-column-break-inside": "always|auto|avoid",
      "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
      "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
      "-webkit-print-color-adjust": "economy|exact",
      "-webkit-text-security": "none|circle|disc|square",
      "-webkit-user-drag": "none|element|auto",
      "-webkit-user-select": "auto|none|text|all",
      "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
      "baseline-shift": "baseline|sub|super|<svg-length>",
      "behavior": "<url>+",
      "cue": "<'cue-before'> <'cue-after'>?",
      "cue-after": "<url> <decibel>?|none",
      "cue-before": "<url> <decibel>?|none",
      "glyph-orientation-horizontal": "<angle>",
      "glyph-orientation-vertical": "<angle>",
      "kerning": "auto|<svg-length>",
      "pause": "<'pause-before'> <'pause-after'>?",
      "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "rest": "<'rest-before'> <'rest-after'>?",
      "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
      "speak": "auto|never|always",
      "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
      "unicode-range": "<urange>#",
      "voice-balance": "<number>|left|center|right|leftwards|rightwards",
      "voice-duration": "auto|<time>",
      "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
      "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
      "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
      "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
      "voice-stress": "normal|strong|moderate|none|reduced",
      "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]",
      "white-space-trim": "none|discard-before||discard-after||discard-inner"
    },
    "atrules": {
      "charset": {
        "prelude": "<string>",
        "descriptors": null
      },
      "counter-style": {
        "prelude": "<counter-style-name>",
        "descriptors": {
          "additive-symbols": "[<integer>&&<symbol>]#",
          "fallback": "<counter-style-name>",
          "negative": "<symbol> <symbol>?",
          "pad": "<integer>&&<symbol>",
          "prefix": "<symbol>",
          "range": "[[<integer>|infinite]{2}]#|auto",
          "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
          "suffix": "<symbol>",
          "symbols": "<symbol>+",
          "system": "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
        }
      },
      "document": {
        "prelude": "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
        "descriptors": null
      },
      "font-palette-values": {
        "prelude": "<dashed-ident>",
        "descriptors": {
          "base-palette": "light|dark|<integer [0,\u221E]>",
          "font-family": "<family-name>#",
          "override-colors": "[<integer [0,\u221E]> <absolute-color-base>]#"
        }
      },
      "font-face": {
        "prelude": null,
        "descriptors": {
          "ascent-override": "normal|<percentage>",
          "descent-override": "normal|<percentage>",
          "font-display": "[auto|block|swap|fallback|optional]",
          "font-family": "<family-name>",
          "font-feature-settings": "normal|<feature-tag-value>#",
          "font-variation-settings": "normal|[<string> <number>]#",
          "font-stretch": "<font-stretch-absolute>{1,2}",
          "font-style": "normal|italic|oblique <angle>{0,2}",
          "font-weight": "<font-weight-absolute>{1,2}",
          "line-gap-override": "normal|<percentage>",
          "size-adjust": "<percentage>",
          "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
          "unicode-range": "<urange>#"
        }
      },
      "font-feature-values": {
        "prelude": "<family-name>#",
        "descriptors": null
      },
      "import": {
        "prelude": "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?",
        "descriptors": null
      },
      "keyframes": {
        "prelude": "<keyframes-name>",
        "descriptors": null
      },
      "layer": {
        "prelude": "[<layer-name>#|<layer-name>?]",
        "descriptors": null
      },
      "media": {
        "prelude": "<media-query-list>",
        "descriptors": null
      },
      "namespace": {
        "prelude": "<namespace-prefix>? [<string>|<url>]",
        "descriptors": null
      },
      "page": {
        "prelude": "<page-selector-list>",
        "descriptors": {
          "bleed": "auto|<length>",
          "marks": "none|[crop||cross]",
          "page-orientation": "upright|rotate-left|rotate-right",
          "size": "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
        }
      },
      "position-try": {
        "prelude": "<dashed-ident>",
        "descriptors": {
          "top": "<'top'>",
          "left": "<'left'>",
          "bottom": "<'bottom'>",
          "right": "<'right'>",
          "inset-block-start": "<'inset-block-start'>",
          "inset-block-end": "<'inset-block-end'>",
          "inset-inline-start": "<'inset-inline-start'>",
          "inset-inline-end": "<'inset-inline-end'>",
          "inset-block": "<'inset-block'>",
          "inset-inline": "<'inset-inline'>",
          "inset": "<'inset'>",
          "margin-top": "<'margin-top'>",
          "margin-left": "<'margin-left'>",
          "margin-bottom": "<'margin-bottom'>",
          "margin-right": "<'margin-right'>",
          "margin-block-start": "<'margin-block-start'>",
          "margin-block-end": "<'margin-block-end'>",
          "margin-inline-start": "<'margin-inline-start'>",
          "margin-inline-end": "<'margin-inline-end'>",
          "margin": "<'margin'>",
          "margin-block": "<'margin-block'>",
          "margin-inline": "<'margin-inline'>",
          "width": "<'width'>",
          "height": "<'height'>",
          "min-width": "<'min-width'>",
          "min-height": "<'min-height'>",
          "max-width": "<'max-width'>",
          "max-height": "<'max-height'>",
          "block-size": "<'block-size'>",
          "inline-size": "<'inline-size'>",
          "min-block-size": "<'min-block-size'>",
          "min-inline-size": "<'min-inline-size'>",
          "max-block-size": "<'max-block-size'>",
          "max-inline-size": "<'max-inline-size'>",
          "align-self": "<'align-self'>|anchor-center",
          "justify-self": "<'justify-self'>|anchor-center"
        }
      },
      "property": {
        "prelude": "<custom-property-name>",
        "descriptors": {
          "syntax": "<string>",
          "inherits": "true|false",
          "initial-value": "<declaration-value>?"
        }
      },
      "scope": {
        "prelude": "[( <scope-start> )]? [to ( <scope-end> )]?",
        "descriptors": null
      },
      "starting-style": {
        "prelude": null,
        "descriptors": null
      },
      "supports": {
        "prelude": "<supports-condition>",
        "descriptors": null
      },
      "container": {
        "prelude": "[<container-name>]? <container-condition>",
        "descriptors": null
      },
      "nest": {
        "prelude": "<complex-selector-list>",
        "descriptors": null
      }
    }
  };
  const PLUSSIGN$5 = 43;
  const HYPHENMINUS$2 = 45;
  const N = 110;
  const DISALLOW_SIGN = true;
  const ALLOW_SIGN = false;
  function checkInteger(offset, disallowSign) {
    let pos = this.tokenStart + offset;
    const code2 = this.charCodeAt(pos);
    if (code2 === PLUSSIGN$5 || code2 === HYPHENMINUS$2) {
      if (disallowSign) {
        this.error("Number sign is not allowed");
      }
      pos++;
    }
    for (; pos < this.tokenEnd; pos++) {
      if (!isDigit(this.charCodeAt(pos))) {
        this.error("Integer is expected", pos);
      }
    }
  }
  function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
  }
  function expectCharCode(offset, code2) {
    if (!this.cmpChar(this.tokenStart + offset, code2)) {
      let msg = "";
      switch (code2) {
        case N:
          msg = "N is expected";
          break;
        case HYPHENMINUS$2:
          msg = "HyphenMinus is expected";
          break;
      }
      this.error(msg, this.tokenStart + offset);
    }
  }
  function consumeB() {
    let offset = 0;
    let sign2 = 0;
    let type2 = this.tokenType;
    while (type2 === WhiteSpace$1 || type2 === Comment$1) {
      type2 = this.lookupType(++offset);
    }
    if (type2 !== Number$2) {
      if (this.isDelim(PLUSSIGN$5, offset) || this.isDelim(HYPHENMINUS$2, offset)) {
        sign2 = this.isDelim(PLUSSIGN$5, offset) ? PLUSSIGN$5 : HYPHENMINUS$2;
        do {
          type2 = this.lookupType(++offset);
        } while (type2 === WhiteSpace$1 || type2 === Comment$1);
        if (type2 !== Number$2) {
          this.skip(offset);
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
        }
      } else {
        return null;
      }
    }
    if (offset > 0) {
      this.skip(offset);
    }
    if (sign2 === 0) {
      type2 = this.charCodeAt(this.tokenStart);
      if (type2 !== PLUSSIGN$5 && type2 !== HYPHENMINUS$2) {
        this.error("Number sign is expected");
      }
    }
    checkTokenIsInteger.call(this, sign2 !== 0);
    return sign2 === HYPHENMINUS$2 ? "-" + this.consume(Number$2) : this.consume(Number$2);
  }
  const name$M = "AnPlusB";
  const structure$M = {
    a: [
      String,
      null
    ],
    b: [
      String,
      null
    ]
  };
  function parse$N() {
    const start = this.tokenStart;
    let a = null;
    let b = null;
    if (this.tokenType === Number$2) {
      checkTokenIsInteger.call(this, ALLOW_SIGN);
      b = this.consume(Number$2);
    } else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS$2)) {
      a = "-1";
      expectCharCode.call(this, 1, N);
      switch (this.tokenEnd - this.tokenStart) {
        case 2:
          this.next();
          b = consumeB.call(this);
          break;
        case 3:
          expectCharCode.call(this, 2, HYPHENMINUS$2);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(Number$2);
          break;
        default:
          expectCharCode.call(this, 2, HYPHENMINUS$2);
          checkInteger.call(this, 3, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(start + 2);
      }
    } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN$5) && this.lookupType(1) === Ident) {
      let sign2 = 0;
      a = "1";
      if (this.isDelim(PLUSSIGN$5)) {
        sign2 = 1;
        this.next();
      }
      expectCharCode.call(this, 0, N);
      switch (this.tokenEnd - this.tokenStart) {
        case 1:
          this.next();
          b = consumeB.call(this);
          break;
        case 2:
          expectCharCode.call(this, 1, HYPHENMINUS$2);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(Number$2);
          break;
        default:
          expectCharCode.call(this, 1, HYPHENMINUS$2);
          checkInteger.call(this, 2, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(start + sign2 + 1);
      }
    } else if (this.tokenType === Dimension$1) {
      const code2 = this.charCodeAt(this.tokenStart);
      const sign2 = code2 === PLUSSIGN$5 || code2 === HYPHENMINUS$2;
      let i22 = this.tokenStart + sign2;
      for (; i22 < this.tokenEnd; i22++) {
        if (!isDigit(this.charCodeAt(i22))) {
          break;
        }
      }
      if (i22 === this.tokenStart + sign2) {
        this.error("Integer is expected", this.tokenStart + sign2);
      }
      expectCharCode.call(this, i22 - this.tokenStart, N);
      a = this.substring(start, i22);
      if (i22 + 1 === this.tokenEnd) {
        this.next();
        b = consumeB.call(this);
      } else {
        expectCharCode.call(this, i22 - this.tokenStart + 1, HYPHENMINUS$2);
        if (i22 + 2 === this.tokenEnd) {
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(Number$2);
        } else {
          checkInteger.call(this, i22 - this.tokenStart + 2, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(i22 + 1);
        }
      }
    } else {
      this.error();
    }
    if (a !== null && a.charCodeAt(0) === PLUSSIGN$5) {
      a = a.substr(1);
    }
    if (b !== null && b.charCodeAt(0) === PLUSSIGN$5) {
      b = b.substr(1);
    }
    return {
      type: "AnPlusB",
      loc: this.getLocation(start, this.tokenStart),
      a,
      b
    };
  }
  function generate$N(node2) {
    if (node2.a) {
      const a = node2.a === "+1" && "n" || node2.a === "1" && "n" || node2.a === "-1" && "-n" || node2.a + "n";
      if (node2.b) {
        const b = node2.b[0] === "-" || node2.b[0] === "+" ? node2.b : "+" + node2.b;
        this.tokenize(a + b);
      } else {
        this.tokenize(a);
      }
    } else {
      this.tokenize(node2.b);
    }
  }
  const AnPlusB = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$N,
    name: name$M,
    parse: parse$N,
    structure: structure$M
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function consumeRaw$4() {
    return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, true);
  }
  function isDeclarationBlockAtrule() {
    for (let offset = 1, type2; type2 = this.lookupType(offset); offset++) {
      if (type2 === RightCurlyBracket) {
        return true;
      }
      if (type2 === LeftCurlyBracket || type2 === AtKeyword) {
        return false;
      }
    }
    return false;
  }
  const name$L = "Atrule";
  const walkContext$9 = "atrule";
  const structure$L = {
    name: String,
    prelude: [
      "AtrulePrelude",
      "Raw",
      null
    ],
    block: [
      "Block",
      null
    ]
  };
  function parse$M(isDeclaration = false) {
    const start = this.tokenStart;
    let name2;
    let nameLowerCase;
    let prelude = null;
    let block = null;
    this.eat(AtKeyword);
    name2 = this.substrToCursor(start + 1);
    nameLowerCase = name2.toLowerCase();
    this.skipSC();
    if (this.eof === false && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
      if (this.parseAtrulePrelude) {
        prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name2, isDeclaration), consumeRaw$4);
      } else {
        prelude = consumeRaw$4.call(this, this.tokenIndex);
      }
      this.skipSC();
    }
    switch (this.tokenType) {
      case Semicolon:
        this.next();
        break;
      case LeftCurlyBracket:
        if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
          block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
        } else {
          block = this.Block(isDeclarationBlockAtrule.call(this));
        }
        break;
    }
    return {
      type: "Atrule",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      prelude,
      block
    };
  }
  function generate$M(node2) {
    this.token(AtKeyword, "@" + node2.name);
    if (node2.prelude !== null) {
      this.node(node2.prelude);
    }
    if (node2.block) {
      this.node(node2.block);
    } else {
      this.token(Semicolon, ";");
    }
  }
  const Atrule = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$M,
    name: name$L,
    parse: parse$M,
    structure: structure$L,
    walkContext: walkContext$9
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$K = "AtrulePrelude";
  const walkContext$8 = "atrulePrelude";
  const structure$K = {
    children: [
      []
    ]
  };
  function parse$L(name2) {
    let children = null;
    if (name2 !== null) {
      name2 = name2.toLowerCase();
    }
    this.skipSC();
    if (hasOwnProperty.call(this.atrule, name2) && typeof this.atrule[name2].prelude === "function") {
      children = this.atrule[name2].prelude.call(this);
    } else {
      children = this.readSequence(this.scope.AtrulePrelude);
    }
    this.skipSC();
    if (this.eof !== true && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
      this.error("Semicolon or block is expected");
    }
    return {
      type: "AtrulePrelude",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$L(node2) {
    this.children(node2);
  }
  const AtrulePrelude = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$L,
    name: name$K,
    parse: parse$L,
    structure: structure$K,
    walkContext: walkContext$8
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const DOLLARSIGN$1 = 36;
  const ASTERISK$5 = 42;
  const EQUALSSIGN$1 = 61;
  const CIRCUMFLEXACCENT = 94;
  const VERTICALLINE$2 = 124;
  const TILDE$2 = 126;
  function getAttributeName() {
    if (this.eof) {
      this.error("Unexpected end of input");
    }
    const start = this.tokenStart;
    let expectIdent = false;
    if (this.isDelim(ASTERISK$5)) {
      expectIdent = true;
      this.next();
    } else if (!this.isDelim(VERTICALLINE$2)) {
      this.eat(Ident);
    }
    if (this.isDelim(VERTICALLINE$2)) {
      if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN$1) {
        this.next();
        this.eat(Ident);
      } else if (expectIdent) {
        this.error("Identifier is expected", this.tokenEnd);
      }
    } else if (expectIdent) {
      this.error("Vertical line is expected");
    }
    return {
      type: "Identifier",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  function getOperator() {
    const start = this.tokenStart;
    const code2 = this.charCodeAt(start);
    if (code2 !== EQUALSSIGN$1 && code2 !== TILDE$2 && code2 !== CIRCUMFLEXACCENT && code2 !== DOLLARSIGN$1 && code2 !== ASTERISK$5 && code2 !== VERTICALLINE$2) {
      this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
    }
    this.next();
    if (code2 !== EQUALSSIGN$1) {
      if (!this.isDelim(EQUALSSIGN$1)) {
        this.error("Equal sign is expected");
      }
      this.next();
    }
    return this.substrToCursor(start);
  }
  const name$J = "AttributeSelector";
  const structure$J = {
    name: "Identifier",
    matcher: [
      String,
      null
    ],
    value: [
      "String",
      "Identifier",
      null
    ],
    flags: [
      String,
      null
    ]
  };
  function parse$K() {
    const start = this.tokenStart;
    let name2;
    let matcher = null;
    let value2 = null;
    let flags = null;
    this.eat(LeftSquareBracket);
    this.skipSC();
    name2 = getAttributeName.call(this);
    this.skipSC();
    if (this.tokenType !== RightSquareBracket) {
      if (this.tokenType !== Ident) {
        matcher = getOperator.call(this);
        this.skipSC();
        value2 = this.tokenType === String$2 ? this.String() : this.Identifier();
        this.skipSC();
      }
      if (this.tokenType === Ident) {
        flags = this.consume(Ident);
        this.skipSC();
      }
    }
    this.eat(RightSquareBracket);
    return {
      type: "AttributeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      matcher,
      value: value2,
      flags
    };
  }
  function generate$K(node2) {
    this.token(Delim, "[");
    this.node(node2.name);
    if (node2.matcher !== null) {
      this.tokenize(node2.matcher);
      this.node(node2.value);
    }
    if (node2.flags !== null) {
      this.token(Ident, node2.flags);
    }
    this.token(Delim, "]");
  }
  const AttributeSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$K,
    name: name$J,
    parse: parse$K,
    structure: structure$J
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const AMPERSAND$4 = 38;
  function consumeRaw$3() {
    return this.Raw(null, true);
  }
  function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw$3);
  }
  function consumeRawDeclaration() {
    return this.Raw(this.consumeUntilSemicolonIncluded, true);
  }
  function consumeDeclaration() {
    if (this.tokenType === Semicolon) {
      return consumeRawDeclaration.call(this, this.tokenIndex);
    }
    const node2 = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
    if (this.tokenType === Semicolon) {
      this.next();
    }
    return node2;
  }
  const name$I = "Block";
  const walkContext$7 = "block";
  const structure$I = {
    children: [
      [
        "Atrule",
        "Rule",
        "Declaration"
      ]
    ]
  };
  function parse$J(isStyleBlock) {
    const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
    const start = this.tokenStart;
    let children = this.createList();
    this.eat(LeftCurlyBracket);
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case RightCurlyBracket:
            break scan;
          case WhiteSpace$1:
          case Comment$1:
            this.next();
            break;
          case AtKeyword:
            children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw$3));
            break;
          default:
            if (isStyleBlock && this.isDelim(AMPERSAND$4)) {
              children.push(consumeRule.call(this));
            } else {
              children.push(consumer.call(this));
            }
        }
      }
    if (!this.eof) {
      this.eat(RightCurlyBracket);
    }
    return {
      type: "Block",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate$J(node2) {
    this.token(LeftCurlyBracket, "{");
    this.children(node2, (prev) => {
      if (prev.type === "Declaration") {
        this.token(Semicolon, ";");
      }
    });
    this.token(RightCurlyBracket, "}");
  }
  const Block = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$J,
    name: name$I,
    parse: parse$J,
    structure: structure$I,
    walkContext: walkContext$7
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$H = "Brackets";
  const structure$H = {
    children: [
      []
    ]
  };
  function parse$I(readSequence2, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(LeftSquareBracket);
    children = readSequence2.call(this, recognizer);
    if (!this.eof) {
      this.eat(RightSquareBracket);
    }
    return {
      type: "Brackets",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate$I(node2) {
    this.token(Delim, "[");
    this.children(node2);
    this.token(Delim, "]");
  }
  const Brackets = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$I,
    name: name$H,
    parse: parse$I,
    structure: structure$H
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$G = "CDC";
  const structure$G = [];
  function parse$H() {
    const start = this.tokenStart;
    this.eat(CDC$1);
    return {
      type: "CDC",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate$H() {
    this.token(CDC$1, "-->");
  }
  const CDC = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$H,
    name: name$G,
    parse: parse$H,
    structure: structure$G
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$F = "CDO";
  const structure$F = [];
  function parse$G() {
    const start = this.tokenStart;
    this.eat(CDO$1);
    return {
      type: "CDO",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate$G() {
    this.token(CDO$1, "<!--");
  }
  const CDO = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$G,
    name: name$F,
    parse: parse$G,
    structure: structure$F
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const FULLSTOP$2 = 46;
  const name$E = "ClassSelector";
  const structure$E = {
    name: String
  };
  function parse$F() {
    this.eatDelim(FULLSTOP$2);
    return {
      type: "ClassSelector",
      loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
      name: this.consume(Ident)
    };
  }
  function generate$F(node2) {
    this.token(Delim, ".");
    this.token(Ident, node2.name);
  }
  const ClassSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$F,
    name: name$E,
    parse: parse$F,
    structure: structure$E
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const PLUSSIGN$4 = 43;
  const SOLIDUS$7 = 47;
  const GREATERTHANSIGN$2 = 62;
  const TILDE$1 = 126;
  const name$D = "Combinator";
  const structure$D = {
    name: String
  };
  function parse$E() {
    const start = this.tokenStart;
    let name2;
    switch (this.tokenType) {
      case WhiteSpace$1:
        name2 = " ";
        break;
      case Delim:
        switch (this.charCodeAt(this.tokenStart)) {
          case GREATERTHANSIGN$2:
          case PLUSSIGN$4:
          case TILDE$1:
            this.next();
            break;
          case SOLIDUS$7:
            this.next();
            this.eatIdent("deep");
            this.eatDelim(SOLIDUS$7);
            break;
          default:
            this.error("Combinator is expected");
        }
        name2 = this.substrToCursor(start);
        break;
    }
    return {
      type: "Combinator",
      loc: this.getLocation(start, this.tokenStart),
      name: name2
    };
  }
  function generate$E(node2) {
    this.tokenize(node2.name);
  }
  const Combinator = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$E,
    name: name$D,
    parse: parse$E,
    structure: structure$D
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const ASTERISK$4 = 42;
  const SOLIDUS$6 = 47;
  const name$C = "Comment";
  const structure$C = {
    value: String
  };
  function parse$D() {
    const start = this.tokenStart;
    let end = this.tokenEnd;
    this.eat(Comment$1);
    if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK$4 && this.charCodeAt(end - 1) === SOLIDUS$6) {
      end -= 2;
    }
    return {
      type: "Comment",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substring(start + 2, end)
    };
  }
  function generate$D(node2) {
    this.token(Comment$1, "/*" + node2.value + "*/");
  }
  const Comment = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$D,
    name: name$C,
    parse: parse$D,
    structure: structure$C
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const likelyFeatureToken = /* @__PURE__ */ new Set([
    Colon,
    RightParenthesis,
    EOF$1
  ]);
  const name$B = "Condition";
  const structure$B = {
    kind: String,
    children: [
      [
        "Identifier",
        "Feature",
        "FeatureFunction",
        "FeatureRange",
        "SupportsDeclaration"
      ]
    ]
  };
  function featureOrRange(kind) {
    if (this.lookupTypeNonSC(1) === Ident && likelyFeatureToken.has(this.lookupTypeNonSC(2))) {
      return this.Feature(kind);
    }
    return this.FeatureRange(kind);
  }
  const parentheses = {
    media: featureOrRange,
    container: featureOrRange,
    supports() {
      return this.SupportsDeclaration();
    }
  };
  function parse$C(kind = "media") {
    const children = this.createList();
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case Comment$1:
          case WhiteSpace$1:
            this.next();
            continue;
          case Ident:
            children.push(this.Identifier());
            break;
          case LeftParenthesis: {
            let term = this.parseWithFallback(() => parentheses[kind].call(this, kind), () => null);
            if (!term) {
              term = this.parseWithFallback(() => {
                this.eat(LeftParenthesis);
                const res = this.Condition(kind);
                this.eat(RightParenthesis);
                return res;
              }, () => {
                return this.GeneralEnclosed(kind);
              });
            }
            children.push(term);
            break;
          }
          case Function$2: {
            let term = this.parseWithFallback(() => this.FeatureFunction(kind), () => null);
            if (!term) {
              term = this.GeneralEnclosed(kind);
            }
            children.push(term);
            break;
          }
          default:
            break scan;
        }
      }
    if (children.isEmpty) {
      this.error("Condition is expected");
    }
    return {
      type: "Condition",
      loc: this.getLocationFromList(children),
      kind,
      children
    };
  }
  function generate$C(node2) {
    node2.children.forEach((child) => {
      if (child.type === "Condition") {
        this.token(LeftParenthesis, "(");
        this.node(child);
        this.token(RightParenthesis, ")");
      } else {
        this.node(child);
      }
    });
  }
  const Condition = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$C,
    name: name$B,
    parse: parse$C,
    structure: structure$B
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const EXCLAMATIONMARK$1 = 33;
  const NUMBERSIGN$2 = 35;
  const DOLLARSIGN = 36;
  const AMPERSAND$3 = 38;
  const ASTERISK$3 = 42;
  const PLUSSIGN$3 = 43;
  const SOLIDUS$5 = 47;
  function consumeValueRaw() {
    return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, true);
  }
  function consumeCustomPropertyRaw() {
    return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
  }
  function consumeValue() {
    const startValueToken = this.tokenIndex;
    const value2 = this.Value();
    if (value2.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon && this.isDelim(EXCLAMATIONMARK$1) === false && this.isBalanceEdge(startValueToken) === false) {
      this.error();
    }
    return value2;
  }
  const name$A = "Declaration";
  const walkContext$6 = "declaration";
  const structure$A = {
    important: [
      Boolean,
      String
    ],
    property: String,
    value: [
      "Value",
      "Raw"
    ]
  };
  function parse$B() {
    const start = this.tokenStart;
    const startToken = this.tokenIndex;
    const property2 = readProperty.call(this);
    const customProperty = isCustomProperty(property2);
    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    const consumeRaw2 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    let important = false;
    let value2;
    this.skipSC();
    this.eat(Colon);
    const valueStart = this.tokenIndex;
    if (!customProperty) {
      this.skipSC();
    }
    if (parseValue) {
      value2 = this.parseWithFallback(consumeValue, consumeRaw2);
    } else {
      value2 = consumeRaw2.call(this, this.tokenIndex);
    }
    if (customProperty && value2.type === "Value" && value2.children.isEmpty) {
      for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
        if (this.lookupType(offset) === WhiteSpace$1) {
          value2.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    if (this.isDelim(EXCLAMATIONMARK$1)) {
      important = getImportant.call(this);
      this.skipSC();
    }
    if (this.eof === false && this.tokenType !== Semicolon && this.isBalanceEdge(startToken) === false) {
      this.error();
    }
    return {
      type: "Declaration",
      loc: this.getLocation(start, this.tokenStart),
      important,
      property: property2,
      value: value2
    };
  }
  function generate$B(node2) {
    this.token(Ident, node2.property);
    this.token(Colon, ":");
    this.node(node2.value);
    if (node2.important) {
      this.token(Delim, "!");
      this.token(Ident, node2.important === true ? "important" : node2.important);
    }
  }
  function readProperty() {
    const start = this.tokenStart;
    if (this.tokenType === Delim) {
      switch (this.charCodeAt(this.tokenStart)) {
        case ASTERISK$3:
        case DOLLARSIGN:
        case PLUSSIGN$3:
        case NUMBERSIGN$2:
        case AMPERSAND$3:
          this.next();
          break;
        case SOLIDUS$5:
          this.next();
          if (this.isDelim(SOLIDUS$5)) {
            this.next();
          }
          break;
      }
    }
    if (this.tokenType === Hash$1) {
      this.eat(Hash$1);
    } else {
      this.eat(Ident);
    }
    return this.substrToCursor(start);
  }
  function getImportant() {
    this.eat(Delim);
    this.skipSC();
    const important = this.consume(Ident);
    return important === "important" ? true : important;
  }
  const Declaration = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$B,
    name: name$A,
    parse: parse$B,
    structure: structure$A,
    walkContext: walkContext$6
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const AMPERSAND$2 = 38;
  function consumeRaw$2() {
    return this.Raw(this.consumeUntilSemicolonIncluded, true);
  }
  const name$z = "DeclarationList";
  const structure$z = {
    children: [
      [
        "Declaration",
        "Atrule",
        "Rule"
      ]
    ]
  };
  function parse$A() {
    const children = this.createList();
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace$1:
        case Comment$1:
        case Semicolon:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw$2));
          break;
        default:
          if (this.isDelim(AMPERSAND$2)) {
            children.push(this.parseWithFallback(this.Rule, consumeRaw$2));
          } else {
            children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
          }
      }
    }
    return {
      type: "DeclarationList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$A(node2) {
    this.children(node2, (prev) => {
      if (prev.type === "Declaration") {
        this.token(Semicolon, ";");
      }
    });
  }
  const DeclarationList = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$A,
    name: name$z,
    parse: parse$A,
    structure: structure$z
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$y = "Dimension";
  const structure$y = {
    value: String,
    unit: String
  };
  function parse$z() {
    const start = this.tokenStart;
    const value2 = this.consumeNumber(Dimension$1);
    return {
      type: "Dimension",
      loc: this.getLocation(start, this.tokenStart),
      value: value2,
      unit: this.substring(start + value2.length, this.tokenStart)
    };
  }
  function generate$z(node2) {
    this.token(Dimension$1, node2.value + node2.unit);
  }
  const Dimension = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$z,
    name: name$y,
    parse: parse$z,
    structure: structure$y
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const SOLIDUS$4 = 47;
  const name$x = "Feature";
  const structure$x = {
    kind: String,
    name: String,
    value: [
      "Identifier",
      "Number",
      "Dimension",
      "Ratio",
      "Function",
      null
    ]
  };
  function parse$y(kind) {
    const start = this.tokenStart;
    let name2;
    let value2 = null;
    this.eat(LeftParenthesis);
    this.skipSC();
    name2 = this.consume(Ident);
    this.skipSC();
    if (this.tokenType !== RightParenthesis) {
      this.eat(Colon);
      this.skipSC();
      switch (this.tokenType) {
        case Number$2:
          if (this.lookupNonWSType(1) === Delim) {
            value2 = this.Ratio();
          } else {
            value2 = this.Number();
          }
          break;
        case Dimension$1:
          value2 = this.Dimension();
          break;
        case Ident:
          value2 = this.Identifier();
          break;
        case Function$2:
          value2 = this.parseWithFallback(() => {
            const res = this.Function(this.readSequence, this.scope.Value);
            this.skipSC();
            if (this.isDelim(SOLIDUS$4)) {
              this.error();
            }
            return res;
          }, () => {
            return this.Ratio();
          });
          break;
        default:
          this.error("Number, dimension, ratio or identifier is expected");
      }
      this.skipSC();
    }
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "Feature",
      loc: this.getLocation(start, this.tokenStart),
      kind,
      name: name2,
      value: value2
    };
  }
  function generate$y(node2) {
    this.token(LeftParenthesis, "(");
    this.token(Ident, node2.name);
    if (node2.value !== null) {
      this.token(Colon, ":");
      this.node(node2.value);
    }
    this.token(RightParenthesis, ")");
  }
  const Feature = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$y,
    name: name$x,
    parse: parse$y,
    structure: structure$x
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$w = "FeatureFunction";
  const structure$w = {
    kind: String,
    feature: String,
    value: [
      "Declaration",
      "Selector"
    ]
  };
  function getFeatureParser(kind, name2) {
    const featuresOfKind = this.features[kind] || {};
    const parser = featuresOfKind[name2];
    if (typeof parser !== "function") {
      this.error(`Unknown feature ${name2}()`);
    }
    return parser;
  }
  function parse$x(kind = "unknown") {
    const start = this.tokenStart;
    const functionName = this.consumeFunctionName();
    const valueParser = getFeatureParser.call(this, kind, functionName.toLowerCase());
    this.skipSC();
    const value2 = this.parseWithFallback(() => {
      const startValueToken = this.tokenIndex;
      const value3 = valueParser.call(this);
      if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return value3;
    }, () => this.Raw(null, false));
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "FeatureFunction",
      loc: this.getLocation(start, this.tokenStart),
      kind,
      feature: functionName,
      value: value2
    };
  }
  function generate$x(node2) {
    this.token(Function$2, node2.feature + "(");
    this.node(node2.value);
    this.token(RightParenthesis, ")");
  }
  const FeatureFunction = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$x,
    name: name$w,
    parse: parse$x,
    structure: structure$w
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const SOLIDUS$3 = 47;
  const LESSTHANSIGN = 60;
  const EQUALSSIGN = 61;
  const GREATERTHANSIGN$1 = 62;
  const name$v = "FeatureRange";
  const structure$v = {
    kind: String,
    left: [
      "Identifier",
      "Number",
      "Dimension",
      "Ratio",
      "Function"
    ],
    leftComparison: String,
    middle: [
      "Identifier",
      "Number",
      "Dimension",
      "Ratio",
      "Function"
    ],
    rightComparison: [
      String,
      null
    ],
    right: [
      "Identifier",
      "Number",
      "Dimension",
      "Ratio",
      "Function",
      null
    ]
  };
  function readTerm() {
    this.skipSC();
    switch (this.tokenType) {
      case Number$2:
        if (this.isDelim(SOLIDUS$3, this.lookupOffsetNonSC(1))) {
          return this.Ratio();
        } else {
          return this.Number();
        }
      case Dimension$1:
        return this.Dimension();
      case Ident:
        return this.Identifier();
      case Function$2:
        return this.parseWithFallback(() => {
          const res = this.Function(this.readSequence, this.scope.Value);
          this.skipSC();
          if (this.isDelim(SOLIDUS$3)) {
            this.error();
          }
          return res;
        }, () => {
          return this.Ratio();
        });
      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }
  }
  function readComparison(expectColon) {
    this.skipSC();
    if (this.isDelim(LESSTHANSIGN) || this.isDelim(GREATERTHANSIGN$1)) {
      const value2 = this.source[this.tokenStart];
      this.next();
      if (this.isDelim(EQUALSSIGN)) {
        this.next();
        return value2 + "=";
      }
      return value2;
    }
    if (this.isDelim(EQUALSSIGN)) {
      return "=";
    }
    this.error(`Expected ${expectColon ? '":", ' : ""}"<", ">", "=" or ")"`);
  }
  function parse$w(kind = "unknown") {
    const start = this.tokenStart;
    this.skipSC();
    this.eat(LeftParenthesis);
    const left = readTerm.call(this);
    const leftComparison = readComparison.call(this, left.type === "Identifier");
    const middle = readTerm.call(this);
    let rightComparison = null;
    let right = null;
    if (this.lookupNonWSType(0) !== RightParenthesis) {
      rightComparison = readComparison.call(this);
      right = readTerm.call(this);
    }
    this.skipSC();
    this.eat(RightParenthesis);
    return {
      type: "FeatureRange",
      loc: this.getLocation(start, this.tokenStart),
      kind,
      left,
      leftComparison,
      middle,
      rightComparison,
      right
    };
  }
  function generate$w(node2) {
    this.token(LeftParenthesis, "(");
    this.node(node2.left);
    this.tokenize(node2.leftComparison);
    this.node(node2.middle);
    if (node2.right) {
      this.tokenize(node2.rightComparison);
      this.node(node2.right);
    }
    this.token(RightParenthesis, ")");
  }
  const FeatureRange = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$w,
    name: name$v,
    parse: parse$w,
    structure: structure$v
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$u = "Function";
  const walkContext$5 = "function";
  const structure$u = {
    name: String,
    children: [
      []
    ]
  };
  function parse$v(readSequence2, recognizer) {
    const start = this.tokenStart;
    const name2 = this.consumeFunctionName();
    const nameLowerCase = name2.toLowerCase();
    let children;
    children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence2.call(this, recognizer);
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "Function",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate$v(node2) {
    this.token(Function$2, node2.name + "(");
    this.children(node2);
    this.token(RightParenthesis, ")");
  }
  const Function$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$v,
    name: name$u,
    parse: parse$v,
    structure: structure$u,
    walkContext: walkContext$5
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$t = "GeneralEnclosed";
  const structure$t = {
    kind: String,
    function: [
      String,
      null
    ],
    children: [
      []
    ]
  };
  function parse$u(kind) {
    const start = this.tokenStart;
    let functionName = null;
    if (this.tokenType === Function$2) {
      functionName = this.consumeFunctionName();
    } else {
      this.eat(LeftParenthesis);
    }
    const children = this.parseWithFallback(() => {
      const startValueToken = this.tokenIndex;
      const children2 = this.readSequence(this.scope.Value);
      if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return children2;
    }, () => this.createSingleNodeList(this.Raw(null, false)));
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "GeneralEnclosed",
      loc: this.getLocation(start, this.tokenStart),
      kind,
      function: functionName,
      children
    };
  }
  function generate$u(node2) {
    if (node2.function) {
      this.token(Function$2, node2.function + "(");
    } else {
      this.token(LeftParenthesis, "(");
    }
    this.children(node2);
    this.token(RightParenthesis, ")");
  }
  const GeneralEnclosed = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$u,
    name: name$t,
    parse: parse$u,
    structure: structure$t
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const xxx = "XXX";
  const name$s = "Hash";
  const structure$s = {
    value: String
  };
  function parse$t() {
    const start = this.tokenStart;
    this.eat(Hash$1);
    return {
      type: "Hash",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start + 1)
    };
  }
  function generate$t(node2) {
    this.token(Hash$1, "#" + node2.value);
  }
  const Hash = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$t,
    name: name$s,
    parse: parse$t,
    structure: structure$s,
    xxx
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$r = "Identifier";
  const structure$r = {
    name: String
  };
  function parse$s() {
    return {
      type: "Identifier",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      name: this.consume(Ident)
    };
  }
  function generate$s(node2) {
    this.token(Ident, node2.name);
  }
  const Identifier = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$s,
    name: name$r,
    parse: parse$s,
    structure: structure$r
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$q = "IdSelector";
  const structure$q = {
    name: String
  };
  function parse$r() {
    const start = this.tokenStart;
    this.eat(Hash$1);
    return {
      type: "IdSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start + 1)
    };
  }
  function generate$r(node2) {
    this.token(Delim, "#" + node2.name);
  }
  const IdSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$r,
    name: name$q,
    parse: parse$r,
    structure: structure$q
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const FULLSTOP$1 = 46;
  const name$p = "Layer";
  const structure$p = {
    name: String
  };
  function parse$q() {
    let tokenStart = this.tokenStart;
    let name2 = this.consume(Ident);
    while (this.isDelim(FULLSTOP$1)) {
      this.eat(Delim);
      name2 += "." + this.consume(Ident);
    }
    return {
      type: "Layer",
      loc: this.getLocation(tokenStart, this.tokenStart),
      name: name2
    };
  }
  function generate$q(node2) {
    this.tokenize(node2.name);
  }
  const Layer = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$q,
    name: name$p,
    parse: parse$q,
    structure: structure$p
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$o = "LayerList";
  const structure$o = {
    children: [
      [
        "Layer"
      ]
    ]
  };
  function parse$p() {
    const children = this.createList();
    this.skipSC();
    while (!this.eof) {
      children.push(this.Layer());
      if (this.lookupTypeNonSC(0) !== Comma) {
        break;
      }
      this.skipSC();
      this.next();
      this.skipSC();
    }
    return {
      type: "LayerList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$p(node2) {
    this.children(node2, () => this.token(Comma, ","));
  }
  const LayerList = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$p,
    name: name$o,
    parse: parse$p,
    structure: structure$o
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$n = "MediaQuery";
  const structure$n = {
    modifier: [
      String,
      null
    ],
    mediaType: [
      String,
      null
    ],
    condition: [
      "Condition",
      null
    ]
  };
  function parse$o() {
    const start = this.tokenStart;
    let modifier = null;
    let mediaType = null;
    let condition = null;
    this.skipSC();
    if (this.tokenType === Ident && this.lookupTypeNonSC(1) !== LeftParenthesis) {
      const ident = this.consume(Ident);
      const identLowerCase = ident.toLowerCase();
      if (identLowerCase === "not" || identLowerCase === "only") {
        this.skipSC();
        modifier = identLowerCase;
        mediaType = this.consume(Ident);
      } else {
        mediaType = ident;
      }
      switch (this.lookupTypeNonSC(0)) {
        case Ident: {
          this.skipSC();
          this.eatIdent("and");
          condition = this.Condition("media");
          break;
        }
        case LeftCurlyBracket:
        case Semicolon:
        case Comma:
        case EOF$1:
          break;
        default:
          this.error("Identifier or parenthesis is expected");
      }
    } else {
      switch (this.tokenType) {
        case Ident:
        case LeftParenthesis:
        case Function$2: {
          condition = this.Condition("media");
          break;
        }
        case LeftCurlyBracket:
        case Semicolon:
        case EOF$1:
          break;
        default:
          this.error("Identifier or parenthesis is expected");
      }
    }
    return {
      type: "MediaQuery",
      loc: this.getLocation(start, this.tokenStart),
      modifier,
      mediaType,
      condition
    };
  }
  function generate$o(node2) {
    if (node2.mediaType) {
      if (node2.modifier) {
        this.token(Ident, node2.modifier);
      }
      this.token(Ident, node2.mediaType);
      if (node2.condition) {
        this.token(Ident, "and");
        this.node(node2.condition);
      }
    } else if (node2.condition) {
      this.node(node2.condition);
    }
  }
  const MediaQuery = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$o,
    name: name$n,
    parse: parse$o,
    structure: structure$n
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$m = "MediaQueryList";
  const structure$m = {
    children: [
      [
        "MediaQuery"
      ]
    ]
  };
  function parse$n() {
    const children = this.createList();
    this.skipSC();
    while (!this.eof) {
      children.push(this.MediaQuery());
      if (this.tokenType !== Comma) {
        break;
      }
      this.next();
    }
    return {
      type: "MediaQueryList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$n(node2) {
    this.children(node2, () => this.token(Comma, ","));
  }
  const MediaQueryList = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$n,
    name: name$m,
    parse: parse$n,
    structure: structure$m
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const AMPERSAND$1 = 38;
  const name$l = "NestingSelector";
  const structure$l = {};
  function parse$m() {
    const start = this.tokenStart;
    this.eatDelim(AMPERSAND$1);
    return {
      type: "NestingSelector",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate$m() {
    this.token(Delim, "&");
  }
  const NestingSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$m,
    name: name$l,
    parse: parse$m,
    structure: structure$l
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$k = "Nth";
  const structure$k = {
    nth: [
      "AnPlusB",
      "Identifier"
    ],
    selector: [
      "SelectorList",
      null
    ]
  };
  function parse$l() {
    this.skipSC();
    const start = this.tokenStart;
    let end = start;
    let selector2 = null;
    let nth2;
    if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
      nth2 = this.Identifier();
    } else {
      nth2 = this.AnPlusB();
    }
    end = this.tokenStart;
    this.skipSC();
    if (this.lookupValue(0, "of")) {
      this.next();
      selector2 = this.SelectorList();
      end = this.tokenStart;
    }
    return {
      type: "Nth",
      loc: this.getLocation(start, end),
      nth: nth2,
      selector: selector2
    };
  }
  function generate$l(node2) {
    this.node(node2.nth);
    if (node2.selector !== null) {
      this.token(Ident, "of");
      this.node(node2.selector);
    }
  }
  const Nth = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$l,
    name: name$k,
    parse: parse$l,
    structure: structure$k
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$j = "Number";
  const structure$j = {
    value: String
  };
  function parse$k() {
    return {
      type: "Number",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consume(Number$2)
    };
  }
  function generate$k(node2) {
    this.token(Number$2, node2.value);
  }
  const Number$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$k,
    name: name$j,
    parse: parse$k,
    structure: structure$j
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$i = "Operator";
  const structure$i = {
    value: String
  };
  function parse$j() {
    const start = this.tokenStart;
    this.next();
    return {
      type: "Operator",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  function generate$j(node2) {
    this.tokenize(node2.value);
  }
  const Operator = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$j,
    name: name$i,
    parse: parse$j,
    structure: structure$i
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$h = "Parentheses";
  const structure$h = {
    children: [
      []
    ]
  };
  function parse$i(readSequence2, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(LeftParenthesis);
    children = readSequence2.call(this, recognizer);
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "Parentheses",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate$i(node2) {
    this.token(LeftParenthesis, "(");
    this.children(node2);
    this.token(RightParenthesis, ")");
  }
  const Parentheses = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$i,
    name: name$h,
    parse: parse$i,
    structure: structure$h
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$g = "Percentage";
  const structure$g = {
    value: String
  };
  function parse$h() {
    return {
      type: "Percentage",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consumeNumber(Percentage$1)
    };
  }
  function generate$h(node2) {
    this.token(Percentage$1, node2.value + "%");
  }
  const Percentage = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$h,
    name: name$g,
    parse: parse$h,
    structure: structure$g
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$f = "PseudoClassSelector";
  const walkContext$4 = "function";
  const structure$f = {
    name: String,
    children: [
      [
        "Raw"
      ],
      null
    ]
  };
  function parse$g() {
    const start = this.tokenStart;
    let children = null;
    let name2;
    let nameLowerCase;
    this.eat(Colon);
    if (this.tokenType === Function$2) {
      name2 = this.consumeFunctionName();
      nameLowerCase = name2.toLowerCase();
      if (this.lookupNonWSType(0) == RightParenthesis) {
        children = this.createList();
      } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(null, false));
      }
      this.eat(RightParenthesis);
    } else {
      name2 = this.consume(Ident);
    }
    return {
      type: "PseudoClassSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate$g(node2) {
    this.token(Colon, ":");
    if (node2.children === null) {
      this.token(Ident, node2.name);
    } else {
      this.token(Function$2, node2.name + "(");
      this.children(node2);
      this.token(RightParenthesis, ")");
    }
  }
  const PseudoClassSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$g,
    name: name$f,
    parse: parse$g,
    structure: structure$f,
    walkContext: walkContext$4
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$e = "PseudoElementSelector";
  const walkContext$3 = "function";
  const structure$e = {
    name: String,
    children: [
      [
        "Raw"
      ],
      null
    ]
  };
  function parse$f() {
    const start = this.tokenStart;
    let children = null;
    let name2;
    let nameLowerCase;
    this.eat(Colon);
    this.eat(Colon);
    if (this.tokenType === Function$2) {
      name2 = this.consumeFunctionName();
      nameLowerCase = name2.toLowerCase();
      if (this.lookupNonWSType(0) == RightParenthesis) {
        children = this.createList();
      } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(null, false));
      }
      this.eat(RightParenthesis);
    } else {
      name2 = this.consume(Ident);
    }
    return {
      type: "PseudoElementSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate$f(node2) {
    this.token(Colon, ":");
    this.token(Colon, ":");
    if (node2.children === null) {
      this.token(Ident, node2.name);
    } else {
      this.token(Function$2, node2.name + "(");
      this.children(node2);
      this.token(RightParenthesis, ")");
    }
  }
  const PseudoElementSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$f,
    name: name$e,
    parse: parse$f,
    structure: structure$e,
    walkContext: walkContext$3
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const SOLIDUS$2 = 47;
  function consumeTerm() {
    this.skipSC();
    switch (this.tokenType) {
      case Number$2:
        return this.Number();
      case Function$2:
        return this.Function(this.readSequence, this.scope.Value);
      default:
        this.error("Number of function is expected");
    }
  }
  const name$d = "Ratio";
  const structure$d = {
    left: [
      "Number",
      "Function"
    ],
    right: [
      "Number",
      "Function",
      null
    ]
  };
  function parse$e() {
    const start = this.tokenStart;
    const left = consumeTerm.call(this);
    let right = null;
    this.skipSC();
    if (this.isDelim(SOLIDUS$2)) {
      this.eatDelim(SOLIDUS$2);
      right = consumeTerm.call(this);
    }
    return {
      type: "Ratio",
      loc: this.getLocation(start, this.tokenStart),
      left,
      right
    };
  }
  function generate$e(node2) {
    this.node(node2.left);
    this.token(Delim, "/");
    if (node2.right) {
      this.node(node2.right);
    } else {
      this.node(Number$2, 1);
    }
  }
  const Ratio = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$e,
    name: name$d,
    parse: parse$e,
    structure: structure$d
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function getOffsetExcludeWS() {
    if (this.tokenIndex > 0) {
      if (this.lookupType(-1) === WhiteSpace$1) {
        return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
      }
    }
    return this.tokenStart;
  }
  const name$c = "Raw";
  const structure$c = {
    value: String
  };
  function parse$d(consumeUntil, excludeWhiteSpace) {
    const startOffset = this.getTokenStart(this.tokenIndex);
    let endOffset;
    this.skipUntilBalanced(this.tokenIndex, consumeUntil || this.consumeUntilBalanceEnd);
    if (excludeWhiteSpace && this.tokenStart > startOffset) {
      endOffset = getOffsetExcludeWS.call(this);
    } else {
      endOffset = this.tokenStart;
    }
    return {
      type: "Raw",
      loc: this.getLocation(startOffset, endOffset),
      value: this.substring(startOffset, endOffset)
    };
  }
  function generate$d(node2) {
    this.tokenize(node2.value);
  }
  const Raw = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$d,
    name: name$c,
    parse: parse$d,
    structure: structure$c
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function consumeRaw$1() {
    return this.Raw(this.consumeUntilLeftCurlyBracket, true);
  }
  function consumePrelude() {
    const prelude = this.SelectorList();
    if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket) {
      this.error();
    }
    return prelude;
  }
  const name$b = "Rule";
  const walkContext$2 = "rule";
  const structure$b = {
    prelude: [
      "SelectorList",
      "Raw"
    ],
    block: [
      "Block"
    ]
  };
  function parse$c() {
    const startToken = this.tokenIndex;
    const startOffset = this.tokenStart;
    let prelude;
    let block;
    if (this.parseRulePrelude) {
      prelude = this.parseWithFallback(consumePrelude, consumeRaw$1);
    } else {
      prelude = consumeRaw$1.call(this, startToken);
    }
    block = this.Block(true);
    return {
      type: "Rule",
      loc: this.getLocation(startOffset, this.tokenStart),
      prelude,
      block
    };
  }
  function generate$c(node2) {
    this.node(node2.prelude);
    this.node(node2.block);
  }
  const Rule = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$c,
    name: name$b,
    parse: parse$c,
    structure: structure$b,
    walkContext: walkContext$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$a = "Scope";
  const structure$a = {
    root: [
      "SelectorList",
      "Raw",
      null
    ],
    limit: [
      "SelectorList",
      "Raw",
      null
    ]
  };
  function parse$b() {
    let root2 = null;
    let limit = null;
    this.skipSC();
    const startOffset = this.tokenStart;
    if (this.tokenType === LeftParenthesis) {
      this.next();
      this.skipSC();
      root2 = this.parseWithFallback(this.SelectorList, () => this.Raw(false, true));
      this.skipSC();
      this.eat(RightParenthesis);
    }
    if (this.lookupNonWSType(0) === Ident) {
      this.skipSC();
      this.eatIdent("to");
      this.skipSC();
      this.eat(LeftParenthesis);
      this.skipSC();
      limit = this.parseWithFallback(this.SelectorList, () => this.Raw(false, true));
      this.skipSC();
      this.eat(RightParenthesis);
    }
    return {
      type: "Scope",
      loc: this.getLocation(startOffset, this.tokenStart),
      root: root2,
      limit
    };
  }
  function generate$b(node2) {
    if (node2.root) {
      this.token(LeftParenthesis, "(");
      this.node(node2.root);
      this.token(RightParenthesis, ")");
    }
    if (node2.limit) {
      this.token(Ident, "to");
      this.token(LeftParenthesis, "(");
      this.node(node2.limit);
      this.token(RightParenthesis, ")");
    }
  }
  const Scope = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$b,
    name: name$a,
    parse: parse$b,
    structure: structure$a
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$9 = "Selector";
  const structure$9 = {
    children: [
      [
        "TypeSelector",
        "IdSelector",
        "ClassSelector",
        "AttributeSelector",
        "PseudoClassSelector",
        "PseudoElementSelector",
        "Combinator"
      ]
    ]
  };
  function parse$a() {
    const children = this.readSequence(this.scope.Selector);
    if (this.getFirstListNode(children) === null) {
      this.error("Selector is expected");
    }
    return {
      type: "Selector",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$a(node2) {
    this.children(node2);
  }
  const Selector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$a,
    name: name$9,
    parse: parse$a,
    structure: structure$9
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$8 = "SelectorList";
  const walkContext$1 = "selector";
  const structure$8 = {
    children: [
      [
        "Selector",
        "Raw"
      ]
    ]
  };
  function parse$9() {
    const children = this.createList();
    while (!this.eof) {
      children.push(this.Selector());
      if (this.tokenType === Comma) {
        this.next();
        continue;
      }
      break;
    }
    return {
      type: "SelectorList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$9(node2) {
    this.children(node2, () => this.token(Comma, ","));
  }
  const SelectorList = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$9,
    name: name$8,
    parse: parse$9,
    structure: structure$8,
    walkContext: walkContext$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const REVERSE_SOLIDUS$1 = 92;
  const QUOTATION_MARK$1 = 34;
  const APOSTROPHE$1 = 39;
  function decode$1(str) {
    const len = str.length;
    const firstChar = str.charCodeAt(0);
    const start = firstChar === QUOTATION_MARK$1 || firstChar === APOSTROPHE$1 ? 1 : 0;
    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
    let decoded = "";
    for (let i22 = start; i22 <= end; i22++) {
      let code2 = str.charCodeAt(i22);
      if (code2 === REVERSE_SOLIDUS$1) {
        if (i22 === end) {
          if (i22 !== len - 1) {
            decoded = str.substr(i22 + 1);
          }
          break;
        }
        code2 = str.charCodeAt(++i22);
        if (isValidEscape(REVERSE_SOLIDUS$1, code2)) {
          const escapeStart = i22 - 1;
          const escapeEnd = consumeEscaped(str, escapeStart);
          i22 = escapeEnd - 1;
          decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code2 === 13 && str.charCodeAt(i22 + 1) === 10) {
            i22++;
          }
        }
      } else {
        decoded += str[i22];
      }
    }
    return decoded;
  }
  function encode$1(str, apostrophe) {
    const quote = '"';
    const quoteCode = QUOTATION_MARK$1;
    let encoded = "";
    let wsBeforeHexIsNeeded = false;
    for (let i22 = 0; i22 < str.length; i22++) {
      const code2 = str.charCodeAt(i22);
      if (code2 === 0) {
        encoded += "\uFFFD";
        continue;
      }
      if (code2 <= 31 || code2 === 127) {
        encoded += "\\" + code2.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      }
      if (code2 === quoteCode || code2 === REVERSE_SOLIDUS$1) {
        encoded += "\\" + str.charAt(i22);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && (isHexDigit(code2) || isWhiteSpace(code2))) {
          encoded += " ";
        }
        encoded += str.charAt(i22);
        wsBeforeHexIsNeeded = false;
      }
    }
    return quote + encoded + quote;
  }
  const name$7 = "String";
  const structure$7 = {
    value: String
  };
  function parse$8() {
    return {
      type: "String",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: decode$1(this.consume(String$2))
    };
  }
  function generate$8(node2) {
    this.token(String$2, encode$1(node2.value));
  }
  const String$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$8,
    name: name$7,
    parse: parse$8,
    structure: structure$7
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const EXCLAMATIONMARK = 33;
  function consumeRaw() {
    return this.Raw(null, false);
  }
  const name$6 = "StyleSheet";
  const walkContext = "stylesheet";
  const structure$6 = {
    children: [
      [
        "Comment",
        "CDO",
        "CDC",
        "Atrule",
        "Rule",
        "Raw"
      ]
    ]
  };
  function parse$7() {
    const start = this.tokenStart;
    const children = this.createList();
    let child;
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace$1:
          this.next();
          continue;
        case Comment$1:
          if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
            this.next();
            continue;
          }
          child = this.Comment();
          break;
        case CDO$1:
          child = this.CDO();
          break;
        case CDC$1:
          child = this.CDC();
          break;
        case AtKeyword:
          child = this.parseWithFallback(this.Atrule, consumeRaw);
          break;
        default:
          child = this.parseWithFallback(this.Rule, consumeRaw);
      }
      children.push(child);
    }
    return {
      type: "StyleSheet",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate$7(node2) {
    this.children(node2);
  }
  const StyleSheet = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$7,
    name: name$6,
    parse: parse$7,
    structure: structure$6,
    walkContext
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$5 = "SupportsDeclaration";
  const structure$5 = {
    declaration: "Declaration"
  };
  function parse$6() {
    const start = this.tokenStart;
    this.eat(LeftParenthesis);
    this.skipSC();
    const declaration = this.Declaration();
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "SupportsDeclaration",
      loc: this.getLocation(start, this.tokenStart),
      declaration
    };
  }
  function generate$6(node2) {
    this.token(LeftParenthesis, "(");
    this.node(node2.declaration);
    this.token(RightParenthesis, ")");
  }
  const SupportsDeclaration = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$6,
    name: name$5,
    parse: parse$6,
    structure: structure$5
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const ASTERISK$2 = 42;
  const VERTICALLINE$1 = 124;
  function eatIdentifierOrAsterisk() {
    if (this.tokenType !== Ident && this.isDelim(ASTERISK$2) === false) {
      this.error("Identifier or asterisk is expected");
    }
    this.next();
  }
  const name$4 = "TypeSelector";
  const structure$4 = {
    name: String
  };
  function parse$5() {
    const start = this.tokenStart;
    if (this.isDelim(VERTICALLINE$1)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    } else {
      eatIdentifierOrAsterisk.call(this);
      if (this.isDelim(VERTICALLINE$1)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
      }
    }
    return {
      type: "TypeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  function generate$5(node2) {
    this.tokenize(node2.name);
  }
  const TypeSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$5,
    name: name$4,
    parse: parse$5,
    structure: structure$4
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const PLUSSIGN$2 = 43;
  const HYPHENMINUS$1 = 45;
  const QUESTIONMARK = 63;
  function eatHexSequence(offset, allowDash) {
    let len = 0;
    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
      const code2 = this.charCodeAt(pos);
      if (code2 === HYPHENMINUS$1 && allowDash && len !== 0) {
        eatHexSequence.call(this, offset + len + 1, false);
        return -1;
      }
      if (!isHexDigit(code2)) {
        this.error(allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input", pos);
      }
      if (++len > 6) {
        this.error("Too many hex digits", pos);
      }
    }
    this.next();
    return len;
  }
  function eatQuestionMarkSequence(max) {
    let count = 0;
    while (this.isDelim(QUESTIONMARK)) {
      if (++count > max) {
        this.error("Too many question marks");
      }
      this.next();
    }
  }
  function startsWith(code2) {
    if (this.charCodeAt(this.tokenStart) !== code2) {
      this.error((code2 === PLUSSIGN$2 ? "Plus sign" : "Hyphen minus") + " is expected");
    }
  }
  function scanUnicodeRange() {
    let hexLength = 0;
    switch (this.tokenType) {
      case Number$2:
        hexLength = eatHexSequence.call(this, 1, true);
        if (this.isDelim(QUESTIONMARK)) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
          break;
        }
        if (this.tokenType === Dimension$1 || this.tokenType === Number$2) {
          startsWith.call(this, HYPHENMINUS$1);
          eatHexSequence.call(this, 1, false);
          break;
        }
        break;
      case Dimension$1:
        hexLength = eatHexSequence.call(this, 1, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      default:
        this.eatDelim(PLUSSIGN$2);
        if (this.tokenType === Ident) {
          hexLength = eatHexSequence.call(this, 0, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          break;
        }
        if (this.isDelim(QUESTIONMARK)) {
          this.next();
          eatQuestionMarkSequence.call(this, 5);
          break;
        }
        this.error("Hex digit or question mark is expected");
    }
  }
  const name$3 = "UnicodeRange";
  const structure$3 = {
    value: String
  };
  function parse$4() {
    const start = this.tokenStart;
    this.eatIdent("u");
    scanUnicodeRange.call(this);
    return {
      type: "UnicodeRange",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  function generate$4(node2) {
    this.tokenize(node2.value);
  }
  const UnicodeRange = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$4,
    name: name$3,
    parse: parse$4,
    structure: structure$3
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const SPACE$1 = 32;
  const REVERSE_SOLIDUS = 92;
  const QUOTATION_MARK = 34;
  const APOSTROPHE = 39;
  const LEFTPARENTHESIS = 40;
  const RIGHTPARENTHESIS = 41;
  function decode(str) {
    const len = str.length;
    let start = 4;
    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
    let decoded = "";
    while (start < end && isWhiteSpace(str.charCodeAt(start))) {
      start++;
    }
    while (start < end && isWhiteSpace(str.charCodeAt(end))) {
      end--;
    }
    for (let i22 = start; i22 <= end; i22++) {
      let code2 = str.charCodeAt(i22);
      if (code2 === REVERSE_SOLIDUS) {
        if (i22 === end) {
          if (i22 !== len - 1) {
            decoded = str.substr(i22 + 1);
          }
          break;
        }
        code2 = str.charCodeAt(++i22);
        if (isValidEscape(REVERSE_SOLIDUS, code2)) {
          const escapeStart = i22 - 1;
          const escapeEnd = consumeEscaped(str, escapeStart);
          i22 = escapeEnd - 1;
          decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code2 === 13 && str.charCodeAt(i22 + 1) === 10) {
            i22++;
          }
        }
      } else {
        decoded += str[i22];
      }
    }
    return decoded;
  }
  function encode(str) {
    let encoded = "";
    let wsBeforeHexIsNeeded = false;
    for (let i22 = 0; i22 < str.length; i22++) {
      const code2 = str.charCodeAt(i22);
      if (code2 === 0) {
        encoded += "\uFFFD";
        continue;
      }
      if (code2 <= 31 || code2 === 127) {
        encoded += "\\" + code2.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      }
      if (code2 === SPACE$1 || code2 === REVERSE_SOLIDUS || code2 === QUOTATION_MARK || code2 === APOSTROPHE || code2 === LEFTPARENTHESIS || code2 === RIGHTPARENTHESIS) {
        encoded += "\\" + str.charAt(i22);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && isHexDigit(code2)) {
          encoded += " ";
        }
        encoded += str.charAt(i22);
        wsBeforeHexIsNeeded = false;
      }
    }
    return "url(" + encoded + ")";
  }
  const name$2 = "Url";
  const structure$2 = {
    value: String
  };
  function parse$3() {
    const start = this.tokenStart;
    let value2;
    switch (this.tokenType) {
      case Url$1:
        value2 = decode(this.consume(Url$1));
        break;
      case Function$2:
        if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
          this.error("Function name must be `url`");
        }
        this.eat(Function$2);
        this.skipSC();
        value2 = decode$1(this.consume(String$2));
        this.skipSC();
        if (!this.eof) {
          this.eat(RightParenthesis);
        }
        break;
      default:
        this.error("Url or Function is expected");
    }
    return {
      type: "Url",
      loc: this.getLocation(start, this.tokenStart),
      value: value2
    };
  }
  function generate$3(node2) {
    this.token(Url$1, encode(node2.value));
  }
  const Url = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$3,
    name: name$2,
    parse: parse$3,
    structure: structure$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$1 = "Value";
  const structure$1 = {
    children: [
      []
    ]
  };
  function parse$2() {
    const start = this.tokenStart;
    const children = this.readSequence(this.scope.Value);
    return {
      type: "Value",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate$2(node2) {
    this.children(node2);
  }
  const Value = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$2,
    name: name$1,
    parse: parse$2,
    structure: structure$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const SPACE = Object.freeze({
    type: "WhiteSpace",
    loc: null,
    value: " "
  });
  const name = "WhiteSpace";
  const structure = {
    value: String
  };
  function parse$1() {
    this.eat(WhiteSpace$1);
    return SPACE;
  }
  function generate$1(node2) {
    this.token(WhiteSpace$1, node2.value);
  }
  const WhiteSpace = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$1,
    name,
    parse: parse$1,
    structure
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const node$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    AnPlusB,
    Atrule,
    AtrulePrelude,
    AttributeSelector,
    Block,
    Brackets,
    CDC,
    CDO,
    ClassSelector,
    Combinator,
    Comment,
    Condition,
    Declaration,
    DeclarationList,
    Dimension,
    Feature,
    FeatureFunction,
    FeatureRange,
    Function: Function$1,
    GeneralEnclosed,
    Hash,
    IdSelector,
    Identifier,
    Layer,
    LayerList,
    MediaQuery,
    MediaQueryList,
    NestingSelector,
    Nth,
    Number: Number$1,
    Operator,
    Parentheses,
    Percentage,
    PseudoClassSelector,
    PseudoElementSelector,
    Ratio,
    Raw,
    Rule,
    Scope,
    Selector,
    SelectorList,
    String: String$1,
    StyleSheet,
    SupportsDeclaration,
    TypeSelector,
    UnicodeRange,
    Url,
    Value,
    WhiteSpace
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const lexerConfig = {
    generic: true,
    cssWideKeywords,
    ...definitions,
    node: node$1
  };
  const NUMBERSIGN$1 = 35;
  const ASTERISK$1 = 42;
  const PLUSSIGN$1 = 43;
  const HYPHENMINUS = 45;
  const SOLIDUS$1 = 47;
  const U = 117;
  function defaultRecognizer(context2) {
    switch (this.tokenType) {
      case Hash$1:
        return this.Hash();
      case Comma:
        return this.Operator();
      case LeftParenthesis:
        return this.Parentheses(this.readSequence, context2.recognizer);
      case LeftSquareBracket:
        return this.Brackets(this.readSequence, context2.recognizer);
      case String$2:
        return this.String();
      case Dimension$1:
        return this.Dimension();
      case Percentage$1:
        return this.Percentage();
      case Number$2:
        return this.Number();
      case Function$2:
        return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context2.recognizer);
      case Url$1:
        return this.Url();
      case Ident:
        if (this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, PLUSSIGN$1)) {
          return this.UnicodeRange();
        } else {
          return this.Identifier();
        }
      case Delim: {
        const code2 = this.charCodeAt(this.tokenStart);
        if (code2 === SOLIDUS$1 || code2 === ASTERISK$1 || code2 === PLUSSIGN$1 || code2 === HYPHENMINUS) {
          return this.Operator();
        }
        if (code2 === NUMBERSIGN$1) {
          this.error("Hex or identifier is expected", this.tokenStart + 1);
        }
        break;
      }
    }
  }
  const atrulePrelude = {
    getNode: defaultRecognizer
  };
  const NUMBERSIGN = 35;
  const AMPERSAND = 38;
  const ASTERISK = 42;
  const PLUSSIGN = 43;
  const SOLIDUS = 47;
  const FULLSTOP = 46;
  const GREATERTHANSIGN = 62;
  const VERTICALLINE = 124;
  const TILDE = 126;
  function onWhiteSpace(next2, children) {
    if (children.last !== null && children.last.type !== "Combinator" && next2 !== null && next2.type !== "Combinator") {
      children.push({
        type: "Combinator",
        loc: null,
        name: " "
      });
    }
  }
  function getNode() {
    switch (this.tokenType) {
      case LeftSquareBracket:
        return this.AttributeSelector();
      case Hash$1:
        return this.IdSelector();
      case Colon:
        if (this.lookupType(1) === Colon) {
          return this.PseudoElementSelector();
        } else {
          return this.PseudoClassSelector();
        }
      case Ident:
        return this.TypeSelector();
      case Number$2:
      case Percentage$1:
        return this.Percentage();
      case Dimension$1:
        if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
          this.error("Identifier is expected", this.tokenStart + 1);
        }
        break;
      case Delim: {
        const code2 = this.charCodeAt(this.tokenStart);
        switch (code2) {
          case PLUSSIGN:
          case GREATERTHANSIGN:
          case TILDE:
          case SOLIDUS:
            return this.Combinator();
          case FULLSTOP:
            return this.ClassSelector();
          case ASTERISK:
          case VERTICALLINE:
            return this.TypeSelector();
          case NUMBERSIGN:
            return this.IdSelector();
          case AMPERSAND:
            return this.NestingSelector();
        }
        break;
      }
    }
  }
  const selector$1 = {
    onWhiteSpace,
    getNode
  };
  function expressionFn() {
    return this.createSingleNodeList(this.Raw(null, false));
  }
  function varFn() {
    const children = this.createList();
    this.skipSC();
    children.push(this.Identifier());
    this.skipSC();
    if (this.tokenType === Comma) {
      children.push(this.Operator());
      const startIndex = this.tokenIndex;
      const value2 = this.parseCustomProperty ? this.Value(null) : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
      if (value2.type === "Value" && value2.children.isEmpty) {
        for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
          if (this.lookupType(offset) === WhiteSpace$1) {
            value2.children.appendData({
              type: "WhiteSpace",
              loc: null,
              value: " "
            });
            break;
          }
        }
      }
      children.push(value2);
    }
    return children;
  }
  function isPlusMinusOperator(node2) {
    return node2 !== null && node2.type === "Operator" && (node2.value[node2.value.length - 1] === "-" || node2.value[node2.value.length - 1] === "+");
  }
  const value = {
    getNode: defaultRecognizer,
    onWhiteSpace(next2, children) {
      if (isPlusMinusOperator(next2)) {
        next2.value = " " + next2.value;
      }
      if (isPlusMinusOperator(children.last)) {
        children.last.value += " ";
      }
    },
    "expression": expressionFn,
    "var": varFn
  };
  const scope$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    AtrulePrelude: atrulePrelude,
    Selector: selector$1,
    Value: value
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const nonContainerNameKeywords = /* @__PURE__ */ new Set([
    "none",
    "and",
    "not",
    "or"
  ]);
  const container = {
    parse: {
      prelude() {
        const children = this.createList();
        if (this.tokenType === Ident) {
          const name2 = this.substring(this.tokenStart, this.tokenEnd);
          if (!nonContainerNameKeywords.has(name2.toLowerCase())) {
            children.push(this.Identifier());
          }
        }
        children.push(this.Condition("container"));
        return children;
      },
      block(nested = false) {
        return this.Block(nested);
      }
    }
  };
  const fontFace = {
    parse: {
      prelude: null,
      block() {
        return this.Block(true);
      }
    }
  };
  function parseWithFallback(parse2, fallback) {
    return this.parseWithFallback(() => {
      try {
        return parse2.call(this);
      } finally {
        this.skipSC();
        if (this.lookupNonWSType(0) !== RightParenthesis) {
          this.error();
        }
      }
    }, fallback || (() => this.Raw(null, true)));
  }
  const parseFunctions = {
    layer() {
      this.skipSC();
      const children = this.createList();
      const node2 = parseWithFallback.call(this, this.Layer);
      if (node2.type !== "Raw" || node2.value !== "") {
        children.push(node2);
      }
      return children;
    },
    supports() {
      this.skipSC();
      const children = this.createList();
      const node2 = parseWithFallback.call(this, this.Declaration, () => parseWithFallback.call(this, () => this.Condition("supports")));
      if (node2.type !== "Raw" || node2.value !== "") {
        children.push(node2);
      }
      return children;
    }
  };
  const importAtrule = {
    parse: {
      prelude() {
        const children = this.createList();
        switch (this.tokenType) {
          case String$2:
            children.push(this.String());
            break;
          case Url$1:
          case Function$2:
            children.push(this.Url());
            break;
          default:
            this.error("String or url() is expected");
        }
        this.skipSC();
        if (this.tokenType === Ident && this.cmpStr(this.tokenStart, this.tokenEnd, "layer")) {
          children.push(this.Identifier());
        } else if (this.tokenType === Function$2 && this.cmpStr(this.tokenStart, this.tokenEnd, "layer(")) {
          children.push(this.Function(null, parseFunctions));
        }
        this.skipSC();
        if (this.tokenType === Function$2 && this.cmpStr(this.tokenStart, this.tokenEnd, "supports(")) {
          children.push(this.Function(null, parseFunctions));
        }
        if (this.lookupNonWSType(0) === Ident || this.lookupNonWSType(0) === LeftParenthesis) {
          children.push(this.MediaQueryList());
        }
        return children;
      },
      block: null
    }
  };
  const layer = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.LayerList());
      },
      block() {
        return this.Block(false);
      }
    }
  };
  const media = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.MediaQueryList());
      },
      block(nested = false) {
        return this.Block(nested);
      }
    }
  };
  const nest = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.SelectorList());
      },
      block() {
        return this.Block(true);
      }
    }
  };
  const page = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.SelectorList());
      },
      block() {
        return this.Block(true);
      }
    }
  };
  const scope = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.Scope());
      },
      block(nested = false) {
        return this.Block(nested);
      }
    }
  };
  const startingStyle = {
    parse: {
      prelude: null,
      block(nested = false) {
        return this.Block(nested);
      }
    }
  };
  const supports = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.Condition("supports"));
      },
      block(nested = false) {
        return this.Block(nested);
      }
    }
  };
  const atrule = {
    container,
    "font-face": fontFace,
    import: importAtrule,
    layer,
    media,
    nest,
    page,
    scope,
    "starting-style": startingStyle,
    supports
  };
  function parseLanguageRangeList() {
    const children = this.createList();
    this.skipSC();
    loop:
      while (!this.eof) {
        switch (this.tokenType) {
          case Ident:
            children.push(this.Identifier());
            break;
          case String$2:
            children.push(this.String());
            break;
          case Comma:
            children.push(this.Operator());
            break;
          case RightParenthesis:
            break loop;
          default:
            this.error("Identifier, string or comma is expected");
        }
        this.skipSC();
      }
    return children;
  }
  const selectorList = {
    parse() {
      return this.createSingleNodeList(this.SelectorList());
    }
  };
  const selector = {
    parse() {
      return this.createSingleNodeList(this.Selector());
    }
  };
  const identList = {
    parse() {
      return this.createSingleNodeList(this.Identifier());
    }
  };
  const langList = {
    parse: parseLanguageRangeList
  };
  const nth = {
    parse() {
      return this.createSingleNodeList(this.Nth());
    }
  };
  const pseudo = {
    "dir": identList,
    "has": selectorList,
    "lang": langList,
    "matches": selectorList,
    "is": selectorList,
    "-moz-any": selectorList,
    "-webkit-any": selectorList,
    "where": selectorList,
    "not": selectorList,
    "nth-child": nth,
    "nth-last-child": nth,
    "nth-last-of-type": nth,
    "nth-of-type": nth,
    "slotted": selector,
    "host": selector,
    "host-context": selector
  };
  const node = Object.freeze(Object.defineProperty({
    __proto__: null,
    AnPlusB: parse$N,
    Atrule: parse$M,
    AtrulePrelude: parse$L,
    AttributeSelector: parse$K,
    Block: parse$J,
    Brackets: parse$I,
    CDC: parse$H,
    CDO: parse$G,
    ClassSelector: parse$F,
    Combinator: parse$E,
    Comment: parse$D,
    Condition: parse$C,
    Declaration: parse$B,
    DeclarationList: parse$A,
    Dimension: parse$z,
    Feature: parse$y,
    FeatureFunction: parse$x,
    FeatureRange: parse$w,
    Function: parse$v,
    GeneralEnclosed: parse$u,
    Hash: parse$t,
    IdSelector: parse$r,
    Identifier: parse$s,
    Layer: parse$q,
    LayerList: parse$p,
    MediaQuery: parse$o,
    MediaQueryList: parse$n,
    NestingSelector: parse$m,
    Nth: parse$l,
    Number: parse$k,
    Operator: parse$j,
    Parentheses: parse$i,
    Percentage: parse$h,
    PseudoClassSelector: parse$g,
    PseudoElementSelector: parse$f,
    Ratio: parse$e,
    Raw: parse$d,
    Rule: parse$c,
    Scope: parse$b,
    Selector: parse$a,
    SelectorList: parse$9,
    String: parse$8,
    StyleSheet: parse$7,
    SupportsDeclaration: parse$6,
    TypeSelector: parse$5,
    UnicodeRange: parse$4,
    Url: parse$3,
    Value: parse$2,
    WhiteSpace: parse$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const parserConfig = {
    parseContext: {
      default: "StyleSheet",
      stylesheet: "StyleSheet",
      atrule: "Atrule",
      atrulePrelude(options2) {
        return this.AtrulePrelude(options2.atrule ? String(options2.atrule) : null);
      },
      mediaQueryList: "MediaQueryList",
      mediaQuery: "MediaQuery",
      condition(options2) {
        return this.Condition(options2.kind);
      },
      rule: "Rule",
      selectorList: "SelectorList",
      selector: "Selector",
      block() {
        return this.Block(true);
      },
      declarationList: "DeclarationList",
      declaration: "Declaration",
      value: "Value"
    },
    features: {
      supports: {
        selector() {
          return this.Selector();
        }
      },
      container: {
        style() {
          return this.Declaration();
        }
      }
    },
    scope: scope$1,
    atrule,
    pseudo,
    node
  };
  const walkerConfig = {
    node: node$1
  };
  const syntax = createSyntax$1({
    ...lexerConfig,
    ...parserConfig,
    ...walkerConfig
  });
  const { tokenize, parse, generate, lexer, createLexer, walk, find, findLast, findAll, toPlainObject, fromPlainObject, fork } = syntax;
  function resolveRelativePath(dir, relativePath) {
    const parts = dir.split("/").filter(Boolean);
    const relParts = relativePath.split("/");
    for (const part of relParts) {
      if (part === "..") {
        parts.pop();
      } else if (part !== "." && part !== "") {
        parts.push(part);
      }
    }
    return "/" + parts.join("/");
  }
  function resolveCssModulePath(cssPath, currentFile, ctx) {
    if (currentFile && (cssPath.startsWith("./") || cssPath.startsWith("../"))) {
      const dir = currentFile.replace(/\/[^/]+$/, "");
      const resolved = resolveRelativePath(dir, cssPath);
      if (ctx.exists(resolved))
        return resolved;
    }
    if (ctx.exists(cssPath))
      return cssPath;
    const withSlash = "/" + cssPath.replace(/^\.\//, "");
    if (ctx.exists(withSlash))
      return withSlash;
    return null;
  }
  function generateCssModuleReplacement(varName, cssPath, currentFile, ctx) {
    try {
      const resolvedPath2 = resolveCssModulePath(cssPath, currentFile, ctx);
      if (!resolvedPath2) {
        return `const ${varName} = {};`;
      }
      const cssContent = ctx.readFile(resolvedPath2);
      const fileHash = simpleHash(resolvedPath2 + cssContent).slice(0, 6);
      const classMap = {};
      const ast = parse(cssContent);
      walk(ast, {
        visit: "ClassSelector",
        enter(node2) {
          if (!classMap[node2.name]) {
            classMap[node2.name] = `${node2.name}_${fileHash}`;
          }
        }
      });
      walk(ast, {
        visit: "ClassSelector",
        enter(node2) {
          if (classMap[node2.name]) {
            node2.name = classMap[node2.name];
          }
        }
      });
      const scopedCss = generate(ast);
      const escapedCss = scopedCss.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
      const mapEntries = Object.entries(classMap).map(([k, v]) => `${JSON.stringify(k)}: ${JSON.stringify(v)}`).join(", ");
      return `const ${varName} = {${mapEntries}};
(function() {
  if (typeof document !== 'undefined') {
    var id = ${JSON.stringify("cssmod-" + fileHash)};
    if (!document.getElementById(id)) {
      var s = document.createElement('style');
      s.id = id;
      s.textContent = \`${escapedCss}\`;
      document.head.appendChild(s);
    }
  }
})();`;
    } catch {
      return `const ${varName} = {};`;
    }
  }
  function stripCssImports(code2, currentFile, ctx) {
    code2 = code2.replace(/import\s+(\w+)\s+from\s+['"]([^'"]+\.module\.css)['"]\s*;?/g, (_match, varName, cssPath) => {
      return generateCssModuleReplacement(varName, cssPath, currentFile, ctx);
    });
    code2 = code2.replace(/import\s+\{([^}]+)\}\s+from\s+['"]([^'"]+\.module\.css)['"]\s*;?/g, (_match, names, cssPath) => {
      const varName = "__cssModule_" + simpleHash(cssPath);
      const replacement = generateCssModuleReplacement(varName, cssPath, currentFile, ctx);
      const namedExports = names.split(",").map((n10) => {
        var _a22;
        const trimmed = n10.trim();
        const parts = trimmed.split(/\s+as\s+/);
        const key = parts[0].trim();
        const alias = ((_a22 = parts[1]) == null ? void 0 : _a22.trim()) || key;
        return `const ${alias} = ${varName}[${JSON.stringify(key)}];`;
      }).join("\n");
      return `${replacement}
${namedExports}`;
    });
    return code2.replace(/import\s+['"][^'"]+\.css['"]\s*;?/g, "");
  }
  const EXPLICIT_MAPPINGS = {
    "react": "https://esm.sh/react@18.2.0?dev",
    "react/jsx-runtime": "https://esm.sh/react@18.2.0&dev/jsx-runtime",
    "react/jsx-dev-runtime": "https://esm.sh/react@18.2.0&dev/jsx-dev-runtime",
    "react-dom": "https://esm.sh/react-dom@18.2.0?dev",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev"
  };
  const LOCAL_PACKAGES = /* @__PURE__ */ new Set([
    "next/link",
    "next/router",
    "next/head",
    "next/navigation",
    "next/dynamic",
    "next/image",
    "next/script",
    "next/font/google",
    "next/font/local",
    "convex/_generated/api",
    "convex/react",
    "convex/server",
    "convex/values"
  ]);
  function resolveNpmPackage(packageName) {
    if (packageName.startsWith(".") || packageName.startsWith("/") || packageName.startsWith("http://") || packageName.startsWith("https://") || packageName.startsWith("/__virtual__")) {
      return null;
    }
    if (EXPLICIT_MAPPINGS[packageName])
      return EXPLICIT_MAPPINGS[packageName];
    if (LOCAL_PACKAGES.has(packageName))
      return null;
    const basePkg = packageName.includes("/") ? packageName.split("/")[0] : packageName;
    const isScoped = basePkg.startsWith("@");
    const scopedBasePkg = isScoped && packageName.includes("/") ? packageName.split("/").slice(0, 2).join("/") : basePkg;
    if (LOCAL_PACKAGES.has(scopedBasePkg))
      return null;
    return `https://esm.sh/${packageName}?external=react`;
  }
  function redirectNpmImports(code2) {
    try {
      return redirectNpmImportsAst(code2);
    } catch {
      return redirectNpmImportsRegex(code2);
    }
  }
  function redirectNpmImportsAst(code2) {
    const ast = parse3(code2, {
      ecmaVersion: "latest",
      sourceType: "module"
    });
    const replacements = [];
    function processSource(sourceNode) {
      if (!sourceNode || sourceNode.type !== "Literal")
        return;
      const resolved = resolveNpmPackage(sourceNode.value);
      if (resolved) {
        replacements.push([
          sourceNode.start,
          sourceNode.end,
          JSON.stringify(resolved)
        ]);
      }
    }
    for (const node2 of ast.body) {
      if (node2.type === "ImportDeclaration") {
        processSource(node2.source);
      } else if (node2.type === "ExportNamedDeclaration" && node2.source) {
        processSource(node2.source);
      } else if (node2.type === "ExportAllDeclaration") {
        processSource(node2.source);
      }
    }
    if (replacements.length === 0)
      return code2;
    let result = code2;
    replacements.sort((a, b) => b[0] - a[0]);
    for (const [start, end, replacement] of replacements) {
      result = result.slice(0, start) + replacement + result.slice(end);
    }
    return result;
  }
  function redirectNpmImportsRegex(code2) {
    const importPattern = /(from\s*['"])([^'"./][^'"]*?)(['"])/g;
    return code2.replace(importPattern, (match2, prefix, packageName, suffix) => {
      const resolved = resolveNpmPackage(packageName);
      if (!resolved)
        return match2;
      return `${prefix}${resolved}${suffix}`;
    });
  }
  function transformEsmToCjsSimple(code2) {
    try {
      return transformEsmToCjsAst(code2);
    } catch {
      return transformEsmToCjsRegex(code2);
    }
  }
  function transformEsmToCjsAst(code2) {
    const ast = parse3(code2, {
      ecmaVersion: "latest",
      sourceType: "module"
    });
    const replacements = [];
    for (const node2 of ast.body) {
      if (node2.type === "ImportDeclaration") {
        const source = node2.source.value;
        const specs = node2.specifiers;
        if (specs.length === 0) {
          replacements.push([
            node2.start,
            node2.end,
            `require(${JSON.stringify(source)})`
          ]);
        } else {
          const defaultSpec = specs.find((s10) => s10.type === "ImportDefaultSpecifier");
          const nsSpec = specs.find((s10) => s10.type === "ImportNamespaceSpecifier");
          const namedSpecs = specs.filter((s10) => s10.type === "ImportSpecifier");
          const parts = [];
          if (defaultSpec) {
            parts.push(`const ${defaultSpec.local.name} = require(${JSON.stringify(source)})`);
          }
          if (nsSpec) {
            parts.push(`const ${nsSpec.local.name} = require(${JSON.stringify(source)})`);
          }
          if (namedSpecs.length > 0) {
            const bindings = namedSpecs.map((s10) => {
              if (s10.imported.name === s10.local.name)
                return s10.local.name;
              return `${s10.imported.name}: ${s10.local.name}`;
            }).join(", ");
            if (defaultSpec) {
              parts.push(`const { ${bindings} } = require(${JSON.stringify(source)})`);
            } else {
              parts.push(`const { ${bindings} } = require(${JSON.stringify(source)})`);
            }
          }
          replacements.push([
            node2.start,
            node2.end,
            parts.join(";\n")
          ]);
        }
      } else if (node2.type === "ExportDefaultDeclaration") {
        const decl = node2.declaration;
        if (decl.type === "FunctionDeclaration") {
          const funcCode = code2.slice(decl.start, node2.end);
          replacements.push([
            node2.start,
            node2.end,
            `module.exports = ${funcCode}`
          ]);
        } else if (decl.type === "ClassDeclaration") {
          const classCode = code2.slice(decl.start, node2.end);
          replacements.push([
            node2.start,
            node2.end,
            `module.exports = ${classCode}`
          ]);
        } else {
          const exprCode = code2.slice(decl.start, node2.end);
          replacements.push([
            node2.start,
            node2.end,
            `module.exports = ${exprCode}`
          ]);
        }
      } else if (node2.type === "ExportNamedDeclaration") {
        if (node2.declaration) {
          const decl = node2.declaration;
          if (decl.type === "FunctionDeclaration") {
            const name2 = decl.id.name;
            const funcCode = code2.slice(decl.start, node2.end);
            replacements.push([
              node2.start,
              node2.end,
              `exports.${name2} = ${funcCode}`
            ]);
          } else if (decl.type === "ClassDeclaration") {
            const name2 = decl.id.name;
            const classCode = code2.slice(decl.start, node2.end);
            replacements.push([
              node2.start,
              node2.end,
              `exports.${name2} = ${classCode}`
            ]);
          } else if (decl.type === "VariableDeclaration") {
            const parts = [];
            for (const declarator of decl.declarations) {
              const name2 = declarator.id.name;
              const initCode = declarator.init ? code2.slice(declarator.init.start, declarator.init.end) : "undefined";
              parts.push(`exports.${name2} = ${initCode}`);
            }
            replacements.push([
              node2.start,
              node2.end,
              parts.join(";\n")
            ]);
          }
        } else if (node2.source) {
          const source = node2.source.value;
          const parts = [];
          const tmpVar = `__reexport_${node2.start}`;
          parts.push(`const ${tmpVar} = require(${JSON.stringify(source)})`);
          for (const spec2 of node2.specifiers) {
            parts.push(`exports.${spec2.exported.name} = ${tmpVar}.${spec2.local.name}`);
          }
          replacements.push([
            node2.start,
            node2.end,
            parts.join(";\n")
          ]);
        } else {
          const parts = [];
          for (const spec2 of node2.specifiers) {
            parts.push(`exports.${spec2.exported.name} = ${spec2.local.name}`);
          }
          replacements.push([
            node2.start,
            node2.end,
            parts.join(";\n")
          ]);
        }
      } else if (node2.type === "ExportAllDeclaration") {
        const source = node2.source.value;
        replacements.push([
          node2.start,
          node2.end,
          `Object.assign(exports, require(${JSON.stringify(source)}))`
        ]);
      }
    }
    let result = code2;
    replacements.sort((a, b) => b[0] - a[0]);
    for (const [start, end, replacement] of replacements) {
      result = result.slice(0, start) + replacement + result.slice(end);
    }
    return result;
  }
  function transformEsmToCjsRegex(code2) {
    let transformed = code2;
    transformed = transformed.replace(/import\s+(\w+)\s+from\s+['"]([^'"]+)['"]/g, 'const $1 = require("$2")');
    transformed = transformed.replace(/import\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"]/g, 'const {$1} = require("$2")');
    transformed = transformed.replace(/export\s+default\s+function\s+(\w+)/g, "module.exports = function $1");
    transformed = transformed.replace(/export\s+default\s+function\s*\(/g, "module.exports = function(");
    transformed = transformed.replace(/export\s+default\s+/g, "module.exports = ");
    transformed = transformed.replace(/export\s+async\s+function\s+(\w+)/g, "exports.$1 = async function $1");
    transformed = transformed.replace(/export\s+function\s+(\w+)/g, "exports.$1 = function $1");
    transformed = transformed.replace(/export\s+const\s+(\w+)\s*=/g, "exports.$1 =");
    return transformed;
  }
  function addReactRefresh(code2, filename2) {
    const components = detectReactComponents(code2);
    if (components.length === 0) {
      return `// HMR Setup
import.meta.hot = window.__vite_hot_context__("${filename2}");

${code2}

// HMR Accept
if (import.meta.hot) {
  import.meta.hot.accept();
}
`;
    }
    const registrations = components.map((name2) => `  $RefreshReg$(${name2}, "${filename2} ${name2}");`).join("\n");
    return `// HMR Setup
import.meta.hot = window.__vite_hot_context__("${filename2}");

${code2}

// React Refresh Registration
if (import.meta.hot) {
${registrations}
  import.meta.hot.accept(() => {
    if (window.$RefreshRuntime$) {
      window.$RefreshRuntime$.performReactRefresh();
    }
  });
}
`;
  }
  function isUppercaseStart(name2) {
    return name2.length > 0 && name2[0] >= "A" && name2[0] <= "Z";
  }
  function detectReactComponents(code2) {
    try {
      return detectReactComponentsAst(code2);
    } catch {
      return detectReactComponentsRegex(code2);
    }
  }
  function detectReactComponentsAst(code2) {
    var _a22, _b22, _c22, _d2;
    const ast = parse3(code2, {
      ecmaVersion: "latest",
      sourceType: "module"
    });
    const components = [];
    for (const node2 of ast.body) {
      if (node2.type === "FunctionDeclaration" && node2.id && isUppercaseStart(node2.id.name)) {
        if (!components.includes(node2.id.name)) {
          components.push(node2.id.name);
        }
      }
      if (node2.type === "ExportDefaultDeclaration" && ((_a22 = node2.declaration) == null ? void 0 : _a22.type) === "FunctionDeclaration" && node2.declaration.id && isUppercaseStart(node2.declaration.id.name)) {
        if (!components.includes(node2.declaration.id.name)) {
          components.push(node2.declaration.id.name);
        }
      }
      if (node2.type === "ExportNamedDeclaration" && ((_b22 = node2.declaration) == null ? void 0 : _b22.type) === "FunctionDeclaration" && node2.declaration.id && isUppercaseStart(node2.declaration.id.name)) {
        if (!components.includes(node2.declaration.id.name)) {
          components.push(node2.declaration.id.name);
        }
      }
      const varDecl = node2.type === "VariableDeclaration" ? node2 : node2.type === "ExportNamedDeclaration" && ((_c22 = node2.declaration) == null ? void 0 : _c22.type) === "VariableDeclaration" ? node2.declaration : null;
      if (varDecl) {
        for (const declarator of varDecl.declarations) {
          if (((_d2 = declarator.id) == null ? void 0 : _d2.name) && isUppercaseStart(declarator.id.name) && declarator.init) {
            const initType = declarator.init.type;
            if (initType === "ArrowFunctionExpression" || initType === "FunctionExpression" || initType === "CallExpression") {
              if (!components.includes(declarator.id.name)) {
                components.push(declarator.id.name);
              }
            }
          }
        }
      }
    }
    return components;
  }
  function detectReactComponentsRegex(code2) {
    const components = [];
    const funcDeclRegex = /(?:^|\n)(?:export\s+)?(?:async\s+)?function\s+([A-Z][a-zA-Z0-9]*)\s*\(/g;
    let match2;
    while ((match2 = funcDeclRegex.exec(code2)) !== null) {
      if (!components.includes(match2[1])) {
        components.push(match2[1]);
      }
    }
    const arrowRegex = /(?:^|\n)(?:export\s+)?(?:const|let|var)\s+([A-Z][a-zA-Z0-9]*)\s*=/g;
    while ((match2 = arrowRegex.exec(code2)) !== null) {
      if (!components.includes(match2[1])) {
        components.push(match2[1]);
      }
    }
    return components;
  }
  const isBrowser$1 = typeof window !== "undefined" && typeof window.navigator !== "undefined" && "serviceWorker" in window.navigator;
  async function initEsbuild$1() {
    if (!isBrowser$1)
      return;
    if (window.__esbuild) {
      return;
    }
    if (window.__esbuildInitPromise) {
      return window.__esbuildInitPromise;
    }
    window.__esbuildInitPromise = (async () => {
      try {
        const mod = await import("https://esm.sh/esbuild-wasm@0.20.0").then(async (m) => {
          await m.__tla;
          return m;
        });
        const esbuildMod = mod.default || mod;
        try {
          await esbuildMod.initialize({
            wasmURL: "https://unpkg.com/esbuild-wasm@0.20.0/esbuild.wasm"
          });
          console.log("[ViteDevServer] esbuild-wasm initialized");
        } catch (initError) {
          if (initError instanceof Error && initError.message.includes('Cannot call "initialize" more than once')) {
            console.log("[ViteDevServer] esbuild-wasm already initialized, reusing");
          } else {
            throw initError;
          }
        }
        window.__esbuild = esbuildMod;
      } catch (error) {
        console.error("[ViteDevServer] Failed to initialize esbuild:", error);
        window.__esbuildInitPromise = void 0;
        throw error;
      }
    })();
    return window.__esbuildInitPromise;
  }
  function getEsbuild$1() {
    return isBrowser$1 ? window.__esbuild : void 0;
  }
  const REACT_REFRESH_PREAMBLE$1 = `
<script type="module">
// Block until React Refresh is loaded and initialized
// This MUST happen before React is imported
const RefreshRuntime = await import('https://esm.sh/react-refresh@0.14.0/runtime').then(m => m.default || m);

// Hook into React BEFORE it's loaded
RefreshRuntime.injectIntoGlobalHook(window);
window.$RefreshRuntime$ = RefreshRuntime;

// Track registrations for debugging
window.$RefreshRegCount$ = 0;

// Register function called by transformed modules
window.$RefreshReg$ = (type, id) => {
  window.$RefreshRegCount$++;
  RefreshRuntime.register(type, id);
};

// Signature function (simplified - always returns identity)
window.$RefreshSig$ = () => (type) => type;

console.log('[HMR] React Refresh initialized');
<\/script>
`;
  const HMR_CLIENT_SCRIPT$1 = `
<script type="module">
(function() {
  // Track hot modules and their callbacks
  const hotModules = new Map();
  const pendingUpdates = new Map();

  // Implement import.meta.hot API (Vite-compatible)
  window.__vite_hot_context__ = function createHotContext(ownerPath) {
    // Return existing context if already created
    if (hotModules.has(ownerPath)) {
      return hotModules.get(ownerPath);
    }

    const hot = {
      // Persisted data between updates
      data: {},

      // Accept self-updates
      accept(callback) {
        hot._acceptCallback = callback;
      },

      // Cleanup before update
      dispose(callback) {
        hot._disposeCallback = callback;
      },

      // Force full reload
      invalidate() {
        location.reload();
      },

      // Prune callback (called when module is no longer imported)
      prune(callback) {
        hot._pruneCallback = callback;
      },

      // Event handlers (not implemented)
      on(event, cb) {},
      off(event, cb) {},
      send(event, data) {},

      // Internal callbacks
      _acceptCallback: null,
      _disposeCallback: null,
      _pruneCallback: null,
    };

    hotModules.set(ownerPath, hot);
    return hot;
  };

  // Listen for HMR updates via postMessage (works with sandboxed iframes)
  window.addEventListener('message', async (event) => {
    // Filter for HMR messages only
    if (!event.data || event.data.channel !== 'vite-hmr') return;
    const { type, path, timestamp } = event.data;

    if (type === 'update') {
      console.log('[HMR] Update:', path);

      if (path.endsWith('.css')) {
        // CSS hot reload - update stylesheet href
        const links = document.querySelectorAll('link[rel="stylesheet"]');
        links.forEach(link => {
          const href = link.getAttribute('href');
          if (href && href.includes(path.replace(/^\\//, ''))) {
            link.href = href.split('?')[0] + '?t=' + timestamp;
          }
        });

        // Also update any injected style tags
        const styles = document.querySelectorAll('style[data-vite-dev-id]');
        styles.forEach(style => {
          const id = style.getAttribute('data-vite-dev-id');
          if (id && id.includes(path.replace(/^\\//, ''))) {
            // Re-import the CSS module to get updated styles
            import(path + '?t=' + timestamp).catch(() => {});
          }
        });
      } else if (path.match(/\\.(jsx?|tsx?)$/)) {
        // JS/JSX hot reload with React Refresh
        await handleJSUpdate(path, timestamp);
      }
    } else if (type === 'full-reload') {
      console.log('[HMR] Full reload');
      location.reload();
    }
  });

  // Handle JS/JSX module updates
  async function handleJSUpdate(path, timestamp) {
    // Normalize path to match module keys
    const normalizedPath = path.startsWith('/') ? path : '/' + path;
    const hot = hotModules.get(normalizedPath);

    try {
      // Call dispose callback if registered
      if (hot && hot._disposeCallback) {
        hot._disposeCallback(hot.data);
      }

      // Enqueue React Refresh (batches multiple updates)
      if (window.$RefreshRuntime$) {
        pendingUpdates.set(normalizedPath, timestamp);

        // Schedule refresh after a short delay to batch updates
        if (pendingUpdates.size === 1) {
          setTimeout(async () => {
            try {
              // Re-import all pending modules
              for (const [modulePath, ts] of pendingUpdates) {
                const moduleUrl = '.' + modulePath + '?t=' + ts;
                await import(moduleUrl);
              }

              // Perform React Refresh
              window.$RefreshRuntime$.performReactRefresh();
              console.log('[HMR] Updated', pendingUpdates.size, 'module(s)');

              pendingUpdates.clear();
            } catch (error) {
              console.error('[HMR] Failed to apply update:', error);
              pendingUpdates.clear();
              location.reload();
            }
          }, 30);
        }
      } else {
        // No React Refresh available, fall back to page reload
        console.log('[HMR] React Refresh not available, reloading page');
        location.reload();
      }
    } catch (error) {
      console.error('[HMR] Update failed:', error);
      location.reload();
    }
  }

  console.log('[HMR] Client ready with React Refresh support');
})();
<\/script>
`;
  ViteDevServer = class extends DevServer {
    constructor(vfs2, options2) {
      super(vfs2, options2);
      __publicField(this, "watcherCleanup", null);
      __publicField(this, "options");
      __publicField(this, "hmrTargetWindow", null);
      __publicField(this, "transformCache", /* @__PURE__ */ new Map());
      this.options = {
        jsx: true,
        jsxFactory: "React.createElement",
        jsxFragment: "React.Fragment",
        jsxAutoImport: true,
        ...options2
      };
    }
    setHMRTarget(targetWindow) {
      this.hmrTargetWindow = targetWindow;
    }
    async handleRequest(method, url2, headers, body) {
      const urlObj = new URL(url2, "http://localhost");
      let pathname = urlObj.pathname;
      if (pathname === "/") {
        pathname = "/index.html";
      }
      const filePath = this.resolvePath(pathname);
      if (!this.exists(filePath)) {
        if (this.exists(filePath + ".html")) {
          return this.serveFile(filePath + ".html");
        }
        if (this.isDirectory(filePath) && this.exists(filePath + "/index.html")) {
          return this.serveFile(filePath + "/index.html");
        }
        return this.notFound(pathname);
      }
      if (this.isDirectory(filePath)) {
        if (this.exists(filePath + "/index.html")) {
          return this.serveFile(filePath + "/index.html");
        }
        return this.notFound(pathname);
      }
      if (this.needsTransform(pathname)) {
        return this.transformAndServe(filePath, pathname);
      }
      if (pathname.endsWith(".css")) {
        const secFetchDest = headers["sec-fetch-dest"] || headers["Sec-Fetch-Dest"] || headers["SEC-FETCH-DEST"] || "";
        const isModuleImport = secFetchDest === "script" || secFetchDest === "empty" || isBrowser$1 && secFetchDest === "";
        if (isModuleImport) {
          return this.serveCssAsModule(filePath);
        }
        return this.serveFile(filePath);
      }
      if (pathname.endsWith(".html")) {
        return this.serveHtmlWithHMR(filePath);
      }
      return this.serveFile(filePath);
    }
    startWatching() {
      const srcPath = this.root === "/" ? "/src" : `${this.root}/src`;
      try {
        const watcher = this.vfs.watch(srcPath, {
          recursive: true
        }, (eventType, filename2) => {
          if (eventType === "change" && filename2) {
            const fullPath = filename2.startsWith("/") ? filename2 : `${srcPath}/${filename2}`;
            this.handleFileChange(fullPath);
          }
        });
        this.watcherCleanup = () => {
          watcher.close();
        };
      } catch (error) {
        console.warn("[ViteDevServer] Could not watch /src directory:", error);
      }
      try {
        const rootWatcher = this.vfs.watch(this.root, {
          recursive: false
        }, (eventType, filename2) => {
          if (eventType === "change" && filename2 && filename2.endsWith(".css")) {
            this.handleFileChange(`${this.root}/${filename2}`);
          }
        });
        const originalCleanup = this.watcherCleanup;
        this.watcherCleanup = () => {
          originalCleanup == null ? void 0 : originalCleanup();
          rootWatcher.close();
        };
      } catch {
      }
    }
    handleFileChange(path22) {
      const isCSS = path22.endsWith(".css");
      const isJS = /\.(jsx?|tsx?)$/.test(path22);
      const updateType = isCSS || isJS ? "update" : "full-reload";
      const update = {
        type: updateType,
        path: path22,
        timestamp: Date.now()
      };
      this.emitHMRUpdate(update);
      if (this.hmrTargetWindow) {
        try {
          this.hmrTargetWindow.postMessage({
            ...update,
            channel: "vite-hmr"
          }, "*");
        } catch (e11) {
        }
      }
    }
    stop() {
      if (this.watcherCleanup) {
        this.watcherCleanup();
        this.watcherCleanup = null;
      }
      this.hmrTargetWindow = null;
      super.stop();
    }
    needsTransform(path22) {
      return /\.(jsx|tsx|ts)$/.test(path22);
    }
    async transformAndServe(filePath, urlPath) {
      try {
        const content = this.vfs.readFileSync(filePath, "utf8");
        const hash = simpleHash(content);
        const cached = this.transformCache.get(filePath);
        if (cached && cached.hash === hash) {
          const buffer22 = BufferPolyfill.from(cached.code);
          return {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
              "Content-Type": "application/javascript; charset=utf-8",
              "Content-Length": String(buffer22.length),
              "Cache-Control": "no-cache",
              "X-Transformed": "true",
              "X-Cache": "hit"
            },
            body: buffer22
          };
        }
        const transformed = await this.transformCode(content, urlPath);
        this.transformCache.set(filePath, {
          code: transformed,
          hash
        });
        const buffer2 = BufferPolyfill.from(transformed);
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "application/javascript; charset=utf-8",
            "Content-Length": String(buffer2.length),
            "Cache-Control": "no-cache",
            "X-Transformed": "true"
          },
          body: buffer2
        };
      } catch (error) {
        console.error("[ViteDevServer] Transform error:", error);
        const message = error instanceof Error ? error.message : "Transform failed";
        const body = `// Transform Error: ${message}
console.error(${JSON.stringify(message)});`;
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "application/javascript; charset=utf-8",
            "X-Transform-Error": "true"
          },
          body: BufferPolyfill.from(body)
        };
      }
    }
    async transformCode(code2, filename2) {
      if (!isBrowser$1) {
        return code2;
      }
      await initEsbuild$1();
      const esbuild2 = getEsbuild$1();
      if (!esbuild2) {
        throw new Error("esbuild not available");
      }
      let loader = "js";
      if (filename2.endsWith(".jsx"))
        loader = "jsx";
      else if (filename2.endsWith(".tsx"))
        loader = "tsx";
      else if (filename2.endsWith(".ts"))
        loader = "ts";
      const result = await esbuild2.transform(code2, {
        loader,
        format: "esm",
        target: "esnext",
        jsx: "automatic",
        jsxImportSource: "react",
        sourcemap: "inline",
        sourcefile: filename2
      });
      if (/\.(jsx|tsx)$/.test(filename2)) {
        return this.addReactRefresh(result.code, filename2);
      }
      return result.code;
    }
    addReactRefresh(code2, filename2) {
      return addReactRefresh(code2, filename2);
    }
    serveCssAsModule(filePath) {
      try {
        const css = this.vfs.readFileSync(filePath, "utf8");
        const js2 = `
// CSS Module: ${filePath}
const css = ${JSON.stringify(css)};
const style = document.createElement('style');
style.setAttribute('data-vite-dev-id', ${JSON.stringify(filePath)});
style.textContent = css;
document.head.appendChild(style);
export default css;
`;
        const buffer2 = BufferPolyfill.from(js2);
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "application/javascript; charset=utf-8",
            "Content-Length": String(buffer2.length),
            "Cache-Control": "no-cache"
          },
          body: buffer2
        };
      } catch (error) {
        return this.serverError(error);
      }
    }
    serveHtmlWithHMR(filePath) {
      try {
        let content = this.vfs.readFileSync(filePath, "utf8");
        if (content.includes("<head>")) {
          content = content.replace("<head>", `<head>${REACT_REFRESH_PREAMBLE$1}`);
        } else if (content.includes("<html")) {
          content = content.replace(/<html[^>]*>/, `$&${REACT_REFRESH_PREAMBLE$1}`);
        } else {
          content = REACT_REFRESH_PREAMBLE$1 + content;
        }
        if (content.includes("</head>")) {
          content = content.replace("</head>", `${HMR_CLIENT_SCRIPT$1}</head>`);
        } else if (content.includes("</body>")) {
          content = content.replace("</body>", `${HMR_CLIENT_SCRIPT$1}</body>`);
        } else {
          content += HMR_CLIENT_SCRIPT$1;
        }
        const buffer2 = BufferPolyfill.from(content);
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "text/html; charset=utf-8",
            "Content-Length": String(buffer2.length),
            "Cache-Control": "no-cache"
          },
          body: buffer2
        };
      } catch (error) {
        return this.serverError(error);
      }
    }
  };
  const CONFIG_FILE_NAMES = [
    "/tailwind.config.ts",
    "/tailwind.config.js",
    "/tailwind.config.mjs"
  ];
  async function loadTailwindConfig(vfs2, root2 = "/") {
    let configPath = null;
    let configContent = null;
    for (const fileName of CONFIG_FILE_NAMES) {
      const fullPath = root2 === "/" ? fileName : `${root2}${fileName}`;
      try {
        const content = vfs2.readFileSync(fullPath);
        configContent = typeof content === "string" ? content : content instanceof Uint8Array ? new TextDecoder("utf-8").decode(content) : Buffer.from(content).toString("utf-8");
        configPath = fullPath;
        break;
      } catch {
        continue;
      }
    }
    if (!configPath || configContent === null) {
      return {
        configScript: "",
        success: true
      };
    }
    try {
      const jsConfig = stripTypescriptSyntax(configContent);
      const configObject = extractConfigObject(jsConfig);
      if (!configObject) {
        return {
          configScript: "",
          success: false,
          error: "Could not extract config object from tailwind.config"
        };
      }
      const configScript = generateConfigScript(configObject);
      return {
        configScript,
        success: true
      };
    } catch (error) {
      return {
        configScript: "",
        success: false,
        error: `Failed to parse tailwind.config: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  function stripTypescriptSyntax(content) {
    let result = content;
    result = result.replace(/import\s+type\s+\{[^}]*\}\s+from\s+['"][^'"]*['"]\s*;?\s*/g, "");
    result = result.replace(/import\s+\{[^}]*\}\s+from\s+['"][^'"]*['"]\s*;?\s*/g, "");
    result = result.replace(/\s+satisfies\s+\w+\s*$/gm, "");
    result = result.replace(/\s+satisfies\s+\w+\s*;?\s*$/gm, "");
    result = result.replace(/:\s*[A-Z]\w*\s*=/g, " =");
    result = result.replace(/\s+as\s+const\s*/g, " ");
    return result;
  }
  function extractConfigObject(content) {
    const exportDefaultMatch = content.match(/export\s+default\s*/);
    if (!exportDefaultMatch || exportDefaultMatch.index === void 0) {
      return null;
    }
    const startIndex = exportDefaultMatch.index + exportDefaultMatch[0].length;
    const remaining = content.substring(startIndex);
    const trimmedRemaining = remaining.trimStart();
    if (!trimmedRemaining.startsWith("{")) {
      return null;
    }
    const objectStart = startIndex + (remaining.length - trimmedRemaining.length);
    const objectContent = content.substring(objectStart);
    let braceCount = 0;
    let inString = false;
    let stringChar = "";
    let escaped = false;
    let endIndex = -1;
    for (let i22 = 0; i22 < objectContent.length; i22++) {
      const char = objectContent[i22];
      if (escaped) {
        escaped = false;
        continue;
      }
      if (char === "\\") {
        escaped = true;
        continue;
      }
      if (inString) {
        if (char === stringChar) {
          inString = false;
        }
        continue;
      }
      if (char === '"' || char === "'" || char === "`") {
        inString = true;
        stringChar = char;
        continue;
      }
      if (char === "{") {
        braceCount++;
      } else if (char === "}") {
        braceCount--;
        if (braceCount === 0) {
          endIndex = i22 + 1;
          break;
        }
      }
    }
    if (endIndex === -1) {
      return null;
    }
    return objectContent.substring(0, endIndex);
  }
  function generateConfigScript(configObject) {
    return `<script>
  tailwind.config = ${configObject};
<\/script>`;
  }
  function parseNextConfigValue(content, key, isTypeScript = false) {
    const processed = isTypeScript ? stripTypescriptSyntax(content) : content;
    try {
      return parseNextConfigValueAst(processed, key);
    } catch {
      return parseNextConfigValueRegex(processed, key);
    }
  }
  function parseNextConfigValueAst(content, key) {
    var _a22, _b22, _c22;
    const ast = parse3(content, {
      ecmaVersion: "latest",
      sourceType: "module"
    });
    const variables = /* @__PURE__ */ new Map();
    for (const node2 of ast.body) {
      if (node2.type === "VariableDeclaration") {
        for (const decl of node2.declarations) {
          if (((_a22 = decl.id) == null ? void 0 : _a22.name) && decl.init) {
            variables.set(decl.id.name, decl.init);
          }
        }
      }
    }
    let configObject = null;
    for (const node2 of ast.body) {
      if (node2.type === "ExportDefaultDeclaration") {
        configObject = resolveToObject(node2.declaration, variables);
        if (configObject)
          break;
      }
      if (node2.type === "ExpressionStatement" && node2.expression.type === "AssignmentExpression" && node2.expression.left.type === "MemberExpression" && ((_b22 = node2.expression.left.object) == null ? void 0 : _b22.name) === "module" && ((_c22 = node2.expression.left.property) == null ? void 0 : _c22.name) === "exports") {
        configObject = resolveToObject(node2.expression.right, variables);
        if (configObject)
          break;
      }
    }
    if (!configObject || configObject.type !== "ObjectExpression") {
      return null;
    }
    for (const prop of configObject.properties) {
      if (prop.type !== "Property")
        continue;
      const propName = prop.key.type === "Identifier" ? prop.key.name : prop.key.type === "Literal" ? String(prop.key.value) : null;
      if (propName !== key)
        continue;
      return resolveToString(prop.value, variables);
    }
    return null;
  }
  function resolveToObject(node2, variables) {
    if (!node2)
      return null;
    if (node2.type === "ObjectExpression")
      return node2;
    if (node2.type === "Identifier") {
      const init22 = variables.get(node2.name);
      return init22 ? resolveToObject(init22, variables) : null;
    }
    if (node2.type === "CallExpression" && node2.arguments.length > 0) {
      return resolveToObject(node2.arguments[0], variables);
    }
    return null;
  }
  function resolveToString(node2, variables) {
    var _a22, _b22;
    if (!node2)
      return null;
    if (node2.type === "Literal" && typeof node2.value === "string") {
      return node2.value;
    }
    if (node2.type === "TemplateLiteral" && node2.expressions.length === 0) {
      return ((_b22 = (_a22 = node2.quasis[0]) == null ? void 0 : _a22.value) == null ? void 0 : _b22.cooked) ?? null;
    }
    if (node2.type === "Identifier") {
      const init22 = variables.get(node2.name);
      return init22 ? resolveToString(init22, variables) : null;
    }
    return null;
  }
  function parseNextConfigValueRegex(content, key) {
    const regex = new RegExp(`${key}\\s*:\\s*["'\`]([^"'\`]+)["'\`]`);
    const match2 = content.match(regex);
    return match2 ? match2[1] : null;
  }
  const TAILWIND_CDN_SCRIPT = `<script src="https://cdn.tailwindcss.com"><\/script>`;
  const CORS_PROXY_SCRIPT = `
<script>
  // CORS Proxy support for external API calls
  window.__getCorsProxy = function() {
    return localStorage.getItem('__corsProxyUrl') || null;
  };

  window.__setCorsProxy = function(url) {
    if (url) {
      localStorage.setItem('__corsProxyUrl', url);
    } else {
      localStorage.removeItem('__corsProxyUrl');
    }
  };

  window.__proxyFetch = async function(url, options) {
    const proxyUrl = window.__getCorsProxy();
    if (proxyUrl) {
      const proxiedUrl = proxyUrl + encodeURIComponent(url);
      return fetch(proxiedUrl, options);
    }
    return fetch(url, options);
  };
<\/script>
`;
  const REACT_REFRESH_PREAMBLE = `
<script type="module">
// Block until React Refresh is loaded and initialized
const RefreshRuntime = await import('https://esm.sh/react-refresh@0.14.0/runtime').then(m => m.default || m);

RefreshRuntime.injectIntoGlobalHook(window);
window.$RefreshRuntime$ = RefreshRuntime;
window.$RefreshRegCount$ = 0;

window.$RefreshReg$ = (type, id) => {
  window.$RefreshRegCount$++;
  RefreshRuntime.register(type, id);
};

window.$RefreshSig$ = () => (type) => type;

console.log('[HMR] React Refresh initialized');
<\/script>
`;
  const HMR_CLIENT_SCRIPT = `
<script type="module">
(function() {
  const hotModules = new Map();
  const pendingUpdates = new Map();

  window.__vite_hot_context__ = function createHotContext(ownerPath) {
    if (hotModules.has(ownerPath)) {
      return hotModules.get(ownerPath);
    }

    const hot = {
      data: {},
      accept(callback) {
        hot._acceptCallback = callback;
      },
      dispose(callback) {
        hot._disposeCallback = callback;
      },
      invalidate() {
        location.reload();
      },
      prune(callback) {
        hot._pruneCallback = callback;
      },
      on(event, cb) {},
      off(event, cb) {},
      send(event, data) {},
      _acceptCallback: null,
      _disposeCallback: null,
      _pruneCallback: null,
    };

    hotModules.set(ownerPath, hot);
    return hot;
  };

  // Listen for HMR updates via postMessage (works with sandboxed iframes)
  window.addEventListener('message', async (event) => {
    // Filter for HMR messages only
    if (!event.data || event.data.channel !== 'next-hmr') return;
    const { type, path, timestamp } = event.data;

    if (type === 'update') {
      console.log('[HMR] Update:', path);

      if (path.endsWith('.css')) {
        const links = document.querySelectorAll('link[rel="stylesheet"]');
        links.forEach(link => {
          const href = link.getAttribute('href');
          if (href && href.includes(path.replace(/^\\//, ''))) {
            link.href = href.split('?')[0] + '?t=' + timestamp;
          }
        });

        const styles = document.querySelectorAll('style[data-next-dev-id]');
        styles.forEach(style => {
          const id = style.getAttribute('data-next-dev-id');
          if (id && id.includes(path.replace(/^\\//, ''))) {
            import(path + '?t=' + timestamp).catch(() => {});
          }
        });
      } else if (path.match(/\\.(jsx?|tsx?)$/)) {
        await handleJSUpdate(path, timestamp);
      }
    } else if (type === 'full-reload') {
      console.log('[HMR] Full reload');
      location.reload();
    }
  });

  async function handleJSUpdate(path, timestamp) {
    const normalizedPath = path.startsWith('/') ? path : '/' + path;
    const hot = hotModules.get(normalizedPath);

    try {
      if (hot && hot._disposeCallback) {
        hot._disposeCallback(hot.data);
      }

      if (window.$RefreshRuntime$) {
        pendingUpdates.set(normalizedPath, timestamp);

        if (pendingUpdates.size === 1) {
          setTimeout(async () => {
            try {
              for (const [modulePath, ts] of pendingUpdates) {
                const moduleUrl = '.' + modulePath + '?t=' + ts;
                await import(moduleUrl);
              }

              window.$RefreshRuntime$.performReactRefresh();
              console.log('[HMR] Updated', pendingUpdates.size, 'module(s)');

              pendingUpdates.clear();
            } catch (error) {
              console.error('[HMR] Failed to apply update:', error);
              pendingUpdates.clear();
              location.reload();
            }
          }, 30);
        }
      } else {
        console.log('[HMR] React Refresh not available, reloading page');
        location.reload();
      }
    } catch (error) {
      console.error('[HMR] Update failed:', error);
      location.reload();
    }
  }

  console.log('[HMR] Next.js client ready');
})();
<\/script>
`;
  const NEXT_LINK_SHIM = `
import React from 'react';

const getVirtualBasePath = () => {
  const match = window.location.pathname.match(/^\\/__virtual__\\/\\d+(?:\\/|$)/);
  if (!match) return '';
  return match[0].endsWith('/') ? match[0] : match[0] + '/';
};

const getBasePath = () => window.__NEXT_BASE_PATH__ || '';

const applyVirtualBase = (url) => {
  if (typeof url !== 'string') return url;
  if (!url || url.startsWith('#') || url.startsWith('?')) return url;
  if (/^(https?:)?\\/\\//.test(url)) return url;

  // Apply basePath first
  const bp = getBasePath();
  if (bp && url.startsWith('/') && !url.startsWith(bp + '/') && url !== bp) {
    url = bp + url;
  }

  const base = getVirtualBasePath();
  if (!base) return url;
  if (url.startsWith(base)) return url;
  if (url.startsWith('/')) return base + url.slice(1);
  return base + url;
};

export default function Link({ href, children, ...props }) {
  const handleClick = (e) => {
    console.log('[Link] Click handler called, href:', href);

    if (props.onClick) {
      props.onClick(e);
    }

    // Allow cmd/ctrl click to open in new tab
    if (e.metaKey || e.ctrlKey) {
      console.log('[Link] Meta/Ctrl key pressed, allowing default behavior');
      return;
    }

    if (typeof href !== 'string' || !href || href.startsWith('#') || href.startsWith('?')) {
      console.log('[Link] Skipping navigation for href:', href);
      return;
    }

    if (/^(https?:)?\\/\\//.test(href)) {
      console.log('[Link] External URL, allowing default behavior:', href);
      return;
    }

    e.preventDefault();
    const resolvedHref = applyVirtualBase(href);
    console.log('[Link] Navigating to:', resolvedHref);
    window.history.pushState({}, '', resolvedHref);
    window.dispatchEvent(new PopStateEvent('popstate'));
  };

  return React.createElement('a', { href, onClick: handleClick, ...props }, children);
}

export { Link };
`;
  const NEXT_ROUTER_SHIM = `
import React, { useState, useEffect, createContext, useContext } from 'react';

const RouterContext = createContext(null);

const getVirtualBasePath = () => {
  const match = window.location.pathname.match(/^\\/__virtual__\\/\\d+(?:\\/|$)/);
  if (!match) return '';
  return match[0].endsWith('/') ? match[0] : match[0] + '/';
};

const applyVirtualBase = (url) => {
  if (typeof url !== 'string') return url;
  if (!url || url.startsWith('#') || url.startsWith('?')) return url;
  if (/^(https?:)?\\/\\//.test(url)) return url;

  const base = getVirtualBasePath();
  if (!base) return url;
  if (url.startsWith(base)) return url;
  if (url.startsWith('/')) return base + url.slice(1);
  return base + url;
};

const stripVirtualBase = (pathname) => {
  const match = pathname.match(/^\\/__virtual__\\/\\d+(?:\\/|$)/);
  if (!match) return pathname;
  return '/' + pathname.slice(match[0].length);
};

export function useRouter() {
  const [pathname, setPathname] = useState(
    typeof window !== 'undefined' ? stripVirtualBase(window.location.pathname) : '/'
  );
  const [query, setQuery] = useState({});

  useEffect(() => {
    const updateRoute = () => {
      setPathname(stripVirtualBase(window.location.pathname));
      setQuery(Object.fromEntries(new URLSearchParams(window.location.search)));
    };

    window.addEventListener('popstate', updateRoute);
    updateRoute();

    return () => window.removeEventListener('popstate', updateRoute);
  }, []);

  return {
    pathname,
    query,
    asPath: pathname + window.location.search,
    push: (url, as, options) => {
      if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
        window.location.href = url;
        return Promise.resolve(true);
      }
      const resolvedUrl = applyVirtualBase(url);
      window.history.pushState({}, '', resolvedUrl);
      window.dispatchEvent(new PopStateEvent('popstate'));
      return Promise.resolve(true);
    },
    replace: (url, as, options) => {
      if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
        window.location.href = url;
        return Promise.resolve(true);
      }
      const resolvedUrl = applyVirtualBase(url);
      window.history.replaceState({}, '', resolvedUrl);
      window.dispatchEvent(new PopStateEvent('popstate'));
      return Promise.resolve(true);
    },
    prefetch: () => Promise.resolve(),
    back: () => window.history.back(),
    forward: () => window.history.forward(),
    reload: () => window.location.reload(),
    events: {
      on: () => {},
      off: () => {},
      emit: () => {},
    },
    isFallback: false,
    isReady: true,
    isPreview: false,
  };
}

export const Router = {
  events: {
    on: () => {},
    off: () => {},
    emit: () => {},
  },
  push: (url) => {
    if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
      window.location.href = url;
      return Promise.resolve(true);
    }
    const resolvedUrl = applyVirtualBase(url);
    window.history.pushState({}, '', resolvedUrl);
    window.dispatchEvent(new PopStateEvent('popstate'));
    return Promise.resolve(true);
  },
  replace: (url) => {
    if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
      window.location.href = url;
      return Promise.resolve(true);
    }
    const resolvedUrl = applyVirtualBase(url);
    window.history.replaceState({}, '', resolvedUrl);
    window.dispatchEvent(new PopStateEvent('popstate'));
    return Promise.resolve(true);
  },
};

export default { useRouter, Router };
`;
  const NEXT_NAVIGATION_SHIM = `
import React, { useState, useEffect, useCallback, useMemo } from 'react';

const getVirtualBasePath = () => {
  const match = window.location.pathname.match(/^\\/__virtual__\\/\\d+(?:\\/|$)/);
  if (!match) return '';
  return match[0].endsWith('/') ? match[0] : match[0] + '/';
};

const applyVirtualBase = (url) => {
  if (typeof url !== 'string') return url;
  if (!url || url.startsWith('#') || url.startsWith('?')) return url;
  if (/^(https?:)?\\/\\//.test(url)) return url;

  const base = getVirtualBasePath();
  if (!base) return url;
  if (url.startsWith(base)) return url;
  if (url.startsWith('/')) return base + url.slice(1);
  return base + url;
};

const stripVirtualBase = (pathname) => {
  const match = pathname.match(/^\\/__virtual__\\/\\d+(?:\\/|$)/);
  if (!match) return pathname;
  return '/' + pathname.slice(match[0].length);
};

/**
 * App Router's useRouter hook
 * Returns navigation methods only (no pathname, no query)
 * Use usePathname() and useSearchParams() for URL info
 */
export function useRouter() {
  const push = useCallback((url, options) => {
    if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
      window.location.href = url;
      return;
    }
    const resolvedUrl = applyVirtualBase(url);
    window.history.pushState({}, '', resolvedUrl);
    window.dispatchEvent(new PopStateEvent('popstate'));
  }, []);

  const replace = useCallback((url, options) => {
    if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
      window.location.href = url;
      return;
    }
    const resolvedUrl = applyVirtualBase(url);
    window.history.replaceState({}, '', resolvedUrl);
    window.dispatchEvent(new PopStateEvent('popstate'));
  }, []);

  const back = useCallback(() => window.history.back(), []);
  const forward = useCallback(() => window.history.forward(), []);
  const refresh = useCallback(() => window.location.reload(), []);
  const prefetch = useCallback(() => Promise.resolve(), []);

  return useMemo(() => ({
    push,
    replace,
    back,
    forward,
    refresh,
    prefetch,
  }), [push, replace, back, forward, refresh, prefetch]);
}

/**
 * usePathname - Returns the current URL pathname
 * Reactively updates when navigation occurs
 * @example const pathname = usePathname(); // '/dashboard/settings'
 */
export function usePathname() {
  const [pathname, setPathname] = useState(
    typeof window !== 'undefined' ? stripVirtualBase(window.location.pathname) : '/'
  );

  useEffect(() => {
    const handler = () => setPathname(stripVirtualBase(window.location.pathname));
    window.addEventListener('popstate', handler);
    return () => window.removeEventListener('popstate', handler);
  }, []);

  return pathname;
}

/**
 * useSearchParams - Returns the current URL search parameters
 * @example const searchParams = useSearchParams();
 *          const query = searchParams.get('q'); // '?q=hello' -> 'hello'
 */
export function useSearchParams() {
  const [searchParams, setSearchParams] = useState(() => {
    if (typeof window === 'undefined') return new URLSearchParams();
    return new URLSearchParams(window.location.search);
  });

  useEffect(() => {
    const handler = () => {
      setSearchParams(new URLSearchParams(window.location.search));
    };
    window.addEventListener('popstate', handler);
    return () => window.removeEventListener('popstate', handler);
  }, []);

  return searchParams;
}

/**
 * useParams - Returns dynamic route parameters
 * For route /users/[id]/page.jsx with URL /users/123:
 * @example const { id } = useParams(); // { id: '123' }
 *
 * Fetches params from the server's route-info endpoint for dynamic routes.
 */
export function useParams() {
  const [params, setParams] = useState(() => {
    // Check if initial params were embedded by the server
    if (typeof window !== 'undefined' && window.__NEXT_ROUTE_PARAMS__) {
      return window.__NEXT_ROUTE_PARAMS__;
    }
    return {};
  });

  useEffect(() => {
    let cancelled = false;

    const fetchParams = async () => {
      const pathname = stripVirtualBase(window.location.pathname);
      const base = getVirtualBasePath();
      const baseUrl = base ? base.replace(/\\/$/, '') : '';

      try {
        const response = await fetch(baseUrl + '/_next/route-info?pathname=' + encodeURIComponent(pathname));
        const info = await response.json();
        if (!cancelled && info.params) {
          setParams(info.params);
        }
      } catch (e) {
        // Silently fail - static routes won't have params
      }
    };

    fetchParams();

    const handler = () => fetchParams();
    window.addEventListener('popstate', handler);
    return () => {
      cancelled = true;
      window.removeEventListener('popstate', handler);
    };
  }, []);

  return params;
}

/**
 * useSelectedLayoutSegment - Returns the active child segment one level below
 * Useful for styling active nav items in layouts
 * @example For /dashboard/settings, returns 'settings' in dashboard layout
 */
export function useSelectedLayoutSegment() {
  const pathname = usePathname();
  const segments = pathname.split('/').filter(Boolean);
  return segments[0] || null;
}

/**
 * useSelectedLayoutSegments - Returns all active child segments
 * @example For /dashboard/settings/profile, returns ['dashboard', 'settings', 'profile']
 */
export function useSelectedLayoutSegments() {
  const pathname = usePathname();
  return pathname.split('/').filter(Boolean);
}

/**
 * redirect - Programmatic redirect (typically used in Server Components)
 * In this browser implementation, performs immediate navigation
 */
export function redirect(url) {
  if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
    window.location.href = url;
    return;
  }
  window.location.href = applyVirtualBase(url);
}

/**
 * notFound - Trigger the not-found UI
 * In this browser implementation, throws an error
 */
export function notFound() {
  throw new Error('NEXT_NOT_FOUND');
}

// Re-export Link for convenience (can import from next/navigation or next/link)
export { default as Link } from 'next/link';
`;
  const NEXT_HEAD_SHIM = `
import React, { useEffect } from 'react';

export default function Head({ children }) {
  useEffect(() => {
    // Process children and update document.head
    React.Children.forEach(children, (child) => {
      if (!React.isValidElement(child)) return;

      const { type, props } = child;

      if (type === 'title' && props.children) {
        document.title = Array.isArray(props.children)
          ? props.children.join('')
          : props.children;
      } else if (type === 'meta') {
        const existingMeta = props.name
          ? document.querySelector(\`meta[name="\${props.name}"]\`)
          : props.property
            ? document.querySelector(\`meta[property="\${props.property}"]\`)
            : null;

        if (existingMeta) {
          Object.keys(props).forEach(key => {
            existingMeta.setAttribute(key, props[key]);
          });
        } else {
          const meta = document.createElement('meta');
          Object.keys(props).forEach(key => {
            meta.setAttribute(key, props[key]);
          });
          document.head.appendChild(meta);
        }
      } else if (type === 'link') {
        const link = document.createElement('link');
        Object.keys(props).forEach(key => {
          link.setAttribute(key, props[key]);
        });
        document.head.appendChild(link);
      }
    });
  }, [children]);

  return null;
}
`;
  const NEXT_IMAGE_SHIM = `
import React from 'react';

function Image({
  src,
  alt = '',
  width,
  height,
  fill,
  loader,
  quality = 75,
  priority,
  loading,
  placeholder,
  blurDataURL,
  unoptimized,
  onLoad,
  onError,
  style,
  className,
  sizes,
  ...rest
}) {
  // Handle src - could be string or StaticImageData object
  const imageSrc = typeof src === 'object' ? src.src : src;

  // Build style object
  const imgStyle = { ...style };
  if (fill) {
    imgStyle.position = 'absolute';
    imgStyle.width = '100%';
    imgStyle.height = '100%';
    imgStyle.objectFit = imgStyle.objectFit || 'cover';
    imgStyle.inset = '0';
  }

  return React.createElement('img', {
    src: imageSrc,
    alt,
    width: fill ? undefined : width,
    height: fill ? undefined : height,
    loading: priority ? 'eager' : (loading || 'lazy'),
    decoding: 'async',
    style: imgStyle,
    className,
    onLoad,
    onError,
    ...rest
  });
}

export default Image;
export { Image };
`;
  const NEXT_DYNAMIC_SHIM = `
import React from 'react';

function dynamic(importFn, options = {}) {
  const {
    loading: LoadingComponent,
    ssr = true,
  } = options;

  // Create a lazy component
  const LazyComponent = React.lazy(importFn);

  // Wrapper component that handles loading state
  function DynamicComponent(props) {
    const fallback = LoadingComponent
      ? React.createElement(LoadingComponent, { isLoading: true })
      : null;

    return React.createElement(
      React.Suspense,
      { fallback },
      React.createElement(LazyComponent, props)
    );
  }

  return DynamicComponent;
}

export default dynamic;
export { dynamic };
`;
  const NEXT_SCRIPT_SHIM = `
import React from 'react';

function Script({
  src,
  strategy = 'afterInteractive',
  onLoad,
  onReady,
  onError,
  children,
  dangerouslySetInnerHTML,
  ...rest
}) {
  React.useEffect(function() {
    if (!src && !children && !dangerouslySetInnerHTML) return;

    var script = document.createElement('script');

    if (src) {
      script.src = src;
      script.async = strategy !== 'beforeInteractive';
    }

    Object.keys(rest).forEach(function(key) {
      script.setAttribute(key, rest[key]);
    });

    if (children) {
      script.textContent = children;
    } else if (dangerouslySetInnerHTML && dangerouslySetInnerHTML.__html) {
      script.textContent = dangerouslySetInnerHTML.__html;
    }

    script.onload = function() {
      if (onLoad) onLoad();
      if (onReady) onReady();
    };
    script.onerror = onError;

    document.head.appendChild(script);

    return function() {
      if (script.parentNode) {
        script.parentNode.removeChild(script);
      }
    };
  }, [src]);

  return null;
}

export default Script;
export { Script };
`;
  const NEXT_FONT_GOOGLE_SHIM = `
// Track loaded fonts to avoid duplicate style injections
const loadedFonts = new Set();

/**
 * Convert font function name to Google Fonts family name
 * Examples:
 *   DM_Sans -> DM Sans
 *   Open_Sans -> Open Sans
 *   Fraunces -> Fraunces
 */
function toFontFamily(fontName) {
  return fontName.replace(/_/g, ' ');
}

/**
 * Inject font CSS into document
 * - Adds preconnect links for faster font loading
 * - Loads the font from Google Fonts CDN
 * - Creates a CSS class that sets the CSS variable
 */
function injectFontCSS(fontFamily, variableName, weight, style) {
  const fontKey = fontFamily + '-' + (variableName || 'default');
  if (loadedFonts.has(fontKey)) {
    return;
  }
  loadedFonts.add(fontKey);

  if (typeof document === 'undefined') {
    return;
  }

  // Add preconnect links for faster loading (only once)
  if (!document.querySelector('link[href="https://fonts.googleapis.com"]')) {
    const preconnect1 = document.createElement('link');
    preconnect1.rel = 'preconnect';
    preconnect1.href = 'https://fonts.googleapis.com';
    document.head.appendChild(preconnect1);

    const preconnect2 = document.createElement('link');
    preconnect2.rel = 'preconnect';
    preconnect2.href = 'https://fonts.gstatic.com';
    preconnect2.crossOrigin = 'anonymous';
    document.head.appendChild(preconnect2);
  }

  // Build Google Fonts URL
  const escapedFamily = fontFamily.replace(/ /g, '+');

  // Build axis list based on options
  let axisList = '';
  const axes = [];

  // Handle italic style
  if (style === 'italic') {
    axes.push('ital');
  }

  // Handle weight - use specific weight or variable range
  if (weight && weight !== '400' && !Array.isArray(weight)) {
    // Specific weight requested
    axes.push('wght');
    if (style === 'italic') {
      axisList = ':ital,wght@1,' + weight;
    } else {
      axisList = ':wght@' + weight;
    }
  } else if (Array.isArray(weight)) {
    // Multiple weights
    axes.push('wght');
    axisList = ':wght@' + weight.join(';');
  } else {
    // Default: request common weights for flexibility
    axisList = ':wght@400;500;600;700';
  }

  const fontUrl = 'https://fonts.googleapis.com/css2?family=' +
    escapedFamily + axisList + '&display=swap';

  // Add link element for Google Fonts (if not already present)
  if (!document.querySelector('link[href*="family=' + escapedFamily + '"]')) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = fontUrl;
    document.head.appendChild(link);
  }

  // Create style element for CSS variable at :root level (globally available)
  // This makes the variable work without needing to apply the class to body
  if (variableName) {
    const styleEl = document.createElement('style');
    styleEl.setAttribute('data-font-var', variableName);
    styleEl.textContent = ':root { ' + variableName + ': "' + fontFamily + '", ' + (fontFamily.includes('Serif') ? 'serif' : 'sans-serif') + '; }';
    document.head.appendChild(styleEl);
  }
}

/**
 * Create a font loader function for a specific font
 */
function createFontLoader(fontName) {
  const fontFamily = toFontFamily(fontName);

  return function(options = {}) {
    const {
      weight,
      style = 'normal',
      subsets = ['latin'],
      variable,
      display = 'swap',
      preload = true,
      fallback = ['sans-serif'],
      adjustFontFallback = true
    } = options;

    // Inject the font CSS
    injectFontCSS(fontFamily, variable, weight, style);

    // Generate class name from variable (--font-inter -> __font-inter)
    const className = variable
      ? variable.replace('--', '__')
      : '__font-' + fontName.toLowerCase().replace(/_/g, '-');

    return {
      className,
      variable: className,
      style: {
        fontFamily: '"' + fontFamily + '", ' + fallback.join(', ')
      }
    };
  };
}

/**
 * Use a Proxy to dynamically create font loaders for ANY font name
 * This allows: import { AnyGoogleFont } from "next/font/google"
 */
const fontProxy = new Proxy({}, {
  get(target, prop) {
    // Handle special properties
    if (prop === '__esModule') return true;
    if (prop === 'default') return fontProxy;
    if (typeof prop !== 'string') return undefined;

    // Create a font loader for this font name
    return createFontLoader(prop);
  }
});

// Export the proxy as both default and named exports
export default fontProxy;

// Re-export through proxy for named imports
export const {
  Fraunces, Inter, DM_Sans, DM_Serif_Text, Roboto, Open_Sans, Lato,
  Montserrat, Poppins, Playfair_Display, Merriweather, Raleway, Nunito,
  Ubuntu, Oswald, Quicksand, Work_Sans, Fira_Sans, Barlow, Mulish, Rubik,
  Noto_Sans, Manrope, Space_Grotesk, Geist, Geist_Mono
} = fontProxy;
`;
  const NEXT_FONT_LOCAL_SHIM = `
const loadedLocalFonts = new Set();

function localFont(options = {}) {
  const {
    src,
    weight,
    style = 'normal',
    variable,
    display = 'swap',
    fallback = ['sans-serif'],
    declarations = [],
    adjustFontFallback = true
  } = options;

  // Determine font family name from variable or src
  const familyName = variable
    ? variable.replace('--', '').replace(/-/g, ' ')
    : 'local-font-' + Math.random().toString(36).slice(2, 8);

  const fontKey = familyName + '-' + (variable || 'default');
  if (typeof document !== 'undefined' && !loadedLocalFonts.has(fontKey)) {
    loadedLocalFonts.add(fontKey);

    // Build @font-face declarations
    let fontFaces = '';

    if (typeof src === 'string') {
      // Single source
      fontFaces = '@font-face {\\n' +
        '  font-family: "' + familyName + '";\\n' +
        '  src: url("' + src + '");\\n' +
        '  font-weight: ' + (weight || '400') + ';\\n' +
        '  font-style: ' + style + ';\\n' +
        '  font-display: ' + display + ';\\n' +
        '}';
    } else if (Array.isArray(src)) {
      // Multiple sources (different weights/styles)
      fontFaces = src.map(function(s) {
        const path = typeof s === 'string' ? s : s.path;
        const w = (typeof s === 'object' && s.weight) || weight || '400';
        const st = (typeof s === 'object' && s.style) || style;
        return '@font-face {\\n' +
          '  font-family: "' + familyName + '";\\n' +
          '  src: url("' + path + '");\\n' +
          '  font-weight: ' + w + ';\\n' +
          '  font-style: ' + st + ';\\n' +
          '  font-display: ' + display + ';\\n' +
          '}';
      }).join('\\n');
    }

    // Inject font-face CSS
    if (fontFaces) {
      var styleEl = document.createElement('style');
      styleEl.setAttribute('data-local-font', fontKey);
      styleEl.textContent = fontFaces;
      document.head.appendChild(styleEl);
    }

    // Inject CSS variable at :root level
    if (variable) {
      var varStyle = document.createElement('style');
      varStyle.setAttribute('data-font-var', variable);
      varStyle.textContent = ':root { ' + variable + ': "' + familyName + '", ' + fallback.join(', ') + '; }';
      document.head.appendChild(varStyle);
    }
  }

  const className = variable
    ? variable.replace('--', '__')
    : '__font-' + familyName.toLowerCase().replace(/\\s+/g, '-');

  return {
    className,
    variable: className,
    style: {
      fontFamily: '"' + familyName + '", ' + fallback.join(', ')
    }
  };
}

export default localFont;
export { localFont };
`;
  async function generateAppRouterHtml(ctx, route, pathname) {
    const virtualPrefix = `/__virtual__/${ctx.port}`;
    const globalCssLinks = [];
    const cssLocations = [
      "/app/globals.css",
      "/styles/globals.css",
      "/styles/global.css"
    ];
    for (const cssPath of cssLocations) {
      if (ctx.exists(cssPath)) {
        globalCssLinks.push(`<link rel="stylesheet" href="${virtualPrefix}${cssPath}">`);
      }
    }
    virtualPrefix + route.page;
    route.layouts.map((layout, i22) => `import Layout${i22} from '${virtualPrefix}${layout}';`).join("\n    ");
    const loadingModulePath = route.loading ? `${virtualPrefix}${route.loading}` : "";
    const errorModulePath = route.error ? `${virtualPrefix}${route.error}` : "";
    const notFoundModulePath = route.notFound ? `${virtualPrefix}${route.notFound}` : "";
    for (let i22 = route.layouts.length - 1; i22 >= 0; i22--) {
    }
    const envScript = ctx.generateEnvScript();
    const tailwindConfigScript = await ctx.loadTailwindConfigIfNeeded();
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <base href="${virtualPrefix}/">
  <title>Next.js App</title>
  ${envScript}
  ${TAILWIND_CDN_SCRIPT}
  ${tailwindConfigScript}
  ${CORS_PROXY_SCRIPT}
  ${globalCssLinks.join("\n  ")}
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0?dev",
      "react/": "https://esm.sh/react@18.2.0&dev/",
      "react-dom": "https://esm.sh/react-dom@18.2.0?dev",
      "react-dom/": "https://esm.sh/react-dom@18.2.0&dev/",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev",
      "convex/react": "https://esm.sh/convex@1.21.0/react?external=react",
      "convex/server": "https://esm.sh/convex@1.21.0/server",
      "convex/values": "https://esm.sh/convex@1.21.0/values",
      "convex/_generated/api": "${virtualPrefix}/convex/_generated/api.ts",
      "ai": "https://esm.sh/ai@4?external=react",
      "ai/react": "https://esm.sh/ai@4/react?external=react",
      "@ai-sdk/openai": "https://esm.sh/@ai-sdk/openai@1",
      "next/link": "${virtualPrefix}/_next/shims/link.js",
      "next/router": "${virtualPrefix}/_next/shims/router.js",
      "next/head": "${virtualPrefix}/_next/shims/head.js",
      "next/navigation": "${virtualPrefix}/_next/shims/navigation.js",
      "next/image": "${virtualPrefix}/_next/shims/image.js",
      "next/dynamic": "${virtualPrefix}/_next/shims/dynamic.js",
      "next/script": "${virtualPrefix}/_next/shims/script.js",
      "next/font/google": "${virtualPrefix}/_next/shims/font/google.js",
      "next/font/local": "${virtualPrefix}/_next/shims/font/local.js"
    }
  }
  <\/script>
  ${REACT_REFRESH_PREAMBLE}
  ${HMR_CLIENT_SCRIPT}
</head>
<body>
  <div id="__next"></div>
  <script type="module">
    import React from 'react';
    import ReactDOM from 'react-dom/client';

    const virtualBase = '${virtualPrefix}';

    // Initial route params (embedded by server for initial page load)
    const initialRouteParams = ${JSON.stringify(route.params)};
    const initialPathname = '${pathname}';

    // Expose initial params for useParams() hook
    window.__NEXT_ROUTE_PARAMS__ = initialRouteParams;

    // Convention file paths (loading.tsx, error.tsx, not-found.tsx)
    const loadingModulePath = '${loadingModulePath}';
    const errorModulePath = '${errorModulePath}';
    const notFoundModulePath = '${notFoundModulePath}';

    // Route params cache for client-side navigation
    const routeParamsCache = new Map();
    routeParamsCache.set(initialPathname, initialRouteParams);

    // Extract route params from server for client-side navigation
    async function extractRouteParams(pathname) {
      // Strip virtual base if present
      let route = pathname;
      if (route.startsWith(virtualBase)) {
        route = route.slice(virtualBase.length);
      }
      route = route.replace(/^\\/+/, '/') || '/';

      // Check cache first
      if (routeParamsCache.has(route)) {
        return routeParamsCache.get(route);
      }

      try {
        const response = await fetch(virtualBase + '/_next/route-info?pathname=' + encodeURIComponent(route));
        const info = await response.json();
        routeParamsCache.set(route, info.params || {});
        return info.params || {};
      } catch (e) {
        console.error('[Router] Failed to extract route params:', e);
        return {};
      }
    }

    // Convert URL path to app router page module path
    function getAppPageModulePath(pathname) {
      let route = pathname;
      if (route.startsWith(virtualBase)) {
        route = route.slice(virtualBase.length);
      }
      route = route.replace(/^\\/+/, '/') || '/';
      // App Router: / -> /app/page, /about -> /app/about/page
      const pagePath = route === '/' ? '/app/page' : '/app' + route + '/page';
      return virtualBase + '/_next/app' + pagePath + '.js';
    }

    // Get layout paths for a route
    function getLayoutPaths(pathname) {
      let route = pathname;
      if (route.startsWith(virtualBase)) {
        route = route.slice(virtualBase.length);
      }
      route = route.replace(/^\\/+/, '/') || '/';

      // Build layout paths from root to current route
      const layouts = [virtualBase + '/_next/app/app/layout.js'];
      if (route !== '/') {
        const segments = route.split('/').filter(Boolean);
        let currentPath = '/app';
        for (const segment of segments) {
          currentPath += '/' + segment;
          layouts.push(virtualBase + '/_next/app' + currentPath + '/layout.js');
        }
      }
      return layouts;
    }

    // Dynamic page loader with retry (SW may need time to recover after idle termination)
    async function loadPage(pathname) {
      const modulePath = getAppPageModulePath(pathname);
      for (let attempt = 0; attempt < 3; attempt++) {
        try {
          const module = await import(/* @vite-ignore */ modulePath + (attempt > 0 ? '?retry=' + attempt : ''));
          return module.default;
        } catch (e) {
          console.warn('[Navigation] Load attempt ' + (attempt + 1) + ' failed:', modulePath, e.message);
          if (attempt < 2) await new Promise(r => setTimeout(r, 1000));
        }
      }
      console.error('[Navigation] Failed to load page after 3 attempts:', modulePath);
      return null;
    }

    // Load layouts (with caching)
    const layoutCache = new Map();
    async function loadLayouts(pathname) {
      const layoutPaths = getLayoutPaths(pathname);
      const layouts = [];
      for (const path of layoutPaths) {
        if (layoutCache.has(path)) {
          layouts.push(layoutCache.get(path));
        } else {
          try {
            const module = await import(/* @vite-ignore */ path);
            layoutCache.set(path, module.default);
            layouts.push(module.default);
          } catch (e) {
            // Layout might not exist for this segment, skip
          }
        }
      }
      return layouts;
    }

    // Load convention components (loading.tsx, error.tsx)
    let LoadingComponent = null;
    let ErrorComponent = null;
    let NotFoundComponent = null;

    async function loadConventionComponents() {
      if (loadingModulePath) {
        try {
          const mod = await import(/* @vite-ignore */ loadingModulePath);
          LoadingComponent = mod.default;
        } catch (e) { /* loading.tsx not available */ }
      }
      if (errorModulePath) {
        try {
          const mod = await import(/* @vite-ignore */ errorModulePath);
          ErrorComponent = mod.default;
        } catch (e) { /* error.tsx not available */ }
      }
      if (notFoundModulePath) {
        try {
          const mod = await import(/* @vite-ignore */ notFoundModulePath);
          NotFoundComponent = mod.default;
        } catch (e) { /* not-found.tsx not available */ }
      }
    }
    await loadConventionComponents();

    // Error boundary class component
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { error: null };
      }
      static getDerivedStateFromError(error) {
        return { error };
      }
      componentDidCatch(error, info) {
        console.error('[ErrorBoundary]', error, info);
      }
      render() {
        if (this.state.error) {
          if (this.props.fallback) {
            return React.createElement(this.props.fallback, {
              error: this.state.error,
              reset: () => this.setState({ error: null })
            });
          }
          return React.createElement('div', { style: { color: 'red', padding: '20px' } },
            'Error: ' + this.state.error.message
          );
        }
        return this.props.children;
      }
    }

    // Wrapper that provides searchParams/params props and handles errors
    function PageWrapper({ component: Component, pathname, search }) {
      const [searchParams, setSearchParams] = React.useState(() => {
        const url = new URL(window.location.href);
        return Promise.resolve(Object.fromEntries(url.searchParams));
      });
      const [params, setParams] = React.useState(() => Promise.resolve(initialRouteParams));
      const [isNotFound, setIsNotFound] = React.useState(false);

      React.useEffect(() => {
        // Update searchParams when search changes
        const url = new URL(window.location.href);
        setSearchParams(Promise.resolve(Object.fromEntries(url.searchParams)));
      }, [search]);

      React.useEffect(() => {
        // Update route params when pathname changes
        let cancelled = false;
        extractRouteParams(pathname).then(routeParams => {
          if (!cancelled) setParams(Promise.resolve(routeParams));
        });
        return () => { cancelled = true; };
      }, [pathname]);

      if (isNotFound && NotFoundComponent) {
        return React.createElement(NotFoundComponent);
      }
      if (isNotFound) {
        return React.createElement('div', { style: { padding: '20px', textAlign: 'center' } },
          React.createElement('h2', null, '404'),
          React.createElement('p', null, 'This page could not be found.')
        );
      }

      // Render the component via createElement so hooks work correctly
      try {
        return React.createElement(Component, { searchParams, params });
      } catch (e) {
        if (e && e.message === 'NEXT_NOT_FOUND') {
          // Will re-render with notFound on next tick
          if (!isNotFound) setIsNotFound(true);
          return null;
        }
        throw e; // Let ErrorBoundary handle it
      }
    }

    // Router component
    function Router() {
      const [Page, setPage] = React.useState(null);
      const [layouts, setLayouts] = React.useState([]);
      const [path, setPath] = React.useState(window.location.pathname);
      const [search, setSearch] = React.useState(window.location.search);

      React.useEffect(() => {
        Promise.all([loadPage(path), loadLayouts(path)]).then(([P, L]) => {
          if (P) setPage(() => P);
          setLayouts(L);
        });
      }, []);

      React.useEffect(() => {
        const handleNavigation = async () => {
          const newPath = window.location.pathname;
          const newSearch = window.location.search;
          console.log('[Router] handleNavigation called, newPath:', newPath, 'current path:', path);

          // Always update search params
          if (newSearch !== search) {
            setSearch(newSearch);
          }

          if (newPath !== path) {
            console.log('[Router] Path changed, loading new page...');
            setPath(newPath);
            const [P, L, routeParams] = await Promise.all([loadPage(newPath), loadLayouts(newPath), extractRouteParams(newPath)]);
            window.__NEXT_ROUTE_PARAMS__ = routeParams;
            console.log('[Router] Page loaded:', !!P, 'Layouts:', L.length);
            if (P) setPage(() => P);
            setLayouts(L);
          } else {
            console.log('[Router] Path unchanged, skipping navigation');
          }
        };
        window.addEventListener('popstate', handleNavigation);
        console.log('[Router] Added popstate listener for path:', path);
        return () => window.removeEventListener('popstate', handleNavigation);
      }, [path, search]);

      if (!Page) return null;

      // Render page via PageWrapper so hooks work correctly
      // Pass search to force re-render when query params change
      let content = React.createElement(PageWrapper, { component: Page, pathname: path, search: search });

      // Wrap with loading.tsx Suspense fallback if it exists
      if (LoadingComponent) {
        content = React.createElement(React.Suspense,
          { fallback: React.createElement(LoadingComponent) },
          content
        );
      }

      // Wrap with error boundary if error.tsx exists
      if (ErrorComponent) {
        content = React.createElement(ErrorBoundary, { fallback: ErrorComponent }, content);
      }

      for (let i = layouts.length - 1; i >= 0; i--) {
        content = React.createElement(layouts[i], null, content);
      }
      return content;
    }

    // Mark that we've initialized (for testing no-reload)
    window.__NEXT_INITIALIZED__ = Date.now();

    ReactDOM.createRoot(document.getElementById('__next')).render(
      React.createElement(React.StrictMode, null, React.createElement(Router))
    );
  <\/script>
</body>
</html>`;
  }
  async function generatePageHtml(ctx, pageFile, pathname) {
    const virtualPrefix = `/__virtual__/${ctx.port}`;
    const globalCssLinks = [];
    const cssLocations = [
      "/styles/globals.css",
      "/styles/global.css",
      "/app/globals.css"
    ];
    for (const cssPath of cssLocations) {
      if (ctx.exists(cssPath)) {
        globalCssLinks.push(`<link rel="stylesheet" href="${virtualPrefix}${cssPath}">`);
      }
    }
    const envScript = ctx.generateEnvScript();
    const tailwindConfigScript = await ctx.loadTailwindConfigIfNeeded();
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <base href="${virtualPrefix}/">
  <title>Next.js App</title>
  ${envScript}
  ${TAILWIND_CDN_SCRIPT}
  ${tailwindConfigScript}
  ${CORS_PROXY_SCRIPT}
  ${globalCssLinks.join("\n  ")}
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0?dev",
      "react/": "https://esm.sh/react@18.2.0&dev/",
      "react-dom": "https://esm.sh/react-dom@18.2.0?dev",
      "react-dom/": "https://esm.sh/react-dom@18.2.0&dev/",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev",
      "next/link": "${virtualPrefix}/_next/shims/link.js",
      "next/router": "${virtualPrefix}/_next/shims/router.js",
      "next/head": "${virtualPrefix}/_next/shims/head.js",
      "next/navigation": "${virtualPrefix}/_next/shims/navigation.js",
      "next/image": "${virtualPrefix}/_next/shims/image.js",
      "next/dynamic": "${virtualPrefix}/_next/shims/dynamic.js",
      "next/script": "${virtualPrefix}/_next/shims/script.js",
      "next/font/google": "${virtualPrefix}/_next/shims/font/google.js",
      "next/font/local": "${virtualPrefix}/_next/shims/font/local.js"
    }
  }
  <\/script>
  ${REACT_REFRESH_PREAMBLE}
  ${HMR_CLIENT_SCRIPT}
</head>
<body>
  <div id="__next"></div>
  <script type="module">
    import React from 'react';
    import ReactDOM from 'react-dom/client';

    const virtualBase = '${virtualPrefix}';

    // Convert URL path to page module path
    function getPageModulePath(pathname) {
      let route = pathname;
      if (route.startsWith(virtualBase)) {
        route = route.slice(virtualBase.length);
      }
      route = route.replace(/^\\/+/, '/') || '/';
      const modulePath = route === '/' ? '/index' : route;
      return virtualBase + '/_next/pages' + modulePath + '.js';
    }

    // Dynamic page loader
    async function loadPage(pathname) {
      const modulePath = getPageModulePath(pathname);
      try {
        const module = await import(/* @vite-ignore */ modulePath);
        return module.default;
      } catch (e) {
        console.error('[Navigation] Failed to load:', modulePath, e);
        return null;
      }
    }

    // Router component
    function Router() {
      const [Page, setPage] = React.useState(null);
      const [path, setPath] = React.useState(window.location.pathname);

      React.useEffect(() => {
        loadPage(path).then(C => C && setPage(() => C));
      }, []);

      React.useEffect(() => {
        const handleNavigation = async () => {
          const newPath = window.location.pathname;
          if (newPath !== path) {
            setPath(newPath);
            const C = await loadPage(newPath);
            if (C) setPage(() => C);
          }
        };
        window.addEventListener('popstate', handleNavigation);
        return () => window.removeEventListener('popstate', handleNavigation);
      }, [path]);

      if (!Page) return null;
      return React.createElement(Page);
    }

    // Mark that we've initialized (for testing no-reload)
    window.__NEXT_INITIALIZED__ = Date.now();

    ReactDOM.createRoot(document.getElementById('__next')).render(
      React.createElement(React.StrictMode, null, React.createElement(Router))
    );
  <\/script>
</body>
</html>`;
  }
  function serve404Page(port) {
    const virtualPrefix = `/__virtual__/${port}`;
    const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <base href="${virtualPrefix}/">
  <title>404 - Page Not Found</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      background: #fafafa;
    }
    h1 { font-size: 48px; margin: 0; }
    p { color: #666; margin-top: 10px; }
    a { color: #0070f3; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <h1>404</h1>
  <p>This page could not be found.</p>
  <p><a href="/">Go back home</a></p>
</body>
</html>`;
    const buffer2 = BufferPolyfill.from(html);
    return {
      statusCode: 404,
      statusMessage: "Not Found",
      headers: {
        "Content-Type": "text/html; charset=utf-8",
        "Content-Length": String(buffer2.length)
      },
      body: buffer2
    };
  }
  const PAGE_EXTENSIONS = [
    ".jsx",
    ".tsx",
    ".js",
    ".ts"
  ];
  const API_EXTENSIONS = [
    ".js",
    ".ts",
    ".jsx",
    ".tsx"
  ];
  function hasAppRouter(appDir, ctx) {
    try {
      if (!ctx.exists(appDir))
        return false;
      for (const ext2 of PAGE_EXTENSIONS) {
        if (ctx.exists(`${appDir}/page${ext2}`))
          return true;
      }
      try {
        const entries = ctx.readdir(appDir);
        for (const entry of entries) {
          if (/^\([^)]+\)$/.test(entry) && ctx.isDirectory(`${appDir}/${entry}`)) {
            for (const ext2 of PAGE_EXTENSIONS) {
              if (ctx.exists(`${appDir}/${entry}/page${ext2}`))
                return true;
            }
          }
        }
      } catch {
      }
      for (const ext2 of PAGE_EXTENSIONS) {
        if (ctx.exists(`${appDir}/layout${ext2}`))
          return true;
      }
      return false;
    } catch {
      return false;
    }
  }
  function resolveAppRoute(appDir, pathname, ctx) {
    const segments = pathname === "/" ? [] : pathname.split("/").filter(Boolean);
    return resolveAppDynamicRoute(appDir, segments, ctx);
  }
  function resolveAppDynamicRoute(appDir, segments, ctx) {
    const collectLayout = (dirPath, layouts2) => {
      for (const ext2 of PAGE_EXTENSIONS) {
        const layoutPath = `${dirPath}/layout${ext2}`;
        if (ctx.exists(layoutPath) && !layouts2.includes(layoutPath)) {
          return [
            ...layouts2,
            layoutPath
          ];
        }
      }
      return layouts2;
    };
    const findPage = (dirPath) => {
      for (const ext2 of PAGE_EXTENSIONS) {
        const pagePath = `${dirPath}/page${ext2}`;
        if (ctx.exists(pagePath)) {
          return pagePath;
        }
      }
      return null;
    };
    const findConventionFile = (dirPath, name2) => {
      for (const ext2 of PAGE_EXTENSIONS) {
        const filePath = `${dirPath}/${name2}${ext2}`;
        if (ctx.exists(filePath)) {
          return filePath;
        }
      }
      return null;
    };
    const findNearestConventionFile = (dirPath, name2) => {
      let current = dirPath;
      while (current.startsWith(appDir)) {
        const file = findConventionFile(current, name2);
        if (file)
          return file;
        const parent = current.replace(/\/[^/]+$/, "");
        if (parent === current)
          break;
        current = parent;
      }
      return null;
    };
    const getRouteGroups = (dirPath) => {
      try {
        const entries = ctx.readdir(dirPath);
        return entries.filter((e11) => /^\([^)]+\)$/.test(e11) && ctx.isDirectory(`${dirPath}/${e11}`));
      } catch {
        return [];
      }
    };
    const tryPath = (dirPath, remainingSegments, layouts2, params) => {
      layouts2 = collectLayout(dirPath, layouts2);
      if (remainingSegments.length === 0) {
        const page2 = findPage(dirPath);
        if (page2) {
          return {
            page: page2,
            layouts: layouts2,
            params,
            loading: findNearestConventionFile(dirPath, "loading") || void 0,
            error: findNearestConventionFile(dirPath, "error") || void 0,
            notFound: findNearestConventionFile(dirPath, "not-found") || void 0
          };
        }
        const groups2 = getRouteGroups(dirPath);
        for (const group of groups2) {
          const groupPath = `${dirPath}/${group}`;
          const groupLayouts = collectLayout(groupPath, layouts2);
          const page22 = findPage(groupPath);
          if (page22) {
            return {
              page: page22,
              layouts: groupLayouts,
              params,
              loading: findNearestConventionFile(groupPath, "loading") || void 0,
              error: findNearestConventionFile(groupPath, "error") || void 0,
              notFound: findNearestConventionFile(groupPath, "not-found") || void 0
            };
          }
        }
        return null;
      }
      const [current, ...rest] = remainingSegments;
      const exactPath = `${dirPath}/${current}`;
      if (ctx.isDirectory(exactPath)) {
        const result = tryPath(exactPath, rest, layouts2, params);
        if (result)
          return result;
      }
      const groups = getRouteGroups(dirPath);
      for (const group of groups) {
        const groupPath = `${dirPath}/${group}`;
        const groupLayouts = collectLayout(groupPath, layouts2);
        const groupExactPath = `${groupPath}/${current}`;
        if (ctx.isDirectory(groupExactPath)) {
          const result = tryPath(groupExactPath, rest, groupLayouts, params);
          if (result)
            return result;
        }
        try {
          const groupEntries = ctx.readdir(groupPath);
          for (const entry of groupEntries) {
            if (entry.startsWith("[...") && entry.endsWith("]")) {
              const dynamicPath = `${groupPath}/${entry}`;
              if (ctx.isDirectory(dynamicPath)) {
                const paramName = entry.slice(4, -1);
                const newParams = {
                  ...params,
                  [paramName]: [
                    current,
                    ...rest
                  ]
                };
                const result = tryPath(dynamicPath, [], groupLayouts, newParams);
                if (result)
                  return result;
              }
            } else if (entry.startsWith("[[...") && entry.endsWith("]]")) {
              const dynamicPath = `${groupPath}/${entry}`;
              if (ctx.isDirectory(dynamicPath)) {
                const paramName = entry.slice(5, -2);
                const newParams = {
                  ...params,
                  [paramName]: [
                    current,
                    ...rest
                  ]
                };
                const result = tryPath(dynamicPath, [], groupLayouts, newParams);
                if (result)
                  return result;
              }
            } else if (entry.startsWith("[") && entry.endsWith("]") && !entry.includes(".")) {
              const dynamicPath = `${groupPath}/${entry}`;
              if (ctx.isDirectory(dynamicPath)) {
                const paramName = entry.slice(1, -1);
                const newParams = {
                  ...params,
                  [paramName]: current
                };
                const result = tryPath(dynamicPath, rest, groupLayouts, newParams);
                if (result)
                  return result;
              }
            }
          }
        } catch {
        }
      }
      try {
        const entries = ctx.readdir(dirPath);
        for (const entry of entries) {
          if (entry.startsWith("[...") && entry.endsWith("]")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const paramName = entry.slice(4, -1);
              const newParams = {
                ...params,
                [paramName]: [
                  current,
                  ...rest
                ]
              };
              const result = tryPath(dynamicPath, [], layouts2, newParams);
              if (result)
                return result;
            }
          } else if (entry.startsWith("[[...") && entry.endsWith("]]")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const paramName = entry.slice(5, -2);
              const newParams = {
                ...params,
                [paramName]: [
                  current,
                  ...rest
                ]
              };
              const result = tryPath(dynamicPath, [], layouts2, newParams);
              if (result)
                return result;
            }
          } else if (entry.startsWith("[") && entry.endsWith("]") && !entry.includes(".")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const paramName = entry.slice(1, -1);
              const newParams = {
                ...params,
                [paramName]: current
              };
              const result = tryPath(dynamicPath, rest, layouts2, newParams);
              if (result)
                return result;
            }
          }
        }
      } catch {
      }
      return null;
    };
    const layouts = [];
    for (const ext2 of PAGE_EXTENSIONS) {
      const rootLayout = `${appDir}/layout${ext2}`;
      if (ctx.exists(rootLayout)) {
        layouts.push(rootLayout);
        break;
      }
    }
    return tryPath(appDir, segments, layouts, {});
  }
  function resolveAppRouteHandler(appDir, pathname, ctx) {
    const extensions = API_EXTENSIONS;
    const segments = pathname === "/" ? [] : pathname.split("/").filter(Boolean);
    let dirPath = appDir;
    for (const segment of segments) {
      dirPath = `${dirPath}/${segment}`;
    }
    for (const ext2 of extensions) {
      const routePath = `${dirPath}/route${ext2}`;
      if (ctx.exists(routePath)) {
        return routePath;
      }
    }
    return resolveAppRouteHandlerDynamic(appDir, segments, ctx);
  }
  function resolveAppRouteHandlerDynamic(appDir, segments, ctx) {
    const extensions = API_EXTENSIONS;
    const tryPath = (dirPath, remainingSegments) => {
      if (remainingSegments.length === 0) {
        for (const ext2 of extensions) {
          const routePath = `${dirPath}/route${ext2}`;
          if (ctx.exists(routePath)) {
            return routePath;
          }
        }
        try {
          const entries = ctx.readdir(dirPath);
          for (const entry of entries) {
            if (/^\([^)]+\)$/.test(entry) && ctx.isDirectory(`${dirPath}/${entry}`)) {
              for (const ext2 of extensions) {
                const routePath = `${dirPath}/${entry}/route${ext2}`;
                if (ctx.exists(routePath)) {
                  return routePath;
                }
              }
            }
          }
        } catch {
        }
        return null;
      }
      const [current, ...rest] = remainingSegments;
      const exactPath = `${dirPath}/${current}`;
      if (ctx.isDirectory(exactPath)) {
        const result = tryPath(exactPath, rest);
        if (result)
          return result;
      }
      try {
        const entries = ctx.readdir(dirPath);
        for (const entry of entries) {
          if (/^\([^)]+\)$/.test(entry) && ctx.isDirectory(`${dirPath}/${entry}`)) {
            const groupExact = `${dirPath}/${entry}/${current}`;
            if (ctx.isDirectory(groupExact)) {
              const result = tryPath(groupExact, rest);
              if (result)
                return result;
            }
          }
          if (entry.startsWith("[") && entry.endsWith("]") && !entry.includes(".")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const result = tryPath(dynamicPath, rest);
              if (result)
                return result;
            }
          }
          if (entry.startsWith("[...") && entry.endsWith("]")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const result = tryPath(dynamicPath, []);
              if (result)
                return result;
            }
          }
        }
      } catch {
      }
      return null;
    };
    return tryPath(appDir, segments);
  }
  function resolvePageFile(pagesDir, pathname, ctx) {
    if (pathname === "/") {
      pathname = "/index";
    }
    for (const ext2 of PAGE_EXTENSIONS) {
      const filePath = `${pagesDir}${pathname}${ext2}`;
      if (ctx.exists(filePath)) {
        return filePath;
      }
    }
    for (const ext2 of PAGE_EXTENSIONS) {
      const filePath = `${pagesDir}${pathname}/index${ext2}`;
      if (ctx.exists(filePath)) {
        return filePath;
      }
    }
    return resolveDynamicRoute(pagesDir, pathname, ctx);
  }
  function resolveDynamicRoute(pagesDir, pathname, ctx) {
    const segments = pathname.split("/").filter(Boolean);
    if (segments.length === 0)
      return null;
    const tryPath = (dirPath, remainingSegments) => {
      if (remainingSegments.length === 0) {
        for (const ext2 of PAGE_EXTENSIONS) {
          const indexPath = `${dirPath}/index${ext2}`;
          if (ctx.exists(indexPath)) {
            return indexPath;
          }
        }
        return null;
      }
      const [current, ...rest] = remainingSegments;
      const exactPath = `${dirPath}/${current}`;
      for (const ext2 of PAGE_EXTENSIONS) {
        if (rest.length === 0 && ctx.exists(exactPath + ext2)) {
          return exactPath + ext2;
        }
      }
      if (ctx.isDirectory(exactPath)) {
        const exactResult = tryPath(exactPath, rest);
        if (exactResult)
          return exactResult;
      }
      try {
        const entries = ctx.readdir(dirPath);
        for (const entry of entries) {
          for (const ext2 of PAGE_EXTENSIONS) {
            const dynamicFilePattern = /^\[([^\]]+)\]$/;
            const nameWithoutExt = entry.replace(ext2, "");
            if (entry.endsWith(ext2) && dynamicFilePattern.test(nameWithoutExt)) {
              if (rest.length === 0) {
                const filePath = `${dirPath}/${entry}`;
                if (ctx.exists(filePath)) {
                  return filePath;
                }
              }
            }
          }
          if (entry.startsWith("[") && entry.endsWith("]") && !entry.includes(".")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const dynamicResult = tryPath(dynamicPath, rest);
              if (dynamicResult)
                return dynamicResult;
            }
          }
          for (const ext2 of PAGE_EXTENSIONS) {
            if (entry.startsWith("[...") && entry.endsWith("]" + ext2)) {
              const filePath = `${dirPath}/${entry}`;
              if (ctx.exists(filePath)) {
                return filePath;
              }
            }
          }
        }
      } catch {
      }
      return null;
    };
    return tryPath(pagesDir, segments);
  }
  function resolveApiFile(pagesDir, pathname, ctx) {
    const apiPath = pathname.replace(/^\/api/, `${pagesDir}/api`);
    for (const ext2 of API_EXTENSIONS) {
      const filePath = apiPath + ext2;
      if (ctx.exists(filePath)) {
        return filePath;
      }
    }
    for (const ext2 of API_EXTENSIONS) {
      const filePath = `${apiPath}/index${ext2}`;
      if (ctx.exists(filePath)) {
        return filePath;
      }
    }
    return null;
  }
  function resolveFileWithExtension(pathname, ctx) {
    if (/\.\w+$/.test(pathname) && ctx.exists(pathname)) {
      return pathname;
    }
    const extensions = [
      ".tsx",
      ".ts",
      ".jsx",
      ".js"
    ];
    for (const ext2 of extensions) {
      const withExt = pathname + ext2;
      if (ctx.exists(withExt)) {
        return withExt;
      }
    }
    for (const ext2 of extensions) {
      const indexPath = pathname + "/index" + ext2;
      if (ctx.exists(indexPath)) {
        return indexPath;
      }
    }
    return null;
  }
  function needsTransform(path22) {
    return /\.(jsx|tsx|ts)$/.test(path22);
  }
  function parseCookies(cookieHeader) {
    const cookies = {};
    if (!cookieHeader)
      return cookies;
    cookieHeader.split(";").forEach((cookie) => {
      const [name2, value2] = cookie.trim().split("=");
      if (name2 && value2) {
        cookies[name2] = decodeURIComponent(value2);
      }
    });
    return cookies;
  }
  function createMockRequest(method, pathname, headers, body) {
    const url2 = new URL(pathname, "http://localhost");
    return {
      method,
      url: pathname,
      headers,
      query: Object.fromEntries(url2.searchParams),
      body: body ? JSON.parse(body.toString()) : void 0,
      cookies: parseCookies(headers.cookie || "")
    };
  }
  function createMockResponse() {
    let statusCode = 200;
    let statusMessage = "OK";
    const headers = {};
    let responseBody = "";
    let ended = false;
    let resolveEnded = null;
    let headersSent = false;
    const endedPromise = new Promise((resolve2) => {
      resolveEnded = resolve2;
    });
    const markEnded = () => {
      if (!ended) {
        ended = true;
        if (resolveEnded)
          resolveEnded();
      }
    };
    return {
      headersSent: false,
      status(code2) {
        statusCode = code2;
        return this;
      },
      setHeader(name2, value2) {
        headers[name2] = value2;
        return this;
      },
      getHeader(name2) {
        return headers[name2];
      },
      write(chunk) {
        if (!headersSent) {
          headersSent = true;
          this.headersSent = true;
        }
        responseBody += typeof chunk === "string" ? chunk : chunk.toString();
        return true;
      },
      get writable() {
        return true;
      },
      json(data2) {
        headers["Content-Type"] = "application/json; charset=utf-8";
        responseBody = JSON.stringify(data2);
        markEnded();
        return this;
      },
      send(data2) {
        if (typeof data2 === "object") {
          return this.json(data2);
        }
        responseBody = data2;
        markEnded();
        return this;
      },
      end(data2) {
        if (data2)
          responseBody += data2;
        markEnded();
        return this;
      },
      redirect(statusOrUrl, url2) {
        if (typeof statusOrUrl === "number") {
          statusCode = statusOrUrl;
          headers["Location"] = url2 || "/";
        } else {
          statusCode = 307;
          headers["Location"] = statusOrUrl;
        }
        markEnded();
        return this;
      },
      isEnded() {
        return ended;
      },
      waitForEnd() {
        return endedPromise;
      },
      toResponse() {
        const buffer2 = BufferPolyfill.from(responseBody);
        headers["Content-Length"] = String(buffer2.length);
        return {
          statusCode,
          statusMessage,
          headers,
          body: buffer2
        };
      }
    };
  }
  function createStreamingMockResponse(onStart, onChunk, onEnd) {
    let statusCode = 200;
    let statusMessage = "OK";
    const headers = {};
    let ended = false;
    let headersSent = false;
    let resolveEnded = null;
    const endedPromise = new Promise((resolve2) => {
      resolveEnded = resolve2;
    });
    const sendHeaders = () => {
      if (!headersSent) {
        headersSent = true;
        onStart(statusCode, statusMessage, headers);
      }
    };
    const markEnded = () => {
      if (!ended) {
        sendHeaders();
        ended = true;
        onEnd();
        if (resolveEnded)
          resolveEnded();
      }
    };
    return {
      headersSent: false,
      status(code2) {
        statusCode = code2;
        return this;
      },
      setHeader(name2, value2) {
        headers[name2] = value2;
        return this;
      },
      getHeader(name2) {
        return headers[name2];
      },
      write(chunk) {
        sendHeaders();
        const data2 = typeof chunk === "string" ? chunk : chunk.toString();
        onChunk(data2);
        return true;
      },
      get writable() {
        return true;
      },
      json(data2) {
        headers["Content-Type"] = "application/json; charset=utf-8";
        sendHeaders();
        onChunk(JSON.stringify(data2));
        markEnded();
        return this;
      },
      send(data2) {
        if (typeof data2 === "object") {
          return this.json(data2);
        }
        sendHeaders();
        onChunk(data2);
        markEnded();
        return this;
      },
      end(data2) {
        if (data2) {
          sendHeaders();
          onChunk(data2);
        }
        markEnded();
        return this;
      },
      redirect(statusOrUrl, url2) {
        if (typeof statusOrUrl === "number") {
          statusCode = statusOrUrl;
          headers["Location"] = url2 || "/";
        } else {
          statusCode = 307;
          headers["Location"] = statusOrUrl;
        }
        markEnded();
        return this;
      },
      isEnded() {
        return ended;
      },
      waitForEnd() {
        return endedPromise;
      },
      toResponse() {
        return {
          statusCode,
          statusMessage,
          headers,
          body: BufferPolyfill.from("")
        };
      }
    };
  }
  async function createBuiltinModules(createFsShim2) {
    const modules = {
      https: await Promise.resolve().then(() => httpsShim),
      http: await Promise.resolve().then(() => httpShim),
      path: await Promise.resolve().then(() => pathShim),
      url: await Promise.resolve().then(() => urlShim),
      querystring: await Promise.resolve().then(() => querystringShim),
      util: await Promise.resolve().then(() => utilShim),
      events: await Promise.resolve().then(() => events$1),
      stream: await Promise.resolve().then(() => stream),
      buffer: await Promise.resolve().then(() => buffer),
      crypto: await Promise.resolve().then(() => cryptoShim)
    };
    if (createFsShim2) {
      modules.fs = await createFsShim2();
    }
    return modules;
  }
  async function executeApiHandler(code2, req, res, env, builtinModules2) {
    try {
      const require2 = (id2) => {
        const modId = id2.startsWith("node:") ? id2.slice(5) : id2;
        if (builtinModules2[modId]) {
          return builtinModules2[modId];
        }
        throw new Error(`Module not found: ${id2}`);
      };
      const module2 = {
        exports: {}
      };
      const exports$1 = module2.exports;
      const process22 = {
        env: {
          ...env
        },
        cwd: () => "/",
        platform: "browser",
        version: "v18.0.0",
        versions: {
          node: "18.0.0"
        }
      };
      const fn22 = new Function("exports", "require", "module", "process", code2);
      fn22(exports$1, require2, module2, process22);
      let handler = module2.exports.default || module2.exports;
      if (typeof handler === "object" && handler !== null && "default" in handler) {
        handler = handler.default;
      }
      if (typeof handler !== "function") {
        throw new Error("No default export handler found");
      }
      const result = handler(req, res);
      if (result instanceof Promise) {
        await result;
      }
    } catch (error) {
      console.error("[NextDevServer] API handler error:", error);
      throw error;
    }
  }
  const isBrowser = typeof window !== "undefined" && typeof window.navigator !== "undefined" && "serviceWorker" in window.navigator;
  async function initEsbuild() {
    if (!isBrowser)
      return;
    if (window.__esbuild) {
      return;
    }
    if (window.__esbuildInitPromise) {
      return window.__esbuildInitPromise;
    }
    window.__esbuildInitPromise = (async () => {
      try {
        const mod = await import("https://esm.sh/esbuild-wasm@0.20.0").then(async (m) => {
          await m.__tla;
          return m;
        });
        const esbuildMod = mod.default || mod;
        try {
          await esbuildMod.initialize({
            wasmURL: "https://unpkg.com/esbuild-wasm@0.20.0/esbuild.wasm"
          });
          console.log("[NextDevServer] esbuild-wasm initialized");
        } catch (initError) {
          if (initError instanceof Error && initError.message.includes('Cannot call "initialize" more than once')) {
            console.log("[NextDevServer] esbuild-wasm already initialized, reusing");
          } else {
            throw initError;
          }
        }
        window.__esbuild = esbuildMod;
      } catch (error) {
        console.error("[NextDevServer] Failed to initialize esbuild:", error);
        window.__esbuildInitPromise = void 0;
        throw error;
      }
    })();
    return window.__esbuildInitPromise;
  }
  function getEsbuild() {
    return isBrowser ? window.__esbuild : void 0;
  }
  NextDevServer = class extends DevServer {
    constructor(vfs2, options2) {
      super(vfs2, options2);
      __publicField(this, "pagesDir");
      __publicField(this, "appDir");
      __publicField(this, "publicDir");
      __publicField(this, "useAppRouter");
      __publicField(this, "watcherCleanup", null);
      __publicField(this, "hmrTargetWindow", null);
      __publicField(this, "options");
      __publicField(this, "transformCache", /* @__PURE__ */ new Map());
      __publicField(this, "pathAliases", /* @__PURE__ */ new Map());
      __publicField(this, "tailwindConfigScript", "");
      __publicField(this, "tailwindConfigLoaded", false);
      __publicField(this, "assetPrefix", "");
      __publicField(this, "basePath", "");
      this.options = options2;
      this.pagesDir = options2.pagesDir || "/pages";
      this.appDir = options2.appDir || "/app";
      this.publicDir = options2.publicDir || "/public";
      if (options2.preferAppRouter !== void 0) {
        this.useAppRouter = options2.preferAppRouter;
      } else {
        this.useAppRouter = hasAppRouter(this.appDir, this.routeCtx);
      }
      this.loadPathAliases();
      this.loadAssetPrefix(options2.assetPrefix);
      this.loadBasePath(options2.basePath);
    }
    get routeCtx() {
      return {
        exists: (path22) => this.exists(path22),
        isDirectory: (path22) => this.isDirectory(path22),
        readdir: (path22) => this.vfs.readdirSync(path22)
      };
    }
    loadPathAliases() {
      var _a22;
      try {
        const tsconfigPath = "/tsconfig.json";
        if (!this.vfs.existsSync(tsconfigPath)) {
          return;
        }
        const content = this.vfs.readFileSync(tsconfigPath, "utf-8");
        const tsconfig = JSON.parse(content);
        const paths = (_a22 = tsconfig == null ? void 0 : tsconfig.compilerOptions) == null ? void 0 : _a22.paths;
        if (!paths) {
          return;
        }
        for (const [alias, targets] of Object.entries(paths)) {
          if (Array.isArray(targets) && targets.length > 0) {
            const aliasPrefix = alias.replace(/\*$/, "");
            const targetPrefix = targets[0].replace(/\*$/, "").replace(/^\./, "");
            this.pathAliases.set(aliasPrefix, targetPrefix);
          }
        }
      } catch (e11) {
      }
    }
    loadConfigStringValue(key, optionValue) {
      if (optionValue !== void 0) {
        let val = optionValue.startsWith("/") ? optionValue : `/${optionValue}`;
        if (val.endsWith("/"))
          val = val.slice(0, -1);
        return val;
      }
      try {
        const configFiles = [
          {
            path: "/next.config.ts",
            isTs: true
          },
          {
            path: "/next.config.js",
            isTs: false
          },
          {
            path: "/next.config.mjs",
            isTs: false
          }
        ];
        for (const { path: path22, isTs } of configFiles) {
          if (!this.vfs.existsSync(path22))
            continue;
          const content = this.vfs.readFileSync(path22, "utf-8");
          const value2 = parseNextConfigValue(content, key, isTs);
          if (value2) {
            let normalized = value2.startsWith("/") ? value2 : `/${value2}`;
            if (normalized.endsWith("/"))
              normalized = normalized.slice(0, -1);
            return normalized;
          }
        }
      } catch {
      }
      return "";
    }
    loadAssetPrefix(optionValue) {
      this.assetPrefix = this.loadConfigStringValue("assetPrefix", optionValue);
    }
    loadBasePath(optionValue) {
      this.basePath = this.loadConfigStringValue("basePath", optionValue);
    }
    resolvePathAliases(code2, currentFile) {
      if (this.pathAliases.size === 0) {
        return code2;
      }
      const virtualBase = `/__virtual__/${this.port}`;
      let result = code2;
      for (const [alias, target] of this.pathAliases) {
        const aliasEscaped = alias.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const pattern = new RegExp(`(from\\s*['"]|import\\s*\\(\\s*['"])${aliasEscaped}([^'"]+)(['"])`, "g");
        result = result.replace(pattern, (match2, prefix, path22, quote) => {
          const resolvedPath2 = `${virtualBase}${target}${path22}`;
          return `${prefix}${resolvedPath2}${quote}`;
        });
      }
      return result;
    }
    setEnv(key, value2) {
      this.options.env = this.options.env || {};
      this.options.env[key] = value2;
    }
    getEnv() {
      return {
        ...this.options.env
      };
    }
    setHMRTarget(targetWindow) {
      this.hmrTargetWindow = targetWindow;
    }
    generateEnvScript() {
      const env = this.options.env || {};
      const publicEnvVars = {};
      for (const [key, value2] of Object.entries(env)) {
        if (key.startsWith("NEXT_PUBLIC_")) {
          publicEnvVars[key] = value2;
        }
      }
      return `<script>
  // Environment variables (injected by NextDevServer)
  window.process = window.process || {};
  window.process.env = window.process.env || {};
  Object.assign(window.process.env, ${JSON.stringify(publicEnvVars)});
  // Next.js config values
  window.__NEXT_BASE_PATH__ = ${JSON.stringify(this.basePath)};
<\/script>`;
    }
    async loadTailwindConfigIfNeeded() {
      if (this.tailwindConfigLoaded) {
        return this.tailwindConfigScript;
      }
      try {
        const result = await loadTailwindConfig(this.vfs, this.root);
        if (result.success) {
          this.tailwindConfigScript = result.configScript;
        } else if (result.error) {
          console.warn("[NextDevServer] Tailwind config warning:", result.error);
          this.tailwindConfigScript = "";
        }
      } catch (error) {
        console.warn("[NextDevServer] Failed to load tailwind.config:", error);
        this.tailwindConfigScript = "";
      }
      this.tailwindConfigLoaded = true;
      return this.tailwindConfigScript;
    }
    async handleRequest(method, url2, headers, body) {
      const urlObj = new URL(url2, "http://localhost");
      let pathname = urlObj.pathname;
      const virtualPrefixMatch = pathname.match(/^\/__virtual__\/\d+/);
      if (virtualPrefixMatch) {
        pathname = pathname.slice(virtualPrefixMatch[0].length) || "/";
      }
      if (this.assetPrefix && pathname.startsWith(this.assetPrefix)) {
        const rest = pathname.slice(this.assetPrefix.length);
        if (rest === "" || rest.startsWith("/")) {
          pathname = rest || "/";
          if (pathname.startsWith("//")) {
            pathname = pathname.slice(1);
          }
        }
      }
      if (this.basePath && pathname.startsWith(this.basePath)) {
        const rest = pathname.slice(this.basePath.length);
        if (rest === "" || rest.startsWith("/")) {
          pathname = rest || "/";
        }
      }
      if (pathname.startsWith("/_next/shims/")) {
        return this.serveNextShim(pathname);
      }
      if (pathname === "/_next/route-info") {
        return this.serveRouteInfo(urlObj.searchParams.get("pathname") || "/");
      }
      if (pathname.startsWith("/_next/pages/")) {
        return this.servePageComponent(pathname);
      }
      if (pathname.startsWith("/_next/app/")) {
        return this.serveAppComponent(pathname);
      }
      if (pathname.startsWith("/_next/static/")) {
        return this.serveStaticAsset(pathname);
      }
      if (this.useAppRouter) {
        const appRouteFile = resolveAppRouteHandler(this.appDir, pathname, this.routeCtx);
        if (appRouteFile) {
          return this.handleAppRouteHandler(method, pathname, headers, body, appRouteFile, urlObj.search);
        }
      }
      if (pathname.startsWith("/api/")) {
        return this.handleApiRoute(method, pathname, headers, body);
      }
      const publicPath = this.publicDir + pathname;
      if (this.exists(publicPath) && !this.isDirectory(publicPath)) {
        return this.serveFile(publicPath);
      }
      if (needsTransform(pathname) && this.exists(pathname)) {
        return this.transformAndServe(pathname, pathname);
      }
      const resolvedFile = resolveFileWithExtension(pathname, this.routeCtx);
      if (resolvedFile) {
        if (needsTransform(resolvedFile)) {
          return this.transformAndServe(resolvedFile, pathname);
        }
        return this.serveFile(resolvedFile);
      }
      if (this.exists(pathname) && !this.isDirectory(pathname)) {
        return this.serveFile(pathname);
      }
      return this.handlePageRoute(pathname, urlObj.search);
    }
    serveNextShim(pathname) {
      const shimName = pathname.replace("/_next/shims/", "").replace(".js", "");
      let code2;
      switch (shimName) {
        case "link":
          code2 = NEXT_LINK_SHIM;
          break;
        case "router":
          code2 = NEXT_ROUTER_SHIM;
          break;
        case "head":
          code2 = NEXT_HEAD_SHIM;
          break;
        case "navigation":
          code2 = NEXT_NAVIGATION_SHIM;
          break;
        case "image":
          code2 = NEXT_IMAGE_SHIM;
          break;
        case "dynamic":
          code2 = NEXT_DYNAMIC_SHIM;
          break;
        case "script":
          code2 = NEXT_SCRIPT_SHIM;
          break;
        case "font/google":
          code2 = NEXT_FONT_GOOGLE_SHIM;
          break;
        case "font/local":
          code2 = NEXT_FONT_LOCAL_SHIM;
          break;
        default:
          return this.notFound(pathname);
      }
      const buffer2 = BufferPolyfill.from(code2);
      return {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "Content-Type": "application/javascript; charset=utf-8",
          "Content-Length": String(buffer2.length),
          "Cache-Control": "no-cache"
        },
        body: buffer2
      };
    }
    serveRouteInfo(pathname) {
      const route = resolveAppRoute(this.appDir, pathname, this.routeCtx);
      const info = route ? {
        params: route.params,
        found: true
      } : {
        params: {},
        found: false
      };
      const json = JSON.stringify(info);
      const buffer2 = BufferPolyfill.from(json);
      return {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "Content-Type": "application/json; charset=utf-8",
          "Content-Length": String(buffer2.length),
          "Cache-Control": "no-cache"
        },
        body: buffer2
      };
    }
    serveStaticAsset(pathname) {
      const filePath = pathname.replace("/_next/static/", "/");
      if (this.exists(filePath)) {
        return this.serveFile(filePath);
      }
      return this.notFound(pathname);
    }
    async servePageComponent(pathname) {
      const route = pathname.replace("/_next/pages", "").replace(/\.js$/, "");
      const pageFile = resolvePageFile(this.pagesDir, route, this.routeCtx);
      if (!pageFile) {
        return this.notFound(pathname);
      }
      return this.transformAndServe(pageFile, pageFile);
    }
    async serveAppComponent(pathname) {
      const rawFilePath = pathname.replace("/_next/app", "");
      if (this.exists(rawFilePath) && !this.isDirectory(rawFilePath)) {
        return this.transformAndServe(rawFilePath, rawFilePath);
      }
      const filePath = rawFilePath.replace(/\.js$/, "");
      const extensions = [
        ".tsx",
        ".jsx",
        ".ts",
        ".js"
      ];
      for (const ext2 of extensions) {
        const fullPath = filePath + ext2;
        if (this.exists(fullPath)) {
          return this.transformAndServe(fullPath, fullPath);
        }
      }
      return this.notFound(pathname);
    }
    async handleApiRoute(method, pathname, headers, body) {
      const apiFile = resolveApiFile(this.pagesDir, pathname, this.routeCtx);
      if (!apiFile) {
        return {
          statusCode: 404,
          statusMessage: "Not Found",
          headers: {
            "Content-Type": "application/json; charset=utf-8"
          },
          body: BufferPolyfill.from(JSON.stringify({
            error: "API route not found"
          }))
        };
      }
      try {
        const code2 = this.vfs.readFileSync(apiFile, "utf8");
        const transformed = await this.transformApiHandler(code2, apiFile);
        const req = createMockRequest(method, pathname, headers, body);
        const res = createMockResponse();
        const builtins = await createBuiltinModules(() => Promise.resolve().then(() => fs).then((m) => m.createFsShim(this.vfs)));
        await executeApiHandler(transformed, req, res, this.options.env, builtins);
        if (!res.isEnded()) {
          const timeout = new Promise((_10, reject) => {
            setTimeout(() => reject(new Error("API handler timeout")), 3e4);
          });
          await Promise.race([
            res.waitForEnd(),
            timeout
          ]);
        }
        return res.toResponse();
      } catch (error) {
        console.error("[NextDevServer] API error:", error);
        return {
          statusCode: 500,
          statusMessage: "Internal Server Error",
          headers: {
            "Content-Type": "application/json; charset=utf-8"
          },
          body: BufferPolyfill.from(JSON.stringify({
            error: error instanceof Error ? error.message : "Internal Server Error"
          }))
        };
      }
    }
    async handleAppRouteHandler(method, pathname, headers, body, routeFile, search) {
      try {
        const code2 = this.vfs.readFileSync(routeFile, "utf8");
        const transformed = await this.transformApiHandler(code2, routeFile);
        const builtinModules2 = await createBuiltinModules();
        const require2 = (id2) => {
          const modId = id2.startsWith("node:") ? id2.slice(5) : id2;
          if (builtinModules2[modId])
            return builtinModules2[modId];
          throw new Error(`Module not found: ${id2}`);
        };
        const moduleObj = {
          exports: {}
        };
        const exports$1 = moduleObj.exports;
        const process22 = {
          env: {
            ...this.options.env
          },
          cwd: () => "/",
          platform: "browser",
          version: "v18.0.0",
          versions: {
            node: "18.0.0"
          }
        };
        const fn22 = new Function("exports", "require", "module", "process", transformed);
        fn22(exports$1, require2, moduleObj, process22);
        const methodUpper = method.toUpperCase();
        const handler = moduleObj.exports[methodUpper] || moduleObj.exports[methodUpper.toLowerCase()];
        if (typeof handler !== "function") {
          return {
            statusCode: 405,
            statusMessage: "Method Not Allowed",
            headers: {
              "Content-Type": "application/json; charset=utf-8"
            },
            body: BufferPolyfill.from(JSON.stringify({
              error: `Method ${method} not allowed`
            }))
          };
        }
        const requestUrl = new URL(pathname + (search || ""), "http://localhost");
        const requestInit = {
          method: methodUpper,
          headers: new Headers(headers)
        };
        if (body && methodUpper !== "GET" && methodUpper !== "HEAD") {
          requestInit.body = body;
        }
        const request2 = new Request(requestUrl.toString(), requestInit);
        const route = resolveAppRoute(this.appDir, pathname, this.routeCtx);
        const params = (route == null ? void 0 : route.params) || {};
        const response = await handler(request2, {
          params: Promise.resolve(params)
        });
        if (response instanceof Response) {
          const respHeaders = {};
          response.headers.forEach((value2, key) => {
            respHeaders[key] = value2;
          });
          const respBody = await response.text();
          return {
            statusCode: response.status,
            statusMessage: response.statusText || "OK",
            headers: respHeaders,
            body: BufferPolyfill.from(respBody)
          };
        }
        if (response && typeof response === "object") {
          const json = JSON.stringify(response);
          return {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
              "Content-Type": "application/json; charset=utf-8"
            },
            body: BufferPolyfill.from(json)
          };
        }
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "text/plain; charset=utf-8"
          },
          body: BufferPolyfill.from(String(response || ""))
        };
      } catch (error) {
        console.error("[NextDevServer] App Route handler error:", error);
        return {
          statusCode: 500,
          statusMessage: "Internal Server Error",
          headers: {
            "Content-Type": "application/json; charset=utf-8"
          },
          body: BufferPolyfill.from(JSON.stringify({
            error: error instanceof Error ? error.message : "Internal Server Error"
          }))
        };
      }
    }
    async handleStreamingRequest(method, url2, headers, body, onStart, onChunk, onEnd) {
      const urlObj = new URL(url2, "http://localhost");
      const pathname = urlObj.pathname;
      if (!pathname.startsWith("/api/")) {
        onStart(404, "Not Found", {
          "Content-Type": "application/json"
        });
        onChunk(JSON.stringify({
          error: "Not found"
        }));
        onEnd();
        return;
      }
      const apiFile = resolveApiFile(this.pagesDir, pathname, this.routeCtx);
      if (!apiFile) {
        onStart(404, "Not Found", {
          "Content-Type": "application/json"
        });
        onChunk(JSON.stringify({
          error: "API route not found"
        }));
        onEnd();
        return;
      }
      try {
        const code2 = this.vfs.readFileSync(apiFile, "utf8");
        const transformed = await this.transformApiHandler(code2, apiFile);
        const req = createMockRequest(method, pathname, headers, body);
        const res = createStreamingMockResponse(onStart, onChunk, onEnd);
        const builtins = await createBuiltinModules(() => Promise.resolve().then(() => fs).then((m) => m.createFsShim(this.vfs)));
        await executeApiHandler(transformed, req, res, this.options.env, builtins);
        if (!res.isEnded()) {
          const timeout = new Promise((_10, reject) => {
            setTimeout(() => reject(new Error("API handler timeout")), 3e4);
          });
          await Promise.race([
            res.waitForEnd(),
            timeout
          ]);
        }
      } catch (error) {
        console.error("[NextDevServer] Streaming API error:", error);
        onStart(500, "Internal Server Error", {
          "Content-Type": "application/json"
        });
        onChunk(JSON.stringify({
          error: error instanceof Error ? error.message : "Internal Server Error"
        }));
        onEnd();
      }
    }
    async handlePageRoute(pathname, search) {
      if (this.useAppRouter) {
        return this.handleAppRouterPage(pathname, search);
      }
      const pageFile = resolvePageFile(this.pagesDir, pathname, this.routeCtx);
      if (!pageFile) {
        const notFoundPage = resolvePageFile(this.pagesDir, "/404", this.routeCtx);
        if (notFoundPage) {
          const html2 = await this.generatePageHtml(notFoundPage, "/404");
          return {
            statusCode: 404,
            statusMessage: "Not Found",
            headers: {
              "Content-Type": "text/html; charset=utf-8"
            },
            body: BufferPolyfill.from(html2)
          };
        }
        return this.serve404Page();
      }
      if (needsTransform(pathname)) {
        return this.transformAndServe(pageFile, pathname);
      }
      const html = await this.generatePageHtml(pageFile, pathname);
      const buffer2 = BufferPolyfill.from(html);
      return {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "Content-Type": "text/html; charset=utf-8",
          "Content-Length": String(buffer2.length),
          "Cache-Control": "no-cache"
        },
        body: buffer2
      };
    }
    async handleAppRouterPage(pathname, search) {
      const route = resolveAppRoute(this.appDir, pathname, this.routeCtx);
      if (!route) {
        const notFoundRoute = resolveAppRoute(this.appDir, "/not-found", this.routeCtx);
        if (notFoundRoute) {
          const html2 = await this.generateAppRouterHtml(notFoundRoute, "/not-found");
          return {
            statusCode: 404,
            statusMessage: "Not Found",
            headers: {
              "Content-Type": "text/html; charset=utf-8"
            },
            body: BufferPolyfill.from(html2)
          };
        }
        return this.serve404Page();
      }
      const html = await this.generateAppRouterHtml(route, pathname);
      const buffer2 = BufferPolyfill.from(html);
      return {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "Content-Type": "text/html; charset=utf-8",
          "Content-Length": String(buffer2.length),
          "Cache-Control": "no-cache"
        },
        body: buffer2
      };
    }
    htmlContext() {
      return {
        port: this.port,
        exists: (path22) => this.exists(path22),
        generateEnvScript: () => this.generateEnvScript(),
        loadTailwindConfigIfNeeded: () => this.loadTailwindConfigIfNeeded()
      };
    }
    async generateAppRouterHtml(route, pathname) {
      return generateAppRouterHtml(this.htmlContext(), route, pathname);
    }
    async generatePageHtml(pageFile, pathname) {
      return generatePageHtml(this.htmlContext());
    }
    serve404Page() {
      return serve404Page(this.port);
    }
    async transformAndServe(filePath, urlPath) {
      try {
        const content = this.vfs.readFileSync(filePath, "utf8");
        const hash = simpleHash(content);
        const cached = this.transformCache.get(filePath);
        if (cached && cached.hash === hash) {
          const buffer22 = BufferPolyfill.from(cached.code);
          return {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
              "Content-Type": "application/javascript; charset=utf-8",
              "Content-Length": String(buffer22.length),
              "Cache-Control": "no-cache",
              "X-Transformed": "true",
              "X-Cache": "hit"
            },
            body: buffer22
          };
        }
        const transformed = await this.transformCode(content, filePath);
        this.transformCache.set(filePath, {
          code: transformed,
          hash
        });
        if (this.transformCache.size > 500) {
          const firstKey = this.transformCache.keys().next().value;
          if (firstKey)
            this.transformCache.delete(firstKey);
        }
        const buffer2 = BufferPolyfill.from(transformed);
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "application/javascript; charset=utf-8",
            "Content-Length": String(buffer2.length),
            "Cache-Control": "no-cache",
            "X-Transformed": "true"
          },
          body: buffer2
        };
      } catch (error) {
        console.error("[NextDevServer] Transform error:", error);
        const message = error instanceof Error ? error.message : "Transform failed";
        const body = `// Transform Error: ${message}
console.error(${JSON.stringify(message)});`;
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "application/javascript; charset=utf-8",
            "X-Transform-Error": "true"
          },
          body: BufferPolyfill.from(body)
        };
      }
    }
    async transformCode(code2, filename2) {
      if (!isBrowser) {
        return this.stripCssImports(code2, filename2);
      }
      await initEsbuild();
      const esbuild2 = getEsbuild();
      if (!esbuild2) {
        throw new Error("esbuild not available");
      }
      const codeWithoutCssImports = this.stripCssImports(code2, filename2);
      const codeWithResolvedAliases = this.resolvePathAliases(codeWithoutCssImports, filename2);
      let loader = "js";
      if (filename2.endsWith(".jsx"))
        loader = "jsx";
      else if (filename2.endsWith(".tsx"))
        loader = "tsx";
      else if (filename2.endsWith(".ts"))
        loader = "ts";
      const result = await esbuild2.transform(codeWithResolvedAliases, {
        loader,
        format: "esm",
        target: "esnext",
        jsx: "automatic",
        jsxImportSource: "react",
        sourcemap: "inline",
        sourcefile: filename2
      });
      const codeWithCdnImports = this.redirectNpmImports(result.code);
      if (/\.(jsx|tsx)$/.test(filename2)) {
        return this.addReactRefresh(codeWithCdnImports, filename2);
      }
      return codeWithCdnImports;
    }
    redirectNpmImports(code2) {
      return redirectNpmImports(code2);
    }
    stripCssImports(code2, currentFile) {
      return stripCssImports(code2, currentFile, this.getCssModuleContext());
    }
    getCssModuleContext() {
      return {
        readFile: (path22) => this.vfs.readFileSync(path22, "utf-8"),
        exists: (path22) => this.exists(path22)
      };
    }
    async transformApiHandler(code2, filename2) {
      const codeWithResolvedAliases = this.resolvePathAliases(code2, filename2);
      if (isBrowser) {
        await initEsbuild();
        const esbuild2 = getEsbuild();
        if (!esbuild2) {
          throw new Error("esbuild not available");
        }
        let loader = "js";
        if (filename2.endsWith(".jsx"))
          loader = "jsx";
        else if (filename2.endsWith(".tsx"))
          loader = "tsx";
        else if (filename2.endsWith(".ts"))
          loader = "ts";
        const result = await esbuild2.transform(codeWithResolvedAliases, {
          loader,
          format: "cjs",
          target: "esnext",
          platform: "neutral",
          sourcefile: filename2
        });
        return result.code;
      }
      return transformEsmToCjsSimple(codeWithResolvedAliases);
    }
    addReactRefresh(code2, filename2) {
      return addReactRefresh(code2, filename2);
    }
    startWatching() {
      const watchers = [];
      try {
        const pagesWatcher = this.vfs.watch(this.pagesDir, {
          recursive: true
        }, (eventType, filename2) => {
          if (eventType === "change" && filename2) {
            const fullPath = filename2.startsWith("/") ? filename2 : `${this.pagesDir}/${filename2}`;
            this.handleFileChange(fullPath);
          }
        });
        watchers.push(pagesWatcher);
      } catch (error) {
        console.warn("[NextDevServer] Could not watch pages directory:", error);
      }
      if (this.useAppRouter) {
        try {
          const appWatcher = this.vfs.watch(this.appDir, {
            recursive: true
          }, (eventType, filename2) => {
            if (eventType === "change" && filename2) {
              const fullPath = filename2.startsWith("/") ? filename2 : `${this.appDir}/${filename2}`;
              this.handleFileChange(fullPath);
            }
          });
          watchers.push(appWatcher);
        } catch (error) {
          console.warn("[NextDevServer] Could not watch app directory:", error);
        }
      }
      try {
        const publicWatcher = this.vfs.watch(this.publicDir, {
          recursive: true
        }, (eventType, filename2) => {
          if (eventType === "change" && filename2) {
            this.handleFileChange(`${this.publicDir}/${filename2}`);
          }
        });
        watchers.push(publicWatcher);
      } catch {
      }
      this.watcherCleanup = () => {
        watchers.forEach((w) => w.close());
      };
    }
    handleFileChange(path22) {
      const isCSS = path22.endsWith(".css");
      const isJS = /\.(jsx?|tsx?)$/.test(path22);
      const updateType = isCSS || isJS ? "update" : "full-reload";
      const update = {
        type: updateType,
        path: path22,
        timestamp: Date.now()
      };
      this.emitHMRUpdate(update);
      if (this.hmrTargetWindow) {
        try {
          this.hmrTargetWindow.postMessage({
            ...update,
            channel: "next-hmr"
          }, "*");
        } catch (e11) {
        }
      }
    }
    serveFile(filePath) {
      if (filePath.endsWith(".json")) {
        try {
          const normalizedPath = this.resolvePath(filePath);
          const content = this.vfs.readFileSync(normalizedPath);
          let jsonContent;
          if (typeof content === "string") {
            jsonContent = content;
          } else if (content instanceof Uint8Array) {
            jsonContent = new TextDecoder("utf-8").decode(content);
          } else {
            jsonContent = BufferPolyfill.from(content).toString("utf-8");
          }
          const esModuleContent = `export default ${jsonContent};`;
          const buffer2 = BufferPolyfill.from(esModuleContent);
          return {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
              "Content-Type": "application/javascript; charset=utf-8",
              "Content-Length": String(buffer2.length),
              "Cache-Control": "no-cache"
            },
            body: buffer2
          };
        } catch (error) {
          if (error.code === "ENOENT") {
            return this.notFound(filePath);
          }
          return this.serverError(error);
        }
      }
      return super.serveFile(filePath);
    }
    resolvePath(urlPath) {
      let path22 = urlPath.split("?")[0].split("#")[0];
      if (!path22.startsWith("/")) {
        path22 = "/" + path22;
      }
      if (this.root !== "/") {
        path22 = this.root + path22;
      }
      return path22;
    }
    stop() {
      if (this.watcherCleanup) {
        this.watcherCleanup();
        this.watcherCleanup = null;
      }
      this.hmrTargetWindow = null;
      super.stop();
    }
  };
  PACKAGE_JSON = {
    name: "convex-app-demo",
    version: "0.1.0",
    private: true,
    scripts: {
      dev: "next dev",
      build: "next build",
      start: "next start"
    },
    dependencies: {
      "next": "^14.0.0",
      "react": "^18.2.0",
      "react-dom": "^18.2.0",
      "clsx": "^2.1.1",
      "tailwind-merge": "^3.1.0",
      "lucide-react": "^0.400.0",
      "zod": "^3.24.2",
      "date-fns": "^3.6.0"
    },
    devDependencies: {
      "@types/node": "^20",
      "@types/react": "^19",
      "@types/react-dom": "^19",
      "typescript": "^5.9.3"
    }
  };
  DEMO_PACKAGES = [
    "clsx",
    "tailwind-merge",
    "zod",
    "date-fns"
  ];
  createConvexAppProject = function(vfs2) {
    vfs2.writeFileSync("/package.json", JSON.stringify(PACKAGE_JSON, null, 2));
    vfs2.mkdirSync("/app", {
      recursive: true
    });
    vfs2.mkdirSync("/app/api", {
      recursive: true
    });
    vfs2.mkdirSync("/app/tasks", {
      recursive: true
    });
    vfs2.mkdirSync("/components", {
      recursive: true
    });
    vfs2.mkdirSync("/components/ui", {
      recursive: true
    });
    vfs2.mkdirSync("/lib", {
      recursive: true
    });
    vfs2.mkdirSync("/convex", {
      recursive: true
    });
    vfs2.mkdirSync("/public", {
      recursive: true
    });
    vfs2.writeFileSync("/convex.json", JSON.stringify({
      functions: "convex/"
    }, null, 2));
    vfs2.writeFileSync("/tsconfig.json", JSON.stringify({
      compilerOptions: {
        target: "es5",
        lib: [
          "dom",
          "dom.iterable",
          "esnext"
        ],
        allowJs: true,
        skipLibCheck: true,
        strict: true,
        noEmit: true,
        esModuleInterop: true,
        module: "esnext",
        moduleResolution: "bundler",
        resolveJsonModule: true,
        isolatedModules: true,
        jsx: "preserve",
        incremental: true,
        paths: {
          "@/*": [
            "./*"
          ]
        }
      },
      include: [
        "**/*.ts",
        "**/*.tsx"
      ],
      exclude: [
        "node_modules"
      ]
    }, null, 2));
    vfs2.writeFileSync("/tailwind.config.js", `/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [],
}
`);
    vfs2.writeFileSync("/app/globals.css", `@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
`);
    vfs2.writeFileSync("/lib/utils.ts", `// Utility functions
// Note: In production, use clsx and tailwind-merge packages

export function cn(...inputs: (string | undefined | null | false)[]) {
  return inputs.filter(Boolean).join(' ');
}
`);
    vfs2.writeFileSync("/convex/convex.config.ts", `import { defineApp } from "convex/server";

const app = defineApp();
export default app;
`);
    vfs2.writeFileSync("/convex/convex.config.js", `import { defineApp } from "convex/server";

const app = defineApp();
export default app;
`);
    vfs2.writeFileSync("/convex/schema.ts", `import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  todos: defineTable({
    title: v.string(),
    completed: v.boolean(),
    priority: v.union(v.literal("low"), v.literal("medium"), v.literal("high")),
  }),
});
`);
    vfs2.writeFileSync("/convex/todos.ts", `import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

export const list = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("todos").order("desc").collect();
  },
});

export const create = mutation({
  args: {
    title: v.string(),
    priority: v.union(v.literal("low"), v.literal("medium"), v.literal("high")),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("todos", {
      title: args.title,
      completed: false,
      priority: args.priority,
    });
  },
});

export const toggle = mutation({
  args: { id: v.id("todos") },
  handler: async (ctx, args) => {
    const todo = await ctx.db.get(args.id);
    if (!todo) throw new Error("Todo not found");
    await ctx.db.patch(args.id, { completed: !todo.completed });
  },
});

export const remove = mutation({
  args: { id: v.id("todos") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
  },
});
`);
    vfs2.writeFileSync("/convex/_generated/api.ts", `// Convex API - manually created for browser demo
// In a real project, this is auto-generated by 'npx convex dev'

// Function references for the Convex client
// These are string identifiers that map to server functions
export const api = {
  todos: {
    list: "todos:list",
    create: "todos:create",
    toggle: "todos:toggle",
    remove: "todos:remove",
  },
} as const;
`);
    vfs2.writeFileSync("/convex/_generated/server.ts", `// Server stubs for browser demo
// In a real project, this is auto-generated by Convex

export function query<Args, Output>(config: {
  args: Args;
  handler: (ctx: any, args: any) => Promise<Output>;
}) {
  return config;
}

export function mutation<Args, Output>(config: {
  args: Args;
  handler: (ctx: any, args: any) => Promise<Output>;
}) {
  return config;
}
`);
    vfs2.writeFileSync("/lib/convex.tsx", `"use client";

import React, { useState, useEffect } from 'react';
import { ConvexProvider as BaseConvexProvider, ConvexReactClient, useQuery as useConvexQuery, useMutation as useConvexMutation } from 'convex/react';

// Re-export the API
export { api } from '../convex/_generated/api.ts';

// Get Convex URL using standard Next.js env var pattern
// Falls back to window.__CONVEX_URL__ for backwards compatibility
const getConvexUrl = () => {
  // Standard Next.js pattern: process.env.NEXT_PUBLIC_*
  if (typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_CONVEX_URL) {
    return process.env.NEXT_PUBLIC_CONVEX_URL;
  }
  // Fallback for backwards compatibility
  if (typeof window !== 'undefined' && (window as any).__CONVEX_URL__) {
    return (window as any).__CONVEX_URL__;
  }
  return null;
};

// Create client lazily
let client: ConvexReactClient | null = null;

function getClient() {
  const url = getConvexUrl();
  if (!url) return null;
  if (!client || (client as any)._address !== url) {
    client = new ConvexReactClient(url);
  }
  return client;
}

// Wrapper hooks that handle the case when Convex is not connected
export function useQuery(query: any, ...args: any[]) {
  const url = getConvexUrl();
  // When not connected, return undefined
  if (!url) return undefined;
  return useConvexQuery(query, ...args);
}

export function useMutation(mutation: any) {
  const url = getConvexUrl();
  const convexMutation = url ? useConvexMutation(mutation) : null;

  return async (args: any) => {
    if (!convexMutation) {
      console.warn('Convex not connected - mutation ignored');
      return;
    }
    return convexMutation(args);
  };
}

export function ConvexProvider({ children }: { children: React.ReactNode }) {
  const [convexUrl, setConvexUrl] = useState(getConvexUrl());

  // Check for URL changes (after deploy)
  useEffect(() => {
    const checkUrl = () => {
      const url = getConvexUrl();
      if (url !== convexUrl) {
        setConvexUrl(url);
      }
    };

    // Check periodically for URL changes
    const interval = setInterval(checkUrl, 1000);
    return () => clearInterval(interval);
  }, [convexUrl]);

  const convexClient = getClient();

  if (!convexClient) {
    // Show a message when Convex is not configured
    return (
      <div className="min-h-screen bg-background font-sans antialiased">
        <div className="flex flex-col items-center justify-center min-h-screen p-8 text-center">
          <div className="max-w-md space-y-4">
            <h2 className="text-2xl font-bold">Connect to Convex</h2>
            <p className="text-muted-foreground">
              Enter your Convex deploy key in the console panel and click "Deploy Schema" to connect.
            </p>
            <div className="p-4 bg-muted rounded-lg text-left text-sm">
              <p className="font-medium mb-2">Files ready in /convex/:</p>
              <ul className="space-y-1 text-muted-foreground">
                <li>schema.ts - Database schema (todos table)</li>
                <li>todos.ts - Query and mutation functions</li>
              </ul>
            </div>
            <p className="text-xs text-muted-foreground">
              Get a deploy key from your Convex dashboard at convex.dev
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <BaseConvexProvider client={convexClient}>
      {children}
    </BaseConvexProvider>
  );
}
`);
    vfs2.writeFileSync("/components/ui/button.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

const buttonVariants = {
  default: "bg-primary text-primary-foreground hover:bg-primary/90",
  destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
  outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
  secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
  ghost: "hover:bg-accent hover:text-accent-foreground",
  link: "text-primary underline-offset-4 hover:underline",
};

const buttonSizes = {
  default: "h-10 px-4 py-2",
  sm: "h-9 rounded-md px-3",
  lg: "h-11 rounded-md px-8",
  icon: "h-10 w-10",
};

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: keyof typeof buttonVariants;
  size?: keyof typeof buttonSizes;
}

export function Button({
  className,
  variant = "default",
  size = "default",
  ...props
}: ButtonProps) {
  return (
    <button
      className={cn(
        "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
        buttonVariants[variant],
        buttonSizes[size],
        className
      )}
      {...props}
    />
  );
}
`);
    vfs2.writeFileSync("/components/ui/card.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

export function Card({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn(
        "rounded-lg border bg-card text-card-foreground shadow-sm",
        className
      )}
      {...props}
    />
  );
}

export function CardHeader({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("flex flex-col space-y-1.5 p-6", className)}
      {...props}
    />
  );
}

export function CardTitle({
  className,
  ...props
}: React.HTMLAttributes<HTMLHeadingElement>) {
  return (
    <h3
      className={cn("text-2xl font-semibold leading-none tracking-tight", className)}
      {...props}
    />
  );
}

export function CardDescription({
  className,
  ...props
}: React.HTMLAttributes<HTMLParagraphElement>) {
  return (
    <p
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  );
}

export function CardContent({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return <div className={cn("p-6 pt-0", className)} {...props} />;
}

export function CardFooter({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("flex items-center p-6 pt-0", className)}
      {...props}
    />
  );
}
`);
    vfs2.writeFileSync("/components/ui/input.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}

export function Input({ className, type, ...props }: InputProps) {
  return (
    <input
      type={type}
      className={cn(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  );
}
`);
    vfs2.writeFileSync("/components/ui/badge.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

const badgeVariants = {
  default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
  secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
  destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
  outline: "text-foreground",
  success: "border-transparent bg-green-500 text-white",
  warning: "border-transparent bg-yellow-500 text-white",
};

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: keyof typeof badgeVariants;
}

export function Badge({ className, variant = "default", ...props }: BadgeProps) {
  return (
    <div
      className={cn(
        "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
        badgeVariants[variant],
        className
      )}
      {...props}
    />
  );
}
`);
    vfs2.writeFileSync("/components/ui/checkbox.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

export interface CheckboxProps extends React.InputHTMLAttributes<HTMLInputElement> {
  onCheckedChange?: (checked: boolean) => void;
}

export function Checkbox({ className, checked, onCheckedChange, ...props }: CheckboxProps) {
  return (
    <input
      type="checkbox"
      checked={checked}
      onChange={(e) => onCheckedChange?.(e.target.checked)}
      className={cn(
        "h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        className
      )}
      {...props}
    />
  );
}
`);
    vfs2.writeFileSync("/components/ui/select.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

export interface SelectProps extends React.SelectHTMLAttributes<HTMLSelectElement> {}

export function Select({ className, children, ...props }: SelectProps) {
  return (
    <select
      className={cn(
        "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      {children}
    </select>
  );
}
`);
    vfs2.writeFileSync("/components/task-list.tsx", `"use client";

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from './ui/card.tsx';
import { Button } from './ui/button.tsx';
import { Input } from './ui/input.tsx';
import { Badge } from './ui/badge.tsx';
import { Checkbox } from './ui/checkbox.tsx';
import { Select } from './ui/select.tsx';
import { useQuery, useMutation, api } from '../lib/convex.tsx';
import { cn } from '../lib/utils.ts';

type Todo = {
  _id: string;
  _creationTime: number;
  title: string;
  completed: boolean;
  priority: "low" | "medium" | "high";
};

const priorityColors = {
  low: "success" as const,
  medium: "warning" as const,
  high: "destructive" as const,
};

function TaskItem({
  task,
  onToggle,
  onDelete
}: {
  task: Todo;
  onToggle: () => void;
  onDelete: () => void;
}) {
  return (
    <div className={cn(
      "flex items-center gap-4 p-4 border rounded-lg transition-all",
      task.completed && "opacity-50 bg-muted"
    )}>
      <Checkbox
        checked={task.completed}
        onCheckedChange={onToggle}
      />
      <div className="flex-1 min-w-0">
        <p className={cn(
          "font-medium truncate",
          task.completed && "line-through text-muted-foreground"
        )}>
          {task.title}
        </p>
        <p className="text-xs text-muted-foreground">
          Created {new Date(task._creationTime).toLocaleDateString()}
        </p>
      </div>
      <Badge variant={priorityColors[task.priority]}>
        {task.priority}
      </Badge>
      <Button
        variant="ghost"
        size="sm"
        onClick={onDelete}
        className="text-destructive hover:text-destructive"
      >
        Delete
      </Button>
    </div>
  );
}

export function TaskList() {
  const todos = useQuery(api.todos.list) as Todo[] | undefined;
  const createTodo = useMutation(api.todos.create);
  const toggleTodo = useMutation(api.todos.toggle);
  const removeTodo = useMutation(api.todos.remove);

  const [newTitle, setNewTitle] = React.useState("");
  const [priority, setPriority] = React.useState<Todo["priority"]>("medium");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newTitle.trim()) return;

    await createTodo({ title: newTitle.trim(), priority });
    setNewTitle("");
  };

  const completedCount = todos?.filter(t => t.completed).length ?? 0;
  const totalCount = todos?.length ?? 0;

  return (
    <Card className="w-full max-w-2xl mx-auto">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          Task Manager
          <Badge variant="secondary">
            {completedCount}/{totalCount} done
          </Badge>
        </CardTitle>
        <CardDescription>
          Real-time sync powered by Convex - running from the browser!
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <form onSubmit={handleSubmit} className="flex gap-2">
          <Input
            placeholder="Add a new task..."
            value={newTitle}
            onChange={(e) => setNewTitle(e.target.value)}
            className="flex-1"
          />
          <Select
            value={priority}
            onChange={(e) => setPriority(e.target.value as Todo["priority"])}
            className="w-32"
          >
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
          </Select>
          <Button type="submit">Add Task</Button>
        </form>

        <div className="space-y-2">
          {todos === undefined ? (
            <div className="text-center py-8 text-muted-foreground">
              Loading tasks...
            </div>
          ) : todos.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              No tasks yet. Add one above!
            </div>
          ) : (
            todos.map((task) => (
              <TaskItem
                key={task._id}
                task={task}
                onToggle={() => toggleTodo({ id: task._id })}
                onDelete={() => removeTodo({ id: task._id })}
              />
            ))
          )}
        </div>
      </CardContent>
    </Card>
  );
}
`);
    vfs2.writeFileSync("/app/layout.tsx", `import React from 'react';
import './globals.css';
import { ConvexProvider } from '../lib/convex.tsx';

export const metadata = {
  title: 'Convex App Demo',
  description: 'A realistic Next.js + Convex app running in the browser',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <ConvexProvider>
      <div className="min-h-screen bg-background font-sans antialiased">
        <div className="relative flex min-h-screen flex-col">
          <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
            <div className="container flex h-14 items-center">
              <div className="mr-4 flex">
                <a href="/" className="mr-6 flex items-center space-x-2">
                  <span className="font-bold text-xl">TaskApp</span>
                </a>
                <nav className="flex items-center space-x-6 text-sm font-medium">
                  <a href="/" className="transition-colors hover:text-foreground/80 text-foreground">
                    Home
                  </a>
                  <a href="/tasks" className="transition-colors hover:text-foreground/80 text-muted-foreground">
                    Tasks
                  </a>
                  <a href="/about" className="transition-colors hover:text-foreground/80 text-muted-foreground">
                    About
                  </a>
                </nav>
              </div>
            </div>
          </header>
          <main className="flex-1">
            {children}
          </main>
          <footer className="border-t py-6 md:py-0">
            <div className="container flex flex-col items-center justify-between gap-4 md:h-14 md:flex-row">
              <p className="text-center text-sm leading-loose text-muted-foreground">
                Running in browser with virtual Node.js
              </p>
            </div>
          </footer>
        </div>
      </div>
    </ConvexProvider>
  );
}
`);
    vfs2.writeFileSync("/app/page.tsx", `"use client";

import React from 'react';
import { TaskList } from '../components/task-list.tsx';

export default function HomePage() {
  return (
    <div className="container py-10">
      <div className="mb-8 text-center">
        <h1 className="text-3xl font-bold tracking-tight">Task Manager</h1>
        <p className="text-muted-foreground mt-2">
          Real-time sync powered by Convex - running in the browser!
        </p>
      </div>
      <TaskList />
    </div>
  );
}
`);
    vfs2.writeFileSync("/app/features/page.tsx", `import React from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../../components/ui/card.tsx';
import { Button } from '../../components/ui/button.tsx';
import { Badge } from '../../components/ui/badge.tsx';

export default function FeaturesPage() {
  return (
    <div className="container py-10">
      {/* Feature Cards */}
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u26A1 React 18
            </CardTitle>
            <CardDescription>
              Latest React with Concurrent features
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Using React 18 with automatic batching, Suspense,
              and concurrent rendering for optimal performance.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u{1F3A8} shadcn/ui
            </CardTitle>
            <CardDescription>
              Beautiful, accessible components
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Beautifully designed components built with Radix UI
              primitives and Tailwind CSS.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u{1F504} Convex (Mock)
            </CardTitle>
            <CardDescription>
              Real-time data sync simulation
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Demonstrates the Convex pattern with useQuery and
              useMutation hooks using mock data.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u{1F3AF} TypeScript
            </CardTitle>
            <CardDescription>
              Full type safety
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Written in TypeScript with strict mode enabled
              for maximum type safety and developer experience.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u{1F4F1} Responsive
            </CardTitle>
            <CardDescription>
              Mobile-first design
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Fully responsive design that works great on any device,
              from mobile phones to desktop monitors.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u{1F310} Browser Runtime
            </CardTitle>
            <CardDescription>
              No server required
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Running entirely in the browser using virtual Node.js
              shims and Service Workers.
            </p>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
`);
    vfs2.mkdirSync("/app/features", {
      recursive: true
    });
    vfs2.writeFileSync("/app/tasks/page.tsx", `"use client";

import React from 'react';
import { TaskList } from '../../components/task-list.tsx';

export default function TasksPage() {
  return (
    <div className="container py-10">
      <div className="mb-8 text-center">
        <h1 className="text-3xl font-bold tracking-tight">Task Manager</h1>
        <p className="text-muted-foreground mt-2">
          Add, complete, and manage your tasks
        </p>
      </div>
      <TaskList />
    </div>
  );
}
`);
    vfs2.writeFileSync("/app/about/page.tsx", `import React from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../../components/ui/card.tsx';
import { Badge } from '../../components/ui/badge.tsx';

export default function AboutPage() {
  return (
    <div className="container py-10 max-w-3xl">
      <div className="mb-8">
        <Badge variant="outline" className="mb-4">About</Badge>
        <h1 className="text-3xl font-bold tracking-tight">How It Works</h1>
        <p className="text-muted-foreground mt-2">
          This demo showcases running a complex Next.js application entirely in the browser.
        </p>
      </div>

      <div className="space-y-6">
        <Card>
          <CardHeader>
            <CardTitle>Virtual File System</CardTitle>
            <CardDescription>In-memory file system simulation</CardDescription>
          </CardHeader>
          <CardContent className="prose prose-sm">
            <p>
              All project files exist in a virtual file system (VFS) in memory.
              This includes React components, configuration files, and even
              npm package contents.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Node.js Shims</CardTitle>
            <CardDescription>Browser-compatible Node.js APIs</CardDescription>
          </CardHeader>
          <CardContent className="prose prose-sm">
            <p>
              Core Node.js modules like <code>fs</code>, <code>path</code>, <code>crypto</code>,
              <code>stream</code>, and <code>http</code> are shimmed to work in the browser
              using Web APIs.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>esbuild-wasm</CardTitle>
            <CardDescription>Fast JSX/TypeScript compilation</CardDescription>
          </CardHeader>
          <CardContent className="prose prose-sm">
            <p>
              JSX and TypeScript files are transformed to JavaScript in real-time
              using esbuild-wasm, which runs WebAssembly in the browser.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Service Worker</CardTitle>
            <CardDescription>Request interception and routing</CardDescription>
          </CardHeader>
          <CardContent className="prose prose-sm">
            <p>
              A Service Worker intercepts HTTP requests and routes them to the
              virtual dev server, enabling file-based routing without a real backend.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Convex Mock</CardTitle>
            <CardDescription>Simulated real-time database</CardDescription>
          </CardHeader>
          <CardContent className="prose prose-sm">
            <p>
              The Convex client is mocked to demonstrate the pattern of using
              <code>useQuery</code> and <code>useMutation</code> hooks. In production,
              this would connect to a real Convex backend.
            </p>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
`);
    vfs2.writeFileSync("/pages/api/health.js", `export default function handler(req, res) {
  res.status(200).json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    runtime: 'browser-node-shim'
  });
}
`);
    vfs2.writeFileSync("/public/favicon.ico", "favicon placeholder");
    vfs2.writeFileSync("/public/robots.txt", "User-agent: *\nAllow: /");
  };
  initConvexAppDemo = async function(outputElement, options2 = {}) {
    const log = (message) => {
      const line = document.createElement("div");
      line.textContent = `[${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`;
      outputElement.appendChild(line);
      outputElement.scrollTop = outputElement.scrollHeight;
    };
    log("Creating virtual file system...");
    const vfs2 = new VirtualFS();
    log("Creating Convex App project structure...");
    createConvexAppProject(vfs2);
    if (options2.installPackages) {
      log("Installing npm packages (this may take a while)...");
      const npm = new PackageManager(vfs2);
      for (const pkg of DEMO_PACKAGES) {
        try {
          log(`Installing ${pkg}...`);
          await npm.install(pkg, {
            onProgress: (msg) => log(`  ${msg}`)
          });
        } catch (error) {
          log(`Warning: Failed to install ${pkg}: ${error}`);
        }
      }
    }
    log("Initializing runtime...");
    const runtime = new Runtime(vfs2, {
      cwd: "/",
      env: {
        NODE_ENV: "development"
      },
      onConsole: (method, args) => {
        const prefix = method === "error" ? "[ERROR]" : method === "warn" ? "[WARN]" : "";
        log(`${prefix} ${args.map((a) => String(a)).join(" ")}`);
      }
    });
    log("Setting up file watcher...");
    vfs2.watch("/app", {
      recursive: true
    }, (eventType, filename2) => {
      log(`File ${eventType}: ${filename2}`);
    });
    log("Convex App demo initialized!");
    log("");
    log("Project structure:");
    listFiles(vfs2, "/", log, "  ");
    return {
      vfs: vfs2,
      runtime
    };
  };
  startConvexAppDevServer = async function(vfs2, options2 = {}) {
    const port = options2.port || 3002;
    const log = options2.log || console.log;
    log("Starting Convex App dev server...");
    const server = new NextDevServer(vfs2, {
      port,
      root: "/",
      preferAppRouter: true
    });
    const bridge = getServerBridge();
    try {
      log("Initializing Service Worker...");
      await bridge.initServiceWorker();
      log("Service Worker ready");
    } catch (error) {
      log(`Warning: Service Worker failed to initialize: ${error}`);
      log("Falling back to direct request handling...");
    }
    bridge.on("server-ready", (p, u) => {
      log(`Server ready at ${u}`);
    });
    const httpServer = createHttpServerWrapper(server);
    bridge.registerServer(httpServer, port);
    server.start();
    log("File watcher started");
    server.on("hmr-update", (update) => {
      log(`HMR update: ${JSON.stringify(update)}`);
    });
    const url2 = bridge.getServerUrl(port);
    log(`Convex App dev server running at: ${url2}/`);
    return {
      server,
      url: url2 + "/",
      stop: () => {
        server.stop();
        bridge.unregisterServer(port);
      }
    };
  };
  function createHttpServerWrapper(devServer) {
    return {
      listening: true,
      address: () => ({
        port: devServer.getPort(),
        address: "0.0.0.0",
        family: "IPv4"
      }),
      async handleRequest(method, url2, headers, body) {
        const bodyBuffer = body ? typeof body === "string" ? BufferPolyfill.from(body) : body : void 0;
        return devServer.handleRequest(method, url2, headers, bodyBuffer);
      }
    };
  }
  function listFiles(vfs2, path22, log, indent) {
    try {
      const entries = vfs2.readdirSync(path22);
      for (const entry of entries) {
        if (entry === "node_modules") {
          log(`${indent}${entry}/ (skipped)`);
          continue;
        }
        const fullPath = path22 === "/" ? `/${entry}` : `${path22}/${entry}`;
        try {
          const stat = vfs2.statSync(fullPath);
          if (stat.isDirectory()) {
            log(`${indent}${entry}/`);
            listFiles(vfs2, fullPath, log, indent + "  ");
          } else {
            log(`${indent}${entry}`);
          }
        } catch {
          log(`${indent}${entry}`);
        }
      }
    } catch {
    }
  }
  createContainer = function(options2) {
    const vfs2 = new VirtualFS();
    const runtime = new Runtime(vfs2, options2);
    const npmManager = new PackageManager(vfs2);
    const serverBridge = getServerBridge({
      baseUrl: options2 == null ? void 0 : options2.baseUrl,
      onServerReady: options2 == null ? void 0 : options2.onServerReady
    });
    return {
      vfs: vfs2,
      runtime,
      npm: npmManager,
      serverBridge,
      execute: (code2, filename2) => runtime.execute(code2, filename2),
      runFile: (filename2) => runtime.runFile(filename2),
      createREPL: () => runtime.createREPL(),
      on: (event, listener) => {
        serverBridge.on(event, listener);
      }
    };
  };
})();
export {
  VirtualFS,
  ViteDevServer,
  getServerBridge
};
/*! Bundled license information:

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)

just-bash/dist/bundle/browser.js:
  (*! Bundled license information:
  
  re2js/build/index.esm.js:
    (*!
     * re2js
     * RE2JS is the JavaScript port of RE2, a regular expression engine that provides linear time matching
     *
     * @version v1.2.1
     * @author Alexey Vasiliev
     * @homepage https://github.com/le0pard/re2js#readme
     * @repository github:le0pard/re2js
     * @license MIT
     *)
  
  ieee754/index.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  *)

comlink/dist/esm/comlink.mjs:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
import pako from "pako";
import { defineCommand, Bash } from "just-bash";
import { resolve as resolve$3 } from "resolve.exports";
import { wrap, proxy } from "comlink";
let DEMO_PACKAGES, PACKAGE_JSON, DevServer, NextDevServer, PackageManager, Runtime, SANDBOX_SETUP_INSTRUCTIONS, SandboxRuntime, ServerBridge, VirtualFS, ViteDevServer, WorkerRuntime, assert$1, chokidarShim, createContainer, createConvexAppProject, createFsShim, createProcess, createRuntime, esbuildShim, events$1, execute, fseventsShim, generateSandboxFiles, getSandboxHtml, getSandboxVercelConfig, getServerBridge, httpShim, initConvexAppDemo, install, moduleShim, netShim, index, pathShim, perfHooksShim, querystringShim, readdirpShim, resetServerBridge, rollupShim, startConvexAppDevServer, stream, urlShim, utilShim, workerThreadsShim, wsShim;
let __tla = (async () => {
  var _a, _b, _c;
  const CHUNK = 8192;
  function uint8ToBase64(bytes) {
    const parts = [];
    for (let i2 = 0; i2 < bytes.length; i2 += CHUNK) {
      parts.push(String.fromCharCode.apply(null, Array.from(bytes.subarray(i2, i2 + CHUNK))));
    }
    return btoa(parts.join(""));
  }
  function base64ToUint8(base642) {
    const binary = atob(base642);
    const bytes = new Uint8Array(binary.length);
    for (let i2 = 0; i2 < binary.length; i2++) {
      bytes[i2] = binary.charCodeAt(i2);
    }
    return bytes;
  }
  function uint8ToHex(bytes) {
    const hex = new Array(bytes.length);
    for (let i2 = 0; i2 < bytes.length; i2++) {
      hex[i2] = bytes[i2].toString(16).padStart(2, "0");
    }
    return hex.join("");
  }
  function uint8ToBinaryString(bytes) {
    const parts = [];
    for (let i2 = 0; i2 < bytes.length; i2 += CHUNK) {
      parts.push(String.fromCharCode.apply(null, Array.from(bytes.subarray(i2, i2 + CHUNK))));
    }
    return parts.join("");
  }
  function createNodeError(code2, syscall, path2, message) {
    const errno = {
      ENOENT: -2,
      ENOTDIR: -20,
      EISDIR: -21,
      EEXIST: -17,
      ENOTEMPTY: -39
    };
    const messages = {
      ENOENT: "no such file or directory",
      ENOTDIR: "not a directory",
      EISDIR: "is a directory",
      EEXIST: "file already exists",
      ENOTEMPTY: "directory not empty"
    };
    const err = new Error(`${code2}: ${messages[code2]}, ${syscall} '${path2}'`);
    err.code = code2;
    err.errno = errno[code2];
    err.syscall = syscall;
    err.path = path2;
    return err;
  }
  VirtualFS = class {
    constructor() {
      __publicField(this, "root");
      __publicField(this, "encoder", new TextEncoder());
      __publicField(this, "decoder", new TextDecoder());
      __publicField(this, "watchers", /* @__PURE__ */ new Map());
      __publicField(this, "eventListeners", /* @__PURE__ */ new Map());
      this.root = {
        type: "directory",
        children: /* @__PURE__ */ new Map(),
        mtime: Date.now()
      };
    }
    on(event, listener) {
      if (!this.eventListeners.has(event)) {
        this.eventListeners.set(event, /* @__PURE__ */ new Set());
      }
      this.eventListeners.get(event).add(listener);
      return this;
    }
    off(event, listener) {
      const listeners = this.eventListeners.get(event);
      if (listeners) {
        listeners.delete(listener);
      }
      return this;
    }
    emit(event, ...args) {
      const listeners = this.eventListeners.get(event);
      if (listeners) {
        for (const listener of listeners) {
          try {
            listener(...args);
          } catch (err) {
            console.error("Error in VFS event listener:", err);
          }
        }
      }
    }
    toSnapshot() {
      const files = [];
      this.serializeNode("/", this.root, files);
      return {
        files
      };
    }
    serializeNode(path2, node2, files) {
      if (node2.type === "file") {
        let content = "";
        if (node2.content && node2.content.length > 0) {
          content = uint8ToBase64(node2.content);
        }
        files.push({
          path: path2,
          type: "file",
          content
        });
      } else if (node2.type === "directory") {
        files.push({
          path: path2,
          type: "directory"
        });
        if (node2.children) {
          for (const [name2, child] of node2.children) {
            const childPath = path2 === "/" ? `/${name2}` : `${path2}/${name2}`;
            this.serializeNode(childPath, child, files);
          }
        }
      }
    }
    static fromSnapshot(snapshot) {
      const vfs2 = new VirtualFS();
      const sortedFiles = snapshot.files.map((entry, i2) => ({
        entry,
        depth: entry.path.split("/").length,
        i: i2
      })).sort((a, b) => a.depth - b.depth || a.i - b.i).map((x) => x.entry);
      for (const entry of sortedFiles) {
        if (entry.path === "/") continue;
        if (entry.type === "directory") {
          vfs2.mkdirSync(entry.path, {
            recursive: true
          });
        } else if (entry.type === "file") {
          let content;
          if (entry.content) {
            content = base64ToUint8(entry.content);
          } else {
            content = new Uint8Array(0);
          }
          const parentPath = entry.path.substring(0, entry.path.lastIndexOf("/")) || "/";
          if (parentPath !== "/" && !vfs2.existsSync(parentPath)) {
            vfs2.mkdirSync(parentPath, {
              recursive: true
            });
          }
          vfs2.writeFileSyncInternal(entry.path, content, false);
        }
      }
      return vfs2;
    }
    writeFileSyncInternal(path2, data2, emitEvent) {
      const normalized = this.normalizePath(path2);
      const parentPath = this.getParentPath(normalized);
      const basename2 = this.getBasename(normalized);
      if (!basename2) {
        throw new Error(`EISDIR: illegal operation on a directory, '${path2}'`);
      }
      const parent = this.ensureDirectory(parentPath);
      const existed = parent.children.has(basename2);
      const content = typeof data2 === "string" ? this.encoder.encode(data2) : data2;
      parent.children.set(basename2, {
        type: "file",
        content,
        mtime: Date.now()
      });
      if (emitEvent) {
        this.notifyWatchers(normalized, existed ? "change" : "rename");
        this.emit("change", normalized, typeof data2 === "string" ? data2 : this.decoder.decode(data2));
      }
    }
    normalizePath(path2) {
      if (!path2.startsWith("/")) {
        path2 = "/" + path2;
      }
      const parts = path2.split("/").filter(Boolean);
      const resolved = [];
      for (const part of parts) {
        if (part === "..") {
          resolved.pop();
        } else if (part !== ".") {
          resolved.push(part);
        }
      }
      return "/" + resolved.join("/");
    }
    getPathSegments(path2) {
      return this.normalizePath(path2).split("/").filter(Boolean);
    }
    getParentPath(path2) {
      const normalized = this.normalizePath(path2);
      const lastSlash = normalized.lastIndexOf("/");
      return lastSlash <= 0 ? "/" : normalized.slice(0, lastSlash);
    }
    getBasename(path2) {
      const normalized = this.normalizePath(path2);
      const lastSlash = normalized.lastIndexOf("/");
      return normalized.slice(lastSlash + 1);
    }
    getNode(path2) {
      const segments = this.getPathSegments(path2);
      let current = this.root;
      for (const segment of segments) {
        if (current.type !== "directory" || !current.children) {
          return void 0;
        }
        const child = current.children.get(segment);
        if (!child) {
          return void 0;
        }
        current = child;
      }
      return current;
    }
    ensureDirectory(path2) {
      const segments = this.getPathSegments(path2);
      let current = this.root;
      for (const segment of segments) {
        if (!current.children) {
          current.children = /* @__PURE__ */ new Map();
        }
        let child = current.children.get(segment);
        if (!child) {
          child = {
            type: "directory",
            children: /* @__PURE__ */ new Map(),
            mtime: Date.now()
          };
          current.children.set(segment, child);
        } else if (child.type !== "directory") {
          throw new Error(`ENOTDIR: not a directory, '${path2}'`);
        }
        current = child;
      }
      return current;
    }
    existsSync(path2) {
      return this.getNode(path2) !== void 0;
    }
    statSync(path2) {
      var _a2;
      const node2 = this.getNode(path2);
      if (!node2) {
        throw createNodeError("ENOENT", "stat", path2);
      }
      const size = node2.type === "file" ? ((_a2 = node2.content) == null ? void 0 : _a2.length) || 0 : 0;
      const mtime = node2.mtime;
      return {
        isFile: () => node2.type === "file",
        isDirectory: () => node2.type === "directory",
        isSymbolicLink: () => false,
        isBlockDevice: () => false,
        isCharacterDevice: () => false,
        isFIFO: () => false,
        isSocket: () => false,
        size,
        mode: node2.type === "directory" ? 493 : 420,
        mtime: new Date(mtime),
        atime: new Date(mtime),
        ctime: new Date(mtime),
        birthtime: new Date(mtime),
        mtimeMs: mtime,
        atimeMs: mtime,
        ctimeMs: mtime,
        birthtimeMs: mtime,
        nlink: 1,
        uid: 1e3,
        gid: 1e3,
        dev: 0,
        ino: 0,
        rdev: 0,
        blksize: 4096,
        blocks: Math.ceil(size / 512)
      };
    }
    lstatSync(path2) {
      return this.statSync(path2);
    }
    readFileSync(path2, encoding) {
      const node2 = this.getNode(path2);
      if (!node2) {
        throw createNodeError("ENOENT", "open", path2);
      }
      if (node2.type !== "file") {
        throw createNodeError("EISDIR", "read", path2);
      }
      const content = node2.content || new Uint8Array(0);
      if (encoding === "utf8" || encoding === "utf-8") {
        return this.decoder.decode(content);
      }
      return content;
    }
    writeFileSync(path2, data2) {
      this.writeFileSyncInternal(path2, data2, true);
    }
    mkdirSync(path2, options2) {
      const normalized = this.normalizePath(path2);
      if (options2 == null ? void 0 : options2.recursive) {
        this.ensureDirectory(normalized);
        return;
      }
      const parentPath = this.getParentPath(normalized);
      const basename2 = this.getBasename(normalized);
      if (!basename2) {
        return;
      }
      const parent = this.getNode(parentPath);
      if (!parent) {
        throw createNodeError("ENOENT", "mkdir", parentPath);
      }
      if (parent.type !== "directory") {
        throw createNodeError("ENOTDIR", "mkdir", parentPath);
      }
      if (parent.children.has(basename2)) {
        throw createNodeError("EEXIST", "mkdir", path2);
      }
      parent.children.set(basename2, {
        type: "directory",
        children: /* @__PURE__ */ new Map(),
        mtime: Date.now()
      });
    }
    readdirSync(path2) {
      const node2 = this.getNode(path2);
      if (!node2) {
        throw createNodeError("ENOENT", "scandir", path2);
      }
      if (node2.type !== "directory") {
        throw createNodeError("ENOTDIR", "scandir", path2);
      }
      return Array.from(node2.children.keys());
    }
    unlinkSync(path2) {
      const normalized = this.normalizePath(path2);
      const parentPath = this.getParentPath(normalized);
      const basename2 = this.getBasename(normalized);
      const parent = this.getNode(parentPath);
      if (!parent || parent.type !== "directory") {
        throw createNodeError("ENOENT", "unlink", path2);
      }
      const node2 = parent.children.get(basename2);
      if (!node2) {
        throw createNodeError("ENOENT", "unlink", path2);
      }
      if (node2.type !== "file") {
        throw createNodeError("EISDIR", "unlink", path2);
      }
      parent.children.delete(basename2);
      this.notifyWatchers(normalized, "rename");
      this.emit("delete", normalized);
    }
    rmdirSync(path2) {
      const normalized = this.normalizePath(path2);
      const parentPath = this.getParentPath(normalized);
      const basename2 = this.getBasename(normalized);
      if (!basename2) {
        throw new Error(`EPERM: operation not permitted, '${path2}'`);
      }
      const parent = this.getNode(parentPath);
      if (!parent || parent.type !== "directory") {
        throw createNodeError("ENOENT", "rmdir", path2);
      }
      const node2 = parent.children.get(basename2);
      if (!node2) {
        throw createNodeError("ENOENT", "rmdir", path2);
      }
      if (node2.type !== "directory") {
        throw createNodeError("ENOTDIR", "rmdir", path2);
      }
      if (node2.children.size > 0) {
        throw createNodeError("ENOTEMPTY", "rmdir", path2);
      }
      parent.children.delete(basename2);
    }
    renameSync(oldPath, newPath) {
      const normalizedOld = this.normalizePath(oldPath);
      const normalizedNew = this.normalizePath(newPath);
      const oldParentPath = this.getParentPath(normalizedOld);
      const oldBasename = this.getBasename(normalizedOld);
      const newParentPath = this.getParentPath(normalizedNew);
      const newBasename = this.getBasename(normalizedNew);
      const oldParent = this.getNode(oldParentPath);
      if (!oldParent || oldParent.type !== "directory") {
        throw createNodeError("ENOENT", "rename", oldPath);
      }
      const node2 = oldParent.children.get(oldBasename);
      if (!node2) {
        throw createNodeError("ENOENT", "rename", oldPath);
      }
      const newParent = this.ensureDirectory(newParentPath);
      oldParent.children.delete(oldBasename);
      newParent.children.set(newBasename, node2);
      this.notifyWatchers(normalizedOld, "rename");
      this.notifyWatchers(normalizedNew, "rename");
    }
    readFile(path2, optionsOrCallback, callback) {
      const actualCallback = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
      const options2 = typeof optionsOrCallback === "object" ? optionsOrCallback : void 0;
      try {
        const data2 = (options2 == null ? void 0 : options2.encoding) ? this.readFileSync(path2, options2.encoding) : this.readFileSync(path2);
        if (actualCallback) {
          setTimeout(() => actualCallback(null, data2), 0);
        }
      } catch (err) {
        if (actualCallback) {
          setTimeout(() => actualCallback(err), 0);
        }
      }
    }
    stat(path2, callback) {
      try {
        const stats = this.statSync(path2);
        setTimeout(() => callback(null, stats), 0);
      } catch (err) {
        setTimeout(() => callback(err), 0);
      }
    }
    lstat(path2, callback) {
      this.stat(path2, callback);
    }
    readdir(path2, optionsOrCallback, callback) {
      const actualCallback = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
      try {
        const files = this.readdirSync(path2);
        if (actualCallback) {
          setTimeout(() => actualCallback(null, files), 0);
        }
      } catch (err) {
        if (actualCallback) {
          setTimeout(() => actualCallback(err), 0);
        }
      }
    }
    realpath(path2, callback) {
      try {
        const resolved = this.realpathSync(path2);
        setTimeout(() => callback(null, resolved), 0);
      } catch (err) {
        setTimeout(() => callback(err), 0);
      }
    }
    realpathSync(path2) {
      const normalized = this.normalizePath(path2);
      if (!this.existsSync(normalized)) {
        throw createNodeError("ENOENT", "realpath", path2);
      }
      return normalized;
    }
    watch(filename2, optionsOrListener, listener) {
      const normalized = this.normalizePath(filename2);
      let options2 = {};
      let actualListener;
      if (typeof optionsOrListener === "function") {
        actualListener = optionsOrListener;
      } else if (optionsOrListener) {
        options2 = optionsOrListener;
        actualListener = listener;
      } else {
        actualListener = listener;
      }
      const entry = {
        listener: actualListener || (() => {
        }),
        recursive: options2.recursive || false,
        closed: false
      };
      if (!this.watchers.has(normalized)) {
        this.watchers.set(normalized, /* @__PURE__ */ new Set());
      }
      this.watchers.get(normalized).add(entry);
      const watcher = {
        close: () => {
          entry.closed = true;
          const watcherSet = this.watchers.get(normalized);
          if (watcherSet) {
            watcherSet.delete(entry);
            if (watcherSet.size === 0) {
              this.watchers.delete(normalized);
            }
          }
        },
        ref: () => watcher,
        unref: () => watcher
      };
      return watcher;
    }
    notifyWatchers(path2, eventType) {
      const normalized = this.normalizePath(path2);
      const basename2 = this.getBasename(normalized);
      const directWatchers = this.watchers.get(normalized);
      if (directWatchers) {
        for (const entry of directWatchers) {
          if (!entry.closed) {
            try {
              entry.listener(eventType, basename2);
            } catch (err) {
              console.error("Error in file watcher:", err);
            }
          }
        }
      }
      let currentPath = this.getParentPath(normalized);
      let relativePath = basename2;
      while (currentPath) {
        const parentWatchers = this.watchers.get(currentPath);
        if (parentWatchers) {
          for (const entry of parentWatchers) {
            if (!entry.closed) {
              const isDirectChild = this.getParentPath(normalized) === currentPath;
              if (entry.recursive || isDirectChild) {
                try {
                  entry.listener(eventType, relativePath);
                } catch (err) {
                  console.error("Error in file watcher:", err);
                }
              }
            }
          }
        }
        if (currentPath === "/") break;
        relativePath = this.getBasename(currentPath) + "/" + relativePath;
        currentPath = this.getParentPath(currentPath);
      }
    }
    accessSync(path2, mode) {
      if (!this.existsSync(path2)) {
        throw createNodeError("ENOENT", "access", path2);
      }
    }
    access(path2, modeOrCallback, callback) {
      const actualCallback = typeof modeOrCallback === "function" ? modeOrCallback : callback;
      try {
        this.accessSync(path2);
        if (actualCallback) setTimeout(() => actualCallback(null), 0);
      } catch (err) {
        if (actualCallback) setTimeout(() => actualCallback(err), 0);
      }
    }
    copyFileSync(src, dest) {
      const content = this.readFileSync(src);
      this.writeFileSync(dest, content);
    }
    createReadStream(path2) {
      const self = this;
      const listeners = {};
      const stream2 = {
        on(event, cb) {
          if (!listeners[event]) listeners[event] = [];
          listeners[event].push(cb);
          return stream2;
        },
        pipe(dest) {
          return dest;
        }
      };
      setTimeout(() => {
        var _a2, _b2, _c2;
        try {
          const data2 = self.readFileSync(path2);
          (_a2 = listeners["data"]) == null ? void 0 : _a2.forEach((cb) => cb(data2));
          (_b2 = listeners["end"]) == null ? void 0 : _b2.forEach((cb) => cb());
        } catch (err) {
          (_c2 = listeners["error"]) == null ? void 0 : _c2.forEach((cb) => cb(err));
        }
      }, 0);
      return stream2;
    }
    createWriteStream(path2) {
      const self = this;
      const chunks = [];
      const listeners = {};
      const encoder = new TextEncoder();
      return {
        write(data2) {
          const chunk = typeof data2 === "string" ? encoder.encode(data2) : data2;
          chunks.push(chunk);
          return true;
        },
        end(data2) {
          var _a2, _b2;
          if (data2) {
            const chunk = typeof data2 === "string" ? encoder.encode(data2) : data2;
            chunks.push(chunk);
          }
          const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
          const combined = new Uint8Array(totalLength);
          let offset = 0;
          for (const chunk of chunks) {
            combined.set(chunk, offset);
            offset += chunk.length;
          }
          self.writeFileSync(path2, combined);
          (_a2 = listeners["finish"]) == null ? void 0 : _a2.forEach((cb) => cb());
          (_b2 = listeners["close"]) == null ? void 0 : _b2.forEach((cb) => cb());
        },
        on(event, cb) {
          if (!listeners[event]) listeners[event] = [];
          listeners[event].push(cb);
          return this;
        }
      };
    }
  };
  function simpleHash(str) {
    let hash = 0;
    for (let i2 = 0; i2 < str.length; i2++) {
      hash = (hash << 5) - hash + str.charCodeAt(i2);
      hash |= 0;
    }
    return hash.toString(36);
  }
  const _decoder$2 = new TextDecoder();
  const _encoder$2 = new TextEncoder();
  class Dirent {
    constructor(name2, isDirectory, isFile) {
      __publicField(this, "name");
      __publicField(this, "_isDirectory");
      __publicField(this, "_isFile");
      this.name = name2;
      this._isDirectory = isDirectory;
      this._isFile = isFile;
    }
    isDirectory() {
      return this._isDirectory;
    }
    isFile() {
      return this._isFile;
    }
    isBlockDevice() {
      return false;
    }
    isCharacterDevice() {
      return false;
    }
    isFIFO() {
      return false;
    }
    isSocket() {
      return false;
    }
    isSymbolicLink() {
      return false;
    }
  }
  function createBuffer(data2) {
    const buffer2 = data2;
    Object.defineProperty(buffer2, "toString", {
      value: function(encoding) {
        if (encoding === "utf8" || encoding === "utf-8" || !encoding) {
          return _decoder$2.decode(this);
        }
        if (encoding === "base64") {
          return uint8ToBase64(this);
        }
        if (encoding === "hex") {
          return uint8ToHex(this);
        }
        throw new Error(`Unsupported encoding: ${encoding}`);
      },
      writable: true,
      configurable: true
    });
    return buffer2;
  }
  const pathRemaps = [
    {
      from: "/convex/",
      to: "/project/convex/"
    }
  ];
  function remapPath(path2) {
    if (path2.includes("vfs:")) {
      const cleanPath = path2.replace(/vfs:/g, "");
      if (!remapPath.logged) remapPath.logged = /* @__PURE__ */ new Set();
      if (!remapPath.logged.has(path2)) {
        console.log(`[fs] Stripping vfs: prefix: ${path2} -> ${cleanPath}`);
        remapPath.logged.add(path2);
      }
      path2 = cleanPath;
    }
    for (const remap of pathRemaps) {
      if (path2 === remap.from.slice(0, -1) || path2.startsWith(remap.from)) {
        const remapped = remap.to + path2.slice(remap.from.length);
        if (!remapPath.logged) remapPath.logged = /* @__PURE__ */ new Set();
        if (!remapPath.logged.has(path2)) {
          console.log(`[fs] Remapping path: ${path2} -> ${remapped}`);
          remapPath.logged.add(path2);
        }
        return remapped;
      }
    }
    return path2;
  }
  remapPath.logged = /* @__PURE__ */ new Set();
  function toPath(pathLike, getCwd) {
    let path2;
    if (typeof pathLike === "string") {
      path2 = pathLike;
    } else if (pathLike instanceof URL) {
      if (pathLike.protocol === "file:") {
        path2 = decodeURIComponent(pathLike.pathname);
      } else {
        throw new Error(`Unsupported URL protocol: ${pathLike.protocol}`);
      }
    } else if (Buffer.isBuffer(pathLike)) {
      path2 = pathLike.toString("utf8");
    } else if (pathLike && typeof pathLike === "object" && "toString" in pathLike) {
      path2 = String(pathLike);
    } else {
      throw new TypeError(`Path must be a string, URL, or Buffer. Received: ${typeof pathLike}`);
    }
    if (!path2.startsWith("/") && getCwd) {
      const cwd = getCwd();
      path2 = cwd.endsWith("/") ? cwd + path2 : cwd + "/" + path2;
    }
    path2 = remapPath(path2);
    return path2;
  }
  const fdMap = /* @__PURE__ */ new Map();
  let nextFd = 3;
  const callTracker = {
    statSync: /* @__PURE__ */ new Map(),
    readdirSync: /* @__PURE__ */ new Map(),
    lastReset: Date.now()
  };
  function trackCall(method, path2) {
    var _a2;
    const now = Date.now();
    if (now - callTracker.lastReset > 500) {
      callTracker.statSync.clear();
      callTracker.readdirSync.clear();
      callTracker.lastReset = now;
    }
    const map = callTracker[method];
    const count = (map.get(path2) || 0) + 1;
    map.set(path2, count);
    if (count === 10 && path2.includes("_generated")) {
      console.warn(`[fs] ${method} called ${count}x on ${path2}`);
      const err = new Error();
      console.log(`[fs] Stack at ${count} calls:`, (_a2 = err.stack) == null ? void 0 : _a2.split("\n").slice(1, 10).join("\n"));
    }
    if (count === 50) {
      console.warn(`[fs] Potential infinite loop: ${method} called ${count}+ times on ${path2}`);
    }
  }
  createFsShim = function(vfs2, getCwd) {
    const resolvePath = (pathLike) => toPath(pathLike, getCwd);
    const constants2 = {
      F_OK: 0,
      R_OK: 4,
      W_OK: 2,
      X_OK: 1
    };
    const promises2 = {
      readFile(pathLike, encodingOrOptions) {
        return new Promise((resolve2, reject) => {
          try {
            const path2 = resolvePath(pathLike);
            let encoding;
            if (typeof encodingOrOptions === "string") {
              encoding = encodingOrOptions;
            } else if (encodingOrOptions == null ? void 0 : encodingOrOptions.encoding) {
              encoding = encodingOrOptions.encoding;
            }
            if (encoding === "utf8" || encoding === "utf-8") {
              resolve2(vfs2.readFileSync(path2, "utf8"));
            } else {
              resolve2(createBuffer(vfs2.readFileSync(path2)));
            }
          } catch (err) {
            reject(err);
          }
        });
      },
      writeFile(pathLike, data2) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.writeFileSync(resolvePath(pathLike), data2);
            resolve2();
          } catch (err) {
            reject(err);
          }
        });
      },
      stat(pathLike) {
        return new Promise((resolve2, reject) => {
          try {
            const path2 = typeof pathLike === "string" ? pathLike : resolvePath(pathLike);
            resolve2(vfs2.statSync(path2));
          } catch (err) {
            reject(err);
          }
        });
      },
      lstat(pathLike) {
        return this.stat(resolvePath(pathLike));
      },
      readdir(pathLike) {
        return new Promise((resolve2, reject) => {
          try {
            resolve2(vfs2.readdirSync(resolvePath(pathLike)));
          } catch (err) {
            reject(err);
          }
        });
      },
      mkdir(pathLike, options2) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.mkdirSync(resolvePath(pathLike), options2);
            resolve2();
          } catch (err) {
            reject(err);
          }
        });
      },
      unlink(pathLike) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.unlinkSync(resolvePath(pathLike));
            resolve2();
          } catch (err) {
            reject(err);
          }
        });
      },
      rmdir(path2) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.rmdirSync(path2);
            resolve2();
          } catch (err) {
            reject(err);
          }
        });
      },
      rename(oldPath, newPath) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.renameSync(oldPath, newPath);
            resolve2();
          } catch (err) {
            reject(err);
          }
        });
      },
      access(path2, mode) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.accessSync(path2, mode);
            resolve2();
          } catch (err) {
            reject(err);
          }
        });
      },
      realpath(path2) {
        return new Promise((resolve2, reject) => {
          try {
            resolve2(vfs2.realpathSync(path2));
          } catch (err) {
            reject(err);
          }
        });
      },
      copyFile(src, dest) {
        return new Promise((resolve2, reject) => {
          try {
            vfs2.copyFileSync(src, dest);
            resolve2();
          } catch (err) {
            reject(err);
          }
        });
      }
    };
    return {
      readFileSync(pathLike, encodingOrOptions) {
        const path2 = resolvePath(pathLike);
        let encoding;
        if (typeof encodingOrOptions === "string") {
          encoding = encodingOrOptions;
        } else if (encodingOrOptions == null ? void 0 : encodingOrOptions.encoding) {
          encoding = encodingOrOptions.encoding;
        }
        if (encoding === "utf8" || encoding === "utf-8") {
          return vfs2.readFileSync(path2, "utf8");
        }
        const data2 = vfs2.readFileSync(path2);
        return createBuffer(data2);
      },
      writeFileSync(pathLike, data2) {
        if (typeof pathLike === "number") {
          const fd = pathLike;
          const entry = fdMap.get(fd);
          if (!entry) {
            const err = new Error(`EBADF: bad file descriptor, write`);
            err.code = "EBADF";
            err.errno = -9;
            throw err;
          }
          const bytes = typeof data2 === "string" ? _encoder$2.encode(data2) : data2;
          entry.content = new Uint8Array(bytes);
          entry.position = bytes.length;
          return;
        }
        const path2 = resolvePath(pathLike);
        if (path2.includes("convex") || path2.includes("_generated")) {
          console.log("[fs] writeFileSync:", path2);
        }
        vfs2.writeFileSync(path2, data2);
      },
      existsSync(pathLike) {
        return vfs2.existsSync(resolvePath(pathLike));
      },
      mkdirSync(pathLike, options2) {
        const path2 = resolvePath(pathLike);
        if (path2.includes("convex") || path2.includes("_generated")) {
          console.log("[fs] mkdirSync:", path2, options2);
        }
        vfs2.mkdirSync(path2, options2);
      },
      readdirSync(pathLike, options2) {
        const path2 = resolvePath(pathLike);
        trackCall("readdirSync", path2);
        const entries = vfs2.readdirSync(path2);
        const opts = typeof options2 === "string" ? {} : options2;
        if (opts == null ? void 0 : opts.withFileTypes) {
          const dirents = entries.map((name2) => {
            const entryPath = path2.endsWith("/") ? path2 + name2 : path2 + "/" + name2;
            let isDir = false;
            let isFile = false;
            try {
              const stat = vfs2.statSync(entryPath);
              isDir = stat.isDirectory();
              isFile = stat.isFile();
            } catch {
              isFile = true;
            }
            return new Dirent(name2, isDir, isFile);
          });
          if (path2.includes("_generated")) {
            console.log(`[fs] readdirSync(${path2}, withFileTypes) -> [${dirents.map((d) => d.name).join(", ")}]`);
          }
          return dirents;
        }
        if (path2.includes("_generated")) {
          console.log(`[fs] readdirSync(${path2}) -> [${entries.join(", ")}]`);
        }
        return entries;
      },
      statSync(pathLike) {
        const origPath = typeof pathLike === "string" ? pathLike : String(pathLike);
        const path2 = resolvePath(pathLike);
        trackCall("statSync", path2);
        const result = vfs2.statSync(path2);
        if (path2.includes("_generated")) {
          const wasRemapped = origPath !== path2;
          console.log(`[fs] statSync(${origPath}${wasRemapped ? " -> " + path2 : ""}) -> isDir: ${result.isDirectory()}`);
        }
        return result;
      },
      lstatSync(pathLike) {
        return vfs2.lstatSync(resolvePath(pathLike));
      },
      fstatSync(fd) {
        const entry = fdMap.get(fd);
        if (!entry) {
          const err = new Error(`EBADF: bad file descriptor, fstat`);
          err.code = "EBADF";
          err.errno = -9;
          throw err;
        }
        return vfs2.statSync(entry.path);
      },
      openSync(pathLike, flags, _mode) {
        const path2 = resolvePath(pathLike);
        const flagStr = typeof flags === "number" ? "r" : flags;
        const exists = vfs2.existsSync(path2);
        const isWriteMode = flagStr.includes("w") || flagStr.includes("a");
        const isReadMode = flagStr.includes("r") && !flagStr.includes("+");
        if (!exists && isReadMode) {
          const err = new Error(`ENOENT: no such file or directory, open '${path2}'`);
          err.code = "ENOENT";
          err.errno = -2;
          err.path = path2;
          throw err;
        }
        let content;
        if (exists && !flagStr.includes("w")) {
          content = vfs2.readFileSync(path2);
        } else {
          content = new Uint8Array(0);
          if (isWriteMode) {
            const parentPath = path2.substring(0, path2.lastIndexOf("/")) || "/";
            if (!vfs2.existsSync(parentPath)) {
              vfs2.mkdirSync(parentPath, {
                recursive: true
              });
            }
          }
        }
        const fd = nextFd++;
        fdMap.set(fd, {
          path: path2,
          position: flagStr.includes("a") ? content.length : 0,
          flags: flagStr,
          content: new Uint8Array(content)
        });
        return fd;
      },
      closeSync(fd) {
        const entry = fdMap.get(fd);
        if (!entry) {
          return;
        }
        if (entry.flags.includes("w") || entry.flags.includes("a") || entry.flags.includes("+")) {
          vfs2.writeFileSync(entry.path, entry.content);
        }
        fdMap.delete(fd);
      },
      readSync(fd, buffer2, offset, length2, position) {
        const entry = fdMap.get(fd);
        if (!entry) {
          const err = new Error(`EBADF: bad file descriptor, read`);
          err.code = "EBADF";
          err.errno = -9;
          throw err;
        }
        const readPos = position !== null ? position : entry.position;
        const bytesToRead = Math.min(length2, entry.content.length - readPos);
        if (bytesToRead <= 0) {
          return 0;
        }
        for (let i2 = 0; i2 < bytesToRead; i2++) {
          buffer2[offset + i2] = entry.content[readPos + i2];
        }
        if (position === null) {
          entry.position += bytesToRead;
        }
        return bytesToRead;
      },
      writeSync(fd, buffer2, offset, length2, position) {
        const entry = fdMap.get(fd);
        if (!entry) {
          const err = new Error(`EBADF: bad file descriptor, write`);
          err.code = "EBADF";
          err.errno = -9;
          throw err;
        }
        let data2;
        if (typeof buffer2 === "string") {
          data2 = _encoder$2.encode(buffer2);
          offset = 0;
          length2 = data2.length;
        } else {
          data2 = buffer2;
          offset = offset ?? 0;
          length2 = length2 ?? data2.length - offset;
        }
        const writePos = position !== null && position !== void 0 ? position : entry.position;
        const endPos = writePos + length2;
        if (endPos > entry.content.length) {
          const newContent = new Uint8Array(endPos);
          newContent.set(entry.content);
          entry.content = newContent;
        }
        for (let i2 = 0; i2 < length2; i2++) {
          entry.content[writePos + i2] = data2[offset + i2];
        }
        if (position === null || position === void 0) {
          entry.position = endPos;
        }
        return length2;
      },
      ftruncateSync(fd, len = 0) {
        const entry = fdMap.get(fd);
        if (!entry) {
          const err = new Error(`EBADF: bad file descriptor, ftruncate`);
          err.code = "EBADF";
          err.errno = -9;
          throw err;
        }
        if (len < entry.content.length) {
          entry.content = entry.content.slice(0, len);
        } else if (len > entry.content.length) {
          const newContent = new Uint8Array(len);
          newContent.set(entry.content);
          entry.content = newContent;
        }
      },
      fsyncSync(_fd) {
      },
      fdatasyncSync(_fd) {
      },
      mkdtempSync(prefix) {
        const suffix = Math.random().toString(36).slice(2, 8);
        const tempDir = `${prefix}${suffix}`;
        const resolvedPath2 = resolvePath(tempDir);
        vfs2.mkdirSync(resolvedPath2, {
          recursive: true
        });
        return resolvedPath2;
      },
      rmSync(pathLike, options2) {
        const path2 = resolvePath(pathLike);
        if (!vfs2.existsSync(path2)) {
          if (options2 == null ? void 0 : options2.force) return;
          throw createNodeError("ENOENT", "rm", path2);
        }
        const stats = vfs2.statSync(path2);
        if (stats.isDirectory()) {
          if (options2 == null ? void 0 : options2.recursive) {
            const entries = vfs2.readdirSync(path2);
            for (const entry of entries) {
              const entryPath = path2.endsWith("/") ? path2 + entry : path2 + "/" + entry;
              this.rmSync(entryPath, options2);
            }
            vfs2.rmdirSync(path2);
          } else {
            throw createNodeError("EISDIR", "rm", path2);
          }
        } else {
          vfs2.unlinkSync(path2);
        }
      },
      unlinkSync(pathLike) {
        const path2 = resolvePath(pathLike);
        if (path2.includes("_generated")) {
          console.log(`[fs] unlinkSync(${path2})`);
        }
        vfs2.unlinkSync(path2);
      },
      rmdirSync(pathLike) {
        vfs2.rmdirSync(resolvePath(pathLike));
      },
      renameSync(oldPathLike, newPathLike) {
        vfs2.renameSync(resolvePath(oldPathLike), resolvePath(newPathLike));
      },
      realpathSync(pathLike) {
        return vfs2.realpathSync(resolvePath(pathLike));
      },
      accessSync(pathLike, _mode) {
        vfs2.accessSync(resolvePath(pathLike));
      },
      copyFileSync(srcLike, destLike) {
        const src = resolvePath(srcLike);
        const dest = resolvePath(destLike);
        const data2 = vfs2.readFileSync(src);
        vfs2.writeFileSync(dest, data2);
      },
      watch(pathLike, optionsOrListener, listener) {
        return vfs2.watch(resolvePath(pathLike), optionsOrListener, listener);
      },
      readFile(pathLike, optionsOrCallback, callback) {
        const path2 = resolvePath(pathLike);
        vfs2.readFile(path2, optionsOrCallback, callback);
      },
      stat(pathLike, callback) {
        vfs2.stat(resolvePath(pathLike), callback);
      },
      lstat(pathLike, callback) {
        vfs2.lstat(resolvePath(pathLike), callback);
      },
      readdir(pathLike, optionsOrCallback, callback) {
        vfs2.readdir(resolvePath(pathLike), optionsOrCallback, callback);
      },
      realpath(pathLike, callback) {
        vfs2.realpath(resolvePath(pathLike), callback);
      },
      access(pathLike, modeOrCallback, callback) {
        vfs2.access(resolvePath(pathLike), modeOrCallback, callback);
      },
      createReadStream(pathLike) {
        return vfs2.createReadStream(resolvePath(pathLike));
      },
      createWriteStream(pathLike) {
        return vfs2.createWriteStream(resolvePath(pathLike));
      },
      promises: promises2,
      constants: constants2
    };
  };
  const fs = Object.freeze(Object.defineProperty({
    __proto__: null,
    Dirent,
    createFsShim,
    default: createFsShim
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const sep = "/";
  const delimiter = ":";
  function normalize(path2) {
    if (!path2) return ".";
    const isAbsolute2 = path2.startsWith("/");
    const parts = path2.split("/").filter(Boolean);
    const resolved = [];
    for (const part of parts) {
      if (part === "..") {
        if (resolved.length > 0 && resolved[resolved.length - 1] !== "..") {
          resolved.pop();
        } else if (!isAbsolute2) {
          resolved.push("..");
        }
      } else if (part !== ".") {
        resolved.push(part);
      }
    }
    let result = resolved.join("/");
    if (isAbsolute2) {
      result = "/" + result;
    }
    return result || ".";
  }
  function join(...paths) {
    if (paths.length === 0) return ".";
    return normalize(paths.filter(Boolean).join("/"));
  }
  function resolve$2(...paths) {
    let resolvedPath2 = "";
    for (let i2 = paths.length - 1; i2 >= 0 && !resolvedPath2.startsWith("/"); i2--) {
      const path2 = paths[i2];
      if (!path2) continue;
      resolvedPath2 = path2 + (resolvedPath2 ? "/" + resolvedPath2 : "");
    }
    if (!resolvedPath2.startsWith("/")) {
      const cwd = typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/";
      resolvedPath2 = cwd + (resolvedPath2 ? "/" + resolvedPath2 : "");
    }
    return normalize(resolvedPath2);
  }
  function isAbsolute(path2) {
    return path2.startsWith("/");
  }
  function dirname(path2) {
    if (!path2) return ".";
    const normalized = normalize(path2);
    const lastSlash = normalized.lastIndexOf("/");
    if (lastSlash === -1) return ".";
    if (lastSlash === 0) return "/";
    return normalized.slice(0, lastSlash);
  }
  function basename(path2, ext) {
    if (!path2) return "";
    const normalized = normalize(path2);
    let base = normalized.slice(normalized.lastIndexOf("/") + 1);
    if (ext && base.endsWith(ext)) {
      base = base.slice(0, -ext.length);
    }
    return base;
  }
  function extname(path2) {
    const base = basename(path2);
    const dotIndex = base.lastIndexOf(".");
    if (dotIndex <= 0) return "";
    return base.slice(dotIndex);
  }
  function relative(from, to) {
    from = resolve$2(from);
    to = resolve$2(to);
    if (from === to) return "";
    const fromParts = from.split("/").filter(Boolean);
    const toParts = to.split("/").filter(Boolean);
    let commonLength = 0;
    for (let i2 = 0; i2 < Math.min(fromParts.length, toParts.length); i2++) {
      if (fromParts[i2] !== toParts[i2]) break;
      commonLength++;
    }
    const upCount = fromParts.length - commonLength;
    const remainingPath = toParts.slice(commonLength);
    const result = [
      ...Array(upCount).fill(".."),
      ...remainingPath
    ];
    return result.join("/") || ".";
  }
  function parse$R(path2) {
    const normalized = normalize(path2);
    const isAbs = isAbsolute(normalized);
    const dir = dirname(normalized);
    const base = basename(normalized);
    const ext = extname(normalized);
    const name2 = base.slice(0, base.length - ext.length);
    return {
      root: isAbs ? "/" : "",
      dir,
      base,
      ext,
      name: name2
    };
  }
  function format$2(pathObject) {
    const dir = pathObject.dir || pathObject.root || "";
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + "/" + base;
  }
  const posix = {
    sep,
    delimiter,
    normalize,
    join,
    resolve: resolve$2,
    isAbsolute,
    dirname,
    basename,
    extname,
    relative,
    parse: parse$R,
    format: format$2
  };
  const path = {
    sep,
    delimiter,
    normalize,
    join,
    resolve: resolve$2,
    isAbsolute,
    dirname,
    basename,
    extname,
    relative,
    parse: parse$R,
    format: format$2,
    posix
  };
  pathShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    basename,
    default: path,
    delimiter,
    dirname,
    extname,
    format: format$2,
    isAbsolute,
    join,
    normalize,
    parse: parse$R,
    posix,
    relative,
    resolve: resolve$2,
    sep
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const kEvents = Symbol("events");
  const kMaxListeners = Symbol("maxListeners");
  _b = kEvents, _a = kMaxListeners;
  class EventEmitter {
    constructor() {
      __publicField(this, _b);
      __publicField(this, _a);
    }
    _getEvents() {
      const self = this;
      if (!self[kEvents]) {
        self[kEvents] = /* @__PURE__ */ new Map();
      }
      return self[kEvents];
    }
    on(event, listener) {
      return this.addListener(event, listener);
    }
    addListener(event, listener) {
      const events2 = this._getEvents();
      if (!events2.has(event)) {
        events2.set(event, []);
      }
      events2.get(event).push(listener);
      return this;
    }
    once(event, listener) {
      const onceWrapper = (...args) => {
        this.removeListener(event, onceWrapper);
        listener.apply(this, args);
      };
      return this.addListener(event, onceWrapper);
    }
    off(event, listener) {
      return this.removeListener(event, listener);
    }
    removeListener(event, listener) {
      const events2 = this._getEvents();
      const listeners = events2.get(event);
      if (listeners) {
        const index2 = listeners.indexOf(listener);
        if (index2 !== -1) {
          listeners.splice(index2, 1);
        }
      }
      return this;
    }
    removeAllListeners(event) {
      const events2 = this._getEvents();
      if (event) {
        events2.delete(event);
      } else {
        events2.clear();
      }
      return this;
    }
    emit(event, ...args) {
      const events2 = this._getEvents();
      const listeners = events2.get(event);
      if (!listeners || listeners.length === 0) {
        if (event === "error") {
          const err = args[0];
          if (err instanceof Error) {
            throw err;
          }
          throw new Error("Unhandled error event");
        }
        return false;
      }
      for (const listener of [
        ...listeners
      ]) {
        try {
          listener.apply(this, args);
        } catch (err) {
          console.error("Error in event listener:", err);
        }
      }
      return true;
    }
    listeners(event) {
      const events2 = this._getEvents();
      return [
        ...events2.get(event) || []
      ];
    }
    rawListeners(event) {
      return this.listeners(event);
    }
    listenerCount(event) {
      var _a2;
      const events2 = this._getEvents();
      return ((_a2 = events2.get(event)) == null ? void 0 : _a2.length) || 0;
    }
    eventNames() {
      const events2 = this._getEvents();
      return [
        ...events2.keys()
      ];
    }
    setMaxListeners(n) {
      this[kMaxListeners] = n;
      return this;
    }
    getMaxListeners() {
      return this[kMaxListeners] || 10;
    }
    prependListener(event, listener) {
      const events2 = this._getEvents();
      if (!events2.has(event)) {
        events2.set(event, []);
      }
      events2.get(event).unshift(listener);
      return this;
    }
    prependOnceListener(event, listener) {
      const onceWrapper = (...args) => {
        this.removeListener(event, onceWrapper);
        listener.apply(this, args);
      };
      return this.prependListener(event, onceWrapper);
    }
    static listenerCount(emitter, event) {
      return emitter.listenerCount(event);
    }
  }
  const events = EventEmitter;
  events.EventEmitter = EventEmitter;
  events.once = async (emitter, event) => {
    return new Promise((resolve2, reject) => {
      const onEvent = (...args) => {
        emitter.removeListener("error", onError);
        resolve2(args);
      };
      const onError = (...args) => {
        emitter.removeListener(event, onEvent);
        reject(args[0]);
      };
      emitter.once(event, onEvent);
      emitter.once("error", onError);
    });
  };
  events.on = (emitter, event) => {
    const iterator = {
      async next() {
        return new Promise((resolve2) => {
          emitter.once(event, (...args) => resolve2({
            value: args,
            done: false
          }));
        });
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
    return iterator;
  };
  events.getEventListeners = (emitter, event) => emitter.listeners(event);
  events.listenerCount = (emitter, event) => emitter.listenerCount(event);
  events$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    EventEmitter,
    default: events
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function createProcessStream(isWritable, writeImpl) {
    const emitter = new EventEmitter();
    const stream2 = {
      isTTY: false,
      on(event, listener) {
        emitter.on(event, listener);
        return stream2;
      },
      once(event, listener) {
        emitter.once(event, listener);
        return stream2;
      },
      off(event, listener) {
        emitter.off(event, listener);
        return stream2;
      },
      emit(event, ...args) {
        return emitter.emit(event, ...args);
      },
      addListener(event, listener) {
        emitter.addListener(event, listener);
        return stream2;
      },
      removeListener(event, listener) {
        emitter.removeListener(event, listener);
        return stream2;
      },
      removeAllListeners(event) {
        emitter.removeAllListeners(event);
        return stream2;
      },
      setMaxListeners(n) {
        emitter.setMaxListeners(n);
        return stream2;
      },
      pause() {
        return stream2;
      },
      resume() {
        return stream2;
      },
      setEncoding(_encoding) {
        return stream2;
      },
      write(_data, _encoding, callback) {
        if (callback) queueMicrotask(callback);
        return true;
      },
      end(_data, callback) {
        if (callback) queueMicrotask(callback);
      },
      read() {
        return null;
      },
      setRawMode(_mode) {
        return stream2;
      }
    };
    if (isWritable && writeImpl) {
      stream2.write = (data2, _encoding, callback) => {
        const result = writeImpl(typeof data2 === "string" ? data2 : data2.toString());
        if (callback) queueMicrotask(callback);
        return result;
      };
    }
    return stream2;
  }
  createProcess = function(options2) {
    let currentDir2 = (options2 == null ? void 0 : options2.cwd) || "/";
    const env = {
      NODE_ENV: "development",
      PATH: "/usr/local/bin:/usr/bin:/bin",
      HOME: "/",
      ...options2 == null ? void 0 : options2.env
    };
    const emitter = new EventEmitter();
    const startTime = Date.now();
    const proc = {
      env,
      cwd() {
        if (!proc._cwdCallCount) proc._cwdCallCount = 0;
        proc._cwdCallCount++;
        if (proc._cwdCallCount <= 5 || proc._cwdCallCount % 100 === 0) {
          console.log(`[process] cwd() called (${proc._cwdCallCount}x), returning:`, currentDir2);
        }
        return currentDir2;
      },
      chdir(directory) {
        console.log("[process] chdir called:", directory, "from:", currentDir2);
        if (!directory.startsWith("/")) {
          directory = currentDir2 + "/" + directory;
        }
        currentDir2 = directory;
        console.log("[process] chdir result:", currentDir2);
      },
      platform: "linux",
      version: "v20.0.0",
      versions: {
        node: "20.0.0",
        v8: "11.3.244.8",
        uv: "1.44.2"
      },
      argv: [
        "node",
        "/index.js"
      ],
      argv0: "node",
      execPath: "/usr/local/bin/node",
      execArgv: [],
      pid: 1,
      ppid: 0,
      exit(code2 = 0) {
        emitter.emit("exit", code2);
        if (options2 == null ? void 0 : options2.onExit) {
          options2.onExit(code2);
        }
        throw new Error(`Process exited with code ${code2}`);
      },
      nextTick(callback, ...args) {
        queueMicrotask(() => callback(...args));
      },
      stdout: createProcessStream(true, (data2) => {
        console.log(data2);
        return true;
      }),
      stderr: createProcessStream(true, (data2) => {
        console.error(data2);
        return true;
      }),
      stdin: createProcessStream(false),
      hrtime: Object.assign(function hrtime(time2) {
        const now = performance.now();
        const seconds = Math.floor(now / 1e3);
        const nanoseconds = Math.floor(now % 1e3 * 1e6);
        if (time2) {
          const diffSeconds = seconds - time2[0];
          const diffNanos = nanoseconds - time2[1];
          return [
            diffSeconds,
            diffNanos
          ];
        }
        return [
          seconds,
          nanoseconds
        ];
      }, {
        bigint: () => BigInt(Math.floor(performance.now() * 1e6))
      }),
      memoryUsage() {
        return {
          rss: 50 * 1024 * 1024,
          heapTotal: 30 * 1024 * 1024,
          heapUsed: 20 * 1024 * 1024,
          external: 1 * 1024 * 1024,
          arrayBuffers: 0
        };
      },
      uptime() {
        return (Date.now() - startTime) / 1e3;
      },
      cpuUsage() {
        return {
          user: 0,
          system: 0
        };
      },
      on(event, listener) {
        emitter.on(event, listener);
        return proc;
      },
      once(event, listener) {
        emitter.once(event, listener);
        return proc;
      },
      off(event, listener) {
        emitter.off(event, listener);
        return proc;
      },
      emit(event, ...args) {
        return emitter.emit(event, ...args);
      },
      addListener(event, listener) {
        emitter.addListener(event, listener);
        return proc;
      },
      removeListener(event, listener) {
        emitter.removeListener(event, listener);
        return proc;
      },
      removeAllListeners(event) {
        emitter.removeAllListeners(event);
        return proc;
      },
      listeners(event) {
        return emitter.listeners(event);
      },
      listenerCount(event) {
        return emitter.listenerCount(event);
      },
      prependListener(event, listener) {
        emitter.prependListener(event, listener);
        return proc;
      },
      prependOnceListener(event, listener) {
        emitter.prependOnceListener(event, listener);
        return proc;
      },
      eventNames() {
        return emitter.eventNames();
      },
      setMaxListeners(n) {
        emitter.setMaxListeners(n);
        return proc;
      },
      getMaxListeners() {
        return emitter.getMaxListeners();
      }
    };
    return proc;
  };
  createProcess();
  const _encoder$1 = new TextEncoder();
  const _decoder$1 = new TextDecoder("utf-8");
  class Readable extends EventEmitter {
    constructor() {
      super();
      __publicField(this, "_buffer", []);
      __publicField(this, "_ended", false);
      __publicField(this, "_flowing", false);
      __publicField(this, "_endEmitted", false);
      __publicField(this, "readable", true);
      __publicField(this, "readableEnded", false);
      __publicField(this, "readableFlowing", null);
    }
    _addListenerInternal(event, listener) {
      EventEmitter.prototype.addListener.call(this, event, listener);
      return this;
    }
    on(event, listener) {
      this._addListenerInternal(event, listener);
      if (event === "data" && !this._flowing) {
        queueMicrotask(() => {
          if (this.listenerCount("data") > 0 && !this._flowing) {
            this.resume();
          }
        });
      }
      return this;
    }
    addListener(event, listener) {
      return this.on(event, listener);
    }
    push(chunk) {
      if (chunk === null) {
        this._ended = true;
        this.readableEnded = true;
        this.readable = false;
        if (this._flowing && this._buffer.length === 0 && !this._endEmitted) {
          this._endEmitted = true;
          queueMicrotask(() => this.emit("end"));
        }
        return false;
      }
      const buffer2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
      this._buffer.push(buffer2);
      if (this._flowing) {
        queueMicrotask(() => {
          this._flushBuffer();
        });
      }
      return true;
    }
    _flushBuffer() {
      while (this._buffer.length > 0 && this._flowing) {
        const data2 = this._buffer.shift();
        this.emit("data", data2);
      }
      if (this._ended && this._buffer.length === 0 && !this._endEmitted) {
        this._endEmitted = true;
        this.emit("end");
      }
    }
    read(size) {
      if (this._buffer.length === 0) {
        return null;
      }
      if (size === void 0) {
        const result = Buffer.concat(this._buffer);
        this._buffer = [];
        return result;
      }
      const chunks = [];
      let remaining = size;
      while (remaining > 0 && this._buffer.length > 0) {
        const chunk = this._buffer[0];
        if (chunk.length <= remaining) {
          chunks.push(this._buffer.shift());
          remaining -= chunk.length;
        } else {
          chunks.push(chunk.slice(0, remaining));
          this._buffer[0] = chunk.slice(remaining);
          remaining = 0;
        }
      }
      return chunks.length > 0 ? Buffer.concat(chunks) : null;
    }
    resume() {
      this._flowing = true;
      this.readableFlowing = true;
      this._flushBuffer();
      return this;
    }
    pause() {
      this._flowing = false;
      this.readableFlowing = false;
      return this;
    }
    pipe(destination) {
      this.on("data", (chunk) => {
        destination.write(chunk);
      });
      this.on("end", () => {
        destination.end();
      });
      this.resume();
      return destination;
    }
    unpipe(destination) {
      this.removeAllListeners("data");
      this.removeAllListeners("end");
      return this;
    }
    setEncoding(encoding) {
      return this;
    }
    destroy(error) {
      this._buffer = [];
      this._ended = true;
      this.readable = false;
      if (error) {
        this.emit("error", error);
      }
      this.emit("close");
      return this;
    }
    static from(iterable, options2) {
      const readable = new Readable();
      (async () => {
        try {
          for await (const chunk of iterable) {
            if (chunk !== null && chunk !== void 0) {
              const data2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
              readable.push(data2);
            }
          }
          readable.push(null);
        } catch (err) {
          readable.destroy(err);
        }
      })();
      return readable;
    }
  }
  class Writable extends EventEmitter {
    constructor() {
      super();
      __publicField(this, "_chunks", []);
      __publicField(this, "_ended", false);
      __publicField(this, "writable", true);
      __publicField(this, "writableEnded", false);
      __publicField(this, "writableFinished", false);
    }
    write(chunk, encodingOrCallback, callback) {
      if (this._ended) {
        const error = new Error("write after end");
        if (typeof encodingOrCallback === "function") {
          encodingOrCallback(error);
        } else if (callback) {
          callback(error);
        }
        return false;
      }
      const buffer2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
      this._chunks.push(buffer2);
      const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      if (cb) {
        queueMicrotask(() => cb(null));
      }
      return true;
    }
    end(chunkOrCallback, encodingOrCallback, callback) {
      if (typeof chunkOrCallback === "function") {
        callback = chunkOrCallback;
      } else if (chunkOrCallback !== void 0) {
        this.write(chunkOrCallback);
      }
      if (typeof encodingOrCallback === "function") {
        callback = encodingOrCallback;
      }
      this._ended = true;
      this.writable = false;
      this.writableEnded = true;
      queueMicrotask(() => {
        this.writableFinished = true;
        this.emit("finish");
        if (callback) {
          callback();
        }
      });
      return this;
    }
    getBuffer() {
      return Buffer.concat(this._chunks);
    }
    getBufferAsString(encoding = "utf8") {
      return this.getBuffer().toString(encoding);
    }
    destroy(error) {
      this._chunks = [];
      this._ended = true;
      this.writable = false;
      if (error) {
        this.emit("error", error);
      }
      this.emit("close");
      return this;
    }
    cork() {
    }
    uncork() {
    }
    setDefaultEncoding(encoding) {
      return this;
    }
  }
  class Duplex extends Readable {
    constructor() {
      super(...arguments);
      __publicField(this, "_writeChunks", []);
      __publicField(this, "_writeEnded", false);
      __publicField(this, "writable", true);
      __publicField(this, "writableEnded", false);
      __publicField(this, "writableFinished", false);
    }
    write(chunk, encodingOrCallback, callback) {
      if (this._writeEnded) {
        return false;
      }
      const buffer2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
      this._writeChunks.push(buffer2);
      const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      if (cb) {
        queueMicrotask(() => cb(null));
      }
      return true;
    }
    end(chunkOrCallback, encodingOrCallback, callback) {
      if (typeof chunkOrCallback === "function") {
        callback = chunkOrCallback;
      } else if (chunkOrCallback !== void 0) {
        this.write(chunkOrCallback);
      }
      this._writeEnded = true;
      this.writable = false;
      this.writableEnded = true;
      queueMicrotask(() => {
        this.writableFinished = true;
        this.emit("finish");
        if (callback) {
          callback();
        }
      });
      return this;
    }
  }
  class PassThrough extends Duplex {
    constructor() {
      super();
    }
    write(chunk, encodingOrCallback, callback) {
      const buffer2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
      this.push(buffer2);
      const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      if (cb) {
        queueMicrotask(() => cb(null));
      }
      return true;
    }
  }
  class Transform extends Duplex {
    constructor() {
      super();
    }
    _transform(chunk, encoding, callback) {
      callback(null, chunk);
    }
    _flush(callback) {
      callback(null);
    }
    write(chunk, encodingOrCallback, callback) {
      const buffer2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
      const encoding = typeof encodingOrCallback === "string" ? encodingOrCallback : "utf8";
      const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      this._transform(buffer2, encoding, (error, data2) => {
        if (error) {
          if (cb) cb(error);
          return;
        }
        if (data2) {
          this.push(data2);
        }
        if (cb) cb(null);
      });
      return true;
    }
    end(chunkOrCallback, encodingOrCallback, callback) {
      this._flush((error, data2) => {
        if (data2) {
          this.push(data2);
        }
      });
      return super.end(chunkOrCallback, encodingOrCallback, callback);
    }
  }
  class Stream extends EventEmitter {
    pipe(destination) {
      return destination;
    }
  }
  Stream.Readable = Readable;
  Stream.Writable = Writable;
  Stream.Duplex = Duplex;
  Stream.Transform = Transform;
  Stream.PassThrough = PassThrough;
  Stream.Stream = Stream;
  Stream.from = Readable.from;
  const promises$2 = {
    pipeline: async (...streams) => {
      return Promise.resolve();
    },
    finished: async (stream2) => {
      return Promise.resolve();
    }
  };
  function pipeline(...args) {
    const callback = args[args.length - 1];
    if (typeof callback === "function") {
      setTimeout(() => callback(), 0);
    }
    return args[args.length - 2] || args[0];
  }
  function finished(stream2, callback) {
    setTimeout(() => callback(), 0);
    return () => {
    };
  }
  const _BufferPolyfill = class _BufferPolyfill extends Uint8Array {
    static from(value2, encodingOrMapfn, thisArg) {
      if (typeof encodingOrMapfn === "function") {
        const arrayLike = value2;
        const mapped = Array.from(arrayLike, encodingOrMapfn, thisArg);
        return new _BufferPolyfill(mapped);
      }
      const data2 = value2;
      const encoding = encodingOrMapfn;
      if (Array.isArray(data2)) {
        return new _BufferPolyfill(data2);
      }
      if (typeof data2 === "string") {
        const enc = (encoding || "utf8").toLowerCase();
        if (enc === "base64" || enc === "base64url") {
          let base642 = data2;
          if (enc === "base64url") {
            base642 = data2.replace(/-/g, "+").replace(/_/g, "/");
            while (base642.length % 4 !== 0) {
              base642 += "=";
            }
          }
          const binary = atob(base642);
          const bytes2 = new Uint8Array(binary.length);
          for (let i2 = 0; i2 < binary.length; i2++) {
            bytes2[i2] = binary.charCodeAt(i2);
          }
          return new _BufferPolyfill(bytes2);
        }
        if (enc === "hex") {
          const bytes2 = new Uint8Array(data2.length / 2);
          for (let i2 = 0; i2 < data2.length; i2 += 2) {
            bytes2[i2 / 2] = parseInt(data2.slice(i2, i2 + 2), 16);
          }
          return new _BufferPolyfill(bytes2);
        }
        if (enc === "latin1" || enc === "binary") {
          const bytes2 = new Uint8Array(data2.length);
          for (let i2 = 0; i2 < data2.length; i2++) {
            bytes2[i2] = data2.charCodeAt(i2) & 255;
          }
          return new _BufferPolyfill(bytes2);
        }
        const bytes = _encoder$1.encode(data2);
        return new _BufferPolyfill(bytes);
      }
      if (data2 instanceof ArrayBuffer) {
        return new _BufferPolyfill(data2);
      }
      return new _BufferPolyfill(data2);
    }
    static alloc(size, fill) {
      const buffer2 = new _BufferPolyfill(size);
      if (fill !== void 0) {
        buffer2.fill(fill);
      }
      return buffer2;
    }
    static allocUnsafe(size) {
      return new _BufferPolyfill(size);
    }
    static allocUnsafeSlow(size) {
      return new _BufferPolyfill(size);
    }
    static concat(buffers) {
      const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0);
      const result = new _BufferPolyfill(totalLength);
      let offset = 0;
      for (const buf of buffers) {
        result.set(buf, offset);
        offset += buf.length;
      }
      return result;
    }
    static isBuffer(obj) {
      return obj instanceof _BufferPolyfill || obj instanceof Uint8Array;
    }
    static isEncoding(encoding) {
      return [
        "utf8",
        "utf-8",
        "ascii",
        "latin1",
        "binary",
        "base64",
        "base64url",
        "hex"
      ].includes(encoding.toLowerCase());
    }
    static byteLength(string, encoding) {
      const enc = (encoding || "utf8").toLowerCase();
      if (enc === "base64" || enc === "base64url") {
        const base642 = string.replace(/[=]/g, "");
        return Math.floor(base642.length * 3 / 4);
      }
      if (enc === "hex") {
        return string.length / 2;
      }
      return _encoder$1.encode(string).length;
    }
    toString(encoding = "utf8") {
      const enc = (encoding || "utf8").toLowerCase();
      if (enc === "base64") {
        return uint8ToBase64(this);
      }
      if (enc === "base64url") {
        return uint8ToBase64(this).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      }
      if (enc === "hex") {
        return uint8ToHex(this);
      }
      if (enc === "latin1" || enc === "binary") {
        return uint8ToBinaryString(this);
      }
      return _decoder$1.decode(this);
    }
    slice(start, end) {
      return new _BufferPolyfill(super.slice(start, end));
    }
    subarray(start, end) {
      return new _BufferPolyfill(super.subarray(start, end));
    }
    write(string, offset) {
      const bytes = _encoder$1.encode(string);
      this.set(bytes, offset || 0);
      return bytes.length;
    }
    copy(target, targetStart, sourceStart, sourceEnd) {
      const src = this.subarray(sourceStart || 0, sourceEnd);
      target.set(src, targetStart || 0);
      return src.length;
    }
    compare(otherBuffer) {
      const len = Math.min(this.length, otherBuffer.length);
      for (let i2 = 0; i2 < len; i2++) {
        if (this[i2] < otherBuffer[i2]) return -1;
        if (this[i2] > otherBuffer[i2]) return 1;
      }
      if (this.length < otherBuffer.length) return -1;
      if (this.length > otherBuffer.length) return 1;
      return 0;
    }
    equals(otherBuffer) {
      return this.compare(otherBuffer) === 0;
    }
    toJSON() {
      return {
        type: "Buffer",
        data: Array.from(this)
      };
    }
    hasOwnProperty(prop) {
      return Object.prototype.hasOwnProperty.call(this, prop);
    }
    readUInt8(offset) {
      return this[offset];
    }
    readUInt16BE(offset) {
      return this[offset] << 8 | this[offset + 1];
    }
    readUInt16LE(offset) {
      return this[offset] | this[offset + 1] << 8;
    }
    readUInt32BE(offset) {
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    }
    readUInt32LE(offset) {
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    }
    writeUInt8(value2, offset) {
      this[offset] = value2 & 255;
      return offset + 1;
    }
    writeUInt16BE(value2, offset) {
      this[offset] = value2 >> 8 & 255;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    }
    writeUInt16LE(value2, offset) {
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >> 8 & 255;
      return offset + 2;
    }
    writeUInt32BE(value2, offset) {
      this[offset] = value2 >> 24 & 255;
      this[offset + 1] = value2 >> 16 & 255;
      this[offset + 2] = value2 >> 8 & 255;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    }
    writeUInt32LE(value2, offset) {
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >> 8 & 255;
      this[offset + 2] = value2 >> 16 & 255;
      this[offset + 3] = value2 >> 24 & 255;
      return offset + 4;
    }
    readUint8(offset) {
      return this.readUInt8(offset);
    }
    readUint16BE(offset) {
      return this.readUInt16BE(offset);
    }
    readUint16LE(offset) {
      return this.readUInt16LE(offset);
    }
    readUint32BE(offset) {
      return this.readUInt32BE(offset);
    }
    readUint32LE(offset) {
      return this.readUInt32LE(offset);
    }
    writeUint8(value2, offset) {
      return this.writeUInt8(value2, offset);
    }
    writeUint16BE(value2, offset) {
      return this.writeUInt16BE(value2, offset);
    }
    writeUint16LE(value2, offset) {
      return this.writeUInt16LE(value2, offset);
    }
    writeUint32BE(value2, offset) {
      return this.writeUInt32BE(value2, offset);
    }
    writeUint32LE(value2, offset) {
      return this.writeUInt32LE(value2, offset);
    }
    readInt8(offset) {
      const val = this[offset];
      return val & 128 ? val - 256 : val;
    }
    readInt16BE(offset) {
      const val = this.readUInt16BE(offset);
      return val & 32768 ? val - 65536 : val;
    }
    readInt16LE(offset) {
      const val = this.readUInt16LE(offset);
      return val & 32768 ? val - 65536 : val;
    }
    readInt32BE(offset) {
      const val = this.readUInt32BE(offset);
      return val | 0;
    }
    readInt32LE(offset) {
      const val = this.readUInt32LE(offset);
      return val | 0;
    }
    writeInt8(value2, offset) {
      this[offset] = value2 & 255;
      return offset + 1;
    }
    writeInt16BE(value2, offset) {
      return this.writeUInt16BE(value2 & 65535, offset);
    }
    writeInt16LE(value2, offset) {
      return this.writeUInt16LE(value2 & 65535, offset);
    }
    writeInt32BE(value2, offset) {
      return this.writeUInt32BE(value2 >>> 0, offset);
    }
    writeInt32LE(value2, offset) {
      return this.writeUInt32LE(value2 >>> 0, offset);
    }
    readBigUInt64LE(offset) {
      const lo = BigInt(this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24) & 0xffffffffn;
      const hi = BigInt(this[offset + 4] | this[offset + 5] << 8 | this[offset + 6] << 16 | this[offset + 7] << 24) & 0xffffffffn;
      return lo | hi << 32n;
    }
    readBigUInt64BE(offset) {
      const hi = BigInt(this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]) & 0xffffffffn;
      const lo = BigInt(this[offset + 4] << 24 | this[offset + 5] << 16 | this[offset + 6] << 8 | this[offset + 7]) & 0xffffffffn;
      return lo | hi << 32n;
    }
    readBigInt64LE(offset) {
      const val = this.readBigUInt64LE(offset);
      if (val >= 0x8000000000000000n) {
        return val - 0x10000000000000000n;
      }
      return val;
    }
    readBigInt64BE(offset) {
      const val = this.readBigUInt64BE(offset);
      if (val >= 0x8000000000000000n) {
        return val - 0x10000000000000000n;
      }
      return val;
    }
    writeBigUInt64LE(value2, offset) {
      const lo = value2 & 0xffffffffn;
      const hi = value2 >> 32n & 0xffffffffn;
      this[offset] = Number(lo & 0xffn);
      this[offset + 1] = Number(lo >> 8n & 0xffn);
      this[offset + 2] = Number(lo >> 16n & 0xffn);
      this[offset + 3] = Number(lo >> 24n & 0xffn);
      this[offset + 4] = Number(hi & 0xffn);
      this[offset + 5] = Number(hi >> 8n & 0xffn);
      this[offset + 6] = Number(hi >> 16n & 0xffn);
      this[offset + 7] = Number(hi >> 24n & 0xffn);
      return offset + 8;
    }
    writeBigUInt64BE(value2, offset) {
      const lo = value2 & 0xffffffffn;
      const hi = value2 >> 32n & 0xffffffffn;
      this[offset] = Number(hi >> 24n & 0xffn);
      this[offset + 1] = Number(hi >> 16n & 0xffn);
      this[offset + 2] = Number(hi >> 8n & 0xffn);
      this[offset + 3] = Number(hi & 0xffn);
      this[offset + 4] = Number(lo >> 24n & 0xffn);
      this[offset + 5] = Number(lo >> 16n & 0xffn);
      this[offset + 6] = Number(lo >> 8n & 0xffn);
      this[offset + 7] = Number(lo & 0xffn);
      return offset + 8;
    }
    writeBigInt64LE(value2, offset) {
      const unsigned = value2 < 0n ? value2 + 0x10000000000000000n : value2;
      return this.writeBigUInt64LE(unsigned, offset);
    }
    writeBigInt64BE(value2, offset) {
      const unsigned = value2 < 0n ? value2 + 0x10000000000000000n : value2;
      return this.writeBigUInt64BE(unsigned, offset);
    }
    readBigUint64LE(offset) {
      return this.readBigUInt64LE(offset);
    }
    readBigUint64BE(offset) {
      return this.readBigUInt64BE(offset);
    }
    writeBigUint64LE(value2, offset) {
      return this.writeBigUInt64LE(value2, offset);
    }
    writeBigUint64BE(value2, offset) {
      return this.writeBigUInt64BE(value2, offset);
    }
    readFloatLE(offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 4);
      return view.getFloat32(0, true);
    }
    readFloatBE(offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 4);
      return view.getFloat32(0, false);
    }
    readDoubleLE(offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 8);
      return view.getFloat64(0, true);
    }
    readDoubleBE(offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 8);
      return view.getFloat64(0, false);
    }
    writeFloatLE(value2, offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 4);
      view.setFloat32(0, value2, true);
      return offset + 4;
    }
    writeFloatBE(value2, offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 4);
      view.setFloat32(0, value2, false);
      return offset + 4;
    }
    writeDoubleLE(value2, offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 8);
      view.setFloat64(0, value2, true);
      return offset + 8;
    }
    writeDoubleBE(value2, offset) {
      const view = new DataView(this.buffer, this.byteOffset + offset, 8);
      view.setFloat64(0, value2, false);
      return offset + 8;
    }
    readUIntLE(offset, byteLength) {
      let val = 0;
      let mul = 1;
      for (let i2 = 0; i2 < byteLength; i2++) {
        val += this[offset + i2] * mul;
        mul *= 256;
      }
      return val;
    }
    readUintLE(offset, byteLength) {
      return this.readUIntLE(offset, byteLength);
    }
    readUIntBE(offset, byteLength) {
      let val = 0;
      let mul = 1;
      for (let i2 = byteLength - 1; i2 >= 0; i2--) {
        val += this[offset + i2] * mul;
        mul *= 256;
      }
      return val;
    }
    readUintBE(offset, byteLength) {
      return this.readUIntBE(offset, byteLength);
    }
    readIntLE(offset, byteLength) {
      let val = this.readUIntLE(offset, byteLength);
      const limit = Math.pow(2, byteLength * 8 - 1);
      if (val >= limit) {
        val -= Math.pow(2, byteLength * 8);
      }
      return val;
    }
    readIntBE(offset, byteLength) {
      let val = this.readUIntBE(offset, byteLength);
      const limit = Math.pow(2, byteLength * 8 - 1);
      if (val >= limit) {
        val -= Math.pow(2, byteLength * 8);
      }
      return val;
    }
    writeUIntLE(value2, offset, byteLength) {
      let val = value2;
      for (let i2 = 0; i2 < byteLength; i2++) {
        this[offset + i2] = val & 255;
        val = Math.floor(val / 256);
      }
      return offset + byteLength;
    }
    writeUintLE(value2, offset, byteLength) {
      return this.writeUIntLE(value2, offset, byteLength);
    }
    writeUIntBE(value2, offset, byteLength) {
      let val = value2;
      for (let i2 = byteLength - 1; i2 >= 0; i2--) {
        this[offset + i2] = val & 255;
        val = Math.floor(val / 256);
      }
      return offset + byteLength;
    }
    writeUintBE(value2, offset, byteLength) {
      return this.writeUIntBE(value2, offset, byteLength);
    }
    writeIntLE(value2, offset, byteLength) {
      let val = value2;
      if (val < 0) {
        val += Math.pow(2, byteLength * 8);
      }
      return this.writeUIntLE(val, offset, byteLength);
    }
    writeIntBE(value2, offset, byteLength) {
      let val = value2;
      if (val < 0) {
        val += Math.pow(2, byteLength * 8);
      }
      return this.writeUIntBE(val, offset, byteLength);
    }
    swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 2) {
        const a = this[i2];
        this[i2] = this[i2 + 1];
        this[i2 + 1] = a;
      }
      return this;
    }
    swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 4) {
        const a = this[i2];
        const b = this[i2 + 1];
        this[i2] = this[i2 + 3];
        this[i2 + 1] = this[i2 + 2];
        this[i2 + 2] = b;
        this[i2 + 3] = a;
      }
      return this;
    }
    swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 8) {
        const a = this[i2];
        const b = this[i2 + 1];
        const c = this[i2 + 2];
        const d = this[i2 + 3];
        this[i2] = this[i2 + 7];
        this[i2 + 1] = this[i2 + 6];
        this[i2 + 2] = this[i2 + 5];
        this[i2 + 3] = this[i2 + 4];
        this[i2 + 4] = d;
        this[i2 + 5] = c;
        this[i2 + 6] = b;
        this[i2 + 7] = a;
      }
      return this;
    }
  };
  __publicField(_BufferPolyfill, "BYTES_PER_ELEMENT", 1);
  let BufferPolyfill = _BufferPolyfill;
  if (typeof globalThis.Buffer === "undefined") {
    globalThis.Buffer = BufferPolyfill;
  }
  Stream.pipeline = pipeline;
  Stream.finished = finished;
  Stream.promises = promises$2;
  stream = Object.freeze(Object.defineProperty({
    __proto__: null,
    Buffer: BufferPolyfill,
    Duplex,
    PassThrough,
    Readable,
    Stream,
    Transform,
    Writable,
    default: Stream,
    finished,
    pipeline,
    promises: promises$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  let Socket$1 = class Socket extends Duplex {
    constructor(options2) {
      super();
      __publicField(this, "_connecting", false);
      __publicField(this, "_connected", false);
      __publicField(this, "_destroyed", false);
      __publicField(this, "_remoteAddress", "");
      __publicField(this, "_remotePort", 0);
      __publicField(this, "_localAddress", "127.0.0.1");
      __publicField(this, "_localPort", 0);
      __publicField(this, "localAddress", "127.0.0.1");
      __publicField(this, "localPort", 0);
      __publicField(this, "remoteAddress");
      __publicField(this, "remotePort");
      __publicField(this, "remoteFamily");
      __publicField(this, "connecting", false);
      __publicField(this, "destroyed", false);
      __publicField(this, "readyState", "closed");
    }
    connect(portOrOptions, hostOrCallback, callback) {
      let port;
      let host = "127.0.0.1";
      let cb;
      if (typeof portOrOptions === "number") {
        port = portOrOptions;
        if (typeof hostOrCallback === "string") {
          host = hostOrCallback;
          cb = callback;
        } else {
          cb = hostOrCallback;
        }
      } else {
        port = portOrOptions.port;
        host = portOrOptions.host || "127.0.0.1";
        cb = typeof hostOrCallback === "function" ? hostOrCallback : callback;
      }
      this._connecting = true;
      this.connecting = true;
      this._remoteAddress = host;
      this._remotePort = port;
      this.remoteAddress = host;
      this.remotePort = port;
      this.remoteFamily = "IPv4";
      this.readyState = "opening";
      queueMicrotask(() => {
        this._connecting = false;
        this._connected = true;
        this.connecting = false;
        this.readyState = "open";
        this.emit("connect");
        if (cb) cb();
      });
      return this;
    }
    address() {
      if (!this._connected) return null;
      return {
        address: this._localAddress,
        family: "IPv4",
        port: this._localPort
      };
    }
    setEncoding(encoding) {
      return this;
    }
    setTimeout(timeout, callback) {
      if (callback) {
        this.once("timeout", callback);
      }
      return this;
    }
    setNoDelay(noDelay) {
      return this;
    }
    setKeepAlive(enable, initialDelay) {
      return this;
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    destroy(error) {
      if (this._destroyed) return this;
      this._destroyed = true;
      this._connected = false;
      this.destroyed = true;
      this.readyState = "closed";
      if (error) {
        this.emit("error", error);
      }
      queueMicrotask(() => {
        this.emit("close", !!error);
      });
      return this;
    }
    _receiveData(data2) {
      const buffer2 = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
      this.push(buffer2);
    }
    _receiveEnd() {
      this.push(null);
    }
  };
  let Server$3 = class Server extends EventEmitter {
    constructor(optionsOrConnectionListener, connectionListener) {
      super();
      __publicField(this, "_listening", false);
      __publicField(this, "_address", null);
      __publicField(this, "_connections", /* @__PURE__ */ new Set());
      __publicField(this, "_maxConnections", Infinity);
      __publicField(this, "listening", false);
      __publicField(this, "maxConnections");
      let listener;
      if (typeof optionsOrConnectionListener === "function") {
        listener = optionsOrConnectionListener;
      } else {
        listener = connectionListener;
      }
      if (listener) {
        this.on("connection", listener);
      }
    }
    listen(portOrOptions, hostOrCallback, backlogOrCallback, callback) {
      let port = 0;
      let host = "0.0.0.0";
      let cb;
      if (typeof portOrOptions === "number") {
        port = portOrOptions;
        if (typeof hostOrCallback === "string") {
          host = hostOrCallback;
          if (typeof backlogOrCallback === "function") {
            cb = backlogOrCallback;
          } else {
            cb = callback;
          }
        } else if (typeof hostOrCallback === "function") {
          cb = hostOrCallback;
        } else if (typeof hostOrCallback === "number") {
          cb = typeof backlogOrCallback === "function" ? backlogOrCallback : callback;
        } else {
          if (typeof backlogOrCallback === "function") {
            cb = backlogOrCallback;
          } else if (typeof callback === "function") {
            cb = callback;
          }
        }
      } else if (portOrOptions) {
        port = portOrOptions.port || 0;
        host = portOrOptions.host || "0.0.0.0";
        cb = typeof hostOrCallback === "function" ? hostOrCallback : callback;
      }
      if (port === 0) {
        port = 3e3 + Math.floor(Math.random() * 1e3);
      }
      this._address = {
        address: host,
        family: "IPv4",
        port
      };
      this._listening = true;
      this.listening = true;
      queueMicrotask(() => {
        this.emit("listening");
        if (cb) cb();
      });
      return this;
    }
    address() {
      return this._address;
    }
    close(callback) {
      this._listening = false;
      this.listening = false;
      for (const socket of this._connections) {
        socket.destroy();
      }
      this._connections.clear();
      queueMicrotask(() => {
        this.emit("close");
        if (callback) callback();
      });
      return this;
    }
    getConnections(callback) {
      callback(null, this._connections.size);
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    _handleConnection(socket) {
      if (!this._listening) {
        socket.destroy();
        return;
      }
      this._connections.add(socket);
      socket.on("close", () => {
        this._connections.delete(socket);
      });
      this.emit("connection", socket);
    }
  };
  function createServer$3(optionsOrConnectionListener, connectionListener) {
    return new Server$3(optionsOrConnectionListener, connectionListener);
  }
  function createConnection(portOrOptions, hostOrCallback, callback) {
    const socket = new Socket$1();
    return socket.connect(portOrOptions, hostOrCallback, callback);
  }
  const connect$2 = createConnection;
  function isIP(input) {
    if (/^(\d{1,3}\.){3}\d{1,3}$/.test(input)) {
      return 4;
    }
    if (/^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/.test(input)) {
      return 6;
    }
    return 0;
  }
  function isIPv4(input) {
    return isIP(input) === 4;
  }
  function isIPv6(input) {
    return isIP(input) === 6;
  }
  const net = {
    Socket: Socket$1,
    Server: Server$3,
    createServer: createServer$3,
    createConnection,
    connect: connect$2,
    isIP,
    isIPv4,
    isIPv6
  };
  netShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Server: Server$3,
    Socket: Socket$1,
    connect: connect$2,
    createConnection,
    createServer: createServer$3,
    default: net,
    isIP,
    isIPv4,
    isIPv6
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function randomBytes(size) {
    const array = new Uint8Array(size);
    crypto.getRandomValues(array);
    return BufferPolyfill.from(array);
  }
  function randomFillSync(buffer2, offset, size) {
    const start = offset || 0;
    const len = size !== void 0 ? size : buffer2.length - start;
    const view = new Uint8Array(buffer2.buffer, buffer2.byteOffset + start, len);
    crypto.getRandomValues(view);
    return buffer2;
  }
  function randomUUID() {
    return crypto.randomUUID();
  }
  function randomInt(min, max) {
    if (max === void 0) {
      max = min;
      min = 0;
    }
    const range = max - min;
    const array = new Uint32Array(1);
    crypto.getRandomValues(array);
    return min + array[0] % range;
  }
  function getRandomValues(array) {
    return crypto.getRandomValues(array);
  }
  function createHash(algorithm) {
    return new Hash$2(algorithm);
  }
  let Hash$2 = class Hash {
    constructor(algorithm) {
      __publicField(this, "algorithm");
      __publicField(this, "data", []);
      this.algorithm = normalizeHashAlgorithm(algorithm);
    }
    update(data2, encoding) {
      let buffer2;
      if (typeof data2 === "string") {
        if (encoding === "base64") {
          buffer2 = BufferPolyfill.from(atob(data2));
        } else {
          buffer2 = BufferPolyfill.from(data2);
        }
      } else {
        buffer2 = data2;
      }
      this.data.push(buffer2);
      return this;
    }
    async digestAsync(encoding) {
      const combined = concatBuffers(this.data);
      const dataBuffer = new Uint8Array(combined).buffer;
      const hashBuffer = await crypto.subtle.digest(this.algorithm, dataBuffer);
      return encodeResult(new Uint8Array(hashBuffer), encoding);
    }
    digest(encoding) {
      const combined = concatBuffers(this.data);
      const hash = syncHash(combined, this.algorithm);
      return encodeResult(hash, encoding);
    }
  };
  function createHmac(algorithm, key) {
    return new Hmac(algorithm, key);
  }
  class Hmac {
    constructor(algorithm, key) {
      __publicField(this, "algorithm");
      __publicField(this, "key");
      __publicField(this, "data", []);
      this.algorithm = normalizeHashAlgorithm(algorithm);
      this.key = typeof key === "string" ? BufferPolyfill.from(key) : key;
    }
    update(data2, encoding) {
      const buffer2 = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
      this.data.push(buffer2);
      return this;
    }
    async digestAsync(encoding) {
      const combined = concatBuffers(this.data);
      const keyBuffer = new Uint8Array(this.key).buffer;
      const dataBuffer = new Uint8Array(combined).buffer;
      const cryptoKey = await crypto.subtle.importKey("raw", keyBuffer, {
        name: "HMAC",
        hash: this.algorithm
      }, false, [
        "sign"
      ]);
      const signature = await crypto.subtle.sign("HMAC", cryptoKey, dataBuffer);
      return encodeResult(new Uint8Array(signature), encoding);
    }
    digest(encoding) {
      const combined = concatBuffers(this.data);
      const hash = syncHmac(combined, this.key, this.algorithm);
      return encodeResult(hash, encoding);
    }
  }
  async function pbkdf2Async(password, salt, iterations, keylen, digest) {
    const passwordBuffer = typeof password === "string" ? BufferPolyfill.from(password) : password instanceof Uint8Array ? password : BufferPolyfill.from(password);
    const saltBuffer = typeof salt === "string" ? BufferPolyfill.from(salt) : salt instanceof Uint8Array ? salt : BufferPolyfill.from(salt);
    const passwordArrayBuffer = new Uint8Array(passwordBuffer).buffer;
    const saltArrayBuffer = new Uint8Array(saltBuffer).buffer;
    const key = await crypto.subtle.importKey("raw", passwordArrayBuffer, "PBKDF2", false, [
      "deriveBits"
    ]);
    const derivedBits = await crypto.subtle.deriveBits({
      name: "PBKDF2",
      salt: saltArrayBuffer,
      iterations,
      hash: normalizeHashAlgorithm(digest)
    }, key, keylen * 8);
    return BufferPolyfill.from(derivedBits);
  }
  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
    pbkdf2Async(password, salt, iterations, keylen, digest).then((key) => callback(null, key)).catch((err) => callback(err, BufferPolyfill.alloc(0)));
  }
  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
    const passwordBuffer = typeof password === "string" ? BufferPolyfill.from(password) : password;
    const saltBuffer = typeof salt === "string" ? BufferPolyfill.from(salt) : salt;
    const hashAlg = normalizeHashAlgorithm(digest);
    let hashLen;
    if (hashAlg.includes("512")) {
      hashLen = 64;
    } else if (hashAlg.includes("384")) {
      hashLen = 48;
    } else if (hashAlg.includes("1") || hashAlg === "SHA-1") {
      hashLen = 20;
    } else {
      hashLen = 32;
    }
    const numBlocks = Math.ceil(keylen / hashLen);
    const derivedKey = new Uint8Array(numBlocks * hashLen);
    for (let blockNum = 1; blockNum <= numBlocks; blockNum++) {
      const blockNumBuf = new Uint8Array(4);
      blockNumBuf[0] = blockNum >>> 24 & 255;
      blockNumBuf[1] = blockNum >>> 16 & 255;
      blockNumBuf[2] = blockNum >>> 8 & 255;
      blockNumBuf[3] = blockNum & 255;
      const saltWithBlock = new Uint8Array(saltBuffer.length + 4);
      saltWithBlock.set(saltBuffer);
      saltWithBlock.set(blockNumBuf, saltBuffer.length);
      let u = syncHmac(saltWithBlock, passwordBuffer, hashAlg);
      const block = new Uint8Array(u);
      for (let i2 = 1; i2 < iterations; i2++) {
        u = syncHmac(u, passwordBuffer, hashAlg);
        for (let j = 0; j < block.length; j++) {
          block[j] ^= u[j];
        }
      }
      derivedKey.set(block, (blockNum - 1) * hashLen);
    }
    return BufferPolyfill.from(derivedKey.slice(0, keylen));
  }
  function sign(algorithm, data2, key, callback) {
    const keyInfo = extractKeyInfo(key);
    const alg = algorithm || keyInfo.algorithm;
    if (!alg) {
      const error = new Error("Algorithm must be specified");
      if (callback) {
        callback(error, null);
        return;
      }
      throw error;
    }
    if (callback) {
      signAsync(alg, data2, keyInfo).then((sig) => callback(null, sig)).catch((err) => callback(err, null));
      return;
    }
    const result = signSync(alg, data2, keyInfo);
    return result;
  }
  function verify(algorithm, data2, key, signature, callback) {
    const keyInfo = extractKeyInfo(key);
    const alg = algorithm || keyInfo.algorithm;
    if (!alg) {
      const error = new Error("Algorithm must be specified");
      if (callback) {
        callback(error, false);
        return;
      }
      throw error;
    }
    if (callback) {
      verifyAsync(alg, data2, keyInfo, signature).then((result) => callback(null, result)).catch((err) => callback(err, false));
      return;
    }
    return verifySync(alg, data2, keyInfo, signature);
  }
  function createSign(algorithm) {
    return new Sign(algorithm);
  }
  function createVerify(algorithm) {
    return new Verify(algorithm);
  }
  class Sign extends EventEmitter {
    constructor(algorithm) {
      super();
      __publicField(this, "algorithm");
      __publicField(this, "data", []);
      this.algorithm = algorithm;
    }
    update(data2, encoding) {
      const buffer2 = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
      this.data.push(buffer2);
      return this;
    }
    sign(privateKey, outputEncoding) {
      const combined = concatBuffers(this.data);
      const keyInfo = extractKeyInfo(privateKey);
      const signature = signSync(this.algorithm, combined, keyInfo);
      if (outputEncoding === "base64") {
        return btoa(String.fromCharCode(...signature));
      }
      if (outputEncoding === "hex") {
        return Array.from(signature).map((b) => b.toString(16).padStart(2, "0")).join("");
      }
      return signature;
    }
  }
  class Verify extends EventEmitter {
    constructor(algorithm) {
      super();
      __publicField(this, "algorithm");
      __publicField(this, "data", []);
      this.algorithm = algorithm;
    }
    update(data2, encoding) {
      const buffer2 = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
      this.data.push(buffer2);
      return this;
    }
    verify(publicKey, signature, signatureEncoding) {
      const combined = concatBuffers(this.data);
      const keyInfo = extractKeyInfo(publicKey);
      let sig;
      if (typeof signature === "string") {
        if (signatureEncoding === "base64") {
          sig = BufferPolyfill.from(atob(signature));
        } else if (signatureEncoding === "hex") {
          sig = BufferPolyfill.from(signature.match(/.{2}/g).map((byte) => parseInt(byte, 16)));
        } else {
          sig = BufferPolyfill.from(signature);
        }
      } else {
        sig = signature;
      }
      return verifySync(this.algorithm, combined, keyInfo, sig);
    }
  }
  class KeyObject {
    constructor(type2, keyData, algorithm) {
      __publicField(this, "_keyData");
      __publicField(this, "_type");
      __publicField(this, "_algorithm");
      this._type = type2;
      this._keyData = keyData;
      this._algorithm = algorithm;
    }
    get type() {
      return this._type;
    }
    get asymmetricKeyType() {
      var _a2, _b2, _c2, _d;
      if (this._type === "secret") return void 0;
      if ((_a2 = this._algorithm) == null ? void 0 : _a2.includes("RSA")) return "rsa";
      if (((_b2 = this._algorithm) == null ? void 0 : _b2.includes("EC")) || ((_c2 = this._algorithm) == null ? void 0 : _c2.includes("ES"))) return "ec";
      if ((_d = this._algorithm) == null ? void 0 : _d.includes("Ed")) return "ed25519";
      return void 0;
    }
    get symmetricKeySize() {
      if (this._type !== "secret") return void 0;
      if (this._keyData instanceof Uint8Array) {
        return this._keyData.length * 8;
      }
      return void 0;
    }
    export(options2) {
      if (this._keyData instanceof Uint8Array) {
        return BufferPolyfill.from(this._keyData);
      }
      throw new Error("Cannot export CryptoKey synchronously");
    }
  }
  function createSecretKey(key, encoding) {
    const keyBuffer = typeof key === "string" ? BufferPolyfill.from(key, encoding) : key;
    return new KeyObject("secret", keyBuffer);
  }
  function createPublicKey(key) {
    const keyInfo = extractKeyInfo(key);
    return new KeyObject("public", keyInfo.keyData, keyInfo.algorithm);
  }
  function createPrivateKey(key) {
    const keyInfo = extractKeyInfo(key);
    return new KeyObject("private", keyInfo.keyData, keyInfo.algorithm);
  }
  function timingSafeEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    let result = 0;
    for (let i2 = 0; i2 < a.length; i2++) {
      result |= a[i2] ^ b[i2];
    }
    return result === 0;
  }
  function getCiphers$1() {
    return [
      "aes-128-cbc",
      "aes-256-cbc",
      "aes-128-gcm",
      "aes-256-gcm"
    ];
  }
  function getHashes() {
    return [
      "sha1",
      "sha256",
      "sha384",
      "sha512"
    ];
  }
  const constants$5 = {
    SSL_OP_ALL: 0,
    RSA_PKCS1_PADDING: 1,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_PKCS1_PSS_PADDING: 6
  };
  function normalizeHashAlgorithm(alg) {
    const normalized = alg.toUpperCase().replace(/[^A-Z0-9]/g, "");
    switch (normalized) {
      case "SHA1":
        return "SHA-1";
      case "SHA256":
        return "SHA-256";
      case "SHA384":
        return "SHA-384";
      case "SHA512":
        return "SHA-512";
      case "MD5":
        return "MD5";
      default:
        return alg;
    }
  }
  function getWebCryptoAlgorithm(nodeAlgorithm) {
    var _a2, _b2, _c2, _d;
    const alg = nodeAlgorithm.toUpperCase().replace(/[^A-Z0-9]/g, "");
    if (alg.includes("RSA")) {
      if (alg.includes("PSS")) {
        const hash2 = ((_a2 = alg.match(/SHA(\d+)/)) == null ? void 0 : _a2[0]) || "SHA-256";
        return {
          name: "RSA-PSS",
          hash: `SHA-${hash2.replace("SHA", "")}`
        };
      }
      const hash = ((_b2 = alg.match(/SHA(\d+)/)) == null ? void 0 : _b2[0]) || "SHA-256";
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: `SHA-${hash.replace("SHA", "")}`
      };
    }
    if (alg.startsWith("ES") || alg.includes("ECDSA")) {
      const bits = ((_c2 = alg.match(/\d+/)) == null ? void 0 : _c2[0]) || "256";
      const hash = bits === "512" ? "SHA-512" : bits === "384" ? "SHA-384" : "SHA-256";
      return {
        name: "ECDSA",
        hash
      };
    }
    if (alg.includes("ED25519") || alg === "EDDSA") {
      return {
        name: "Ed25519"
      };
    }
    if (alg.includes("HS") || alg.includes("HMAC")) {
      const bits = ((_d = alg.match(/\d+/)) == null ? void 0 : _d[0]) || "256";
      return {
        name: "HMAC",
        hash: `SHA-${bits}`
      };
    }
    return {
      name: "RSASSA-PKCS1-v1_5",
      hash: "SHA-256"
    };
  }
  function extractKeyInfo(key) {
    if (key instanceof KeyObject) {
      return {
        keyData: key._keyData,
        algorithm: key._algorithm,
        type: key._type,
        format: "raw"
      };
    }
    if (typeof key === "object" && "key" in key) {
      return extractKeyInfo(key.key);
    }
    const keyStr = typeof key === "string" ? key : key.toString();
    if (keyStr.includes("-----BEGIN")) {
      const isPrivate = keyStr.includes("PRIVATE");
      const isPublic = keyStr.includes("PUBLIC");
      const base642 = keyStr.replace(/-----BEGIN [^-]+-----/, "").replace(/-----END [^-]+-----/, "").replace(/\s/g, "");
      const keyData2 = BufferPolyfill.from(atob(base642));
      let algorithm;
      if (keyStr.includes("RSA")) algorithm = "RSA-SHA256";
      else if (keyStr.includes("EC")) algorithm = "ES256";
      else if (keyStr.includes("ED25519")) algorithm = "Ed25519";
      return {
        keyData: keyData2,
        algorithm,
        type: isPrivate ? "private" : isPublic ? "public" : "secret",
        format: "pem"
      };
    }
    const keyData = typeof key === "string" ? BufferPolyfill.from(key) : key;
    return {
      keyData,
      type: "secret",
      format: "raw"
    };
  }
  function concatBuffers(buffers) {
    const totalLength = buffers.reduce((acc, arr) => acc + arr.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const buf of buffers) {
      result.set(buf, offset);
      offset += buf.length;
    }
    return result;
  }
  function encodeResult(data2, encoding) {
    if (encoding === "hex") {
      return Array.from(data2).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    if (encoding === "base64") {
      return btoa(String.fromCharCode(...data2));
    }
    return BufferPolyfill.from(data2);
  }
  function syncHash(data2, algorithm) {
    let size;
    if (algorithm.includes("512")) {
      size = 64;
    } else if (algorithm.includes("384")) {
      size = 48;
    } else if (algorithm.includes("1") || algorithm === "SHA-1") {
      size = 20;
    } else {
      size = 32;
    }
    const result = new Uint8Array(size);
    let h1 = 3735928559;
    let h2 = 1103547991;
    for (let i2 = 0; i2 < data2.length; i2++) {
      h1 = Math.imul(h1 ^ data2[i2], 2654435761);
      h2 = Math.imul(h2 ^ data2[i2], 1597334677);
    }
    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
    for (let i2 = 0; i2 < size; i2++) {
      const mix2 = i2 < size / 2 ? h1 : h2;
      result[i2] = mix2 >>> i2 % 4 * 8 & 255;
      h1 = Math.imul(h1, 1103515245) + 12345;
      h2 = Math.imul(h2, 1103515245) + 12345;
    }
    return result;
  }
  function syncHmac(data2, key, algorithm) {
    const combined = new Uint8Array(key.length + data2.length);
    combined.set(key, 0);
    combined.set(data2, key.length);
    return syncHash(combined, algorithm);
  }
  async function signAsync(algorithm, data2, keyInfo) {
    const webCryptoAlg = getWebCryptoAlgorithm(algorithm);
    try {
      const cryptoKey = await importKey(keyInfo, webCryptoAlg, [
        "sign"
      ]);
      const signatureAlg = webCryptoAlg.hash ? {
        name: webCryptoAlg.name,
        hash: webCryptoAlg.hash
      } : {
        name: webCryptoAlg.name
      };
      const dataBuffer = new Uint8Array(data2).buffer;
      const signature = await crypto.subtle.sign(signatureAlg, cryptoKey, dataBuffer);
      return BufferPolyfill.from(signature);
    } catch (error) {
      console.warn("WebCrypto sign failed, using fallback:", error);
      return signSync(algorithm, data2, keyInfo);
    }
  }
  async function verifyAsync(algorithm, data2, keyInfo, signature) {
    const webCryptoAlg = getWebCryptoAlgorithm(algorithm);
    try {
      const cryptoKey = await importKey(keyInfo, webCryptoAlg, [
        "verify"
      ]);
      const verifyAlg = webCryptoAlg.hash ? {
        name: webCryptoAlg.name,
        hash: webCryptoAlg.hash
      } : {
        name: webCryptoAlg.name
      };
      const sigBuffer = new Uint8Array(signature).buffer;
      const dataBuffer = new Uint8Array(data2).buffer;
      return await crypto.subtle.verify(verifyAlg, cryptoKey, sigBuffer, dataBuffer);
    } catch (error) {
      console.warn("WebCrypto verify failed, using fallback:", error);
      return verifySync(algorithm, data2, keyInfo, signature);
    }
  }
  function signSync(algorithm, data2, keyInfo) {
    const keyData = keyInfo.keyData instanceof Uint8Array ? keyInfo.keyData : new Uint8Array(0);
    const combined = new Uint8Array(keyData.length + data2.length);
    combined.set(keyData, 0);
    combined.set(data2, keyData.length);
    const hash = syncHash(combined, algorithm);
    return BufferPolyfill.from(hash);
  }
  function verifySync(algorithm, data2, keyInfo, signature) {
    const expectedSig = signSync(algorithm, data2, keyInfo);
    return timingSafeEqual(BufferPolyfill.from(signature), expectedSig);
  }
  async function importKey(keyInfo, algorithm, usages) {
    if (keyInfo.keyData instanceof CryptoKey) {
      return keyInfo.keyData;
    }
    const keyData = keyInfo.keyData;
    const keyBuffer = new Uint8Array(keyData).buffer;
    if (keyInfo.format === "pem") {
      const format2 = keyInfo.type === "private" ? "pkcs8" : "spki";
      const importAlg = algorithm.name === "ECDSA" ? {
        name: "ECDSA",
        namedCurve: "P-256"
      } : algorithm.name === "Ed25519" ? {
        name: "Ed25519"
      } : {
        name: algorithm.name,
        hash: algorithm.hash || "SHA-256"
      };
      return await crypto.subtle.importKey(format2, keyBuffer, importAlg, true, usages);
    }
    if (keyInfo.type === "secret") {
      return await crypto.subtle.importKey("raw", keyBuffer, {
        name: algorithm.name,
        hash: algorithm.hash
      }, true, usages);
    }
    throw new Error(`Unsupported key format: ${keyInfo.format}`);
  }
  const crypto$1 = {
    randomBytes,
    randomFillSync,
    randomUUID,
    randomInt,
    getRandomValues,
    createHash,
    createHmac,
    createSign,
    createVerify,
    sign,
    verify,
    pbkdf2,
    pbkdf2Sync,
    timingSafeEqual,
    getCiphers: getCiphers$1,
    getHashes,
    constants: constants$5,
    KeyObject,
    createSecretKey,
    createPublicKey,
    createPrivateKey
  };
  const cryptoShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    KeyObject,
    constants: constants$5,
    createHash,
    createHmac,
    createPrivateKey,
    createPublicKey,
    createSecretKey,
    createSign,
    createVerify,
    default: crypto$1,
    getCiphers: getCiphers$1,
    getHashes,
    getRandomValues,
    pbkdf2,
    pbkdf2Sync,
    randomBytes,
    randomFillSync,
    randomInt,
    randomUUID,
    sign,
    timingSafeEqual,
    verify
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const _isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  const _BrowserWebSocket = _isBrowser && typeof globalThis.WebSocket === "function" ? globalThis.WebSocket : null;
  class IncomingMessage extends Readable {
    constructor(socket) {
      super();
      __publicField(this, "httpVersion", "1.1");
      __publicField(this, "httpVersionMajor", 1);
      __publicField(this, "httpVersionMinor", 1);
      __publicField(this, "complete", false);
      __publicField(this, "headers", {});
      __publicField(this, "rawHeaders", []);
      __publicField(this, "trailers", {});
      __publicField(this, "rawTrailers", []);
      __publicField(this, "method");
      __publicField(this, "url");
      __publicField(this, "statusCode");
      __publicField(this, "statusMessage");
      __publicField(this, "socket");
      __publicField(this, "_body", null);
      this.socket = socket || new Socket$1();
    }
    setTimeout(msecs, callback) {
      if (callback) {
        this.once("timeout", callback);
      }
      return this;
    }
    destroy(error) {
      super.destroy(error);
      return this;
    }
    _setBody(body) {
      if (body === null) {
        this._body = null;
      } else {
        this._body = typeof body === "string" ? BufferPolyfill.from(body) : body;
      }
      if (this._body) {
        this.push(this._body);
      }
      this.push(null);
      this.complete = true;
    }
    static fromRequest(method, url2, headers, body) {
      const msg = new IncomingMessage();
      msg.method = method;
      msg.url = url2;
      msg.headers = {
        ...headers
      };
      for (const [key, value2] of Object.entries(headers)) {
        msg.rawHeaders.push(key, value2);
      }
      if (body) {
        msg._setBody(body);
      } else {
        msg.push(null);
        msg.complete = true;
      }
      return msg;
    }
  }
  class ServerResponse extends Writable {
    constructor(req) {
      super();
      __publicField(this, "statusCode", 200);
      __publicField(this, "statusMessage", "OK");
      __publicField(this, "headersSent", false);
      __publicField(this, "finished", false);
      __publicField(this, "sendDate", true);
      __publicField(this, "socket");
      __publicField(this, "_headers", /* @__PURE__ */ new Map());
      __publicField(this, "_body", []);
      __publicField(this, "_resolve");
      this.socket = req.socket;
    }
    _setResolver(resolve2) {
      this._resolve = resolve2;
    }
    setHeader(name2, value2) {
      if (this.headersSent) {
        throw new Error("Cannot set headers after they are sent");
      }
      this._headers.set(name2.toLowerCase(), String(value2));
      return this;
    }
    getHeader(name2) {
      return this._headers.get(name2.toLowerCase());
    }
    getHeaders() {
      const headers = {};
      for (const [key, value2] of this._headers) {
        headers[key] = value2;
      }
      return headers;
    }
    getHeaderNames() {
      return [
        ...this._headers.keys()
      ];
    }
    hasHeader(name2) {
      return this._headers.has(name2.toLowerCase());
    }
    removeHeader(name2) {
      if (this.headersSent) {
        throw new Error("Cannot remove headers after they are sent");
      }
      this._headers.delete(name2.toLowerCase());
    }
    writeHead(statusCode, statusMessageOrHeaders, headers) {
      this.statusCode = statusCode;
      if (typeof statusMessageOrHeaders === "string") {
        this.statusMessage = statusMessageOrHeaders;
        if (headers) {
          for (const [key, value2] of Object.entries(headers)) {
            this.setHeader(key, value2);
          }
        }
      } else if (statusMessageOrHeaders) {
        for (const [key, value2] of Object.entries(statusMessageOrHeaders)) {
          this.setHeader(key, value2);
        }
      }
      return this;
    }
    write(chunk, encodingOrCallback, callback) {
      this.headersSent = true;
      const buffer2 = typeof chunk === "string" ? BufferPolyfill.from(chunk) : chunk;
      this._body.push(buffer2);
      const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      if (cb) {
        queueMicrotask(() => cb(null));
      }
      return true;
    }
    end(chunkOrCallback, encodingOrCallback, callback) {
      if (typeof chunkOrCallback === "function") {
        callback = chunkOrCallback;
      } else if (chunkOrCallback !== void 0) {
        this.write(chunkOrCallback);
      }
      if (typeof encodingOrCallback === "function") {
        callback = encodingOrCallback;
      }
      this.headersSent = true;
      this.finished = true;
      if (this._resolve) {
        const headers = {};
        for (const [key, value2] of this._headers) {
          headers[key] = Array.isArray(value2) ? value2.join(", ") : value2;
        }
        this._resolve({
          statusCode: this.statusCode,
          statusMessage: this.statusMessage,
          headers,
          body: BufferPolyfill.concat(this._body)
        });
      }
      queueMicrotask(() => {
        this.emit("finish");
        if (callback) callback();
      });
      return this;
    }
    send(data2) {
      if (typeof data2 === "object" && !BufferPolyfill.isBuffer(data2)) {
        this.setHeader("Content-Type", "application/json");
        data2 = JSON.stringify(data2);
      }
      if (!this.hasHeader("Content-Type")) {
        this.setHeader("Content-Type", "text/html");
      }
      this.write(typeof data2 === "string" ? data2 : data2);
      return this.end();
    }
    json(data2) {
      this.setHeader("Content-Type", "application/json");
      return this.end(JSON.stringify(data2));
    }
    status(code2) {
      this.statusCode = code2;
      return this;
    }
    redirect(urlOrStatus, url2) {
      if (typeof urlOrStatus === "number") {
        this.statusCode = urlOrStatus;
        this.setHeader("Location", url2);
      } else {
        this.statusCode = 302;
        this.setHeader("Location", urlOrStatus);
      }
      this.end();
    }
    _getBody() {
      return BufferPolyfill.concat(this._body);
    }
    _getBodyAsString() {
      return this._getBody().toString("utf8");
    }
  }
  let Server$2 = class Server extends EventEmitter {
    constructor(requestListener) {
      super();
      __publicField(this, "_netServer");
      __publicField(this, "_requestListener");
      __publicField(this, "_pendingRequests", /* @__PURE__ */ new Map());
      __publicField(this, "listening", false);
      __publicField(this, "maxHeadersCount", null);
      __publicField(this, "timeout", 0);
      __publicField(this, "keepAliveTimeout", 5e3);
      __publicField(this, "headersTimeout", 6e4);
      __publicField(this, "requestTimeout", 0);
      this._requestListener = requestListener;
      this._netServer = new Server$3();
      this._netServer.on("listening", () => {
        this.listening = true;
        this.emit("listening");
      });
      this._netServer.on("close", () => {
        this.listening = false;
        this.emit("close");
      });
      this._netServer.on("error", (err) => {
        this.emit("error", err);
      });
    }
    listen(portOrOptions, hostOrCallback, callback) {
      let port;
      let host;
      let cb;
      if (typeof portOrOptions === "number") {
        port = portOrOptions;
        if (typeof hostOrCallback === "string") {
          host = hostOrCallback;
          cb = callback;
        } else {
          cb = hostOrCallback;
        }
      } else if (portOrOptions) {
        port = portOrOptions.port;
        host = portOrOptions.host;
        cb = typeof hostOrCallback === "function" ? hostOrCallback : callback;
      }
      const originalCb = cb;
      const self = this;
      cb = function() {
        const addr = self._netServer.address();
        if (addr) {
          _registerServer(addr.port, self);
        }
        if (originalCb) originalCb();
      };
      this._netServer.listen(port, host, cb);
      return this;
    }
    close(callback) {
      const addr = this._netServer.address();
      if (addr) {
        _unregisterServer(addr.port);
      }
      this._netServer.close(callback);
      return this;
    }
    address() {
      return this._netServer.address();
    }
    setTimeout(msecs, callback) {
      this.timeout = msecs || 0;
      if (callback) {
        this.on("timeout", callback);
      }
      return this;
    }
    ref() {
      this._netServer.ref();
      return this;
    }
    unref() {
      this._netServer.unref();
      return this;
    }
    async handleRequest(method, url2, headers, body) {
      return new Promise((resolve2, reject) => {
        const req = IncomingMessage.fromRequest(method, url2, headers, body);
        const res = new ServerResponse(req);
        res._setResolver(resolve2);
        const timeoutId = this.timeout ? setTimeout(() => {
          reject(new Error("Request timeout"));
        }, this.timeout) : null;
        res.on("finish", () => {
          if (timeoutId) clearTimeout(timeoutId);
        });
        try {
          this.emit("request", req, res);
          if (this._requestListener) {
            this._requestListener(req, res);
          }
        } catch (error) {
          if (timeoutId) clearTimeout(timeoutId);
          reject(error);
        }
      });
    }
  };
  function createServer$2(requestListener) {
    return new Server$2(requestListener);
  }
  const STATUS_CODES = {
    100: "Continue",
    101: "Switching Protocols",
    200: "OK",
    201: "Created",
    202: "Accepted",
    204: "No Content",
    301: "Moved Permanently",
    302: "Found",
    304: "Not Modified",
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    408: "Request Timeout",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable"
  };
  const METHODS = [
    "GET",
    "POST",
    "PUT",
    "DELETE",
    "PATCH",
    "HEAD",
    "OPTIONS",
    "CONNECT",
    "TRACE"
  ];
  function getCorsProxy() {
    if (typeof localStorage !== "undefined") {
      return localStorage.getItem("__corsProxyUrl") || null;
    }
    return null;
  }
  class ClientRequest extends Writable {
    constructor(options2, protocol = "http") {
      super();
      __publicField(this, "method");
      __publicField(this, "path");
      __publicField(this, "headers");
      __publicField(this, "_options");
      __publicField(this, "_protocol");
      __publicField(this, "_bodyChunks", []);
      __publicField(this, "_aborted", false);
      __publicField(this, "_timeout", null);
      __publicField(this, "_timeoutId", null);
      __publicField(this, "_requestEnded", false);
      this._options = options2;
      this._protocol = protocol;
      this.method = options2.method || "GET";
      this.path = options2.path || "/";
      this.headers = {};
      if (options2.headers) {
        for (const [key, value2] of Object.entries(options2.headers)) {
          this.headers[key.toLowerCase()] = Array.isArray(value2) ? value2.join(", ") : value2;
        }
      }
    }
    setHeader(name2, value2) {
      this.headers[name2.toLowerCase()] = value2;
    }
    getHeader(name2) {
      return this.headers[name2.toLowerCase()];
    }
    removeHeader(name2) {
      delete this.headers[name2.toLowerCase()];
    }
    write(chunk, encodingOrCallback, callback) {
      const buffer2 = typeof chunk === "string" ? BufferPolyfill.from(chunk) : chunk;
      this._bodyChunks.push(buffer2);
      const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      if (cb) {
        queueMicrotask(() => cb(null));
      }
      return true;
    }
    end(dataOrCallback, encodingOrCallback, callback) {
      if (this._requestEnded) return this;
      this._requestEnded = true;
      let finalCallback = callback;
      if (typeof dataOrCallback === "function") {
        finalCallback = dataOrCallback;
      } else if (dataOrCallback !== void 0) {
        this.write(dataOrCallback);
      }
      if (typeof encodingOrCallback === "function") {
        finalCallback = encodingOrCallback;
      }
      this._performRequest().then(() => {
        if (finalCallback) finalCallback();
      }).catch((error) => {
        this.emit("error", error);
      });
      return this;
    }
    abort() {
      this._aborted = true;
      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
      }
      this.emit("abort");
    }
    setTimeout(ms, callback) {
      this._timeout = ms;
      if (callback) {
        this.once("timeout", callback);
      }
      return this;
    }
    async _performRequest() {
      var _a2;
      if (this._aborted) return;
      try {
        const protocol = this._protocol === "https" ? "https:" : "http:";
        let hostname2 = this._options.hostname || "";
        let port = this._options.port ? `:${this._options.port}` : "";
        if (!hostname2 && this._options.host) {
          const hostParts = this._options.host.split(":");
          hostname2 = hostParts[0];
          if (!port && hostParts[1]) {
            port = `:${hostParts[1]}`;
          }
        }
        if (!hostname2) hostname2 = "localhost";
        const path2 = this._options.path || "/";
        const url2 = `${protocol}//${hostname2}${port}${path2}`;
        if (((_a2 = this.headers["upgrade"]) == null ? void 0 : _a2.toLowerCase()) === "websocket") {
          this._handleWebSocketUpgrade(url2);
          return;
        }
        const corsProxy = getCorsProxy();
        const fetchUrl = corsProxy ? corsProxy + encodeURIComponent(url2) : url2;
        const fetchOptions = {
          method: this.method,
          headers: this.headers
        };
        if (this._bodyChunks.length > 0 && this.method !== "GET" && this.method !== "HEAD") {
          fetchOptions.body = BufferPolyfill.concat(this._bodyChunks);
        }
        const controller = new AbortController();
        fetchOptions.signal = controller.signal;
        if (this._timeout) {
          this._timeoutId = setTimeout(() => {
            controller.abort();
            this.emit("timeout");
          }, this._timeout);
        }
        const response = await fetch(fetchUrl, fetchOptions);
        if (this._timeoutId) {
          clearTimeout(this._timeoutId);
          this._timeoutId = null;
        }
        if (this._aborted) return;
        const incomingMessage = await this._responseToIncomingMessage(response);
        this.emit("response", incomingMessage);
      } catch (error) {
        if (this._timeoutId) {
          clearTimeout(this._timeoutId);
        }
        if (this._aborted) return;
        if (error instanceof Error && error.name === "AbortError") {
          return;
        }
        this.emit("error", error);
      }
    }
    async _responseToIncomingMessage(response) {
      const msg = new IncomingMessage();
      msg.statusCode = response.status;
      msg.statusMessage = response.statusText || STATUS_CODES[response.status] || "";
      response.headers.forEach((value2, key) => {
        msg.headers[key.toLowerCase()] = value2;
        msg.rawHeaders.push(key, value2);
      });
      const body = await response.arrayBuffer();
      msg._setBody(BufferPolyfill.from(body));
      return msg;
    }
    _handleWebSocketUpgrade(url2) {
      const wsUrl = url2.replace(/^https:/, "wss:").replace(/^http:/, "ws:");
      const wsKey = this.headers["sec-websocket-key"] || "";
      const NativeWS = _BrowserWebSocket;
      if (!NativeWS) {
        setTimeout(() => {
          this.emit("error", new TypeError("Failed to fetch"));
        }, 0);
        return;
      }
      const GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
      const acceptValue = createHash("sha1").update(wsKey + GUID).digest("base64");
      let nativeWs;
      try {
        nativeWs = new NativeWS(wsUrl);
        nativeWs.binaryType = "arraybuffer";
      } catch (e) {
        setTimeout(() => {
          this.emit("error", e instanceof Error ? e : new Error(String(e)));
        }, 0);
        return;
      }
      const socket = new Socket$1();
      if (typeof socket.cork !== "function") socket.cork = () => {
      };
      if (typeof socket.uncork !== "function") socket.uncork = () => {
      };
      socket._readableState = {
        endEmitted: false
      };
      socket._writableState = {
        finished: false,
        errorEmitted: false
      };
      let writeBuffer = new Uint8Array(0);
      socket.write = (chunk, encodingOrCallback, callback) => {
        const data2 = typeof chunk === "string" ? BufferPolyfill.from(chunk) : new Uint8Array(chunk);
        const cb = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
        const newBuf = new Uint8Array(writeBuffer.length + data2.length);
        newBuf.set(writeBuffer, 0);
        newBuf.set(data2, writeBuffer.length);
        writeBuffer = newBuf;
        while (writeBuffer.length >= 2) {
          const parsed = _parseWsFrame(writeBuffer);
          if (!parsed) break;
          const { opcode, payload, totalLength } = parsed;
          writeBuffer = writeBuffer.slice(totalLength);
          if (nativeWs.readyState !== NativeWS.OPEN) continue;
          if (opcode === 8) {
            nativeWs.close();
          } else if (opcode === 9) {
            nativeWs.send(payload);
          } else if (opcode === 10) ;
          else if (opcode === 1) {
            const text = new TextDecoder().decode(payload);
            nativeWs.send(text);
          } else if (opcode === 2) {
            nativeWs.send(payload);
          }
        }
        if (cb) queueMicrotask(() => cb(null));
        return true;
      };
      nativeWs.onopen = () => {
        const response = new IncomingMessage(socket);
        response.statusCode = 101;
        response.statusMessage = "Switching Protocols";
        response.headers = {
          "upgrade": "websocket",
          "connection": "Upgrade",
          "sec-websocket-accept": acceptValue
        };
        response.complete = true;
        response.push(null);
        this.emit("upgrade", response, socket, BufferPolyfill.alloc(0));
      };
      nativeWs.onmessage = (event) => {
        let payload;
        let opcode;
        if (typeof event.data === "string") {
          payload = new TextEncoder().encode(event.data);
          opcode = 1;
        } else if (event.data instanceof ArrayBuffer) {
          payload = new Uint8Array(event.data);
          opcode = 2;
        } else {
          return;
        }
        const frame = _createWsFrame(opcode, payload, false);
        socket._receiveData(BufferPolyfill.from(frame));
      };
      nativeWs.onclose = (event) => {
        const code2 = event.code || 1e3;
        const closePayload = new Uint8Array(2);
        closePayload[0] = code2 >> 8 & 255;
        closePayload[1] = code2 & 255;
        const frame = _createWsFrame(8, closePayload, false);
        socket._receiveData(BufferPolyfill.from(frame));
        setTimeout(() => {
          socket._readableState.endEmitted = true;
          socket._receiveEnd();
          socket.emit("close", false);
        }, 10);
      };
      nativeWs.onerror = () => {
        socket.emit("error", new Error("WebSocket connection error"));
        socket.destroy();
      };
      const origDestroy = socket.destroy.bind(socket);
      socket.destroy = (error) => {
        if (nativeWs.readyState === NativeWS.OPEN || nativeWs.readyState === NativeWS.CONNECTING) {
          nativeWs.close();
        }
        return origDestroy(error);
      };
    }
  }
  function parseRequestArgs(urlOrOptions, optionsOrCallback, callback) {
    let options2;
    let cb = callback;
    if (typeof urlOrOptions === "string" || urlOrOptions instanceof URL) {
      const parsed = new URL(urlOrOptions.toString());
      options2 = {
        hostname: parsed.hostname,
        port: parsed.port ? parseInt(parsed.port) : void 0,
        path: parsed.pathname + parsed.search,
        method: "GET"
      };
      if (typeof optionsOrCallback === "function") {
        cb = optionsOrCallback;
      } else if (optionsOrCallback) {
        options2 = {
          ...options2,
          ...optionsOrCallback
        };
      }
    } else {
      options2 = urlOrOptions;
      if (typeof optionsOrCallback === "function") {
        cb = optionsOrCallback;
      }
    }
    return {
      options: options2,
      callback: cb
    };
  }
  function request$1(urlOrOptions, optionsOrCallback, callback) {
    const { options: options2, callback: cb } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
    const req = new ClientRequest(options2, "http");
    if (cb) {
      req.once("response", cb);
    }
    return req;
  }
  function get$1(urlOrOptions, optionsOrCallback, callback) {
    const { options: options2, callback: cb } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
    const req = new ClientRequest({
      ...options2,
      method: "GET"
    }, "http");
    if (cb) {
      req.once("response", cb);
    }
    req.end();
    return req;
  }
  function _createClientRequest(urlOrOptions, optionsOrCallback, callback, protocol) {
    const { options: options2, callback: cb } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
    const req = new ClientRequest(options2, protocol);
    if (cb) {
      req.once("response", cb);
    }
    return req;
  }
  const serverRegistry = /* @__PURE__ */ new Map();
  let onServerListenCallback = null;
  let onServerCloseCallback = null;
  function _registerServer(port, server) {
    serverRegistry.set(port, server);
    if (onServerListenCallback) {
      onServerListenCallback(port, server);
    }
  }
  function _unregisterServer(port) {
    serverRegistry.delete(port);
    if (onServerCloseCallback) {
      onServerCloseCallback(port);
    }
  }
  function getServer(port) {
    return serverRegistry.get(port);
  }
  function getAllServers() {
    return new Map(serverRegistry);
  }
  function setServerListenCallback(callback) {
    onServerListenCallback = callback;
  }
  function setServerCloseCallback(callback) {
    onServerCloseCallback = callback;
  }
  class Agent extends EventEmitter {
    constructor(opts) {
      super();
      __publicField(this, "maxSockets");
      __publicField(this, "maxFreeSockets");
      __publicField(this, "maxTotalSockets");
      __publicField(this, "sockets");
      __publicField(this, "freeSockets");
      __publicField(this, "requests");
      __publicField(this, "options");
      this.options = opts || {};
      this.maxSockets = (opts == null ? void 0 : opts.maxSockets) ?? Infinity;
      this.maxFreeSockets = (opts == null ? void 0 : opts.maxFreeSockets) ?? 256;
      this.maxTotalSockets = (opts == null ? void 0 : opts.maxTotalSockets) ?? Infinity;
      this.sockets = {};
      this.freeSockets = {};
      this.requests = {};
    }
    createConnection(_options2, callback) {
      const socket = new Socket$1();
      if (callback) {
        callback(null, socket);
      }
      return socket;
    }
    getName(options2) {
      const host = options2.host || "localhost";
      const port = options2.port || 80;
      return `${host}:${port}:${options2.localAddress || ""}`;
    }
    addRequest(_req, _options2) {
    }
    destroy() {
      this.sockets = {};
      this.freeSockets = {};
      this.requests = {};
    }
  }
  const globalAgent = new Agent();
  function _parseWsFrame(data2) {
    if (data2.length < 2) return null;
    const opcode = data2[0] & 15;
    const masked = (data2[1] & 128) !== 0;
    let payloadLength = data2[1] & 127;
    let offset = 2;
    if (payloadLength === 126) {
      if (data2.length < 4) return null;
      payloadLength = data2[2] << 8 | data2[3];
      offset = 4;
    } else if (payloadLength === 127) {
      if (data2.length < 10) return null;
      payloadLength = data2[6] << 24 | data2[7] << 16 | data2[8] << 8 | data2[9];
      offset = 10;
    }
    if (masked) {
      if (data2.length < offset + 4 + payloadLength) return null;
      const maskKey = data2.slice(offset, offset + 4);
      offset += 4;
      const payload = new Uint8Array(payloadLength);
      for (let i2 = 0; i2 < payloadLength; i2++) {
        payload[i2] = data2[offset + i2] ^ maskKey[i2 % 4];
      }
      return {
        opcode,
        payload,
        totalLength: offset + payloadLength
      };
    } else {
      if (data2.length < offset + payloadLength) return null;
      const payload = data2.slice(offset, offset + payloadLength);
      return {
        opcode,
        payload,
        totalLength: offset + payloadLength
      };
    }
  }
  function _createWsFrame(opcode, payload, masked) {
    const length2 = payload.length;
    let headerSize = 2;
    if (length2 > 125 && length2 <= 65535) {
      headerSize += 2;
    } else if (length2 > 65535) {
      headerSize += 8;
    }
    if (masked) {
      headerSize += 4;
    }
    const frame = new Uint8Array(headerSize + length2);
    frame[0] = 128 | opcode;
    let offset = 2;
    if (length2 <= 125) {
      frame[1] = (masked ? 128 : 0) | length2;
    } else if (length2 <= 65535) {
      frame[1] = (masked ? 128 : 0) | 126;
      frame[2] = length2 >> 8 & 255;
      frame[3] = length2 & 255;
      offset = 4;
    } else {
      frame[1] = (masked ? 128 : 0) | 127;
      frame[2] = 0;
      frame[3] = 0;
      frame[4] = 0;
      frame[5] = 0;
      frame[6] = length2 >> 24 & 255;
      frame[7] = length2 >> 16 & 255;
      frame[8] = length2 >> 8 & 255;
      frame[9] = length2 & 255;
      offset = 10;
    }
    if (masked) {
      const maskKey = new Uint8Array(4);
      if (typeof crypto !== "undefined" && crypto.getRandomValues) {
        crypto.getRandomValues(maskKey);
      } else {
        for (let i2 = 0; i2 < 4; i2++) maskKey[i2] = Math.floor(Math.random() * 256);
      }
      frame.set(maskKey, offset);
      offset += 4;
      for (let i2 = 0; i2 < length2; i2++) {
        frame[offset + i2] = payload[i2] ^ maskKey[i2 % 4];
      }
    } else {
      frame.set(payload, offset);
    }
    return frame;
  }
  const http = {
    Server: Server$2,
    IncomingMessage,
    ServerResponse,
    ClientRequest,
    createServer: createServer$2,
    request: request$1,
    get: get$1,
    STATUS_CODES,
    METHODS,
    getServer,
    getAllServers,
    setServerListenCallback,
    setServerCloseCallback,
    _createClientRequest,
    Agent,
    globalAgent,
    _parseWsFrame,
    _createWsFrame
  };
  httpShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Agent,
    ClientRequest,
    IncomingMessage,
    METHODS,
    STATUS_CODES,
    Server: Server$2,
    ServerResponse,
    _createClientRequest,
    _createWsFrame,
    _parseWsFrame,
    _registerServer,
    _unregisterServer,
    createServer: createServer$2,
    default: http,
    get: get$1,
    getAllServers,
    getServer,
    globalAgent,
    request: request$1,
    setServerCloseCallback,
    setServerListenCallback
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function request(urlOrOptions, optionsOrCallback, callback) {
    return _createClientRequest(urlOrOptions, optionsOrCallback, callback, "https");
  }
  function get(urlOrOptions, optionsOrCallback, callback) {
    const req = _createClientRequest(urlOrOptions, optionsOrCallback, callback, "https");
    req.end();
    return req;
  }
  const https = {
    Server: Server$2,
    IncomingMessage,
    ServerResponse,
    ClientRequest,
    createServer: createServer$2,
    request,
    get,
    STATUS_CODES,
    METHODS,
    getServer,
    getAllServers,
    setServerListenCallback,
    setServerCloseCallback,
    Agent,
    globalAgent
  };
  const httpsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Agent,
    ClientRequest,
    IncomingMessage,
    METHODS,
    STATUS_CODES,
    Server: Server$2,
    ServerResponse,
    createServer: createServer$2,
    default: https,
    get,
    getAllServers,
    getServer,
    globalAgent,
    request,
    setServerCloseCallback,
    setServerListenCallback
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function parse$Q(urlString, parseQueryString = false, slashesDenoteHost = false) {
    var _a2;
    try {
      const url2 = new URL$1(urlString, "http://localhost");
      const result = {
        protocol: url2.protocol,
        slashes: url2.protocol.endsWith(":"),
        auth: url2.username ? `${url2.username}:${url2.password}` : null,
        host: url2.host,
        port: url2.port || null,
        hostname: url2.hostname,
        hash: url2.hash || null,
        search: url2.search || null,
        query: parseQueryString ? Object.fromEntries(url2.searchParams) : ((_a2 = url2.search) == null ? void 0 : _a2.slice(1)) || null,
        pathname: url2.pathname,
        path: url2.pathname + url2.search,
        href: url2.href
      };
      return result;
    } catch {
      return {
        protocol: null,
        slashes: null,
        auth: null,
        host: null,
        port: null,
        hostname: null,
        hash: null,
        search: null,
        query: null,
        pathname: urlString,
        path: urlString,
        href: urlString
      };
    }
  }
  function format$1(urlObject) {
    if (urlObject.href) {
      return urlObject.href;
    }
    let result = "";
    if (urlObject.protocol) {
      result += urlObject.protocol;
      if (!urlObject.protocol.endsWith(":")) {
        result += ":";
      }
    }
    if (urlObject.slashes || urlObject.protocol === "http:" || urlObject.protocol === "https:") {
      result += "//";
    }
    if (urlObject.auth) {
      result += urlObject.auth + "@";
    }
    if (urlObject.hostname) {
      result += urlObject.hostname;
    } else if (urlObject.host) {
      result += urlObject.host;
    }
    if (urlObject.port) {
      result += ":" + urlObject.port;
    }
    if (urlObject.pathname) {
      result += urlObject.pathname;
    }
    if (urlObject.search) {
      result += urlObject.search;
    } else if (urlObject.query) {
      if (typeof urlObject.query === "string") {
        result += "?" + urlObject.query;
      } else {
        const params = new URLSearchParams();
        for (const [key, value2] of Object.entries(urlObject.query)) {
          if (Array.isArray(value2)) {
            for (const v of value2) {
              params.append(key, v);
            }
          } else {
            params.set(key, value2);
          }
        }
        const search = params.toString();
        if (search) {
          result += "?" + search;
        }
      }
    }
    if (urlObject.hash) {
      result += urlObject.hash;
    }
    return result;
  }
  function resolve$1(from, to) {
    try {
      return new URL$1(to, from).href;
    } catch {
      return to;
    }
  }
  const URL$1 = globalThis.URL;
  const URLSearchParams = globalThis.URLSearchParams;
  function fileURLToPath(url2) {
    const urlObj = typeof url2 === "string" ? new globalThis.URL(url2) : url2;
    if (urlObj.protocol !== "file:") {
      throw new TypeError("The URL must be of scheme file");
    }
    return decodeURIComponent(urlObj.pathname);
  }
  function pathToFileURL(path2) {
    const encoded = encodeURIComponent(path2).replace(/%2F/g, "/");
    return new globalThis.URL("file://" + encoded);
  }
  const url$1 = {
    parse: parse$Q,
    format: format$1,
    resolve: resolve$1,
    URL: URL$1,
    URLSearchParams,
    fileURLToPath,
    pathToFileURL
  };
  urlShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    URL: URL$1,
    URLSearchParams,
    default: url$1,
    fileURLToPath,
    format: format$1,
    parse: parse$Q,
    pathToFileURL,
    resolve: resolve$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function parse$P(str, sep2 = "&", eq = "=", options2) {
    const result = {};
    if (!str || typeof str !== "string") {
      return result;
    }
    const maxKeys = (options2 == null ? void 0 : options2.maxKeys) || 1e3;
    const pairs = str.split(sep2).slice(0, maxKeys > 0 ? maxKeys : void 0);
    for (const pair of pairs) {
      const idx = pair.indexOf(eq);
      let key;
      let value2;
      if (idx >= 0) {
        key = decodeURIComponent(pair.slice(0, idx).replace(/\+/g, " "));
        value2 = decodeURIComponent(pair.slice(idx + 1).replace(/\+/g, " "));
      } else {
        key = decodeURIComponent(pair.replace(/\+/g, " "));
        value2 = "";
      }
      if (key in result) {
        const existing = result[key];
        if (Array.isArray(existing)) {
          existing.push(value2);
        } else {
          result[key] = [
            existing,
            value2
          ];
        }
      } else {
        result[key] = value2;
      }
    }
    return result;
  }
  function stringify(obj, sep2 = "&", eq = "=") {
    if (!obj || typeof obj !== "object") {
      return "";
    }
    const pairs = [];
    for (const [key, value2] of Object.entries(obj)) {
      if (value2 === void 0) continue;
      const encodedKey = encodeURIComponent(key);
      if (Array.isArray(value2)) {
        for (const v of value2) {
          pairs.push(`${encodedKey}${eq}${encodeURIComponent(String(v))}`);
        }
      } else {
        pairs.push(`${encodedKey}${eq}${encodeURIComponent(String(value2))}`);
      }
    }
    return pairs.join(sep2);
  }
  function escape(str) {
    return encodeURIComponent(str);
  }
  function unescape(str) {
    return decodeURIComponent(str.replace(/\+/g, " "));
  }
  const encode$2 = stringify;
  const decode$2 = parse$P;
  const querystring = {
    parse: parse$P,
    stringify,
    escape,
    unescape,
    encode: encode$2,
    decode: decode$2
  };
  querystringShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    decode: decode$2,
    default: querystring,
    encode: encode$2,
    escape,
    parse: parse$P,
    stringify,
    unescape
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  var define_process_env_default = {};
  function format(fmt, ...args) {
    if (typeof fmt !== "string") {
      return args.map((arg) => inspect(arg)).join(" ");
    }
    let i2 = 0;
    return fmt.replace(/%[sdjifoO%]/g, (match) => {
      if (match === "%%") return "%";
      if (i2 >= args.length) return match;
      const arg = args[i2++];
      switch (match) {
        case "%s":
          return String(arg);
        case "%d":
        case "%i":
          return String(parseInt(String(arg), 10));
        case "%f":
          return String(parseFloat(String(arg)));
        case "%j":
          try {
            return JSON.stringify(arg);
          } catch {
            return "[Circular]";
          }
        case "%o":
        case "%O":
          return inspect(arg);
        default:
          return match;
      }
    });
  }
  function inspect(obj, options2) {
    const seen = /* @__PURE__ */ new WeakSet();
    const depth = (options2 == null ? void 0 : options2.depth) ?? 2;
    function inspectValue(value2, currentDepth) {
      if (value2 === null) return "null";
      if (value2 === void 0) return "undefined";
      const type2 = typeof value2;
      if (type2 === "string") {
        return `'${value2}'`;
      }
      if (type2 === "number" || type2 === "boolean" || type2 === "bigint") {
        return String(value2);
      }
      if (type2 === "symbol") {
        return value2.toString();
      }
      if (type2 === "function") {
        const name2 = value2.name || "anonymous";
        return `[Function: ${name2}]`;
      }
      if (type2 !== "object") {
        return String(value2);
      }
      if (seen.has(value2)) {
        return "[Circular]";
      }
      seen.add(value2);
      if (currentDepth > depth) {
        return Array.isArray(value2) ? "[Array]" : "[Object]";
      }
      if (Array.isArray(value2)) {
        if (value2.length === 0) return "[]";
        const items = value2.map((v) => inspectValue(v, currentDepth + 1));
        return `[ ${items.join(", ")} ]`;
      }
      if (value2 instanceof Date) {
        return value2.toISOString();
      }
      if (value2 instanceof RegExp) {
        return value2.toString();
      }
      if (value2 instanceof Error) {
        return `${value2.name}: ${value2.message}`;
      }
      if (value2 instanceof Map) {
        const entries2 = [
          ...value2.entries()
        ].map(([k, v]) => `${inspectValue(k, currentDepth + 1)} => ${inspectValue(v, currentDepth + 1)}`);
        return `Map(${value2.size}) { ${entries2.join(", ")} }`;
      }
      if (value2 instanceof Set) {
        const items = [
          ...value2
        ].map((v) => inspectValue(v, currentDepth + 1));
        return `Set(${value2.size}) { ${items.join(", ")} }`;
      }
      const keys = Object.keys(value2);
      if (keys.length === 0) return "{}";
      const entries = keys.map((key) => {
        const val = value2[key];
        return `${key}: ${inspectValue(val, currentDepth + 1)}`;
      });
      return `{ ${entries.join(", ")} }`;
    }
    return inspectValue(obj, 0);
  }
  function inherits(ctor, superCtor) {
    if (ctor === void 0 || ctor === null) {
      throw new TypeError("inherits: ctor must be a function");
    }
    if (superCtor === void 0 || superCtor === null) {
      return;
    }
    if (superCtor.prototype === void 0) {
      return;
    }
    ctor.super_ = superCtor;
    Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
  }
  function deprecate(fn2, msg, code2) {
    let warned = false;
    const deprecated = function(...args) {
      if (!warned) {
        console.warn(`DeprecationWarning: ${msg}${code2 ? ` (${code2})` : ""}`);
        warned = true;
      }
      return fn2.apply(this, args);
    };
    return deprecated;
  }
  function promisify(fn2) {
    return (...args) => {
      return new Promise((resolve2, reject) => {
        fn2(...args, (err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve2(result);
          }
        });
      });
    };
  }
  function callbackify(fn2) {
    return (...args) => {
      const callback = args.pop();
      fn2(...args).then((result) => callback(null, result)).catch((err) => callback(err, void 0));
    };
  }
  function isArray$1(value2) {
    return Array.isArray(value2);
  }
  function isBoolean(value2) {
    return typeof value2 === "boolean";
  }
  function isNull(value2) {
    return value2 === null;
  }
  function isNullOrUndefined(value2) {
    return value2 === null || value2 === void 0;
  }
  function isNumber(value2) {
    return typeof value2 === "number";
  }
  function isString(value2) {
    return typeof value2 === "string";
  }
  function isUndefined(value2) {
    return value2 === void 0;
  }
  function isRegExp(value2) {
    return value2 instanceof RegExp;
  }
  function isObject(value2) {
    return typeof value2 === "object" && value2 !== null;
  }
  function isDate(value2) {
    return value2 instanceof Date;
  }
  function isError(value2) {
    return value2 instanceof Error;
  }
  function isFunction(value2) {
    return typeof value2 === "function";
  }
  function isPrimitive(value2) {
    return value2 === null || typeof value2 !== "object" && typeof value2 !== "function";
  }
  function isBuffer(value2) {
    return value2 instanceof Uint8Array;
  }
  function debuglog(section) {
    const nodeDebug = typeof process !== "undefined" && (define_process_env_default == null ? void 0 : define_process_env_default.NODE_DEBUG) || "";
    const enabled = nodeDebug.toLowerCase().includes(section.toLowerCase());
    if (enabled) {
      return (...args) => {
        console.error(`${section.toUpperCase()} ${(process == null ? void 0 : process.pid) || 0}:`, ...args);
      };
    }
    return () => {
    };
  }
  const debug = debuglog;
  const types$2 = {
    isArray: isArray$1,
    isBoolean,
    isNull,
    isNullOrUndefined,
    isNumber,
    isString,
    isUndefined,
    isRegExp,
    isObject,
    isDate,
    isError,
    isFunction,
    isPrimitive,
    isBuffer
  };
  const TextEncoder$1 = globalThis.TextEncoder;
  const TextDecoder$1 = globalThis.TextDecoder;
  const util$4 = {
    format,
    inspect,
    inherits,
    deprecate,
    promisify,
    callbackify,
    debuglog,
    debug,
    isArray: isArray$1,
    isBoolean,
    isNull,
    isNullOrUndefined,
    isNumber,
    isString,
    isUndefined,
    isRegExp,
    isObject,
    isDate,
    isError,
    isFunction,
    isPrimitive,
    isBuffer,
    types: types$2,
    TextEncoder: TextEncoder$1,
    TextDecoder: TextDecoder$1
  };
  utilShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    TextDecoder: TextDecoder$1,
    TextEncoder: TextEncoder$1,
    callbackify,
    debug,
    debuglog,
    default: util$4,
    deprecate,
    format,
    inherits,
    inspect,
    isArray: isArray$1,
    isBoolean,
    isBuffer,
    isDate,
    isError,
    isFunction,
    isNull,
    isNullOrUndefined,
    isNumber,
    isObject,
    isPrimitive,
    isRegExp,
    isString,
    isUndefined,
    promisify,
    types: types$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class ReadStream extends Readable {
    constructor() {
      super(...arguments);
      __publicField(this, "isTTY", false);
      __publicField(this, "isRaw", false);
    }
    setRawMode(mode) {
      this.isRaw = mode;
      return this;
    }
  }
  class WriteStream extends Writable {
    constructor() {
      super(...arguments);
      __publicField(this, "isTTY", false);
      __publicField(this, "columns", 80);
      __publicField(this, "rows", 24);
    }
    clearLine(dir, callback) {
      if (callback) callback();
      return true;
    }
    clearScreenDown(callback) {
      if (callback) callback();
      return true;
    }
    cursorTo(x, y, callback) {
      if (callback) callback();
      return true;
    }
    moveCursor(dx, dy, callback) {
      if (callback) callback();
      return true;
    }
    getColorDepth(env) {
      return 1;
    }
    hasColors(count, env) {
      return false;
    }
    getWindowSize() {
      return [
        this.columns,
        this.rows
      ];
    }
  }
  function isatty(fd) {
    return false;
  }
  const tty = {
    ReadStream,
    WriteStream,
    isatty
  };
  const ttyShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    ReadStream,
    WriteStream,
    default: tty,
    isatty
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function hostname() {
    return "localhost";
  }
  function platform() {
    return "linux";
  }
  function arch() {
    return "x64";
  }
  function type() {
    return "Linux";
  }
  function release() {
    return "5.10.0";
  }
  function version$2() {
    return "#1 SMP";
  }
  function machine() {
    return "x86_64";
  }
  function tmpdir() {
    return "/tmp";
  }
  function homedir() {
    return "/home/user";
  }
  function cpus() {
    const cpu = {
      model: "Virtual CPU",
      speed: 2400,
      times: {
        user: 0,
        nice: 0,
        sys: 0,
        idle: 0,
        irq: 0
      }
    };
    return [
      cpu,
      cpu
    ];
  }
  function totalmem() {
    return 4 * 1024 * 1024 * 1024;
  }
  function freemem() {
    return 2 * 1024 * 1024 * 1024;
  }
  function uptime() {
    return Math.floor(performance.now() / 1e3);
  }
  function loadavg() {
    return [
      0.5,
      0.5,
      0.5
    ];
  }
  function networkInterfaces() {
    return {
      lo: [
        {
          address: "127.0.0.1",
          netmask: "255.0.0.0",
          family: "IPv4",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "127.0.0.1/8"
        }
      ]
    };
  }
  function userInfo() {
    return {
      username: "user",
      uid: 1e3,
      gid: 1e3,
      shell: "/bin/bash",
      homedir: "/home/user"
    };
  }
  function endianness() {
    return "LE";
  }
  function getPriority(pid) {
    return 0;
  }
  function setPriority(pid, priority) {
  }
  const EOL = "\n";
  const constants$4 = {
    signals: {
      SIGHUP: 1,
      SIGINT: 2,
      SIGQUIT: 3,
      SIGILL: 4,
      SIGTRAP: 5,
      SIGABRT: 6,
      SIGBUS: 7,
      SIGFPE: 8,
      SIGKILL: 9,
      SIGUSR1: 10,
      SIGSEGV: 11,
      SIGUSR2: 12,
      SIGPIPE: 13,
      SIGALRM: 14,
      SIGTERM: 15,
      SIGCHLD: 17,
      SIGCONT: 18,
      SIGSTOP: 19,
      SIGTSTP: 20,
      SIGTTIN: 21,
      SIGTTOU: 22,
      SIGURG: 23,
      SIGXCPU: 24,
      SIGXFSZ: 25,
      SIGVTALRM: 26,
      SIGPROF: 27,
      SIGWINCH: 28,
      SIGIO: 29,
      SIGPWR: 30,
      SIGSYS: 31
    },
    errno: {},
    priority: {
      PRIORITY_LOW: 19,
      PRIORITY_BELOW_NORMAL: 10,
      PRIORITY_NORMAL: 0,
      PRIORITY_ABOVE_NORMAL: -7,
      PRIORITY_HIGH: -14,
      PRIORITY_HIGHEST: -20
    }
  };
  const devNull = "/dev/null";
  const os = {
    hostname,
    platform,
    arch,
    type,
    release,
    version: version$2,
    machine,
    tmpdir,
    homedir,
    cpus,
    totalmem,
    freemem,
    uptime,
    loadavg,
    networkInterfaces,
    userInfo,
    endianness,
    getPriority,
    setPriority,
    EOL,
    constants: constants$4,
    devNull
  };
  const osShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    EOL,
    arch,
    constants: constants$4,
    cpus,
    default: os,
    devNull,
    endianness,
    freemem,
    getPriority,
    homedir,
    hostname,
    loadavg,
    machine,
    networkInterfaces,
    platform,
    release,
    setPriority,
    tmpdir,
    totalmem,
    type,
    uptime,
    userInfo,
    version: version$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  let brotliModule = null;
  let brotliLoadPromise = null;
  async function loadBrotli() {
    if (brotliModule) return brotliModule;
    if (!brotliLoadPromise) {
      brotliLoadPromise = (async () => {
        try {
          const brotliWasmModule = await import("brotli-wasm").then(async (m) => {
            await m.__tla;
            return m;
          });
          brotliModule = await brotliWasmModule.default;
          console.log("[zlib] brotli-wasm loaded successfully");
          return brotliModule;
        } catch (error) {
          console.error("[zlib] Failed to load brotli-wasm:", error);
          return null;
        }
      })();
    }
    return brotliLoadPromise;
  }
  function gzip(buffer2, callback) {
    try {
      const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
      const result = pako.gzip(input);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function gunzip(buffer2, callback) {
    try {
      const result = pako.ungzip(buffer2);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function deflate(buffer2, callback) {
    try {
      const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
      const result = pako.deflate(input);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function inflate(buffer2, callback) {
    try {
      const result = pako.inflate(buffer2);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function deflateRaw(buffer2, callback) {
    try {
      const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
      const result = pako.deflateRaw(input);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function inflateRaw(buffer2, callback) {
    try {
      const result = pako.inflateRaw(buffer2);
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }
  function brotliCompress(buffer2, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
    }
    loadBrotli().then((brotli) => {
      if (!brotli) {
        callback(new Error("Brotli WASM failed to load"), BufferPolyfill.alloc(0));
        return;
      }
      try {
        const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
        const result = brotli.compress(new Uint8Array(input));
        callback(null, BufferPolyfill.from(result));
      } catch (error) {
        callback(error, BufferPolyfill.alloc(0));
      }
    }).catch((error) => {
      callback(error, BufferPolyfill.alloc(0));
    });
  }
  function brotliDecompress(buffer2, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
    }
    loadBrotli().then((brotli) => {
      if (!brotli) {
        callback(new Error("Brotli WASM failed to load"), BufferPolyfill.alloc(0));
        return;
      }
      try {
        const result = brotli.decompress(new Uint8Array(buffer2));
        callback(null, BufferPolyfill.from(result));
      } catch (error) {
        callback(error, BufferPolyfill.alloc(0));
      }
    }).catch((error) => {
      callback(error, BufferPolyfill.alloc(0));
    });
  }
  function brotliCompressSync(buffer2, _options2) {
    if (!brotliModule) {
      throw new Error("Brotli WASM not loaded. Call brotliCompress first to initialize.");
    }
    const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
    return BufferPolyfill.from(brotliModule.compress(new Uint8Array(input)));
  }
  function brotliDecompressSync(buffer2, _options2) {
    if (!brotliModule) {
      throw new Error("Brotli WASM not loaded. Call brotliDecompress first to initialize.");
    }
    return BufferPolyfill.from(brotliModule.decompress(new Uint8Array(buffer2)));
  }
  function gzipSync(buffer2) {
    const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
    return BufferPolyfill.from(pako.gzip(input));
  }
  function gunzipSync(buffer2) {
    return BufferPolyfill.from(pako.ungzip(buffer2));
  }
  function deflateSync(buffer2) {
    const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
    return BufferPolyfill.from(pako.deflate(input));
  }
  function inflateSync(buffer2) {
    return BufferPolyfill.from(pako.inflate(buffer2));
  }
  function deflateRawSync(buffer2) {
    const input = typeof buffer2 === "string" ? BufferPolyfill.from(buffer2) : buffer2;
    return BufferPolyfill.from(pako.deflateRaw(input));
  }
  function inflateRawSync(buffer2) {
    return BufferPolyfill.from(pako.inflateRaw(buffer2));
  }
  const constants$3 = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4784,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_DECODE: 0,
    BROTLI_ENCODE: 1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24
  };
  const zlib = {
    gzip,
    gunzip,
    deflate,
    inflate,
    deflateRaw,
    inflateRaw,
    gzipSync,
    gunzipSync,
    deflateSync,
    inflateSync,
    deflateRawSync,
    inflateRawSync,
    brotliCompress,
    brotliDecompress,
    brotliCompressSync,
    brotliDecompressSync,
    constants: constants$3
  };
  const zlibShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    brotliCompress,
    brotliCompressSync,
    brotliDecompress,
    brotliDecompressSync,
    constants: constants$3,
    default: zlib,
    deflate,
    deflateRaw,
    deflateRawSync,
    deflateSync,
    gunzip,
    gunzipSync,
    gzip,
    gzipSync,
    inflate,
    inflateRaw,
    inflateRawSync,
    inflateSync
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function lookup(hostname2, optionsOrCallback, callback) {
    const cb = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
    const options2 = typeof optionsOrCallback === "object" ? optionsOrCallback : {};
    setImmediate(() => {
      if (hostname2 === "localhost" || hostname2 === "127.0.0.1") {
        if (options2.all) {
          cb(null, [
            {
              address: "127.0.0.1",
              family: 4
            }
          ]);
        } else {
          cb(null, "127.0.0.1", 4);
        }
      } else {
        if (options2.all) {
          cb(null, [
            {
              address: "0.0.0.0",
              family: 4
            }
          ]);
        } else {
          cb(null, "0.0.0.0", 4);
        }
      }
    });
  }
  function resolve(hostname2, callback) {
    setImmediate(() => {
      callback(null, [
        "0.0.0.0"
      ]);
    });
  }
  function resolve4(hostname2, callback) {
    resolve(hostname2, callback);
  }
  function resolve6(hostname2, callback) {
    setImmediate(() => {
      callback(null, [
        "::1"
      ]);
    });
  }
  function reverse(ip, callback) {
    setImmediate(() => {
      callback(null, [
        "localhost"
      ]);
    });
  }
  function setServers(_servers) {
  }
  function getServers() {
    return [];
  }
  function setDefaultResultOrder(_order) {
  }
  function getDefaultResultOrder() {
    return "verbatim";
  }
  const promises$1 = {
    lookup: (hostname2, options2) => {
      return new Promise((resolve2, reject) => {
        if (options2 == null ? void 0 : options2.all) {
          lookup(hostname2, options2, (err, addresses) => {
            if (err) reject(err);
            else resolve2(addresses || []);
          });
          return;
        }
        lookup(hostname2, options2 || {}, (err, address, family) => {
          if (err) reject(err);
          else resolve2({
            address,
            family
          });
        });
      });
    },
    resolve: (hostname2) => {
      return new Promise((promiseResolve, promiseReject) => {
        resolve(hostname2, (err, addresses) => {
          if (err) promiseReject(err);
          else promiseResolve(addresses || []);
        });
      });
    },
    resolve4: (hostname2) => promises$1.resolve(hostname2),
    resolve6: (hostname2) => {
      return new Promise((resolve2) => {
        resolve2([
          "::1"
        ]);
      });
    },
    reverse: (ip) => {
      return new Promise((resolve2) => {
        resolve2([
          "localhost"
        ]);
      });
    },
    setServers: (_servers) => {
    },
    getServers: () => []
  };
  const ADDRCONFIG = 0;
  const V4MAPPED = 0;
  const ALL = 0;
  const dns = {
    lookup,
    resolve,
    resolve4,
    resolve6,
    reverse,
    setServers,
    getServers,
    setDefaultResultOrder,
    getDefaultResultOrder,
    promises: promises$1,
    ADDRCONFIG,
    V4MAPPED,
    ALL
  };
  const dnsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    ADDRCONFIG,
    ALL,
    V4MAPPED,
    default: dns,
    getDefaultResultOrder,
    getServers,
    lookup,
    promises: promises$1,
    resolve,
    resolve4,
    resolve6,
    reverse,
    setDefaultResultOrder,
    setServers
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const Buffer$1 = BufferPolyfill;
  const SlowBuffer = BufferPolyfill;
  const kMaxLength = 2147483647;
  const INSPECT_MAX_BYTES = 50;
  const constants$2 = {
    MAX_LENGTH: kMaxLength,
    MAX_STRING_LENGTH: 536870888
  };
  function transcode(source, _fromEnc, _toEnc) {
    return Buffer$1.from(source);
  }
  function resolveObjectURL(id) {
    return void 0;
  }
  function atob$1(data2) {
    return globalThis.atob(data2);
  }
  function btoa$1(data2) {
    return globalThis.btoa(data2);
  }
  const bufferModule = {
    Buffer: Buffer$1,
    SlowBuffer,
    kMaxLength,
    INSPECT_MAX_BYTES,
    constants: constants$2,
    transcode,
    resolveObjectURL,
    atob: atob$1,
    btoa: btoa$1
  };
  Object.defineProperty(bufferModule, "hasOwnProperty", {
    value: Object.prototype.hasOwnProperty,
    enumerable: false,
    configurable: true,
    writable: true
  });
  const buffer = Object.freeze(Object.defineProperty({
    __proto__: null,
    Buffer: Buffer$1,
    INSPECT_MAX_BYTES,
    SlowBuffer,
    atob: atob$1,
    btoa: btoa$1,
    constants: constants$2,
    default: bufferModule,
    kMaxLength,
    resolveObjectURL,
    transcode
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const _decoder = new TextDecoder();
  class VirtualFSAdapter {
    constructor(vfs2) {
      this.vfs = vfs2;
    }
    async readFile(path2, options2) {
      const encoding = typeof options2 === "string" ? options2 : options2 == null ? void 0 : options2.encoding;
      if (!encoding || encoding === "utf8" || encoding === "utf-8") {
        return this.vfs.readFileSync(path2, "utf8");
      }
      if (encoding === "binary" || encoding === "latin1") {
        const buffer2 = this.vfs.readFileSync(path2);
        return uint8ToBinaryString(buffer2);
      }
      return this.vfs.readFileSync(path2, "utf8");
    }
    async readFileBuffer(path2) {
      return this.vfs.readFileSync(path2);
    }
    async writeFile(path2, content, _options2) {
      this.vfs.writeFileSync(path2, content);
    }
    async appendFile(path2, content, _options2) {
      let existing = "";
      try {
        existing = this.vfs.readFileSync(path2, "utf8");
      } catch {
      }
      const newContent = typeof content === "string" ? content : _decoder.decode(content);
      this.vfs.writeFileSync(path2, existing + newContent);
    }
    async exists(path2) {
      return this.vfs.existsSync(path2);
    }
    async stat(path2) {
      const stats = this.vfs.statSync(path2);
      const isFile = stats.isFile();
      const isDirectory = stats.isDirectory();
      let size = 0;
      if (isFile) {
        try {
          const content = this.vfs.readFileSync(path2);
          size = content.length;
        } catch {
        }
      }
      return {
        isFile,
        isDirectory,
        isSymbolicLink: false,
        mode: isDirectory ? 493 : 420,
        size,
        mtime: /* @__PURE__ */ new Date()
      };
    }
    async mkdir(path2, options2) {
      this.vfs.mkdirSync(path2, options2);
    }
    async readdir(path2) {
      return this.vfs.readdirSync(path2);
    }
    async readdirWithFileTypes(path2) {
      const entries = this.vfs.readdirSync(path2);
      const result = [];
      for (const name2 of entries) {
        const fullPath = path2 === "/" ? `/${name2}` : `${path2}/${name2}`;
        try {
          const stats = this.vfs.statSync(fullPath);
          result.push({
            name: name2,
            isFile: stats.isFile(),
            isDirectory: stats.isDirectory(),
            isSymbolicLink: false
          });
        } catch {
        }
      }
      return result;
    }
    async rm(path2, options2) {
      const exists = this.vfs.existsSync(path2);
      if (!exists) {
        if (options2 == null ? void 0 : options2.force) {
          return;
        }
        throw createNodeError("ENOENT", "rm", path2);
      }
      const stats = this.vfs.statSync(path2);
      if (stats.isFile()) {
        this.vfs.unlinkSync(path2);
      } else if (stats.isDirectory()) {
        if (options2 == null ? void 0 : options2.recursive) {
          await this.rmRecursive(path2);
        } else {
          this.vfs.rmdirSync(path2);
        }
      }
    }
    async rmRecursive(path2) {
      const entries = this.vfs.readdirSync(path2);
      for (const entry of entries) {
        const fullPath = path2 === "/" ? `/${entry}` : `${path2}/${entry}`;
        const stats = this.vfs.statSync(fullPath);
        if (stats.isDirectory()) {
          await this.rmRecursive(fullPath);
        } else {
          this.vfs.unlinkSync(fullPath);
        }
      }
      this.vfs.rmdirSync(path2);
    }
    async cp(src, dest, options2) {
      const stats = this.vfs.statSync(src);
      if (stats.isFile()) {
        const content = this.vfs.readFileSync(src);
        this.vfs.writeFileSync(dest, content);
      } else if (stats.isDirectory()) {
        if (!(options2 == null ? void 0 : options2.recursive)) {
          throw new Error(`EISDIR: illegal operation on a directory, cannot copy '${src}'`);
        }
        await this.cpRecursive(src, dest);
      }
    }
    async cpRecursive(src, dest) {
      this.vfs.mkdirSync(dest, {
        recursive: true
      });
      const entries = this.vfs.readdirSync(src);
      for (const entry of entries) {
        const srcPath = src === "/" ? `/${entry}` : `${src}/${entry}`;
        const destPath = dest === "/" ? `/${entry}` : `${dest}/${entry}`;
        const stats = this.vfs.statSync(srcPath);
        if (stats.isDirectory()) {
          await this.cpRecursive(srcPath, destPath);
        } else {
          const content = this.vfs.readFileSync(srcPath);
          this.vfs.writeFileSync(destPath, content);
        }
      }
    }
    async mv(src, dest) {
      this.vfs.renameSync(src, dest);
    }
    resolvePath(base, path2) {
      if (path2.startsWith("/")) {
        return this.normalizePath(path2);
      }
      const combined = base.endsWith("/") ? `${base}${path2}` : `${base}/${path2}`;
      return this.normalizePath(combined);
    }
    normalizePath(path2) {
      if (!path2.startsWith("/")) {
        path2 = "/" + path2;
      }
      const parts = path2.split("/").filter(Boolean);
      const resolved = [];
      for (const part of parts) {
        if (part === "..") {
          resolved.pop();
        } else if (part !== ".") {
          resolved.push(part);
        }
      }
      return "/" + resolved.join("/");
    }
    getAllPaths() {
      const paths = [];
      this.collectPaths("/", paths);
      return paths;
    }
    collectPaths(dir, paths) {
      try {
        const entries = this.vfs.readdirSync(dir);
        for (const entry of entries) {
          const fullPath = dir === "/" ? `/${entry}` : `${dir}/${entry}`;
          paths.push(fullPath);
          try {
            const stats = this.vfs.statSync(fullPath);
            if (stats.isDirectory()) {
              this.collectPaths(fullPath, paths);
            }
          } catch {
          }
        }
      } catch {
      }
    }
    async chmod(_path, _mode) {
      if (!this.vfs.existsSync(_path)) {
        throw createNodeError("ENOENT", "chmod", _path);
      }
    }
    async symlink(_target, _linkPath) {
      throw new Error("Symbolic links are not supported in VirtualFS");
    }
    async link(_existingPath, _newPath) {
      throw new Error("Hard links are not supported in VirtualFS");
    }
    async readlink(_path) {
      throw new Error("Symbolic links are not supported in VirtualFS");
    }
    async lstat(path2) {
      return this.stat(path2);
    }
    async realpath(path2) {
      if (!this.vfs.existsSync(path2)) {
        throw createNodeError("ENOENT", "realpath", path2);
      }
      return this.normalizePath(path2);
    }
    async utimes(path2, _atime, _mtime) {
      if (!this.vfs.existsSync(path2)) {
        throw createNodeError("ENOENT", "utimes", path2);
      }
    }
  }
  if (typeof globalThis.process === "undefined") {
    globalThis.process = {
      env: {
        HOME: "/home/user",
        USER: "user",
        PATH: "/usr/local/bin:/usr/bin:/bin",
        NODE_ENV: "development"
      },
      cwd: () => "/",
      platform: "linux",
      version: "v18.0.0",
      versions: {
        node: "18.0.0"
      },
      stdout: {
        write: () => {
        }
      },
      stderr: {
        write: () => {
        }
      }
    };
  }
  let bashInstance = null;
  let vfsAdapter = null;
  let currentVfs = null;
  function initChildProcess(vfs2) {
    currentVfs = vfs2;
    vfsAdapter = new VirtualFSAdapter(vfs2);
    const nodeCommand = defineCommand("node", async (args, ctx) => {
      if (!currentVfs) {
        return {
          stdout: "",
          stderr: "VFS not initialized\n",
          exitCode: 1
        };
      }
      const scriptPath = args[0];
      if (!scriptPath) {
        return {
          stdout: "",
          stderr: "Usage: node <script.js> [args...]\n",
          exitCode: 1
        };
      }
      const resolvedPath2 = scriptPath.startsWith("/") ? scriptPath : `${ctx.cwd}/${scriptPath}`.replace(/\/+/g, "/");
      try {
        if (!currentVfs.existsSync(resolvedPath2)) {
          return {
            stdout: "",
            stderr: `Error: Cannot find module '${resolvedPath2}'
`,
            exitCode: 1
          };
        }
        let stdout = "";
        let stderr = "";
        const runtime = new Runtime(currentVfs, {
          cwd: ctx.cwd,
          env: ctx.env,
          onConsole: (method, consoleArgs) => {
            const msg = consoleArgs.map((a) => String(a)).join(" ") + "\n";
            if (method === "error") {
              stderr += msg;
            } else {
              stdout += msg;
            }
          }
        });
        const processShim = globalThis.process || {};
        const originalArgv = processShim.argv;
        processShim.argv = [
          "node",
          resolvedPath2,
          ...args.slice(1)
        ];
        globalThis.process = processShim;
        try {
          runtime.runFile(resolvedPath2);
          return {
            stdout,
            stderr,
            exitCode: 0
          };
        } finally {
          processShim.argv = originalArgv;
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        return {
          stdout: "",
          stderr: `Error: ${errorMsg}
`,
          exitCode: 1
        };
      }
    });
    const convexCommand = defineCommand("convex", async (args, ctx) => {
      if (!currentVfs) {
        return {
          stdout: "",
          stderr: "VFS not initialized\n",
          exitCode: 1
        };
      }
      const cliBundlePath = "/node_modules/convex/dist/cli.bundle.cjs";
      if (!currentVfs.existsSync(cliBundlePath)) {
        return {
          stdout: "",
          stderr: "Convex CLI not found. Run: npm install convex\n",
          exitCode: 1
        };
      }
      let stdout = "";
      let stderr = "";
      try {
        const runtime = new Runtime(currentVfs, {
          cwd: ctx.cwd,
          env: ctx.env,
          onConsole: (method, consoleArgs) => {
            const msg = consoleArgs.map((a) => String(a)).join(" ") + "\n";
            if (method === "error") {
              stderr += msg;
            } else {
              stdout += msg;
            }
          }
        });
        const processShim = globalThis.process || {};
        const originalArgv = processShim.argv;
        const originalEnv = {
          ...processShim.env
        };
        processShim.argv = [
          "node",
          "convex",
          ...args
        ];
        processShim.env = {
          ...processShim.env,
          ...ctx.env
        };
        globalThis.process = processShim;
        try {
          runtime.runFile(cliBundlePath);
          return {
            stdout,
            stderr,
            exitCode: 0
          };
        } finally {
          processShim.argv = originalArgv;
          processShim.env = originalEnv;
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        return {
          stdout,
          stderr: stderr + `Error: ${errorMsg}
`,
          exitCode: 1
        };
      }
    });
    bashInstance = new Bash({
      fs: vfsAdapter,
      cwd: "/",
      env: {
        HOME: "/home/user",
        USER: "user",
        PATH: "/usr/local/bin:/usr/bin:/bin:/node_modules/.bin",
        NODE_ENV: "development"
      },
      customCommands: [
        nodeCommand,
        convexCommand
      ]
    });
  }
  function exec(command, optionsOrCallback, callback) {
    let options2 = {};
    let cb;
    if (typeof optionsOrCallback === "function") {
      cb = optionsOrCallback;
    } else if (optionsOrCallback) {
      options2 = optionsOrCallback;
      cb = callback;
    }
    const child = new ChildProcess();
    (async () => {
      var _a2, _b2, _c2, _d;
      if (!bashInstance) {
        const error = new Error("child_process not initialized");
        child.emit("error", error);
        if (cb) cb(error, "", "");
        return;
      }
      try {
        const result = await bashInstance.exec(command, {
          cwd: options2.cwd,
          env: options2.env
        });
        const stdout = result.stdout || "";
        const stderr = result.stderr || "";
        if (stdout) {
          (_a2 = child.stdout) == null ? void 0 : _a2.push(BufferPolyfill.from(stdout));
        }
        (_b2 = child.stdout) == null ? void 0 : _b2.push(null);
        if (stderr) {
          (_c2 = child.stderr) == null ? void 0 : _c2.push(BufferPolyfill.from(stderr));
        }
        (_d = child.stderr) == null ? void 0 : _d.push(null);
        child.emit("close", result.exitCode, null);
        child.emit("exit", result.exitCode, null);
        if (cb) {
          if (result.exitCode !== 0) {
            const error = new Error(`Command failed: ${command}`);
            error.code = result.exitCode;
            cb(error, stdout, stderr);
          } else {
            cb(null, stdout, stderr);
          }
        }
      } catch (error) {
        child.emit("error", error);
        if (cb) cb(error, "", "");
      }
    })();
    return child;
  }
  function execSync(command, options2) {
    if (!bashInstance) {
      throw new Error("child_process not initialized");
    }
    throw new Error("execSync is not supported in browser environment. Use exec() with async/await or callbacks instead.");
  }
  function spawn(command, args, options2) {
    let spawnArgs = [];
    let spawnOptions = {};
    if (Array.isArray(args)) {
      spawnArgs = args;
      spawnOptions = options2 || {};
    } else if (args) {
      spawnOptions = args;
    }
    const child = new ChildProcess();
    const fullCommand = spawnArgs.length > 0 ? `${command} ${spawnArgs.map((arg) => arg.includes(" ") ? `"${arg}"` : arg).join(" ")}` : command;
    (async () => {
      var _a2, _b2, _c2, _d;
      if (!bashInstance) {
        const error = new Error("child_process not initialized");
        child.emit("error", error);
        return;
      }
      try {
        const result = await bashInstance.exec(fullCommand, {
          cwd: spawnOptions.cwd,
          env: spawnOptions.env
        });
        const stdout = result.stdout || "";
        const stderr = result.stderr || "";
        if (stdout) {
          (_a2 = child.stdout) == null ? void 0 : _a2.push(BufferPolyfill.from(stdout));
        }
        (_b2 = child.stdout) == null ? void 0 : _b2.push(null);
        if (stderr) {
          (_c2 = child.stderr) == null ? void 0 : _c2.push(BufferPolyfill.from(stderr));
        }
        (_d = child.stderr) == null ? void 0 : _d.push(null);
        child.emit("close", result.exitCode, null);
        child.emit("exit", result.exitCode, null);
      } catch (error) {
        child.emit("error", error);
      }
    })();
    return child;
  }
  function spawnSync(command, args, options2) {
    throw new Error("spawnSync is not supported in browser environment. Use spawn() instead.");
  }
  function execFile(file, args, options2, callback) {
    let execArgs = [];
    let execOptions = {};
    let cb;
    if (Array.isArray(args)) {
      execArgs = args;
      if (typeof options2 === "function") {
        cb = options2;
      } else if (options2) {
        execOptions = options2;
        cb = callback;
      }
    } else if (typeof args === "function") {
      cb = args;
    } else if (args) {
      execOptions = args;
      cb = options2;
    }
    const command = execArgs.length > 0 ? `${file} ${execArgs.join(" ")}` : file;
    return exec(command, execOptions, cb);
  }
  function fork$2() {
    throw new Error("fork is not supported in browser environment");
  }
  class ChildProcess extends EventEmitter {
    constructor() {
      super();
      __publicField(this, "pid");
      __publicField(this, "connected", false);
      __publicField(this, "killed", false);
      __publicField(this, "exitCode", null);
      __publicField(this, "signalCode", null);
      __publicField(this, "spawnargs", []);
      __publicField(this, "spawnfile", "");
      __publicField(this, "stdin");
      __publicField(this, "stdout");
      __publicField(this, "stderr");
      this.pid = Math.floor(Math.random() * 1e4) + 1e3;
      this.stdin = new Writable();
      this.stdout = new Readable();
      this.stderr = new Readable();
    }
    kill(signal) {
      this.killed = true;
      this.emit("exit", null, signal || "SIGTERM");
      return true;
    }
    disconnect() {
      this.connected = false;
    }
    send(message, callback) {
      if (callback) callback(new Error("IPC not supported"));
      return false;
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
  }
  const child_process = {
    exec,
    execSync,
    execFile,
    spawn,
    spawnSync,
    fork: fork$2,
    ChildProcess,
    initChildProcess
  };
  const childProcessShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    ChildProcess,
    default: child_process,
    exec,
    execFile,
    execSync,
    fork: fork$2,
    initChildProcess,
    spawn,
    spawnSync
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  let globalVFS$2 = null;
  function setVFS$2(vfs2) {
    globalVFS$2 = vfs2;
  }
  class FSWatcher extends EventEmitter {
    constructor(options2 = {}) {
      super();
      __publicField(this, "vfs");
      __publicField(this, "watched", /* @__PURE__ */ new Map());
      __publicField(this, "options");
      __publicField(this, "closed", false);
      __publicField(this, "ready", false);
      __publicField(this, "_eventCounts");
      if (!globalVFS$2) {
        throw new Error("chokidar: VirtualFS not initialized. Call setVFS first.");
      }
      this.vfs = globalVFS$2;
      this.options = options2;
    }
    shouldIgnore(path2) {
      const { ignored } = this.options;
      if (!ignored) return false;
      const ignoreList = Array.isArray(ignored) ? ignored : [
        ignored
      ];
      for (const pattern of ignoreList) {
        if (typeof pattern === "string") {
          if (path2 === pattern || path2.startsWith(pattern + "/")) return true;
        } else if (pattern instanceof RegExp) {
          if (pattern.test(path2)) return true;
        } else if (typeof pattern === "function") {
          if (pattern(path2)) return true;
        }
      }
      return false;
    }
    normalizePath(path2) {
      if (this.options.cwd && !path2.startsWith("/")) {
        path2 = this.options.cwd + "/" + path2;
      }
      if (!path2.startsWith("/")) {
        path2 = "/" + path2;
      }
      return path2;
    }
    add(paths) {
      if (this.closed) return this;
      const pathArray = Array.isArray(paths) ? paths : [
        paths
      ];
      const pendingEmits = [];
      console.log("[chokidar] add:", pathArray);
      for (const p of pathArray) {
        const normalized = this.normalizePath(p);
        if (this.shouldIgnore(normalized)) continue;
        if (this.watched.has(normalized)) continue;
        try {
          if (!this.vfs.existsSync(normalized)) {
            const parentPath = normalized.substring(0, normalized.lastIndexOf("/")) || "/";
            if (this.vfs.existsSync(parentPath)) {
              this.watchPath(parentPath, normalized);
            }
            continue;
          }
          const stats = this.vfs.statSync(normalized);
          if (!this.options.ignoreInitial) {
            if (stats.isDirectory()) {
              this.collectDirContents(normalized, pendingEmits);
            } else {
              pendingEmits.push(() => this.emit("add", normalized, stats));
            }
          }
          this.watchPath(normalized);
          if (stats.isDirectory()) {
            this.watchDirRecursive(normalized);
          }
        } catch (err) {
          this.emit("error", err);
        }
      }
      if (!this.ready) {
        this.ready = true;
        setTimeout(() => {
          for (const emitFn of pendingEmits) {
            emitFn();
          }
          this.emit("ready");
        }, 0);
      }
      return this;
    }
    collectDirContents(dirPath, pendingEmits) {
      try {
        const entries = this.vfs.readdirSync(dirPath);
        for (const entry of entries) {
          const fullPath = dirPath === "/" ? "/" + entry : dirPath + "/" + entry;
          if (this.shouldIgnore(fullPath)) continue;
          const stats = this.vfs.statSync(fullPath);
          if (stats.isDirectory()) {
            pendingEmits.push(() => this.emit("addDir", fullPath, stats));
            this.collectDirContents(fullPath, pendingEmits);
          } else {
            pendingEmits.push(() => this.emit("add", fullPath, stats));
          }
        }
      } catch {
      }
    }
    watchPath(path2, watchFor) {
      if (this.watched.has(path2)) return;
      const watcher = this.vfs.watch(path2, {
        recursive: true
      }, (eventType, filename2) => {
        if (this.closed) return;
        let fullPath;
        if (filename2) {
          fullPath = path2 === "/" ? "/" + filename2 : path2 + "/" + filename2;
        } else {
          fullPath = path2;
        }
        const eventKey = `${eventType}:${fullPath}`;
        if (!this._eventCounts) this._eventCounts = /* @__PURE__ */ new Map();
        const count = (this._eventCounts.get(eventKey) || 0) + 1;
        this._eventCounts.set(eventKey, count);
        if (count === 5) {
          console.warn(`[chokidar] Repeated event: ${eventType} on ${fullPath} (${count}+ times)`);
        }
        console.log("[chokidar] event:", eventType, fullPath);
        if (watchFor && fullPath !== watchFor && !fullPath.startsWith(watchFor + "/")) {
          return;
        }
        if (this.shouldIgnore(fullPath)) {
          console.log("[chokidar] ignored:", fullPath);
          return;
        }
        if (eventType === "rename") {
          if (this.vfs.existsSync(fullPath)) {
            try {
              const stats = this.vfs.statSync(fullPath);
              if (stats.isDirectory()) {
                console.log("[chokidar] emit addDir:", fullPath);
                this.emit("addDir", fullPath, stats);
              } else {
                console.log("[chokidar] emit add:", fullPath);
                this.emit("add", fullPath, stats);
              }
            } catch {
            }
          } else {
            console.log("[chokidar] emit unlink:", fullPath);
            this.emit("unlink", fullPath);
          }
        } else if (eventType === "change") {
          try {
            const stats = this.vfs.statSync(fullPath);
            console.log("[chokidar] emit change:", fullPath);
            this.emit("change", fullPath, stats);
          } catch {
            this.emit("unlink", fullPath);
          }
        }
      });
      this.watched.set(path2, watcher);
    }
    watchDirRecursive(dirPath, depth = 0) {
      if (this.options.depth !== void 0 && depth > this.options.depth) return;
      try {
        const entries = this.vfs.readdirSync(dirPath);
        for (const entry of entries) {
          const fullPath = dirPath === "/" ? "/" + entry : dirPath + "/" + entry;
          if (this.shouldIgnore(fullPath)) continue;
          try {
            const stats = this.vfs.statSync(fullPath);
            if (stats.isDirectory()) {
              this.watchPath(fullPath);
              this.watchDirRecursive(fullPath, depth + 1);
            }
          } catch {
          }
        }
      } catch {
      }
    }
    unwatch(paths) {
      const pathArray = Array.isArray(paths) ? paths : [
        paths
      ];
      for (const p of pathArray) {
        const normalized = this.normalizePath(p);
        const watcher = this.watched.get(normalized);
        if (watcher) {
          watcher.close();
          this.watched.delete(normalized);
        }
      }
      return this;
    }
    close() {
      this.closed = true;
      for (const watcher of this.watched.values()) {
        watcher.close();
      }
      this.watched.clear();
      this.emit("close");
      return Promise.resolve();
    }
    getWatched() {
      const result = {};
      for (const path2 of this.watched.keys()) {
        const dir = path2.substring(0, path2.lastIndexOf("/")) || "/";
        const basename2 = path2.substring(path2.lastIndexOf("/") + 1);
        if (!result[dir]) {
          result[dir] = [];
        }
        result[dir].push(basename2);
      }
      return result;
    }
  }
  function watch$2(paths, options2) {
    const watcher = new FSWatcher(options2);
    watcher.add(paths);
    return watcher;
  }
  const chokidar = {
    watch: watch$2,
    FSWatcher,
    setVFS: setVFS$2
  };
  chokidarShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    FSWatcher,
    default: chokidar,
    setVFS: setVFS$2,
    watch: watch$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const CloseEventPolyfill = typeof CloseEvent !== "undefined" ? CloseEvent : class CloseEvent2 extends Event {
    constructor(type2, init2) {
      super(type2);
      __publicField(this, "code");
      __publicField(this, "reason");
      __publicField(this, "wasClean");
      this.code = (init2 == null ? void 0 : init2.code) ?? 1e3;
      this.reason = (init2 == null ? void 0 : init2.reason) ?? "";
      this.wasClean = (init2 == null ? void 0 : init2.wasClean) ?? true;
    }
  };
  const MessageEventPolyfill = typeof MessageEvent !== "undefined" ? MessageEvent : class MessageEvent2 extends Event {
    constructor(type2, init2) {
      super(type2);
      __publicField(this, "data");
      this.data = init2 == null ? void 0 : init2.data;
    }
  };
  let messageChannel = null;
  try {
    messageChannel = new BroadcastChannel("vite-ws-channel");
  } catch {
  }
  const servers = /* @__PURE__ */ new Map();
  let clientIdCounter = 0;
  const _WebSocket = class _WebSocket extends EventEmitter {
    constructor(url2, protocols) {
      super();
      __publicField(this, "CONNECTING", _WebSocket.CONNECTING);
      __publicField(this, "OPEN", _WebSocket.OPEN);
      __publicField(this, "CLOSING", _WebSocket.CLOSING);
      __publicField(this, "CLOSED", _WebSocket.CLOSED);
      __publicField(this, "readyState", _WebSocket.CONNECTING);
      __publicField(this, "url");
      __publicField(this, "protocol", "");
      __publicField(this, "extensions", "");
      __publicField(this, "bufferedAmount", 0);
      __publicField(this, "binaryType", "blob");
      __publicField(this, "_id");
      __publicField(this, "_server", null);
      __publicField(this, "_nativeWs", null);
      __publicField(this, "onopen", null);
      __publicField(this, "onclose", null);
      __publicField(this, "onerror", null);
      __publicField(this, "onmessage", null);
      this.url = url2;
      this._id = `client-${++clientIdCounter}`;
      if (protocols) {
        this.protocol = Array.isArray(protocols) ? protocols[0] : protocols;
      }
      setTimeout(() => this._connect(), 0);
    }
    _connect() {
      if (this.url.startsWith("internal://")) {
        this.readyState = _WebSocket.OPEN;
        this.emit("open");
        if (this.onopen) this.onopen(new Event("open"));
        return;
      }
      if (this.url.startsWith("ws://") || this.url.startsWith("wss://")) {
        this._connectNative();
        return;
      }
      if (!messageChannel) {
        setTimeout(() => {
          this.readyState = _WebSocket.OPEN;
          this.emit("open");
          if (this.onopen) this.onopen(new Event("open"));
        }, 0);
        return;
      }
      messageChannel.postMessage({
        type: "connect",
        clientId: this._id,
        url: this.url
      });
      const channel2 = messageChannel;
      const handler = (event) => {
        const data2 = event.data;
        if (data2.targetClient !== this._id) return;
        switch (data2.type) {
          case "connected":
            this.readyState = _WebSocket.OPEN;
            this.emit("open");
            if (this.onopen) this.onopen(new Event("open"));
            break;
          case "message":
            const msgEvent = new MessageEventPolyfill("message", {
              data: data2.payload
            });
            this.emit("message", msgEvent);
            if (this.onmessage) this.onmessage(msgEvent);
            break;
          case "close":
            this.readyState = _WebSocket.CLOSED;
            const closeEvent = new CloseEventPolyfill("close", {
              code: data2.code || 1e3,
              reason: data2.reason || "",
              wasClean: true
            });
            this.emit("close", closeEvent);
            if (this.onclose) this.onclose(closeEvent);
            channel2.removeEventListener("message", handler);
            break;
          case "error":
            const errorEvent = new Event("error");
            this.emit("error", errorEvent);
            if (this.onerror) this.onerror(errorEvent);
            break;
        }
      };
      channel2.addEventListener("message", handler);
      setTimeout(() => {
        if (this.readyState === _WebSocket.CONNECTING) {
          this.readyState = _WebSocket.OPEN;
          this.emit("open");
          if (this.onopen) this.onopen(new Event("open"));
        }
      }, 100);
    }
    _connectNative() {
      const isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
      const NativeWS = isBrowser2 && typeof globalThis.WebSocket === "function" && globalThis.WebSocket !== _WebSocket ? globalThis.WebSocket : null;
      if (!NativeWS) {
        setTimeout(() => {
          this.readyState = _WebSocket.OPEN;
          this.emit("open");
          if (this.onopen) this.onopen(new Event("open"));
        }, 0);
        return;
      }
      try {
        this._nativeWs = new NativeWS(this.url);
        this._nativeWs.binaryType = this.binaryType === "arraybuffer" ? "arraybuffer" : "blob";
      } catch {
        this.readyState = _WebSocket.CLOSED;
        const errorEvent = new Event("error");
        this.emit("error", errorEvent);
        if (this.onerror) this.onerror(errorEvent);
        return;
      }
      this._nativeWs.onopen = () => {
        this.readyState = _WebSocket.OPEN;
        this.emit("open");
        if (this.onopen) this.onopen(new Event("open"));
      };
      this._nativeWs.onmessage = (event) => {
        const msgEvent = new MessageEventPolyfill("message", {
          data: event.data
        });
        this.emit("message", msgEvent);
        if (this.onmessage) this.onmessage(msgEvent);
      };
      this._nativeWs.onclose = (event) => {
        this.readyState = _WebSocket.CLOSED;
        this._nativeWs = null;
        const closeEvent = new CloseEventPolyfill("close", {
          code: event.code,
          reason: event.reason,
          wasClean: event.wasClean
        });
        this.emit("close", closeEvent);
        if (this.onclose) this.onclose(closeEvent);
      };
      this._nativeWs.onerror = () => {
        const errorEvent = new Event("error");
        this.emit("error", errorEvent);
        if (this.onerror) this.onerror(errorEvent);
      };
    }
    send(data2) {
      if (this.readyState !== _WebSocket.OPEN) {
        throw new Error("WebSocket is not open");
      }
      if (this._nativeWs) {
        this._nativeWs.send(data2);
        return;
      }
      if (this._server) {
        this._server._handleClientMessage(this, data2);
        return;
      }
      if (messageChannel) {
        messageChannel.postMessage({
          type: "message",
          clientId: this._id,
          url: this.url,
          payload: data2
        });
      }
    }
    close(code2, reason) {
      if (this.readyState === _WebSocket.CLOSED || this.readyState === _WebSocket.CLOSING) {
        return;
      }
      this.readyState = _WebSocket.CLOSING;
      if (this._nativeWs) {
        this._nativeWs.close(code2, reason);
        return;
      }
      if (messageChannel) {
        messageChannel.postMessage({
          type: "disconnect",
          clientId: this._id,
          url: this.url,
          code: code2,
          reason
        });
      }
      setTimeout(() => {
        this.readyState = _WebSocket.CLOSED;
        const closeEvent = new CloseEventPolyfill("close", {
          code: code2 || 1e3,
          reason: reason || "",
          wasClean: true
        });
        this.emit("close", closeEvent);
        if (this.onclose) this.onclose(closeEvent);
      }, 0);
    }
    ping() {
    }
    pong() {
    }
    terminate() {
      if (this._nativeWs) {
        this._nativeWs.close();
        this._nativeWs = null;
      }
      this.readyState = _WebSocket.CLOSED;
      const closeEvent = new CloseEventPolyfill("close", {
        code: 1006,
        reason: "Connection terminated",
        wasClean: false
      });
      this.emit("close", closeEvent);
      if (this.onclose) this.onclose(closeEvent);
    }
    _setServer(server) {
      this._server = server;
    }
    _receiveMessage(data2) {
      const msgEvent = new MessageEventPolyfill("message", {
        data: data2
      });
      this.emit("message", msgEvent);
      if (this.onmessage) this.onmessage(msgEvent);
    }
  };
  __publicField(_WebSocket, "CONNECTING", 0);
  __publicField(_WebSocket, "OPEN", 1);
  __publicField(_WebSocket, "CLOSING", 2);
  __publicField(_WebSocket, "CLOSED", 3);
  let WebSocket = _WebSocket;
  class WebSocketServer extends EventEmitter {
    constructor(options2 = {}) {
      super();
      __publicField(this, "clients", /* @__PURE__ */ new Set());
      __publicField(this, "options");
      __publicField(this, "_path");
      __publicField(this, "_channelHandler", null);
      this.options = options2;
      this._path = options2.path || "/";
      if (!options2.noServer) {
        this._setupListener();
      }
      servers.set(this._path, this);
    }
    _setupListener() {
      if (!messageChannel) return;
      const channel2 = messageChannel;
      this._channelHandler = (event) => {
        const data2 = event.data;
        if (data2.type === "connect") {
          const ws = new WebSocket("internal://" + this._path);
          ws._setServer(this);
          ws._clientId = data2.clientId;
          this.clients.add(ws);
          channel2.postMessage({
            type: "connected",
            targetClient: data2.clientId
          });
          this.emit("connection", ws, {
            url: data2.url
          });
        }
        if (data2.type === "message") {
          for (const client of this.clients) {
            if (client._clientId === data2.clientId) {
              client._receiveMessage(data2.payload);
              break;
            }
          }
        }
        if (data2.type === "disconnect") {
          for (const client of this.clients) {
            if (client._clientId === data2.clientId) {
              client.close(data2.code, data2.reason);
              this.clients.delete(client);
              break;
            }
          }
        }
      };
      channel2.addEventListener("message", this._channelHandler);
    }
    _handleClientMessage(client, data2) {
      const msgEvent = new MessageEventPolyfill("message", {
        data: data2
      });
      client.emit("message", msgEvent);
    }
    handleUpgrade(request2, socket, head, callback) {
      const ws = new WebSocket("internal://" + this._path);
      ws._setServer(this);
      if (this.options.clientTracking !== false) {
        this.clients.add(ws);
      }
      setTimeout(() => {
        callback(ws, request2);
        this.emit("connection", ws, request2);
      }, 0);
    }
    close(callback) {
      for (const client of this.clients) {
        client.close(1001, "Server shutting down");
      }
      this.clients.clear();
      servers.delete(this._path);
      if (this._channelHandler && messageChannel) {
        messageChannel.removeEventListener("message", this._channelHandler);
        this._channelHandler = null;
      }
      this.emit("close");
      if (callback) {
        setTimeout(callback, 0);
      }
    }
    address() {
      return {
        port: this.options.port || 0,
        family: "IPv4",
        address: this.options.host || "0.0.0.0"
      };
    }
  }
  const Server$1 = WebSocketServer;
  const createWebSocketStream = () => {
    throw new Error("createWebSocketStream is not supported in browser");
  };
  wsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Server: Server$1,
    WebSocket,
    WebSocketServer,
    createWebSocketStream,
    default: WebSocket
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const constants$1 = {
    kFSEventStreamEventFlagNone: 0,
    kFSEventStreamEventFlagMustScanSubDirs: 1,
    kFSEventStreamEventFlagUserDropped: 2,
    kFSEventStreamEventFlagKernelDropped: 4,
    kFSEventStreamEventFlagEventIdsWrapped: 8,
    kFSEventStreamEventFlagHistoryDone: 16,
    kFSEventStreamEventFlagRootChanged: 32,
    kFSEventStreamEventFlagMount: 64,
    kFSEventStreamEventFlagUnmount: 128,
    kFSEventStreamEventFlagItemCreated: 256,
    kFSEventStreamEventFlagItemRemoved: 512,
    kFSEventStreamEventFlagItemInodeMetaMod: 1024,
    kFSEventStreamEventFlagItemRenamed: 2048,
    kFSEventStreamEventFlagItemModified: 4096,
    kFSEventStreamEventFlagItemFinderInfoMod: 8192,
    kFSEventStreamEventFlagItemChangeOwner: 16384,
    kFSEventStreamEventFlagItemXattrMod: 32768,
    kFSEventStreamEventFlagItemIsFile: 65536,
    kFSEventStreamEventFlagItemIsDir: 131072,
    kFSEventStreamEventFlagItemIsSymlink: 262144
  };
  function watch$1(path2, handler) {
    return () => Promise.resolve();
  }
  function getInfo(path2, flags) {
    return {
      event: "unknown",
      path: path2,
      type: "file",
      changes: {
        inode: false,
        finder: false,
        access: false,
        xattrs: false
      },
      flags
    };
  }
  const fsevents = {
    watch: watch$1,
    getInfo,
    constants: constants$1
  };
  fseventsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    constants: constants$1,
    default: fsevents,
    getInfo,
    watch: watch$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  let globalVFS$1 = null;
  function setVFS$1(vfs2) {
    globalVFS$1 = vfs2;
  }
  class ReaddirpStream {
    constructor(root, options2 = {}) {
      __publicField(this, "options");
      __publicField(this, "root");
      __publicField(this, "entries", []);
      __publicField(this, "index", 0);
      __publicField(this, "collected", false);
      __publicField(this, "listeners", /* @__PURE__ */ new Map());
      this.root = root;
      this.options = options2;
    }
    matchFilter(entry, filter) {
      if (!filter) return true;
      if (typeof filter === "function") {
        return filter(entry);
      }
      const patterns = Array.isArray(filter) ? filter : [
        filter
      ];
      for (const pattern of patterns) {
        if (pattern.startsWith("!")) {
          const posPattern = pattern.slice(1);
          if (this.matchGlob(entry.basename, posPattern)) {
            return false;
          }
        } else if (this.matchGlob(entry.basename, pattern)) {
          return true;
        }
      }
      return patterns.length === 0 || patterns.every((p) => p.startsWith("!"));
    }
    matchGlob(name2, pattern) {
      if (pattern === "*") return true;
      if (pattern.startsWith("*.")) {
        const ext = pattern.slice(1);
        return name2.endsWith(ext);
      }
      if (pattern.endsWith("*")) {
        const prefix = pattern.slice(0, -1);
        return name2.startsWith(prefix);
      }
      return name2 === pattern;
    }
    collect(dir, depth, relativePath = "") {
      if (!globalVFS$1) return;
      if (this.options.depth !== void 0 && depth > this.options.depth) return;
      try {
        const entries = globalVFS$1.readdirSync(dir);
        for (const name2 of entries) {
          const fullPath = dir === "/" ? "/" + name2 : dir + "/" + name2;
          const relPath = relativePath ? relativePath + "/" + name2 : name2;
          try {
            const stats = globalVFS$1.statSync(fullPath);
            const isDir = stats.isDirectory();
            const entry = {
              path: relPath,
              fullPath,
              basename: name2,
              stats: this.options.alwaysStat ? stats : void 0,
              dirent: {
                isFile: () => !isDir,
                isDirectory: () => isDir,
                name: name2
              }
            };
            const type2 = this.options.type || "files";
            if (isDir) {
              if (!this.matchFilter(entry, this.options.directoryFilter)) {
                continue;
              }
              if (type2 === "directories" || type2 === "files_directories" || type2 === "all") {
                this.entries.push(entry);
              }
              this.collect(fullPath, depth + 1, relPath);
            } else {
              if (type2 === "files" || type2 === "files_directories" || type2 === "all") {
                if (this.matchFilter(entry, this.options.fileFilter)) {
                  this.entries.push(entry);
                }
              }
            }
          } catch {
          }
        }
      } catch {
      }
    }
    async *[Symbol.asyncIterator]() {
      if (!this.collected) {
        this.collect(this.root, 0);
        this.collected = true;
      }
      for (const entry of this.entries) {
        yield entry;
      }
    }
    async toArray() {
      if (!this.collected) {
        this.collect(this.root, 0);
        this.collected = true;
      }
      return [
        ...this.entries
      ];
    }
    on(event, callback) {
      if (event === "data") {
        setTimeout(async () => {
          if (!this.collected) {
            this.collect(this.root, 0);
            this.collected = true;
          }
          for (const entry of this.entries) {
            callback(entry);
          }
          this.emit("end");
        }, 0);
      }
      return this;
    }
    emit(event, ...args) {
      const handlers = this.listeners.get(event);
      if (handlers) {
        for (const handler of handlers) {
          handler(...args);
        }
      }
    }
    once(event, callback) {
      const wrapper = (...args) => {
        callback(...args);
        this.off(event, wrapper);
      };
      return this.on(event, wrapper);
    }
    off(event, callback) {
      const handlers = this.listeners.get(event);
      if (handlers) {
        const index2 = handlers.indexOf(callback);
        if (index2 !== -1) {
          handlers.splice(index2, 1);
        }
      }
      return this;
    }
  }
  function readdirp(root, options2) {
    return new ReaddirpStream(root, options2);
  }
  async function readdirpPromise(root, options2) {
    const stream2 = new ReaddirpStream(root, options2);
    return stream2.toArray();
  }
  readdirpShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    ReaddirpStream,
    default: readdirp,
    readdirp,
    readdirpPromise,
    setVFS: setVFS$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function createRequire$1(filename2) {
    return function require2(id) {
      throw new Error(`Cannot find module '${id}' from '${filename2}'`);
    };
  }
  const builtinModules$1 = [
    "assert",
    "buffer",
    "child_process",
    "cluster",
    "console",
    "constants",
    "crypto",
    "dgram",
    "dns",
    "domain",
    "events",
    "fs",
    "http",
    "https",
    "module",
    "net",
    "os",
    "path",
    "perf_hooks",
    "process",
    "punycode",
    "querystring",
    "readline",
    "repl",
    "stream",
    "string_decoder",
    "sys",
    "timers",
    "tls",
    "tty",
    "url",
    "util",
    "v8",
    "vm",
    "worker_threads",
    "zlib"
  ];
  function isBuiltin(moduleName) {
    const name2 = moduleName.startsWith("node:") ? moduleName.slice(5) : moduleName;
    return builtinModules$1.includes(name2);
  }
  const _cache = {};
  const _extensions = {
    ".js": () => {
    },
    ".json": () => {
    },
    ".node": () => {
    }
  };
  const _pathCache = {};
  function syncBuiltinESMExports() {
  }
  const Module$1 = {
    createRequire: createRequire$1,
    builtinModules: builtinModules$1,
    isBuiltin,
    _cache,
    _extensions,
    _pathCache,
    syncBuiltinESMExports
  };
  moduleShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Module: Module$1,
    _cache,
    _extensions,
    _pathCache,
    builtinModules: builtinModules$1,
    createRequire: createRequire$1,
    default: Module$1,
    isBuiltin,
    syncBuiltinESMExports
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const performance$1 = globalThis.performance || {
    now: () => Date.now(),
    timeOrigin: Date.now(),
    mark: () => {
    },
    measure: () => {
    },
    getEntries: () => [],
    getEntriesByName: () => [],
    getEntriesByType: () => [],
    clearMarks: () => {
    },
    clearMeasures: () => {
    },
    clearResourceTimings: () => {
    }
  };
  class PerformanceObserver {
    constructor(callback) {
      __publicField(this, "callback");
      __publicField(this, "entryTypes", []);
      this.callback = callback;
    }
    observe(options2) {
      this.entryTypes = options2.entryTypes || (options2.type ? [
        options2.type
      ] : []);
    }
    disconnect() {
      this.entryTypes = [];
    }
    takeRecords() {
      return [];
    }
  }
  __publicField(PerformanceObserver, "supportedEntryTypes", [
    "mark",
    "measure",
    "resource",
    "navigation"
  ]);
  class Histogram {
    constructor() {
      __publicField(this, "min", 0);
      __publicField(this, "max", 0);
      __publicField(this, "mean", 0);
      __publicField(this, "stddev", 0);
      __publicField(this, "percentiles", /* @__PURE__ */ new Map());
      __publicField(this, "exceeds", 0);
    }
    reset() {
      this.min = 0;
      this.max = 0;
      this.mean = 0;
      this.stddev = 0;
      this.percentiles.clear();
      this.exceeds = 0;
    }
    percentile(percentile) {
      return this.percentiles.get(percentile) || 0;
    }
  }
  function createHistogram() {
    return new Histogram();
  }
  function monitorEventLoopDelay(options2) {
    const histogram = new Histogram();
    return histogram;
  }
  const perf_hooks = {
    performance: performance$1,
    PerformanceObserver,
    createHistogram,
    monitorEventLoopDelay
  };
  perfHooksShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Histogram,
    PerformanceObserver,
    createHistogram,
    default: perf_hooks,
    monitorEventLoopDelay,
    performance: performance$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const isMainThread = true;
  const parentPort = null;
  const workerData = null;
  const threadId = 0;
  let Worker$2 = class Worker extends EventEmitter {
    constructor(filename2, options2) {
      super();
      __publicField(this, "threadId", 0);
      __publicField(this, "resourceLimits", {});
      console.warn("Worker threads are not fully supported in browser environment");
    }
    postMessage(value2, transferList) {
    }
    terminate() {
      return Promise.resolve(0);
    }
    ref() {
    }
    unref() {
    }
    getHeapSnapshot() {
      return Promise.resolve({});
    }
  };
  let MessageChannel$1 = class MessageChannel {
    constructor() {
      __publicField(this, "port1", new MessagePort());
      __publicField(this, "port2", new MessagePort());
    }
  };
  class MessagePort extends EventEmitter {
    postMessage(value2, transferList) {
    }
    start() {
    }
    close() {
    }
    ref() {
    }
    unref() {
    }
  }
  let BroadcastChannel$1 = class BroadcastChannel extends EventEmitter {
    constructor(name2) {
      super();
      __publicField(this, "name");
      this.name = name2;
    }
    postMessage(message) {
    }
    close() {
    }
    ref() {
    }
    unref() {
    }
  };
  function moveMessagePortToContext(port, contextifiedSandbox) {
    return port;
  }
  function receiveMessageOnPort(port) {
    return void 0;
  }
  const SHARE_ENV = Symbol.for("nodejs.worker_threads.SHARE_ENV");
  function markAsUntransferable(object) {
  }
  function getEnvironmentData(key) {
    return void 0;
  }
  function setEnvironmentData(key, value2) {
  }
  const worker_threads = {
    isMainThread,
    parentPort,
    workerData,
    threadId,
    Worker: Worker$2,
    MessageChannel: MessageChannel$1,
    MessagePort,
    BroadcastChannel: BroadcastChannel$1,
    moveMessagePortToContext,
    receiveMessageOnPort,
    SHARE_ENV,
    markAsUntransferable,
    getEnvironmentData,
    setEnvironmentData
  };
  workerThreadsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    BroadcastChannel: BroadcastChannel$1,
    MessageChannel: MessageChannel$1,
    MessagePort,
    SHARE_ENV,
    Worker: Worker$2,
    default: worker_threads,
    getEnvironmentData,
    isMainThread,
    markAsUntransferable,
    moveMessagePortToContext,
    parentPort,
    receiveMessageOnPort,
    setEnvironmentData,
    threadId,
    workerData
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const EXPORT_CONDITION_PRIORITY = [
    "convex",
    "module",
    "import",
    "require",
    "default"
  ];
  function resolveExportConditions(entry) {
    if (typeof entry === "string") {
      return entry;
    }
    if (typeof entry === "object" && entry !== null) {
      for (const condition of EXPORT_CONDITION_PRIORITY) {
        const conditionValue = entry[condition];
        if (conditionValue !== void 0) {
          const result = resolveExportConditions(conditionValue);
          if (result) {
            return result;
          }
        }
      }
    }
    return void 0;
  }
  function resolveNodeModuleImport(vfs2, importPath, extensions) {
    const pathParts = importPath.split("/");
    const isScoped = pathParts[0].startsWith("@");
    const moduleName = isScoped ? pathParts.slice(0, 2).join("/") : pathParts[0];
    const subPath = isScoped ? pathParts.slice(2).join("/") : pathParts.slice(1).join("/");
    const nodeModulesBase = "/project/node_modules/" + moduleName;
    if (!vfs2.existsSync(nodeModulesBase)) {
      return null;
    }
    const packageJsonPath = nodeModulesBase + "/package.json";
    if (!vfs2.existsSync(packageJsonPath)) {
      return null;
    }
    try {
      const packageJsonContent = vfs2.readFileSync(packageJsonPath, "utf8");
      const packageJson = JSON.parse(packageJsonContent);
      let resolvedPath2 = null;
      if (subPath) {
        resolvedPath2 = resolveSubpathImport(vfs2, packageJson, nodeModulesBase, subPath, extensions);
      } else {
        resolvedPath2 = resolveMainImport(vfs2, packageJson, nodeModulesBase, extensions);
      }
      if (resolvedPath2) {
        return {
          path: resolvedPath2,
          pluginData: {
            fromVFS: true
          }
        };
      }
    } catch {
    }
    return null;
  }
  function resolveSubpathImport(vfs2, packageJson, nodeModulesBase, subPath, extensions) {
    if (packageJson.exports && typeof packageJson.exports === "object") {
      const exportKey = "./" + subPath;
      const exportsMap = packageJson.exports;
      const exportEntry = exportsMap[exportKey];
      if (exportEntry) {
        const exportPath = resolveExportConditions(exportEntry);
        if (exportPath) {
          const resolvedPath2 = nodeModulesBase + "/" + exportPath.replace(/^\.\//, "");
          const foundPath = findVFSFile(vfs2, resolvedPath2, [
            "",
            ".js",
            ".ts",
            ".mjs"
          ]);
          if (foundPath) {
            return foundPath;
          }
        }
      }
    }
    const directPath = nodeModulesBase + "/" + subPath;
    return findVFSFile(vfs2, directPath, extensions);
  }
  function resolveMainImport(vfs2, packageJson, nodeModulesBase, extensions) {
    if (packageJson.exports) {
      const mainExport = typeof packageJson.exports === "object" && !Array.isArray(packageJson.exports) ? packageJson.exports["."] || packageJson.exports : packageJson.exports;
      const exportPath = resolveExportConditions(mainExport);
      if (exportPath) {
        const resolvedPath22 = nodeModulesBase + "/" + exportPath.replace(/^\.\//, "");
        const foundPath = findVFSFile(vfs2, resolvedPath22, [
          "",
          ".js",
          ".ts",
          ".mjs"
        ]);
        if (foundPath) {
          return foundPath;
        }
      }
    }
    const mainField = packageJson.module || packageJson.main || "index.js";
    const resolvedPath2 = nodeModulesBase + "/" + mainField.replace(/^\.\//, "");
    return findVFSFile(vfs2, resolvedPath2, extensions);
  }
  let esbuildInstance = null;
  let initPromise = null;
  let wasmURL = "https://unpkg.com/esbuild-wasm@0.20.0/esbuild.wasm";
  let globalVFS = null;
  function setVFS(vfs2) {
    globalVFS = vfs2;
  }
  function setWasmURL(url2) {
    wasmURL = url2;
  }
  async function initialize(options2) {
    if (esbuildInstance) {
      return;
    }
    if (typeof window !== "undefined" && window.__esbuild) {
      esbuildInstance = window.__esbuild;
      return;
    }
    if (typeof window !== "undefined" && window.__esbuildInitPromise) {
      await window.__esbuildInitPromise;
      if (window.__esbuild) {
        esbuildInstance = window.__esbuild;
        return;
      }
    }
    if (initPromise) {
      return initPromise;
    }
    initPromise = (async () => {
      try {
        const esbuild2 = await import("https://unpkg.com/esbuild-wasm@0.20.0/esm/browser.min.js").then(async (m) => {
          await m.__tla;
          return m;
        });
        await esbuild2.initialize({
          wasmURL: (options2 == null ? void 0 : options2.wasmURL) || wasmURL
        });
        esbuildInstance = esbuild2;
      } catch (error) {
        initPromise = null;
        throw new Error(`Failed to initialize esbuild-wasm: ${error}`);
      }
    })();
    return initPromise;
  }
  function isInitialized() {
    return esbuildInstance !== null;
  }
  async function transform(code2, options2) {
    if (!esbuildInstance) {
      await initialize();
    }
    if (!esbuildInstance) {
      throw new Error("esbuild not initialized");
    }
    return esbuildInstance.transform(code2, options2);
  }
  function transformSync(code2, options2) {
    if (!esbuildInstance) {
      throw new Error("esbuild not initialized. Call initialize() first.");
    }
    throw new Error("transformSync is not available in browser. Use transform() instead.");
  }
  async function transformToCommonJS(code2, options2) {
    const result = await transform(code2, {
      loader: (options2 == null ? void 0 : options2.loader) || "js",
      format: "cjs",
      target: "es2020"
    });
    return result.code;
  }
  function remapVFSPath(path2) {
    if (path2 === "/convex" || path2.startsWith("/convex/")) {
      return "/project" + path2;
    }
    return path2;
  }
  function findVFSFile(vfs2, originalPath, extensions) {
    for (const ext of extensions) {
      const pathWithExt = originalPath + ext;
      if (vfs2.existsSync(pathWithExt)) {
        return pathWithExt;
      }
      const remapped = remapVFSPath(pathWithExt);
      if (remapped !== pathWithExt && vfs2.existsSync(remapped)) {
        return pathWithExt;
      }
    }
    return null;
  }
  function createVFSPlugin() {
    if (!globalVFS) {
      return null;
    }
    const vfs2 = globalVFS;
    return {
      name: "vfs-loader",
      setup(build2) {
        const b = build2;
        b.onResolve({
          filter: /.*/
        }, (args) => {
          const { path: importPath, importer } = args;
          if (importPath.startsWith("node_modules/")) {
            return {
              external: true
            };
          }
          const extensions = [
            "",
            ".ts",
            ".tsx",
            ".js",
            ".jsx",
            ".json"
          ];
          if (importPath.startsWith("/")) {
            const foundPath = findVFSFile(vfs2, importPath, extensions);
            if (foundPath) {
              return {
                path: foundPath,
                pluginData: {
                  fromVFS: true
                }
              };
            }
            return {
              external: true
            };
          }
          if (importPath.startsWith(".")) {
            let resolved = importPath;
            if (importer) {
              const importerDir = importer.substring(0, importer.lastIndexOf("/"));
              resolved = importerDir + "/" + importPath;
            }
            const parts = resolved.split("/").filter(Boolean);
            const normalized = [];
            for (const part of parts) {
              if (part === "..") {
                normalized.pop();
              } else if (part !== ".") {
                normalized.push(part);
              }
            }
            resolved = "/" + normalized.join("/");
            const foundPath = findVFSFile(vfs2, resolved, extensions);
            if (foundPath) {
              return {
                path: foundPath,
                pluginData: {
                  fromVFS: true
                }
              };
            }
            for (const ext of [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]) {
              const indexPath = resolved + "/index" + ext;
              const foundIndex = findVFSFile(vfs2, indexPath, [
                ""
              ]);
              if (foundIndex) {
                return {
                  path: foundIndex,
                  pluginData: {
                    fromVFS: true
                  }
                };
              }
            }
          }
          const resolution2 = resolveNodeModuleImport(vfs2, importPath, extensions);
          if (resolution2) {
            return resolution2;
          }
          return {
            external: true
          };
        });
        b.onLoad({
          filter: /^\/.*/
        }, (args) => {
          var _a2;
          if (!((_a2 = args.pluginData) == null ? void 0 : _a2.fromVFS)) {
            return null;
          }
          try {
            let contents;
            const originalPath = args.path;
            const remappedPath = remapVFSPath(originalPath);
            if (vfs2.existsSync(originalPath)) {
              contents = vfs2.readFileSync(originalPath, "utf8");
            } else if (remappedPath !== originalPath && vfs2.existsSync(remappedPath)) {
              contents = vfs2.readFileSync(remappedPath, "utf8");
            } else {
              throw new Error(`File not found: ${originalPath} (tried ${remappedPath})`);
            }
            const ext = originalPath.substring(originalPath.lastIndexOf("."));
            let loader = "ts";
            if (ext === ".tsx") loader = "tsx";
            else if (ext === ".js") loader = "js";
            else if (ext === ".jsx") loader = "jsx";
            else if (ext === ".json") loader = "json";
            return {
              contents,
              loader
            };
          } catch (err) {
            return {
              errors: [
                {
                  text: `Failed to load ${args.path}: ${err}`
                }
              ]
            };
          }
        });
      }
    };
  }
  async function build(options2) {
    if (!esbuildInstance) {
      await initialize();
    }
    if (!esbuildInstance) {
      throw new Error("esbuild not initialized");
    }
    const vfsPlugin = createVFSPlugin();
    const plugins = [
      ...options2.plugins || []
    ];
    if (vfsPlugin) {
      plugins.unshift(vfsPlugin);
    }
    let entryPoints = options2.entryPoints;
    if (entryPoints && globalVFS) {
      const absWorkingDir = options2.absWorkingDir || (typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/");
      entryPoints = entryPoints.map((ep) => {
        if (ep.includes("vfs:")) {
          const vfsIndex = ep.indexOf("vfs:");
          ep = ep.substring(vfsIndex + 4);
        }
        if (ep.startsWith("/")) {
          return ep;
        }
        if (ep.startsWith("./")) {
          const base = absWorkingDir.endsWith("/") ? absWorkingDir.slice(0, -1) : absWorkingDir;
          const relative2 = ep.slice(2);
          const resolved = base + "/" + relative2;
          return resolved;
        }
        if (ep.startsWith("../")) {
          const base = absWorkingDir.endsWith("/") ? absWorkingDir.slice(0, -1) : absWorkingDir;
          const parts = base.split("/").filter(Boolean);
          parts.pop();
          const relative2 = ep.slice(3);
          const resolved = "/" + parts.join("/") + "/" + relative2;
          return resolved;
        }
        return ep;
      });
    }
    const resolvedAbsWorkingDir = options2.absWorkingDir || (typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/");
    const result = await esbuildInstance.build({
      ...options2,
      entryPoints,
      plugins,
      write: false,
      absWorkingDir: resolvedAbsWorkingDir
    });
    if (result.outputFiles) {
      for (const file of result.outputFiles) {
        if (file.path.includes("vfs:")) {
          file.path = file.path.replace(/vfs:/g, "");
        }
      }
    }
    return result;
  }
  function buildSync(_options2) {
    throw new Error("buildSync is not available in browser. Use build() instead.");
  }
  function version$1() {
    return "0.20.0";
  }
  async function context(_options2) {
    throw new Error("esbuild context API is not supported in browser");
  }
  const esbuild = {
    initialize,
    isInitialized,
    transform,
    transformSync,
    transformToCommonJS,
    build,
    buildSync,
    context,
    version: version$1,
    setWasmURL,
    setVFS
  };
  esbuildShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    build,
    buildSync,
    context,
    default: esbuild,
    initialize,
    isInitialized,
    setVFS,
    setWasmURL,
    transform,
    transformSync,
    transformToCommonJS,
    version: version$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  let rollupInstance = null;
  let loadPromise = null;
  async function loadRollup() {
    if (rollupInstance) return rollupInstance;
    if (loadPromise) return loadPromise;
    loadPromise = (async () => {
      try {
        const rollup2 = await import("https://esm.sh/@rollup/browser@4.9.0").then(async (m) => {
          await m.__tla;
          return m;
        });
        rollupInstance = rollup2;
        console.log("[rollup] Browser version loaded");
        return rollup2;
      } catch (error) {
        console.error("[rollup] Failed to load browser version:", error);
        loadPromise = null;
        throw error;
      }
    })();
    return loadPromise;
  }
  const VERSION = "4.9.0";
  async function rollup(options2) {
    const r = await loadRollup();
    return r.rollup(options2);
  }
  async function watch(options2) {
    const r = await loadRollup();
    return r.watch(options2);
  }
  function getPackageBase() {
    return "";
  }
  const rollup_default = {
    VERSION,
    rollup,
    watch,
    loadRollup
  };
  rollupShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    VERSION,
    default: rollup_default,
    getPackageBase,
    loadRollup,
    rollup,
    watch
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function getHeapStatistics() {
    return {
      total_heap_size: 0,
      total_heap_size_executable: 0,
      total_physical_size: 0,
      total_available_size: 0,
      used_heap_size: 0,
      heap_size_limit: 0,
      malloced_memory: 0,
      peak_malloced_memory: 0,
      does_zap_garbage: 0,
      number_of_native_contexts: 0,
      number_of_detached_contexts: 0
    };
  }
  function getHeapSpaceStatistics() {
    return [];
  }
  function getHeapCodeStatistics() {
    return {
      code_and_metadata_size: 0,
      bytecode_and_metadata_size: 0,
      external_script_source_size: 0
    };
  }
  function getHeapSnapshot() {
    return null;
  }
  function writeHeapSnapshot() {
    return "";
  }
  function setFlagsFromString(_flags) {
  }
  function takeCoverage() {
  }
  function stopCoverage() {
  }
  function serialize(value2) {
    const json = JSON.stringify(value2);
    return Buffer.from(json);
  }
  function deserialize(buffer2) {
    return JSON.parse(buffer2.toString());
  }
  class Serializer {
    writeHeader() {
    }
    writeValue(_value) {
    }
    releaseBuffer() {
      return Buffer.from("");
    }
  }
  class Deserializer {
    constructor(_buffer) {
    }
    readHeader() {
      return true;
    }
    readValue() {
      return null;
    }
  }
  class DefaultSerializer extends Serializer {
  }
  class DefaultDeserializer extends Deserializer {
  }
  function promiseHooks() {
    return {
      onInit: () => {
      },
      onSettled: () => {
      },
      onBefore: () => {
      },
      onAfter: () => {
      },
      createHook: () => ({
        enable: () => {
        },
        disable: () => {
        }
      })
    };
  }
  const v8 = {
    getHeapStatistics,
    getHeapSpaceStatistics,
    getHeapCodeStatistics,
    getHeapSnapshot,
    writeHeapSnapshot,
    setFlagsFromString,
    takeCoverage,
    stopCoverage,
    serialize,
    deserialize,
    Serializer,
    Deserializer,
    DefaultSerializer,
    DefaultDeserializer,
    promiseHooks
  };
  const v8Shim = Object.freeze(Object.defineProperty({
    __proto__: null,
    DefaultDeserializer,
    DefaultSerializer,
    Deserializer,
    Serializer,
    default: v8,
    deserialize,
    getHeapCodeStatistics,
    getHeapSnapshot,
    getHeapSpaceStatistics,
    getHeapStatistics,
    promiseHooks,
    serialize,
    setFlagsFromString,
    stopCoverage,
    takeCoverage,
    writeHeapSnapshot
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Interface extends EventEmitter {
    constructor(_options2) {
      super();
      __publicField(this, "promptText");
      __publicField(this, "line", "");
      __publicField(this, "cursor", 0);
      this.promptText = (_options2 == null ? void 0 : _options2.prompt) ?? "";
    }
    prompt(_preserveCursor) {
    }
    setPrompt(prompt) {
      this.promptText = prompt;
    }
    getPrompt() {
      return this.promptText;
    }
    question(_query, callback) {
      setTimeout(() => callback(""), 0);
    }
    pause() {
      return this;
    }
    resume() {
      return this;
    }
    close() {
      this.emit("close");
    }
    write(_data, _key) {
    }
    getCursorPos() {
      return {
        rows: 0,
        cols: 0
      };
    }
  }
  function createInterface(options2) {
    return new Interface(options2);
  }
  function clearLine(_stream, _dir, _callback) {
    _callback == null ? void 0 : _callback();
    return true;
  }
  function clearScreenDown(_stream, _callback) {
    _callback == null ? void 0 : _callback();
    return true;
  }
  function cursorTo(_stream, _x, _y, _callback) {
    _callback == null ? void 0 : _callback();
    return true;
  }
  function moveCursor(_stream, _dx, _dy, _callback) {
    _callback == null ? void 0 : _callback();
    return true;
  }
  function emitKeypressEvents(_stream, _interface) {
  }
  const promises = {
    createInterface: (options2) => {
      const rl = createInterface(options2);
      return {
        question: (query) => new Promise((resolve2) => {
          rl.question(query, resolve2);
        }),
        close: () => rl.close(),
        [Symbol.asyncIterator]: async function* () {
        }
      };
    }
  };
  const readline = {
    Interface,
    createInterface,
    clearLine,
    clearScreenDown,
    cursorTo,
    moveCursor,
    emitKeypressEvents,
    promises
  };
  const readlineShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Interface,
    clearLine,
    clearScreenDown,
    createInterface,
    cursorTo,
    default: readline,
    emitKeypressEvents,
    moveCursor,
    promises
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class TLSSocket extends EventEmitter {
    constructor(_socket, _options2) {
      super();
      __publicField(this, "authorized", false);
      __publicField(this, "encrypted", true);
    }
    getPeerCertificate(_detailed) {
      return {};
    }
    getCipher() {
      return null;
    }
    getProtocol() {
      return null;
    }
    setServername(_name) {
    }
    renegotiate(_options2, _callback) {
      return false;
    }
  }
  class Server extends EventEmitter {
    constructor(_options2, _connectionListener) {
      super();
    }
    listen(..._args) {
      return this;
    }
    close(_callback) {
      return this;
    }
    address() {
      return null;
    }
    getTicketKeys() {
      return Buffer.from("");
    }
    setTicketKeys(_keys) {
    }
    setSecureContext(_options2) {
    }
  }
  function createServer$1(_options2, _connectionListener) {
    return new Server(_options2, _connectionListener);
  }
  function connect$1(_options2, _callback) {
    const socket = new TLSSocket();
    if (_callback) {
      setTimeout(_callback, 0);
    }
    return socket;
  }
  const createSecureContext = (_options2) => ({});
  const getCiphers = () => [
    "TLS_AES_256_GCM_SHA384",
    "TLS_AES_128_GCM_SHA256"
  ];
  const DEFAULT_ECDH_CURVE = "auto";
  const DEFAULT_MAX_VERSION = "TLSv1.3";
  const DEFAULT_MIN_VERSION = "TLSv1.2";
  const rootCertificates = [];
  const tls = {
    TLSSocket,
    Server,
    createServer: createServer$1,
    connect: connect$1,
    createSecureContext,
    getCiphers,
    DEFAULT_ECDH_CURVE,
    DEFAULT_MAX_VERSION,
    DEFAULT_MIN_VERSION,
    rootCertificates
  };
  const tlsShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    DEFAULT_ECDH_CURVE,
    DEFAULT_MAX_VERSION,
    DEFAULT_MIN_VERSION,
    Server,
    TLSSocket,
    connect: connect$1,
    createSecureContext,
    createServer: createServer$1,
    default: tls,
    getCiphers,
    rootCertificates
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Http2Session extends EventEmitter {
    close(_callback) {
      if (_callback) setTimeout(_callback, 0);
    }
    destroy(_error, _code) {
    }
    get destroyed() {
      return false;
    }
    get encrypted() {
      return false;
    }
    get closed() {
      return false;
    }
    ping(_callback) {
      return false;
    }
    ref() {
    }
    unref() {
    }
    setTimeout(_msecs, _callback) {
    }
  }
  class ClientHttp2Session extends Http2Session {
  }
  class ServerHttp2Session extends Http2Session {
  }
  class Http2Stream extends EventEmitter {
    close(_code, _callback) {
    }
    get id() {
      return 0;
    }
    get pending() {
      return false;
    }
    get destroyed() {
      return false;
    }
    get closed() {
      return false;
    }
    priority(_options2) {
    }
    setTimeout(_msecs, _callback) {
    }
    end(_data, _encoding, _callback) {
    }
  }
  class Http2ServerRequest extends EventEmitter {
  }
  class Http2ServerResponse extends EventEmitter {
    writeHead(_statusCode, _headers) {
      return this;
    }
    end(_data) {
    }
  }
  function createServer(_options2, _onRequestHandler) {
    return new EventEmitter();
  }
  function createSecureServer(_options2, _onRequestHandler) {
    return new EventEmitter();
  }
  function connect(_authority, _options2, _listener) {
    return new ClientHttp2Session();
  }
  const constants = {
    NGHTTP2_SESSION_SERVER: 0,
    NGHTTP2_SESSION_CLIENT: 1,
    HTTP2_HEADER_STATUS: ":status",
    HTTP2_HEADER_METHOD: ":method",
    HTTP2_HEADER_AUTHORITY: ":authority",
    HTTP2_HEADER_SCHEME: ":scheme",
    HTTP2_HEADER_PATH: ":path",
    HTTP_STATUS_OK: 200,
    HTTP_STATUS_NOT_FOUND: 404
  };
  function getDefaultSettings() {
    return {};
  }
  function getPackedSettings(_settings) {
    return Buffer.from("");
  }
  function getUnpackedSettings(_buf) {
    return {};
  }
  const sensitiveHeaders = Symbol("sensitiveHeaders");
  const http2 = {
    Http2Session,
    ClientHttp2Session,
    ServerHttp2Session,
    Http2Stream,
    Http2ServerRequest,
    Http2ServerResponse,
    createServer,
    createSecureServer,
    connect,
    constants,
    getDefaultSettings,
    getPackedSettings,
    getUnpackedSettings,
    sensitiveHeaders
  };
  const http2Shim = Object.freeze(Object.defineProperty({
    __proto__: null,
    ClientHttp2Session,
    Http2ServerRequest,
    Http2ServerResponse,
    Http2Session,
    Http2Stream,
    ServerHttp2Session,
    connect,
    constants,
    createSecureServer,
    createServer,
    default: http2,
    getDefaultSettings,
    getPackedSettings,
    getUnpackedSettings,
    sensitiveHeaders
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const isMaster = true;
  const isPrimary = true;
  const isWorker = false;
  let Worker$1 = class Worker extends EventEmitter {
    constructor() {
      super(...arguments);
      __publicField(this, "id", 0);
      __publicField(this, "process", null);
    }
    send(_message, _callback) {
      return false;
    }
    kill(_signal) {
    }
    disconnect() {
    }
    isDead() {
      return false;
    }
    isConnected() {
      return false;
    }
  };
  const worker = null;
  const workers = {};
  function fork$1(_env) {
    return new Worker$1();
  }
  function disconnect(_callback) {
    if (_callback) setTimeout(_callback, 0);
  }
  const settings = {};
  const SCHED_NONE = 1;
  const SCHED_RR = 2;
  let schedulingPolicy = SCHED_RR;
  function setupMaster(_settings) {
  }
  function setupPrimary(_settings) {
  }
  const clusterEmitter = new EventEmitter();
  const on = clusterEmitter.on.bind(clusterEmitter);
  const once = clusterEmitter.once.bind(clusterEmitter);
  const emit = clusterEmitter.emit.bind(clusterEmitter);
  const removeListener = clusterEmitter.removeListener.bind(clusterEmitter);
  const cluster = {
    isMaster,
    isPrimary,
    isWorker,
    Worker: Worker$1,
    worker,
    workers,
    fork: fork$1,
    disconnect,
    settings,
    SCHED_NONE,
    SCHED_RR,
    schedulingPolicy,
    setupMaster,
    setupPrimary,
    on,
    once,
    emit,
    removeListener
  };
  const clusterShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    SCHED_NONE,
    SCHED_RR,
    Worker: Worker$1,
    default: cluster,
    disconnect,
    emit,
    fork: fork$1,
    isMaster,
    isPrimary,
    isWorker,
    on,
    once,
    removeListener,
    schedulingPolicy,
    settings,
    setupMaster,
    setupPrimary,
    worker,
    workers
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Socket extends EventEmitter {
    bind(_port, _address, _callback) {
      if (_callback) setTimeout(_callback, 0);
      return this;
    }
    close(_callback) {
      if (_callback) setTimeout(_callback, 0);
    }
    send(_msg, _offset, _length, _port, _address, _callback) {
      if (_callback) setTimeout(() => _callback(null, 0), 0);
    }
    address() {
      return {
        address: "0.0.0.0",
        family: "IPv4",
        port: 0
      };
    }
    setBroadcast(_flag) {
    }
    setTTL(_ttl) {
      return _ttl;
    }
    setMulticastTTL(_ttl) {
      return _ttl;
    }
    setMulticastLoopback(_flag) {
      return _flag;
    }
    setMulticastInterface(_multicastInterface) {
    }
    addMembership(_multicastAddress, _multicastInterface) {
    }
    dropMembership(_multicastAddress, _multicastInterface) {
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    setRecvBufferSize(_size) {
    }
    setSendBufferSize(_size) {
    }
    getRecvBufferSize() {
      return 0;
    }
    getSendBufferSize() {
      return 0;
    }
  }
  function createSocket(_type, _callback) {
    return new Socket();
  }
  const dgram = {
    Socket,
    createSocket
  };
  const dgramShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Socket,
    createSocket,
    default: dgram
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Script {
    constructor(code2, _options2) {
      __publicField(this, "code");
      this.code = code2;
    }
    runInThisContext(_options) {
      return eval(this.code);
    }
    runInNewContext(contextObject, _options2) {
      const keys = contextObject ? Object.keys(contextObject) : [];
      const values = contextObject ? Object.values(contextObject) : [];
      const fn2 = new Function(...keys, `return eval(${JSON.stringify(this.code)})`);
      return fn2(...values);
    }
    runInContext(_context, _options2) {
      return this.runInNewContext(_context, _options2);
    }
    createCachedData() {
      return Buffer.from("");
    }
  }
  function createContext(contextObject, _options2) {
    return contextObject || {};
  }
  function isContext(_sandbox) {
    return true;
  }
  function runInThisContext(code, _options) {
    return eval(code);
  }
  function runInNewContext(code2, contextObject, _options2) {
    const script = new Script(code2);
    return script.runInNewContext(contextObject);
  }
  function runInContext(code2, context2, _options2) {
    return runInNewContext(code2, context2);
  }
  function compileFunction(code2, params, _options2) {
    return new Function(...params || [], code2);
  }
  class Module {
    constructor(_code, _options2) {
    }
    link(_linker) {
      return Promise.resolve();
    }
    evaluate(_options2) {
      return Promise.resolve();
    }
    get status() {
      return "unlinked";
    }
    get identifier() {
      return "";
    }
    get context() {
      return {};
    }
    get namespace() {
      return {};
    }
  }
  class SourceTextModule extends Module {
  }
  class SyntheticModule extends Module {
    setExport(_name, _value) {
    }
  }
  const vm = {
    Script,
    createContext,
    isContext,
    runInThisContext,
    runInNewContext,
    runInContext,
    compileFunction,
    Module,
    SourceTextModule,
    SyntheticModule
  };
  const vmShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Module,
    Script,
    SourceTextModule,
    SyntheticModule,
    compileFunction,
    createContext,
    default: vm,
    isContext,
    runInContext,
    runInNewContext,
    runInThisContext
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Session extends EventEmitter {
    connect() {
    }
    connectToMainThread() {
    }
    disconnect() {
    }
    post(_method, _params, _callback) {
      if (_callback) setTimeout(() => _callback(null, {}), 0);
    }
  }
  function open(_port, _host, _wait) {
  }
  function close$1() {
  }
  function url() {
    return void 0;
  }
  function waitForDebugger() {
  }
  const console$1 = globalThis.console;
  const inspector = {
    Session,
    open,
    close: close$1,
    url,
    waitForDebugger,
    console: console$1
  };
  const inspectorShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Session,
    close: close$1,
    console: console$1,
    default: inspector,
    open,
    url,
    waitForDebugger
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class AsyncResource {
    constructor(_type, _options2) {
    }
    runInAsyncScope(fn2, thisArg, ...args) {
      return fn2.apply(thisArg, args);
    }
    emitDestroy() {
      return this;
    }
    asyncId() {
      return 0;
    }
    triggerAsyncId() {
      return 0;
    }
    static bind(fn2, _type) {
      return fn2;
    }
  }
  class AsyncLocalStorage {
    constructor() {
      __publicField(this, "store");
    }
    disable() {
    }
    getStore() {
      return this.store;
    }
    run(store, callback) {
      const prev = this.store;
      this.store = store;
      try {
        return callback();
      } finally {
        this.store = prev;
      }
    }
    exit(callback) {
      const prev = this.store;
      this.store = void 0;
      try {
        return callback();
      } finally {
        this.store = prev;
      }
    }
    enterWith(store) {
      this.store = store;
    }
  }
  function createHook(_callbacks) {
    return {
      enable() {
        return this;
      },
      disable() {
        return this;
      }
    };
  }
  function executionAsyncId() {
    return 0;
  }
  function executionAsyncResource() {
    return {};
  }
  function triggerAsyncId() {
    return 0;
  }
  const async_hooks = {
    AsyncResource,
    AsyncLocalStorage,
    createHook,
    executionAsyncId,
    executionAsyncResource,
    triggerAsyncId
  };
  const asyncHooksShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    AsyncLocalStorage,
    AsyncResource,
    createHook,
    default: async_hooks,
    executionAsyncId,
    executionAsyncResource,
    triggerAsyncId
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Domain extends EventEmitter {
    constructor() {
      super(...arguments);
      __publicField(this, "members", []);
    }
    add(emitter) {
      this.members.push(emitter);
    }
    remove(emitter) {
      const index2 = this.members.indexOf(emitter);
      if (index2 !== -1) {
        this.members.splice(index2, 1);
      }
    }
    bind(callback) {
      return callback;
    }
    intercept(callback) {
      return callback;
    }
    run(fn2) {
      return fn2();
    }
    dispose() {
      this.members = [];
    }
    enter() {
    }
    exit() {
    }
  }
  function create() {
    return new Domain();
  }
  let active = null;
  const domain = {
    Domain,
    create,
    active
  };
  const domainShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Domain,
    active,
    create,
    default: domain
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Channel {
    constructor(name2) {
      __publicField(this, "name");
      __publicField(this, "_subscribers", /* @__PURE__ */ new Set());
      this.name = name2;
    }
    get hasSubscribers() {
      return this._subscribers.size > 0;
    }
    publish(message) {
      for (const subscriber of this._subscribers) {
        try {
          subscriber(message, this.name);
        } catch (err) {
          console.error("Error in diagnostics channel subscriber:", err);
        }
      }
    }
    subscribe(onMessage) {
      this._subscribers.add(onMessage);
    }
    unsubscribe(onMessage) {
      return this._subscribers.delete(onMessage);
    }
    bindStore(store, transform2) {
    }
    unbindStore(store) {
      return false;
    }
  }
  const channels = /* @__PURE__ */ new Map();
  function channel(name2) {
    let ch = channels.get(name2);
    if (!ch) {
      ch = new Channel(name2);
      channels.set(name2, ch);
    }
    return ch;
  }
  function hasSubscribers(name2) {
    const ch = channels.get(name2);
    return ch ? ch.hasSubscribers : false;
  }
  function subscribe(name2, onMessage) {
    channel(name2).subscribe(onMessage);
  }
  function unsubscribe(name2, onMessage) {
    const ch = channels.get(name2);
    return ch ? ch.unsubscribe(onMessage) : false;
  }
  class TracingChannel {
    constructor(nameOrChannels) {
      __publicField(this, "channels");
      if (typeof nameOrChannels === "string") {
        this.channels = {
          start: channel(`tracing:${nameOrChannels}:start`),
          end: channel(`tracing:${nameOrChannels}:end`),
          asyncStart: channel(`tracing:${nameOrChannels}:asyncStart`),
          asyncEnd: channel(`tracing:${nameOrChannels}:asyncEnd`),
          error: channel(`tracing:${nameOrChannels}:error`)
        };
      } else {
        this.channels = nameOrChannels;
      }
    }
    get hasSubscribers() {
      return Object.values(this.channels).some((ch) => ch.hasSubscribers);
    }
    subscribe(handlers) {
      if (handlers.start) this.channels.start.subscribe(handlers.start);
      if (handlers.end) this.channels.end.subscribe(handlers.end);
      if (handlers.asyncStart) this.channels.asyncStart.subscribe(handlers.asyncStart);
      if (handlers.asyncEnd) this.channels.asyncEnd.subscribe(handlers.asyncEnd);
      if (handlers.error) this.channels.error.subscribe(handlers.error);
    }
    unsubscribe(handlers) {
      if (handlers.start) this.channels.start.unsubscribe(handlers.start);
      if (handlers.end) this.channels.end.unsubscribe(handlers.end);
      if (handlers.asyncStart) this.channels.asyncStart.unsubscribe(handlers.asyncStart);
      if (handlers.asyncEnd) this.channels.asyncEnd.unsubscribe(handlers.asyncEnd);
      if (handlers.error) this.channels.error.unsubscribe(handlers.error);
    }
    traceSync(fn2, context2, thisArg) {
      this.channels.start.publish(context2);
      try {
        const result = fn2.call(thisArg);
        this.channels.end.publish(context2);
        return result;
      } catch (error) {
        this.channels.error.publish({
          error,
          ...context2
        });
        throw error;
      }
    }
    async tracePromise(fn2, context2, thisArg) {
      this.channels.start.publish(context2);
      try {
        const result = await fn2.call(thisArg);
        this.channels.asyncEnd.publish(context2);
        return result;
      } catch (error) {
        this.channels.error.publish({
          error,
          ...context2
        });
        throw error;
      }
    }
    traceCallback(fn2, position, context2, thisArg) {
      return fn2;
    }
  }
  function tracingChannel(name2) {
    return new TracingChannel(name2);
  }
  const diagnostics_channel = {
    channel,
    hasSubscribers,
    subscribe,
    unsubscribe,
    tracingChannel,
    Channel,
    TracingChannel
  };
  const diagnosticsChannelShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Channel,
    TracingChannel,
    channel,
    default: diagnostics_channel,
    hasSubscribers,
    subscribe,
    tracingChannel,
    unsubscribe
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const noop$3 = () => {
  };
  const noopPromise = () => Promise.resolve();
  let Scope$2 = class Scope2 {
    constructor() {
      __publicField(this, "setTag", noop$3);
      __publicField(this, "setTags", noop$3);
      __publicField(this, "setUser", noop$3);
      __publicField(this, "setContext", noop$3);
      __publicField(this, "setExtra", noop$3);
      __publicField(this, "setExtras", noop$3);
      __publicField(this, "setLevel", noop$3);
      __publicField(this, "setTransactionName", noop$3);
      __publicField(this, "setFingerprint", noop$3);
      __publicField(this, "addBreadcrumb", noop$3);
      __publicField(this, "clearBreadcrumbs", noop$3);
      __publicField(this, "addEventProcessor", noop$3);
      __publicField(this, "addAttachment", noop$3);
      __publicField(this, "clear", noop$3);
      __publicField(this, "update", () => this);
      __publicField(this, "clone", () => new Scope2());
    }
  };
  class Hub {
    constructor() {
      __publicField(this, "getClient", () => void 0);
      __publicField(this, "getScope", () => new Scope$2());
      __publicField(this, "pushScope", () => new Scope$2());
      __publicField(this, "popScope", noop$3);
      __publicField(this, "withScope", (callback) => callback(new Scope$2()));
      __publicField(this, "captureException", () => "");
      __publicField(this, "captureMessage", () => "");
      __publicField(this, "captureEvent", () => "");
      __publicField(this, "addBreadcrumb", noop$3);
      __publicField(this, "setUser", noop$3);
      __publicField(this, "setTags", noop$3);
      __publicField(this, "setTag", noop$3);
      __publicField(this, "setExtra", noop$3);
      __publicField(this, "setExtras", noop$3);
      __publicField(this, "setContext", noop$3);
    }
  }
  class Transaction {
    constructor() {
      __publicField(this, "name", "");
      __publicField(this, "spanId", "");
      __publicField(this, "traceId", "");
      __publicField(this, "op", "");
      __publicField(this, "finish", noop$3);
      __publicField(this, "setTag", noop$3);
      __publicField(this, "setData", noop$3);
      __publicField(this, "setStatus", noop$3);
      __publicField(this, "startChild", () => new Transaction());
      __publicField(this, "toTraceparent", () => "");
    }
  }
  const currentHub = new Hub();
  const init = noop$3;
  const close = noopPromise;
  const flush = noopPromise;
  const captureException = () => "";
  const captureMessage = () => "";
  const captureEvent = () => "";
  const addBreadcrumb = noop$3;
  const setUser = noop$3;
  const setTag = noop$3;
  const setTags = noop$3;
  const setExtra = noop$3;
  const setExtras = noop$3;
  const setContext = noop$3;
  const configureScope = (callback) => callback(new Scope$2());
  const withScope = (callback) => callback(new Scope$2());
  const getCurrentHub = () => currentHub;
  const getHubFromCarrier = () => currentHub;
  const startTransaction = () => new Transaction();
  const lastEventId = () => void 0;
  const Integrations = {
    Http: class {
    },
    OnUncaughtException: class {
    },
    OnUnhandledRejection: class {
    },
    Console: class {
    },
    Context: class {
    },
    ContextLines: class {
    },
    Modules: class {
    },
    RequestData: class {
    },
    LinkedErrors: class {
    }
  };
  const Handlers = {
    requestHandler: () => (_req, _res, next) => next(),
    errorHandler: () => (_err, _req, _res, next) => next(),
    tracingHandler: () => (_req, _res, next) => next()
  };
  const sentry = {
    init,
    close,
    flush,
    captureException,
    captureMessage,
    captureEvent,
    addBreadcrumb,
    setUser,
    setTag,
    setTags,
    setExtra,
    setExtras,
    setContext,
    configureScope,
    withScope,
    getCurrentHub,
    startTransaction,
    lastEventId,
    Scope: Scope$2,
    Hub,
    Integrations,
    Handlers
  };
  const sentryShim = Object.freeze(Object.defineProperty({
    __proto__: null,
    Handlers,
    Hub,
    Integrations,
    Scope: Scope$2,
    addBreadcrumb,
    captureEvent,
    captureException,
    captureMessage,
    close,
    configureScope,
    default: sentry,
    flush,
    getCurrentHub,
    getHubFromCarrier,
    init,
    lastEventId,
    setContext,
    setExtra,
    setExtras,
    setTag,
    setTags,
    setUser,
    startTransaction,
    withScope
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class AssertionError extends Error {
    constructor(options2) {
      const message = options2.message || `${JSON.stringify(options2.actual)} ${options2.operator || "=="} ${JSON.stringify(options2.expected)}`;
      super(message);
      __publicField(this, "actual");
      __publicField(this, "expected");
      __publicField(this, "operator");
      __publicField(this, "generatedMessage");
      __publicField(this, "code", "ERR_ASSERTION");
      this.name = "AssertionError";
      this.actual = options2.actual;
      this.expected = options2.expected;
      this.operator = options2.operator || "";
      this.generatedMessage = !options2.message;
      if (Error.captureStackTrace && options2.stackStartFn) {
        Error.captureStackTrace(this, options2.stackStartFn);
      }
    }
  }
  function isDeepStrictEqual(actual, expected) {
    if (actual === expected) {
      return true;
    }
    if (actual === null || expected === null || actual === void 0 || expected === void 0) {
      return actual === expected;
    }
    if (typeof actual !== typeof expected) {
      return false;
    }
    if (typeof actual === "number" && Number.isNaN(actual) && Number.isNaN(expected)) {
      return true;
    }
    if (actual instanceof Date && expected instanceof Date) {
      return actual.getTime() === expected.getTime();
    }
    if (actual instanceof RegExp && expected instanceof RegExp) {
      return actual.source === expected.source && actual.flags === expected.flags;
    }
    if (Array.isArray(actual) && Array.isArray(expected)) {
      if (actual.length !== expected.length) {
        return false;
      }
      for (let i2 = 0; i2 < actual.length; i2++) {
        if (!isDeepStrictEqual(actual[i2], expected[i2])) {
          return false;
        }
      }
      return true;
    }
    if (actual instanceof Uint8Array && expected instanceof Uint8Array) {
      if (actual.length !== expected.length) {
        return false;
      }
      for (let i2 = 0; i2 < actual.length; i2++) {
        if (actual[i2] !== expected[i2]) {
          return false;
        }
      }
      return true;
    }
    if (actual instanceof Map && expected instanceof Map) {
      if (actual.size !== expected.size) {
        return false;
      }
      const actualEntries = Array.from(actual.entries());
      for (let i2 = 0; i2 < actualEntries.length; i2++) {
        const [key, value2] = actualEntries[i2];
        if (!expected.has(key) || !isDeepStrictEqual(value2, expected.get(key))) {
          return false;
        }
      }
      return true;
    }
    if (actual instanceof Set && expected instanceof Set) {
      if (actual.size !== expected.size) {
        return false;
      }
      const actualValues = Array.from(actual.values());
      const expectedValues = Array.from(expected.values());
      for (let i2 = 0; i2 < actualValues.length; i2++) {
        const value2 = actualValues[i2];
        if (!expected.has(value2)) {
          let found = false;
          for (let j = 0; j < expectedValues.length; j++) {
            if (isDeepStrictEqual(value2, expectedValues[j])) {
              found = true;
              break;
            }
          }
          if (!found) return false;
        }
      }
      return true;
    }
    if (typeof actual === "object" && typeof expected === "object") {
      const actualKeys = Object.keys(actual);
      const expectedKeys = Object.keys(expected);
      if (actualKeys.length !== expectedKeys.length) {
        return false;
      }
      for (const key of actualKeys) {
        if (!Object.prototype.hasOwnProperty.call(expected, key)) {
          return false;
        }
        if (!isDeepStrictEqual(actual[key], expected[key])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function assert(value2, message) {
    if (!value2) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message: message || "The expression evaluated to a falsy value",
        actual: value2,
        expected: true,
        operator: "==",
        stackStartFn: assert
      });
    }
  }
  assert.ok = function ok(value2, message) {
    if (!value2) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message: message || "The expression evaluated to a falsy value",
        actual: value2,
        expected: true,
        operator: "==",
        stackStartFn: ok
      });
    }
  };
  assert.strictEqual = function strictEqual(actual, expected, message) {
    if (actual !== expected) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message,
        actual,
        expected,
        operator: "===",
        stackStartFn: strictEqual
      });
    }
  };
  assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (actual === expected) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message,
        actual,
        expected,
        operator: "!==",
        stackStartFn: notStrictEqual
      });
    }
  };
  assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
    if (!isDeepStrictEqual(actual, expected)) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message,
        actual,
        expected,
        operator: "deepStrictEqual",
        stackStartFn: deepStrictEqual
      });
    }
  };
  assert.notDeepStrictEqual = function notDeepStrictEqual(actual, expected, message) {
    if (isDeepStrictEqual(actual, expected)) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message,
        actual,
        expected,
        operator: "notDeepStrictEqual",
        stackStartFn: notDeepStrictEqual
      });
    }
  };
  assert.throws = function throws(fn2, errorOrMessage, message) {
    let threw = false;
    let thrownError;
    try {
      fn2();
    } catch (err) {
      threw = true;
      thrownError = err;
    }
    if (!threw) {
      throw new AssertionError({
        message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected function to throw",
        actual: void 0,
        expected: errorOrMessage,
        operator: "throws",
        stackStartFn: throws
      });
    }
    if (errorOrMessage !== void 0 && typeof errorOrMessage !== "string") {
      if (errorOrMessage instanceof RegExp) {
        const errMessage = thrownError instanceof Error ? thrownError.message : String(thrownError);
        if (!errorOrMessage.test(errMessage)) {
          throw new AssertionError({
            message: message || `The error message did not match the regular expression`,
            actual: thrownError,
            expected: errorOrMessage,
            operator: "throws",
            stackStartFn: throws
          });
        }
      } else if (typeof errorOrMessage === "function") {
        if (!(thrownError instanceof errorOrMessage)) {
          throw new AssertionError({
            message: message || `The error is not an instance of the expected type`,
            actual: thrownError,
            expected: errorOrMessage,
            operator: "throws",
            stackStartFn: throws
          });
        }
      } else if (typeof errorOrMessage === "object") {
        const expected = errorOrMessage;
        const err = thrownError;
        if (expected.message !== void 0) {
          const errMsg = err.message || String(thrownError);
          if (expected.message instanceof RegExp) {
            if (!expected.message.test(errMsg)) {
              throw new AssertionError({
                message: message || `The error message did not match`,
                actual: errMsg,
                expected: expected.message,
                operator: "throws",
                stackStartFn: throws
              });
            }
          } else if (errMsg !== expected.message) {
            throw new AssertionError({
              message: message || `The error message did not match`,
              actual: errMsg,
              expected: expected.message,
              operator: "throws",
              stackStartFn: throws
            });
          }
        }
        if (expected.code !== void 0 && err.code !== expected.code) {
          throw new AssertionError({
            message: message || `The error code did not match`,
            actual: err.code,
            expected: expected.code,
            operator: "throws",
            stackStartFn: throws
          });
        }
      }
    }
  };
  assert.doesNotThrow = function doesNotThrow(fn2, errorOrMessage, message) {
    try {
      fn2();
    } catch (err) {
      if (errorOrMessage === void 0 || typeof errorOrMessage === "string") {
        throw new AssertionError({
          message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected function not to throw",
          actual: err,
          expected: void 0,
          operator: "doesNotThrow",
          stackStartFn: doesNotThrow
        });
      }
      if (errorOrMessage instanceof RegExp) {
        const errMessage = err instanceof Error ? err.message : String(err);
        if (errorOrMessage.test(errMessage)) {
          throw new AssertionError({
            message: message || "Expected function not to throw matching error",
            actual: err,
            expected: errorOrMessage,
            operator: "doesNotThrow",
            stackStartFn: doesNotThrow
          });
        }
      } else if (typeof errorOrMessage === "function") {
        if (err instanceof errorOrMessage) {
          throw new AssertionError({
            message: message || "Expected function not to throw error of this type",
            actual: err,
            expected: errorOrMessage,
            operator: "doesNotThrow",
            stackStartFn: doesNotThrow
          });
        }
      }
    }
  };
  assert.rejects = async function rejects(asyncFn, errorOrMessage, message) {
    const promise = typeof asyncFn === "function" ? asyncFn() : asyncFn;
    let rejected = false;
    let rejectionReason;
    try {
      await promise;
    } catch (err) {
      rejected = true;
      rejectionReason = err;
    }
    if (!rejected) {
      throw new AssertionError({
        message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected promise to reject",
        actual: void 0,
        expected: errorOrMessage,
        operator: "rejects",
        stackStartFn: rejects
      });
    }
    if (errorOrMessage !== void 0 && typeof errorOrMessage !== "string") {
      if (errorOrMessage instanceof RegExp) {
        const errMessage = rejectionReason instanceof Error ? rejectionReason.message : String(rejectionReason);
        if (!errorOrMessage.test(errMessage)) {
          throw new AssertionError({
            message: message || "The rejection message did not match the regular expression",
            actual: rejectionReason,
            expected: errorOrMessage,
            operator: "rejects",
            stackStartFn: rejects
          });
        }
      } else if (typeof errorOrMessage === "function") {
        if (!(rejectionReason instanceof errorOrMessage)) {
          throw new AssertionError({
            message: message || "The rejection is not an instance of the expected type",
            actual: rejectionReason,
            expected: errorOrMessage,
            operator: "rejects",
            stackStartFn: rejects
          });
        }
      } else if (typeof errorOrMessage === "object") {
        const expected = errorOrMessage;
        const err = rejectionReason;
        if (expected.message !== void 0) {
          const errMsg = err.message || String(rejectionReason);
          if (expected.message instanceof RegExp) {
            if (!expected.message.test(errMsg)) {
              throw new AssertionError({
                message: message || "The rejection message did not match",
                actual: errMsg,
                expected: expected.message,
                operator: "rejects",
                stackStartFn: rejects
              });
            }
          } else if (errMsg !== expected.message) {
            throw new AssertionError({
              message: message || "The rejection message did not match",
              actual: errMsg,
              expected: expected.message,
              operator: "rejects",
              stackStartFn: rejects
            });
          }
        }
        if (expected.code !== void 0 && err.code !== expected.code) {
          throw new AssertionError({
            message: message || "The rejection code did not match",
            actual: err.code,
            expected: expected.code,
            operator: "rejects",
            stackStartFn: rejects
          });
        }
      }
    }
  };
  assert.doesNotReject = async function doesNotReject(asyncFn, errorOrMessage, message) {
    const promise = typeof asyncFn === "function" ? asyncFn() : asyncFn;
    try {
      await promise;
    } catch (err) {
      if (errorOrMessage === void 0 || typeof errorOrMessage === "string") {
        throw new AssertionError({
          message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected promise not to reject",
          actual: err,
          expected: void 0,
          operator: "doesNotReject",
          stackStartFn: doesNotReject
        });
      }
      if (errorOrMessage instanceof RegExp) {
        const errMessage = err instanceof Error ? err.message : String(err);
        if (errorOrMessage.test(errMessage)) {
          throw new AssertionError({
            message: message || "Expected promise not to reject with matching error",
            actual: err,
            expected: errorOrMessage,
            operator: "doesNotReject",
            stackStartFn: doesNotReject
          });
        }
      } else if (typeof errorOrMessage === "function") {
        if (err instanceof errorOrMessage) {
          throw new AssertionError({
            message: message || "Expected promise not to reject with error of this type",
            actual: err,
            expected: errorOrMessage,
            operator: "doesNotReject",
            stackStartFn: doesNotReject
          });
        }
      }
    }
  };
  assert.fail = function fail(messageOrActual, expected, message, operator) {
    if (arguments.length === 0 || arguments.length === 1) {
      throw new AssertionError({
        message: typeof messageOrActual === "string" ? messageOrActual : "Failed",
        stackStartFn: fail
      });
    }
    throw new AssertionError({
      message,
      actual: messageOrActual,
      expected,
      operator: operator || "fail",
      stackStartFn: fail
    });
  };
  assert.match = function match(string, regexp, message) {
    if (!regexp.test(string)) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message: message || `The input did not match the regular expression`,
        actual: string,
        expected: regexp,
        operator: "match",
        stackStartFn: match
      });
    }
  };
  assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
    if (regexp.test(string)) {
      if (message instanceof Error) {
        throw message;
      }
      throw new AssertionError({
        message: message || `The input was expected not to match the regular expression`,
        actual: string,
        expected: regexp,
        operator: "doesNotMatch",
        stackStartFn: doesNotMatch
      });
    }
  };
  assert.ifError = function ifError(value2) {
    if (value2 !== null && value2 !== void 0) {
      if (value2 instanceof Error) {
        throw value2;
      }
      throw new AssertionError({
        message: `ifError got unwanted exception: ${value2}`,
        actual: value2,
        expected: null,
        operator: "ifError",
        stackStartFn: ifError
      });
    }
  };
  assert.AssertionError = AssertionError;
  assert.strict = assert;
  assert$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    AssertionError,
    assert,
    default: assert
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function transformDynamicImports(code2) {
    return code2.replace(new RegExp("(?<![.$\\w])import\\s*\\(", "g"), "__dynamicImport(");
  }
  function transformEsmToCjs(code2, filename2) {
    const hasImport = /\bimport\s+[\w{*'"]/m.test(code2);
    const hasExport = /\bexport\s+(?:default|const|let|var|function|class|{|\*)/m.test(code2);
    const hasImportMeta = /\bimport\.meta\b/.test(code2);
    if (!hasImport && !hasExport && !hasImportMeta) {
      return code2;
    }
    let transformed = code2;
    transformed = transformed.replace(/\bimport\.meta\.url\b/g, `"file://${filename2}"`);
    transformed = transformed.replace(/\bimport\.meta\.dirname\b/g, `"${dirname(filename2)}"`);
    transformed = transformed.replace(/\bimport\.meta\.filename\b/g, `"${filename2}"`);
    transformed = transformed.replace(/\bimport\.meta\b/g, `({ url: "file://${filename2}", dirname: "${dirname(filename2)}", filename: "${filename2}" })`);
    transformed = transformed.replace(/\bimport\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"]\s*;?/g, (_, imports, module2) => {
      const cleanImports = imports.replace(/\s+as\s+/g, ": ");
      return `const {${cleanImports}} = require("${module2}");`;
    });
    transformed = transformed.replace(/\bimport\s+(\w+)\s+from\s+['"]([^'"]+)['"]\s*;?/g, (_, name2, module2) => {
      return `const ${name2} = (function() { const m = require("${module2}"); return m && m.__esModule ? m.default : m; })();`;
    });
    transformed = transformed.replace(/\bimport\s+\*\s+as\s+(\w+)\s+from\s+['"]([^'"]+)['"]\s*;?/g, 'const $1 = require("$2");');
    transformed = transformed.replace(/\bimport\s+['"]([^'"]+)['"]\s*;?/g, 'require("$1");');
    transformed = transformed.replace(/\bexport\s+default\s+/g, "module.exports = module.exports.default = ");
    transformed = transformed.replace(/\bexport\s+\{([^}]+)\}\s*;?/g, (_, exports$1) => {
      const items = exports$1.split(",").map((item) => {
        const [local, exported] = item.trim().split(/\s+as\s+/);
        const exportName = exported || local;
        return `module.exports.${exportName.trim()} = ${local.trim()};`;
      });
      return items.join("\n");
    });
    transformed = transformed.replace(/\bexport\s+(const|let|var)\s+(\w+)\s*=/g, "$1 $2 = module.exports.$2 =");
    transformed = transformed.replace(/\bexport\s+function\s+(\w+)/g, "function $1");
    transformed = transformed.replace(/\bexport\s+class\s+(\w+)/g, "class $1");
    if (hasExport) {
      transformed = 'Object.defineProperty(exports, "__esModule", { value: true });\n' + transformed;
    }
    return transformed;
  }
  function createDynamicImport(moduleRequire2) {
    return async (specifier) => {
      try {
        const mod = moduleRequire2(specifier);
        if (mod && typeof mod === "object" && ("default" in mod || "__esModule" in mod)) {
          return mod;
        }
        return {
          default: mod,
          ...mod && typeof mod === "object" ? mod : {}
        };
      } catch (error) {
        throw error;
      }
    };
  }
  function createStringDecoderModule() {
    class StringDecoder {
      constructor(encoding) {
        __publicField(this, "encoding");
        this.encoding = encoding || "utf8";
      }
      write(buffer2) {
        return new TextDecoder(this.encoding).decode(buffer2);
      }
      end(buffer2) {
        if (buffer2) return this.write(buffer2);
        return "";
      }
    }
    return {
      StringDecoder
    };
  }
  function createTimersModule() {
    return {
      setTimeout: globalThis.setTimeout.bind(globalThis),
      setInterval: globalThis.setInterval.bind(globalThis),
      setImmediate: (fn2) => setTimeout(fn2, 0),
      clearTimeout: globalThis.clearTimeout.bind(globalThis),
      clearInterval: globalThis.clearInterval.bind(globalThis),
      clearImmediate: globalThis.clearTimeout.bind(globalThis)
    };
  }
  const prettierShim = {
    format: (source, _options2) => Promise.resolve(source),
    formatWithCursor: (source, _options2) => Promise.resolve({
      formatted: source,
      cursorOffset: 0
    }),
    check: (_source, _options2) => Promise.resolve(true),
    resolveConfig: () => Promise.resolve(null),
    resolveConfigFile: () => Promise.resolve(null),
    clearConfigCache: () => {
    },
    getFileInfo: () => Promise.resolve({
      ignored: false,
      inferredParser: null
    }),
    getSupportInfo: () => Promise.resolve({
      languages: [],
      options: []
    }),
    version: "3.0.0",
    doc: {
      builders: {},
      printer: {},
      utils: {}
    }
  };
  function makeMutable(mod) {
    const mutable = {};
    for (const key of Object.keys(mod)) {
      mutable[key] = mod[key];
    }
    return mutable;
  }
  const builtinModules = {
    path: pathShim,
    http: makeMutable(httpShim),
    https: makeMutable(httpsShim),
    net: netShim,
    events,
    stream: Stream,
    buffer: bufferModule,
    url: urlShim,
    querystring: querystringShim,
    util: utilShim,
    tty: ttyShim,
    os: osShim,
    crypto: cryptoShim,
    zlib: zlibShim,
    dns: dnsShim,
    child_process: childProcessShim,
    assert,
    string_decoder: createStringDecoderModule(),
    timers: createTimersModule(),
    _http_common: {},
    _http_incoming: {},
    _http_outgoing: {},
    chokidar: chokidarShim,
    ws: wsShim,
    fsevents: fseventsShim,
    readdirp: readdirpShim,
    module: moduleShim,
    perf_hooks: perfHooksShim,
    worker_threads: workerThreadsShim,
    esbuild: esbuildShim,
    rollup: rollupShim,
    v8: v8Shim,
    readline: readlineShim,
    tls: tlsShim,
    http2: http2Shim,
    cluster: clusterShim,
    dgram: dgramShim,
    vm: vmShim,
    inspector: inspectorShim,
    "inspector/promises": inspectorShim,
    async_hooks: asyncHooksShim,
    domain: domainShim,
    diagnostics_channel: diagnosticsChannelShim,
    prettier: prettierShim,
    console,
    "util/types": types$2,
    "@sentry/node": sentryShim,
    "@sentry/core": sentryShim
  };
  function createRequire(vfs, fsShim, process, currentDir, moduleCache, options, processedCodeCache) {
    const resolutionCache = /* @__PURE__ */ new Map();
    const packageJsonCache = /* @__PURE__ */ new Map();
    const getParsedPackageJson = (pkgPath) => {
      if (packageJsonCache.has(pkgPath)) {
        return packageJsonCache.get(pkgPath);
      }
      try {
        const content = vfs.readFileSync(pkgPath, "utf8");
        const parsed = JSON.parse(content);
        packageJsonCache.set(pkgPath, parsed);
        return parsed;
      } catch {
        packageJsonCache.set(pkgPath, null);
        return null;
      }
    };
    const resolveModule = (id, fromDir) => {
      if (id.startsWith("node:")) {
        id = id.slice(5);
      }
      if (builtinModules[id] || id === "fs" || id === "process" || id === "url" || id === "querystring" || id === "util") {
        return id;
      }
      const cacheKey = `${fromDir}|${id}`;
      const cached = resolutionCache.get(cacheKey);
      if (cached !== void 0) {
        if (cached === null) {
          throw new Error(`Cannot find module '${id}'`);
        }
        return cached;
      }
      if (id.startsWith("./") || id.startsWith("../") || id.startsWith("/")) {
        const resolved = id.startsWith("/") ? id : resolve$2(fromDir, id);
        if (vfs.existsSync(resolved)) {
          const stats = vfs.statSync(resolved);
          if (stats.isFile()) {
            resolutionCache.set(cacheKey, resolved);
            return resolved;
          }
          const indexPath = join(resolved, "index.js");
          if (vfs.existsSync(indexPath)) {
            resolutionCache.set(cacheKey, indexPath);
            return indexPath;
          }
        }
        const extensions = [
          ".js",
          ".json"
        ];
        for (const ext of extensions) {
          const withExt = resolved + ext;
          if (vfs.existsSync(withExt)) {
            resolutionCache.set(cacheKey, withExt);
            return withExt;
          }
        }
        resolutionCache.set(cacheKey, null);
        throw new Error(`Cannot find module '${id}' from '${fromDir}'`);
      }
      const tryResolveFile = (basePath) => {
        if (vfs.existsSync(basePath)) {
          const stats = vfs.statSync(basePath);
          if (stats.isFile()) {
            return basePath;
          }
          const indexPath = join(basePath, "index.js");
          if (vfs.existsSync(indexPath)) {
            return indexPath;
          }
        }
        const extensions = [
          ".js",
          ".json",
          ".node"
        ];
        for (const ext of extensions) {
          const withExt = basePath + ext;
          if (vfs.existsSync(withExt)) {
            return withExt;
          }
        }
        return null;
      };
      const tryResolveFromNodeModules = (nodeModulesDir, moduleId) => {
        const parts = moduleId.split("/");
        const pkgName = parts[0].startsWith("@") && parts.length > 1 ? `${parts[0]}/${parts[1]}` : parts[0];
        const pkgRoot = join(nodeModulesDir, pkgName);
        const pkgPath = join(pkgRoot, "package.json");
        const pkg = getParsedPackageJson(pkgPath);
        if (pkg) {
          if (pkg.exports) {
            try {
              const resolved2 = resolve$3(pkg, moduleId, {
                require: true
              });
              if (resolved2 && resolved2.length > 0) {
                const exportPath = resolved2[0];
                const fullExportPath = join(pkgRoot, exportPath);
                const resolvedFile = tryResolveFile(fullExportPath);
                if (resolvedFile) return resolvedFile;
              }
            } catch {
            }
          }
          if (pkgName === moduleId) {
            let main;
            if (typeof pkg.browser === "string") {
              main = pkg.browser;
            }
            if (!main) {
              main = pkg.main || "index.js";
            }
            const mainPath = join(pkgRoot, main);
            const resolvedMain = tryResolveFile(mainPath);
            if (resolvedMain) return resolvedMain;
          }
        }
        const fullPath = join(nodeModulesDir, moduleId);
        const resolved = tryResolveFile(fullPath);
        if (resolved) return resolved;
        return null;
      };
      let searchDir = fromDir;
      while (searchDir !== "/") {
        const nodeModulesDir = join(searchDir, "node_modules");
        const resolved = tryResolveFromNodeModules(nodeModulesDir, id);
        if (resolved) {
          resolutionCache.set(cacheKey, resolved);
          return resolved;
        }
        searchDir = dirname(searchDir);
      }
      const rootResolved = tryResolveFromNodeModules("/node_modules", id);
      if (rootResolved) {
        resolutionCache.set(cacheKey, rootResolved);
        return rootResolved;
      }
      resolutionCache.set(cacheKey, null);
      throw new Error(`Cannot find module '${id}'`);
    };
    const loadModule = (resolvedPath) => {
      if (moduleCache[resolvedPath]) {
        return moduleCache[resolvedPath];
      }
      const module = {
        id: resolvedPath,
        filename: resolvedPath,
        exports: {},
        loaded: false,
        children: [],
        paths: []
      };
      moduleCache[resolvedPath] = module;
      const cacheKeys = Object.keys(moduleCache);
      if (cacheKeys.length > 2e3) {
        delete moduleCache[cacheKeys[0]];
      }
      if (resolvedPath.endsWith(".json")) {
        const content = vfs.readFileSync(resolvedPath, "utf8");
        module.exports = JSON.parse(content);
        module.loaded = true;
        return module;
      }
      const rawCode = vfs.readFileSync(resolvedPath, "utf8");
      const dirname$1 = dirname(resolvedPath);
      const codeCacheKey = `${resolvedPath}|${simpleHash(rawCode)}`;
      let code = processedCodeCache == null ? void 0 : processedCodeCache.get(codeCacheKey);
      if (!code) {
        code = rawCode;
        const isCjsFile = resolvedPath.endsWith(".cjs");
        const isAlreadyBundledCjs = code.startsWith('"use strict";\nvar __') || code.startsWith("'use strict';\nvar __");
        const hasEsmImport = /\bimport\s+[\w{*'"]/m.test(code);
        const hasEsmExport = /\bexport\s+(?:default|const|let|var|function|class|{|\*)/m.test(code);
        if (!isCjsFile && !isAlreadyBundledCjs) {
          if (resolvedPath.endsWith(".mjs") || resolvedPath.includes("/esm/") || hasEsmImport || hasEsmExport) {
            code = transformEsmToCjs(code, resolvedPath);
          }
        }
        code = transformDynamicImports(code);
        processedCodeCache == null ? void 0 : processedCodeCache.set(codeCacheKey, code);
      }
      const moduleRequire = createRequire(vfs, fsShim, process, dirname$1, moduleCache, options, processedCodeCache);
      moduleRequire.cache = moduleCache;
      const consoleWrapper = createConsoleWrapper(options.onConsole);
      try {
        const importMetaUrl = "file://" + resolvedPath;
        const wrappedCode = `(function($exports, $require, $module, $filename, $dirname, $process, $console, $importMeta, $dynamicImport) {
var exports = $exports;
var require = $require;
var module = $module;
var __filename = $filename;
var __dirname = $dirname;
var process = $process;
var console = $console;
var import_meta = $importMeta;
var __dynamicImport = $dynamicImport;
// Set up global.process and globalThis.process for code that accesses them directly
var global = globalThis;
globalThis.process = $process;
global.process = $process;
return (function() {
${code}
}).call(this);
})`;
        let fn;
        try {
          fn = eval(wrappedCode);
        } catch (evalError) {
          console.error("[runtime] Eval failed for:", resolvedPath);
          console.error("[runtime] First 500 chars of code:", code.substring(0, 500));
          throw evalError;
        }
        const dynamicImport = createDynamicImport(moduleRequire);
        fn(module.exports, moduleRequire, module, resolvedPath, dirname$1, process, consoleWrapper, {
          url: importMetaUrl,
          dirname: dirname$1,
          filename: resolvedPath
        }, dynamicImport);
        module.loaded = true;
      } catch (error) {
        delete moduleCache[resolvedPath];
        throw error;
      }
      return module;
    };
    const require = (id) => {
      if (id.startsWith("node:")) {
        id = id.slice(5);
      }
      if (id === "fs") {
        return fsShim;
      }
      if (id === "fs/promises") {
        return fsShim.promises;
      }
      if (id === "process") {
        return process;
      }
      if (id === "module") {
        return {
          ...moduleShim,
          createRequire: (filenameOrUrl) => {
            let fromPath = filenameOrUrl;
            if (filenameOrUrl.startsWith("file://")) {
              fromPath = filenameOrUrl.slice(7);
              if (fromPath.startsWith("/") && fromPath[2] === ":") {
                fromPath = fromPath.slice(1);
              }
            }
            const fromDir = dirname(fromPath);
            const newRequire = createRequire(vfs, fsShim, process, fromDir, moduleCache, options);
            newRequire.cache = moduleCache;
            return newRequire;
          }
        };
      }
      if (builtinModules[id]) {
        return builtinModules[id];
      }
      if (id === "rollup" || id.startsWith("rollup/") || id.startsWith("@rollup/")) {
        console.log("[runtime] Intercepted rollup:", id);
        return builtinModules["rollup"];
      }
      if (id === "esbuild" || id.startsWith("esbuild/") || id.startsWith("@esbuild/")) {
        console.log("[runtime] Intercepted esbuild:", id);
        return builtinModules["esbuild"];
      }
      if (id === "prettier" || id.startsWith("prettier/")) {
        return builtinModules["prettier"];
      }
      if (id.startsWith("@sentry/")) {
        return builtinModules["@sentry/node"];
      }
      const resolved = resolveModule(id, currentDir);
      if (builtinModules[resolved]) {
        return builtinModules[resolved];
      }
      if (resolved.includes("/node_modules/rollup/") || resolved.includes("/node_modules/@rollup/")) {
        return builtinModules["rollup"];
      }
      if (resolved.includes("/node_modules/esbuild/") || resolved.includes("/node_modules/@esbuild/")) {
        return builtinModules["esbuild"];
      }
      if (resolved.includes("/node_modules/prettier/")) {
        return builtinModules["prettier"];
      }
      if (resolved.includes("/node_modules/@sentry/")) {
        return builtinModules["@sentry/node"];
      }
      return loadModule(resolved).exports;
    };
    require.resolve = (id) => {
      if (id === "fs" || id === "process" || builtinModules[id]) {
        return id;
      }
      return resolveModule(id, currentDir);
    };
    require.cache = moduleCache;
    return require;
  }
  function createConsoleWrapper(onConsole) {
    const wrapper = {
      log: (...args) => {
        console.log(...args);
        onConsole == null ? void 0 : onConsole("log", args);
      },
      error: (...args) => {
        console.error(...args);
        onConsole == null ? void 0 : onConsole("error", args);
      },
      warn: (...args) => {
        console.warn(...args);
        onConsole == null ? void 0 : onConsole("warn", args);
      },
      info: (...args) => {
        console.info(...args);
        onConsole == null ? void 0 : onConsole("info", args);
      },
      debug: (...args) => {
        console.debug(...args);
        onConsole == null ? void 0 : onConsole("debug", args);
      },
      trace: (...args) => {
        console.trace(...args);
        onConsole == null ? void 0 : onConsole("trace", args);
      },
      dir: (obj) => {
        console.dir(obj);
        onConsole == null ? void 0 : onConsole("dir", [
          obj
        ]);
      },
      time: console.time.bind(console),
      timeEnd: console.timeEnd.bind(console),
      timeLog: console.timeLog.bind(console),
      assert: console.assert.bind(console),
      clear: console.clear.bind(console),
      count: console.count.bind(console),
      countReset: console.countReset.bind(console),
      group: console.group.bind(console),
      groupCollapsed: console.groupCollapsed.bind(console),
      groupEnd: console.groupEnd.bind(console),
      table: console.table.bind(console)
    };
    return wrapper;
  }
  Runtime = class {
    constructor(vfs2, options2 = {}) {
      __publicField(this, "vfs");
      __publicField(this, "fsShim");
      __publicField(this, "process");
      __publicField(this, "moduleCache", {});
      __publicField(this, "options");
      __publicField(this, "processedCodeCache", /* @__PURE__ */ new Map());
      __publicField(this, "executeSync", this.execute);
      __publicField(this, "runFileSync", this.runFile);
      this.vfs = vfs2;
      this.process = createProcess({
        cwd: options2.cwd || "/",
        env: options2.env
      });
      this.fsShim = createFsShim(vfs2, () => this.process.cwd());
      this.options = options2;
      initChildProcess(vfs2);
      setVFS$2(vfs2);
      setVFS$1(vfs2);
      setVFS(vfs2);
      this.setupStackTracePolyfill();
      this.setupTextDecoderPolyfill();
    }
    setupTextDecoderPolyfill() {
      const OriginalTextDecoder = globalThis.TextDecoder;
      class PolyfillTextDecoder {
        constructor(encoding = "utf-8", options2) {
          __publicField(this, "encoding");
          __publicField(this, "decoder", null);
          this.encoding = encoding.toLowerCase();
          const validTextEncodings = [
            "utf-8",
            "utf8",
            "utf-16le",
            "utf-16be",
            "utf-16",
            "ascii",
            "iso-8859-1",
            "latin1",
            "windows-1252"
          ];
          if (validTextEncodings.includes(this.encoding)) {
            try {
              this.decoder = new OriginalTextDecoder(encoding, options2);
            } catch {
              this.decoder = new OriginalTextDecoder("utf-8", options2);
            }
          }
        }
        decode(input, options2) {
          if (this.decoder) {
            return this.decoder.decode(input, options2);
          }
          if (!input) return "";
          const bytes = input instanceof ArrayBuffer ? new Uint8Array(input) : new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
          if (this.encoding === "base64") {
            return uint8ToBase64(bytes);
          }
          if (this.encoding === "base64url") {
            return uint8ToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
          }
          if (this.encoding === "hex") {
            return uint8ToHex(bytes);
          }
          return new OriginalTextDecoder("utf-8").decode(input, options2);
        }
        get fatal() {
          var _a2;
          return ((_a2 = this.decoder) == null ? void 0 : _a2.fatal) ?? false;
        }
        get ignoreBOM() {
          var _a2;
          return ((_a2 = this.decoder) == null ? void 0 : _a2.ignoreBOM) ?? false;
        }
      }
      globalThis.TextDecoder = PolyfillTextDecoder;
    }
    setupStackTracePolyfill() {
      if (typeof Error.captureStackTrace === "function") return;
      if (Error.stackTraceLimit === void 0) {
        Error.stackTraceLimit = 10;
      }
      function parseStack(stack) {
        if (!stack) return [];
        const frames = [];
        const lines = stack.split("\n");
        for (const raw of lines) {
          const line = raw.trim();
          if (!line || line.startsWith("Error") || line.startsWith("TypeError")) continue;
          let fn2 = "", file = "", lineNo = 0, colNo = 0;
          const safariMatch = line.match(/^(.*)@(.*?):(\d+):(\d+)$/);
          if (safariMatch) {
            fn2 = safariMatch[1] || "";
            file = safariMatch[2];
            lineNo = parseInt(safariMatch[3], 10);
            colNo = parseInt(safariMatch[4], 10);
            frames.push({
              fn: fn2,
              file,
              line: lineNo,
              col: colNo
            });
            continue;
          }
          const chromeMatch = line.match(/^at\s+(?:(.+?)\s+\()?(.*?):(\d+):(\d+)\)?$/);
          if (chromeMatch) {
            fn2 = chromeMatch[1] || "";
            file = chromeMatch[2];
            lineNo = parseInt(chromeMatch[3], 10);
            colNo = parseInt(chromeMatch[4], 10);
            frames.push({
              fn: fn2,
              file,
              line: lineNo,
              col: colNo
            });
            continue;
          }
        }
        return frames;
      }
      function createCallSite(frame) {
        return {
          getFileName: () => frame.file || null,
          getLineNumber: () => frame.line || null,
          getColumnNumber: () => frame.col || null,
          getFunctionName: () => frame.fn || null,
          getMethodName: () => frame.fn || null,
          getTypeName: () => null,
          getThis: () => void 0,
          getFunction: () => void 0,
          getEvalOrigin: () => void 0,
          isNative: () => false,
          isConstructor: () => false,
          isToplevel: () => !frame.fn,
          isEval: () => false,
          toString: () => frame.fn ? `${frame.fn} (${frame.file}:${frame.line}:${frame.col})` : `${frame.file}:${frame.line}:${frame.col}`
        };
      }
      function buildCallSites(stack, constructorOpt) {
        const frames = parseStack(stack);
        let startIdx = 0;
        if (constructorOpt && constructorOpt.name) {
          for (let i2 = 0; i2 < frames.length; i2++) {
            if (frames[i2].fn === constructorOpt.name) {
              startIdx = i2 + 1;
              break;
            }
          }
        }
        return frames.slice(startIdx).map(createCallSite);
      }
      const stackSymbol = Symbol("rawStack");
      Object.defineProperty(Error.prototype, "stack", {
        get() {
          const rawStack = this[stackSymbol];
          if (rawStack !== void 0 && typeof Error.prepareStackTrace === "function") {
            const callSites = buildCallSites(rawStack);
            try {
              return Error.prepareStackTrace(this, callSites);
            } catch {
              return rawStack;
            }
          }
          return rawStack;
        },
        set(value2) {
          this[stackSymbol] = value2;
        },
        configurable: true,
        enumerable: false
      });
      Error.captureStackTrace = function(target, constructorOpt) {
        const savedPrepare = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        const err = new Error();
        const rawStack = err.stack || "";
        Error.prepareStackTrace = savedPrepare;
        if (typeof savedPrepare === "function") {
          const callSites = buildCallSites(rawStack, constructorOpt);
          try {
            target.stack = savedPrepare(target, callSites);
          } catch (e) {
            console.warn("[almostnode] Error.prepareStackTrace threw:", e);
            target.stack = rawStack;
          }
        } else {
          target.stack = rawStack;
        }
      };
    }
    execute(code, filename = "/index.js") {
      const dirname$1 = dirname(filename);
      this.vfs.writeFileSync(filename, code);
      const require = createRequire(this.vfs, this.fsShim, this.process, dirname$1, this.moduleCache, this.options, this.processedCodeCache);
      const module = {
        id: filename,
        filename,
        exports: {},
        loaded: false,
        children: [],
        paths: []
      };
      this.moduleCache[filename] = module;
      const consoleWrapper = createConsoleWrapper(this.options.onConsole);
      try {
        const importMetaUrl = "file://" + filename;
        const wrappedCode = `(function($exports, $require, $module, $filename, $dirname, $process, $console, $importMeta) {
var exports = $exports;
var require = $require;
var module = $module;
var __filename = $filename;
var __dirname = $dirname;
var process = $process;
var console = $console;
var import_meta = $importMeta;
// Set up global.process and globalThis.process for code that accesses them directly
var global = globalThis;
globalThis.process = $process;
global.process = $process;

return (function() {
${code}
}).call(this);
})`;
        const fn = eval(wrappedCode);
        fn(module.exports, require, module, filename, dirname$1, this.process, consoleWrapper, {
          url: importMetaUrl,
          dirname: dirname$1,
          filename
        });
        module.loaded = true;
      } catch (error) {
        delete this.moduleCache[filename];
        throw error;
      }
      return {
        exports: module.exports,
        module
      };
    }
    async executeAsync(code2, filename2 = "/index.js") {
      return Promise.resolve(this.execute(code2, filename2));
    }
    runFile(filename2) {
      const code2 = this.vfs.readFileSync(filename2, "utf8");
      return this.execute(code2, filename2);
    }
    async runFileAsync(filename2) {
      return Promise.resolve(this.runFile(filename2));
    }
    clearCache() {
      this.moduleCache = {};
    }
    getVFS() {
      return this.vfs;
    }
    getProcess() {
      return this.process;
    }
    createREPL() {
      const require2 = createRequire(this.vfs, this.fsShim, this.process, "/", this.moduleCache, this.options, this.processedCodeCache);
      const consoleWrapper2 = createConsoleWrapper(this.options.onConsole);
      const process2 = this.process;
      const buffer2 = bufferModule.Buffer;
      const GeneratorFunction = Object.getPrototypeOf(function* () {
      }).constructor;
      const replGen = new GeneratorFunction("require", "console", "process", "Buffer", `var __code, __result;
while (true) {
  __code = yield;
  try {
    __result = eval(__code);
    yield { value: __result, error: null };
  } catch (e) {
    yield { value: undefined, error: e };
  }
}`)(require2, consoleWrapper2, process2, buffer2);
      replGen.next();
      return {
        eval(code2) {
          const transformed = code2.replace(/^\s*(const|let)\s+/gm, "var ");
          const exprResult = replGen.next("(" + transformed + ")").value;
          if (!exprResult.error) {
            replGen.next();
            return exprResult.value;
          }
          replGen.next();
          const stmtResult = replGen.next(transformed).value;
          if (stmtResult.error) {
            replGen.next();
            throw stmtResult.error;
          }
          replGen.next();
          return stmtResult.value;
        }
      };
    }
  };
  execute = function(code2, vfs2, options2) {
    const runtime = new Runtime(vfs2, options2);
    return runtime.execute(code2);
  };
  WorkerRuntime = class {
    constructor(vfs2, options2 = {}) {
      __publicField(this, "worker");
      __publicField(this, "workerApi");
      __publicField(this, "vfs");
      __publicField(this, "options");
      __publicField(this, "initialized");
      __publicField(this, "changeListener", null);
      __publicField(this, "deleteListener", null);
      this.vfs = vfs2;
      this.options = options2;
      this.worker = new Worker(new URL("/assets/runtime-worker-6nZdzFoC.js", import.meta.url), {
        type: "module"
      });
      this.workerApi = wrap(this.worker);
      this.initialized = this.initWorker();
      this.setupVFSListeners();
    }
    async initWorker() {
      const snapshot = this.vfs.toSnapshot();
      const workerOptions = {
        cwd: this.options.cwd,
        env: this.options.env
      };
      await this.workerApi.init(snapshot, workerOptions);
      if (this.options.onConsole) {
        await this.workerApi.setConsoleCallback(proxy(this.options.onConsole));
      }
      console.log("[WorkerRuntime] Worker initialized");
    }
    setupVFSListeners() {
      this.changeListener = (path2, content) => {
        this.workerApi.syncFile(path2, content);
      };
      this.vfs.on("change", this.changeListener);
      this.deleteListener = (path2) => {
        this.workerApi.syncFile(path2, null);
      };
      this.vfs.on("delete", this.deleteListener);
    }
    async execute(code2, filename2) {
      await this.initialized;
      return this.workerApi.execute(code2, filename2);
    }
    async runFile(filename2) {
      await this.initialized;
      return this.workerApi.runFile(filename2);
    }
    clearCache() {
      this.workerApi.clearCache();
    }
    getVFS() {
      return this.vfs;
    }
    terminate() {
      if (this.changeListener) {
        this.vfs.off("change", this.changeListener);
      }
      if (this.deleteListener) {
        this.vfs.off("delete", this.deleteListener);
      }
      this.worker.terminate();
      console.log("[WorkerRuntime] Worker terminated");
    }
  };
  SandboxRuntime = class {
    constructor(sandboxUrl, vfs2, options2 = {}) {
      __publicField(this, "iframe");
      __publicField(this, "sandboxOrigin");
      __publicField(this, "vfs");
      __publicField(this, "options");
      __publicField(this, "initialized");
      __publicField(this, "pending", /* @__PURE__ */ new Map());
      __publicField(this, "messageId", 0);
      __publicField(this, "changeListener", null);
      __publicField(this, "deleteListener", null);
      __publicField(this, "messageHandler", null);
      this.sandboxOrigin = new URL(sandboxUrl).origin;
      this.vfs = vfs2;
      this.options = options2;
      this.iframe = document.createElement("iframe");
      this.iframe.src = sandboxUrl;
      this.iframe.style.display = "none";
      this.iframe.credentialless = true;
      this.iframe.setAttribute("credentialless", "");
      document.body.appendChild(this.iframe);
      this.setupMessageHandler();
      this.initialized = this.waitForReady().then(() => this.initSandbox());
      this.setupVFSListeners();
    }
    setupMessageHandler() {
      this.messageHandler = (event) => {
        if (event.origin !== this.sandboxOrigin) return;
        const message = event.data;
        if (message.type === "result" && message.id) {
          const pending = this.pending.get(message.id);
          if (pending && message.result) {
            pending.resolve(message.result);
            this.pending.delete(message.id);
          }
        } else if (message.type === "error" && message.id) {
          const pending = this.pending.get(message.id);
          if (pending) {
            pending.reject(new Error(message.error || "Unknown sandbox error"));
            this.pending.delete(message.id);
          }
        } else if (message.type === "console" && this.options.onConsole) {
          this.options.onConsole(message.consoleMethod || "log", message.consoleArgs || []);
        }
      };
      window.addEventListener("message", this.messageHandler);
    }
    waitForReady() {
      return new Promise((resolve2) => {
        const handler = (event) => {
          if (event.origin !== this.sandboxOrigin) return;
          const message = event.data;
          if (message.type === "ready") {
            window.removeEventListener("message", handler);
            resolve2();
          }
        };
        window.addEventListener("message", handler);
      });
    }
    async initSandbox() {
      var _a2;
      const snapshot = this.vfs.toSnapshot();
      const message = {
        type: "init",
        vfsSnapshot: snapshot,
        options: {
          cwd: this.options.cwd,
          env: this.options.env
        }
      };
      (_a2 = this.iframe.contentWindow) == null ? void 0 : _a2.postMessage(message, this.sandboxOrigin);
      console.log("[SandboxRuntime] Sandbox initialized");
    }
    setupVFSListeners() {
      this.changeListener = (path2, content) => {
        var _a2;
        const message = {
          type: "syncFile",
          path: path2,
          content
        };
        (_a2 = this.iframe.contentWindow) == null ? void 0 : _a2.postMessage(message, this.sandboxOrigin);
      };
      this.vfs.on("change", this.changeListener);
      this.deleteListener = (path2) => {
        var _a2;
        const message = {
          type: "syncFile",
          path: path2,
          content: null
        };
        (_a2 = this.iframe.contentWindow) == null ? void 0 : _a2.postMessage(message, this.sandboxOrigin);
      };
      this.vfs.on("delete", this.deleteListener);
    }
    sendAndWait(message) {
      return new Promise((resolve2, reject) => {
        var _a2;
        const id = String(this.messageId++);
        this.pending.set(id, {
          resolve: resolve2,
          reject
        });
        (_a2 = this.iframe.contentWindow) == null ? void 0 : _a2.postMessage({
          ...message,
          id
        }, this.sandboxOrigin);
        setTimeout(() => {
          if (this.pending.has(id)) {
            this.pending.delete(id);
            reject(new Error("Sandbox execution timeout"));
          }
        }, 6e4);
      });
    }
    async execute(code2, filename2) {
      await this.initialized;
      return this.sendAndWait({
        type: "execute",
        code: code2,
        filename: filename2
      });
    }
    async runFile(filename2) {
      await this.initialized;
      return this.sendAndWait({
        type: "runFile",
        filename: filename2
      });
    }
    clearCache() {
      var _a2;
      const message = {
        type: "clearCache"
      };
      (_a2 = this.iframe.contentWindow) == null ? void 0 : _a2.postMessage(message, this.sandboxOrigin);
    }
    getVFS() {
      return this.vfs;
    }
    terminate() {
      if (this.changeListener) {
        this.vfs.off("change", this.changeListener);
      }
      if (this.deleteListener) {
        this.vfs.off("delete", this.deleteListener);
      }
      if (this.messageHandler) {
        window.removeEventListener("message", this.messageHandler);
      }
      this.iframe.remove();
      for (const [id, { reject }] of this.pending) {
        reject(new Error("Sandbox terminated"));
        this.pending.delete(id);
      }
      console.log("[SandboxRuntime] Sandbox terminated");
    }
  };
  function isWorkerAvailable() {
    return typeof Worker !== "undefined";
  }
  class AsyncRuntimeWrapper {
    constructor(vfs2, options2 = {}) {
      __publicField(this, "runtime");
      this.runtime = new Runtime(vfs2, options2);
    }
    async execute(code2, filename2) {
      return Promise.resolve(this.runtime.execute(code2, filename2));
    }
    async runFile(filename2) {
      return Promise.resolve(this.runtime.runFile(filename2));
    }
    clearCache() {
      this.runtime.clearCache();
    }
    getVFS() {
      return this.runtime.getVFS();
    }
    getSyncRuntime() {
      return this.runtime;
    }
  }
  createRuntime = async function(vfs2, options2 = {}) {
    const { sandbox, dangerouslyAllowSameOrigin, useWorker = false, ...runtimeOptions } = options2;
    if (sandbox) {
      console.log("[createRuntime] Creating SandboxRuntime (cross-origin isolated)");
      const sandboxRuntime = new SandboxRuntime(sandbox, vfs2, runtimeOptions);
      await sandboxRuntime.execute("/* sandbox ready check */", "/__sandbox_init__.js");
      return sandboxRuntime;
    }
    if (!dangerouslyAllowSameOrigin) {
      throw new Error('almostnode: For security, you must either:\n  1. Use sandbox mode: { sandbox: "https://your-sandbox.vercel.app" }\n  2. Explicitly opt-in to same-origin: { dangerouslyAllowSameOrigin: true }\n\nSame-origin execution allows code to access cookies, localStorage, and IndexedDB.\nOnly use dangerouslyAllowSameOrigin for trusted code or demos.\n\nFor sandbox setup instructions, see: https://github.com/anthropics/almostnode#sandbox-setup');
    }
    let shouldUseWorker = false;
    if (useWorker === true) {
      shouldUseWorker = isWorkerAvailable();
      if (!shouldUseWorker) {
        console.warn("[createRuntime] Worker requested but not available, falling back to main thread");
      }
    } else if (useWorker === "auto") {
      shouldUseWorker = isWorkerAvailable();
      console.log(`[createRuntime] Auto mode: using ${shouldUseWorker ? "worker" : "main thread"}`);
    }
    if (shouldUseWorker) {
      console.log("[createRuntime] Creating WorkerRuntime (same-origin, thread-isolated)");
      const workerRuntime = new WorkerRuntime(vfs2, runtimeOptions);
      await workerRuntime.execute("/* worker ready check */", "/__worker_init__.js");
      return workerRuntime;
    }
    console.log("[createRuntime] Creating main-thread Runtime (same-origin, least secure)");
    return new AsyncRuntimeWrapper(vfs2, runtimeOptions);
  };
  function getServiceWorkerContent() {
    if (typeof require === "undefined") {
      return null;
    }
    try {
      const fs2 = require("fs");
      const path2 = require("path");
      let dirname2;
      try {
        const url2 = require("url");
        dirname2 = path2.dirname(url2.fileURLToPath(import.meta.url));
      } catch {
        dirname2 = __dirname;
      }
      let swPath = path2.join(dirname2, "__sw__.js");
      if (fs2.existsSync(swPath)) {
        return fs2.readFileSync(swPath, "utf-8");
      }
      swPath = path2.join(dirname2, "../dist/__sw__.js");
      if (fs2.existsSync(swPath)) {
        return fs2.readFileSync(swPath, "utf-8");
      }
      return null;
    } catch {
      return null;
    }
  }
  getSandboxHtml = function(options2 = {}) {
    const opts = typeof options2 === "string" ? {
      almostnodeUrl: options2
    } : options2;
    const almostnodeUrl = opts.almostnodeUrl ?? "https://unpkg.com/almostnode/dist/index.js";
    const includeServiceWorker = opts.includeServiceWorker ?? true;
    const serviceWorkerScript = includeServiceWorker ? `
  // Register service worker for dev server support
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/__sw__.js', { scope: '/' })
      .then(reg => console.log('[Sandbox] Service worker registered'))
      .catch(err => console.warn('[Sandbox] Service worker registration failed:', err));
  }
` : "";
    return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>almostnode Sandbox</title>
</head>
<body>
<script type="module">
  import { VirtualFS, Runtime } from '${almostnodeUrl}';
${serviceWorkerScript}

  let vfs = null;
  let runtime = null;
  let consoleCallback = null;

  // Handle messages from parent
  window.addEventListener('message', async (event) => {
    const { type, id, code, filename, vfsSnapshot, options, path, content } = event.data;

    try {
      switch (type) {
        case 'init':
          // Initialize VFS from snapshot
          vfs = VirtualFS.fromSnapshot(vfsSnapshot);

          // Create runtime with options
          runtime = new Runtime(vfs, {
            cwd: options?.cwd,
            env: options?.env,
            onConsole: (method, args) => {
              // Forward console to parent
              parent.postMessage({
                type: 'console',
                consoleMethod: method,
                consoleArgs: args,
              }, '*');
            },
          });
          break;

        case 'syncFile':
          // Sync file changes from parent
          if (vfs) {
            if (content === null) {
              try { vfs.unlinkSync(path); } catch {}
            } else {
              vfs.writeFileSync(path, content);
            }
          }
          break;

        case 'execute':
          if (!runtime) {
            parent.postMessage({ type: 'error', id, error: 'Runtime not initialized' }, '*');
            return;
          }
          const execResult = runtime.execute(code, filename);
          parent.postMessage({ type: 'result', id, result: execResult }, '*');
          break;

        case 'runFile':
          if (!runtime) {
            parent.postMessage({ type: 'error', id, error: 'Runtime not initialized' }, '*');
            return;
          }
          const runResult = runtime.runFile(filename);
          parent.postMessage({ type: 'result', id, result: runResult }, '*');
          break;

        case 'clearCache':
          if (runtime) {
            runtime.clearCache();
          }
          break;
      }
    } catch (error) {
      if (id) {
        parent.postMessage({
          type: 'error',
          id,
          error: error instanceof Error ? error.message : String(error),
        }, '*');
      }
    }
  });

  // Signal ready to parent
  parent.postMessage({ type: 'ready' }, '*');
<\/script>
</body>
</html>`;
  };
  getSandboxVercelConfig = function() {
    return {
      headers: [
        {
          source: "/(.*)",
          headers: [
            {
              key: "Access-Control-Allow-Origin",
              value: "*"
            },
            {
              key: "Cross-Origin-Resource-Policy",
              value: "cross-origin"
            }
          ]
        }
      ]
    };
  };
  generateSandboxFiles = function(options2 = {}) {
    const opts = typeof options2 === "string" ? {
      almostnodeUrl: options2
    } : options2;
    const includeServiceWorker = opts.includeServiceWorker ?? true;
    const swContent = includeServiceWorker ? getServiceWorkerContent() : null;
    const files = {
      "index.html": getSandboxHtml(opts),
      "vercel.json": JSON.stringify(getSandboxVercelConfig(), null, 2)
    };
    if (swContent) {
      files["__sw__.js"] = swContent;
    }
    return files;
  };
  SANDBOX_SETUP_INSTRUCTIONS = `
# Setting up a almostnode Sandbox on Vercel

## 1. Create sandbox directory
   mkdir sandbox

## 2. Generate sandbox files
   Use generateSandboxFiles() or copy the templates manually.

## 3. Deploy to Vercel
   cd sandbox
   vercel --prod

## 4. Use in your app
   const runtime = await createRuntime(vfs, {
     sandbox: 'https://your-sandbox.vercel.app'
   });

For more details, see: https://github.com/anthropics/almostnode#sandbox-setup
`.trim();
  const DEFAULT_REGISTRY = "https://registry.npmjs.org";
  class Registry {
    constructor(options2 = {}) {
      __publicField(this, "registryUrl");
      __publicField(this, "cache");
      this.registryUrl = options2.registry || DEFAULT_REGISTRY;
      this.cache = options2.cache || /* @__PURE__ */ new Map();
    }
    async getPackageManifest(packageName) {
      if (this.cache.has(packageName)) {
        return this.cache.get(packageName);
      }
      const url2 = `${this.registryUrl}/${encodePackageName(packageName)}`;
      const response = await fetch(url2, {
        headers: {
          Accept: "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8"
        }
      });
      if (!response.ok) {
        if (response.status === 404) {
          throw new Error(`Package not found: ${packageName}`);
        }
        throw new Error(`Failed to fetch package ${packageName}: ${response.status}`);
      }
      const manifest = await response.json();
      this.cache.set(packageName, manifest);
      return manifest;
    }
    async getPackageVersion(packageName, version2) {
      const manifest = await this.getPackageManifest(packageName);
      if (manifest["dist-tags"][version2]) {
        version2 = manifest["dist-tags"][version2];
      }
      const versionData = manifest.versions[version2];
      if (!versionData) {
        throw new Error(`Version ${version2} not found for package ${packageName}`);
      }
      return versionData;
    }
    async getLatestVersion(packageName) {
      const manifest = await this.getPackageManifest(packageName);
      return manifest["dist-tags"].latest;
    }
    async getVersions(packageName) {
      const manifest = await this.getPackageManifest(packageName);
      return Object.keys(manifest.versions);
    }
    async downloadTarball(tarballUrl) {
      const response = await fetch(tarballUrl);
      if (!response.ok) {
        throw new Error(`Failed to download tarball: ${response.status}`);
      }
      return response.arrayBuffer();
    }
    clearCache() {
      this.cache.clear();
    }
  }
  function encodePackageName(name2) {
    return name2.replace("/", "%2f");
  }
  new Registry();
  function parseVersion(version2) {
    const match = version2.match(/^(\d+)\.(\d+)\.(\d+)(?:-(.+))?$/);
    if (!match) return null;
    return {
      major: parseInt(match[1], 10),
      minor: parseInt(match[2], 10),
      patch: parseInt(match[3], 10),
      prerelease: match[4]
    };
  }
  function compareVersions(a, b) {
    const parsedA = parseVersion(a);
    const parsedB = parseVersion(b);
    if (!parsedA || !parsedB) {
      return a.localeCompare(b);
    }
    if (parsedA.major !== parsedB.major) {
      return parsedA.major - parsedB.major;
    }
    if (parsedA.minor !== parsedB.minor) {
      return parsedA.minor - parsedB.minor;
    }
    if (parsedA.patch !== parsedB.patch) {
      return parsedA.patch - parsedB.patch;
    }
    if (parsedA.prerelease && !parsedB.prerelease) return -1;
    if (!parsedA.prerelease && parsedB.prerelease) return 1;
    if (parsedA.prerelease && parsedB.prerelease) {
      return parsedA.prerelease.localeCompare(parsedB.prerelease);
    }
    return 0;
  }
  function satisfies(version2, range) {
    const parsed = parseVersion(version2);
    if (!parsed) return false;
    if (parsed.prerelease && !range.includes("-")) {
      return false;
    }
    range = range.trim();
    if (/^\d+\.\d+\.\d+/.test(range) && !range.includes(" ")) {
      const rangeMatch = range.match(/^(\d+\.\d+\.\d+(?:-[^\s]+)?)/);
      if (rangeMatch) {
        return compareVersions(version2, rangeMatch[1]) === 0;
      }
    }
    if (range === "*" || range === "latest" || range === "") {
      return true;
    }
    if (range.includes("||")) {
      return range.split("||").some((r) => satisfies(version2, r.trim()));
    }
    if (range.includes(" - ")) {
      const [min, max] = range.split(" - ").map((s) => s.trim());
      return compareVersions(version2, min) >= 0 && compareVersions(version2, max) <= 0;
    }
    const operatorMatches = range.match(/(>=|<=|>|<|=)?\s*(\d+\.\d+\.\d+(?:-[^\s]*)?)/g);
    if (operatorMatches && operatorMatches.length > 1) {
      return operatorMatches.every((match) => {
        const m = match.match(/^(>=|<=|>|<|=)?\s*(\d+\.\d+\.\d+(?:-[^\s]*)?)$/);
        if (!m) return true;
        const op = m[1] || "=";
        const ver = m[2];
        switch (op) {
          case ">=":
            return compareVersions(version2, ver) >= 0;
          case "<=":
            return compareVersions(version2, ver) <= 0;
          case ">":
            return compareVersions(version2, ver) > 0;
          case "<":
            return compareVersions(version2, ver) < 0;
          case "=":
            return compareVersions(version2, ver) === 0;
          default:
            return compareVersions(version2, ver) === 0;
        }
      });
    }
    if (range.startsWith("^")) {
      const base = range.slice(1);
      const baseParsed = parseVersion(base);
      if (!baseParsed) return false;
      if (parsed.major !== baseParsed.major) {
        return false;
      }
      if (baseParsed.major === 0) {
        if (baseParsed.minor !== 0 && parsed.minor !== baseParsed.minor) {
          return false;
        }
        if (baseParsed.minor === 0 && parsed.minor !== 0) {
          return false;
        }
      }
      return compareVersions(version2, base) >= 0;
    }
    if (range.startsWith("~")) {
      const base = range.slice(1);
      const baseParsed = parseVersion(base);
      if (!baseParsed) return false;
      if (parsed.major !== baseParsed.major || parsed.minor !== baseParsed.minor) {
        return false;
      }
      return compareVersions(version2, base) >= 0;
    }
    if (range.startsWith(">=")) {
      const base = range.slice(2).trim();
      return compareVersions(version2, base) >= 0;
    }
    if (range.startsWith(">")) {
      const base = range.slice(1).trim();
      return compareVersions(version2, base) > 0;
    }
    if (range.startsWith("<=")) {
      const base = range.slice(2).trim();
      return compareVersions(version2, base) <= 0;
    }
    if (range.startsWith("<")) {
      const base = range.slice(1).trim();
      return compareVersions(version2, base) < 0;
    }
    if (range.includes("x") || range.includes("X") || /^\d+$/.test(range) || /^\d+\.\d+$/.test(range)) {
      const parts = range.replace(/[xX]/g, "").split(".").filter(Boolean);
      if (parts.length === 1) {
        return parsed.major === parseInt(parts[0], 10);
      }
      if (parts.length === 2) {
        return parsed.major === parseInt(parts[0], 10) && parsed.minor === parseInt(parts[1], 10);
      }
    }
    if (range.includes(" ")) {
      const conditions = range.split(/\s+/).filter(Boolean);
      return conditions.every((r) => satisfies(version2, r));
    }
    return compareVersions(version2, range) === 0;
  }
  function findBestVersion(versions, range) {
    const sorted = [
      ...versions
    ].sort((a, b) => compareVersions(b, a));
    for (const version2 of sorted) {
      if (satisfies(version2, range)) {
        return version2;
      }
    }
    return null;
  }
  async function resolveDependencies(packageName, versionRange = "latest", options2 = {}) {
    const registry = options2.registry || new Registry();
    const context2 = {
      registry,
      resolved: /* @__PURE__ */ new Map(),
      resolving: /* @__PURE__ */ new Set(),
      options: options2
    };
    await resolvePackage(packageName, versionRange, context2);
    return context2.resolved;
  }
  async function resolveFromPackageJson(packageJson, options2 = {}) {
    const registry = options2.registry || new Registry();
    const context2 = {
      registry,
      resolved: /* @__PURE__ */ new Map(),
      resolving: /* @__PURE__ */ new Set(),
      options: options2
    };
    const deps = {
      ...packageJson.dependencies
    };
    if (options2.includeDev && packageJson.devDependencies) {
      Object.assign(deps, packageJson.devDependencies);
    }
    for (const [name2, range] of Object.entries(deps)) {
      await resolvePackage(name2, range, context2);
    }
    return context2.resolved;
  }
  async function resolvePackage(packageName, versionRange, context2) {
    var _a2;
    const { registry, resolved, resolving, options: options2 } = context2;
    const key = `${packageName}@${versionRange}`;
    if (resolving.has(key)) {
      return;
    }
    if (resolved.has(packageName)) {
      const existing = resolved.get(packageName);
      if (satisfies(existing.version, versionRange)) {
        return;
      }
      return;
    }
    resolving.add(key);
    try {
      (_a2 = options2.onProgress) == null ? void 0 : _a2.call(options2, `Resolving ${packageName}@${versionRange}`);
      const manifest = await registry.getPackageManifest(packageName);
      const versions = Object.keys(manifest.versions);
      let targetVersion;
      if (versionRange === "latest" || versionRange === "*") {
        targetVersion = manifest["dist-tags"].latest;
      } else if (manifest["dist-tags"][versionRange]) {
        targetVersion = manifest["dist-tags"][versionRange];
      } else {
        const best = findBestVersion(versions, versionRange);
        if (!best) {
          throw new Error(`No matching version found for ${packageName}@${versionRange}`);
        }
        targetVersion = best;
      }
      const versionData = manifest.versions[targetVersion];
      const resolvedPackage = {
        name: packageName,
        version: targetVersion,
        tarballUrl: versionData.dist.tarball,
        dependencies: versionData.dependencies || {}
      };
      resolved.set(packageName, resolvedPackage);
      const deps = {
        ...versionData.dependencies
      };
      if (options2.includeOptional && versionData.optionalDependencies) {
        Object.assign(deps, versionData.optionalDependencies);
      }
      const depEntries = Object.entries(deps);
      if (depEntries.length > 0) {
        const CONCURRENCY = 8;
        for (let i2 = 0; i2 < depEntries.length; i2 += CONCURRENCY) {
          const batch = depEntries.slice(i2, i2 + CONCURRENCY);
          await Promise.all(batch.map(([depName, depRange]) => resolvePackage(depName, depRange, context2)));
        }
      }
    } finally {
      resolving.delete(key);
    }
  }
  function* parseTar(data2) {
    new TextDecoder();
    let offset = 0;
    while (offset < data2.length - 512) {
      const header = data2.slice(offset, offset + 512);
      offset += 512;
      if (header.every((b) => b === 0)) {
        break;
      }
      const name2 = parseString(header, 0, 100);
      const mode = parseOctal(header, 100, 8);
      const size = parseOctal(header, 124, 12);
      const typeFlag = String.fromCharCode(header[156]);
      const linkName = parseString(header, 157, 100);
      const prefix = parseString(header, 345, 155);
      if (!name2) {
        continue;
      }
      const fullName = prefix ? `${prefix}/${name2}` : name2;
      let type2;
      switch (typeFlag) {
        case "0":
        case "\0":
        case "":
          type2 = "file";
          break;
        case "5":
          type2 = "directory";
          break;
        case "1":
        case "2":
          type2 = "symlink";
          break;
        default:
          type2 = "unknown";
      }
      let content;
      if (type2 === "file" && size > 0) {
        content = data2.slice(offset, offset + size);
        offset += Math.ceil(size / 512) * 512;
      }
      yield {
        name: fullName,
        type: type2,
        size,
        mode,
        content,
        linkTarget: type2 === "symlink" ? linkName : void 0
      };
    }
  }
  function parseString(data2, offset, length2) {
    const bytes = data2.slice(offset, offset + length2);
    const nullIndex = bytes.indexOf(0);
    const actualBytes = nullIndex >= 0 ? bytes.slice(0, nullIndex) : bytes;
    return new TextDecoder().decode(actualBytes);
  }
  function parseOctal(data2, offset, length2) {
    const str = parseString(data2, offset, length2).trim();
    return parseInt(str, 8) || 0;
  }
  function decompress(data2) {
    const input = data2 instanceof Uint8Array ? data2 : new Uint8Array(data2);
    return pako.inflate(input);
  }
  function extractTarball(tarballData, vfs2, destPath, options2 = {}) {
    const { stripComponents = 1, filter, onProgress } = options2;
    onProgress == null ? void 0 : onProgress("Decompressing...");
    const tarData = decompress(tarballData);
    const extractedFiles = [];
    for (const entry of parseTar(tarData)) {
      if (entry.type !== "file" && entry.type !== "directory") {
        continue;
      }
      let entryPath = entry.name;
      if (stripComponents > 0) {
        const parts = entryPath.split("/").filter(Boolean);
        if (parts.length <= stripComponents) {
          continue;
        }
        entryPath = parts.slice(stripComponents).join("/");
      }
      if (filter && !filter(entryPath)) {
        continue;
      }
      const fullPath = join(destPath, entryPath);
      if (entry.type === "directory") {
        vfs2.mkdirSync(fullPath, {
          recursive: true
        });
      } else if (entry.type === "file" && entry.content) {
        const parentDir = dirname(fullPath);
        vfs2.mkdirSync(parentDir, {
          recursive: true
        });
        vfs2.writeFileSync(fullPath, entry.content);
        extractedFiles.push(fullPath);
      }
    }
    onProgress == null ? void 0 : onProgress(`Extracted ${extractedFiles.length} files`);
    return extractedFiles;
  }
  async function downloadAndExtract(url2, vfs2, destPath, options2 = {}) {
    const { onProgress } = options2;
    onProgress == null ? void 0 : onProgress(`Downloading ${url2}...`);
    const response = await fetch(url2);
    if (!response.ok) {
      throw new Error(`Failed to download tarball: ${response.status}`);
    }
    const data2 = await response.arrayBuffer();
    return extractTarball(data2, vfs2, destPath, options2);
  }
  const isBrowser$2 = typeof window !== "undefined";
  async function initTransformer() {
    if (!isBrowser$2) {
      console.log("[transform] Skipping esbuild init (not in browser)");
      return;
    }
    if (window.__esbuild) {
      console.log("[transform] Reusing existing esbuild instance");
      return;
    }
    if (window.__esbuildInitPromise) {
      return window.__esbuildInitPromise;
    }
    window.__esbuildInitPromise = (async () => {
      try {
        console.log("[transform] Loading esbuild-wasm...");
        const mod = await import("https://esm.sh/esbuild-wasm@0.20.0").then(async (m) => {
          await m.__tla;
          return m;
        });
        const esbuildMod = mod.default || mod;
        try {
          await esbuildMod.initialize({
            wasmURL: "https://unpkg.com/esbuild-wasm@0.20.0/esbuild.wasm"
          });
          console.log("[transform] esbuild-wasm initialized");
        } catch (initError) {
          if (initError instanceof Error && initError.message.includes('Cannot call "initialize" more than once')) {
            console.log("[transform] esbuild-wasm already initialized, reusing");
          } else {
            throw initError;
          }
        }
        window.__esbuild = esbuildMod;
      } catch (error) {
        console.error("[transform] Failed to initialize esbuild:", error);
        window.__esbuildInitPromise = void 0;
        throw error;
      }
    })();
    return window.__esbuildInitPromise;
  }
  function isTransformerReady() {
    if (!isBrowser$2) return true;
    return window.__esbuild !== void 0;
  }
  async function transformFile(code2, filename2) {
    if (!isBrowser$2) {
      return code2;
    }
    if (!window.__esbuild) {
      await initTransformer();
    }
    const esbuild2 = window.__esbuild;
    if (!esbuild2) {
      throw new Error("esbuild not initialized");
    }
    let loader = "js";
    if (filename2.endsWith(".jsx")) loader = "jsx";
    else if (filename2.endsWith(".ts")) loader = "ts";
    else if (filename2.endsWith(".tsx")) loader = "tsx";
    else if (filename2.endsWith(".mjs")) loader = "js";
    try {
      const result = await esbuild2.transform(code2, {
        loader,
        format: "cjs",
        target: "esnext",
        platform: "neutral",
        define: {
          "import.meta.url": "import_meta.url",
          "import.meta.dirname": "import_meta.dirname",
          "import.meta.filename": "import_meta.filename",
          "import.meta": "import_meta"
        }
      });
      let transformed = result.code;
      transformed = transformed.replace(/\bimport\s*\(\s*["']node:([^"']+)["']\s*\)/g, 'Promise.resolve(require("node:$1"))');
      const nodeBuiltins = [
        "assert",
        "buffer",
        "child_process",
        "cluster",
        "crypto",
        "dgram",
        "dns",
        "events",
        "fs",
        "http",
        "http2",
        "https",
        "net",
        "os",
        "path",
        "perf_hooks",
        "querystring",
        "readline",
        "stream",
        "string_decoder",
        "timers",
        "tls",
        "url",
        "util",
        "v8",
        "vm",
        "worker_threads",
        "zlib",
        "async_hooks",
        "inspector",
        "module"
      ];
      for (const builtin of nodeBuiltins) {
        const pattern = new RegExp(`\\bimport\\s*\\(\\s*["']${builtin}["']\\s*\\)`, "g");
        transformed = transformed.replace(pattern, `Promise.resolve(require("${builtin}"))`);
      }
      return transformed;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      if (errorMsg.includes("Top-level await")) {
        console.log(`[transform] Skipping ${filename2} (has top-level await, likely CLI entry point)`);
        return code2;
      }
      console.warn(`[transform] Failed to transform ${filename2}:`, error);
      return code2;
    }
  }
  function needsTransform$1(filename2, code2) {
    if (filename2.endsWith(".mjs")) {
      return true;
    }
    if (filename2.endsWith(".cjs")) {
      return false;
    }
    const hasImport = /\bimport\s+[\w{*'"]/m.test(code2);
    const hasExport = /\bexport\s+(?:default|const|let|var|function|class|{|\*)/m.test(code2);
    const hasImportMeta = /\bimport\.meta\b/.test(code2);
    return hasImport || hasExport || hasImportMeta;
  }
  function hasDynamicNodeImports(code2) {
    if (/\bimport\s*\(\s*["']node:/.test(code2)) {
      return true;
    }
    if (/\bimport\s*\(\s*["'](fs|path|http|https|net|url|util|events|stream|os|crypto)["']/.test(code2)) {
      return true;
    }
    return false;
  }
  function patchDynamicImports(code2) {
    let patched = code2;
    patched = patched.replace(/\bimport\s*\(\s*["']node:([^"']+)["']\s*\)/g, 'Promise.resolve(require("node:$1"))');
    const nodeBuiltins = [
      "assert",
      "buffer",
      "child_process",
      "cluster",
      "crypto",
      "dgram",
      "dns",
      "events",
      "fs",
      "http",
      "http2",
      "https",
      "net",
      "os",
      "path",
      "perf_hooks",
      "querystring",
      "readline",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "url",
      "util",
      "v8",
      "vm",
      "worker_threads",
      "zlib",
      "async_hooks",
      "inspector",
      "module"
    ];
    for (const builtin of nodeBuiltins) {
      const pattern = new RegExp(`\\bimport\\s*\\(\\s*["']${builtin}["']\\s*\\)`, "g");
      patched = patched.replace(pattern, `Promise.resolve(require("${builtin}"))`);
    }
    return patched;
  }
  async function transformPackage(vfs2, pkgPath, onProgress) {
    let transformedCount = 0;
    const jsFiles = findJsFiles(vfs2, pkgPath);
    onProgress == null ? void 0 : onProgress(`  Transforming ${jsFiles.length} files in ${pkgPath}...`);
    const BATCH_SIZE = 10;
    for (let i2 = 0; i2 < jsFiles.length; i2 += BATCH_SIZE) {
      const batch = jsFiles.slice(i2, i2 + BATCH_SIZE);
      await Promise.all(batch.map(async (filePath) => {
        try {
          const code2 = vfs2.readFileSync(filePath, "utf8");
          if (needsTransform$1(filePath, code2)) {
            const transformed = await transformFile(code2, filePath);
            vfs2.writeFileSync(filePath, transformed);
            transformedCount++;
          } else if (hasDynamicNodeImports(code2)) {
            const patched = patchDynamicImports(code2);
            vfs2.writeFileSync(filePath, patched);
            transformedCount++;
          }
        } catch (error) {
          console.warn(`[transform] Skipping ${filePath}:`, error);
        }
      }));
    }
    return transformedCount;
  }
  function findJsFiles(vfs2, dir) {
    const files = [];
    try {
      const entries = vfs2.readdirSync(dir);
      for (const entry of entries) {
        const fullPath = dir + "/" + entry;
        try {
          const stat = vfs2.statSync(fullPath);
          if (stat.isDirectory()) {
            if (entry !== "node_modules") {
              files.push(...findJsFiles(vfs2, fullPath));
            }
          } else if (entry.endsWith(".js") || entry.endsWith(".mjs") || entry.endsWith(".jsx")) {
            files.push(fullPath);
          }
        } catch {
        }
      }
    } catch {
    }
    return files;
  }
  PackageManager = class {
    constructor(vfs2, options2 = {}) {
      __publicField(this, "vfs");
      __publicField(this, "registry");
      __publicField(this, "cwd");
      this.vfs = vfs2;
      this.registry = new Registry(options2);
      this.cwd = options2.cwd || "/";
    }
    async install(packageSpec, options2 = {}) {
      const { onProgress } = options2;
      const { name: name2, version: version2 } = parsePackageSpec(packageSpec);
      onProgress == null ? void 0 : onProgress(`Resolving ${name2}@${version2 || "latest"}...`);
      const resolved = await resolveDependencies(name2, version2 || "latest", {
        registry: this.registry,
        includeDev: options2.includeDev,
        includeOptional: options2.includeOptional,
        onProgress
      });
      const added = await this.installResolved(resolved, options2);
      if (options2.save || options2.saveDev) {
        const pkgToAdd = resolved.get(name2);
        if (pkgToAdd) {
          await this.updatePackageJson(name2, `^${pkgToAdd.version}`, options2.saveDev || false);
        }
      }
      onProgress == null ? void 0 : onProgress(`Installed ${resolved.size} packages`);
      return {
        installed: resolved,
        added
      };
    }
    async installFromPackageJson(options2 = {}) {
      const { onProgress } = options2;
      const pkgJsonPath = join(this.cwd, "package.json");
      if (!this.vfs.existsSync(pkgJsonPath)) {
        throw new Error("No package.json found");
      }
      const pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
      onProgress == null ? void 0 : onProgress("Resolving dependencies...");
      const resolved = await resolveFromPackageJson(pkgJson, {
        registry: this.registry,
        includeDev: options2.includeDev,
        includeOptional: options2.includeOptional,
        onProgress
      });
      const added = await this.installResolved(resolved, options2);
      onProgress == null ? void 0 : onProgress(`Installed ${resolved.size} packages`);
      return {
        installed: resolved,
        added
      };
    }
    async installResolved(resolved, options2) {
      const { onProgress } = options2;
      const added = [];
      const nodeModulesPath = join(this.cwd, "node_modules");
      this.vfs.mkdirSync(nodeModulesPath, {
        recursive: true
      });
      const toInstall = [];
      for (const [name2, pkg] of resolved) {
        const pkgPath = join(nodeModulesPath, name2);
        const existingPkgJson = join(pkgPath, "package.json");
        if (this.vfs.existsSync(existingPkgJson)) {
          try {
            const existing = JSON.parse(this.vfs.readFileSync(existingPkgJson, "utf8"));
            if (existing.version === pkg.version) {
              onProgress == null ? void 0 : onProgress(`Skipping ${name2}@${pkg.version} (already installed)`);
              continue;
            }
          } catch {
          }
        }
        toInstall.push({
          name: name2,
          pkg,
          pkgPath
        });
      }
      const shouldTransform = options2.transform !== false;
      if (shouldTransform && !isTransformerReady()) {
        onProgress == null ? void 0 : onProgress("Initializing ESM transformer...");
        await initTransformer();
      }
      const CONCURRENCY = 6;
      onProgress == null ? void 0 : onProgress(`Installing ${toInstall.length} packages...`);
      for (let i2 = 0; i2 < toInstall.length; i2 += CONCURRENCY) {
        const batch = toInstall.slice(i2, i2 + CONCURRENCY);
        await Promise.all(batch.map(async ({ name: name2, pkg, pkgPath }) => {
          onProgress == null ? void 0 : onProgress(`  Downloading ${name2}@${pkg.version}...`);
          await downloadAndExtract(pkg.tarballUrl, this.vfs, pkgPath, {
            stripComponents: 1
          });
          if (shouldTransform) {
            try {
              const count = await transformPackage(this.vfs, pkgPath, onProgress);
              if (count > 0) {
                onProgress == null ? void 0 : onProgress(`  Transformed ${count} files in ${name2}`);
              }
            } catch (transformError) {
              onProgress == null ? void 0 : onProgress(`  Warning: Transform failed for ${name2}: ${transformError}`);
            }
          }
          added.push(name2);
        }));
      }
      await this.writeLockfile(resolved);
      return added;
    }
    async writeLockfile(resolved) {
      const lockfile = {};
      for (const [name2, pkg] of resolved) {
        lockfile[name2] = {
          version: pkg.version,
          resolved: pkg.tarballUrl
        };
      }
      const lockfilePath = join(this.cwd, "node_modules", ".package-lock.json");
      this.vfs.writeFileSync(lockfilePath, JSON.stringify(lockfile, null, 2));
    }
    async updatePackageJson(packageName, version2, isDev) {
      const pkgJsonPath = join(this.cwd, "package.json");
      let pkgJson = {};
      if (this.vfs.existsSync(pkgJsonPath)) {
        pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
      }
      const field = isDev ? "devDependencies" : "dependencies";
      if (!pkgJson[field]) {
        pkgJson[field] = {};
      }
      pkgJson[field][packageName] = version2;
      this.vfs.writeFileSync(pkgJsonPath, JSON.stringify(pkgJson, null, 2));
    }
    list() {
      const nodeModulesPath = join(this.cwd, "node_modules");
      if (!this.vfs.existsSync(nodeModulesPath)) {
        return {};
      }
      const packages = {};
      const entries = this.vfs.readdirSync(nodeModulesPath);
      for (const entry of entries) {
        if (entry.startsWith(".")) continue;
        if (entry.startsWith("@")) {
          const scopePath = join(nodeModulesPath, entry);
          const scopedPkgs = this.vfs.readdirSync(scopePath);
          for (const scopedPkg of scopedPkgs) {
            const pkgJsonPath = join(scopePath, scopedPkg, "package.json");
            if (this.vfs.existsSync(pkgJsonPath)) {
              const pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
              packages[`${entry}/${scopedPkg}`] = pkgJson.version;
            }
          }
        } else {
          const pkgJsonPath = join(nodeModulesPath, entry, "package.json");
          if (this.vfs.existsSync(pkgJsonPath)) {
            const pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
            packages[entry] = pkgJson.version;
          }
        }
      }
      return packages;
    }
  };
  function parsePackageSpec(spec2) {
    if (spec2.startsWith("@")) {
      const slashIndex = spec2.indexOf("/");
      if (slashIndex === -1) {
        throw new Error(`Invalid package spec: ${spec2}`);
      }
      const afterSlash = spec2.slice(slashIndex + 1);
      const atIndex2 = afterSlash.indexOf("@");
      if (atIndex2 === -1) {
        return {
          name: spec2
        };
      }
      return {
        name: spec2.slice(0, slashIndex + 1 + atIndex2),
        version: afterSlash.slice(atIndex2 + 1)
      };
    }
    const atIndex = spec2.indexOf("@");
    if (atIndex === -1) {
      return {
        name: spec2
      };
    }
    return {
      name: spec2.slice(0, atIndex),
      version: spec2.slice(atIndex + 1)
    };
  }
  install = async function(packageSpec, vfs2, options2) {
    const pm = new PackageManager(vfs2);
    return pm.install(packageSpec, options2);
  };
  index = Object.freeze(Object.defineProperty({
    __proto__: null,
    PackageManager,
    Registry,
    install,
    parsePackageSpec
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const _encoder = new TextEncoder();
  ServerBridge = (_c = class extends EventEmitter {
    constructor(options2 = {}) {
      super();
      __publicField(this, "servers", /* @__PURE__ */ new Map());
      __publicField(this, "baseUrl");
      __publicField(this, "options");
      __publicField(this, "messageChannel", null);
      __publicField(this, "serviceWorkerReady", false);
      __publicField(this, "keepaliveInterval", null);
      this.options = options2;
      if (typeof location !== "undefined") {
        this.baseUrl = options2.baseUrl || `${location.protocol}//${location.host}`;
      } else {
        this.baseUrl = options2.baseUrl || "http://localhost";
      }
      setServerListenCallback((port, server) => {
        this.registerServer(server, port);
      });
      setServerCloseCallback((port) => {
        this.unregisterServer(port);
      });
    }
    registerServer(server, port, hostname2 = "0.0.0.0") {
      this.servers.set(port, {
        server,
        port,
        hostname: hostname2
      });
      const url2 = this.getServerUrl(port);
      this.emit("server-ready", port, url2);
      if (this.options.onServerReady) {
        this.options.onServerReady(port, url2);
      }
      this.notifyServiceWorker("server-registered", {
        port,
        hostname: hostname2
      });
    }
    unregisterServer(port) {
      this.servers.delete(port);
      this.notifyServiceWorker("server-unregistered", {
        port
      });
    }
    getServerUrl(port) {
      return `${this.baseUrl}/__virtual__/${port}`;
    }
    getServerPorts() {
      return [
        ...this.servers.keys()
      ];
    }
    async handleRequest(port, method, url2, headers, body) {
      const virtualServer = this.servers.get(port);
      if (!virtualServer) {
        return {
          statusCode: 503,
          statusMessage: "Service Unavailable",
          headers: {
            "Content-Type": "text/plain"
          },
          body: BufferPolyfill.from(`No server listening on port ${port}`)
        };
      }
      try {
        const bodyBuffer = body ? BufferPolyfill.from(new Uint8Array(body)) : void 0;
        return await virtualServer.server.handleRequest(method, url2, headers, bodyBuffer);
      } catch (error) {
        const message = error instanceof Error ? error.message : "Internal Server Error";
        return {
          statusCode: 500,
          statusMessage: "Internal Server Error",
          headers: {
            "Content-Type": "text/plain"
          },
          body: BufferPolyfill.from(message)
        };
      }
    }
    async initServiceWorker(options2) {
      if (!("serviceWorker" in navigator)) {
        throw new Error("Service Workers not supported");
      }
      const swUrl = (options2 == null ? void 0 : options2.swUrl) ?? "/__sw__.js";
      const controllerReady = navigator.serviceWorker.controller ? Promise.resolve() : new Promise((resolve2) => {
        navigator.serviceWorker.addEventListener("controllerchange", () => resolve2(), {
          once: true
        });
      });
      const registration = await navigator.serviceWorker.register(swUrl, {
        scope: "/"
      });
      const sw = registration.active || registration.waiting || registration.installing;
      if (!sw) {
        throw new Error("Service Worker registration failed");
      }
      await new Promise((resolve2) => {
        if (sw.state === "activated") {
          resolve2();
        } else {
          const handler = () => {
            if (sw.state === "activated") {
              sw.removeEventListener("statechange", handler);
              resolve2();
            }
          };
          sw.addEventListener("statechange", handler);
        }
      });
      this.messageChannel = new MessageChannel();
      this.messageChannel.port1.onmessage = this.handleServiceWorkerMessage.bind(this);
      sw.postMessage({
        type: "init",
        port: this.messageChannel.port2
      }, [
        this.messageChannel.port2
      ]);
      await controllerReady;
      const reinit = () => {
        if (navigator.serviceWorker.controller) {
          this.messageChannel = new MessageChannel();
          this.messageChannel.port1.onmessage = this.handleServiceWorkerMessage.bind(this);
          navigator.serviceWorker.controller.postMessage({
            type: "init",
            port: this.messageChannel.port2
          }, [
            this.messageChannel.port2
          ]);
        }
      };
      navigator.serviceWorker.addEventListener("controllerchange", reinit);
      navigator.serviceWorker.addEventListener("message", (event) => {
        var _a2;
        if (((_a2 = event.data) == null ? void 0 : _a2.type) === "sw-needs-init") {
          reinit();
        }
      });
      this.keepaliveInterval = setInterval(() => {
        var _a2;
        (_a2 = this.messageChannel) == null ? void 0 : _a2.port1.postMessage({
          type: "keepalive"
        });
      }, 2e4);
      this.serviceWorkerReady = true;
      this.emit("sw-ready");
    }
    async handleServiceWorkerMessage(event) {
      var _a2, _b2, _c2;
      const { type: type2, id, data: data2 } = event.data;
      ServerBridge.DEBUG && console.log("[ServerBridge] SW message:", type2, id, data2 == null ? void 0 : data2.url);
      if (type2 === "request") {
        const { port, method, url: url2, headers, body, streaming } = data2;
        ServerBridge.DEBUG && console.log("[ServerBridge] Handling request:", port, method, url2, "streaming:", streaming);
        if (streaming) {
          ServerBridge.DEBUG && console.log("[ServerBridge] \u{1F534} Will use streaming handler");
        }
        try {
          if (streaming) {
            await this.handleStreamingRequest(id, port, method, url2, headers, body);
          } else {
            const response = await this.handleRequest(port, method, url2, headers, body);
            ServerBridge.DEBUG && console.log("[ServerBridge] Response:", response.statusCode, "body length:", (_a2 = response.body) == null ? void 0 : _a2.length);
            let bodyBase64 = "";
            if (response.body && response.body.length > 0) {
              const bytes = response.body instanceof Uint8Array ? response.body : new Uint8Array(0);
              bodyBase64 = uint8ToBase64(bytes);
            }
            ServerBridge.DEBUG && console.log("[ServerBridge] Sending response to SW, body base64 length:", bodyBase64.length);
            (_b2 = this.messageChannel) == null ? void 0 : _b2.port1.postMessage({
              type: "response",
              id,
              data: {
                statusCode: response.statusCode,
                statusMessage: response.statusMessage,
                headers: response.headers,
                bodyBase64
              }
            });
          }
        } catch (error) {
          (_c2 = this.messageChannel) == null ? void 0 : _c2.port1.postMessage({
            type: "response",
            id,
            error: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    }
    async handleStreamingRequest(id, port, method, url2, headers, body) {
      var _a2, _b2, _c2, _d, _e;
      const virtualServer = this.servers.get(port);
      if (!virtualServer) {
        (_a2 = this.messageChannel) == null ? void 0 : _a2.port1.postMessage({
          type: "stream-start",
          id,
          data: {
            statusCode: 503,
            statusMessage: "Service Unavailable",
            headers: {}
          }
        });
        (_b2 = this.messageChannel) == null ? void 0 : _b2.port1.postMessage({
          type: "stream-end",
          id
        });
        return;
      }
      const server = virtualServer.server;
      if (typeof server.handleStreamingRequest === "function") {
        ServerBridge.DEBUG && console.log("[ServerBridge] \u{1F7E2} Server has streaming support, calling handleStreamingRequest");
        const bodyBuffer = body ? BufferPolyfill.from(new Uint8Array(body)) : void 0;
        await server.handleStreamingRequest(method, url2, headers, bodyBuffer, (statusCode, statusMessage, respHeaders) => {
          var _a3;
          ServerBridge.DEBUG && console.log("[ServerBridge] \u{1F7E2} onStart called, sending stream-start");
          (_a3 = this.messageChannel) == null ? void 0 : _a3.port1.postMessage({
            type: "stream-start",
            id,
            data: {
              statusCode,
              statusMessage,
              headers: respHeaders
            }
          });
        }, (chunk) => {
          var _a3;
          const bytes = typeof chunk === "string" ? _encoder.encode(chunk) : chunk;
          const chunkBase64 = uint8ToBase64(bytes);
          ServerBridge.DEBUG && console.log("[ServerBridge] \u{1F7E1} onChunk called, sending stream-chunk, size:", chunkBase64.length);
          (_a3 = this.messageChannel) == null ? void 0 : _a3.port1.postMessage({
            type: "stream-chunk",
            id,
            data: {
              chunkBase64
            }
          });
        }, () => {
          var _a3;
          ServerBridge.DEBUG && console.log("[ServerBridge] \u{1F7E2} onEnd called, sending stream-end");
          (_a3 = this.messageChannel) == null ? void 0 : _a3.port1.postMessage({
            type: "stream-end",
            id
          });
        });
      } else {
        const bodyBuffer = body ? BufferPolyfill.from(new Uint8Array(body)) : void 0;
        const response = await virtualServer.server.handleRequest(method, url2, headers, bodyBuffer);
        (_c2 = this.messageChannel) == null ? void 0 : _c2.port1.postMessage({
          type: "stream-start",
          id,
          data: {
            statusCode: response.statusCode,
            statusMessage: response.statusMessage,
            headers: response.headers
          }
        });
        if (response.body && response.body.length > 0) {
          const bytes = response.body instanceof Uint8Array ? response.body : new Uint8Array(0);
          (_d = this.messageChannel) == null ? void 0 : _d.port1.postMessage({
            type: "stream-chunk",
            id,
            data: {
              chunkBase64: uint8ToBase64(bytes)
            }
          });
        }
        (_e = this.messageChannel) == null ? void 0 : _e.port1.postMessage({
          type: "stream-end",
          id
        });
      }
    }
    notifyServiceWorker(type2, data2) {
      if (this.serviceWorkerReady && this.messageChannel) {
        this.messageChannel.port1.postMessage({
          type: type2,
          data: data2
        });
      }
    }
    createFetchHandler() {
      return async (request2) => {
        const url2 = new URL(request2.url);
        const match = url2.pathname.match(/^\/__virtual__\/(\d+)(\/.*)?$/);
        if (!match) {
          throw new Error("Not a virtual server request");
        }
        const port = parseInt(match[1], 10);
        const path2 = match[2] || "/";
        const headers = {};
        request2.headers.forEach((value2, key) => {
          headers[key] = value2;
        });
        let body;
        if (request2.method !== "GET" && request2.method !== "HEAD") {
          body = await request2.arrayBuffer();
        }
        const response = await this.handleRequest(port, request2.method, path2 + url2.search, headers, body);
        return new Response(response.body, {
          status: response.statusCode,
          statusText: response.statusMessage,
          headers: response.headers
        });
      };
    }
  }, __publicField(_c, "DEBUG", false), _c);
  let globalBridge = null;
  getServerBridge = function(options2) {
    if (!globalBridge) {
      globalBridge = new ServerBridge(options2);
    }
    return globalBridge;
  };
  resetServerBridge = function() {
    globalBridge = null;
  };
  const MIME_TYPES = {
    html: "text/html; charset=utf-8",
    htm: "text/html; charset=utf-8",
    css: "text/css; charset=utf-8",
    js: "application/javascript; charset=utf-8",
    mjs: "application/javascript; charset=utf-8",
    cjs: "application/javascript; charset=utf-8",
    jsx: "application/javascript; charset=utf-8",
    ts: "application/javascript; charset=utf-8",
    tsx: "application/javascript; charset=utf-8",
    json: "application/json; charset=utf-8",
    png: "image/png",
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    gif: "image/gif",
    svg: "image/svg+xml",
    ico: "image/x-icon",
    webp: "image/webp",
    woff: "font/woff",
    woff2: "font/woff2",
    ttf: "font/ttf",
    otf: "font/otf",
    eot: "application/vnd.ms-fontobject",
    mp3: "audio/mpeg",
    mp4: "video/mp4",
    webm: "video/webm",
    ogg: "audio/ogg",
    wav: "audio/wav",
    pdf: "application/pdf",
    xml: "application/xml",
    txt: "text/plain; charset=utf-8",
    md: "text/markdown; charset=utf-8",
    wasm: "application/wasm",
    map: "application/json"
  };
  DevServer = class extends EventEmitter {
    constructor(vfs2, options2) {
      super();
      __publicField(this, "vfs");
      __publicField(this, "port");
      __publicField(this, "root");
      __publicField(this, "running", false);
      this.vfs = vfs2;
      this.port = options2.port;
      this.root = options2.root || "/";
    }
    stop() {
      this.running = false;
      this.emit("close");
    }
    start() {
      this.running = true;
      this.startWatching();
      this.emit("listening", this.port);
    }
    isRunning() {
      return this.running;
    }
    getPort() {
      return this.port;
    }
    serveFile(filePath) {
      try {
        const normalizedPath = this.resolvePath(filePath);
        const content = this.vfs.readFileSync(normalizedPath);
        const buffer2 = typeof content === "string" ? BufferPolyfill.from(content) : BufferPolyfill.from(content);
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": this.getMimeType(filePath),
            "Content-Length": String(buffer2.length),
            "Cache-Control": "no-cache"
          },
          body: buffer2
        };
      } catch (error) {
        if (error.code === "ENOENT") {
          return this.notFound(filePath);
        }
        return this.serverError(error);
      }
    }
    resolvePath(urlPath) {
      let path2 = urlPath.split("?")[0].split("#")[0];
      if (!path2.startsWith("/")) {
        path2 = "/" + path2;
      }
      if (this.root !== "/") {
        path2 = this.root + path2;
      }
      return path2;
    }
    notFound(path2) {
      const body = `Not found: ${path2}`;
      return {
        statusCode: 404,
        statusMessage: "Not Found",
        headers: {
          "Content-Type": "text/plain; charset=utf-8",
          "Content-Length": String(BufferPolyfill.byteLength(body))
        },
        body: BufferPolyfill.from(body)
      };
    }
    serverError(error) {
      const message = error instanceof Error ? error.message : "Internal Server Error";
      const body = `Server Error: ${message}`;
      return {
        statusCode: 500,
        statusMessage: "Internal Server Error",
        headers: {
          "Content-Type": "text/plain; charset=utf-8",
          "Content-Length": String(BufferPolyfill.byteLength(body))
        },
        body: BufferPolyfill.from(body)
      };
    }
    redirect(location2, status = 302) {
      return {
        statusCode: status,
        statusMessage: status === 301 ? "Moved Permanently" : "Found",
        headers: {
          Location: location2,
          "Content-Type": "text/plain; charset=utf-8",
          "Content-Length": "0"
        },
        body: BufferPolyfill.from("")
      };
    }
    getMimeType(path2) {
      var _a2;
      const ext = ((_a2 = path2.split(".").pop()) == null ? void 0 : _a2.toLowerCase()) || "";
      return MIME_TYPES[ext] || "application/octet-stream";
    }
    exists(path2) {
      try {
        this.vfs.statSync(path2);
        return true;
      } catch {
        return false;
      }
    }
    isDirectory(path2) {
      try {
        return this.vfs.statSync(path2).isDirectory();
      } catch {
        return false;
      }
    }
    emitHMRUpdate(update) {
      this.emit("hmr-update", {
        ...update,
        timestamp: update.timestamp || Date.now()
      });
    }
  };
  var astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    7,
    9,
    32,
    4,
    318,
    1,
    80,
    3,
    71,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    3,
    0,
    158,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    68,
    8,
    2,
    0,
    3,
    0,
    2,
    3,
    2,
    4,
    2,
    0,
    15,
    1,
    83,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    7,
    19,
    58,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    343,
    9,
    54,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    10,
    1,
    2,
    0,
    49,
    6,
    4,
    4,
    14,
    10,
    5350,
    0,
    7,
    14,
    11465,
    27,
    2343,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    535,
    9,
    470,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4178,
    9,
    519,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    101,
    0,
    161,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    499,
    13,
    245,
    1,
    2,
    9,
    726,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
  ];
  var astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    4,
    51,
    13,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    39,
    27,
    10,
    22,
    251,
    41,
    7,
    1,
    17,
    2,
    60,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    20,
    1,
    64,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    31,
    9,
    2,
    0,
    3,
    0,
    2,
    37,
    2,
    0,
    26,
    0,
    2,
    0,
    45,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    200,
    32,
    32,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    16,
    0,
    2,
    12,
    2,
    33,
    125,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1071,
    18,
    5,
    26,
    3994,
    6,
    582,
    6842,
    29,
    1763,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    433,
    44,
    212,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    42,
    9,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    16,
    0,
    30,
    2,
    3,
    0,
    15,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    7,
    5,
    262,
    61,
    147,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    485,
    27,
    229,
    29,
    3,
    0,
    496,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4153,
    7,
    221,
    3,
    5761,
    15,
    7472,
    16,
    621,
    2467,
    541,
    1507,
    4938,
    6,
    4191
  ];
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };
  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
  var keywords$1 = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };
  var keywordRelationalOperator = /^in(stanceof)?$/;
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  function isInAstralSet(code2, set) {
    var pos = 65536;
    for (var i2 = 0; i2 < set.length; i2 += 2) {
      pos += set[i2];
      if (pos > code2) {
        return false;
      }
      pos += set[i2 + 1];
      if (pos >= code2) {
        return true;
      }
    }
    return false;
  }
  function isIdentifierStart$1(code2, astral) {
    if (code2 < 65) {
      return code2 === 36;
    }
    if (code2 < 91) {
      return true;
    }
    if (code2 < 97) {
      return code2 === 95;
    }
    if (code2 < 123) {
      return true;
    }
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
    }
    if (astral === false) {
      return false;
    }
    return isInAstralSet(code2, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code2, astral) {
    if (code2 < 48) {
      return code2 === 36;
    }
    if (code2 < 58) {
      return true;
    }
    if (code2 < 65) {
      return false;
    }
    if (code2 < 91) {
      return true;
    }
    if (code2 < 97) {
      return code2 === 95;
    }
    if (code2 < 123) {
      return true;
    }
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
    }
    if (astral === false) {
      return false;
    }
    return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
  }
  var TokenType = function TokenType2(label, conf) {
    if (conf === void 0) conf = {};
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };
  function binop(name2, prec) {
    return new TokenType(name2, {
      beforeExpr: true,
      binop: prec
    });
  }
  var beforeExpr = {
    beforeExpr: true
  }, startsExpr = {
    startsExpr: true
  };
  var keywords$2 = {};
  function kw(name2, options2) {
    if (options2 === void 0) options2 = {};
    options2.keyword = name2;
    return keywords$2[name2] = new TokenType(name2, options2);
  }
  var types$1 = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    privateId: new TokenType("privateId", startsExpr),
    eof: new TokenType("eof"),
    bracketL: new TokenType("[", {
      beforeExpr: true,
      startsExpr: true
    }),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {
      beforeExpr: true,
      startsExpr: true
    }),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {
      beforeExpr: true,
      startsExpr: true
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {
      beforeExpr: true,
      startsExpr: true
    }),
    eq: new TokenType("=", {
      beforeExpr: true,
      isAssign: true
    }),
    assign: new TokenType("_=", {
      beforeExpr: true,
      isAssign: true
    }),
    incDec: new TokenType("++/--", {
      prefix: true,
      postfix: true,
      startsExpr: true
    }),
    prefix: new TokenType("!/~", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr: true,
      binop: 9,
      prefix: true,
      startsExpr: true
    }),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {
      beforeExpr: true
    }),
    coalesce: binop("??", 1),
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {
      isLoop: true,
      beforeExpr: true
    }),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {
      isLoop: true
    }),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {
      isLoop: true
    }),
    _with: kw("with"),
    _new: kw("new", {
      beforeExpr: true,
      startsExpr: true
    }),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {
      beforeExpr: true,
      binop: 7
    }),
    _instanceof: kw("instanceof", {
      beforeExpr: true,
      binop: 7
    }),
    _typeof: kw("typeof", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    _void: kw("void", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    _delete: kw("delete", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    })
  };
  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code2) {
    return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
  }
  function nextLineBreak(code2, from, end) {
    if (end === void 0) end = code2.length;
    for (var i2 = from; i2 < end; i2++) {
      var next = code2.charCodeAt(i2);
      if (isNewLine(next)) {
        return i2 < end - 1 && next === 13 && code2.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
      }
    }
    return -1;
  }
  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  var ref = Object.prototype;
  var hasOwnProperty$4 = ref.hasOwnProperty;
  var toString = ref.toString;
  var hasOwn = Object.hasOwn || function(obj, propName) {
    return hasOwnProperty$4.call(obj, propName);
  };
  var isArray = Array.isArray || function(obj) {
    return toString.call(obj) === "[object Array]";
  };
  var regexpCache = /* @__PURE__ */ Object.create(null);
  function wordsRegexp(words) {
    return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
  }
  function codePointToString(code2) {
    if (code2 <= 65535) {
      return String.fromCharCode(code2);
    }
    code2 -= 65536;
    return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
  }
  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
  var Position = function Position2(line, col) {
    this.line = line;
    this.column = col;
  };
  Position.prototype.offset = function offset(n) {
    return new Position(this.line, this.column + n);
  };
  var SourceLocation = function SourceLocation2(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) {
      this.source = p.sourceFile;
    }
  };
  function getLineInfo(input, offset2) {
    for (var line = 1, cur = 0; ; ) {
      var nextBreak = nextLineBreak(input, cur, offset2);
      if (nextBreak < 0) {
        return new Position(line, offset2 - cur);
      }
      ++line;
      cur = nextBreak;
    }
  }
  var defaultOptions = {
    ecmaVersion: null,
    sourceType: "script",
    onInsertedSemicolon: null,
    onTrailingComma: null,
    allowReserved: null,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowAwaitOutsideFunction: null,
    allowSuperOutsideMethod: null,
    allowHashBang: false,
    checkPrivateFields: true,
    locations: false,
    onToken: null,
    onComment: null,
    ranges: false,
    program: null,
    sourceFile: null,
    directSourceFile: null,
    preserveParens: false
  };
  var warnedAboutEcmaVersion = false;
  function getOptions(opts) {
    var options2 = {};
    for (var opt in defaultOptions) {
      options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
    }
    if (options2.ecmaVersion === "latest") {
      options2.ecmaVersion = 1e8;
    } else if (options2.ecmaVersion == null) {
      if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
        warnedAboutEcmaVersion = true;
        console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
      }
      options2.ecmaVersion = 11;
    } else if (options2.ecmaVersion >= 2015) {
      options2.ecmaVersion -= 2009;
    }
    if (options2.allowReserved == null) {
      options2.allowReserved = options2.ecmaVersion < 5;
    }
    if (!opts || opts.allowHashBang == null) {
      options2.allowHashBang = options2.ecmaVersion >= 14;
    }
    if (isArray(options2.onToken)) {
      var tokens = options2.onToken;
      options2.onToken = function(token) {
        return tokens.push(token);
      };
    }
    if (isArray(options2.onComment)) {
      options2.onComment = pushComment(options2, options2.onComment);
    }
    return options2;
  }
  function pushComment(options2, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start,
        end
      };
      if (options2.locations) {
        comment.loc = new SourceLocation(this, startLoc, endLoc);
      }
      if (options2.ranges) {
        comment.range = [
          start,
          end
        ];
      }
      array.push(comment);
    };
  }
  var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
  }
  var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
  var Parser = function Parser2(options2, input, startPos) {
    this.options = options2 = getOptions(options2);
    this.sourceFile = options2.sourceFile;
    this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options2.allowReserved !== true) {
      reserved = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
      if (options2.sourceType === "module") {
        reserved += " await";
      }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);
    this.containsEsc = false;
    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }
    this.type = types$1.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;
    this.context = this.initialContext();
    this.exprAllowed = true;
    this.inModule = options2.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);
    this.potentialArrowAt = -1;
    this.potentialArrowInForAwait = false;
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    this.labels = [];
    this.undefinedExports = /* @__PURE__ */ Object.create(null);
    if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
      this.skipLineComment(2);
    }
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);
    this.regexpState = null;
    this.privateNameStack = [];
  };
  var prototypeAccessors = {
    inFunction: {
      configurable: true
    },
    inGenerator: {
      configurable: true
    },
    inAsync: {
      configurable: true
    },
    canAwait: {
      configurable: true
    },
    allowSuper: {
      configurable: true
    },
    allowDirectSuper: {
      configurable: true
    },
    treatFunctionsAsVar: {
      configurable: true
    },
    allowNewDotTarget: {
      configurable: true
    },
    inClassStaticBlock: {
      configurable: true
    }
  };
  Parser.prototype.parse = function parse2() {
    var node2 = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node2);
  };
  prototypeAccessors.inFunction.get = function() {
    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
  };
  prototypeAccessors.inGenerator.get = function() {
    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
  };
  prototypeAccessors.inAsync.get = function() {
    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
  };
  prototypeAccessors.canAwait.get = function() {
    for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
      var ref2 = this.scopeStack[i2];
      var flags = ref2.flags;
      if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
        return false;
      }
      if (flags & SCOPE_FUNCTION) {
        return (flags & SCOPE_ASYNC) > 0;
      }
    }
    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
  };
  prototypeAccessors.allowSuper.get = function() {
    var ref2 = this.currentThisScope();
    var flags = ref2.flags;
    return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
  };
  prototypeAccessors.allowDirectSuper.get = function() {
    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
  };
  prototypeAccessors.treatFunctionsAsVar.get = function() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  };
  prototypeAccessors.allowNewDotTarget.get = function() {
    for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
      var ref2 = this.scopeStack[i2];
      var flags = ref2.flags;
      if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
        return true;
      }
    }
    return false;
  };
  prototypeAccessors.inClassStaticBlock.get = function() {
    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
  };
  Parser.extend = function extend() {
    var plugins = [], len = arguments.length;
    while (len--) plugins[len] = arguments[len];
    var cls = this;
    for (var i2 = 0; i2 < plugins.length; i2++) {
      cls = plugins[i2](cls);
    }
    return cls;
  };
  Parser.parse = function parse2(input, options2) {
    return new this(options2, input).parse();
  };
  Parser.parseExpressionAt = function parseExpressionAt(input, pos, options2) {
    var parser = new this(options2, input, pos);
    parser.nextToken();
    return parser.parseExpression();
  };
  Parser.tokenizer = function tokenizer(input, options2) {
    return new this(options2, input);
  };
  Object.defineProperties(Parser.prototype, prototypeAccessors);
  var pp$9 = Parser.prototype;
  var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
  pp$9.strictDirective = function(start) {
    if (this.options.ecmaVersion < 5) {
      return false;
    }
    for (; ; ) {
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) {
        return false;
      }
      if ((match[1] || match[2]) === "use strict") {
        skipWhiteSpace.lastIndex = start + match[0].length;
        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
        var next = this.input.charAt(end);
        return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
      }
      start += match[0].length;
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";") {
        start++;
      }
    }
  };
  pp$9.eat = function(type2) {
    if (this.type === type2) {
      this.next();
      return true;
    } else {
      return false;
    }
  };
  pp$9.isContextual = function(name2) {
    return this.type === types$1.name && this.value === name2 && !this.containsEsc;
  };
  pp$9.eatContextual = function(name2) {
    if (!this.isContextual(name2)) {
      return false;
    }
    this.next();
    return true;
  };
  pp$9.expectContextual = function(name2) {
    if (!this.eatContextual(name2)) {
      this.unexpected();
    }
  };
  pp$9.canInsertSemicolon = function() {
    return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  };
  pp$9.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon) {
        this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
      }
      return true;
    }
  };
  pp$9.semicolon = function() {
    if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
      this.unexpected();
    }
  };
  pp$9.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma) {
        this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
      }
      if (!notNext) {
        this.next();
      }
      return true;
    }
  };
  pp$9.expect = function(type2) {
    this.eat(type2) || this.unexpected();
  };
  pp$9.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };
  var DestructuringErrors = function DestructuringErrors2() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  };
  pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) {
      return;
    }
    if (refDestructuringErrors.trailingComma > -1) {
      this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
    }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) {
      this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
    }
  };
  pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) {
      return false;
    }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) {
      return shorthandAssign >= 0 || doubleProto >= 0;
    }
    if (shorthandAssign >= 0) {
      this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
    }
    if (doubleProto >= 0) {
      this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
    }
  };
  pp$9.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
      this.raise(this.yieldPos, "Yield expression cannot be a default value");
    }
    if (this.awaitPos) {
      this.raise(this.awaitPos, "Await expression cannot be a default value");
    }
  };
  pp$9.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression") {
      return this.isSimpleAssignTarget(expr.expression);
    }
    return expr.type === "Identifier" || expr.type === "MemberExpression";
  };
  var pp$8 = Parser.prototype;
  pp$8.parseTopLevel = function(node2) {
    var exports$1 = /* @__PURE__ */ Object.create(null);
    if (!node2.body) {
      node2.body = [];
    }
    while (this.type !== types$1.eof) {
      var stmt = this.parseStatement(null, true, exports$1);
      node2.body.push(stmt);
    }
    if (this.inModule) {
      for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
        var name2 = list2[i2];
        this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
      }
    }
    this.adaptDirectivePrologue(node2.body);
    this.next();
    node2.sourceType = this.options.sourceType;
    return this.finishNode(node2, "Program");
  };
  var loopLabel = {
    kind: "loop"
  }, switchLabel = {
    kind: "switch"
  };
  pp$8.isLet = function(context2) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
      return false;
    }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 91 || nextCh === 92) {
      return true;
    }
    if (context2) {
      return false;
    }
    if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    if (isIdentifierStart$1(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
        ++pos;
      }
      if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
        return true;
      }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) {
        return true;
      }
    }
    return false;
  };
  pp$8.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
      return false;
    }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, after;
    return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
  };
  pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
    if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
      return false;
    }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    if (lineBreak.test(this.input.slice(this.pos, next))) {
      return false;
    }
    if (isAwaitUsing) {
      var awaitEndPos = next + 5, after;
      if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
        return false;
      }
      skipWhiteSpace.lastIndex = awaitEndPos;
      var skipAfterUsing = skipWhiteSpace.exec(this.input);
      if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
        return false;
      }
    }
    if (isFor) {
      var ofEndPos = next + 2, after$1;
      if (this.input.slice(next, ofEndPos) === "of") {
        if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
          return false;
        }
      }
    }
    var ch = this.input.charCodeAt(next);
    return isIdentifierStart$1(ch, true) || ch === 92;
  };
  pp$8.isAwaitUsing = function(isFor) {
    return this.isUsingKeyword(true, isFor);
  };
  pp$8.isUsing = function(isFor) {
    return this.isUsingKeyword(false, isFor);
  };
  pp$8.parseStatement = function(context2, topLevel, exports$1) {
    var starttype = this.type, node2 = this.startNode(), kind;
    if (this.isLet(context2)) {
      starttype = types$1._var;
      kind = "let";
    }
    switch (starttype) {
      case types$1._break:
      case types$1._continue:
        return this.parseBreakContinueStatement(node2, starttype.keyword);
      case types$1._debugger:
        return this.parseDebuggerStatement(node2);
      case types$1._do:
        return this.parseDoStatement(node2);
      case types$1._for:
        return this.parseForStatement(node2);
      case types$1._function:
        if (context2 && (this.strict || context2 !== "if" && context2 !== "label") && this.options.ecmaVersion >= 6) {
          this.unexpected();
        }
        return this.parseFunctionStatement(node2, false, !context2);
      case types$1._class:
        if (context2) {
          this.unexpected();
        }
        return this.parseClass(node2, true);
      case types$1._if:
        return this.parseIfStatement(node2);
      case types$1._return:
        return this.parseReturnStatement(node2);
      case types$1._switch:
        return this.parseSwitchStatement(node2);
      case types$1._throw:
        return this.parseThrowStatement(node2);
      case types$1._try:
        return this.parseTryStatement(node2);
      case types$1._const:
      case types$1._var:
        kind = kind || this.value;
        if (context2 && kind !== "var") {
          this.unexpected();
        }
        return this.parseVarStatement(node2, kind);
      case types$1._while:
        return this.parseWhileStatement(node2);
      case types$1._with:
        return this.parseWithStatement(node2);
      case types$1.braceL:
        return this.parseBlock(true, node2);
      case types$1.semi:
        return this.parseEmptyStatement(node2);
      case types$1._export:
      case types$1._import:
        if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
          if (nextCh === 40 || nextCh === 46) {
            return this.parseExpressionStatement(node2, this.parseExpression());
          }
        }
        if (!this.options.allowImportExportEverywhere) {
          if (!topLevel) {
            this.raise(this.start, "'import' and 'export' may only appear at the top level");
          }
          if (!this.inModule) {
            this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
          }
        }
        return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports$1);
      default:
        if (this.isAsyncFunction()) {
          if (context2) {
            this.unexpected();
          }
          this.next();
          return this.parseFunctionStatement(node2, true, !context2);
        }
        var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
        if (usingKind) {
          if (topLevel && this.options.sourceType === "script") {
            this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
          }
          if (usingKind === "await using") {
            if (!this.canAwait) {
              this.raise(this.start, "Await using cannot appear outside of async function");
            }
            this.next();
          }
          this.next();
          this.parseVar(node2, false, usingKind);
          this.semicolon();
          return this.finishNode(node2, "VariableDeclaration");
        }
        var maybeName = this.value, expr = this.parseExpression();
        if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
          return this.parseLabeledStatement(node2, maybeName, expr, context2);
        } else {
          return this.parseExpressionStatement(node2, expr);
        }
    }
  };
  pp$8.parseBreakContinueStatement = function(node2, keyword2) {
    var isBreak = keyword2 === "break";
    this.next();
    if (this.eat(types$1.semi) || this.insertSemicolon()) {
      node2.label = null;
    } else if (this.type !== types$1.name) {
      this.unexpected();
    } else {
      node2.label = this.parseIdent();
      this.semicolon();
    }
    var i2 = 0;
    for (; i2 < this.labels.length; ++i2) {
      var lab = this.labels[i2];
      if (node2.label == null || lab.name === node2.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) {
          break;
        }
        if (node2.label && isBreak) {
          break;
        }
      }
    }
    if (i2 === this.labels.length) {
      this.raise(node2.start, "Unsyntactic " + keyword2);
    }
    return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
  };
  pp$8.parseDebuggerStatement = function(node2) {
    this.next();
    this.semicolon();
    return this.finishNode(node2, "DebuggerStatement");
  };
  pp$8.parseDoStatement = function(node2) {
    this.next();
    this.labels.push(loopLabel);
    node2.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types$1._while);
    node2.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6) {
      this.eat(types$1.semi);
    } else {
      this.semicolon();
    }
    return this.finishNode(node2, "DoWhileStatement");
  };
  pp$8.parseForStatement = function(node2) {
    this.next();
    var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types$1.parenL);
    if (this.type === types$1.semi) {
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node2, null);
    }
    var isLet = this.isLet();
    if (this.type === types$1._var || this.type === types$1._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      return this.parseForAfterInit(node2, init$1, awaitAt);
    }
    var startsWithLet = this.isContextual("let"), isForOf = false;
    var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
    if (usingKind) {
      var init$2 = this.startNode();
      this.next();
      if (usingKind === "await using") {
        this.next();
      }
      this.parseVar(init$2, true, usingKind);
      this.finishNode(init$2, "VariableDeclaration");
      return this.parseForAfterInit(node2, init$2, awaitAt);
    }
    var containsEsc = this.containsEsc;
    var refDestructuringErrors = new DestructuringErrors();
    var initPos = this.start;
    var init2 = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (awaitAt > -1) {
        if (this.type === types$1._in) {
          this.unexpected(awaitAt);
        }
        node2.await = true;
      } else if (isForOf && this.options.ecmaVersion >= 8) {
        if (init2.start === initPos && !containsEsc && init2.type === "Identifier" && init2.name === "async") {
          this.unexpected();
        } else if (this.options.ecmaVersion >= 9) {
          node2.await = false;
        }
      }
      if (startsWithLet && isForOf) {
        this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
      }
      this.toAssignable(init2, false, refDestructuringErrors);
      this.checkLValPattern(init2);
      return this.parseForIn(node2, init2);
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, init2);
  };
  pp$8.parseForAfterInit = function(node2, init2, awaitAt) {
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init2.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node2.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node2, init2);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, init2);
  };
  pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
  };
  pp$8.parseIfStatement = function(node2) {
    this.next();
    node2.test = this.parseParenExpression();
    node2.consequent = this.parseStatement("if");
    node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
    return this.finishNode(node2, "IfStatement");
  };
  pp$8.parseReturnStatement = function(node2) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
      this.raise(this.start, "'return' outside of function");
    }
    this.next();
    if (this.eat(types$1.semi) || this.insertSemicolon()) {
      node2.argument = null;
    } else {
      node2.argument = this.parseExpression();
      this.semicolon();
    }
    return this.finishNode(node2, "ReturnStatement");
  };
  pp$8.parseSwitchStatement = function(node2) {
    this.next();
    node2.discriminant = this.parseParenExpression();
    node2.cases = [];
    this.expect(types$1.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);
    var cur;
    for (var sawDefault = false; this.type !== types$1.braceR; ) {
      if (this.type === types$1._case || this.type === types$1._default) {
        var isCase = this.type === types$1._case;
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        node2.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) {
            this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
          }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types$1.colon);
      } else {
        if (!cur) {
          this.unexpected();
        }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) {
      this.finishNode(cur, "SwitchCase");
    }
    this.next();
    this.labels.pop();
    return this.finishNode(node2, "SwitchStatement");
  };
  pp$8.parseThrowStatement = function(node2) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
      this.raise(this.lastTokEnd, "Illegal newline after throw");
    }
    node2.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node2, "ThrowStatement");
  };
  var empty$1 = [];
  pp$8.parseCatchClauseParam = function() {
    var param = this.parseBindingAtom();
    var simple = param.type === "Identifier";
    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
    this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
    this.expect(types$1.parenR);
    return param;
  };
  pp$8.parseTryStatement = function(node2) {
    this.next();
    node2.block = this.parseBlock();
    node2.handler = null;
    if (this.type === types$1._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types$1.parenL)) {
        clause.param = this.parseCatchClauseParam();
      } else {
        if (this.options.ecmaVersion < 10) {
          this.unexpected();
        }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node2.handler = this.finishNode(clause, "CatchClause");
    }
    node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
    if (!node2.handler && !node2.finalizer) {
      this.raise(node2.start, "Missing catch or finally clause");
    }
    return this.finishNode(node2, "TryStatement");
  };
  pp$8.parseVarStatement = function(node2, kind, allowMissingInitializer) {
    this.next();
    this.parseVar(node2, false, kind, allowMissingInitializer);
    this.semicolon();
    return this.finishNode(node2, "VariableDeclaration");
  };
  pp$8.parseWhileStatement = function(node2) {
    this.next();
    node2.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node2.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node2, "WhileStatement");
  };
  pp$8.parseWithStatement = function(node2) {
    if (this.strict) {
      this.raise(this.start, "'with' in strict mode");
    }
    this.next();
    node2.object = this.parseParenExpression();
    node2.body = this.parseStatement("with");
    return this.finishNode(node2, "WithStatement");
  };
  pp$8.parseEmptyStatement = function(node2) {
    this.next();
    return this.finishNode(node2, "EmptyStatement");
  };
  pp$8.parseLabeledStatement = function(node2, maybeName, expr, context2) {
    for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
      var label = list2[i$1];
      if (label.name === maybeName) {
        this.raise(expr.start, "Label '" + maybeName + "' is already declared");
      }
    }
    var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
    for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
      var label$1 = this.labels[i2];
      if (label$1.statementStart === node2.start) {
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else {
        break;
      }
    }
    this.labels.push({
      name: maybeName,
      kind,
      statementStart: this.start
    });
    node2.body = this.parseStatement(context2 ? context2.indexOf("label") === -1 ? context2 + "label" : context2 : "label");
    this.labels.pop();
    node2.label = expr;
    return this.finishNode(node2, "LabeledStatement");
  };
  pp$8.parseExpressionStatement = function(node2, expr) {
    node2.expression = expr;
    this.semicolon();
    return this.finishNode(node2, "ExpressionStatement");
  };
  pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
    if (createNewLexicalScope === void 0) createNewLexicalScope = true;
    if (node2 === void 0) node2 = this.startNode();
    node2.body = [];
    this.expect(types$1.braceL);
    if (createNewLexicalScope) {
      this.enterScope(0);
    }
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node2.body.push(stmt);
    }
    if (exitStrict) {
      this.strict = false;
    }
    this.next();
    if (createNewLexicalScope) {
      this.exitScope();
    }
    return this.finishNode(node2, "BlockStatement");
  };
  pp$8.parseFor = function(node2, init2) {
    node2.init = init2;
    this.expect(types$1.semi);
    node2.test = this.type === types$1.semi ? null : this.parseExpression();
    this.expect(types$1.semi);
    node2.update = this.type === types$1.parenR ? null : this.parseExpression();
    this.expect(types$1.parenR);
    node2.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node2, "ForStatement");
  };
  pp$8.parseForIn = function(node2, init2) {
    var isForIn = this.type === types$1._in;
    this.next();
    if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
      this.raise(init2.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
    }
    node2.left = init2;
    node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types$1.parenR);
    node2.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
  };
  pp$8.parseVar = function(node2, isFor, kind, allowMissingInitializer) {
    node2.declarations = [];
    node2.kind = kind;
    for (; ; ) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types$1.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        this.unexpected();
      } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
        this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
      } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types$1.comma)) {
        break;
      }
    }
    return node2;
  };
  pp$8.parseVarId = function(decl, kind) {
    decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
    this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };
  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
  pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
    this.initFunction(node2);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
        this.unexpected();
      }
      node2.generator = this.eat(types$1.star);
    }
    if (this.options.ecmaVersion >= 8) {
      node2.async = !!isAsync;
    }
    if (statement & FUNC_STATEMENT) {
      node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
      if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
        this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
      }
    }
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node2.async, node2.generator));
    if (!(statement & FUNC_STATEMENT)) {
      node2.id = this.type === types$1.name ? this.parseIdent() : null;
    }
    this.parseFunctionParams(node2);
    this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
  };
  pp$8.parseFunctionParams = function(node2) {
    this.expect(types$1.parenL);
    node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };
  pp$8.parseClass = function(node2, isStatement) {
    this.next();
    var oldStrict = this.strict;
    this.strict = true;
    this.parseClassId(node2, isStatement);
    this.parseClassSuper(node2);
    var privateNameMap = this.enterClassBody();
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types$1.braceL);
    while (this.type !== types$1.braceR) {
      var element = this.parseClassElement(node2.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) {
            this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
          }
          hadConstructor = true;
        } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
          this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
        }
      }
    }
    this.strict = oldStrict;
    this.next();
    node2.body = this.finishNode(classBody, "ClassBody");
    this.exitClassBody();
    return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
  };
  pp$8.parseClassElement = function(constructorAllowsSuper) {
    if (this.eat(types$1.semi)) {
      return null;
    }
    var ecmaVersion2 = this.options.ecmaVersion;
    var node2 = this.startNode();
    var keyName = "";
    var isGenerator = false;
    var isAsync = false;
    var kind = "method";
    var isStatic = false;
    if (this.eatContextual("static")) {
      if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
        this.parseClassStaticBlock(node2);
        return node2;
      }
      if (this.isClassElementNameStart() || this.type === types$1.star) {
        isStatic = true;
      } else {
        keyName = "static";
      }
    }
    node2.static = isStatic;
    if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
      if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
        isAsync = true;
      } else {
        keyName = "async";
      }
    }
    if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
      isGenerator = true;
    }
    if (!keyName && !isAsync && !isGenerator) {
      var lastValue = this.value;
      if (this.eatContextual("get") || this.eatContextual("set")) {
        if (this.isClassElementNameStart()) {
          kind = lastValue;
        } else {
          keyName = lastValue;
        }
      }
    }
    if (keyName) {
      node2.computed = false;
      node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
      node2.key.name = keyName;
      this.finishNode(node2.key, "Identifier");
    } else {
      this.parseClassElementName(node2);
    }
    if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
      var isConstructor = !node2.static && checkKeyName(node2, "constructor");
      var allowsDirectSuper = isConstructor && constructorAllowsSuper;
      if (isConstructor && kind !== "method") {
        this.raise(node2.key.start, "Constructor can't have get/set modifier");
      }
      node2.kind = isConstructor ? "constructor" : kind;
      this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
    } else {
      this.parseClassField(node2);
    }
    return node2;
  };
  pp$8.isClassElementNameStart = function() {
    return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
  };
  pp$8.parseClassElementName = function(element) {
    if (this.type === types$1.privateId) {
      if (this.value === "constructor") {
        this.raise(this.start, "Classes can't have an element named '#constructor'");
      }
      element.computed = false;
      element.key = this.parsePrivateIdent();
    } else {
      this.parsePropertyName(element);
    }
  };
  pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    var key = method.key;
    if (method.kind === "constructor") {
      if (isGenerator) {
        this.raise(key.start, "Constructor can't be a generator");
      }
      if (isAsync) {
        this.raise(key.start, "Constructor can't be an async method");
      }
    } else if (method.static && checkKeyName(method, "prototype")) {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && value2.params.length !== 0) {
      this.raiseRecoverable(value2.start, "getter should have no params");
    }
    if (method.kind === "set" && value2.params.length !== 1) {
      this.raiseRecoverable(value2.start, "setter should have exactly one param");
    }
    if (method.kind === "set" && value2.params[0].type === "RestElement") {
      this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
    }
    return this.finishNode(method, "MethodDefinition");
  };
  pp$8.parseClassField = function(field) {
    if (checkKeyName(field, "constructor")) {
      this.raise(field.key.start, "Classes can't have a field named 'constructor'");
    } else if (field.static && checkKeyName(field, "prototype")) {
      this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
    }
    if (this.eat(types$1.eq)) {
      this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
      field.value = this.parseMaybeAssign();
      this.exitScope();
    } else {
      field.value = null;
    }
    this.semicolon();
    return this.finishNode(field, "PropertyDefinition");
  };
  pp$8.parseClassStaticBlock = function(node2) {
    node2.body = [];
    var oldLabels = this.labels;
    this.labels = [];
    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node2.body.push(stmt);
    }
    this.next();
    this.exitScope();
    this.labels = oldLabels;
    return this.finishNode(node2, "StaticBlock");
  };
  pp$8.parseClassId = function(node2, isStatement) {
    if (this.type === types$1.name) {
      node2.id = this.parseIdent();
      if (isStatement) {
        this.checkLValSimple(node2.id, BIND_LEXICAL, false);
      }
    } else {
      if (isStatement === true) {
        this.unexpected();
      }
      node2.id = null;
    }
  };
  pp$8.parseClassSuper = function(node2) {
    node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
  };
  pp$8.enterClassBody = function() {
    var element = {
      declared: /* @__PURE__ */ Object.create(null),
      used: []
    };
    this.privateNameStack.push(element);
    return element.declared;
  };
  pp$8.exitClassBody = function() {
    var ref2 = this.privateNameStack.pop();
    var declared = ref2.declared;
    var used = ref2.used;
    if (!this.options.checkPrivateFields) {
      return;
    }
    var len = this.privateNameStack.length;
    var parent = len === 0 ? null : this.privateNameStack[len - 1];
    for (var i2 = 0; i2 < used.length; ++i2) {
      var id = used[i2];
      if (!hasOwn(declared, id.name)) {
        if (parent) {
          parent.used.push(id);
        } else {
          this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
        }
      }
    }
  };
  function isPrivateNameConflicted(privateNameMap, element) {
    var name2 = element.key.name;
    var curr = privateNameMap[name2];
    var next = "true";
    if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
      next = (element.static ? "s" : "i") + element.kind;
    }
    if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
      privateNameMap[name2] = "true";
      return false;
    } else if (!curr) {
      privateNameMap[name2] = next;
      return false;
    } else {
      return true;
    }
  }
  function checkKeyName(node2, name2) {
    var computed = node2.computed;
    var key = node2.key;
    return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
  }
  pp$8.parseExportAllDeclaration = function(node2, exports$1) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node2.exported = this.parseModuleExportName();
        this.checkExport(exports$1, node2.exported, this.lastTokStart);
      } else {
        node2.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node2.source = this.parseExprAtom();
    if (this.options.ecmaVersion >= 16) {
      node2.attributes = this.parseWithClause();
    }
    this.semicolon();
    return this.finishNode(node2, "ExportAllDeclaration");
  };
  pp$8.parseExport = function(node2, exports$1) {
    this.next();
    if (this.eat(types$1.star)) {
      return this.parseExportAllDeclaration(node2, exports$1);
    }
    if (this.eat(types$1._default)) {
      this.checkExport(exports$1, "default", this.lastTokStart);
      node2.declaration = this.parseExportDefaultDeclaration();
      return this.finishNode(node2, "ExportDefaultDeclaration");
    }
    if (this.shouldParseExportStatement()) {
      node2.declaration = this.parseExportDeclaration(node2);
      if (node2.declaration.type === "VariableDeclaration") {
        this.checkVariableExport(exports$1, node2.declaration.declarations);
      } else {
        this.checkExport(exports$1, node2.declaration.id, node2.declaration.id.start);
      }
      node2.specifiers = [];
      node2.source = null;
      if (this.options.ecmaVersion >= 16) {
        node2.attributes = [];
      }
    } else {
      node2.declaration = null;
      node2.specifiers = this.parseExportSpecifiers(exports$1);
      if (this.eatContextual("from")) {
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node2.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16) {
          node2.attributes = this.parseWithClause();
        }
      } else {
        for (var i2 = 0, list2 = node2.specifiers; i2 < list2.length; i2 += 1) {
          var spec2 = list2[i2];
          this.checkUnreserved(spec2.local);
          this.checkLocalExport(spec2.local);
          if (spec2.local.type === "Literal") {
            this.raise(spec2.local.start, "A string literal cannot be used as an exported binding without `from`.");
          }
        }
        node2.source = null;
        if (this.options.ecmaVersion >= 16) {
          node2.attributes = [];
        }
      }
      this.semicolon();
    }
    return this.finishNode(node2, "ExportNamedDeclaration");
  };
  pp$8.parseExportDeclaration = function(node2) {
    return this.parseStatement(null);
  };
  pp$8.parseExportDefaultDeclaration = function() {
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) {
        this.next();
      }
      return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      return this.parseClass(cNode, "nullableID");
    } else {
      var declaration = this.parseMaybeAssign();
      this.semicolon();
      return declaration;
    }
  };
  pp$8.checkExport = function(exports$1, name2, pos) {
    if (!exports$1) {
      return;
    }
    if (typeof name2 !== "string") {
      name2 = name2.type === "Identifier" ? name2.name : name2.value;
    }
    if (hasOwn(exports$1, name2)) {
      this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
    }
    exports$1[name2] = true;
  };
  pp$8.checkPatternExport = function(exports$1, pat) {
    var type2 = pat.type;
    if (type2 === "Identifier") {
      this.checkExport(exports$1, pat, pat.start);
    } else if (type2 === "ObjectPattern") {
      for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
        var prop = list2[i2];
        this.checkPatternExport(exports$1, prop);
      }
    } else if (type2 === "ArrayPattern") {
      for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];
        if (elt) {
          this.checkPatternExport(exports$1, elt);
        }
      }
    } else if (type2 === "Property") {
      this.checkPatternExport(exports$1, pat.value);
    } else if (type2 === "AssignmentPattern") {
      this.checkPatternExport(exports$1, pat.left);
    } else if (type2 === "RestElement") {
      this.checkPatternExport(exports$1, pat.argument);
    }
  };
  pp$8.checkVariableExport = function(exports$1, decls) {
    if (!exports$1) {
      return;
    }
    for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
      var decl = list2[i2];
      this.checkPatternExport(exports$1, decl.id);
    }
  };
  pp$8.shouldParseExportStatement = function() {
    return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
  };
  pp$8.parseExportSpecifier = function(exports$1) {
    var node2 = this.startNode();
    node2.local = this.parseModuleExportName();
    node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
    this.checkExport(exports$1, node2.exported, node2.exported.start);
    return this.finishNode(node2, "ExportSpecifier");
  };
  pp$8.parseExportSpecifiers = function(exports$1) {
    var nodes = [], first = true;
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      nodes.push(this.parseExportSpecifier(exports$1));
    }
    return nodes;
  };
  pp$8.parseImport = function(node2) {
    this.next();
    if (this.type === types$1.string) {
      node2.specifiers = empty$1;
      node2.source = this.parseExprAtom();
    } else {
      node2.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
    }
    if (this.options.ecmaVersion >= 16) {
      node2.attributes = this.parseWithClause();
    }
    this.semicolon();
    return this.finishNode(node2, "ImportDeclaration");
  };
  pp$8.parseImportSpecifier = function() {
    var node2 = this.startNode();
    node2.imported = this.parseModuleExportName();
    if (this.eatContextual("as")) {
      node2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node2.imported);
      node2.local = node2.imported;
    }
    this.checkLValSimple(node2.local, BIND_LEXICAL);
    return this.finishNode(node2, "ImportSpecifier");
  };
  pp$8.parseImportDefaultSpecifier = function() {
    var node2 = this.startNode();
    node2.local = this.parseIdent();
    this.checkLValSimple(node2.local, BIND_LEXICAL);
    return this.finishNode(node2, "ImportDefaultSpecifier");
  };
  pp$8.parseImportNamespaceSpecifier = function() {
    var node2 = this.startNode();
    this.next();
    this.expectContextual("as");
    node2.local = this.parseIdent();
    this.checkLValSimple(node2.local, BIND_LEXICAL);
    return this.finishNode(node2, "ImportNamespaceSpecifier");
  };
  pp$8.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types$1.name) {
      nodes.push(this.parseImportDefaultSpecifier());
      if (!this.eat(types$1.comma)) {
        return nodes;
      }
    }
    if (this.type === types$1.star) {
      nodes.push(this.parseImportNamespaceSpecifier());
      return nodes;
    }
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      nodes.push(this.parseImportSpecifier());
    }
    return nodes;
  };
  pp$8.parseWithClause = function() {
    var nodes = [];
    if (!this.eat(types$1._with)) {
      return nodes;
    }
    this.expect(types$1.braceL);
    var attributeKeys = {};
    var first = true;
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      var attr = this.parseImportAttribute();
      var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
      if (hasOwn(attributeKeys, keyName)) {
        this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
      }
      attributeKeys[keyName] = true;
      nodes.push(attr);
    }
    return nodes;
  };
  pp$8.parseImportAttribute = function() {
    var node2 = this.startNode();
    node2.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    this.expect(types$1.colon);
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node2.value = this.parseExprAtom();
    return this.finishNode(node2, "ImportAttribute");
  };
  pp$8.parseModuleExportName = function() {
    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
      var stringLiteral = this.parseLiteral(this.value);
      if (loneSurrogate.test(stringLiteral.value)) {
        this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
      }
      return stringLiteral;
    }
    return this.parseIdent(true);
  };
  pp$8.adaptDirectivePrologue = function(statements) {
    for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
      statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
    }
  };
  pp$8.isDirectiveCandidate = function(statement) {
    return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
  };
  var pp$7 = Parser.prototype;
  pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node2) {
      switch (node2.type) {
        case "Identifier":
          if (this.inAsync && node2.name === "await") {
            this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
          }
          break;
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          node2.type = "ObjectPattern";
          if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
          }
          for (var i2 = 0, list2 = node2.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.toAssignable(prop, isBinding);
            if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
              this.raise(prop.argument.start, "Unexpected token");
            }
          }
          break;
        case "Property":
          if (node2.kind !== "init") {
            this.raise(node2.key.start, "Object pattern can't contain getter or setter");
          }
          this.toAssignable(node2.value, isBinding);
          break;
        case "ArrayExpression":
          node2.type = "ArrayPattern";
          if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
          }
          this.toAssignableList(node2.elements, isBinding);
          break;
        case "SpreadElement":
          node2.type = "RestElement";
          this.toAssignable(node2.argument, isBinding);
          if (node2.argument.type === "AssignmentPattern") {
            this.raise(node2.argument.start, "Rest elements cannot have a default value");
          }
          break;
        case "AssignmentExpression":
          if (node2.operator !== "=") {
            this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
          }
          node2.type = "AssignmentPattern";
          delete node2.operator;
          this.toAssignable(node2.left, isBinding);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
          break;
        case "ChainExpression":
          this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (!isBinding) {
            break;
          }
        default:
          this.raise(node2.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) {
      this.checkPatternErrors(refDestructuringErrors, true);
    }
    return node2;
  };
  pp$7.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i2 = 0; i2 < end; i2++) {
      var elt = exprList[i2];
      if (elt) {
        this.toAssignable(elt, isBinding);
      }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
        this.unexpected(last.argument.start);
      }
    }
    return exprList;
  };
  pp$7.parseSpread = function(refDestructuringErrors) {
    var node2 = this.startNode();
    this.next();
    node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node2, "SpreadElement");
  };
  pp$7.parseRestBinding = function() {
    var node2 = this.startNode();
    this.next();
    if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
      this.unexpected();
    }
    node2.argument = this.parseBindingAtom();
    return this.finishNode(node2, "RestElement");
  };
  pp$7.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
        case types$1.bracketL:
          var node2 = this.startNode();
          this.next();
          node2.elements = this.parseBindingList(types$1.bracketR, true, true);
          return this.finishNode(node2, "ArrayPattern");
        case types$1.braceL:
          return this.parseObj(true);
      }
    }
    return this.parseIdent();
  };
  pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
    var elts = [], first = true;
    while (!this.eat(close2)) {
      if (first) {
        first = false;
      } else {
        this.expect(types$1.comma);
      }
      if (allowEmpty && this.type === types$1.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      } else if (this.type === types$1.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types$1.comma) {
          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        }
        this.expect(close2);
        break;
      } else {
        elts.push(this.parseAssignableListItem(allowModifiers));
      }
    }
    return elts;
  };
  pp$7.parseAssignableListItem = function(allowModifiers) {
    var elem = this.parseMaybeDefault(this.start, this.startLoc);
    this.parseBindingListItem(elem);
    return elem;
  };
  pp$7.parseBindingListItem = function(param) {
    return param;
  };
  pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
      return left;
    }
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.left = left;
    node2.right = this.parseMaybeAssign();
    return this.finishNode(node2, "AssignmentPattern");
  };
  pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0) bindingType = BIND_NONE;
    var isBind = bindingType !== BIND_NONE;
    switch (expr.type) {
      case "Identifier":
        if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
          this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
        }
        if (isBind) {
          if (bindingType === BIND_LEXICAL && expr.name === "let") {
            this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
          }
          if (checkClashes) {
            if (hasOwn(checkClashes, expr.name)) {
              this.raiseRecoverable(expr.start, "Argument name clash");
            }
            checkClashes[expr.name] = true;
          }
          if (bindingType !== BIND_OUTSIDE) {
            this.declareName(expr.name, bindingType, expr.start);
          }
        }
        break;
      case "ChainExpression":
        this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (isBind) {
          this.raiseRecoverable(expr.start, "Binding member expression");
        }
        break;
      case "ParenthesizedExpression":
        if (isBind) {
          this.raiseRecoverable(expr.start, "Binding parenthesized expression");
        }
        return this.checkLValSimple(expr.expression, bindingType, checkClashes);
      default:
        this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
    }
  };
  pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0) bindingType = BIND_NONE;
    switch (expr.type) {
      case "ObjectPattern":
        for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
          var prop = list2[i2];
          this.checkLValInnerPattern(prop, bindingType, checkClashes);
        }
        break;
      case "ArrayPattern":
        for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
          var elem = list$1[i$1];
          if (elem) {
            this.checkLValInnerPattern(elem, bindingType, checkClashes);
          }
        }
        break;
      default:
        this.checkLValSimple(expr, bindingType, checkClashes);
    }
  };
  pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0) bindingType = BIND_NONE;
    switch (expr.type) {
      case "Property":
        this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
        break;
      case "AssignmentPattern":
        this.checkLValPattern(expr.left, bindingType, checkClashes);
        break;
      case "RestElement":
        this.checkLValPattern(expr.argument, bindingType, checkClashes);
        break;
      default:
        this.checkLValPattern(expr, bindingType, checkClashes);
    }
  };
  var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };
  var types = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function(p) {
      return p.tryReadTemplateToken();
    }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };
  var pp$6 = Parser.prototype;
  pp$6.initialContext = function() {
    return [
      types.b_stat
    ];
  };
  pp$6.curContext = function() {
    return this.context[this.context.length - 1];
  };
  pp$6.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types.f_expr || parent === types.f_stat) {
      return true;
    }
    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
      return !parent.isExpr;
    }
    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
      return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    }
    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
      return true;
    }
    if (prevType === types$1.braceL) {
      return parent === types.b_stat;
    }
    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
      return false;
    }
    return !this.exprAllowed;
  };
  pp$6.inGeneratorContext = function() {
    for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
      var context2 = this.context[i2];
      if (context2.token === "function") {
        return context2.generator;
      }
    }
    return false;
  };
  pp$6.updateContext = function(prevType) {
    var update, type2 = this.type;
    if (type2.keyword && prevType === types$1.dot) {
      this.exprAllowed = false;
    } else if (update = type2.updateContext) {
      update.call(this, prevType);
    } else {
      this.exprAllowed = type2.beforeExpr;
    }
  };
  pp$6.overrideContext = function(tokenCtx) {
    if (this.curContext() !== tokenCtx) {
      this.context[this.context.length - 1] = tokenCtx;
    }
  };
  types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return;
    }
    var out = this.context.pop();
    if (out === types.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };
  types$1.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
    this.exprAllowed = true;
  };
  types$1.dollarBraceL.updateContext = function() {
    this.context.push(types.b_tmpl);
    this.exprAllowed = true;
  };
  types$1.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
    this.context.push(statementParens ? types.p_stat : types.p_expr);
    this.exprAllowed = true;
  };
  types$1.incDec.updateContext = function() {
  };
  types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
      this.context.push(types.f_expr);
    } else {
      this.context.push(types.f_stat);
    }
    this.exprAllowed = false;
  };
  types$1.colon.updateContext = function() {
    if (this.curContext().token === "function") {
      this.context.pop();
    }
    this.exprAllowed = true;
  };
  types$1.backQuote.updateContext = function() {
    if (this.curContext() === types.q_tmpl) {
      this.context.pop();
    } else {
      this.context.push(types.q_tmpl);
    }
    this.exprAllowed = false;
  };
  types$1.star.updateContext = function(prevType) {
    if (prevType === types$1._function) {
      var index2 = this.context.length - 1;
      if (this.context[index2] === types.f_expr) {
        this.context[index2] = types.f_expr_gen;
      } else {
        this.context[index2] = types.f_gen;
      }
    }
    this.exprAllowed = true;
  };
  types$1.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
      if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
        allowed = true;
      }
    }
    this.exprAllowed = allowed;
  };
  var pp$5 = Parser.prototype;
  pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
      return;
    }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
      return;
    }
    var key = prop.key;
    var name2;
    switch (key.type) {
      case "Identifier":
        name2 = key.name;
        break;
      case "Literal":
        name2 = String(key.value);
        break;
      default:
        return;
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name2 === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0) {
              refDestructuringErrors.doubleProto = key.start;
            }
          } else {
            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
          }
        }
        propHash.proto = true;
      }
      return;
    }
    name2 = "$" + name2;
    var other = propHash[name2];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition) {
        this.raiseRecoverable(key.start, "Redefinition of property");
      }
    } else {
      other = propHash[name2] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };
  pp$5.parseExpression = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
    if (this.type === types$1.comma) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.expressions = [
        expr
      ];
      while (this.eat(types$1.comma)) {
        node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
      }
      return this.finishNode(node2, "SequenceExpression");
    }
    return expr;
  };
  pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) {
        return this.parseYield(forInit);
      } else {
        this.exprAllowed = false;
      }
    }
    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      oldDoubleProto = refDestructuringErrors.doubleProto;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors();
      ownDestructuringErrors = true;
    }
    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types$1.parenL || this.type === types$1.name) {
      this.potentialArrowAt = this.start;
      this.potentialArrowInForAwait = forInit === "await";
    }
    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
    if (afterLeftParse) {
      left = afterLeftParse.call(this, left, startPos, startLoc);
    }
    if (this.type.isAssign) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.operator = this.value;
      if (this.type === types$1.eq) {
        left = this.toAssignable(left, false, refDestructuringErrors);
      }
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= left.start) {
        refDestructuringErrors.shorthandAssign = -1;
      }
      if (this.type === types$1.eq) {
        this.checkLValPattern(left);
      } else {
        this.checkLValSimple(left);
      }
      node2.left = left;
      this.next();
      node2.right = this.parseMaybeAssign(forInit);
      if (oldDoubleProto > -1) {
        refDestructuringErrors.doubleProto = oldDoubleProto;
      }
      return this.finishNode(node2, "AssignmentExpression");
    } else {
      if (ownDestructuringErrors) {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
    }
    if (oldParenAssign > -1) {
      refDestructuringErrors.parenthesizedAssign = oldParenAssign;
    }
    if (oldTrailingComma > -1) {
      refDestructuringErrors.trailingComma = oldTrailingComma;
    }
    return left;
  };
  pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(forInit, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    if (this.eat(types$1.question)) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.test = expr;
      node2.consequent = this.parseMaybeAssign();
      this.expect(types$1.colon);
      node2.alternate = this.parseMaybeAssign(forInit);
      return this.finishNode(node2, "ConditionalExpression");
    }
    return expr;
  };
  pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
  };
  pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
    var prec = this.type.binop;
    if (prec != null && (!forInit || this.type !== types$1._in)) {
      if (prec > minPrec) {
        var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
        var coalesce = this.type === types$1.coalesce;
        if (coalesce) {
          prec = types$1.logicalAND.binop;
        }
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
        var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
        if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
        }
        return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
      }
    }
    return left;
  };
  pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    if (right.type === "PrivateIdentifier") {
      this.raise(right.start, "Private identifier can only be left side of binary expression");
    }
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.left = left;
    node2.operator = op;
    node2.right = right;
    return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
  };
  pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && this.canAwait) {
      expr = this.parseAwait(forInit);
      sawUnary = true;
    } else if (this.type.prefix) {
      var node2 = this.startNode(), update = this.type === types$1.incDec;
      node2.operator = this.value;
      node2.prefix = true;
      this.next();
      node2.argument = this.parseMaybeUnary(null, true, update, forInit);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) {
        this.checkLValSimple(node2.argument);
      } else if (this.strict && node2.operator === "delete" && isLocalVariableAccess(node2.argument)) {
        this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
      } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
        this.raiseRecoverable(node2.start, "Private fields can not be deleted");
      } else {
        sawUnary = true;
      }
      expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
    } else if (!sawUnary && this.type === types$1.privateId) {
      if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
        this.unexpected();
      }
      expr = this.parsePrivateIdent();
      if (this.type !== types$1._in) {
        this.unexpected();
      }
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$12 = this.startNodeAt(startPos, startLoc);
        node$12.operator = this.value;
        node$12.prefix = false;
        node$12.argument = expr;
        this.checkLValSimple(expr);
        this.next();
        expr = this.finishNode(node$12, "UpdateExpression");
      }
    }
    if (!incDec && this.eat(types$1.starstar)) {
      if (sawUnary) {
        this.unexpected(this.lastTokStart);
      } else {
        return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
      }
    } else {
      return expr;
    }
  };
  function isLocalVariableAccess(node2) {
    return node2.type === "Identifier" || node2.type === "ParenthesizedExpression" && isLocalVariableAccess(node2.expression);
  }
  function isPrivateFieldAccess(node2) {
    return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression) || node2.type === "ParenthesizedExpression" && isPrivateFieldAccess(node2.expression);
  }
  pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors, forInit);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
      return expr;
    }
    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) {
        refDestructuringErrors.parenthesizedAssign = -1;
      }
      if (refDestructuringErrors.parenthesizedBind >= result.start) {
        refDestructuringErrors.parenthesizedBind = -1;
      }
      if (refDestructuringErrors.trailingComma >= result.start) {
        refDestructuringErrors.trailingComma = -1;
      }
    }
    return result;
  };
  pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
    var optionalChained = false;
    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
      if (element.optional) {
        optionalChained = true;
      }
      if (element === base || element.type === "ArrowFunctionExpression") {
        if (optionalChained) {
          var chainNode = this.startNodeAt(startPos, startLoc);
          chainNode.expression = element;
          element = this.finishNode(chainNode, "ChainExpression");
        }
        return element;
      }
      base = element;
    }
  };
  pp$5.shouldParseAsyncArrow = function() {
    return !this.canInsertSemicolon() && this.eat(types$1.arrow);
  };
  pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
  };
  pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types$1.questionDot);
    if (noCalls && optional) {
      this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
    }
    var computed = this.eat(types$1.bracketL);
    if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.object = base;
      if (computed) {
        node2.property = this.parseExpression();
        this.expect(types$1.bracketR);
      } else if (this.type === types$1.privateId && base.type !== "Super") {
        node2.property = this.parsePrivateIdent();
      } else {
        node2.property = this.parseIdent(this.options.allowReserved !== "never");
      }
      node2.computed = !!computed;
      if (optionalSupported) {
        node2.optional = optional;
      }
      base = this.finishNode(node2, "MemberExpression");
    } else if (!noCalls && this.eat(types$1.parenL)) {
      var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0) {
          this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
        }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$12 = this.startNodeAt(startPos, startLoc);
      node$12.callee = base;
      node$12.arguments = exprList;
      if (optionalSupported) {
        node$12.optional = optional;
      }
      base = this.finishNode(node$12, "CallExpression");
    } else if (this.type === types$1.backQuote) {
      if (optional || optionalChained) {
        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      }
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({
        isTagged: true
      });
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base;
  };
  pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
    if (this.type === types$1.slash) {
      this.readRegexp();
    }
    var node2, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
      case types$1._super:
        if (!this.allowSuper) {
          this.raise(this.start, "'super' keyword outside a method");
        }
        node2 = this.startNode();
        this.next();
        if (this.type === types$1.parenL && !this.allowDirectSuper) {
          this.raise(node2.start, "super() call outside constructor of a subclass");
        }
        if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
          this.unexpected();
        }
        return this.finishNode(node2, "Super");
      case types$1._this:
        node2 = this.startNode();
        this.next();
        return this.finishNode(node2, "ThisExpression");
      case types$1.name:
        var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
        var id = this.parseIdent(false);
        if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
          this.overrideContext(types.f_expr);
          return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
        }
        if (canBeArrow && !this.canInsertSemicolon()) {
          if (this.eat(types$1.arrow)) {
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
              id
            ], false, forInit);
          }
          if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
            id = this.parseIdent(false);
            if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
              this.unexpected();
            }
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
              id
            ], true, forInit);
          }
        }
        return id;
      case types$1.regexp:
        var value2 = this.value;
        node2 = this.parseLiteral(value2.value);
        node2.regex = {
          pattern: value2.pattern,
          flags: value2.flags
        };
        return node2;
      case types$1.num:
      case types$1.string:
        return this.parseLiteral(this.value);
      case types$1._null:
      case types$1._true:
      case types$1._false:
        node2 = this.startNode();
        node2.value = this.type === types$1._null ? null : this.type === types$1._true;
        node2.raw = this.type.keyword;
        this.next();
        return this.finishNode(node2, "Literal");
      case types$1.parenL:
        var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
        if (refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
            refDestructuringErrors.parenthesizedAssign = start;
          }
          if (refDestructuringErrors.parenthesizedBind < 0) {
            refDestructuringErrors.parenthesizedBind = start;
          }
        }
        return expr;
      case types$1.bracketL:
        node2 = this.startNode();
        this.next();
        node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
        return this.finishNode(node2, "ArrayExpression");
      case types$1.braceL:
        this.overrideContext(types.b_expr);
        return this.parseObj(false, refDestructuringErrors);
      case types$1._function:
        node2 = this.startNode();
        this.next();
        return this.parseFunction(node2, 0);
      case types$1._class:
        return this.parseClass(this.startNode(), false);
      case types$1._new:
        return this.parseNew();
      case types$1.backQuote:
        return this.parseTemplate();
      case types$1._import:
        if (this.options.ecmaVersion >= 11) {
          return this.parseExprImport(forNew);
        } else {
          return this.unexpected();
        }
      default:
        return this.parseExprAtomDefault();
    }
  };
  pp$5.parseExprAtomDefault = function() {
    this.unexpected();
  };
  pp$5.parseExprImport = function(forNew) {
    var node2 = this.startNode();
    if (this.containsEsc) {
      this.raiseRecoverable(this.start, "Escape sequence in keyword import");
    }
    this.next();
    if (this.type === types$1.parenL && !forNew) {
      return this.parseDynamicImport(node2);
    } else if (this.type === types$1.dot) {
      var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
      meta.name = "import";
      node2.meta = this.finishNode(meta, "Identifier");
      return this.parseImportMeta(node2);
    } else {
      this.unexpected();
    }
  };
  pp$5.parseDynamicImport = function(node2) {
    this.next();
    node2.source = this.parseMaybeAssign();
    if (this.options.ecmaVersion >= 16) {
      if (!this.eat(types$1.parenR)) {
        this.expect(types$1.comma);
        if (!this.afterTrailingComma(types$1.parenR)) {
          node2.options = this.parseMaybeAssign();
          if (!this.eat(types$1.parenR)) {
            this.expect(types$1.comma);
            if (!this.afterTrailingComma(types$1.parenR)) {
              this.unexpected();
            }
          }
        } else {
          node2.options = null;
        }
      } else {
        node2.options = null;
      }
    } else {
      if (!this.eat(types$1.parenR)) {
        var errorPos = this.start;
        if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }
    }
    return this.finishNode(node2, "ImportExpression");
  };
  pp$5.parseImportMeta = function(node2) {
    this.next();
    var containsEsc = this.containsEsc;
    node2.property = this.parseIdent(true);
    if (node2.property.name !== "meta") {
      this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
    }
    if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
      this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
    }
    return this.finishNode(node2, "MetaProperty");
  };
  pp$5.parseLiteral = function(value2) {
    var node2 = this.startNode();
    node2.value = value2;
    node2.raw = this.input.slice(this.start, this.end);
    if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
      node2.bigint = node2.value != null ? node2.value.toString() : node2.raw.slice(0, -1).replace(/_/g, "");
    }
    this.next();
    return this.finishNode(node2, "Literal");
  };
  pp$5.parseParenExpression = function() {
    this.expect(types$1.parenL);
    var val = this.parseExpression();
    this.expect(types$1.parenR);
    return val;
  };
  pp$5.shouldParseArrow = function(exprList) {
    return !this.canInsertSemicolon();
  };
  pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();
      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      while (this.type !== types$1.parenR) {
        first ? first = false : this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
          lastIsComma = true;
          break;
        } else if (this.type === types$1.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types$1.comma) {
            this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
          }
          break;
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
      this.expect(types$1.parenR);
      if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
      }
      if (!exprList.length || lastIsComma) {
        this.unexpected(this.lastTokStart);
      }
      if (spreadStart) {
        this.unexpected(spreadStart);
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }
    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression");
    } else {
      return val;
    }
  };
  pp$5.parseParenItem = function(item) {
    return item;
  };
  pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
  };
  var empty = [];
  pp$5.parseNew = function() {
    if (this.containsEsc) {
      this.raiseRecoverable(this.start, "Escape sequence in keyword new");
    }
    var node2 = this.startNode();
    this.next();
    if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
      var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
      meta.name = "new";
      node2.meta = this.finishNode(meta, "Identifier");
      this.next();
      var containsEsc = this.containsEsc;
      node2.property = this.parseIdent(true);
      if (node2.property.name !== "target") {
        this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
      }
      if (!this.allowNewDotTarget) {
        this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
      }
      return this.finishNode(node2, "MetaProperty");
    }
    var startPos = this.start, startLoc = this.startLoc;
    node2.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
    if (this.eat(types$1.parenL)) {
      node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
    } else {
      node2.arguments = empty;
    }
    return this.finishNode(node2, "NewExpression");
  };
  pp$5.parseTemplateElement = function(ref2) {
    var isTagged = ref2.isTagged;
    var elem = this.startNode();
    if (this.type === types$1.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value.replace(/\r\n?/g, "\n"),
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types$1.backQuote;
    return this.finishNode(elem, "TemplateElement");
  };
  pp$5.parseTemplate = function(ref2) {
    if (ref2 === void 0) ref2 = {};
    var isTagged = ref2.isTagged;
    if (isTagged === void 0) isTagged = false;
    var node2 = this.startNode();
    this.next();
    node2.expressions = [];
    var curElt = this.parseTemplateElement({
      isTagged
    });
    node2.quasis = [
      curElt
    ];
    while (!curElt.tail) {
      if (this.type === types$1.eof) {
        this.raise(this.pos, "Unterminated template literal");
      }
      this.expect(types$1.dollarBraceL);
      node2.expressions.push(this.parseExpression());
      this.expect(types$1.braceR);
      node2.quasis.push(curElt = this.parseTemplateElement({
        isTagged
      }));
    }
    this.next();
    return this.finishNode(node2, "TemplateLiteral");
  };
  pp$5.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  };
  pp$5.parseObj = function(isPattern, refDestructuringErrors) {
    var node2 = this.startNode(), first = true, propHash = {};
    node2.properties = [];
    this.next();
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) {
        this.checkPropClash(prop, propHash, refDestructuringErrors);
      }
      node2.properties.push(prop);
    }
    return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
  };
  pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types$1.comma) {
          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement");
      }
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      return this.finishNode(prop, "SpreadElement");
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern) {
        isGenerator = this.eat(types$1.star);
      }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
      this.parsePropertyName(prop);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property");
  };
  pp$5.parseGetterSetter = function(prop) {
    var kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    prop.kind = kind;
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") {
        this.raiseRecoverable(start, "getter should have no params");
      } else {
        this.raiseRecoverable(start, "setter should have exactly one param");
      }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
      }
    }
  };
  pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types$1.colon) {
      this.unexpected();
    }
    if (this.eat(types$1.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
      if (isPattern) {
        this.unexpected();
      }
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
      prop.kind = "init";
    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
      if (isGenerator || isAsync) {
        this.unexpected();
      }
      this.parseGetterSetter(prop);
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) {
        this.unexpected();
      }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos) {
        this.awaitIdentPos = startPos;
      }
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      } else if (this.type === types$1.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0) {
          refDestructuringErrors.shorthandAssign = this.start;
        }
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      } else {
        prop.value = this.copyNode(prop.key);
      }
      prop.kind = "init";
      prop.shorthand = true;
    } else {
      this.unexpected();
    }
  };
  pp$5.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types$1.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types$1.bracketR);
        return prop.key;
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  };
  pp$5.initFunction = function(node2) {
    node2.id = null;
    if (this.options.ecmaVersion >= 6) {
      node2.generator = node2.expression = false;
    }
    if (this.options.ecmaVersion >= 8) {
      node2.async = false;
    }
  };
  pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.initFunction(node2);
    if (this.options.ecmaVersion >= 6) {
      node2.generator = isGenerator;
    }
    if (this.options.ecmaVersion >= 8) {
      node2.async = !!isAsync;
    }
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
    this.expect(types$1.parenL);
    node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node2, false, true, false);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node2, "FunctionExpression");
  };
  pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node2);
    if (this.options.ecmaVersion >= 8) {
      node2.async = !!isAsync;
    }
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    node2.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node2, true, false, forInit);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node2, "ArrowFunctionExpression");
  };
  pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
    var isExpression = isArrowFunction && this.type !== types$1.braceL;
    var oldStrict = this.strict, useStrict = false;
    if (isExpression) {
      node2.body = this.parseMaybeAssign(forInit);
      node2.expression = true;
      this.checkParams(node2, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        if (useStrict && nonSimple) {
          this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
        }
      }
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) {
        this.strict = true;
      }
      this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
      if (this.strict && node2.id) {
        this.checkLValSimple(node2.id, BIND_OUTSIDE);
      }
      node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
      node2.expression = false;
      this.adaptDirectivePrologue(node2.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();
  };
  pp$5.isSimpleParamList = function(params) {
    for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
      var param = list2[i2];
      if (param.type !== "Identifier") {
        return false;
      }
    }
    return true;
  };
  pp$5.checkParams = function(node2, allowDuplicates) {
    var nameHash = /* @__PURE__ */ Object.create(null);
    for (var i2 = 0, list2 = node2.params; i2 < list2.length; i2 += 1) {
      var param = list2[i2];
      this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };
  pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close2)) {
      if (!first) {
        this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(close2)) {
          break;
        }
      } else {
        first = false;
      }
      var elt = void 0;
      if (allowEmpty && this.type === types$1.comma) {
        elt = null;
      } else if (this.type === types$1.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts;
  };
  pp$5.checkUnreserved = function(ref2) {
    var start = ref2.start;
    var end = ref2.end;
    var name2 = ref2.name;
    if (this.inGenerator && name2 === "yield") {
      this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
    }
    if (this.inAsync && name2 === "await") {
      this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
    }
    if (!(this.currentThisScope().flags & SCOPE_VAR) && name2 === "arguments") {
      this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
    }
    if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
      this.raise(start, "Cannot use " + name2 + " in class static initialization block");
    }
    if (this.keywords.test(name2)) {
      this.raise(start, "Unexpected keyword '" + name2 + "'");
    }
    if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
      return;
    }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name2)) {
      if (!this.inAsync && name2 === "await") {
        this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
      }
      this.raiseRecoverable(start, "The keyword '" + name2 + "' is reserved");
    }
  };
  pp$5.parseIdent = function(liberal) {
    var node2 = this.parseIdentNode();
    this.next(!!liberal);
    this.finishNode(node2, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node2);
      if (node2.name === "await" && !this.awaitIdentPos) {
        this.awaitIdentPos = node2.start;
      }
    }
    return node2;
  };
  pp$5.parseIdentNode = function() {
    var node2 = this.startNode();
    if (this.type === types$1.name) {
      node2.name = this.value;
    } else if (this.type.keyword) {
      node2.name = this.type.keyword;
      if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
      this.type = types$1.name;
    } else {
      this.unexpected();
    }
    return node2;
  };
  pp$5.parsePrivateIdent = function() {
    var node2 = this.startNode();
    if (this.type === types$1.privateId) {
      node2.name = this.value;
    } else {
      this.unexpected();
    }
    this.next();
    this.finishNode(node2, "PrivateIdentifier");
    if (this.options.checkPrivateFields) {
      if (this.privateNameStack.length === 0) {
        this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
      } else {
        this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
      }
    }
    return node2;
  };
  pp$5.parseYield = function(forInit) {
    if (!this.yieldPos) {
      this.yieldPos = this.start;
    }
    var node2 = this.startNode();
    this.next();
    if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
      node2.delegate = false;
      node2.argument = null;
    } else {
      node2.delegate = this.eat(types$1.star);
      node2.argument = this.parseMaybeAssign(forInit);
    }
    return this.finishNode(node2, "YieldExpression");
  };
  pp$5.parseAwait = function(forInit) {
    if (!this.awaitPos) {
      this.awaitPos = this.start;
    }
    var node2 = this.startNode();
    this.next();
    node2.argument = this.parseMaybeUnary(null, true, false, forInit);
    return this.finishNode(node2, "AwaitExpression");
  };
  var pp$4 = Parser.prototype;
  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    if (this.sourceFile) {
      message += " in " + this.sourceFile;
    }
    var err = new SyntaxError(message);
    err.pos = pos;
    err.loc = loc;
    err.raisedAt = this.pos;
    throw err;
  };
  pp$4.raiseRecoverable = pp$4.raise;
  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart);
    }
  };
  var pp$3 = Parser.prototype;
  var Scope$1 = function Scope2(flags) {
    this.flags = flags;
    this.var = [];
    this.lexical = [];
    this.functions = [];
  };
  pp$3.enterScope = function(flags) {
    this.scopeStack.push(new Scope$1(flags));
  };
  pp$3.exitScope = function() {
    this.scopeStack.pop();
  };
  pp$3.treatFunctionsAsVarInScope = function(scope2) {
    return scope2.flags & SCOPE_FUNCTION || !this.inModule && scope2.flags & SCOPE_TOP;
  };
  pp$3.declareName = function(name2, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope2 = this.currentScope();
      redeclared = scope2.lexical.indexOf(name2) > -1 || scope2.functions.indexOf(name2) > -1 || scope2.var.indexOf(name2) > -1;
      scope2.lexical.push(name2);
      if (this.inModule && scope2.flags & SCOPE_TOP) {
        delete this.undefinedExports[name2];
      }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$12 = this.currentScope();
      scope$12.lexical.push(name2);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar) {
        redeclared = scope$2.lexical.indexOf(name2) > -1;
      } else {
        redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
      }
      scope$2.functions.push(name2);
    } else {
      for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
        var scope$3 = this.scopeStack[i2];
        if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
          redeclared = true;
          break;
        }
        scope$3.var.push(name2);
        if (this.inModule && scope$3.flags & SCOPE_TOP) {
          delete this.undefinedExports[name2];
        }
        if (scope$3.flags & SCOPE_VAR) {
          break;
        }
      }
    }
    if (redeclared) {
      this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
    }
  };
  pp$3.checkLocalExport = function(id) {
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };
  pp$3.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1];
  };
  pp$3.currentVarScope = function() {
    for (var i2 = this.scopeStack.length - 1; ; i2--) {
      var scope2 = this.scopeStack[i2];
      if (scope2.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
        return scope2;
      }
    }
  };
  pp$3.currentThisScope = function() {
    for (var i2 = this.scopeStack.length - 1; ; i2--) {
      var scope2 = this.scopeStack[i2];
      if (scope2.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope2.flags & SCOPE_ARROW)) {
        return scope2;
      }
    }
  };
  var Node = function Node2(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations) {
      this.loc = new SourceLocation(parser, loc);
    }
    if (parser.options.directSourceFile) {
      this.sourceFile = parser.options.directSourceFile;
    }
    if (parser.options.ranges) {
      this.range = [
        pos,
        0
      ];
    }
  };
  var pp$2 = Parser.prototype;
  pp$2.startNode = function() {
    return new Node(this, this.start, this.startLoc);
  };
  pp$2.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc);
  };
  function finishNodeAt(node2, type2, pos, loc) {
    node2.type = type2;
    node2.end = pos;
    if (this.options.locations) {
      node2.loc.end = loc;
    }
    if (this.options.ranges) {
      node2.range[1] = pos;
    }
    return node2;
  }
  pp$2.finishNode = function(node2, type2) {
    return finishNodeAt.call(this, node2, type2, this.lastTokEnd, this.lastTokEndLoc);
  };
  pp$2.finishNodeAt = function(node2, type2, pos, loc) {
    return finishNodeAt.call(this, node2, type2, pos, loc);
  };
  pp$2.copyNode = function(node2) {
    var newNode = new Node(this, node2.start, this.startLoc);
    for (var prop in node2) {
      newNode[prop] = node2[prop];
    }
    return newNode;
  };
  var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
  var ecma13BinaryProperties = ecma12BinaryProperties;
  var ecma14BinaryProperties = ecma13BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties,
    12: ecma12BinaryProperties,
    13: ecma13BinaryProperties,
    14: ecma14BinaryProperties
  };
  var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
  var unicodeBinaryPropertiesOfStrings = {
    9: "",
    10: "",
    11: "",
    12: "",
    13: "",
    14: ecma14BinaryPropertiesOfStrings
  };
  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
  var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
  var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
  var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues,
    12: ecma12ScriptValues,
    13: ecma13ScriptValues,
    14: ecma14ScriptValues
  };
  var data = {};
  function buildUnicodeData(ecmaVersion2) {
    var d = data[ecmaVersion2] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
      binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;
    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  for (var i = 0, list = [
    9,
    10,
    11,
    12,
    13,
    14
  ]; i < list.length; i += 1) {
    var ecmaVersion = list[i];
    buildUnicodeData(ecmaVersion);
  }
  var pp$1 = Parser.prototype;
  var BranchID = function BranchID2(parent, base) {
    this.parent = parent;
    this.base = base || this;
  };
  BranchID.prototype.separatedFrom = function separatedFrom(alt) {
    for (var self = this; self; self = self.parent) {
      for (var other = alt; other; other = other.parent) {
        if (self.base === other.base && self !== other) {
          return true;
        }
      }
    }
    return false;
  };
  BranchID.prototype.sibling = function sibling() {
    return new BranchID(this.parent, this.base);
  };
  var RegExpValidationState = function RegExpValidationState2(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchV = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = /* @__PURE__ */ Object.create(null);
    this.backReferenceNames = [];
    this.branchID = null;
  };
  RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
    var unicodeSets = flags.indexOf("v") !== -1;
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
      this.switchU = true;
      this.switchV = true;
      this.switchN = true;
    } else {
      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
      this.switchV = false;
      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    }
  };
  RegExpValidationState.prototype.raise = function raise(message) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
  };
  RegExpValidationState.prototype.at = function at(i2, forceU) {
    if (forceU === void 0) forceU = false;
    var s = this.source;
    var l = s.length;
    if (i2 >= l) {
      return -1;
    }
    var c = s.charCodeAt(i2);
    if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
      return c;
    }
    var next = s.charCodeAt(i2 + 1);
    return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
  };
  RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
    if (forceU === void 0) forceU = false;
    var s = this.source;
    var l = s.length;
    if (i2 >= l) {
      return l;
    }
    var c = s.charCodeAt(i2), next;
    if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
      return i2 + 1;
    }
    return i2 + 2;
  };
  RegExpValidationState.prototype.current = function current(forceU) {
    if (forceU === void 0) forceU = false;
    return this.at(this.pos, forceU);
  };
  RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
    if (forceU === void 0) forceU = false;
    return this.at(this.nextIndex(this.pos, forceU), forceU);
  };
  RegExpValidationState.prototype.advance = function advance(forceU) {
    if (forceU === void 0) forceU = false;
    this.pos = this.nextIndex(this.pos, forceU);
  };
  RegExpValidationState.prototype.eat = function eat(ch, forceU) {
    if (forceU === void 0) forceU = false;
    if (this.current(forceU) === ch) {
      this.advance(forceU);
      return true;
    }
    return false;
  };
  RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
    if (forceU === void 0) forceU = false;
    var pos = this.pos;
    for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
      var ch = list2[i2];
      var current2 = this.at(pos, forceU);
      if (current2 === -1 || current2 !== ch) {
        return false;
      }
      pos = this.nextIndex(pos, forceU);
    }
    this.pos = pos;
    return true;
  };
  pp$1.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;
    var u = false;
    var v = false;
    for (var i2 = 0; i2 < flags.length; i2++) {
      var flag = flags.charAt(i2);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i2 + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
      if (flag === "u") {
        u = true;
      }
      if (flag === "v") {
        v = true;
      }
    }
    if (this.options.ecmaVersion >= 15 && u && v) {
      this.raise(state.start, "Invalid regular expression flag");
    }
  };
  function hasProp(obj) {
    for (var _ in obj) {
      return true;
    }
    return false;
  }
  pp$1.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);
    if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };
  pp$1.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames = /* @__PURE__ */ Object.create(null);
    state.backReferenceNames.length = 0;
    state.branchID = null;
    this.regexp_disjunction(state);
    if (state.pos !== state.source.length) {
      if (state.eat(41)) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(93) || state.eat(125)) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
      var name2 = list2[i2];
      if (!state.groupNames[name2]) {
        state.raise("Invalid named capture referenced");
      }
    }
  };
  pp$1.regexp_disjunction = function(state) {
    var trackDisjunction = this.options.ecmaVersion >= 16;
    if (trackDisjunction) {
      state.branchID = new BranchID(state.branchID, null);
    }
    this.regexp_alternative(state);
    while (state.eat(124)) {
      if (trackDisjunction) {
        state.branchID = state.branchID.sibling();
      }
      this.regexp_alternative(state);
    }
    if (trackDisjunction) {
      state.branchID = state.branchID.parent;
    }
    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(123)) {
      state.raise("Lone quantifier brackets");
    }
  };
  pp$1.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
    }
  };
  pp$1.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true;
    }
    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true;
    }
    return false;
  };
  pp$1.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;
    if (state.eat(94) || state.eat(36)) {
      return true;
    }
    if (state.eat(92)) {
      if (state.eat(66) || state.eat(98)) {
        return true;
      }
      state.pos = start;
    }
    if (state.eat(40) && state.eat(63)) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(60);
      }
      if (state.eat(61) || state.eat(33)) {
        this.regexp_disjunction(state);
        if (!state.eat(41)) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true;
      }
    }
    state.pos = start;
    return false;
  };
  pp$1.regexp_eatQuantifier = function(state, noError) {
    if (noError === void 0) noError = false;
    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(63);
      return true;
    }
    return false;
  };
  pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
    return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
  };
  pp$1.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(123)) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(125)) {
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true;
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatAtom = function(state) {
    return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
  };
  pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(92)) {
      if (this.regexp_eatAtomEscape(state)) {
        return true;
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(40)) {
      if (state.eat(63)) {
        if (this.options.ecmaVersion >= 16) {
          var addModifiers = this.regexp_eatModifiers(state);
          var hasHyphen = state.eat(45);
          if (addModifiers || hasHyphen) {
            for (var i2 = 0; i2 < addModifiers.length; i2++) {
              var modifier = addModifiers.charAt(i2);
              if (addModifiers.indexOf(modifier, i2 + 1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
            if (hasHyphen) {
              var removeModifiers = this.regexp_eatModifiers(state);
              if (!addModifiers && !removeModifiers && state.current() === 58) {
                state.raise("Invalid regular expression modifiers");
              }
              for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                var modifier$1 = removeModifiers.charAt(i$1);
                if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                  state.raise("Duplicate regular expression modifiers");
                }
              }
            }
          }
        }
        if (state.eat(58)) {
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            return true;
          }
          state.raise("Unterminated group");
        }
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatCapturingGroup = function(state) {
    if (state.eat(40)) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 63) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(41)) {
        state.numCapturingParens += 1;
        return true;
      }
      state.raise("Unterminated group");
    }
    return false;
  };
  pp$1.regexp_eatModifiers = function(state) {
    var modifiers = "";
    var ch = 0;
    while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
      modifiers += codePointToString(ch);
      state.advance();
    }
    return modifiers;
  };
  function isRegularExpressionModifier(ch) {
    return ch === 105 || ch === 109 || ch === 115;
  }
  pp$1.regexp_eatExtendedAtom = function(state) {
    return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
  };
  pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false;
  };
  pp$1.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  function isSyntaxCharacter(ch) {
    return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
  }
  pp$1.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start;
  };
  pp$1.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_groupSpecifier = function(state) {
    if (state.eat(63)) {
      if (!this.regexp_eatGroupName(state)) {
        state.raise("Invalid group");
      }
      var trackDisjunction = this.options.ecmaVersion >= 16;
      var known = state.groupNames[state.lastStringValue];
      if (known) {
        if (trackDisjunction) {
          for (var i2 = 0, list2 = known; i2 < list2.length; i2 += 1) {
            var altID = list2[i2];
            if (!altID.separatedFrom(state.branchID)) {
              state.raise("Duplicate capture group name");
            }
          }
        } else {
          state.raise("Duplicate capture group name");
        }
      }
      if (trackDisjunction) {
        (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
      } else {
        state.groupNames[state.lastStringValue] = true;
      }
    }
  };
  pp$1.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(60)) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
        return true;
      }
      state.raise("Invalid capture group name");
    }
    return false;
  };
  pp$1.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true;
    }
    return false;
  };
  pp$1.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);
    if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true;
    }
    state.pos = start;
    return false;
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart$1(ch, true) || ch === 36 || ch === 95;
  }
  pp$1.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);
    if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true;
    }
    state.pos = start;
    return false;
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
  }
  pp$1.regexp_eatAtomEscape = function(state) {
    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
      return true;
    }
    if (state.switchU) {
      if (state.current() === 99) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false;
  };
  pp$1.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true;
      }
      if (n <= state.numCapturingParens) {
        return true;
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatKGroupName = function(state) {
    if (state.eat(107)) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true;
      }
      state.raise("Invalid named reference");
    }
    return false;
  };
  pp$1.regexp_eatCharacterEscape = function(state) {
    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
  };
  pp$1.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(99)) {
      if (this.regexp_eatControlLetter(state)) {
        return true;
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatZero = function(state) {
    if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 116) {
      state.lastIntValue = 9;
      state.advance();
      return true;
    }
    if (ch === 110) {
      state.lastIntValue = 10;
      state.advance();
      return true;
    }
    if (ch === 118) {
      state.lastIntValue = 11;
      state.advance();
      return true;
    }
    if (ch === 102) {
      state.lastIntValue = 12;
      state.advance();
      return true;
    }
    if (ch === 114) {
      state.lastIntValue = 13;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 32;
      state.advance();
      return true;
    }
    return false;
  };
  function isControlLetter(ch) {
    return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
  }
  pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if (forceU === void 0) forceU = false;
    var start = state.pos;
    var switchU = forceU || state.switchU;
    if (state.eat(117)) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (switchU && lead >= 55296 && lead <= 56319) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 56320 && trail <= 57343) {
              state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
              return true;
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true;
      }
      if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
        return true;
      }
      if (switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }
    return false;
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 1114111;
  }
  pp$1.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true;
      }
      if (state.eat(47)) {
        state.lastIntValue = 47;
        return true;
      }
      return false;
    }
    var ch = state.current();
    if (ch !== 99 && (!state.switchN || ch !== 107)) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 49 && ch <= 57) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
        state.advance();
      } while ((ch = state.current()) >= 48 && ch <= 57);
      return true;
    }
    return false;
  };
  var CharSetNone = 0;
  var CharSetOk = 1;
  var CharSetString = 2;
  pp$1.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();
    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return CharSetOk;
    }
    var negate = false;
    if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
      state.lastIntValue = -1;
      state.advance();
      var result;
      if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
        if (negate && result === CharSetString) {
          state.raise("Invalid property name");
        }
        return result;
      }
      state.raise("Invalid property name");
    }
    return CharSetNone;
  };
  function isCharacterClassEscape(ch) {
    return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
  }
  pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
      var name2 = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value2 = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name2, value2);
        return CharSetOk;
      }
    }
    state.pos = start;
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    }
    return CharSetNone;
  };
  pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value2) {
    if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
      state.raise("Invalid property name");
    }
    if (!state.unicodeProperties.nonBinary[name2].test(value2)) {
      state.raise("Invalid property value");
    }
  };
  pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (state.unicodeProperties.binary.test(nameOrValue)) {
      return CharSetOk;
    }
    if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
      return CharSetString;
    }
    state.raise("Invalid property name");
  };
  pp$1.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== "";
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 95;
  }
  pp$1.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== "";
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
  }
  pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state);
  };
  pp$1.regexp_eatCharacterClass = function(state) {
    if (state.eat(91)) {
      var negate = state.eat(94);
      var result = this.regexp_classContents(state);
      if (!state.eat(93)) {
        state.raise("Unterminated character class");
      }
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return true;
    }
    return false;
  };
  pp$1.regexp_classContents = function(state) {
    if (state.current() === 93) {
      return CharSetOk;
    }
    if (state.switchV) {
      return this.regexp_classSetExpression(state);
    }
    this.regexp_nonEmptyClassRanges(state);
    return CharSetOk;
  };
  pp$1.regexp_nonEmptyClassRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(45) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };
  pp$1.regexp_eatClassAtom = function(state) {
    var start = state.pos;
    if (state.eat(92)) {
      if (this.regexp_eatClassEscape(state)) {
        return true;
      }
      if (state.switchU) {
        var ch$1 = state.current();
        if (ch$1 === 99 || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    var ch = state.current();
    if (ch !== 93) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatClassEscape = function(state) {
    var start = state.pos;
    if (state.eat(98)) {
      state.lastIntValue = 8;
      return true;
    }
    if (state.switchU && state.eat(45)) {
      state.lastIntValue = 45;
      return true;
    }
    if (!state.switchU && state.eat(99)) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true;
      }
      state.pos = start;
    }
    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
  };
  pp$1.regexp_classSetExpression = function(state) {
    var result = CharSetOk, subResult;
    if (this.regexp_eatClassSetRange(state)) ;
    else if (subResult = this.regexp_eatClassSetOperand(state)) {
      if (subResult === CharSetString) {
        result = CharSetString;
      }
      var start = state.pos;
      while (state.eatChars([
        38,
        38
      ])) {
        if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
          if (subResult !== CharSetString) {
            result = CharSetOk;
          }
          continue;
        }
        state.raise("Invalid character in character class");
      }
      if (start !== state.pos) {
        return result;
      }
      while (state.eatChars([
        45,
        45
      ])) {
        if (this.regexp_eatClassSetOperand(state)) {
          continue;
        }
        state.raise("Invalid character in character class");
      }
      if (start !== state.pos) {
        return result;
      }
    } else {
      state.raise("Invalid character in character class");
    }
    for (; ; ) {
      if (this.regexp_eatClassSetRange(state)) {
        continue;
      }
      subResult = this.regexp_eatClassSetOperand(state);
      if (!subResult) {
        return result;
      }
      if (subResult === CharSetString) {
        result = CharSetString;
      }
    }
  };
  pp$1.regexp_eatClassSetRange = function(state) {
    var start = state.pos;
    if (this.regexp_eatClassSetCharacter(state)) {
      var left = state.lastIntValue;
      if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
        var right = state.lastIntValue;
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
        return true;
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatClassSetOperand = function(state) {
    if (this.regexp_eatClassSetCharacter(state)) {
      return CharSetOk;
    }
    return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
  };
  pp$1.regexp_eatNestedClass = function(state) {
    var start = state.pos;
    if (state.eat(91)) {
      var negate = state.eat(94);
      var result = this.regexp_classContents(state);
      if (state.eat(93)) {
        if (negate && result === CharSetString) {
          state.raise("Negated character class may contain strings");
        }
        return result;
      }
      state.pos = start;
    }
    if (state.eat(92)) {
      var result$1 = this.regexp_eatCharacterClassEscape(state);
      if (result$1) {
        return result$1;
      }
      state.pos = start;
    }
    return null;
  };
  pp$1.regexp_eatClassStringDisjunction = function(state) {
    var start = state.pos;
    if (state.eatChars([
      92,
      113
    ])) {
      if (state.eat(123)) {
        var result = this.regexp_classStringDisjunctionContents(state);
        if (state.eat(125)) {
          return result;
        }
      } else {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return null;
  };
  pp$1.regexp_classStringDisjunctionContents = function(state) {
    var result = this.regexp_classString(state);
    while (state.eat(124)) {
      if (this.regexp_classString(state) === CharSetString) {
        result = CharSetString;
      }
    }
    return result;
  };
  pp$1.regexp_classString = function(state) {
    var count = 0;
    while (this.regexp_eatClassSetCharacter(state)) {
      count++;
    }
    return count === 1 ? CharSetOk : CharSetString;
  };
  pp$1.regexp_eatClassSetCharacter = function(state) {
    var start = state.pos;
    if (state.eat(92)) {
      if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
        return true;
      }
      if (state.eat(98)) {
        state.lastIntValue = 8;
        return true;
      }
      state.pos = start;
      return false;
    }
    var ch = state.current();
    if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
      return false;
    }
    if (isClassSetSyntaxCharacter(ch)) {
      return false;
    }
    state.advance();
    state.lastIntValue = ch;
    return true;
  };
  function isClassSetReservedDoublePunctuatorCharacter(ch) {
    return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
  }
  function isClassSetSyntaxCharacter(ch) {
    return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
  }
  pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
    var ch = state.current();
    if (isClassSetReservedPunctuator(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  function isClassSetReservedPunctuator(ch) {
    return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
  }
  pp$1.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 95) {
      state.lastIntValue = ch % 32;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(120)) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true;
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    }
    return state.pos !== start;
  };
  function isDecimalDigit(ch) {
    return ch >= 48 && ch <= 57;
  }
  pp$1.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit$1(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start;
  };
  function isHexDigit$1(ch) {
    return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
  }
  function hexToInt(ch) {
    if (ch >= 65 && ch <= 70) {
      return 10 + (ch - 65);
    }
    if (ch >= 97 && ch <= 102) {
      return 10 + (ch - 97);
    }
    return ch - 48;
  }
  pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true;
    }
    return false;
  };
  pp$1.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 48;
      state.advance();
      return true;
    }
    state.lastIntValue = 0;
    return false;
  };
  function isOctalDigit(ch) {
    return ch >= 48 && ch <= 55;
  }
  pp$1.regexp_eatFixedHexDigits = function(state, length2) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i2 = 0; i2 < length2; ++i2) {
      var ch = state.current();
      if (!isHexDigit$1(ch)) {
        state.pos = start;
        return false;
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true;
  };
  var Token = function Token2(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations) {
      this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
    }
    if (p.options.ranges) {
      this.range = [
        p.start,
        p.end
      ];
    }
  };
  var pp = Parser.prototype;
  pp.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
      this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
    }
    if (this.options.onToken) {
      this.options.onToken(new Token(this));
    }
    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };
  pp.getToken = function() {
    this.next();
    return new Token(this);
  };
  if (typeof Symbol !== "undefined") {
    pp[Symbol.iterator] = function() {
      var this$1$1 = this;
      return {
        next: function() {
          var token = this$1$1.getToken();
          return {
            done: token.type === types$1.eof,
            value: token
          };
        }
      };
    };
  }
  pp.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) {
      this.skipSpace();
    }
    this.start = this.pos;
    if (this.options.locations) {
      this.startLoc = this.curPosition();
    }
    if (this.pos >= this.input.length) {
      return this.finishToken(types$1.eof);
    }
    if (curContext.override) {
      return curContext.override(this);
    } else {
      this.readToken(this.fullCharCodeAtPos());
    }
  };
  pp.readToken = function(code2) {
    if (isIdentifierStart$1(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
      return this.readWord();
    }
    return this.getTokenFromCode(code2);
  };
  pp.fullCharCodeAtPos = function() {
    var code2 = this.input.charCodeAt(this.pos);
    if (code2 <= 55295 || code2 >= 56320) {
      return code2;
    }
    var next = this.input.charCodeAt(this.pos + 1);
    return next <= 56319 || next >= 57344 ? code2 : (code2 << 10) + next - 56613888;
  };
  pp.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) {
      this.raise(this.pos - 2, "Unterminated comment");
    }
    this.pos = end + 2;
    if (this.options.locations) {
      for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
        ++this.curLine;
        pos = this.lineStart = nextBreak;
      }
    }
    if (this.options.onComment) {
      this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
    }
  };
  pp.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment) {
      this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
    }
  };
  pp.skipSpace = function() {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
  };
  pp.finishToken = function(type2, val) {
    this.end = this.pos;
    if (this.options.locations) {
      this.endLoc = this.curPosition();
    }
    var prevType = this.type;
    this.type = type2;
    this.value = val;
    this.updateContext(prevType);
  };
  pp.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) {
      return this.readNumber(true);
    }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
      this.pos += 3;
      return this.finishToken(types$1.ellipsis);
    } else {
      ++this.pos;
      return this.finishToken(types$1.dot);
    }
  };
  pp.readToken_slash = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) {
      ++this.pos;
      return this.readRegexp();
    }
    if (next === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(types$1.slash, 1);
  };
  pp.readToken_mult_modulo_exp = function(code2) {
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
    if (this.options.ecmaVersion >= 7 && code2 === 42 && next === 42) {
      ++size;
      tokentype = types$1.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }
    if (next === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(tokentype, size);
  };
  pp.readToken_pipe_amp = function(code2) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code2) {
      if (this.options.ecmaVersion >= 12) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
    }
    if (next === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
  };
  pp.readToken_caret = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(types$1.bitwiseXOR, 1);
  };
  pp.readToken_plus_min = function(code2) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code2) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken();
      }
      return this.finishOp(types$1.incDec, 2);
    }
    if (next === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(types$1.plusMin, 1);
  };
  pp.readToken_lt_gt = function(code2) {
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code2) {
      size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) {
        return this.finishOp(types$1.assign, size + 1);
      }
      return this.finishOp(types$1.bitShift, size);
    }
    if (next === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken();
    }
    if (next === 61) {
      size = 2;
    }
    return this.finishOp(types$1.relational, size);
  };
  pp.readToken_eq_excl = function(code2) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) {
      return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
    }
    if (code2 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
      this.pos += 2;
      return this.finishToken(types$1.arrow);
    }
    return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
  };
  pp.readToken_question = function() {
    var ecmaVersion2 = this.options.ecmaVersion;
    if (ecmaVersion2 >= 11) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 46) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 < 48 || next2 > 57) {
          return this.finishOp(types$1.questionDot, 2);
        }
      }
      if (next === 63) {
        if (ecmaVersion2 >= 12) {
          var next2$1 = this.input.charCodeAt(this.pos + 2);
          if (next2$1 === 61) {
            return this.finishOp(types$1.assign, 3);
          }
        }
        return this.finishOp(types$1.coalesce, 2);
      }
    }
    return this.finishOp(types$1.question, 1);
  };
  pp.readToken_numberSign = function() {
    var ecmaVersion2 = this.options.ecmaVersion;
    var code2 = 35;
    if (ecmaVersion2 >= 13) {
      ++this.pos;
      code2 = this.fullCharCodeAtPos();
      if (isIdentifierStart$1(code2, true) || code2 === 92) {
        return this.finishToken(types$1.privateId, this.readWord1());
      }
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
  };
  pp.getTokenFromCode = function(code2) {
    switch (code2) {
      case 46:
        return this.readToken_dot();
      case 40:
        ++this.pos;
        return this.finishToken(types$1.parenL);
      case 41:
        ++this.pos;
        return this.finishToken(types$1.parenR);
      case 59:
        ++this.pos;
        return this.finishToken(types$1.semi);
      case 44:
        ++this.pos;
        return this.finishToken(types$1.comma);
      case 91:
        ++this.pos;
        return this.finishToken(types$1.bracketL);
      case 93:
        ++this.pos;
        return this.finishToken(types$1.bracketR);
      case 123:
        ++this.pos;
        return this.finishToken(types$1.braceL);
      case 125:
        ++this.pos;
        return this.finishToken(types$1.braceR);
      case 58:
        ++this.pos;
        return this.finishToken(types$1.colon);
      case 96:
        if (this.options.ecmaVersion < 6) {
          break;
        }
        ++this.pos;
        return this.finishToken(types$1.backQuote);
      case 48:
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 120 || next === 88) {
          return this.readRadixNumber(16);
        }
        if (this.options.ecmaVersion >= 6) {
          if (next === 111 || next === 79) {
            return this.readRadixNumber(8);
          }
          if (next === 98 || next === 66) {
            return this.readRadixNumber(2);
          }
        }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.readNumber(false);
      case 34:
      case 39:
        return this.readString(code2);
      case 47:
        return this.readToken_slash();
      case 37:
      case 42:
        return this.readToken_mult_modulo_exp(code2);
      case 124:
      case 38:
        return this.readToken_pipe_amp(code2);
      case 94:
        return this.readToken_caret();
      case 43:
      case 45:
        return this.readToken_plus_min(code2);
      case 60:
      case 62:
        return this.readToken_lt_gt(code2);
      case 61:
      case 33:
        return this.readToken_eq_excl(code2);
      case 63:
        return this.readToken_question();
      case 126:
        return this.finishOp(types$1.prefix, 1);
      case 35:
        return this.readToken_numberSign();
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
  };
  pp.finishOp = function(type2, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type2, str);
  };
  pp.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length) {
        this.raise(start, "Unterminated regular expression");
      }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) {
        this.raise(start, "Unterminated regular expression");
      }
      if (!escaped) {
        if (ch === "[") {
          inClass = true;
        } else if (ch === "]" && inClass) {
          inClass = false;
        } else if (ch === "/" && !inClass) {
          break;
        }
        escaped = ch === "\\";
      } else {
        escaped = false;
      }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) {
      this.unexpected(flagsStart);
    }
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);
    var value2 = null;
    try {
      value2 = new RegExp(pattern, flags);
    } catch (e) {
    }
    return this.finishToken(types$1.regexp, {
      pattern,
      flags,
      value: value2
    });
  };
  pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
    var start = this.pos, total = 0, lastCode = 0;
    for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
      var code2 = this.input.charCodeAt(this.pos), val = void 0;
      if (allowSeparators && code2 === 95) {
        if (isLegacyOctalNumericLiteral) {
          this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
        }
        if (lastCode === 95) {
          this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
        }
        if (i2 === 0) {
          this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
        }
        lastCode = code2;
        continue;
      }
      if (code2 >= 97) {
        val = code2 - 97 + 10;
      } else if (code2 >= 65) {
        val = code2 - 65 + 10;
      } else if (code2 >= 48 && code2 <= 57) {
        val = code2 - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        break;
      }
      lastCode = code2;
      total = total * radix + val;
    }
    if (allowSeparators && lastCode === 95) {
      this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
    }
    if (this.pos === start || len != null && this.pos - start !== len) {
      return null;
    }
    return total;
  };
  function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral) {
      return parseInt(str, 8);
    }
    return parseFloat(str.replace(/_/g, ""));
  }
  function stringToBigInt(str) {
    if (typeof BigInt !== "function") {
      return null;
    }
    return BigInt(str.replace(/_/g, ""));
  }
  pp.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2;
    var val = this.readInt(radix);
    if (val == null) {
      this.raise(this.start + 2, "Expected number in radix " + radix);
    }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
    } else if (isIdentifierStart$1(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val);
  };
  pp.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10, void 0, true) === null) {
      this.raise(start, "Invalid number");
    }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) {
      this.raise(start, "Invalid number");
    }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
      if (isIdentifierStart$1(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types$1.num, val$1);
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
      octal = false;
    }
    if (next === 46 && !octal) {
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) {
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) {
        ++this.pos;
      }
      if (this.readInt(10) === null) {
        this.raise(start, "Invalid number");
      }
    }
    if (isIdentifierStart$1(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    var val = stringToNumber(this.input.slice(start, this.pos), octal);
    return this.finishToken(types$1.num, val);
  };
  pp.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code2;
    if (ch === 123) {
      if (this.options.ecmaVersion < 6) {
        this.unexpected();
      }
      var codePos = ++this.pos;
      code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code2 > 1114111) {
        this.invalidStringToken(codePos, "Code point out of bounds");
      }
    } else {
      code2 = this.readHexChar(4);
    }
    return code2;
  };
  pp.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length) {
        this.raise(this.start, "Unterminated string constant");
      }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) {
        break;
      }
      if (ch === 92) {
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else if (ch === 8232 || ch === 8233) {
        if (this.options.ecmaVersion < 10) {
          this.raise(this.start, "Unterminated string constant");
        }
        ++this.pos;
        if (this.options.locations) {
          this.curLine++;
          this.lineStart = this.pos;
        }
      } else {
        if (isNewLine(ch)) {
          this.raise(this.start, "Unterminated string constant");
        }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types$1.string, out);
  };
  var INVALID_TEMPLATE_ESCAPE_ERROR = {};
  pp.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err;
      }
    }
    this.inTemplateElement = false;
  };
  pp.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR;
    } else {
      this.raise(position, message);
    }
  };
  pp.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length) {
        this.raise(this.start, "Unterminated template");
      }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
        if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types$1.dollarBraceL);
          } else {
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types$1.template, out);
      }
      if (ch === 92) {
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch);
            break;
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };
  pp.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break;
        case "$":
          if (this.input[this.pos + 1] !== "{") {
            break;
          }
        case "`":
          return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
        case "\r":
          if (this.input[this.pos + 1] === "\n") {
            ++this.pos;
          }
        case "\n":
        case "\u2028":
        case "\u2029":
          ++this.curLine;
          this.lineStart = this.pos + 1;
          break;
      }
    }
    this.raise(this.start, "Unterminated template");
  };
  pp.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
      case 110:
        return "\n";
      case 114:
        return "\r";
      case 120:
        return String.fromCharCode(this.readHexChar(2));
      case 117:
        return codePointToString(this.readCodePoint());
      case 116:
        return "	";
      case 98:
        return "\b";
      case 118:
        return "\v";
      case 102:
        return "\f";
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) {
          ++this.pos;
        }
      case 10:
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      case 56:
      case 57:
        if (this.strict) {
          this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
        }
        if (inTemplate) {
          var codePos = this.pos - 1;
          this.invalidStringToken(codePos, "Invalid escape sequence in template string");
        }
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          this.pos += octalStr.length - 1;
          ch = this.input.charCodeAt(this.pos);
          if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
            this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
          }
          return String.fromCharCode(octal);
        }
        if (isNewLine(ch)) {
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        }
        return String.fromCharCode(ch);
    }
  };
  pp.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) {
      this.invalidStringToken(codePos, "Bad character escape sequence");
    }
    return n;
  };
  pp.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 65535 ? 1 : 2;
      } else if (ch === 92) {
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) {
          this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
        }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart$1 : isIdentifierChar)(esc, astral)) {
          this.invalidStringToken(escStart, "Invalid Unicode escape");
        }
        word += codePointToString(esc);
        chunkStart = this.pos;
      } else {
        break;
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos);
  };
  pp.readWord = function() {
    var word = this.readWord1();
    var type2 = types$1.name;
    if (this.keywords.test(word)) {
      type2 = keywords$2[word];
    }
    return this.finishToken(type2, word);
  };
  var version = "8.15.0";
  Parser.acorn = {
    Parser,
    version,
    defaultOptions,
    Position,
    SourceLocation,
    getLineInfo,
    Node,
    TokenType,
    tokTypes: types$1,
    keywordTypes: keywords$2,
    TokContext,
    tokContexts: types,
    isIdentifierChar,
    isIdentifierStart: isIdentifierStart$1,
    Token,
    isNewLine,
    lineBreak,
    lineBreakG,
    nonASCIIwhitespace
  };
  function parse3(input, options2) {
    return Parser.parse(input, options2);
  }
  const EOF$1 = 0;
  const Ident = 1;
  const Function$2 = 2;
  const AtKeyword = 3;
  const Hash$1 = 4;
  const String$2 = 5;
  const BadString = 6;
  const Url$1 = 7;
  const BadUrl = 8;
  const Delim = 9;
  const Number$2 = 10;
  const Percentage$1 = 11;
  const Dimension$1 = 12;
  const WhiteSpace$1 = 13;
  const CDO$1 = 14;
  const CDC$1 = 15;
  const Colon = 16;
  const Semicolon = 17;
  const Comma = 18;
  const LeftSquareBracket = 19;
  const RightSquareBracket = 20;
  const LeftParenthesis = 21;
  const RightParenthesis = 22;
  const LeftCurlyBracket = 23;
  const RightCurlyBracket = 24;
  const Comment$1 = 25;
  const EOF = 0;
  function isDigit(code2) {
    return code2 >= 48 && code2 <= 57;
  }
  function isHexDigit(code2) {
    return isDigit(code2) || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102;
  }
  function isUppercaseLetter(code2) {
    return code2 >= 65 && code2 <= 90;
  }
  function isLowercaseLetter(code2) {
    return code2 >= 97 && code2 <= 122;
  }
  function isLetter(code2) {
    return isUppercaseLetter(code2) || isLowercaseLetter(code2);
  }
  function isNonAscii(code2) {
    return code2 >= 128;
  }
  function isNameStart(code2) {
    return isLetter(code2) || isNonAscii(code2) || code2 === 95;
  }
  function isName(code2) {
    return isNameStart(code2) || isDigit(code2) || code2 === 45;
  }
  function isNonPrintable(code2) {
    return code2 >= 0 && code2 <= 8 || code2 === 11 || code2 >= 14 && code2 <= 31 || code2 === 127;
  }
  function isNewline(code2) {
    return code2 === 10 || code2 === 13 || code2 === 12;
  }
  function isWhiteSpace(code2) {
    return isNewline(code2) || code2 === 32 || code2 === 9;
  }
  function isValidEscape(first, second) {
    if (first !== 92) {
      return false;
    }
    if (isNewline(second) || second === EOF) {
      return false;
    }
    return true;
  }
  function isIdentifierStart(first, second, third) {
    if (first === 45) {
      return isNameStart(second) || second === 45 || isValidEscape(second, third);
    }
    if (isNameStart(first)) {
      return true;
    }
    if (first === 92) {
      return isValidEscape(first, second);
    }
    return false;
  }
  function isNumberStart(first, second, third) {
    if (first === 43 || first === 45) {
      if (isDigit(second)) {
        return 2;
      }
      return second === 46 && isDigit(third) ? 3 : 0;
    }
    if (first === 46) {
      return isDigit(second) ? 2 : 0;
    }
    if (isDigit(first)) {
      return 1;
    }
    return 0;
  }
  function isBOM(code2) {
    if (code2 === 65279) {
      return 1;
    }
    if (code2 === 65534) {
      return 1;
    }
    return 0;
  }
  const CATEGORY = new Array(128);
  const EofCategory = 128;
  const WhiteSpaceCategory = 130;
  const DigitCategory = 131;
  const NameStartCategory = 132;
  const NonPrintableCategory = 133;
  for (let i2 = 0; i2 < CATEGORY.length; i2++) {
    CATEGORY[i2] = isWhiteSpace(i2) && WhiteSpaceCategory || isDigit(i2) && DigitCategory || isNameStart(i2) && NameStartCategory || isNonPrintable(i2) && NonPrintableCategory || i2 || EofCategory;
  }
  function charCodeCategory(code2) {
    return code2 < 128 ? CATEGORY[code2] : NameStartCategory;
  }
  function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
  }
  function getNewlineLength(source, offset, code2) {
    if (code2 === 13 && getCharCode(source, offset + 1) === 10) {
      return 2;
    }
    return 1;
  }
  function cmpChar(testStr, offset, referenceCode) {
    let code2 = testStr.charCodeAt(offset);
    if (isUppercaseLetter(code2)) {
      code2 = code2 | 32;
    }
    return code2 === referenceCode;
  }
  function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
      return false;
    }
    if (start < 0 || end > testStr.length) {
      return false;
    }
    for (let i2 = start; i2 < end; i2++) {
      const referenceCode = referenceStr.charCodeAt(i2 - start);
      let testCode = testStr.charCodeAt(i2);
      if (isUppercaseLetter(testCode)) {
        testCode = testCode | 32;
      }
      if (testCode !== referenceCode) {
        return false;
      }
    }
    return true;
  }
  function findWhiteSpaceStart(source, offset) {
    for (; offset >= 0; offset--) {
      if (!isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset + 1;
  }
  function findWhiteSpaceEnd(source, offset) {
    for (; offset < source.length; offset++) {
      if (!isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset;
  }
  function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
      if (!isDigit(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset;
  }
  function consumeEscaped(source, offset) {
    offset += 2;
    if (isHexDigit(getCharCode(source, offset - 1))) {
      for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
        if (!isHexDigit(getCharCode(source, offset))) {
          break;
        }
      }
      const code2 = getCharCode(source, offset);
      if (isWhiteSpace(code2)) {
        offset += getNewlineLength(source, offset, code2);
      }
    }
    return offset;
  }
  function consumeName(source, offset) {
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      if (isName(code2)) {
        continue;
      }
      if (isValidEscape(code2, getCharCode(source, offset + 1))) {
        offset = consumeEscaped(source, offset) - 1;
        continue;
      }
      break;
    }
    return offset;
  }
  function consumeNumber(source, offset) {
    let code2 = source.charCodeAt(offset);
    if (code2 === 43 || code2 === 45) {
      code2 = source.charCodeAt(offset += 1);
    }
    if (isDigit(code2)) {
      offset = findDecimalNumberEnd(source, offset + 1);
      code2 = source.charCodeAt(offset);
    }
    if (code2 === 46 && isDigit(source.charCodeAt(offset + 1))) {
      offset += 2;
      offset = findDecimalNumberEnd(source, offset);
    }
    if (cmpChar(source, offset, 101)) {
      let sign2 = 0;
      code2 = source.charCodeAt(offset + 1);
      if (code2 === 45 || code2 === 43) {
        sign2 = 1;
        code2 = source.charCodeAt(offset + 2);
      }
      if (isDigit(code2)) {
        offset = findDecimalNumberEnd(source, offset + 1 + sign2 + 1);
      }
    }
    return offset;
  }
  function consumeBadUrlRemnants(source, offset) {
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      if (code2 === 41) {
        offset++;
        break;
      }
      if (isValidEscape(code2, getCharCode(source, offset + 1))) {
        offset = consumeEscaped(source, offset);
      }
    }
    return offset;
  }
  function decodeEscaped(escaped) {
    if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {
      return escaped[0];
    }
    let code2 = parseInt(escaped, 16);
    if (code2 === 0 || code2 >= 55296 && code2 <= 57343 || code2 > 1114111) {
      code2 = 65533;
    }
    return String.fromCodePoint(code2);
  }
  const tokenNames = [
    "EOF-token",
    "ident-token",
    "function-token",
    "at-keyword-token",
    "hash-token",
    "string-token",
    "bad-string-token",
    "url-token",
    "bad-url-token",
    "delim-token",
    "number-token",
    "percentage-token",
    "dimension-token",
    "whitespace-token",
    "CDO-token",
    "CDC-token",
    "colon-token",
    "semicolon-token",
    "comma-token",
    "[-token",
    "]-token",
    "(-token",
    ")-token",
    "{-token",
    "}-token",
    "comment-token"
  ];
  const MIN_SIZE = 16 * 1024;
  function adoptBuffer(buffer2 = null, size) {
    if (buffer2 === null || buffer2.length < size) {
      return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
    }
    return buffer2;
  }
  const N$4 = 10;
  const F$2 = 12;
  const R$2 = 13;
  function computeLinesAndColumns(host) {
    const source = host.source;
    const sourceLength = source.length;
    const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
    const lines = adoptBuffer(host.lines, sourceLength);
    const columns = adoptBuffer(host.columns, sourceLength);
    let line = host.startLine;
    let column = host.startColumn;
    for (let i2 = startOffset; i2 < sourceLength; i2++) {
      const code2 = source.charCodeAt(i2);
      lines[i2] = line;
      columns[i2] = column++;
      if (code2 === N$4 || code2 === R$2 || code2 === F$2) {
        if (code2 === R$2 && i2 + 1 < sourceLength && source.charCodeAt(i2 + 1) === N$4) {
          i2++;
          lines[i2] = line;
          columns[i2] = column;
        }
        line++;
        column = 1;
      }
    }
    lines[sourceLength] = line;
    columns[sourceLength] = column;
    host.lines = lines;
    host.columns = columns;
    host.computed = true;
  }
  class OffsetToLocation {
    constructor(source, startOffset, startLine, startColumn) {
      this.setSource(source, startOffset, startLine, startColumn);
      this.lines = null;
      this.columns = null;
    }
    setSource(source = "", startOffset = 0, startLine = 1, startColumn = 1) {
      this.source = source;
      this.startOffset = startOffset;
      this.startLine = startLine;
      this.startColumn = startColumn;
      this.computed = false;
    }
    getLocation(offset, filename2) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }
      return {
        source: filename2,
        offset: this.startOffset + offset,
        line: this.lines[offset],
        column: this.columns[offset]
      };
    }
    getLocationRange(start, end, filename2) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }
      return {
        source: filename2,
        start: {
          offset: this.startOffset + start,
          line: this.lines[start],
          column: this.columns[start]
        },
        end: {
          offset: this.startOffset + end,
          line: this.lines[end],
          column: this.columns[end]
        }
      };
    }
  }
  const OFFSET_MASK = 16777215;
  const TYPE_SHIFT = 24;
  const balancePair$1 = new Uint8Array(32);
  balancePair$1[Function$2] = RightParenthesis;
  balancePair$1[LeftParenthesis] = RightParenthesis;
  balancePair$1[LeftSquareBracket] = RightSquareBracket;
  balancePair$1[LeftCurlyBracket] = RightCurlyBracket;
  function isBlockOpenerToken(tokenType2) {
    return balancePair$1[tokenType2] !== 0;
  }
  class TokenStream {
    constructor(source, tokenize2) {
      this.setSource(source, tokenize2);
    }
    reset() {
      this.eof = false;
      this.tokenIndex = -1;
      this.tokenType = 0;
      this.tokenStart = this.firstCharOffset;
      this.tokenEnd = this.firstCharOffset;
    }
    setSource(source = "", tokenize2 = () => {
    }) {
      source = String(source || "");
      const sourceLength = source.length;
      const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1);
      const balance = adoptBuffer(this.balance, source.length + 1);
      let tokenCount = 0;
      let firstCharOffset = -1;
      let balanceCloseType = 0;
      let balanceStart = source.length;
      this.offsetAndType = null;
      this.balance = null;
      balance.fill(0);
      tokenize2(source, (type2, start, end) => {
        const index2 = tokenCount++;
        offsetAndType[index2] = type2 << TYPE_SHIFT | end;
        if (firstCharOffset === -1) {
          firstCharOffset = start;
        }
        balance[index2] = balanceStart;
        if (type2 === balanceCloseType) {
          const prevBalanceStart = balance[balanceStart];
          balance[balanceStart] = index2;
          balanceStart = prevBalanceStart;
          balanceCloseType = balancePair$1[offsetAndType[prevBalanceStart] >> TYPE_SHIFT];
        } else if (isBlockOpenerToken(type2)) {
          balanceStart = index2;
          balanceCloseType = balancePair$1[type2];
        }
      });
      offsetAndType[tokenCount] = EOF$1 << TYPE_SHIFT | sourceLength;
      balance[tokenCount] = tokenCount;
      for (let i2 = 0; i2 < tokenCount; i2++) {
        const balanceStart2 = balance[i2];
        if (balanceStart2 <= i2) {
          const balanceEnd = balance[balanceStart2];
          if (balanceEnd !== i2) {
            balance[i2] = balanceEnd;
          }
        } else if (balanceStart2 > tokenCount) {
          balance[i2] = tokenCount;
        }
      }
      this.source = source;
      this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
      this.tokenCount = tokenCount;
      this.offsetAndType = offsetAndType;
      this.balance = balance;
      this.reset();
      this.next();
    }
    lookupType(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return this.offsetAndType[offset] >> TYPE_SHIFT;
      }
      return EOF$1;
    }
    lookupTypeNonSC(idx) {
      for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {
        const tokenType2 = this.offsetAndType[offset] >> TYPE_SHIFT;
        if (tokenType2 !== WhiteSpace$1 && tokenType2 !== Comment$1) {
          if (idx-- === 0) {
            return tokenType2;
          }
        }
      }
      return EOF$1;
    }
    lookupOffset(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return this.offsetAndType[offset - 1] & OFFSET_MASK;
      }
      return this.source.length;
    }
    lookupOffsetNonSC(idx) {
      for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {
        const tokenType2 = this.offsetAndType[offset] >> TYPE_SHIFT;
        if (tokenType2 !== WhiteSpace$1 && tokenType2 !== Comment$1) {
          if (idx-- === 0) {
            return offset - this.tokenIndex;
          }
        }
      }
      return EOF$1;
    }
    lookupValue(offset, referenceStr) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);
      }
      return false;
    }
    getTokenStart(tokenIndex) {
      if (tokenIndex === this.tokenIndex) {
        return this.tokenStart;
      }
      if (tokenIndex > 0) {
        return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
      }
      return this.firstCharOffset;
    }
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    }
    isBalanceEdge(pos) {
      return this.balance[this.tokenIndex] < pos;
    }
    isDelim(code2, offset) {
      if (offset) {
        return this.lookupType(offset) === Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code2;
      }
      return this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === code2;
    }
    skip(tokenCount) {
      let next = this.tokenIndex + tokenCount;
      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.tokenIndex = this.tokenCount;
        this.next();
      }
    }
    next() {
      let next = this.tokenIndex + 1;
      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.tokenEnd;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.eof = true;
        this.tokenIndex = this.tokenCount;
        this.tokenType = EOF$1;
        this.tokenStart = this.tokenEnd = this.source.length;
      }
    }
    skipSC() {
      while (this.tokenType === WhiteSpace$1 || this.tokenType === Comment$1) {
        this.next();
      }
    }
    skipUntilBalanced(startToken, stopConsume) {
      let cursor = startToken;
      let balanceEnd = 0;
      let offset = 0;
      loop: for (; cursor < this.tokenCount; cursor++) {
        balanceEnd = this.balance[cursor];
        if (balanceEnd < startToken) {
          break loop;
        }
        offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
        switch (stopConsume(this.source.charCodeAt(offset))) {
          case 1:
            break loop;
          case 2:
            cursor++;
            break loop;
          default:
            if (isBlockOpenerToken(this.offsetAndType[cursor] >> TYPE_SHIFT)) {
              cursor = balanceEnd;
            }
        }
      }
      this.skip(cursor - this.tokenIndex);
    }
    forEachToken(fn2) {
      for (let i2 = 0, offset = this.firstCharOffset; i2 < this.tokenCount; i2++) {
        const start = offset;
        const item = this.offsetAndType[i2];
        const end = item & OFFSET_MASK;
        const type2 = item >> TYPE_SHIFT;
        offset = end;
        fn2(type2, start, end, i2);
      }
    }
    dump() {
      const tokens = new Array(this.tokenCount);
      this.forEachToken((type2, start, end, index2) => {
        tokens[index2] = {
          idx: index2,
          type: tokenNames[type2],
          chunk: this.source.substring(start, end),
          balance: this.balance[index2]
        };
      });
      return tokens;
    }
  }
  function tokenize$1(source, onToken) {
    function getCharCode2(offset2) {
      return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
    }
    function consumeNumericToken() {
      offset = consumeNumber(source, offset);
      if (isIdentifierStart(getCharCode2(offset), getCharCode2(offset + 1), getCharCode2(offset + 2))) {
        type2 = Dimension$1;
        offset = consumeName(source, offset);
        return;
      }
      if (getCharCode2(offset) === 37) {
        type2 = Percentage$1;
        offset++;
        return;
      }
      type2 = Number$2;
    }
    function consumeIdentLikeToken() {
      const nameStartOffset = offset;
      offset = consumeName(source, offset);
      if (cmpStr(source, nameStartOffset, offset, "url") && getCharCode2(offset) === 40) {
        offset = findWhiteSpaceEnd(source, offset + 1);
        if (getCharCode2(offset) === 34 || getCharCode2(offset) === 39) {
          type2 = Function$2;
          offset = nameStartOffset + 4;
          return;
        }
        consumeUrlToken();
        return;
      }
      if (getCharCode2(offset) === 40) {
        type2 = Function$2;
        offset++;
        return;
      }
      type2 = Ident;
    }
    function consumeStringToken(endingCodePoint) {
      if (!endingCodePoint) {
        endingCodePoint = getCharCode2(offset++);
      }
      type2 = String$2;
      for (; offset < source.length; offset++) {
        const code2 = source.charCodeAt(offset);
        switch (charCodeCategory(code2)) {
          case endingCodePoint:
            offset++;
            return;
          case WhiteSpaceCategory:
            if (isNewline(code2)) {
              offset += getNewlineLength(source, offset, code2);
              type2 = BadString;
              return;
            }
            break;
          case 92:
            if (offset === source.length - 1) {
              break;
            }
            const nextCode = getCharCode2(offset + 1);
            if (isNewline(nextCode)) {
              offset += getNewlineLength(source, offset + 1, nextCode);
            } else if (isValidEscape(code2, nextCode)) {
              offset = consumeEscaped(source, offset) - 1;
            }
            break;
        }
      }
    }
    function consumeUrlToken() {
      type2 = Url$1;
      offset = findWhiteSpaceEnd(source, offset);
      for (; offset < source.length; offset++) {
        const code2 = source.charCodeAt(offset);
        switch (charCodeCategory(code2)) {
          case 41:
            offset++;
            return;
          case WhiteSpaceCategory:
            offset = findWhiteSpaceEnd(source, offset);
            if (getCharCode2(offset) === 41 || offset >= source.length) {
              if (offset < source.length) {
                offset++;
              }
              return;
            }
            offset = consumeBadUrlRemnants(source, offset);
            type2 = BadUrl;
            return;
          case 34:
          case 39:
          case 40:
          case NonPrintableCategory:
            offset = consumeBadUrlRemnants(source, offset);
            type2 = BadUrl;
            return;
          case 92:
            if (isValidEscape(code2, getCharCode2(offset + 1))) {
              offset = consumeEscaped(source, offset) - 1;
              break;
            }
            offset = consumeBadUrlRemnants(source, offset);
            type2 = BadUrl;
            return;
        }
      }
    }
    source = String(source || "");
    const sourceLength = source.length;
    let start = isBOM(getCharCode2(0));
    let offset = start;
    let type2;
    while (offset < sourceLength) {
      const code2 = source.charCodeAt(offset);
      switch (charCodeCategory(code2)) {
        case WhiteSpaceCategory:
          type2 = WhiteSpace$1;
          offset = findWhiteSpaceEnd(source, offset + 1);
          break;
        case 34:
          consumeStringToken();
          break;
        case 35:
          if (isName(getCharCode2(offset + 1)) || isValidEscape(getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            type2 = Hash$1;
            offset = consumeName(source, offset + 1);
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 39:
          consumeStringToken();
          break;
        case 40:
          type2 = LeftParenthesis;
          offset++;
          break;
        case 41:
          type2 = RightParenthesis;
          offset++;
          break;
        case 43:
          if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            consumeNumericToken();
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 44:
          type2 = Comma;
          offset++;
          break;
        case 45:
          if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            consumeNumericToken();
          } else {
            if (getCharCode2(offset + 1) === 45 && getCharCode2(offset + 2) === 62) {
              type2 = CDC$1;
              offset = offset + 3;
            } else {
              if (isIdentifierStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
                consumeIdentLikeToken();
              } else {
                type2 = Delim;
                offset++;
              }
            }
          }
          break;
        case 46:
          if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            consumeNumericToken();
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 47:
          if (getCharCode2(offset + 1) === 42) {
            type2 = Comment$1;
            offset = source.indexOf("*/", offset + 2);
            offset = offset === -1 ? source.length : offset + 2;
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 58:
          type2 = Colon;
          offset++;
          break;
        case 59:
          type2 = Semicolon;
          offset++;
          break;
        case 60:
          if (getCharCode2(offset + 1) === 33 && getCharCode2(offset + 2) === 45 && getCharCode2(offset + 3) === 45) {
            type2 = CDO$1;
            offset = offset + 4;
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 64:
          if (isIdentifierStart(getCharCode2(offset + 1), getCharCode2(offset + 2), getCharCode2(offset + 3))) {
            type2 = AtKeyword;
            offset = consumeName(source, offset + 1);
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 91:
          type2 = LeftSquareBracket;
          offset++;
          break;
        case 92:
          if (isValidEscape(code2, getCharCode2(offset + 1))) {
            consumeIdentLikeToken();
          } else {
            type2 = Delim;
            offset++;
          }
          break;
        case 93:
          type2 = RightSquareBracket;
          offset++;
          break;
        case 123:
          type2 = LeftCurlyBracket;
          offset++;
          break;
        case 125:
          type2 = RightCurlyBracket;
          offset++;
          break;
        case DigitCategory:
          consumeNumericToken();
          break;
        case NameStartCategory:
          consumeIdentLikeToken();
          break;
        default:
          type2 = Delim;
          offset++;
      }
      onToken(type2, start, start = offset);
    }
  }
  let releasedCursors = null;
  class List {
    static createItem(data2) {
      return {
        prev: null,
        next: null,
        data: data2
      };
    }
    constructor() {
      this.head = null;
      this.tail = null;
      this.cursor = null;
    }
    createItem(data2) {
      return List.createItem(data2);
    }
    allocateCursor(prev, next) {
      let cursor;
      if (releasedCursors !== null) {
        cursor = releasedCursors;
        releasedCursors = releasedCursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = this.cursor;
      } else {
        cursor = {
          prev,
          next,
          cursor: this.cursor
        };
      }
      this.cursor = cursor;
      return cursor;
    }
    releaseCursor() {
      const { cursor } = this;
      this.cursor = cursor.cursor;
      cursor.prev = null;
      cursor.next = null;
      cursor.cursor = releasedCursors;
      releasedCursors = cursor;
    }
    updateCursors(prevOld, prevNew, nextOld, nextNew) {
      let { cursor } = this;
      while (cursor !== null) {
        if (cursor.prev === prevOld) {
          cursor.prev = prevNew;
        }
        if (cursor.next === nextOld) {
          cursor.next = nextNew;
        }
        cursor = cursor.cursor;
      }
    }
    *[Symbol.iterator]() {
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        yield cursor.data;
      }
    }
    get size() {
      let size = 0;
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        size++;
      }
      return size;
    }
    get isEmpty() {
      return this.head === null;
    }
    get first() {
      return this.head && this.head.data;
    }
    get last() {
      return this.tail && this.tail.data;
    }
    fromArray(array) {
      let cursor = null;
      this.head = null;
      for (let data2 of array) {
        const item = List.createItem(data2);
        if (cursor !== null) {
          cursor.next = item;
        } else {
          this.head = item;
        }
        item.prev = cursor;
        cursor = item;
      }
      this.tail = cursor;
      return this;
    }
    toArray() {
      return [
        ...this
      ];
    }
    toJSON() {
      return [
        ...this
      ];
    }
    forEach(fn2, thisArg = this) {
      const cursor = this.allocateCursor(null, this.head);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        fn2.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    forEachRight(fn2, thisArg = this) {
      const cursor = this.allocateCursor(this.tail, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        fn2.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    reduce(fn2, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(null, this.head);
      let acc = initialValue;
      let item;
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        acc = fn2.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    reduceRight(fn2, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(this.tail, null);
      let acc = initialValue;
      let item;
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        acc = fn2.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    some(fn2, thisArg = this) {
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        if (fn2.call(thisArg, cursor.data, cursor, this)) {
          return true;
        }
      }
      return false;
    }
    map(fn2, thisArg = this) {
      const result = new List();
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        result.appendData(fn2.call(thisArg, cursor.data, cursor, this));
      }
      return result;
    }
    filter(fn2, thisArg = this) {
      const result = new List();
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        if (fn2.call(thisArg, cursor.data, cursor, this)) {
          result.appendData(cursor.data);
        }
      }
      return result;
    }
    nextUntil(start, fn2, thisArg = this) {
      if (start === null) {
        return;
      }
      const cursor = this.allocateCursor(null, start);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        if (fn2.call(thisArg, item.data, item, this)) {
          break;
        }
      }
      this.releaseCursor();
    }
    prevUntil(start, fn2, thisArg = this) {
      if (start === null) {
        return;
      }
      const cursor = this.allocateCursor(start, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        if (fn2.call(thisArg, item.data, item, this)) {
          break;
        }
      }
      this.releaseCursor();
    }
    clear() {
      this.head = null;
      this.tail = null;
    }
    copy() {
      const result = new List();
      for (let data2 of this) {
        result.appendData(data2);
      }
      return result;
    }
    prepend(item) {
      this.updateCursors(null, item, this.head, item);
      if (this.head !== null) {
        this.head.prev = item;
        item.next = this.head;
      } else {
        this.tail = item;
      }
      this.head = item;
      return this;
    }
    prependData(data2) {
      return this.prepend(List.createItem(data2));
    }
    append(item) {
      return this.insert(item);
    }
    appendData(data2) {
      return this.insert(List.createItem(data2));
    }
    insert(item, before = null) {
      if (before !== null) {
        this.updateCursors(before.prev, item, before, item);
        if (before.prev === null) {
          if (this.head !== before) {
            throw new Error("before doesn't belong to list");
          }
          this.head = item;
          before.prev = item;
          item.next = before;
          this.updateCursors(null, item);
        } else {
          before.prev.next = item;
          item.prev = before.prev;
          before.prev = item;
          item.next = before;
        }
      } else {
        this.updateCursors(this.tail, item, null, item);
        if (this.tail !== null) {
          this.tail.next = item;
          item.prev = this.tail;
        } else {
          this.head = item;
        }
        this.tail = item;
      }
      return this;
    }
    insertData(data2, before) {
      return this.insert(List.createItem(data2), before);
    }
    remove(item) {
      this.updateCursors(item, item.prev, item, item.next);
      if (item.prev !== null) {
        item.prev.next = item.next;
      } else {
        if (this.head !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.head = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      } else {
        if (this.tail !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.tail = item.prev;
      }
      item.prev = null;
      item.next = null;
      return item;
    }
    push(data2) {
      this.insert(List.createItem(data2));
    }
    pop() {
      return this.tail !== null ? this.remove(this.tail) : null;
    }
    unshift(data2) {
      this.prepend(List.createItem(data2));
    }
    shift() {
      return this.head !== null ? this.remove(this.head) : null;
    }
    prependList(list2) {
      return this.insertList(list2, this.head);
    }
    appendList(list2) {
      return this.insertList(list2);
    }
    insertList(list2, before) {
      if (list2.head === null) {
        return this;
      }
      if (before !== void 0 && before !== null) {
        this.updateCursors(before.prev, list2.tail, before, list2.head);
        if (before.prev !== null) {
          before.prev.next = list2.head;
          list2.head.prev = before.prev;
        } else {
          this.head = list2.head;
        }
        before.prev = list2.tail;
        list2.tail.next = before;
      } else {
        this.updateCursors(this.tail, list2.tail, null, list2.head);
        if (this.tail !== null) {
          this.tail.next = list2.head;
          list2.head.prev = this.tail;
        } else {
          this.head = list2.head;
        }
        this.tail = list2.tail;
      }
      list2.head = null;
      list2.tail = null;
      return this;
    }
    replace(oldItem, newItemOrList) {
      if ("head" in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
      } else {
        this.insert(newItemOrList, oldItem);
      }
      this.remove(oldItem);
    }
  }
  function createCustomError(name2, message) {
    const error = Object.create(SyntaxError.prototype);
    const errorStack = new Error();
    return Object.assign(error, {
      name: name2,
      message,
      get stack() {
        return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name2}: ${message}
`);
      }
    });
  }
  const MAX_LINE_LENGTH = 100;
  const OFFSET_CORRECTION = 60;
  const TAB_REPLACEMENT = "    ";
  function sourceFragment({ source, line, column, baseLine, baseColumn }, extraLines) {
    function processLines(start, end) {
      return lines.slice(start, end).map((line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2).join("\n");
    }
    const prelines = "\n".repeat(Math.max(baseLine - 1, 0));
    const precolumns = " ".repeat(Math.max(baseColumn - 1, 0));
    const lines = (prelines + precolumns + source).split(/\r\n?|\n|\f/);
    const startLine = Math.max(1, line - extraLines) - 1;
    const endLine = Math.min(line + extraLines, lines.length + 1);
    const maxNumLength = Math.max(4, String(endLine).length) + 1;
    let cutLeft = 0;
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
    if (column > MAX_LINE_LENGTH) {
      cutLeft = column - OFFSET_CORRECTION + 3;
      column = OFFSET_CORRECTION - 2;
    }
    for (let i2 = startLine; i2 <= endLine; i2++) {
      if (i2 >= 0 && i2 < lines.length) {
        lines[i2] = lines[i2].replace(/\t/g, TAB_REPLACEMENT);
        lines[i2] = (cutLeft > 0 && lines[i2].length > cutLeft ? "\u2026" : "") + lines[i2].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i2].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
      }
    }
    return [
      processLines(startLine, line),
      new Array(column + maxNumLength + 2).join("-") + "^",
      processLines(line, endLine)
    ].filter(Boolean).join("\n").replace(/^(\s+\d+\s+\|\n)+/, "").replace(/\n(\s+\d+\s+\|)+$/, "");
  }
  function SyntaxError$2(message, source, offset, line, column, baseLine = 1, baseColumn = 1) {
    const error = Object.assign(createCustomError("SyntaxError", message), {
      source,
      offset,
      line,
      column,
      sourceFragment(extraLines) {
        return sourceFragment({
          source,
          line,
          column,
          baseLine,
          baseColumn
        }, isNaN(extraLines) ? 0 : extraLines);
      },
      get formattedMessage() {
        return `Parse error: ${message}
` + sourceFragment({
          source,
          line,
          column,
          baseLine,
          baseColumn
        }, 2);
      }
    });
    return error;
  }
  function readSequence(recognizer) {
    const children = this.createList();
    let space = false;
    const context2 = {
      recognizer
    };
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment$1:
          this.next();
          continue;
        case WhiteSpace$1:
          space = true;
          this.next();
          continue;
      }
      let child = recognizer.getNode.call(this, context2);
      if (child === void 0) {
        break;
      }
      if (space) {
        if (recognizer.onWhiteSpace) {
          recognizer.onWhiteSpace.call(this, child, children, context2);
        }
        space = false;
      }
      children.push(child);
    }
    if (space && recognizer.onWhiteSpace) {
      recognizer.onWhiteSpace.call(this, null, children, context2);
    }
    return children;
  }
  const NOOP = () => {
  };
  const EXCLAMATIONMARK$3 = 33;
  const NUMBERSIGN$4 = 35;
  const SEMICOLON = 59;
  const LEFTCURLYBRACKET$1 = 123;
  const NULL = 0;
  function createParseContext(name2) {
    return function() {
      return this[name2]();
    };
  }
  function fetchParseValues(dict) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const name2 of Object.keys(dict)) {
      const item = dict[name2];
      const fn2 = item.parse || item;
      if (fn2) {
        result[name2] = fn2;
      }
    }
    return result;
  }
  function processConfig(config) {
    const parseConfig = {
      context: /* @__PURE__ */ Object.create(null),
      features: Object.assign(/* @__PURE__ */ Object.create(null), config.features),
      scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
      atrule: fetchParseValues(config.atrule),
      pseudo: fetchParseValues(config.pseudo),
      node: fetchParseValues(config.node)
    };
    for (const [name2, context2] of Object.entries(config.parseContext)) {
      switch (typeof context2) {
        case "function":
          parseConfig.context[name2] = context2;
          break;
        case "string":
          parseConfig.context[name2] = createParseContext(context2);
          break;
      }
    }
    return {
      config: parseConfig,
      ...parseConfig,
      ...parseConfig.node
    };
  }
  function createParser(config) {
    let source = "";
    let filename2 = "<unknown>";
    let needPositions = false;
    let onParseError = NOOP;
    let onParseErrorThrow = false;
    const locationMap = new OffsetToLocation();
    const parser = Object.assign(new TokenStream(), processConfig(config || {}), {
      parseAtrulePrelude: true,
      parseRulePrelude: true,
      parseValue: true,
      parseCustomProperty: false,
      readSequence,
      consumeUntilBalanceEnd: () => 0,
      consumeUntilLeftCurlyBracket(code2) {
        return code2 === LEFTCURLYBRACKET$1 ? 1 : 0;
      },
      consumeUntilLeftCurlyBracketOrSemicolon(code2) {
        return code2 === LEFTCURLYBRACKET$1 || code2 === SEMICOLON ? 1 : 0;
      },
      consumeUntilExclamationMarkOrSemicolon(code2) {
        return code2 === EXCLAMATIONMARK$3 || code2 === SEMICOLON ? 1 : 0;
      },
      consumeUntilSemicolonIncluded(code2) {
        return code2 === SEMICOLON ? 2 : 0;
      },
      createList() {
        return new List();
      },
      createSingleNodeList(node2) {
        return new List().appendData(node2);
      },
      getFirstListNode(list2) {
        return list2 && list2.first;
      },
      getLastListNode(list2) {
        return list2 && list2.last;
      },
      parseWithFallback(consumer, fallback) {
        const startIndex = this.tokenIndex;
        try {
          return consumer.call(this);
        } catch (e) {
          if (onParseErrorThrow) {
            throw e;
          }
          this.skip(startIndex - this.tokenIndex);
          const fallbackNode = fallback.call(this);
          onParseErrorThrow = true;
          onParseError(e, fallbackNode);
          onParseErrorThrow = false;
          return fallbackNode;
        }
      },
      lookupNonWSType(offset) {
        let type2;
        do {
          type2 = this.lookupType(offset++);
          if (type2 !== WhiteSpace$1 && type2 !== Comment$1) {
            return type2;
          }
        } while (type2 !== NULL);
        return NULL;
      },
      charCodeAt(offset) {
        return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
      },
      substring(offsetStart, offsetEnd) {
        return source.substring(offsetStart, offsetEnd);
      },
      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      },
      cmpChar(offset, charCode) {
        return cmpChar(source, offset, charCode);
      },
      cmpStr(offsetStart, offsetEnd, str) {
        return cmpStr(source, offsetStart, offsetEnd, str);
      },
      consume(tokenType2) {
        const start = this.tokenStart;
        this.eat(tokenType2);
        return this.substrToCursor(start);
      },
      consumeFunctionName() {
        const name2 = source.substring(this.tokenStart, this.tokenEnd - 1);
        this.eat(Function$2);
        return name2;
      },
      consumeNumber(type2) {
        const number2 = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));
        this.eat(type2);
        return number2;
      },
      eat(tokenType2) {
        if (this.tokenType !== tokenType2) {
          const tokenName = tokenNames[tokenType2].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
          let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
          let offset = this.tokenStart;
          switch (tokenType2) {
            case Ident:
              if (this.tokenType === Function$2 || this.tokenType === Url$1) {
                offset = this.tokenEnd - 1;
                message = "Identifier is expected but function found";
              } else {
                message = "Identifier is expected";
              }
              break;
            case Hash$1:
              if (this.isDelim(NUMBERSIGN$4)) {
                this.next();
                offset++;
                message = "Name is expected";
              }
              break;
            case Percentage$1:
              if (this.tokenType === Number$2) {
                offset = this.tokenEnd;
                message = "Percent sign is expected";
              }
              break;
          }
          this.error(message, offset);
        }
        this.next();
      },
      eatIdent(name2) {
        if (this.tokenType !== Ident || this.lookupValue(0, name2) === false) {
          this.error(`Identifier "${name2}" is expected`);
        }
        this.next();
      },
      eatDelim(code2) {
        if (!this.isDelim(code2)) {
          this.error(`Delim "${String.fromCharCode(code2)}" is expected`);
        }
        this.next();
      },
      getLocation(start, end) {
        if (needPositions) {
          return locationMap.getLocationRange(start, end, filename2);
        }
        return null;
      },
      getLocationFromList(list2) {
        if (needPositions) {
          const head = this.getFirstListNode(list2);
          const tail = this.getLastListNode(list2);
          return locationMap.getLocationRange(head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart, tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart, filename2);
        }
        return null;
      },
      error(message, offset) {
        const location2 = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
        throw new SyntaxError$2(message || "Unexpected input", source, location2.offset, location2.line, location2.column, locationMap.startLine, locationMap.startColumn);
      }
    });
    const parse2 = function(source_, options2) {
      source = source_;
      options2 = options2 || {};
      parser.setSource(source, tokenize$1);
      locationMap.setSource(source, options2.offset, options2.line, options2.column);
      filename2 = options2.filename || "<unknown>";
      needPositions = Boolean(options2.positions);
      onParseError = typeof options2.onParseError === "function" ? options2.onParseError : NOOP;
      onParseErrorThrow = false;
      parser.parseAtrulePrelude = "parseAtrulePrelude" in options2 ? Boolean(options2.parseAtrulePrelude) : true;
      parser.parseRulePrelude = "parseRulePrelude" in options2 ? Boolean(options2.parseRulePrelude) : true;
      parser.parseValue = "parseValue" in options2 ? Boolean(options2.parseValue) : true;
      parser.parseCustomProperty = "parseCustomProperty" in options2 ? Boolean(options2.parseCustomProperty) : false;
      const { context: context2 = "default", onComment } = options2;
      if (context2 in parser.context === false) {
        throw new Error("Unknown context `" + context2 + "`");
      }
      if (typeof onComment === "function") {
        parser.forEachToken((type2, start, end) => {
          if (type2 === Comment$1) {
            const loc = parser.getLocation(start, end);
            const value2 = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
            onComment(value2, loc);
          }
        });
      }
      const ast = parser.context[context2].call(parser, options2);
      if (!parser.eof) {
        parser.error();
      }
      return ast;
    };
    return Object.assign(parse2, {
      SyntaxError: SyntaxError$2,
      config: parser.config
    });
  }
  var base64Vlq = {};
  var base64$1 = {};
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  base64$1.encode = function(number2) {
    if (0 <= number2 && number2 < intToCharMap.length) {
      return intToCharMap[number2];
    }
    throw new TypeError("Must be between 0 and 63: " + number2);
  };
  base64$1.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero2 = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero2 <= charCode && charCode <= nine) {
      return charCode - zero2 + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
  var base64 = base64$1;
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  base64Vlq.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  var util$3 = {};
  (function(exports$1) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports$1.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports$1.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url2 = "";
      if (aParsedUrl.scheme) {
        url2 += aParsedUrl.scheme + ":";
      }
      url2 += "//";
      if (aParsedUrl.auth) {
        url2 += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url2 += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url2 += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url2 += aParsedUrl.path;
      }
      return url2;
    }
    exports$1.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      var cache = [];
      return function(input) {
        for (var i2 = 0; i2 < cache.length; i2++) {
          if (cache[i2].input === input) {
            var temp = cache[0];
            cache[0] = cache[i2];
            cache[i2] = temp;
            return cache[0].result;
          }
        }
        var result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize2 = lruMemoize(function normalize3(aPath) {
      var path2 = aPath;
      var url2 = urlParse(aPath);
      if (url2) {
        if (!url2.path) {
          return aPath;
        }
        path2 = url2.path;
      }
      var isAbsolute2 = exports$1.isAbsolute(path2);
      var parts = [];
      var start = 0;
      var i2 = 0;
      while (true) {
        start = i2;
        i2 = path2.indexOf("/", start);
        if (i2 === -1) {
          parts.push(path2.slice(start));
          break;
        } else {
          parts.push(path2.slice(start, i2));
          while (i2 < path2.length && path2[i2] === "/") {
            i2++;
          }
        }
      }
      for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
        part = parts[i2];
        if (part === ".") {
          parts.splice(i2, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i2 + 1, up);
            up = 0;
          } else {
            parts.splice(i2, 2);
            up--;
          }
        }
      }
      path2 = parts.join("/");
      if (path2 === "") {
        path2 = isAbsolute2 ? "/" : ".";
      }
      if (url2) {
        url2.path = path2;
        return urlGenerate(url2);
      }
      return path2;
    });
    exports$1.normalize = normalize2;
    function join2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports$1.join = join2;
    exports$1.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index2 = aRoot.lastIndexOf("/");
        if (index2 < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index2);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports$1.relative = relative2;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports$1.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports$1.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length2 = s.length;
      if (length2 < 9) {
        return false;
      }
      if (s.charCodeAt(length2 - 1) !== 95 || s.charCodeAt(length2 - 2) !== 95 || s.charCodeAt(length2 - 3) !== 111 || s.charCodeAt(length2 - 4) !== 116 || s.charCodeAt(length2 - 5) !== 111 || s.charCodeAt(length2 - 6) !== 114 || s.charCodeAt(length2 - 7) !== 112 || s.charCodeAt(length2 - 8) !== 95 || s.charCodeAt(length2 - 9) !== 95) {
        return false;
      }
      for (var i2 = length2 - 10; i2 >= 0; i2--) {
        if (s.charCodeAt(i2) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports$1.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index2 = parsed.path.lastIndexOf("/");
          if (index2 >= 0) {
            parsed.path = parsed.path.substring(0, index2 + 1);
          }
        }
        sourceURL = join2(urlGenerate(parsed), sourceURL);
      }
      return normalize2(sourceURL);
    }
    exports$1.computeSourceURL = computeSourceURL;
  })(util$3);
  var arraySet = {};
  var util$2 = util$3;
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet$1() {
    this._array = [];
    this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  ArraySet$1.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet$1();
    for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
      set.add(aArray[i2], aAllowDuplicates);
    }
    return set;
  };
  ArraySet$1.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet$1.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util$2.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet$1.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util$2.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet$1.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util$2.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet$1.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet$1.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  arraySet.ArraySet = ArraySet$1;
  var mappingList = {};
  var util$1 = util$3;
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util$1.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList$1() {
    this._array = [];
    this._sorted = true;
    this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }
  MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList$1.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList$1.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util$1.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  mappingList.MappingList = MappingList$1;
  var base64VLQ = base64Vlq;
  var util = util$3;
  var ArraySet = arraySet.ArraySet;
  var MappingList = mappingList.MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
      file: aSourceMapConsumer.file,
      sourceRoot
    }));
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name2 = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      if (this._validateMapping(generated, original, source, name2) === false) {
        return;
      }
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name2 != null) {
      name2 = String(name2);
      if (!this._names.has(name2)) {
        this._names.add(name2);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name: name2
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = /* @__PURE__ */ Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name2 = mapping.name;
      if (name2 != null && !newNames.has(name2)) {
        newNames.add(name2);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
      if (this._ignoreInvalidMapping) {
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
        return false;
      } else {
        throw new Error(message);
      }
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      var message = "Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      });
      if (this._ignoreInvalidMapping) {
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
        return false;
      } else {
        throw new Error(message);
      }
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
      mapping = mappings[i2];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i2 > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  var SourceMapGenerator_1 = SourceMapGenerator;
  const trackNodes = /* @__PURE__ */ new Set([
    "Atrule",
    "Selector",
    "Declaration"
  ]);
  function generateSourceMap(handlers) {
    const map = new SourceMapGenerator_1();
    const generated = {
      line: 1,
      column: 0
    };
    const original = {
      line: 0,
      column: 0
    };
    const activatedGenerated = {
      line: 1,
      column: 0
    };
    const activatedMapping = {
      generated: activatedGenerated
    };
    let line = 1;
    let column = 0;
    let sourceMappingActive = false;
    const origHandlersNode = handlers.node;
    handlers.node = function(node2) {
      if (node2.loc && node2.loc.start && trackNodes.has(node2.type)) {
        const nodeLine = node2.loc.start.line;
        const nodeColumn = node2.loc.start.column - 1;
        if (original.line !== nodeLine || original.column !== nodeColumn) {
          original.line = nodeLine;
          original.column = nodeColumn;
          generated.line = line;
          generated.column = column;
          if (sourceMappingActive) {
            sourceMappingActive = false;
            if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
              map.addMapping(activatedMapping);
            }
          }
          sourceMappingActive = true;
          map.addMapping({
            source: node2.loc.source,
            original,
            generated
          });
        }
      }
      origHandlersNode.call(this, node2);
      if (sourceMappingActive && trackNodes.has(node2.type)) {
        activatedGenerated.line = line;
        activatedGenerated.column = column;
      }
    };
    const origHandlersEmit = handlers.emit;
    handlers.emit = function(value2, type2, auto) {
      for (let i2 = 0; i2 < value2.length; i2++) {
        if (value2.charCodeAt(i2) === 10) {
          line++;
          column = 0;
        } else {
          column++;
        }
      }
      origHandlersEmit(value2, type2, auto);
    };
    const origHandlersResult = handlers.result;
    handlers.result = function() {
      if (sourceMappingActive) {
        map.addMapping(activatedMapping);
      }
      return {
        css: origHandlersResult(),
        map
      };
    };
    return handlers;
  }
  const PLUSSIGN$9 = 43;
  const HYPHENMINUS$6 = 45;
  const code = (type2, value2) => {
    if (type2 === Delim) {
      type2 = value2;
    }
    if (typeof type2 === "string") {
      const charCode = type2.charCodeAt(0);
      return charCode > 127 ? 32768 : charCode << 8;
    }
    return type2;
  };
  const specPairs = [
    [
      Ident,
      Ident
    ],
    [
      Ident,
      Function$2
    ],
    [
      Ident,
      Url$1
    ],
    [
      Ident,
      BadUrl
    ],
    [
      Ident,
      "-"
    ],
    [
      Ident,
      Number$2
    ],
    [
      Ident,
      Percentage$1
    ],
    [
      Ident,
      Dimension$1
    ],
    [
      Ident,
      CDC$1
    ],
    [
      Ident,
      LeftParenthesis
    ],
    [
      AtKeyword,
      Ident
    ],
    [
      AtKeyword,
      Function$2
    ],
    [
      AtKeyword,
      Url$1
    ],
    [
      AtKeyword,
      BadUrl
    ],
    [
      AtKeyword,
      "-"
    ],
    [
      AtKeyword,
      Number$2
    ],
    [
      AtKeyword,
      Percentage$1
    ],
    [
      AtKeyword,
      Dimension$1
    ],
    [
      AtKeyword,
      CDC$1
    ],
    [
      Hash$1,
      Ident
    ],
    [
      Hash$1,
      Function$2
    ],
    [
      Hash$1,
      Url$1
    ],
    [
      Hash$1,
      BadUrl
    ],
    [
      Hash$1,
      "-"
    ],
    [
      Hash$1,
      Number$2
    ],
    [
      Hash$1,
      Percentage$1
    ],
    [
      Hash$1,
      Dimension$1
    ],
    [
      Hash$1,
      CDC$1
    ],
    [
      Dimension$1,
      Ident
    ],
    [
      Dimension$1,
      Function$2
    ],
    [
      Dimension$1,
      Url$1
    ],
    [
      Dimension$1,
      BadUrl
    ],
    [
      Dimension$1,
      "-"
    ],
    [
      Dimension$1,
      Number$2
    ],
    [
      Dimension$1,
      Percentage$1
    ],
    [
      Dimension$1,
      Dimension$1
    ],
    [
      Dimension$1,
      CDC$1
    ],
    [
      "#",
      Ident
    ],
    [
      "#",
      Function$2
    ],
    [
      "#",
      Url$1
    ],
    [
      "#",
      BadUrl
    ],
    [
      "#",
      "-"
    ],
    [
      "#",
      Number$2
    ],
    [
      "#",
      Percentage$1
    ],
    [
      "#",
      Dimension$1
    ],
    [
      "#",
      CDC$1
    ],
    [
      "-",
      Ident
    ],
    [
      "-",
      Function$2
    ],
    [
      "-",
      Url$1
    ],
    [
      "-",
      BadUrl
    ],
    [
      "-",
      "-"
    ],
    [
      "-",
      Number$2
    ],
    [
      "-",
      Percentage$1
    ],
    [
      "-",
      Dimension$1
    ],
    [
      "-",
      CDC$1
    ],
    [
      Number$2,
      Ident
    ],
    [
      Number$2,
      Function$2
    ],
    [
      Number$2,
      Url$1
    ],
    [
      Number$2,
      BadUrl
    ],
    [
      Number$2,
      Number$2
    ],
    [
      Number$2,
      Percentage$1
    ],
    [
      Number$2,
      Dimension$1
    ],
    [
      Number$2,
      "%"
    ],
    [
      Number$2,
      CDC$1
    ],
    [
      "@",
      Ident
    ],
    [
      "@",
      Function$2
    ],
    [
      "@",
      Url$1
    ],
    [
      "@",
      BadUrl
    ],
    [
      "@",
      "-"
    ],
    [
      "@",
      CDC$1
    ],
    [
      ".",
      Number$2
    ],
    [
      ".",
      Percentage$1
    ],
    [
      ".",
      Dimension$1
    ],
    [
      "+",
      Number$2
    ],
    [
      "+",
      Percentage$1
    ],
    [
      "+",
      Dimension$1
    ],
    [
      "/",
      "*"
    ]
  ];
  const safePairs = specPairs.concat([
    [
      Ident,
      Hash$1
    ],
    [
      Dimension$1,
      Hash$1
    ],
    [
      Hash$1,
      Hash$1
    ],
    [
      AtKeyword,
      LeftParenthesis
    ],
    [
      AtKeyword,
      String$2
    ],
    [
      AtKeyword,
      Colon
    ],
    [
      Percentage$1,
      Percentage$1
    ],
    [
      Percentage$1,
      Dimension$1
    ],
    [
      Percentage$1,
      Function$2
    ],
    [
      Percentage$1,
      "-"
    ],
    [
      RightParenthesis,
      Ident
    ],
    [
      RightParenthesis,
      Function$2
    ],
    [
      RightParenthesis,
      Percentage$1
    ],
    [
      RightParenthesis,
      Dimension$1
    ],
    [
      RightParenthesis,
      Hash$1
    ],
    [
      RightParenthesis,
      "-"
    ]
  ]);
  function createMap(pairs) {
    const isWhiteSpaceRequired = new Set(pairs.map(([prev, next]) => code(prev) << 16 | code(next)));
    return function(prevCode, type2, value2) {
      const nextCode = code(type2, value2);
      const nextCharCode = value2.charCodeAt(0);
      const emitWs = nextCharCode === HYPHENMINUS$6 && type2 !== Ident && type2 !== Function$2 && type2 !== CDC$1 || nextCharCode === PLUSSIGN$9 ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
      if (emitWs) {
        this.emit(" ", WhiteSpace$1, true);
      }
      return nextCode;
    };
  }
  const spec = createMap(specPairs);
  const safe = createMap(safePairs);
  const tokenBefore = Object.freeze(Object.defineProperty({
    __proto__: null,
    safe,
    spec
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const REVERSESOLIDUS = 92;
  function processChildren(node2, delimeter) {
    if (typeof delimeter === "function") {
      let prev = null;
      node2.children.forEach((node3) => {
        if (prev !== null) {
          delimeter.call(this, prev);
        }
        this.node(node3);
        prev = node3;
      });
      return;
    }
    node2.children.forEach(this.node, this);
  }
  function processChunk(chunk) {
    tokenize$1(chunk, (type2, start, end) => {
      this.token(type2, chunk.slice(start, end));
    });
  }
  function createGenerator(config) {
    const types2 = /* @__PURE__ */ new Map();
    for (let [name2, item] of Object.entries(config.node)) {
      const fn2 = item.generate || item;
      if (typeof fn2 === "function") {
        types2.set(name2, item.generate || item);
      }
    }
    return function(node2, options2) {
      let buffer2 = "";
      let prevCode = 0;
      let handlers = {
        node(node3) {
          if (types2.has(node3.type)) {
            types2.get(node3.type).call(publicApi, node3);
          } else {
            throw new Error("Unknown node type: " + node3.type);
          }
        },
        tokenBefore: safe,
        token(type2, value2) {
          prevCode = this.tokenBefore(prevCode, type2, value2);
          this.emit(value2, type2, false);
          if (type2 === Delim && value2.charCodeAt(0) === REVERSESOLIDUS) {
            this.emit("\n", WhiteSpace$1, true);
          }
        },
        emit(value2) {
          buffer2 += value2;
        },
        result() {
          return buffer2;
        }
      };
      if (options2) {
        if (typeof options2.decorator === "function") {
          handlers = options2.decorator(handlers);
        }
        if (options2.sourceMap) {
          handlers = generateSourceMap(handlers);
        }
        if (options2.mode in tokenBefore) {
          handlers.tokenBefore = tokenBefore[options2.mode];
        }
      }
      const publicApi = {
        node: (node3) => handlers.node(node3),
        children: processChildren,
        token: (type2, value2) => handlers.token(type2, value2),
        tokenize: processChunk
      };
      handlers.node(node2);
      return handlers.result();
    };
  }
  function createConvertor(walk2) {
    return {
      fromPlainObject(ast) {
        walk2(ast, {
          enter(node2) {
            if (node2.children && node2.children instanceof List === false) {
              node2.children = new List().fromArray(node2.children);
            }
          }
        });
        return ast;
      },
      toPlainObject(ast) {
        walk2(ast, {
          leave(node2) {
            if (node2.children && node2.children instanceof List) {
              node2.children = node2.children.toArray();
            }
          }
        });
        return ast;
      }
    };
  }
  const { hasOwnProperty: hasOwnProperty$3 } = Object.prototype;
  const noop$2 = function() {
  };
  function ensureFunction$1(value2) {
    return typeof value2 === "function" ? value2 : noop$2;
  }
  function invokeForType(fn2, type2) {
    return function(node2, item, list2) {
      if (node2.type === type2) {
        fn2.call(this, node2, item, list2);
      }
    };
  }
  function getWalkersFromStructure(name2, nodeType) {
    const structure2 = nodeType.structure;
    const walkers = [];
    for (const key in structure2) {
      if (hasOwnProperty$3.call(structure2, key) === false) {
        continue;
      }
      let fieldTypes = structure2[key];
      const walker = {
        name: key,
        type: false,
        nullable: false
      };
      if (!Array.isArray(fieldTypes)) {
        fieldTypes = [
          fieldTypes
        ];
      }
      for (const fieldType of fieldTypes) {
        if (fieldType === null) {
          walker.nullable = true;
        } else if (typeof fieldType === "string") {
          walker.type = "node";
        } else if (Array.isArray(fieldType)) {
          walker.type = "list";
        }
      }
      if (walker.type) {
        walkers.push(walker);
      }
    }
    if (walkers.length) {
      return {
        context: nodeType.walkContext,
        fields: walkers
      };
    }
    return null;
  }
  function getTypesFromConfig(config) {
    const types2 = {};
    for (const name2 in config.node) {
      if (hasOwnProperty$3.call(config.node, name2)) {
        const nodeType = config.node[name2];
        if (!nodeType.structure) {
          throw new Error("Missed `structure` field in `" + name2 + "` node type definition");
        }
        types2[name2] = getWalkersFromStructure(name2, nodeType);
      }
    }
    return types2;
  }
  function createTypeIterator(config, reverse2) {
    const fields = config.fields.slice();
    const contextName = config.context;
    const useContext = typeof contextName === "string";
    if (reverse2) {
      fields.reverse();
    }
    return function(node2, context2, walk2, walkReducer) {
      let prevContextValue;
      if (useContext) {
        prevContextValue = context2[contextName];
        context2[contextName] = node2;
      }
      for (const field of fields) {
        const ref2 = node2[field.name];
        if (!field.nullable || ref2) {
          if (field.type === "list") {
            const breakWalk = reverse2 ? ref2.reduceRight(walkReducer, false) : ref2.reduce(walkReducer, false);
            if (breakWalk) {
              return true;
            }
          } else if (walk2(ref2)) {
            return true;
          }
        }
      }
      if (useContext) {
        context2[contextName] = prevContextValue;
      }
    };
  }
  function createFastTraveralMap({ StyleSheet: StyleSheet2, Atrule: Atrule2, Rule: Rule2, Block: Block2, DeclarationList: DeclarationList2 }) {
    return {
      Atrule: {
        StyleSheet: StyleSheet2,
        Atrule: Atrule2,
        Rule: Rule2,
        Block: Block2
      },
      Rule: {
        StyleSheet: StyleSheet2,
        Atrule: Atrule2,
        Rule: Rule2,
        Block: Block2
      },
      Declaration: {
        StyleSheet: StyleSheet2,
        Atrule: Atrule2,
        Rule: Rule2,
        Block: Block2,
        DeclarationList: DeclarationList2
      }
    };
  }
  function createWalker(config) {
    const types2 = getTypesFromConfig(config);
    const iteratorsNatural = {};
    const iteratorsReverse = {};
    const breakWalk = Symbol("break-walk");
    const skipNode = Symbol("skip-node");
    for (const name2 in types2) {
      if (hasOwnProperty$3.call(types2, name2) && types2[name2] !== null) {
        iteratorsNatural[name2] = createTypeIterator(types2[name2], false);
        iteratorsReverse[name2] = createTypeIterator(types2[name2], true);
      }
    }
    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
    const walk2 = function(root, options2) {
      function walkNode(node2, item, list2) {
        const enterRet = enter.call(context2, node2, item, list2);
        if (enterRet === breakWalk) {
          return true;
        }
        if (enterRet === skipNode) {
          return false;
        }
        if (iterators.hasOwnProperty(node2.type)) {
          if (iterators[node2.type](node2, context2, walkNode, walkReducer)) {
            return true;
          }
        }
        if (leave.call(context2, node2, item, list2) === breakWalk) {
          return true;
        }
        return false;
      }
      let enter = noop$2;
      let leave = noop$2;
      let iterators = iteratorsNatural;
      let walkReducer = (ret, data2, item, list2) => ret || walkNode(data2, item, list2);
      const context2 = {
        break: breakWalk,
        skip: skipNode,
        root,
        stylesheet: null,
        atrule: null,
        atrulePrelude: null,
        rule: null,
        selector: null,
        block: null,
        declaration: null,
        function: null
      };
      if (typeof options2 === "function") {
        enter = options2;
      } else if (options2) {
        enter = ensureFunction$1(options2.enter);
        leave = ensureFunction$1(options2.leave);
        if (options2.reverse) {
          iterators = iteratorsReverse;
        }
        if (options2.visit) {
          if (fastTraversalIteratorsNatural.hasOwnProperty(options2.visit)) {
            iterators = options2.reverse ? fastTraversalIteratorsReverse[options2.visit] : fastTraversalIteratorsNatural[options2.visit];
          } else if (!types2.hasOwnProperty(options2.visit)) {
            throw new Error("Bad value `" + options2.visit + "` for `visit` option (should be: " + Object.keys(types2).sort().join(", ") + ")");
          }
          enter = invokeForType(enter, options2.visit);
          leave = invokeForType(leave, options2.visit);
        }
      }
      if (enter === noop$2 && leave === noop$2) {
        throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
      }
      walkNode(root);
    };
    walk2.break = breakWalk;
    walk2.skip = skipNode;
    walk2.find = function(ast, fn2) {
      let found = null;
      walk2(ast, function(node2, item, list2) {
        if (fn2.call(this, node2, item, list2)) {
          found = node2;
          return breakWalk;
        }
      });
      return found;
    };
    walk2.findLast = function(ast, fn2) {
      let found = null;
      walk2(ast, {
        reverse: true,
        enter(node2, item, list2) {
          if (fn2.call(this, node2, item, list2)) {
            found = node2;
            return breakWalk;
          }
        }
      });
      return found;
    };
    walk2.findAll = function(ast, fn2) {
      const found = [];
      walk2(ast, function(node2, item, list2) {
        if (fn2.call(this, node2, item, list2)) {
          found.push(node2);
        }
      });
      return found;
    };
    return walk2;
  }
  function noop$1(value2) {
    return value2;
  }
  function generateMultiplier(multiplier) {
    const { min, max, comma } = multiplier;
    if (min === 0 && max === 0) {
      return comma ? "#?" : "*";
    }
    if (min === 0 && max === 1) {
      return "?";
    }
    if (min === 1 && max === 0) {
      return comma ? "#" : "+";
    }
    if (min === 1 && max === 1) {
      return "";
    }
    return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
  }
  function generateTypeOpts(node2) {
    switch (node2.type) {
      case "Range":
        return " [" + (node2.min === null ? "-\u221E" : node2.min) + "," + (node2.max === null ? "\u221E" : node2.max) + "]";
      default:
        throw new Error("Unknown node type `" + node2.type + "`");
    }
  }
  function generateSequence(node2, decorate, forceBraces, compact) {
    const combinator = node2.combinator === " " || compact ? node2.combinator : " " + node2.combinator + " ";
    const result = node2.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
    if (node2.explicit || forceBraces) {
      return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
    }
    return result;
  }
  function internalGenerate(node2, decorate, forceBraces, compact) {
    let result;
    switch (node2.type) {
      case "Group":
        result = generateSequence(node2, decorate, forceBraces, compact) + (node2.disallowEmpty ? "!" : "");
        break;
      case "Multiplier":
        return internalGenerate(node2.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node2), node2);
      case "Boolean":
        result = "<boolean-expr[" + internalGenerate(node2.term, decorate, forceBraces, compact) + "]>";
        break;
      case "Type":
        result = "<" + node2.name + (node2.opts ? decorate(generateTypeOpts(node2.opts), node2.opts) : "") + ">";
        break;
      case "Property":
        result = "<'" + node2.name + "'>";
        break;
      case "Keyword":
        result = node2.name;
        break;
      case "AtKeyword":
        result = "@" + node2.name;
        break;
      case "Function":
        result = node2.name + "(";
        break;
      case "String":
      case "Token":
        result = node2.value;
        break;
      case "Comma":
        result = ",";
        break;
      default:
        throw new Error("Unknown node type `" + node2.type + "`");
    }
    return decorate(result, node2);
  }
  function generate$O(node2, options2) {
    let decorate = noop$1;
    let forceBraces = false;
    let compact = false;
    if (typeof options2 === "function") {
      decorate = options2;
    } else if (options2) {
      forceBraces = Boolean(options2.forceBraces);
      compact = Boolean(options2.compact);
      if (typeof options2.decorate === "function") {
        decorate = options2.decorate;
      }
    }
    return internalGenerate(node2, decorate, forceBraces, compact);
  }
  const defaultLoc = {
    offset: 0,
    line: 1,
    column: 1
  };
  function locateMismatch(matchResult, node2) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node2 ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = "";
    let start;
    let end;
    for (let i2 = 0; i2 < tokens.length; i2++) {
      const token = tokens[i2].value;
      if (i2 === longestMatch) {
        mismatchLength = token.length;
        mismatchOffset = css.length;
      }
      if (badNode !== null && tokens[i2].node === badNode) {
        if (i2 <= longestMatch) {
          entries++;
        } else {
          entries = 0;
        }
      }
      css += token;
    }
    if (longestMatch === tokens.length || entries > 1) {
      start = fromLoc(badNode || node2, "end") || buildLoc(defaultLoc, css);
      end = buildLoc(start);
    } else {
      start = fromLoc(badNode, "start") || buildLoc(fromLoc(node2, "start") || defaultLoc, css.slice(0, mismatchOffset));
      end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }
    return {
      css,
      mismatchOffset,
      mismatchLength,
      start,
      end
    };
  }
  function fromLoc(node2, point) {
    const value2 = node2 && node2.loc && node2.loc[point];
    if (value2) {
      return "line" in value2 ? buildLoc(value2) : value2;
    }
    return null;
  }
  function buildLoc({ offset, line, column }, extra) {
    const loc = {
      offset,
      line,
      column
    };
    if (extra) {
      const lines = extra.split(/\n|\r\n?|\f/);
      loc.offset += extra.length;
      loc.line += lines.length - 1;
      loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }
    return loc;
  }
  const SyntaxReferenceError = function(type2, referenceName) {
    const error = createCustomError("SyntaxReferenceError", type2 + (referenceName ? " `" + referenceName + "`" : ""));
    error.reference = referenceName;
    return error;
  };
  const SyntaxMatchError = function(message, syntax2, node2, matchResult) {
    const error = createCustomError("SyntaxMatchError", message);
    const { css, mismatchOffset, mismatchLength, start, end } = locateMismatch(matchResult, node2);
    error.rawMessage = message;
    error.syntax = syntax2 ? generate$O(syntax2) : "<generic>";
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
    Object.assign(error, start);
    error.loc = {
      source: node2 && node2.loc && node2.loc.source || "<unknown>",
      start,
      end
    };
    return error;
  };
  const keywords = /* @__PURE__ */ new Map();
  const properties = /* @__PURE__ */ new Map();
  const HYPHENMINUS$5 = 45;
  const keyword = getKeywordDescriptor;
  const property = getPropertyDescriptor;
  function isCustomProperty(str, offset) {
    offset = offset || 0;
    return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS$5 && str.charCodeAt(offset + 1) === HYPHENMINUS$5;
  }
  function getVendorPrefix(str, offset) {
    offset = offset || 0;
    if (str.length - offset >= 3) {
      if (str.charCodeAt(offset) === HYPHENMINUS$5 && str.charCodeAt(offset + 1) !== HYPHENMINUS$5) {
        const secondDashIndex = str.indexOf("-", offset + 2);
        if (secondDashIndex !== -1) {
          return str.substring(offset, secondDashIndex + 1);
        }
      }
    }
    return "";
  }
  function getKeywordDescriptor(keyword2) {
    if (keywords.has(keyword2)) {
      return keywords.get(keyword2);
    }
    const name2 = keyword2.toLowerCase();
    let descriptor = keywords.get(name2);
    if (descriptor === void 0) {
      const custom = isCustomProperty(name2, 0);
      const vendor = !custom ? getVendorPrefix(name2, 0) : "";
      descriptor = Object.freeze({
        basename: name2.substr(vendor.length),
        name: name2,
        prefix: vendor,
        vendor,
        custom
      });
    }
    keywords.set(keyword2, descriptor);
    return descriptor;
  }
  function getPropertyDescriptor(property2) {
    if (properties.has(property2)) {
      return properties.get(property2);
    }
    let name2 = property2;
    let hack = property2[0];
    if (hack === "/") {
      hack = property2[1] === "/" ? "//" : "/";
    } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
      hack = "";
    }
    const custom = isCustomProperty(name2, hack.length);
    if (!custom) {
      name2 = name2.toLowerCase();
      if (properties.has(name2)) {
        const descriptor2 = properties.get(name2);
        properties.set(property2, descriptor2);
        return descriptor2;
      }
    }
    const vendor = !custom ? getVendorPrefix(name2, hack.length) : "";
    const prefix = name2.substr(0, hack.length + vendor.length);
    const descriptor = Object.freeze({
      basename: name2.substr(prefix.length),
      name: name2.substr(hack.length),
      hack,
      vendor,
      prefix,
      custom
    });
    properties.set(property2, descriptor);
    return descriptor;
  }
  const cssWideKeywords = [
    "initial",
    "inherit",
    "unset",
    "revert",
    "revert-layer"
  ];
  const PLUSSIGN$8 = 43;
  const HYPHENMINUS$4 = 45;
  const N$3 = 110;
  const DISALLOW_SIGN$1 = true;
  const ALLOW_SIGN$1 = false;
  function isDelim$1(token, code2) {
    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
  }
  function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === WhiteSpace$1 || token.type === Comment$1)) {
      token = getNextToken(++offset);
    }
    return offset;
  }
  function checkInteger$1(token, valueOffset, disallowSign, offset) {
    if (!token) {
      return 0;
    }
    const code2 = token.value.charCodeAt(valueOffset);
    if (code2 === PLUSSIGN$8 || code2 === HYPHENMINUS$4) {
      if (disallowSign) {
        return 0;
      }
      valueOffset++;
    }
    for (; valueOffset < token.value.length; valueOffset++) {
      if (!isDigit(token.value.charCodeAt(valueOffset))) {
        return 0;
      }
    }
    return offset + 1;
  }
  function consumeB$1(token, offset_, getNextToken) {
    let sign2 = false;
    let offset = skipSC(token, offset_, getNextToken);
    token = getNextToken(offset);
    if (token === null) {
      return offset_;
    }
    if (token.type !== Number$2) {
      if (isDelim$1(token, PLUSSIGN$8) || isDelim$1(token, HYPHENMINUS$4)) {
        sign2 = true;
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        if (token === null || token.type !== Number$2) {
          return 0;
        }
      } else {
        return offset_;
      }
    }
    if (!sign2) {
      const code2 = token.value.charCodeAt(0);
      if (code2 !== PLUSSIGN$8 && code2 !== HYPHENMINUS$4) {
        return 0;
      }
    }
    return checkInteger$1(token, sign2 ? 0 : 1, sign2, offset);
  }
  function anPlusB(token, getNextToken) {
    let offset = 0;
    if (!token) {
      return 0;
    }
    if (token.type === Number$2) {
      return checkInteger$1(token, 0, ALLOW_SIGN$1, offset);
    } else if (token.type === Ident && token.value.charCodeAt(0) === HYPHENMINUS$4) {
      if (!cmpChar(token.value, 1, N$3)) {
        return 0;
      }
      switch (token.value.length) {
        case 2:
          return consumeB$1(getNextToken(++offset), offset, getNextToken);
        case 3:
          if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
            return 0;
          }
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
        default:
          if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
            return 0;
          }
          return checkInteger$1(token, 3, DISALLOW_SIGN$1, offset);
      }
    } else if (token.type === Ident || isDelim$1(token, PLUSSIGN$8) && getNextToken(offset + 1).type === Ident) {
      if (token.type !== Ident) {
        token = getNextToken(++offset);
      }
      if (token === null || !cmpChar(token.value, 0, N$3)) {
        return 0;
      }
      switch (token.value.length) {
        case 1:
          return consumeB$1(getNextToken(++offset), offset, getNextToken);
        case 2:
          if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
            return 0;
          }
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
        default:
          if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
            return 0;
          }
          return checkInteger$1(token, 2, DISALLOW_SIGN$1, offset);
      }
    } else if (token.type === Dimension$1) {
      let code2 = token.value.charCodeAt(0);
      let sign2 = code2 === PLUSSIGN$8 || code2 === HYPHENMINUS$4 ? 1 : 0;
      let i2 = sign2;
      for (; i2 < token.value.length; i2++) {
        if (!isDigit(token.value.charCodeAt(i2))) {
          break;
        }
      }
      if (i2 === sign2) {
        return 0;
      }
      if (!cmpChar(token.value, i2, N$3)) {
        return 0;
      }
      if (i2 + 1 === token.value.length) {
        return consumeB$1(getNextToken(++offset), offset, getNextToken);
      } else {
        if (token.value.charCodeAt(i2 + 1) !== HYPHENMINUS$4) {
          return 0;
        }
        if (i2 + 2 === token.value.length) {
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
        } else {
          return checkInteger$1(token, i2 + 2, DISALLOW_SIGN$1, offset);
        }
      }
    }
    return 0;
  }
  const PLUSSIGN$7 = 43;
  const HYPHENMINUS$3 = 45;
  const QUESTIONMARK$2 = 63;
  const U$1 = 117;
  function isDelim(token, code2) {
    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
  }
  function startsWith$1(token, code2) {
    return token.value.charCodeAt(0) === code2;
  }
  function hexSequence(token, offset, allowDash) {
    let hexlen = 0;
    for (let pos = offset; pos < token.value.length; pos++) {
      const code2 = token.value.charCodeAt(pos);
      if (code2 === HYPHENMINUS$3 && allowDash && hexlen !== 0) {
        hexSequence(token, offset + hexlen + 1, false);
        return 6;
      }
      if (!isHexDigit(code2)) {
        return 0;
      }
      if (++hexlen > 6) {
        return 0;
      }
    }
    return hexlen;
  }
  function withQuestionMarkSequence(consumed, length2, getNextToken) {
    if (!consumed) {
      return 0;
    }
    while (isDelim(getNextToken(length2), QUESTIONMARK$2)) {
      if (++consumed > 6) {
        return 0;
      }
      length2++;
    }
    return length2;
  }
  function urange(token, getNextToken) {
    let length2 = 0;
    if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U$1)) {
      return 0;
    }
    token = getNextToken(++length2);
    if (token === null) {
      return 0;
    }
    if (isDelim(token, PLUSSIGN$7)) {
      token = getNextToken(++length2);
      if (token === null) {
        return 0;
      }
      if (token.type === Ident) {
        return withQuestionMarkSequence(hexSequence(token, 0, true), ++length2, getNextToken);
      }
      if (isDelim(token, QUESTIONMARK$2)) {
        return withQuestionMarkSequence(1, ++length2, getNextToken);
      }
      return 0;
    }
    if (token.type === Number$2) {
      const consumedHexLength = hexSequence(token, 1, true);
      if (consumedHexLength === 0) {
        return 0;
      }
      token = getNextToken(++length2);
      if (token === null) {
        return length2;
      }
      if (token.type === Dimension$1 || token.type === Number$2) {
        if (!startsWith$1(token, HYPHENMINUS$3) || !hexSequence(token, 1, false)) {
          return 0;
        }
        return length2 + 1;
      }
      return withQuestionMarkSequence(consumedHexLength, length2, getNextToken);
    }
    if (token.type === Dimension$1) {
      return withQuestionMarkSequence(hexSequence(token, 1, true), ++length2, getNextToken);
    }
    return 0;
  }
  const calcFunctionNames = [
    "calc(",
    "-moz-calc(",
    "-webkit-calc("
  ];
  const balancePair = /* @__PURE__ */ new Map([
    [
      Function$2,
      RightParenthesis
    ],
    [
      LeftParenthesis,
      RightParenthesis
    ],
    [
      LeftSquareBracket,
      RightSquareBracket
    ],
    [
      LeftCurlyBracket,
      RightCurlyBracket
    ]
  ]);
  function charCodeAt(str, index2) {
    return index2 < str.length ? str.charCodeAt(index2) : 0;
  }
  function eqStr(actual, expected) {
    return cmpStr(actual, 0, actual.length, expected);
  }
  function eqStrAny(actual, expected) {
    for (let i2 = 0; i2 < expected.length; i2++) {
      if (eqStr(actual, expected[i2])) {
        return true;
      }
    }
    return false;
  }
  function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
      return false;
    }
    return charCodeAt(str, offset) === 92 && isDigit(charCodeAt(str, offset + 1));
  }
  function outOfRange(opts, value2, numEnd) {
    if (opts && opts.type === "Range") {
      const num = Number(numEnd !== void 0 && numEnd !== value2.length ? value2.substr(0, numEnd) : value2);
      if (isNaN(num)) {
        return true;
      }
      if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
        return true;
      }
      if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
        return true;
      }
    }
    return false;
  }
  function consumeFunction(token, getNextToken) {
    let balanceCloseType = 0;
    let balanceStash = [];
    let length2 = 0;
    scan: do {
      switch (token.type) {
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          if (balanceStash.length === 0) {
            length2++;
            break scan;
          }
          break;
        case Function$2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
    return length2;
  }
  function calc(next) {
    return function(token, getNextToken, opts) {
      if (token === null) {
        return 0;
      }
      if (token.type === Function$2 && eqStrAny(token.value, calcFunctionNames)) {
        return consumeFunction(token, getNextToken);
      }
      return next(token, getNextToken, opts);
    };
  }
  function tokenType(expectedTokenType) {
    return function(token) {
      if (token === null || token.type !== expectedTokenType) {
        return 0;
      }
      return 1;
    };
  }
  function customIdent(token) {
    if (token === null || token.type !== Ident) {
      return 0;
    }
    const name2 = token.value.toLowerCase();
    if (eqStrAny(name2, cssWideKeywords)) {
      return 0;
    }
    if (eqStr(name2, "default")) {
      return 0;
    }
    return 1;
  }
  function dashedIdent(token) {
    if (token === null || token.type !== Ident) {
      return 0;
    }
    if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
      return 0;
    }
    return 1;
  }
  function customPropertyName(token) {
    if (!dashedIdent(token)) {
      return 0;
    }
    if (token.value === "--") {
      return 0;
    }
    return 1;
  }
  function hexColor(token) {
    if (token === null || token.type !== Hash$1) {
      return 0;
    }
    const length2 = token.value.length;
    if (length2 !== 4 && length2 !== 5 && length2 !== 7 && length2 !== 9) {
      return 0;
    }
    for (let i2 = 1; i2 < length2; i2++) {
      if (!isHexDigit(charCodeAt(token.value, i2))) {
        return 0;
      }
    }
    return 1;
  }
  function idSelector(token) {
    if (token === null || token.type !== Hash$1) {
      return 0;
    }
    if (!isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
      return 0;
    }
    return 1;
  }
  function declarationValue(token, getNextToken) {
    if (!token) {
      return 0;
    }
    let balanceCloseType = 0;
    let balanceStash = [];
    let length2 = 0;
    scan: do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Semicolon:
          if (balanceCloseType === 0) {
            break scan;
          }
          break;
        case Delim:
          if (balanceCloseType === 0 && token.value === "!") {
            break scan;
          }
          break;
        case Function$2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
    return length2;
  }
  function anyValue(token, getNextToken) {
    if (!token) {
      return 0;
    }
    let balanceCloseType = 0;
    let balanceStash = [];
    let length2 = 0;
    scan: do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Function$2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
    return length2;
  }
  function dimension(type2) {
    if (type2) {
      type2 = new Set(type2);
    }
    return function(token, getNextToken, opts) {
      if (token === null || token.type !== Dimension$1) {
        return 0;
      }
      const numberEnd = consumeNumber(token.value, 0);
      if (type2 !== null) {
        const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
        const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
        if (type2.has(unit.toLowerCase()) === false) {
          return 0;
        }
      }
      if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
      }
      return 1;
    };
  }
  function percentage(token, getNextToken, opts) {
    if (token === null || token.type !== Percentage$1) {
      return 0;
    }
    if (outOfRange(opts, token.value, token.value.length - 1)) {
      return 0;
    }
    return 1;
  }
  function zero(next) {
    if (typeof next !== "function") {
      next = function() {
        return 0;
      };
    }
    return function(token, getNextToken, opts) {
      if (token !== null && token.type === Number$2) {
        if (Number(token.value) === 0) {
          return 1;
        }
      }
      return next(token, getNextToken, opts);
    };
  }
  function number(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    const numberEnd = consumeNumber(token.value, 0);
    const isNumber2 = numberEnd === token.value.length;
    if (!isNumber2 && !isPostfixIeHack(token.value, numberEnd)) {
      return 0;
    }
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  }
  function integer(token, getNextToken, opts) {
    if (token === null || token.type !== Number$2) {
      return 0;
    }
    let i2 = charCodeAt(token.value, 0) === 43 || charCodeAt(token.value, 0) === 45 ? 1 : 0;
    for (; i2 < token.value.length; i2++) {
      if (!isDigit(charCodeAt(token.value, i2))) {
        return 0;
      }
    }
    if (outOfRange(opts, token.value, i2)) {
      return 0;
    }
    return 1;
  }
  const tokenTypes = {
    "ident-token": tokenType(Ident),
    "function-token": tokenType(Function$2),
    "at-keyword-token": tokenType(AtKeyword),
    "hash-token": tokenType(Hash$1),
    "string-token": tokenType(String$2),
    "bad-string-token": tokenType(BadString),
    "url-token": tokenType(Url$1),
    "bad-url-token": tokenType(BadUrl),
    "delim-token": tokenType(Delim),
    "number-token": tokenType(Number$2),
    "percentage-token": tokenType(Percentage$1),
    "dimension-token": tokenType(Dimension$1),
    "whitespace-token": tokenType(WhiteSpace$1),
    "CDO-token": tokenType(CDO$1),
    "CDC-token": tokenType(CDC$1),
    "colon-token": tokenType(Colon),
    "semicolon-token": tokenType(Semicolon),
    "comma-token": tokenType(Comma),
    "[-token": tokenType(LeftSquareBracket),
    "]-token": tokenType(RightSquareBracket),
    "(-token": tokenType(LeftParenthesis),
    ")-token": tokenType(RightParenthesis),
    "{-token": tokenType(LeftCurlyBracket),
    "}-token": tokenType(RightCurlyBracket)
  };
  const productionTypes = {
    "string": tokenType(String$2),
    "ident": tokenType(Ident),
    "percentage": calc(percentage),
    "zero": zero(),
    "number": calc(number),
    "integer": calc(integer),
    "custom-ident": customIdent,
    "dashed-ident": dashedIdent,
    "custom-property-name": customPropertyName,
    "hex-color": hexColor,
    "id-selector": idSelector,
    "an-plus-b": anPlusB,
    "urange": urange,
    "declaration-value": declarationValue,
    "any-value": anyValue
  };
  function createDemensionTypes(units2) {
    const { angle: angle2, decibel: decibel2, frequency: frequency2, flex: flex2, length: length2, resolution: resolution2, semitones: semitones2, time: time2 } = units2 || {};
    return {
      "dimension": calc(dimension(null)),
      "angle": calc(dimension(angle2)),
      "decibel": calc(dimension(decibel2)),
      "frequency": calc(dimension(frequency2)),
      "flex": calc(dimension(flex2)),
      "length": calc(zero(dimension(length2))),
      "resolution": calc(dimension(resolution2)),
      "semitones": calc(dimension(semitones2)),
      "time": calc(dimension(time2))
    };
  }
  function createGenericTypes(units2) {
    return {
      ...tokenTypes,
      ...productionTypes,
      ...createDemensionTypes(units2)
    };
  }
  const length = [
    "cm",
    "mm",
    "q",
    "in",
    "pt",
    "pc",
    "px",
    "em",
    "rem",
    "ex",
    "rex",
    "cap",
    "rcap",
    "ch",
    "rch",
    "ic",
    "ric",
    "lh",
    "rlh",
    "vw",
    "svw",
    "lvw",
    "dvw",
    "vh",
    "svh",
    "lvh",
    "dvh",
    "vi",
    "svi",
    "lvi",
    "dvi",
    "vb",
    "svb",
    "lvb",
    "dvb",
    "vmin",
    "svmin",
    "lvmin",
    "dvmin",
    "vmax",
    "svmax",
    "lvmax",
    "dvmax",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
  ];
  const angle = [
    "deg",
    "grad",
    "rad",
    "turn"
  ];
  const time = [
    "s",
    "ms"
  ];
  const frequency = [
    "hz",
    "khz"
  ];
  const resolution = [
    "dpi",
    "dpcm",
    "dppx",
    "x"
  ];
  const flex = [
    "fr"
  ];
  const decibel = [
    "db"
  ];
  const semitones = [
    "st"
  ];
  const units = Object.freeze(Object.defineProperty({
    __proto__: null,
    angle,
    decibel,
    flex,
    frequency,
    length,
    resolution,
    semitones,
    time
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function SyntaxError$1(message, input, offset) {
    return Object.assign(createCustomError("SyntaxError", message), {
      input,
      offset,
      rawMessage: message,
      message: message + "\n  " + input + "\n--" + new Array((offset || input.length) + 1).join("-") + "^"
    });
  }
  const TAB$1 = 9;
  const N$2 = 10;
  const F$1 = 12;
  const R$1 = 13;
  const SPACE$3 = 32;
  const NAME_CHAR = new Uint8Array(128).map((_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0);
  class Scanner {
    constructor(str) {
      this.str = str;
      this.pos = 0;
    }
    charCodeAt(pos) {
      return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    }
    charCode() {
      return this.charCodeAt(this.pos);
    }
    isNameCharCode(code2 = this.charCode()) {
      return code2 < 128 && NAME_CHAR[code2] === 1;
    }
    nextCharCode() {
      return this.charCodeAt(this.pos + 1);
    }
    nextNonWsCode(pos) {
      return this.charCodeAt(this.findWsEnd(pos));
    }
    skipWs() {
      this.pos = this.findWsEnd(this.pos);
    }
    findWsEnd(pos) {
      for (; pos < this.str.length; pos++) {
        const code2 = this.str.charCodeAt(pos);
        if (code2 !== R$1 && code2 !== N$2 && code2 !== F$1 && code2 !== SPACE$3 && code2 !== TAB$1) {
          break;
        }
      }
      return pos;
    }
    substringToPos(end) {
      return this.str.substring(this.pos, this.pos = end);
    }
    eat(code2) {
      if (this.charCode() !== code2) {
        this.error("Expect `" + String.fromCharCode(code2) + "`");
      }
      this.pos++;
    }
    peek() {
      return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
    }
    error(message) {
      throw new SyntaxError$1(message, this.str, this.pos);
    }
    scanSpaces() {
      return this.substringToPos(this.findWsEnd(this.pos));
    }
    scanWord() {
      let end = this.pos;
      for (; end < this.str.length; end++) {
        const code2 = this.str.charCodeAt(end);
        if (code2 >= 128 || NAME_CHAR[code2] === 0) {
          break;
        }
      }
      if (this.pos === end) {
        this.error("Expect a keyword");
      }
      return this.substringToPos(end);
    }
    scanNumber() {
      let end = this.pos;
      for (; end < this.str.length; end++) {
        const code2 = this.str.charCodeAt(end);
        if (code2 < 48 || code2 > 57) {
          break;
        }
      }
      if (this.pos === end) {
        this.error("Expect a number");
      }
      return this.substringToPos(end);
    }
    scanString() {
      const end = this.str.indexOf("'", this.pos + 1);
      if (end === -1) {
        this.pos = this.str.length;
        this.error("Expect an apostrophe");
      }
      return this.substringToPos(end + 1);
    }
  }
  const TAB = 9;
  const N$1 = 10;
  const F = 12;
  const R = 13;
  const SPACE$2 = 32;
  const EXCLAMATIONMARK$2 = 33;
  const NUMBERSIGN$3 = 35;
  const AMPERSAND$5 = 38;
  const APOSTROPHE$2 = 39;
  const LEFTPARENTHESIS$2 = 40;
  const RIGHTPARENTHESIS$2 = 41;
  const ASTERISK$6 = 42;
  const PLUSSIGN$6 = 43;
  const COMMA = 44;
  const HYPERMINUS = 45;
  const LESSTHANSIGN$1 = 60;
  const GREATERTHANSIGN$3 = 62;
  const QUESTIONMARK$1 = 63;
  const COMMERCIALAT = 64;
  const LEFTSQUAREBRACKET = 91;
  const RIGHTSQUAREBRACKET = 93;
  const LEFTCURLYBRACKET = 123;
  const VERTICALLINE$3 = 124;
  const RIGHTCURLYBRACKET = 125;
  const INFINITY = 8734;
  const COMBINATOR_PRECEDENCE = {
    " ": 1,
    "&&": 2,
    "||": 3,
    "|": 4
  };
  function readMultiplierRange(scanner) {
    let min = null;
    let max = null;
    scanner.eat(LEFTCURLYBRACKET);
    scanner.skipWs();
    min = scanner.scanNumber(scanner);
    scanner.skipWs();
    if (scanner.charCode() === COMMA) {
      scanner.pos++;
      scanner.skipWs();
      if (scanner.charCode() !== RIGHTCURLYBRACKET) {
        max = scanner.scanNumber(scanner);
        scanner.skipWs();
      }
    } else {
      max = min;
    }
    scanner.eat(RIGHTCURLYBRACKET);
    return {
      min: Number(min),
      max: max ? Number(max) : 0
    };
  }
  function readMultiplier(scanner) {
    let range = null;
    let comma = false;
    switch (scanner.charCode()) {
      case ASTERISK$6:
        scanner.pos++;
        range = {
          min: 0,
          max: 0
        };
        break;
      case PLUSSIGN$6:
        scanner.pos++;
        range = {
          min: 1,
          max: 0
        };
        break;
      case QUESTIONMARK$1:
        scanner.pos++;
        range = {
          min: 0,
          max: 1
        };
        break;
      case NUMBERSIGN$3:
        scanner.pos++;
        comma = true;
        if (scanner.charCode() === LEFTCURLYBRACKET) {
          range = readMultiplierRange(scanner);
        } else if (scanner.charCode() === QUESTIONMARK$1) {
          scanner.pos++;
          range = {
            min: 0,
            max: 0
          };
        } else {
          range = {
            min: 1,
            max: 0
          };
        }
        break;
      case LEFTCURLYBRACKET:
        range = readMultiplierRange(scanner);
        break;
      default:
        return null;
    }
    return {
      type: "Multiplier",
      comma,
      min: range.min,
      max: range.max,
      term: null
    };
  }
  function maybeMultiplied(scanner, node2) {
    const multiplier = readMultiplier(scanner);
    if (multiplier !== null) {
      multiplier.term = node2;
      if (scanner.charCode() === NUMBERSIGN$3 && scanner.charCodeAt(scanner.pos - 1) === PLUSSIGN$6) {
        return maybeMultiplied(scanner, multiplier);
      }
      return multiplier;
    }
    return node2;
  }
  function maybeToken(scanner) {
    const ch = scanner.peek();
    if (ch === "") {
      return null;
    }
    return maybeMultiplied(scanner, {
      type: "Token",
      value: ch
    });
  }
  function readProperty$1(scanner) {
    let name2;
    scanner.eat(LESSTHANSIGN$1);
    scanner.eat(APOSTROPHE$2);
    name2 = scanner.scanWord();
    scanner.eat(APOSTROPHE$2);
    scanner.eat(GREATERTHANSIGN$3);
    return maybeMultiplied(scanner, {
      type: "Property",
      name: name2
    });
  }
  function readTypeRange(scanner) {
    let min = null;
    let max = null;
    let sign2 = 1;
    scanner.eat(LEFTSQUAREBRACKET);
    if (scanner.charCode() === HYPERMINUS) {
      scanner.peek();
      sign2 = -1;
    }
    if (sign2 == -1 && scanner.charCode() === INFINITY) {
      scanner.peek();
    } else {
      min = sign2 * Number(scanner.scanNumber(scanner));
      if (scanner.isNameCharCode()) {
        min += scanner.scanWord();
      }
    }
    scanner.skipWs();
    scanner.eat(COMMA);
    scanner.skipWs();
    if (scanner.charCode() === INFINITY) {
      scanner.peek();
    } else {
      sign2 = 1;
      if (scanner.charCode() === HYPERMINUS) {
        scanner.peek();
        sign2 = -1;
      }
      max = sign2 * Number(scanner.scanNumber(scanner));
      if (scanner.isNameCharCode()) {
        max += scanner.scanWord();
      }
    }
    scanner.eat(RIGHTSQUAREBRACKET);
    return {
      type: "Range",
      min,
      max
    };
  }
  function readType(scanner) {
    let name2;
    let opts = null;
    scanner.eat(LESSTHANSIGN$1);
    name2 = scanner.scanWord();
    if (name2 === "boolean-expr") {
      scanner.eat(LEFTSQUAREBRACKET);
      const implicitGroup = readImplicitGroup(scanner, RIGHTSQUAREBRACKET);
      scanner.eat(RIGHTSQUAREBRACKET);
      scanner.eat(GREATERTHANSIGN$3);
      return maybeMultiplied(scanner, {
        type: "Boolean",
        term: implicitGroup.terms.length === 1 ? implicitGroup.terms[0] : implicitGroup
      });
    }
    if (scanner.charCode() === LEFTPARENTHESIS$2 && scanner.nextCharCode() === RIGHTPARENTHESIS$2) {
      scanner.pos += 2;
      name2 += "()";
    }
    if (scanner.charCodeAt(scanner.findWsEnd(scanner.pos)) === LEFTSQUAREBRACKET) {
      scanner.skipWs();
      opts = readTypeRange(scanner);
    }
    scanner.eat(GREATERTHANSIGN$3);
    return maybeMultiplied(scanner, {
      type: "Type",
      name: name2,
      opts
    });
  }
  function readKeywordOrFunction(scanner) {
    const name2 = scanner.scanWord();
    if (scanner.charCode() === LEFTPARENTHESIS$2) {
      scanner.pos++;
      return {
        type: "Function",
        name: name2
      };
    }
    return maybeMultiplied(scanner, {
      type: "Keyword",
      name: name2
    });
  }
  function regroupTerms(terms, combinators) {
    function createGroup(terms2, combinator2) {
      return {
        type: "Group",
        terms: terms2,
        combinator: combinator2,
        disallowEmpty: false,
        explicit: false
      };
    }
    let combinator;
    combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);
    while (combinators.length > 0) {
      combinator = combinators.shift();
      let i2 = 0;
      let subgroupStart = 0;
      for (; i2 < terms.length; i2++) {
        const term = terms[i2];
        if (term.type === "Combinator") {
          if (term.value === combinator) {
            if (subgroupStart === -1) {
              subgroupStart = i2 - 1;
            }
            terms.splice(i2, 1);
            i2--;
          } else {
            if (subgroupStart !== -1 && i2 - subgroupStart > 1) {
              terms.splice(subgroupStart, i2 - subgroupStart, createGroup(terms.slice(subgroupStart, i2), combinator));
              i2 = subgroupStart + 1;
            }
            subgroupStart = -1;
          }
        }
      }
      if (subgroupStart !== -1 && combinators.length) {
        terms.splice(subgroupStart, i2 - subgroupStart, createGroup(terms.slice(subgroupStart, i2), combinator));
      }
    }
    return combinator;
  }
  function readImplicitGroup(scanner, stopCharCode) {
    const combinators = /* @__PURE__ */ Object.create(null);
    const terms = [];
    let token;
    let prevToken = null;
    let prevTokenPos = scanner.pos;
    while (scanner.charCode() !== stopCharCode && (token = peek(scanner, stopCharCode))) {
      if (token.type !== "Spaces") {
        if (token.type === "Combinator") {
          if (prevToken === null || prevToken.type === "Combinator") {
            scanner.pos = prevTokenPos;
            scanner.error("Unexpected combinator");
          }
          combinators[token.value] = true;
        } else if (prevToken !== null && prevToken.type !== "Combinator") {
          combinators[" "] = true;
          terms.push({
            type: "Combinator",
            value: " "
          });
        }
        terms.push(token);
        prevToken = token;
        prevTokenPos = scanner.pos;
      }
    }
    if (prevToken !== null && prevToken.type === "Combinator") {
      scanner.pos -= prevTokenPos;
      scanner.error("Unexpected combinator");
    }
    return {
      type: "Group",
      terms,
      combinator: regroupTerms(terms, combinators) || " ",
      disallowEmpty: false,
      explicit: false
    };
  }
  function readGroup(scanner, stopCharCode) {
    let result;
    scanner.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(scanner, stopCharCode);
    scanner.eat(RIGHTSQUAREBRACKET);
    result.explicit = true;
    if (scanner.charCode() === EXCLAMATIONMARK$2) {
      scanner.pos++;
      result.disallowEmpty = true;
    }
    return result;
  }
  function peek(scanner, stopCharCode) {
    let code2 = scanner.charCode();
    switch (code2) {
      case RIGHTSQUAREBRACKET:
        break;
      case LEFTSQUAREBRACKET:
        return maybeMultiplied(scanner, readGroup(scanner, stopCharCode));
      case LESSTHANSIGN$1:
        return scanner.nextCharCode() === APOSTROPHE$2 ? readProperty$1(scanner) : readType(scanner);
      case VERTICALLINE$3:
        return {
          type: "Combinator",
          value: scanner.substringToPos(scanner.pos + (scanner.nextCharCode() === VERTICALLINE$3 ? 2 : 1))
        };
      case AMPERSAND$5:
        scanner.pos++;
        scanner.eat(AMPERSAND$5);
        return {
          type: "Combinator",
          value: "&&"
        };
      case COMMA:
        scanner.pos++;
        return {
          type: "Comma"
        };
      case APOSTROPHE$2:
        return maybeMultiplied(scanner, {
          type: "String",
          value: scanner.scanString()
        });
      case SPACE$2:
      case TAB:
      case N$1:
      case R:
      case F:
        return {
          type: "Spaces",
          value: scanner.scanSpaces()
        };
      case COMMERCIALAT:
        code2 = scanner.nextCharCode();
        if (scanner.isNameCharCode(code2)) {
          scanner.pos++;
          return {
            type: "AtKeyword",
            name: scanner.scanWord()
          };
        }
        return maybeToken(scanner);
      case ASTERISK$6:
      case PLUSSIGN$6:
      case QUESTIONMARK$1:
      case NUMBERSIGN$3:
      case EXCLAMATIONMARK$2:
        break;
      case LEFTCURLYBRACKET:
        code2 = scanner.nextCharCode();
        if (code2 < 48 || code2 > 57) {
          return maybeToken(scanner);
        }
        break;
      default:
        if (scanner.isNameCharCode(code2)) {
          return readKeywordOrFunction(scanner);
        }
        return maybeToken(scanner);
    }
  }
  function parse$O(source) {
    const scanner = new Scanner(source);
    const result = readImplicitGroup(scanner);
    if (scanner.pos !== source.length) {
      scanner.error("Unexpected input");
    }
    if (result.terms.length === 1 && result.terms[0].type === "Group") {
      return result.terms[0];
    }
    return result;
  }
  const noop = function() {
  };
  function ensureFunction(value2) {
    return typeof value2 === "function" ? value2 : noop;
  }
  function walk$1(node2, options2, context2) {
    function walk2(node3) {
      enter.call(context2, node3);
      switch (node3.type) {
        case "Group":
          node3.terms.forEach(walk2);
          break;
        case "Multiplier":
        case "Boolean":
          walk2(node3.term);
          break;
        case "Type":
        case "Property":
        case "Keyword":
        case "AtKeyword":
        case "Function":
        case "String":
        case "Token":
        case "Comma":
          break;
        default:
          throw new Error("Unknown type: " + node3.type);
      }
      leave.call(context2, node3);
    }
    let enter = noop;
    let leave = noop;
    if (typeof options2 === "function") {
      enter = options2;
    } else if (options2) {
      enter = ensureFunction(options2.enter);
      leave = ensureFunction(options2.leave);
    }
    if (enter === noop && leave === noop) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walk2(node2);
  }
  const astToTokens = {
    decorator(handlers) {
      const tokens = [];
      let curNode = null;
      return {
        ...handlers,
        node(node2) {
          const tmp = curNode;
          curNode = node2;
          handlers.node.call(this, node2);
          curNode = tmp;
        },
        emit(value2, type2, auto) {
          tokens.push({
            type: type2,
            value: value2,
            node: auto ? null : curNode
          });
        },
        result() {
          return tokens;
        }
      };
    }
  };
  function stringToTokens(str) {
    const tokens = [];
    tokenize$1(str, (type2, start, end) => tokens.push({
      type: type2,
      value: str.slice(start, end),
      node: null
    }));
    return tokens;
  }
  function prepareTokens(value2, syntax2) {
    if (typeof value2 === "string") {
      return stringToTokens(value2);
    }
    return syntax2.generate(value2, astToTokens);
  }
  const MATCH = {
    type: "Match"
  };
  const MISMATCH = {
    type: "Mismatch"
  };
  const DISALLOW_EMPTY = {
    type: "DisallowEmpty"
  };
  const LEFTPARENTHESIS$1 = 40;
  const RIGHTPARENTHESIS$1 = 41;
  function createCondition(match, thenBranch, elseBranch) {
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
      return match;
    }
    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
      return match;
    }
    if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
      thenBranch = match.then;
      match = match.match;
    }
    return {
      type: "If",
      match,
      then: thenBranch,
      else: elseBranch
    };
  }
  function isFunctionType(name2) {
    return name2.length > 2 && name2.charCodeAt(name2.length - 2) === LEFTPARENTHESIS$1 && name2.charCodeAt(name2.length - 1) === RIGHTPARENTHESIS$1;
  }
  function isEnumCapatible(term) {
    return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
  }
  function groupNode(terms, combinator = " ", explicit = false) {
    return {
      type: "Group",
      terms,
      combinator,
      disallowEmpty: false,
      explicit
    };
  }
  function replaceTypeInGraph(node2, replacements, visited = /* @__PURE__ */ new Set()) {
    if (!visited.has(node2)) {
      visited.add(node2);
      switch (node2.type) {
        case "If":
          node2.match = replaceTypeInGraph(node2.match, replacements, visited);
          node2.then = replaceTypeInGraph(node2.then, replacements, visited);
          node2.else = replaceTypeInGraph(node2.else, replacements, visited);
          break;
        case "Type":
          return replacements[node2.name] || node2;
      }
    }
    return node2;
  }
  function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
      case " ": {
        let result = MATCH;
        for (let i2 = terms.length - 1; i2 >= 0; i2--) {
          const term = terms[i2];
          result = createCondition(term, result, MISMATCH);
        }
        return result;
      }
      case "|": {
        let result = MISMATCH;
        let map = null;
        for (let i2 = terms.length - 1; i2 >= 0; i2--) {
          let term = terms[i2];
          if (isEnumCapatible(term)) {
            if (map === null && i2 > 0 && isEnumCapatible(terms[i2 - 1])) {
              map = /* @__PURE__ */ Object.create(null);
              result = createCondition({
                type: "Enum",
                map
              }, MATCH, result);
            }
            if (map !== null) {
              const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
              if (key in map === false) {
                map[key] = term;
                continue;
              }
            }
          }
          map = null;
          result = createCondition(term, MATCH, result);
        }
        return result;
      }
      case "&&": {
        if (terms.length > 5) {
          return {
            type: "MatchOnce",
            terms,
            all: true
          };
        }
        let result = MISMATCH;
        for (let i2 = terms.length - 1; i2 >= 0; i2--) {
          const term = terms[i2];
          let thenClause;
          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(combinator, terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }), false);
          } else {
            thenClause = MATCH;
          }
          result = createCondition(term, thenClause, result);
        }
        return result;
      }
      case "||": {
        if (terms.length > 5) {
          return {
            type: "MatchOnce",
            terms,
            all: false
          };
        }
        let result = atLeastOneTermMatched ? MATCH : MISMATCH;
        for (let i2 = terms.length - 1; i2 >= 0; i2--) {
          const term = terms[i2];
          let thenClause;
          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(combinator, terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }), true);
          } else {
            thenClause = MATCH;
          }
          result = createCondition(term, thenClause, result);
        }
        return result;
      }
    }
  }
  function buildMultiplierMatchGraph(node2) {
    let result = MATCH;
    let matchTerm = buildMatchGraphInternal(node2.term);
    if (node2.max === 0) {
      matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH);
      result = createCondition(matchTerm, null, MISMATCH);
      result.then = createCondition(MATCH, MATCH, result);
      if (node2.comma) {
        result.then.else = createCondition({
          type: "Comma",
          syntax: node2
        }, result, MISMATCH);
      }
    } else {
      for (let i2 = node2.min || 1; i2 <= node2.max; i2++) {
        if (node2.comma && result !== MATCH) {
          result = createCondition({
            type: "Comma",
            syntax: node2
          }, result, MISMATCH);
        }
        result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);
      }
    }
    if (node2.min === 0) {
      result = createCondition(MATCH, MATCH, result);
    } else {
      for (let i2 = 0; i2 < node2.min - 1; i2++) {
        if (node2.comma && result !== MATCH) {
          result = createCondition({
            type: "Comma",
            syntax: node2
          }, result, MISMATCH);
        }
        result = createCondition(matchTerm, result, MISMATCH);
      }
    }
    return result;
  }
  function buildMatchGraphInternal(node2) {
    if (typeof node2 === "function") {
      return {
        type: "Generic",
        fn: node2
      };
    }
    switch (node2.type) {
      case "Group": {
        let result = buildGroupMatchGraph(node2.combinator, node2.terms.map(buildMatchGraphInternal), false);
        if (node2.disallowEmpty) {
          result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
        }
        return result;
      }
      case "Multiplier":
        return buildMultiplierMatchGraph(node2);
      case "Boolean": {
        const term = buildMatchGraphInternal(node2.term);
        const matchNode = buildMatchGraphInternal(groupNode([
          groupNode([
            {
              type: "Keyword",
              name: "not"
            },
            {
              type: "Type",
              name: "!boolean-group"
            }
          ]),
          groupNode([
            {
              type: "Type",
              name: "!boolean-group"
            },
            groupNode([
              {
                type: "Multiplier",
                comma: false,
                min: 0,
                max: 0,
                term: groupNode([
                  {
                    type: "Keyword",
                    name: "and"
                  },
                  {
                    type: "Type",
                    name: "!boolean-group"
                  }
                ])
              },
              {
                type: "Multiplier",
                comma: false,
                min: 0,
                max: 0,
                term: groupNode([
                  {
                    type: "Keyword",
                    name: "or"
                  },
                  {
                    type: "Type",
                    name: "!boolean-group"
                  }
                ])
              }
            ], "|")
          ])
        ], "|"));
        const booleanGroup = buildMatchGraphInternal(groupNode([
          {
            type: "Type",
            name: "!term"
          },
          groupNode([
            {
              type: "Token",
              value: "("
            },
            {
              type: "Type",
              name: "!self"
            },
            {
              type: "Token",
              value: ")"
            }
          ]),
          {
            type: "Type",
            name: "general-enclosed"
          }
        ], "|"));
        replaceTypeInGraph(booleanGroup, {
          "!term": term,
          "!self": matchNode
        });
        replaceTypeInGraph(matchNode, {
          "!boolean-group": booleanGroup
        });
        return matchNode;
      }
      case "Type":
      case "Property":
        return {
          type: node2.type,
          name: node2.name,
          syntax: node2
        };
      case "Keyword":
        return {
          type: node2.type,
          name: node2.name.toLowerCase(),
          syntax: node2
        };
      case "AtKeyword":
        return {
          type: node2.type,
          name: "@" + node2.name.toLowerCase(),
          syntax: node2
        };
      case "Function":
        return {
          type: node2.type,
          name: node2.name.toLowerCase() + "(",
          syntax: node2
        };
      case "String":
        if (node2.value.length === 3) {
          return {
            type: "Token",
            value: node2.value.charAt(1),
            syntax: node2
          };
        }
        return {
          type: node2.type,
          value: node2.value.substr(1, node2.value.length - 2).replace(/\\'/g, "'"),
          syntax: node2
        };
      case "Token":
        return {
          type: node2.type,
          value: node2.value,
          syntax: node2
        };
      case "Comma":
        return {
          type: node2.type,
          syntax: node2
        };
      default:
        throw new Error("Unknown node type:", node2.type);
    }
  }
  function buildMatchGraph(syntaxTree, ref2) {
    if (typeof syntaxTree === "string") {
      syntaxTree = parse$O(syntaxTree);
    }
    return {
      type: "MatchGraph",
      match: buildMatchGraphInternal(syntaxTree),
      syntax: ref2 || null,
      source: syntaxTree
    };
  }
  const { hasOwnProperty: hasOwnProperty$2 } = Object.prototype;
  const STUB = 0;
  const TOKEN = 1;
  const OPEN_SYNTAX = 2;
  const CLOSE_SYNTAX = 3;
  const EXIT_REASON_MATCH = "Match";
  const EXIT_REASON_MISMATCH = "Mismatch";
  const EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
  const ITERATION_LIMIT = 15e3;
  function reverseList(list2) {
    let prev = null;
    let next = null;
    let item = list2;
    while (item !== null) {
      next = item.prev;
      item.prev = prev;
      prev = item;
      item = next;
    }
    return prev;
  }
  function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
      return false;
    }
    for (let i2 = 0; i2 < testStr.length; i2++) {
      const referenceCode = referenceStr.charCodeAt(i2);
      let testCode = testStr.charCodeAt(i2);
      if (testCode >= 65 && testCode <= 90) {
        testCode = testCode | 32;
      }
      if (testCode !== referenceCode) {
        return false;
      }
    }
    return true;
  }
  function isContextEdgeDelim(token) {
    if (token.type !== Delim) {
      return false;
    }
    return token.value !== "?";
  }
  function isCommaContextStart(token) {
    if (token === null) {
      return true;
    }
    return token.type === Comma || token.type === Function$2 || token.type === LeftParenthesis || token.type === LeftSquareBracket || token.type === LeftCurlyBracket || isContextEdgeDelim(token);
  }
  function isCommaContextEnd(token) {
    if (token === null) {
      return true;
    }
    return token.type === RightParenthesis || token.type === RightSquareBracket || token.type === RightCurlyBracket || token.type === Delim && token.value === "/";
  }
  function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
      do {
        tokenIndex++;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
      } while (token !== null && (token.type === WhiteSpace$1 || token.type === Comment$1));
    }
    function getNextToken(offset) {
      const nextIndex = tokenIndex + offset;
      return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }
    function stateSnapshotFromSyntax(nextState, prev) {
      return {
        nextState,
        matchStack,
        syntaxStack,
        thenStack,
        tokenIndex,
        prev
      };
    }
    function pushThenStack(nextState) {
      thenStack = {
        nextState,
        matchStack,
        syntaxStack,
        prev: thenStack
      };
    }
    function pushElseStack(nextState) {
      elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }
    function addTokenToMatch() {
      matchStack = {
        type: TOKEN,
        syntax: state.syntax,
        token,
        prev: matchStack
      };
      moveToNextToken();
      syntaxStash = null;
      if (tokenIndex > longestMatch) {
        longestMatch = tokenIndex;
      }
    }
    function openSyntax() {
      syntaxStack = {
        syntax: state.syntax,
        opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
        prev: syntaxStack
      };
      matchStack = {
        type: OPEN_SYNTAX,
        syntax: state.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    function closeSyntax() {
      if (matchStack.type === OPEN_SYNTAX) {
        matchStack = matchStack.prev;
      } else {
        matchStack = {
          type: CLOSE_SYNTAX,
          syntax: syntaxStack.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }
      syntaxStack = syntaxStack.prev;
    }
    let syntaxStack = null;
    let thenStack = null;
    let elseStack = null;
    let syntaxStash = null;
    let iterationCount = 0;
    let exitReason = null;
    let token = null;
    let tokenIndex = -1;
    let longestMatch = 0;
    let matchStack = {
      type: STUB,
      syntax: null,
      token: null,
      prev: null
    };
    moveToNextToken();
    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
      switch (state.type) {
        case "Match":
          if (thenStack === null) {
            if (token !== null) {
              if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
                state = MISMATCH;
                break;
              }
            }
            exitReason = EXIT_REASON_MATCH;
            break;
          }
          state = thenStack.nextState;
          if (state === DISALLOW_EMPTY) {
            if (thenStack.matchStack === matchStack) {
              state = MISMATCH;
              break;
            } else {
              state = MATCH;
            }
          }
          while (thenStack.syntaxStack !== syntaxStack) {
            closeSyntax();
          }
          thenStack = thenStack.prev;
          break;
        case "Mismatch":
          if (syntaxStash !== null && syntaxStash !== false) {
            if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
              elseStack = syntaxStash;
              syntaxStash = false;
            }
          } else if (elseStack === null) {
            exitReason = EXIT_REASON_MISMATCH;
            break;
          }
          state = elseStack.nextState;
          thenStack = elseStack.thenStack;
          syntaxStack = elseStack.syntaxStack;
          matchStack = elseStack.matchStack;
          tokenIndex = elseStack.tokenIndex;
          token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
          elseStack = elseStack.prev;
          break;
        case "MatchGraph":
          state = state.match;
          break;
        case "If":
          if (state.else !== MISMATCH) {
            pushElseStack(state.else);
          }
          if (state.then !== MATCH) {
            pushThenStack(state.then);
          }
          state = state.match;
          break;
        case "MatchOnce":
          state = {
            type: "MatchOnceBuffer",
            syntax: state,
            index: 0,
            mask: 0
          };
          break;
        case "MatchOnceBuffer": {
          const terms = state.syntax.terms;
          if (state.index === terms.length) {
            if (state.mask === 0 || state.syntax.all) {
              state = MISMATCH;
              break;
            }
            state = MATCH;
            break;
          }
          if (state.mask === (1 << terms.length) - 1) {
            state = MATCH;
            break;
          }
          for (; state.index < terms.length; state.index++) {
            const matchFlag = 1 << state.index;
            if ((state.mask & matchFlag) === 0) {
              pushElseStack(state);
              pushThenStack({
                type: "AddMatchOnce",
                syntax: state.syntax,
                mask: state.mask | matchFlag
              });
              state = terms[state.index++];
              break;
            }
          }
          break;
        }
        case "AddMatchOnce":
          state = {
            type: "MatchOnceBuffer",
            syntax: state.syntax,
            index: 0,
            mask: state.mask
          };
          break;
        case "Enum":
          if (token !== null) {
            let name2 = token.value.toLowerCase();
            if (name2.indexOf("\\") !== -1) {
              name2 = name2.replace(/\\[09].*$/, "");
            }
            if (hasOwnProperty$2.call(state.map, name2)) {
              state = state.map[name2];
              break;
            }
          }
          state = MISMATCH;
          break;
        case "Generic": {
          const opts = syntaxStack !== null ? syntaxStack.opts : null;
          const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
          if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
            while (tokenIndex < lastTokenIndex2) {
              addTokenToMatch();
            }
            state = MATCH;
          } else {
            state = MISMATCH;
          }
          break;
        }
        case "Type":
        case "Property": {
          const syntaxDict = state.type === "Type" ? "types" : "properties";
          const dictSyntax = hasOwnProperty$2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
          if (!dictSyntax || !dictSyntax.match) {
            throw new Error("Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>"));
          }
          if (syntaxStash !== false && token !== null && state.type === "Type") {
            const lowPriorityMatching = state.name === "custom-ident" && token.type === Ident || state.name === "length" && token.value === "0";
            if (lowPriorityMatching) {
              if (syntaxStash === null) {
                syntaxStash = stateSnapshotFromSyntax(state, elseStack);
              }
              state = MISMATCH;
              break;
            }
          }
          openSyntax();
          state = dictSyntax.matchRef || dictSyntax.match;
          break;
        }
        case "Keyword": {
          const name2 = state.name;
          if (token !== null) {
            let keywordName = token.value;
            if (keywordName.indexOf("\\") !== -1) {
              keywordName = keywordName.replace(/\\[09].*$/, "");
            }
            if (areStringsEqualCaseInsensitive(keywordName, name2)) {
              addTokenToMatch();
              state = MATCH;
              break;
            }
          }
          state = MISMATCH;
          break;
        }
        case "AtKeyword":
        case "Function":
          if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
          state = MISMATCH;
          break;
        case "Token":
          if (token !== null && token.value === state.value) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
          state = MISMATCH;
          break;
        case "Comma":
          if (token !== null && token.type === Comma) {
            if (isCommaContextStart(matchStack.token)) {
              state = MISMATCH;
            } else {
              addTokenToMatch();
              state = isCommaContextEnd(token) ? MISMATCH : MATCH;
            }
          } else {
            state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
          }
          break;
        case "String":
          let string = "";
          let lastTokenIndex = tokenIndex;
          for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
            string += tokens[lastTokenIndex].value;
          }
          if (areStringsEqualCaseInsensitive(string, state.value)) {
            while (tokenIndex < lastTokenIndex) {
              addTokenToMatch();
            }
            state = MATCH;
          } else {
            state = MISMATCH;
          }
          break;
        default:
          throw new Error("Unknown node type: " + state.type);
      }
    }
    switch (exitReason) {
      case null:
        console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
        exitReason = EXIT_REASON_ITERATION_LIMIT;
        matchStack = null;
        break;
      case EXIT_REASON_MATCH:
        while (syntaxStack !== null) {
          closeSyntax();
        }
        break;
      default:
        matchStack = null;
    }
    return {
      tokens,
      reason: exitReason,
      iterations: iterationCount,
      match: matchStack,
      longestMatch
    };
  }
  function matchAsTree(tokens, matchGraph, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
    if (matchResult.match === null) {
      return matchResult;
    }
    let item = matchResult.match;
    let host = matchResult.match = {
      syntax: matchGraph.syntax || null,
      match: []
    };
    const hostStack = [
      host
    ];
    item = reverseList(item).prev;
    while (item !== null) {
      switch (item.type) {
        case OPEN_SYNTAX:
          host.match.push(host = {
            syntax: item.syntax,
            match: []
          });
          hostStack.push(host);
          break;
        case CLOSE_SYNTAX:
          hostStack.pop();
          host = hostStack[hostStack.length - 1];
          break;
        default:
          host.match.push({
            syntax: item.syntax || null,
            token: item.token.value,
            node: item.token.node
          });
      }
      item = item.prev;
    }
    return matchResult;
  }
  function getTrace(node2) {
    function shouldPutToTrace(syntax2) {
      if (syntax2 === null) {
        return false;
      }
      return syntax2.type === "Type" || syntax2.type === "Property" || syntax2.type === "Keyword";
    }
    function hasMatch(matchNode) {
      if (Array.isArray(matchNode.match)) {
        for (let i2 = 0; i2 < matchNode.match.length; i2++) {
          if (hasMatch(matchNode.match[i2])) {
            if (shouldPutToTrace(matchNode.syntax)) {
              result.unshift(matchNode.syntax);
            }
            return true;
          }
        }
      } else if (matchNode.node === node2) {
        result = shouldPutToTrace(matchNode.syntax) ? [
          matchNode.syntax
        ] : [];
        return true;
      }
      return false;
    }
    let result = null;
    if (this.matched !== null) {
      hasMatch(this.matched);
    }
    return result;
  }
  function isType(node2, type2) {
    return testNode(this, node2, (match) => match.type === "Type" && match.name === type2);
  }
  function isProperty(node2, property2) {
    return testNode(this, node2, (match) => match.type === "Property" && match.name === property2);
  }
  function isKeyword(node2) {
    return testNode(this, node2, (match) => match.type === "Keyword");
  }
  function testNode(match, node2, fn2) {
    const trace2 = getTrace.call(match, node2);
    if (trace2 === null) {
      return false;
    }
    return trace2.some(fn2);
  }
  const trace = Object.freeze(Object.defineProperty({
    __proto__: null,
    getTrace,
    isKeyword,
    isProperty,
    isType
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function getFirstMatchNode(matchNode) {
    if ("node" in matchNode) {
      return matchNode.node;
    }
    return getFirstMatchNode(matchNode.match[0]);
  }
  function getLastMatchNode(matchNode) {
    if ("node" in matchNode) {
      return matchNode.node;
    }
    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
  }
  function matchFragments(lexer2, ast, match, type2, name2) {
    function findFragments(matchNode) {
      if (matchNode.syntax !== null && matchNode.syntax.type === type2 && matchNode.syntax.name === name2) {
        const start = getFirstMatchNode(matchNode);
        const end = getLastMatchNode(matchNode);
        lexer2.syntax.walk(ast, function(node2, item, list2) {
          if (node2 === start) {
            const nodes = new List();
            do {
              nodes.appendData(item.data);
              if (item.data === end) {
                break;
              }
              item = item.next;
            } while (item !== null);
            fragments.push({
              parent: list2,
              nodes
            });
          }
        });
      }
      if (Array.isArray(matchNode.match)) {
        matchNode.match.forEach(findFragments);
      }
    }
    const fragments = [];
    if (match.matched !== null) {
      findFragments(match.matched);
    }
    return fragments;
  }
  const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
  function isValidNumber(value2) {
    return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2 && value2 >= 0;
  }
  function isValidLocation(loc) {
    return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
  }
  function createNodeStructureChecker(type2, fields) {
    return function checkNode(node2, warn) {
      if (!node2 || node2.constructor !== Object) {
        return warn(node2, "Type of node should be an Object");
      }
      for (let key in node2) {
        let valid = true;
        if (hasOwnProperty$1.call(node2, key) === false) {
          continue;
        }
        if (key === "type") {
          if (node2.type !== type2) {
            warn(node2, "Wrong node type `" + node2.type + "`, expected `" + type2 + "`");
          }
        } else if (key === "loc") {
          if (node2.loc === null) {
            continue;
          } else if (node2.loc && node2.loc.constructor === Object) {
            if (typeof node2.loc.source !== "string") {
              key += ".source";
            } else if (!isValidLocation(node2.loc.start)) {
              key += ".start";
            } else if (!isValidLocation(node2.loc.end)) {
              key += ".end";
            } else {
              continue;
            }
          }
          valid = false;
        } else if (fields.hasOwnProperty(key)) {
          valid = false;
          for (let i2 = 0; !valid && i2 < fields[key].length; i2++) {
            const fieldType = fields[key][i2];
            switch (fieldType) {
              case String:
                valid = typeof node2[key] === "string";
                break;
              case Boolean:
                valid = typeof node2[key] === "boolean";
                break;
              case null:
                valid = node2[key] === null;
                break;
              default:
                if (typeof fieldType === "string") {
                  valid = node2[key] && node2[key].type === fieldType;
                } else if (Array.isArray(fieldType)) {
                  valid = node2[key] instanceof List;
                }
            }
          }
        } else {
          warn(node2, "Unknown field `" + key + "` for " + type2 + " node type");
        }
        if (!valid) {
          warn(node2, "Bad value for `" + type2 + "." + key + "`");
        }
      }
      for (const key in fields) {
        if (hasOwnProperty$1.call(fields, key) && hasOwnProperty$1.call(node2, key) === false) {
          warn(node2, "Field `" + type2 + "." + key + "` is missed");
        }
      }
    };
  }
  function genTypesList(fieldTypes, path2) {
    const docsTypes = [];
    for (let i2 = 0; i2 < fieldTypes.length; i2++) {
      const fieldType = fieldTypes[i2];
      if (fieldType === String || fieldType === Boolean) {
        docsTypes.push(fieldType.name.toLowerCase());
      } else if (fieldType === null) {
        docsTypes.push("null");
      } else if (typeof fieldType === "string") {
        docsTypes.push(fieldType);
      } else if (Array.isArray(fieldType)) {
        docsTypes.push("List<" + (genTypesList(fieldType, path2) || "any") + ">");
      } else {
        throw new Error("Wrong value `" + fieldType + "` in `" + path2 + "` structure definition");
      }
    }
    return docsTypes.join(" | ");
  }
  function processStructure(name2, nodeType) {
    const structure2 = nodeType.structure;
    const fields = {
      type: String,
      loc: true
    };
    const docs = {
      type: '"' + name2 + '"'
    };
    for (const key in structure2) {
      if (hasOwnProperty$1.call(structure2, key) === false) {
        continue;
      }
      const fieldTypes = fields[key] = Array.isArray(structure2[key]) ? structure2[key].slice() : [
        structure2[key]
      ];
      docs[key] = genTypesList(fieldTypes, name2 + "." + key);
    }
    return {
      docs,
      check: createNodeStructureChecker(name2, fields)
    };
  }
  function getStructureFromConfig(config) {
    const structure2 = {};
    if (config.node) {
      for (const name2 in config.node) {
        if (hasOwnProperty$1.call(config.node, name2)) {
          const nodeType = config.node[name2];
          if (nodeType.structure) {
            structure2[name2] = processStructure(name2, nodeType);
          } else {
            throw new Error("Missed `structure` field in `" + name2 + "` node type definition");
          }
        }
      }
    }
    return structure2;
  }
  function dumpMapSyntax(map, compact, syntaxAsAst) {
    const result = {};
    for (const name2 in map) {
      if (map[name2].syntax) {
        result[name2] = syntaxAsAst ? map[name2].syntax : generate$O(map[name2].syntax, {
          compact
        });
      }
    }
    return result;
  }
  function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};
    for (const [name2, atrule2] of Object.entries(map)) {
      result[name2] = {
        prelude: atrule2.prelude && (syntaxAsAst ? atrule2.prelude.syntax : generate$O(atrule2.prelude.syntax, {
          compact
        })),
        descriptors: atrule2.descriptors && dumpMapSyntax(atrule2.descriptors, compact, syntaxAsAst)
      };
    }
    return result;
  }
  function valueHasVar(tokens) {
    for (let i2 = 0; i2 < tokens.length; i2++) {
      if (tokens[i2].value.toLowerCase() === "var(") {
        return true;
      }
    }
    return false;
  }
  function syntaxHasTopLevelCommaMultiplier(syntax2) {
    const singleTerm = syntax2.terms[0];
    return syntax2.explicit === false && syntax2.terms.length === 1 && singleTerm.type === "Multiplier" && singleTerm.comma === true;
  }
  function buildMatchResult(matched, error, iterations) {
    return {
      matched,
      iterations,
      error,
      ...trace
    };
  }
  function matchSyntax(lexer2, syntax2, value2, useCssWideKeywords) {
    const tokens = prepareTokens(value2, lexer2.syntax);
    let result;
    if (valueHasVar(tokens)) {
      return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
    }
    if (useCssWideKeywords) {
      result = matchAsTree(tokens, lexer2.cssWideKeywordsSyntax, lexer2);
    }
    if (!useCssWideKeywords || !result.match) {
      result = matchAsTree(tokens, syntax2.match, lexer2);
      if (!result.match) {
        return buildMatchResult(null, new SyntaxMatchError(result.reason, syntax2.syntax, value2, result), result.iterations);
      }
    }
    return buildMatchResult(result.match, null, result.iterations);
  }
  class Lexer {
    constructor(config, syntax2, structure2) {
      this.cssWideKeywords = cssWideKeywords;
      this.syntax = syntax2;
      this.generic = false;
      this.units = {
        ...units
      };
      this.atrules = /* @__PURE__ */ Object.create(null);
      this.properties = /* @__PURE__ */ Object.create(null);
      this.types = /* @__PURE__ */ Object.create(null);
      this.structure = structure2 || getStructureFromConfig(config);
      if (config) {
        if (config.cssWideKeywords) {
          this.cssWideKeywords = config.cssWideKeywords;
        }
        if (config.units) {
          for (const group of Object.keys(units)) {
            if (Array.isArray(config.units[group])) {
              this.units[group] = config.units[group];
            }
          }
        }
        if (config.types) {
          for (const [name2, type2] of Object.entries(config.types)) {
            this.addType_(name2, type2);
          }
        }
        if (config.generic) {
          this.generic = true;
          for (const [name2, value2] of Object.entries(createGenericTypes(this.units))) {
            this.addType_(name2, value2);
          }
        }
        if (config.atrules) {
          for (const [name2, atrule2] of Object.entries(config.atrules)) {
            this.addAtrule_(name2, atrule2);
          }
        }
        if (config.properties) {
          for (const [name2, property2] of Object.entries(config.properties)) {
            this.addProperty_(name2, property2);
          }
        }
      }
      this.cssWideKeywordsSyntax = buildMatchGraph(this.cssWideKeywords.join(" |  "));
    }
    checkStructure(ast) {
      function collectWarning(node2, message) {
        warns.push({
          node: node2,
          message
        });
      }
      const structure2 = this.structure;
      const warns = [];
      this.syntax.walk(ast, function(node2) {
        if (structure2.hasOwnProperty(node2.type)) {
          structure2[node2.type].check(node2, collectWarning);
        } else {
          collectWarning(node2, "Unknown node type `" + node2.type + "`");
        }
      });
      return warns.length ? warns : false;
    }
    createDescriptor(syntax2, type2, name2, parent = null) {
      const ref2 = {
        type: type2,
        name: name2
      };
      const descriptor = {
        type: type2,
        name: name2,
        parent,
        serializable: typeof syntax2 === "string" || syntax2 && typeof syntax2.type === "string",
        syntax: null,
        match: null,
        matchRef: null
      };
      if (typeof syntax2 === "function") {
        descriptor.match = buildMatchGraph(syntax2, ref2);
      } else {
        if (typeof syntax2 === "string") {
          Object.defineProperty(descriptor, "syntax", {
            get() {
              Object.defineProperty(descriptor, "syntax", {
                value: parse$O(syntax2)
              });
              return descriptor.syntax;
            }
          });
        } else {
          descriptor.syntax = syntax2;
        }
        Object.defineProperty(descriptor, "match", {
          get() {
            Object.defineProperty(descriptor, "match", {
              value: buildMatchGraph(descriptor.syntax, ref2)
            });
            return descriptor.match;
          }
        });
        if (type2 === "Property") {
          Object.defineProperty(descriptor, "matchRef", {
            get() {
              const syntax3 = descriptor.syntax;
              const value2 = syntaxHasTopLevelCommaMultiplier(syntax3) ? buildMatchGraph({
                ...syntax3,
                terms: [
                  syntax3.terms[0].term
                ]
              }, ref2) : null;
              Object.defineProperty(descriptor, "matchRef", {
                value: value2
              });
              return value2;
            }
          });
        }
      }
      return descriptor;
    }
    addAtrule_(name2, syntax2) {
      if (!syntax2) {
        return;
      }
      this.atrules[name2] = {
        type: "Atrule",
        name: name2,
        prelude: syntax2.prelude ? this.createDescriptor(syntax2.prelude, "AtrulePrelude", name2) : null,
        descriptors: syntax2.descriptors ? Object.keys(syntax2.descriptors).reduce((map, descName) => {
          map[descName] = this.createDescriptor(syntax2.descriptors[descName], "AtruleDescriptor", descName, name2);
          return map;
        }, /* @__PURE__ */ Object.create(null)) : null
      };
    }
    addProperty_(name2, syntax2) {
      if (!syntax2) {
        return;
      }
      this.properties[name2] = this.createDescriptor(syntax2, "Property", name2);
    }
    addType_(name2, syntax2) {
      if (!syntax2) {
        return;
      }
      this.types[name2] = this.createDescriptor(syntax2, "Type", name2);
    }
    checkAtruleName(atruleName) {
      if (!this.getAtrule(atruleName)) {
        return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
      }
    }
    checkAtrulePrelude(atruleName, prelude) {
      const error = this.checkAtruleName(atruleName);
      if (error) {
        return error;
      }
      const atrule2 = this.getAtrule(atruleName);
      if (!atrule2.prelude && prelude) {
        return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
      }
      if (atrule2.prelude && !prelude) {
        if (!matchSyntax(this, atrule2.prelude, "", false).matched) {
          return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
        }
      }
    }
    checkAtruleDescriptorName(atruleName, descriptorName) {
      const error = this.checkAtruleName(atruleName);
      if (error) {
        return error;
      }
      const atrule2 = this.getAtrule(atruleName);
      const descriptor = keyword(descriptorName);
      if (!atrule2.descriptors) {
        return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
      }
      if (!atrule2.descriptors[descriptor.name] && !atrule2.descriptors[descriptor.basename]) {
        return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
      }
    }
    checkPropertyName(propertyName) {
      if (!this.getProperty(propertyName)) {
        return new SyntaxReferenceError("Unknown property", propertyName);
      }
    }
    matchAtrulePrelude(atruleName, prelude) {
      const error = this.checkAtrulePrelude(atruleName, prelude);
      if (error) {
        return buildMatchResult(null, error);
      }
      const atrule2 = this.getAtrule(atruleName);
      if (!atrule2.prelude) {
        return buildMatchResult(null, null);
      }
      return matchSyntax(this, atrule2.prelude, prelude || "", false);
    }
    matchAtruleDescriptor(atruleName, descriptorName, value2) {
      const error = this.checkAtruleDescriptorName(atruleName, descriptorName);
      if (error) {
        return buildMatchResult(null, error);
      }
      const atrule2 = this.getAtrule(atruleName);
      const descriptor = keyword(descriptorName);
      return matchSyntax(this, atrule2.descriptors[descriptor.name] || atrule2.descriptors[descriptor.basename], value2, false);
    }
    matchDeclaration(node2) {
      if (node2.type !== "Declaration") {
        return buildMatchResult(null, new Error("Not a Declaration node"));
      }
      return this.matchProperty(node2.property, node2.value);
    }
    matchProperty(propertyName, value2) {
      if (property(propertyName).custom) {
        return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
      }
      const error = this.checkPropertyName(propertyName);
      if (error) {
        return buildMatchResult(null, error);
      }
      return matchSyntax(this, this.getProperty(propertyName), value2, true);
    }
    matchType(typeName, value2) {
      const typeSyntax = this.getType(typeName);
      if (!typeSyntax) {
        return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
      }
      return matchSyntax(this, typeSyntax, value2, false);
    }
    match(syntax2, value2) {
      if (typeof syntax2 !== "string" && (!syntax2 || !syntax2.type)) {
        return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
      }
      if (typeof syntax2 === "string" || !syntax2.match) {
        syntax2 = this.createDescriptor(syntax2, "Type", "anonymous");
      }
      return matchSyntax(this, syntax2, value2, false);
    }
    findValueFragments(propertyName, value2, type2, name2) {
      return matchFragments(this, value2, this.matchProperty(propertyName, value2), type2, name2);
    }
    findDeclarationValueFragments(declaration, type2, name2) {
      return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type2, name2);
    }
    findAllFragments(ast, type2, name2) {
      const result = [];
      this.syntax.walk(ast, {
        visit: "Declaration",
        enter: (declaration) => {
          result.push.apply(result, this.findDeclarationValueFragments(declaration, type2, name2));
        }
      });
      return result;
    }
    getAtrule(atruleName, fallbackBasename = true) {
      const atrule2 = keyword(atruleName);
      const atruleEntry = atrule2.vendor && fallbackBasename ? this.atrules[atrule2.name] || this.atrules[atrule2.basename] : this.atrules[atrule2.name];
      return atruleEntry || null;
    }
    getAtrulePrelude(atruleName, fallbackBasename = true) {
      const atrule2 = this.getAtrule(atruleName, fallbackBasename);
      return atrule2 && atrule2.prelude || null;
    }
    getAtruleDescriptor(atruleName, name2) {
      return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name2] || null : null;
    }
    getProperty(propertyName, fallbackBasename = true) {
      const property$1 = property(propertyName);
      const propertyEntry = property$1.vendor && fallbackBasename ? this.properties[property$1.name] || this.properties[property$1.basename] : this.properties[property$1.name];
      return propertyEntry || null;
    }
    getType(name2) {
      return hasOwnProperty.call(this.types, name2) ? this.types[name2] : null;
    }
    validate() {
      function syntaxRef(name2, isType2) {
        return isType2 ? `<${name2}>` : `<'${name2}'>`;
      }
      function validate(syntax2, name2, broken, descriptor) {
        if (broken.has(name2)) {
          return broken.get(name2);
        }
        broken.set(name2, false);
        if (descriptor.syntax !== null) {
          walk$1(descriptor.syntax, function(node2) {
            if (node2.type !== "Type" && node2.type !== "Property") {
              return;
            }
            const map = node2.type === "Type" ? syntax2.types : syntax2.properties;
            const brokenMap = node2.type === "Type" ? brokenTypes : brokenProperties;
            if (!hasOwnProperty.call(map, node2.name)) {
              errors.push(`${syntaxRef(name2, broken === brokenTypes)} used missed syntax definition ${syntaxRef(node2.name, node2.type === "Type")}`);
              broken.set(name2, true);
            } else if (validate(syntax2, node2.name, brokenMap, map[node2.name])) {
              errors.push(`${syntaxRef(name2, broken === brokenTypes)} used broken syntax definition ${syntaxRef(node2.name, node2.type === "Type")}`);
              broken.set(name2, true);
            }
          }, this);
        }
      }
      const errors = [];
      let brokenTypes = /* @__PURE__ */ new Map();
      let brokenProperties = /* @__PURE__ */ new Map();
      for (const key in this.types) {
        validate(this, key, brokenTypes, this.types[key]);
      }
      for (const key in this.properties) {
        validate(this, key, brokenProperties, this.properties[key]);
      }
      const brokenTypesArray = [
        ...brokenTypes.keys()
      ].filter((name2) => brokenTypes.get(name2));
      const brokenPropertiesArray = [
        ...brokenProperties.keys()
      ].filter((name2) => brokenProperties.get(name2));
      if (brokenTypesArray.length || brokenPropertiesArray.length) {
        return {
          errors,
          types: brokenTypesArray,
          properties: brokenPropertiesArray
        };
      }
      return null;
    }
    dump(syntaxAsAst, pretty) {
      return {
        generic: this.generic,
        cssWideKeywords: this.cssWideKeywords,
        units: this.units,
        types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
        properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
        atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
      };
    }
    toString() {
      return JSON.stringify(this.dump());
    }
  }
  function appendOrSet(a, b) {
    if (typeof b === "string" && /^\s*\|/.test(b)) {
      return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
    }
    return b || null;
  }
  function sliceProps(obj, props) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const [key, value2] of Object.entries(obj)) {
      if (value2) {
        result[key] = {};
        for (const prop of Object.keys(value2)) {
          if (props.includes(prop)) {
            result[key][prop] = value2[prop];
          }
        }
      }
    }
    return result;
  }
  function mix(dest, src) {
    const result = {
      ...dest
    };
    for (const [prop, value2] of Object.entries(src)) {
      switch (prop) {
        case "generic":
          result[prop] = Boolean(value2);
          break;
        case "cssWideKeywords":
          result[prop] = dest[prop] ? [
            ...dest[prop],
            ...value2
          ] : value2 || [];
          break;
        case "units":
          result[prop] = {
            ...dest[prop]
          };
          for (const [name2, patch] of Object.entries(value2)) {
            result[prop][name2] = Array.isArray(patch) ? patch : [];
          }
          break;
        case "atrules":
          result[prop] = {
            ...dest[prop]
          };
          for (const [name2, atrule2] of Object.entries(value2)) {
            const exists = result[prop][name2] || {};
            const current = result[prop][name2] = {
              prelude: exists.prelude || null,
              descriptors: {
                ...exists.descriptors
              }
            };
            if (!atrule2) {
              continue;
            }
            current.prelude = atrule2.prelude ? appendOrSet(current.prelude, atrule2.prelude) : current.prelude || null;
            for (const [descriptorName, descriptorValue] of Object.entries(atrule2.descriptors || {})) {
              current.descriptors[descriptorName] = descriptorValue ? appendOrSet(current.descriptors[descriptorName], descriptorValue) : null;
            }
            if (!Object.keys(current.descriptors).length) {
              current.descriptors = null;
            }
          }
          break;
        case "types":
        case "properties":
          result[prop] = {
            ...dest[prop]
          };
          for (const [name2, syntax2] of Object.entries(value2)) {
            result[prop][name2] = appendOrSet(result[prop][name2], syntax2);
          }
          break;
        case "scope":
        case "features":
          result[prop] = {
            ...dest[prop]
          };
          for (const [name2, props] of Object.entries(value2)) {
            result[prop][name2] = {
              ...result[prop][name2],
              ...props
            };
          }
          break;
        case "parseContext":
          result[prop] = {
            ...dest[prop],
            ...value2
          };
          break;
        case "atrule":
        case "pseudo":
          result[prop] = {
            ...dest[prop],
            ...sliceProps(value2, [
              "parse"
            ])
          };
          break;
        case "node":
          result[prop] = {
            ...dest[prop],
            ...sliceProps(value2, [
              "name",
              "structure",
              "parse",
              "generate",
              "walkContext"
            ])
          };
          break;
      }
    }
    return result;
  }
  function createSyntax(config) {
    const parse2 = createParser(config);
    const walk2 = createWalker(config);
    const generate2 = createGenerator(config);
    const { fromPlainObject: fromPlainObject2, toPlainObject: toPlainObject2 } = createConvertor(walk2);
    const syntax2 = {
      lexer: null,
      createLexer: (config2) => new Lexer(config2, syntax2, syntax2.lexer.structure),
      tokenize: tokenize$1,
      parse: parse2,
      generate: generate2,
      walk: walk2,
      find: walk2.find,
      findLast: walk2.findLast,
      findAll: walk2.findAll,
      fromPlainObject: fromPlainObject2,
      toPlainObject: toPlainObject2,
      fork(extension) {
        const base = mix({}, config);
        return createSyntax(typeof extension === "function" ? extension(base) : mix(base, extension));
      }
    };
    syntax2.lexer = new Lexer({
      generic: config.generic,
      cssWideKeywords: config.cssWideKeywords,
      units: config.units,
      types: config.types,
      atrules: config.atrules,
      properties: config.properties,
      node: config.node
    }, syntax2);
    return syntax2;
  }
  const createSyntax$1 = (config) => createSyntax(mix({}, config));
  const definitions = {
    "generic": true,
    "cssWideKeywords": [
      "initial",
      "inherit",
      "unset",
      "revert",
      "revert-layer"
    ],
    "units": {
      "angle": [
        "deg",
        "grad",
        "rad",
        "turn"
      ],
      "decibel": [
        "db"
      ],
      "flex": [
        "fr"
      ],
      "frequency": [
        "hz",
        "khz"
      ],
      "length": [
        "cm",
        "mm",
        "q",
        "in",
        "pt",
        "pc",
        "px",
        "em",
        "rem",
        "ex",
        "rex",
        "cap",
        "rcap",
        "ch",
        "rch",
        "ic",
        "ric",
        "lh",
        "rlh",
        "vw",
        "svw",
        "lvw",
        "dvw",
        "vh",
        "svh",
        "lvh",
        "dvh",
        "vi",
        "svi",
        "lvi",
        "dvi",
        "vb",
        "svb",
        "lvb",
        "dvb",
        "vmin",
        "svmin",
        "lvmin",
        "dvmin",
        "vmax",
        "svmax",
        "lvmax",
        "dvmax",
        "cqw",
        "cqh",
        "cqi",
        "cqb",
        "cqmin",
        "cqmax"
      ],
      "resolution": [
        "dpi",
        "dpcm",
        "dppx",
        "x"
      ],
      "semitones": [
        "st"
      ],
      "time": [
        "s",
        "ms"
      ]
    },
    "types": {
      "abs()": "abs( <calc-sum> )",
      "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
      "acos()": "acos( <calc-sum> )",
      "alpha-value": "<number>|<percentage>",
      "angle-percentage": "<angle>|<percentage>",
      "angular-color-hint": "<angle-percentage>",
      "angular-color-stop": "<color>&&<color-stop-angle>?",
      "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
      "animateable-feature": "scroll-position|contents|<custom-ident>",
      "asin()": "asin( <calc-sum> )",
      "atan()": "atan( <calc-sum> )",
      "atan2()": "atan2( <calc-sum> , <calc-sum> )",
      "attachment": "scroll|fixed|local",
      "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
      "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
      "attr-modifier": "i|s",
      "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
      "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
      "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
      "axis": "block|inline|x|y",
      "baseline-position": "[first|last]? baseline",
      "basic-shape": "<inset()>|<xywh()>|<rect()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
      "bg-image": "none|<image>",
      "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
      "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
      "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
      "blur()": "blur( <length> )",
      "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
      "box": "border-box|padding-box|content-box",
      "brightness()": "brightness( <number-percentage> )",
      "calc()": "calc( <calc-sum> )",
      "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
      "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
      "calc-value": "<number>|<dimension>|<percentage>|<calc-constant>|( <calc-sum> )",
      "calc-constant": "e|pi|infinity|-infinity|NaN",
      "cf-final-image": "<image>|<color>",
      "cf-mixing-image": "<percentage>?&&<image>",
      "circle()": "circle( [<shape-radius>]? [at <position>]? )",
      "clamp()": "clamp( <calc-sum>#{3} )",
      "class-selector": "'.' <ident-token>",
      "clip-source": "<url>",
      "color": "<color-base>|currentColor|<system-color>|<device-cmyk()>|<light-dark()>|<-non-standard-color>",
      "color-stop": "<color-stop-length>|<color-stop-angle>",
      "color-stop-angle": "<angle-percentage>{1,2}",
      "color-stop-length": "<length-percentage>{1,2}",
      "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
      "color-interpolation-method": "in [<rectangular-color-space>|<polar-color-space> <hue-interpolation-method>?|<custom-color-space>]",
      "combinator": "'>'|'+'|'~'|['|' '|']",
      "common-lig-values": "[common-ligatures|no-common-ligatures]",
      "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
      "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
      "compositing-operator": "add|subtract|intersect|exclude",
      "compound-selector": "[<type-selector>? <subclass-selector>*]!",
      "compound-selector-list": "<compound-selector>#",
      "complex-selector": "<complex-selector-unit> [<combinator>? <complex-selector-unit>]*",
      "complex-selector-list": "<complex-selector>#",
      "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
      "contextual-alt-values": "[contextual|no-contextual]",
      "content-distribution": "space-between|space-around|space-evenly|stretch",
      "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+",
      "content-position": "center|start|end|flex-start|flex-end",
      "content-replacement": "<image>",
      "contrast()": "contrast( [<number-percentage>] )",
      "cos()": "cos( <calc-sum> )",
      "counter": "<counter()>|<counters()>",
      "counter()": "counter( <counter-name> , <counter-style>? )",
      "counter-name": "<custom-ident>",
      "counter-style": "<counter-style-name>|symbols( )",
      "counter-style-name": "<custom-ident>",
      "counters()": "counters( <counter-name> , <string> , <counter-style>? )",
      "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
      "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
      "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
      "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
      "display-box": "contents|none",
      "display-inside": "flow|flow-root|table|flex|grid|ruby",
      "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
      "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
      "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
      "display-outside": "block|inline|run-in",
      "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
      "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
      "east-asian-width-values": "[full-width|proportional-width]",
      "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
      "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
      "ending-shape": "circle|ellipse",
      "env()": "env( <custom-ident> , <declaration-value>? )",
      "exp()": "exp( <calc-sum> )",
      "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
      "family-name": "<string>|<custom-ident>+",
      "feature-tag-value": "<string> [<integer>|on|off]?",
      "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
      "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
      "feature-value-block-list": "<feature-value-block>+",
      "feature-value-declaration": "<custom-ident> : <integer>+ ;",
      "feature-value-declaration-list": "<feature-value-declaration>",
      "feature-value-name": "<custom-ident>",
      "fill-rule": "nonzero|evenodd",
      "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
      "filter-function-list": "[<filter-function>|<url>]+",
      "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
      "fixed-breadth": "<length-percentage>",
      "fixed-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
      "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
      "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
      "font-variant-css21": "[normal|small-caps]",
      "font-weight-absolute": "normal|bold|<number [1,1000]>",
      "frequency-percentage": "<frequency>|<percentage>",
      "general-enclosed": "[<function-token> <any-value>? )]|[( <any-value>? )]",
      "generic-family": "<generic-script-specific>|<generic-complete>|<generic-incomplete>|<-non-standard-generic-family>",
      "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
      "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
      "gradient": "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>",
      "grayscale()": "grayscale( <number-percentage> )",
      "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
      "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
      "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
      "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
      "hue": "<number>|<angle>",
      "hue-rotate()": "hue-rotate( <angle> )",
      "hue-interpolation-method": "[shorter|longer|increasing|decreasing] hue",
      "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )",
      "hypot()": "hypot( <calc-sum># )",
      "image": "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
      "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
      "image-set()": "image-set( <image-set-option># )",
      "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
      "image-src": "<url>|<string>",
      "image-tags": "ltr|rtl",
      "inflexible-breadth": "<length-percentage>|min-content|max-content|auto",
      "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
      "invert()": "invert( <number-percentage> )",
      "keyframes-name": "<custom-ident>|<string>",
      "keyframe-block": "<keyframe-selector># { <declaration-list> }",
      "keyframe-block-list": "<keyframe-block>+",
      "keyframe-selector": "from|to|<percentage>|<timeline-range-name> <percentage>",
      "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
      "layer()": "layer( <layer-name> )",
      "layer-name": "<ident> ['.' <ident>]*",
      "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
      "leader()": "leader( <leader-type> )",
      "leader-type": "dotted|solid|space|<string>",
      "length-percentage": "<length>|<percentage>",
      "light-dark()": "light-dark( <color> , <color> )",
      "line-names": "'[' <custom-ident>* ']'",
      "line-name-list": "[<line-names>|<name-repeat>]+",
      "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
      "line-width": "<length>|thin|medium|thick",
      "linear-color-hint": "<length-percentage>",
      "linear-color-stop": "<color> <color-stop-length>?",
      "linear-gradient()": "linear-gradient( [[<angle>|to <side-or-corner>]||<color-interpolation-method>]? , <color-stop-list> )",
      "log()": "log( <calc-sum> , <calc-sum>? )",
      "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
      "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
      "mask-reference": "none|<image>|<mask-source>",
      "mask-source": "<url>",
      "masking-mode": "alpha|luminance|match-source",
      "matrix()": "matrix( <number>#{6} )",
      "matrix3d()": "matrix3d( <number>#{16} )",
      "max()": "max( <calc-sum># )",
      "media-and": "<media-in-parens> [and <media-in-parens>]+",
      "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
      "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
      "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
      "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
      "media-not": "not <media-in-parens>",
      "media-or": "<media-in-parens> [or <media-in-parens>]+",
      "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
      "media-query-list": "<media-query>#",
      "media-type": "<ident>",
      "mf-boolean": "<mf-name>",
      "mf-name": "<ident>",
      "mf-plain": "<mf-name> : <mf-value>",
      "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
      "mf-value": "<number>|<dimension>|<ident>|<ratio>",
      "min()": "min( <calc-sum># )",
      "minmax()": "minmax( [<length-percentage>|min-content|max-content|auto] , [<length-percentage>|<flex>|min-content|max-content|auto] )",
      "mod()": "mod( <calc-sum> , <calc-sum> )",
      "name-repeat": "repeat( [<integer [1,\u221E]>|auto-fill] , <line-names>+ )",
      "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen",
      "namespace-prefix": "<ident>",
      "ns-prefix": "[<ident-token>|'*']? '|'",
      "number-percentage": "<number>|<percentage>",
      "numeric-figure-values": "[lining-nums|oldstyle-nums]",
      "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
      "numeric-spacing-values": "[proportional-nums|tabular-nums]",
      "nth": "<an-plus-b>|even|odd",
      "opacity()": "opacity( [<number-percentage>] )",
      "overflow-position": "unsafe|safe",
      "outline-radius": "<length>|<percentage>",
      "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
      "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
      "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
      "page-selector-list": "[<page-selector>#]?",
      "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
      "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
      "path()": "path( [<fill-rule> ,]? <string> )",
      "paint()": "paint( <ident> , <declaration-value>? )",
      "perspective()": "perspective( [<length [0,\u221E]>|none] )",
      "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
      "polar-color-space": "hsl|hwb|lch|oklch",
      "position": "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
      "pow()": "pow( <calc-sum> , <calc-sum> )",
      "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
      "pseudo-element-selector": "':' <pseudo-class-selector>|<legacy-pseudo-element-selector>",
      "pseudo-page": ": [left|right|first|blank]",
      "quote": "open-quote|close-quote|no-open-quote|no-close-quote",
      "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
      "ratio": "<number [0,\u221E]> [/ <number [0,\u221E]>]?",
      "ray()": "ray( <angle>&&<ray-size>?&&contain?&&[at <position>]? )",
      "ray-size": "closest-side|closest-corner|farthest-side|farthest-corner|sides",
      "rectangular-color-space": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020|lab|oklab|xyz|xyz-d50|xyz-d65",
      "relative-selector": "<combinator>? <complex-selector>",
      "relative-selector-list": "<relative-selector>#",
      "relative-size": "larger|smaller",
      "rem()": "rem( <calc-sum> , <calc-sum> )",
      "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
      "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
      "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
      "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
      "reversed-counter-name": "reversed( <counter-name> )",
      "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
      "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
      "rotate()": "rotate( [<angle>|<zero>] )",
      "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
      "rotateX()": "rotateX( [<angle>|<zero>] )",
      "rotateY()": "rotateY( [<angle>|<zero>] )",
      "rotateZ()": "rotateZ( [<angle>|<zero>] )",
      "round()": "round( <rounding-strategy>? , <calc-sum> , <calc-sum> )",
      "rounding-strategy": "nearest|up|down|to-zero",
      "saturate()": "saturate( <number-percentage> )",
      "scale()": "scale( [<number>|<percentage>]#{1,2} )",
      "scale3d()": "scale3d( [<number>|<percentage>]#{3} )",
      "scaleX()": "scaleX( [<number>|<percentage>] )",
      "scaleY()": "scaleY( [<number>|<percentage>] )",
      "scaleZ()": "scaleZ( [<number>|<percentage>] )",
      "scroll()": "scroll( [<axis>||<scroller>]? )",
      "scroller": "root|nearest|self",
      "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
      "shape-radius": "<length-percentage>|closest-side|farthest-side",
      "sign()": "sign( <calc-sum> )",
      "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
      "skewX()": "skewX( [<angle>|<zero>] )",
      "skewY()": "skewY( [<angle>|<zero>] )",
      "sepia()": "sepia( <number-percentage> )",
      "shadow": "inset?&&<length>{2,4}&&<color>?",
      "shadow-t": "[<length>{2,3}&&<color>?]",
      "shape": "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
      "shape-box": "<box>|margin-box",
      "side-or-corner": "[left|right]||[top|bottom]",
      "sin()": "sin( <calc-sum> )",
      "single-animation": "<'animation-duration'>||<easing-function>||<'animation-delay'>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]||<single-animation-timeline>",
      "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
      "single-animation-fill-mode": "none|forwards|backwards|both",
      "single-animation-iteration-count": "infinite|<number>",
      "single-animation-play-state": "running|paused",
      "single-animation-timeline": "auto|none|<dashed-ident>|<scroll()>|<view()>",
      "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>||<transition-behavior-value>",
      "single-transition-property": "all|<custom-ident>",
      "size": "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
      "sqrt()": "sqrt( <calc-sum> )",
      "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
      "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
      "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
      "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
      "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
      "supports-feature": "<supports-decl>|<supports-selector-fn>",
      "supports-decl": "( <declaration> )",
      "supports-selector-fn": "selector( <complex-selector> )",
      "symbol": "<string>|<image>|<custom-ident>",
      "system-color": "AccentColor|AccentColorText|ActiveText|ButtonBorder|ButtonFace|ButtonText|Canvas|CanvasText|Field|FieldText|GrayText|Highlight|HighlightText|LinkText|Mark|MarkText|SelectedItem|SelectedItemText|VisitedText",
      "tan()": "tan( <calc-sum> )",
      "target": "<target-counter()>|<target-counters()>|<target-text()>",
      "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
      "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
      "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
      "time-percentage": "<time>|<percentage>",
      "timeline-range-name": "cover|contain|entry|exit|entry-crossing|exit-crossing",
      "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
      "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
      "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
      "track-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <track-size>]+ <line-names>? )",
      "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( <length-percentage> )",
      "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
      "transform-list": "<transform-function>+",
      "transition-behavior-value": "normal|allow-discrete",
      "translate()": "translate( <length-percentage> , <length-percentage>? )",
      "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
      "translateX()": "translateX( <length-percentage> )",
      "translateY()": "translateY( <length-percentage> )",
      "translateZ()": "translateZ( <length> )",
      "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
      "type-selector": "<wq-name>|<ns-prefix>? '*'",
      "var()": "var( <custom-property-name> , <declaration-value>? )",
      "view()": "view( [<axis>||<'view-timeline-inset'>]? )",
      "viewport-length": "auto|<length-percentage>",
      "visual-box": "content-box|padding-box|border-box",
      "wq-name": "<ns-prefix>? <ident-token>",
      "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
      "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
      "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
      "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
      "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
      "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
      "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
      "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
      "-legacy-radial-gradient-shape": "circle|ellipse",
      "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
      "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
      "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
      "-non-standard-overflow": "overlay|-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
      "-non-standard-size": "intrinsic|min-intrinsic|-webkit-fill-available|-webkit-fit-content|-webkit-min-content|-webkit-max-content|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content",
      "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
      "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
      "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
      "-webkit-gradient-radius": "<length>|<percentage>",
      "-webkit-gradient-type": "linear|radial",
      "-webkit-mask-box-repeat": "repeat|stretch|round",
      "-ms-filter-function-list": "<-ms-filter-function>+",
      "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
      "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
      "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
      "absolute-color-base": "<hex-color>|<absolute-color-function>|<named-color>|transparent",
      "absolute-color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
      "age": "child|young|old",
      "anchor-name": "<dashed-ident>",
      "attr-name": "<wq-name>",
      "attr-fallback": "<any-value>",
      "bg-clip": "<box>|border|text",
      "bottom": "<length>|auto",
      "container-name": "<custom-ident>",
      "container-condition": "not <query-in-parens>|<query-in-parens> [[and <query-in-parens>]*|[or <query-in-parens>]*]",
      "coord-box": "content-box|padding-box|border-box|fill-box|stroke-box|view-box",
      "generic-voice": "[<age>? <gender> <integer>?]",
      "gender": "male|female|neutral",
      "generic-script-specific": "generic( kai )|generic( fangsong )|generic( nastaliq )",
      "generic-complete": "serif|sans-serif|system-ui|cursive|fantasy|math|monospace",
      "generic-incomplete": "ui-serif|ui-sans-serif|ui-monospace|ui-rounded",
      "-non-standard-generic-family": "-apple-system|BlinkMacSystemFont",
      "left": "<length>|auto",
      "color-base": "<hex-color>|<color-function>|<named-color>|<color-mix()>|transparent",
      "color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
      "device-cmyk()": "<legacy-device-cmyk-syntax>|<modern-device-cmyk-syntax>",
      "legacy-device-cmyk-syntax": "device-cmyk( <number>#{4} )",
      "modern-device-cmyk-syntax": "device-cmyk( <cmyk-component>{4} [/ [<alpha-value>|none]]? )",
      "cmyk-component": "<number>|<percentage>|none",
      "color-mix()": "color-mix( <color-interpolation-method> , [<color>&&<percentage [0,100]>?]#{2} )",
      "color-space": "<rectangular-color-space>|<polar-color-space>|<custom-color-space>",
      "custom-color-space": "<dashed-ident>",
      "paint": "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
      "palette-identifier": "<dashed-ident>",
      "right": "<length>|auto",
      "scope-start": "<forgiving-selector-list>",
      "scope-end": "<forgiving-selector-list>",
      "forgiving-selector-list": "<complex-real-selector-list>",
      "forgiving-relative-selector-list": "<relative-real-selector-list>",
      "selector-list": "<complex-selector-list>",
      "complex-real-selector-list": "<complex-real-selector>#",
      "simple-selector-list": "<simple-selector>#",
      "relative-real-selector-list": "<relative-real-selector>#",
      "complex-selector-unit": "[<compound-selector>? <pseudo-compound-selector>*]!",
      "complex-real-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
      "relative-real-selector": "<combinator>? <complex-real-selector>",
      "pseudo-compound-selector": "<pseudo-element-selector> <pseudo-class-selector>*",
      "simple-selector": "<type-selector>|<subclass-selector>",
      "legacy-pseudo-element-selector": "':' [before|after|first-line|first-letter]",
      "single-animation-composition": "replace|add|accumulate",
      "svg-length": "<percentage>|<length>|<number>",
      "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
      "top": "<length>|auto",
      "x": "<number>",
      "y": "<number>",
      "declaration": "<ident-token> : <declaration-value>? ['!' important]?",
      "declaration-list": "[<declaration>? ';']* <declaration>?",
      "url": "url( <string> <url-modifier>* )|<url-token>",
      "url-modifier": "<ident>|<function-token> <any-value> )",
      "number-zero-one": "<number [0,1]>",
      "number-one-or-greater": "<number [1,\u221E]>",
      "color()": "color( <colorspace-params> [/ [<alpha-value>|none]]? )",
      "colorspace-params": "[<predefined-rgb-params>|<xyz-params>]",
      "predefined-rgb-params": "<predefined-rgb> [<number>|<percentage>|none]{3}",
      "predefined-rgb": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020",
      "xyz-params": "<xyz-space> [<number>|<percentage>|none]{3}",
      "xyz-space": "xyz|xyz-d50|xyz-d65",
      "oklab()": "oklab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
      "oklch()": "oklch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
      "offset-path": "<ray()>|<url>|<basic-shape>",
      "rect()": "rect( [<length-percentage>|auto]{4} [round <'border-radius'>]? )",
      "xywh()": "xywh( <length-percentage>{2} <length-percentage [0,\u221E]>{2} [round <'border-radius'>]? )",
      "query-in-parens": "( <container-condition> )|( <size-feature> )|style( <style-query> )|<general-enclosed>",
      "size-feature": "<mf-plain>|<mf-boolean>|<mf-range>",
      "style-feature": "<declaration>",
      "style-query": "<style-condition>|<style-feature>",
      "style-condition": "not <style-in-parens>|<style-in-parens> [[and <style-in-parens>]*|[or <style-in-parens>]*]",
      "style-in-parens": "( <style-condition> )|( <style-feature> )|<general-enclosed>",
      "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box",
      "inset-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
      "position-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|center|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|center|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
      "anchor()": "anchor( <anchor-element>?&&<anchor-side> , <length-percentage>? )",
      "anchor-side": "inside|outside|top|left|right|bottom|start|end|self-start|self-end|<percentage>|center",
      "anchor-size()": "anchor-size( [<anchor-element>||<anchor-size>]? , <length-percentage>? )",
      "anchor-size": "width|height|block|inline|self-block|self-inline",
      "anchor-element": "<dashed-ident>",
      "try-size": "most-width|most-height|most-block-size|most-inline-size",
      "try-tactic": "flip-block||flip-inline||flip-start",
      "font-variant-css2": "normal|small-caps",
      "font-width-css3": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded",
      "system-family-name": "caption|icon|menu|message-box|small-caption|status-bar"
    },
    "properties": {
      "--*": "<declaration-value>",
      "-ms-accelerator": "false|true",
      "-ms-block-progression": "tb|rl|bt|lr",
      "-ms-content-zoom-chaining": "none|chained",
      "-ms-content-zooming": "none|zoom",
      "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
      "-ms-content-zoom-limit-max": "<percentage>",
      "-ms-content-zoom-limit-min": "<percentage>",
      "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
      "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
      "-ms-content-zoom-snap-type": "none|proximity|mandatory",
      "-ms-filter": "<string>",
      "-ms-flow-from": "[none|<custom-ident>]#",
      "-ms-flow-into": "[none|<custom-ident>]#",
      "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
      "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
      "-ms-high-contrast-adjust": "auto|none",
      "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
      "-ms-hyphenate-limit-lines": "no-limit|<integer>",
      "-ms-hyphenate-limit-zone": "<percentage>|<length>",
      "-ms-ime-align": "auto|after",
      "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
      "-ms-scrollbar-3dlight-color": "<color>",
      "-ms-scrollbar-arrow-color": "<color>",
      "-ms-scrollbar-base-color": "<color>",
      "-ms-scrollbar-darkshadow-color": "<color>",
      "-ms-scrollbar-face-color": "<color>",
      "-ms-scrollbar-highlight-color": "<color>",
      "-ms-scrollbar-shadow-color": "<color>",
      "-ms-scrollbar-track-color": "<color>",
      "-ms-scroll-chaining": "chained|none",
      "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
      "-ms-scroll-limit-x-max": "auto|<length>",
      "-ms-scroll-limit-x-min": "<length>",
      "-ms-scroll-limit-y-max": "auto|<length>",
      "-ms-scroll-limit-y-min": "<length>",
      "-ms-scroll-rails": "none|railed",
      "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
      "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
      "-ms-scroll-snap-type": "none|proximity|mandatory",
      "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
      "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
      "-ms-scroll-translation": "none|vertical-to-horizontal",
      "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
      "-ms-touch-select": "grippers|none",
      "-ms-user-select": "none|element|text",
      "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
      "-ms-wrap-margin": "<length>",
      "-ms-wrap-through": "wrap|none",
      "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
      "-moz-binding": "<url>|none",
      "-moz-border-bottom-colors": "<color>+|none",
      "-moz-border-left-colors": "<color>+|none",
      "-moz-border-right-colors": "<color>+|none",
      "-moz-border-top-colors": "<color>+|none",
      "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
      "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
      "-moz-force-broken-image-icon": "0|1",
      "-moz-image-region": "<shape>|auto",
      "-moz-orient": "inline|block|horizontal|vertical",
      "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
      "-moz-outline-radius-bottomleft": "<outline-radius>",
      "-moz-outline-radius-bottomright": "<outline-radius>",
      "-moz-outline-radius-topleft": "<outline-radius>",
      "-moz-outline-radius-topright": "<outline-radius>",
      "-moz-stack-sizing": "ignore|stretch-to-fit",
      "-moz-text-blink": "none|blink",
      "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
      "-moz-user-input": "auto|none|enabled|disabled",
      "-moz-user-modify": "read-only|read-write|write-only",
      "-moz-window-dragging": "drag|no-drag",
      "-moz-window-shadow": "default|menu|tooltip|sheet|none",
      "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
      "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
      "-webkit-border-before-color": "<color>",
      "-webkit-border-before-style": "<'border-style'>",
      "-webkit-border-before-width": "<'border-width'>",
      "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
      "-webkit-line-clamp": "none|<integer>",
      "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
      "-webkit-mask-attachment": "<attachment>#",
      "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
      "-webkit-mask-composite": "<composite-style>#",
      "-webkit-mask-image": "<mask-reference>#",
      "-webkit-mask-origin": "[<box>|border|padding|content]#",
      "-webkit-mask-position": "<position>#",
      "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
      "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
      "-webkit-mask-repeat": "<repeat-style>#",
      "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
      "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
      "-webkit-mask-size": "<bg-size>#",
      "-webkit-overflow-scrolling": "auto|touch",
      "-webkit-tap-highlight-color": "<color>",
      "-webkit-text-fill-color": "<color>",
      "-webkit-text-stroke": "<length>||<color>",
      "-webkit-text-stroke-color": "<color>",
      "-webkit-text-stroke-width": "<length>",
      "-webkit-touch-callout": "default|none",
      "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
      "accent-color": "auto|<color>",
      "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
      "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
      "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
      "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
      "all": "initial|inherit|unset|revert|revert-layer",
      "anchor-name": "none|<dashed-ident>#",
      "anchor-scope": "none|all|<dashed-ident>#",
      "animation": "<single-animation>#",
      "animation-composition": "<single-animation-composition>#",
      "animation-delay": "<time>#",
      "animation-direction": "<single-animation-direction>#",
      "animation-duration": "<time>#",
      "animation-fill-mode": "<single-animation-fill-mode>#",
      "animation-iteration-count": "<single-animation-iteration-count>#",
      "animation-name": "[none|<keyframes-name>]#",
      "animation-play-state": "<single-animation-play-state>#",
      "animation-range": "[<'animation-range-start'> <'animation-range-end'>?]#",
      "animation-range-end": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
      "animation-range-start": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
      "animation-timing-function": "<easing-function>#",
      "animation-timeline": "<single-animation-timeline>#",
      "appearance": "none|auto|textfield|menulist-button|<compat-auto>",
      "aspect-ratio": "auto||<ratio>",
      "azimuth": "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
      "backdrop-filter": "none|<filter-function-list>",
      "backface-visibility": "visible|hidden",
      "background": "[<bg-layer> ,]* <final-bg-layer>",
      "background-attachment": "<attachment>#",
      "background-blend-mode": "<blend-mode>#",
      "background-clip": "<bg-clip>#",
      "background-color": "<color>",
      "background-image": "<bg-image>#",
      "background-origin": "<box>#",
      "background-position": "<bg-position>#",
      "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
      "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
      "background-repeat": "<repeat-style>#",
      "background-size": "<bg-size>#",
      "block-size": "<'width'>",
      "border": "<line-width>||<line-style>||<color>",
      "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-block-color": "<'border-top-color'>{1,2}",
      "border-block-style": "<'border-top-style'>",
      "border-block-width": "<'border-top-width'>",
      "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-block-end-color": "<'border-top-color'>",
      "border-block-end-style": "<'border-top-style'>",
      "border-block-end-width": "<'border-top-width'>",
      "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-block-start-color": "<'border-top-color'>",
      "border-block-start-style": "<'border-top-style'>",
      "border-block-start-width": "<'border-top-width'>",
      "border-bottom": "<line-width>||<line-style>||<color>",
      "border-bottom-color": "<'border-top-color'>",
      "border-bottom-left-radius": "<length-percentage>{1,2}",
      "border-bottom-right-radius": "<length-percentage>{1,2}",
      "border-bottom-style": "<line-style>",
      "border-bottom-width": "<line-width>",
      "border-collapse": "collapse|separate",
      "border-color": "<color>{1,4}",
      "border-end-end-radius": "<length-percentage>{1,2}",
      "border-end-start-radius": "<length-percentage>{1,2}",
      "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
      "border-image-outset": "[<length>|<number>]{1,4}",
      "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
      "border-image-slice": "<number-percentage>{1,4}&&fill?",
      "border-image-source": "none|<image>",
      "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
      "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-inline-color": "<'border-top-color'>{1,2}",
      "border-inline-style": "<'border-top-style'>",
      "border-inline-width": "<'border-top-width'>",
      "border-inline-end-color": "<'border-top-color'>",
      "border-inline-end-style": "<'border-top-style'>",
      "border-inline-end-width": "<'border-top-width'>",
      "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-inline-start-color": "<'border-top-color'>",
      "border-inline-start-style": "<'border-top-style'>",
      "border-inline-start-width": "<'border-top-width'>",
      "border-left": "<line-width>||<line-style>||<color>",
      "border-left-color": "<color>",
      "border-left-style": "<line-style>",
      "border-left-width": "<line-width>",
      "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
      "border-right": "<line-width>||<line-style>||<color>",
      "border-right-color": "<color>",
      "border-right-style": "<line-style>",
      "border-right-width": "<line-width>",
      "border-spacing": "<length> <length>?",
      "border-start-end-radius": "<length-percentage>{1,2}",
      "border-start-start-radius": "<length-percentage>{1,2}",
      "border-style": "<line-style>{1,4}",
      "border-top": "<line-width>||<line-style>||<color>",
      "border-top-color": "<color>",
      "border-top-left-radius": "<length-percentage>{1,2}",
      "border-top-right-radius": "<length-percentage>{1,2}",
      "border-top-style": "<line-style>",
      "border-top-width": "<line-width>",
      "border-width": "<line-width>{1,4}",
      "bottom": "<length>|<percentage>|auto",
      "box-align": "start|center|end|baseline|stretch",
      "box-decoration-break": "slice|clone",
      "box-direction": "normal|reverse|inherit",
      "box-flex": "<number>",
      "box-flex-group": "<integer>",
      "box-lines": "single|multiple",
      "box-ordinal-group": "<integer>",
      "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
      "box-pack": "start|center|end|justify",
      "box-shadow": "none|<shadow>#",
      "box-sizing": "content-box|border-box",
      "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
      "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
      "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
      "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
      "caret": "<'caret-color'>||<'caret-shape'>",
      "caret-color": "auto|<color>",
      "caret-shape": "auto|bar|block|underscore",
      "clear": "none|left|right|both|inline-start|inline-end",
      "clip": "<shape>|auto",
      "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
      "clip-rule": "nonzero|evenodd",
      "color": "<color>",
      "color-interpolation-filters": "auto|sRGB|linearRGB",
      "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?",
      "column-count": "<integer>|auto",
      "column-fill": "auto|balance",
      "column-gap": "normal|<length-percentage>",
      "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
      "column-rule-color": "<color>",
      "column-rule-style": "<'border-style'>",
      "column-rule-width": "<'border-width'>",
      "column-span": "none|all",
      "column-width": "<length>|auto",
      "columns": "<'column-width'>||<'column-count'>",
      "contain": "none|strict|content|[[size||inline-size]||layout||style||paint]",
      "contain-intrinsic-size": "[auto? [none|<length>]]{1,2}",
      "contain-intrinsic-block-size": "auto? [none|<length>]",
      "contain-intrinsic-height": "auto? [none|<length>]",
      "contain-intrinsic-inline-size": "auto? [none|<length>]",
      "contain-intrinsic-width": "auto? [none|<length>]",
      "container": "<'container-name'> [/ <'container-type'>]?",
      "container-name": "none|<custom-ident>+",
      "container-type": "normal||[size|inline-size]",
      "content": "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?",
      "content-visibility": "visible|auto|hidden",
      "counter-increment": "[<counter-name> <integer>?]+|none",
      "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none",
      "counter-set": "[<counter-name> <integer>?]+|none",
      "cursor": "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
      "d": "none|path( <string> )",
      "cx": "<length>|<percentage>",
      "cy": "<length>|<percentage>",
      "direction": "ltr|rtl",
      "display": "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
      "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
      "empty-cells": "show|hide",
      "field-sizing": "content|fixed",
      "fill": "<paint>",
      "fill-opacity": "<number-zero-one>",
      "fill-rule": "nonzero|evenodd",
      "filter": "none|<filter-function-list>|<-ms-filter-function-list>",
      "flex": "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
      "flex-basis": "content|<'width'>",
      "flex-direction": "row|row-reverse|column|column-reverse",
      "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
      "flex-grow": "<number>",
      "flex-shrink": "<number>",
      "flex-wrap": "nowrap|wrap|wrap-reverse",
      "float": "left|right|none|inline-start|inline-end",
      "font": "[[<'font-style'>||<font-variant-css2>||<'font-weight'>||<font-width-css3>]? <'font-size'> [/ <'line-height'>]? <'font-family'>#]|<system-family-name>|<-non-standard-font>",
      "font-family": "[<family-name>|<generic-family>]#",
      "font-feature-settings": "normal|<feature-tag-value>#",
      "font-kerning": "auto|normal|none",
      "font-language-override": "normal|<string>",
      "font-optical-sizing": "auto|none",
      "font-palette": "normal|light|dark|<palette-identifier>",
      "font-variation-settings": "normal|[<string> <number>]#",
      "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
      "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
      "font-smooth": "auto|never|always|<absolute-size>|<length>",
      "font-stretch": "<font-stretch-absolute>",
      "font-style": "normal|italic|oblique <angle>?",
      "font-synthesis": "none|[weight||style||small-caps||position]",
      "font-synthesis-position": "auto|none",
      "font-synthesis-small-caps": "auto|none",
      "font-synthesis-style": "auto|none",
      "font-synthesis-weight": "auto|none",
      "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
      "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
      "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
      "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
      "font-variant-emoji": "normal|text|emoji|unicode",
      "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
      "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
      "font-variant-position": "normal|sub|super",
      "font-weight": "<font-weight-absolute>|bolder|lighter",
      "forced-color-adjust": "auto|none|preserve-parent-color",
      "gap": "<'row-gap'> <'column-gap'>?",
      "grid": "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
      "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
      "grid-auto-columns": "<track-size>+",
      "grid-auto-flow": "[row|column]||dense",
      "grid-auto-rows": "<track-size>+",
      "grid-column": "<grid-line> [/ <grid-line>]?",
      "grid-column-end": "<grid-line>",
      "grid-column-gap": "<length-percentage>",
      "grid-column-start": "<grid-line>",
      "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
      "grid-row": "<grid-line> [/ <grid-line>]?",
      "grid-row-end": "<grid-line>",
      "grid-row-gap": "<length-percentage>",
      "grid-row-start": "<grid-line>",
      "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
      "grid-template-areas": "none|<string>+",
      "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
      "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
      "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
      "height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "hyphenate-character": "auto|<string>",
      "hyphenate-limit-chars": "[auto|<integer>]{1,3}",
      "hyphens": "none|manual|auto",
      "image-orientation": "from-image|<angle>|[<angle>? flip]",
      "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
      "image-resolution": "[from-image||<resolution>]&&snap?",
      "ime-mode": "auto|normal|active|inactive|disabled",
      "initial-letter": "normal|[<number> <integer>?]",
      "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
      "inline-size": "<'width'>",
      "input-security": "auto|none",
      "inset": "<'top'>{1,4}",
      "inset-block": "<'top'>{1,2}",
      "inset-block-end": "<'top'>",
      "inset-block-start": "<'top'>",
      "inset-inline": "<'top'>{1,2}",
      "inset-inline-end": "<'top'>",
      "inset-inline-start": "<'top'>",
      "interpolate-size": "numeric-only|allow-keywords",
      "isolation": "auto|isolate",
      "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
      "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
      "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
      "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
      "left": "<length>|<percentage>|auto",
      "letter-spacing": "normal|<length-percentage>",
      "line-break": "auto|loose|normal|strict|anywhere",
      "line-clamp": "none|<integer>",
      "line-height": "normal|<number>|<length>|<percentage>",
      "line-height-step": "<length>",
      "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
      "list-style-image": "<image>|none",
      "list-style-position": "inside|outside",
      "list-style-type": "<counter-style>|<string>|none",
      "margin": "[<length>|<percentage>|auto]{1,4}",
      "margin-block": "<'margin-left'>{1,2}",
      "margin-block-end": "<'margin-left'>",
      "margin-block-start": "<'margin-left'>",
      "margin-bottom": "<length>|<percentage>|auto",
      "margin-inline": "<'margin-left'>{1,2}",
      "margin-inline-end": "<'margin-left'>",
      "margin-inline-start": "<'margin-left'>",
      "margin-left": "<length>|<percentage>|auto",
      "margin-right": "<length>|<percentage>|auto",
      "margin-top": "<length>|<percentage>|auto",
      "margin-trim": "none|in-flow|all",
      "marker": "none|<url>",
      "marker-end": "none|<url>",
      "marker-mid": "none|<url>",
      "marker-start": "none|<url>",
      "mask": "<mask-layer>#",
      "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
      "mask-border-mode": "luminance|alpha",
      "mask-border-outset": "[<length>|<number>]{1,4}",
      "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
      "mask-border-slice": "<number-percentage>{1,4} fill?",
      "mask-border-source": "none|<image>",
      "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
      "mask-clip": "[<geometry-box>|no-clip]#",
      "mask-composite": "<compositing-operator>#",
      "mask-image": "<mask-reference>#",
      "mask-mode": "<masking-mode>#",
      "mask-origin": "<geometry-box>#",
      "mask-position": "<position>#",
      "mask-repeat": "<repeat-style>#",
      "mask-size": "<bg-size>#",
      "mask-type": "luminance|alpha",
      "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
      "math-depth": "auto-add|add( <integer> )|<integer>",
      "math-shift": "normal|compact",
      "math-style": "normal|compact",
      "max-block-size": "<'max-width'>",
      "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "max-inline-size": "<'max-width'>",
      "max-lines": "none|<integer>",
      "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "min-block-size": "<'min-width'>",
      "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "min-inline-size": "<'min-width'>",
      "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "mix-blend-mode": "<blend-mode>|plus-lighter",
      "object-fit": "fill|contain|cover|none|scale-down",
      "object-position": "<position>",
      "offset": "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
      "offset-anchor": "auto|<position>",
      "offset-distance": "<length-percentage>",
      "offset-path": "none|<offset-path>||<coord-box>",
      "offset-position": "normal|auto|<position>",
      "offset-rotate": "[auto|reverse]||<angle>",
      "opacity": "<alpha-value>",
      "order": "<integer>",
      "orphans": "<integer>",
      "outline": "[<'outline-width'>||<'outline-style'>||<'outline-color'>]",
      "outline-color": "auto|<color>",
      "outline-offset": "<length>",
      "outline-style": "auto|<'border-style'>",
      "outline-width": "<line-width>",
      "overflow": "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
      "overflow-anchor": "auto|none",
      "overflow-block": "visible|hidden|clip|scroll|auto",
      "overflow-clip-box": "padding-box|content-box",
      "overflow-clip-margin": "<visual-box>||<length [0,\u221E]>",
      "overflow-inline": "visible|hidden|clip|scroll|auto",
      "overflow-wrap": "normal|break-word|anywhere",
      "overflow-x": "visible|hidden|clip|scroll|auto",
      "overflow-y": "visible|hidden|clip|scroll|auto",
      "overlay": "none|auto",
      "overscroll-behavior": "[contain|none|auto]{1,2}",
      "overscroll-behavior-block": "contain|none|auto",
      "overscroll-behavior-inline": "contain|none|auto",
      "overscroll-behavior-x": "contain|none|auto",
      "overscroll-behavior-y": "contain|none|auto",
      "padding": "[<length>|<percentage>]{1,4}",
      "padding-block": "<'padding-left'>{1,2}",
      "padding-block-end": "<'padding-left'>",
      "padding-block-start": "<'padding-left'>",
      "padding-bottom": "<length>|<percentage>",
      "padding-inline": "<'padding-left'>{1,2}",
      "padding-inline-end": "<'padding-left'>",
      "padding-inline-start": "<'padding-left'>",
      "padding-left": "<length>|<percentage>",
      "padding-right": "<length>|<percentage>",
      "padding-top": "<length>|<percentage>",
      "page": "auto|<custom-ident>",
      "page-break-after": "auto|always|avoid|left|right|recto|verso",
      "page-break-before": "auto|always|avoid|left|right|recto|verso",
      "page-break-inside": "auto|avoid",
      "paint-order": "normal|[fill||stroke||markers]",
      "perspective": "none|<length>",
      "perspective-origin": "<position>",
      "place-content": "<'align-content'> <'justify-content'>?",
      "place-items": "<'align-items'> <'justify-items'>?",
      "place-self": "<'align-self'> <'justify-self'>?",
      "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
      "position": "static|relative|absolute|sticky|fixed|-webkit-sticky",
      "position-anchor": "auto|<anchor-name>",
      "position-area": "none|<position-area>",
      "position-try": "<'position-try-order'>? <'position-try-fallbacks'>",
      "position-try-fallbacks": "none|[[<dashed-ident>||<try-tactic>]|<'position-area'>]#",
      "position-try-order": "normal|<try-size>",
      "position-visibility": "always|[anchors-valid||anchors-visible||no-overflow]",
      "print-color-adjust": "economy|exact",
      "quotes": "none|auto|[<string> <string>]+",
      "r": "<length>|<percentage>",
      "resize": "none|both|horizontal|vertical|block|inline",
      "right": "<length>|<percentage>|auto",
      "rotate": "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
      "row-gap": "normal|<length-percentage>",
      "ruby-align": "start|center|space-between|space-around",
      "ruby-merge": "separate|collapse|auto",
      "ruby-position": "[alternate||[over|under]]|inter-character",
      "rx": "<length>|<percentage>",
      "ry": "<length>|<percentage>",
      "scale": "none|[<number>|<percentage>]{1,3}",
      "scrollbar-color": "auto|<color>{2}",
      "scrollbar-gutter": "auto|stable&&both-edges?",
      "scrollbar-width": "auto|thin|none",
      "scroll-behavior": "auto|smooth",
      "scroll-margin": "<length>{1,4}",
      "scroll-margin-block": "<length>{1,2}",
      "scroll-margin-block-start": "<length>",
      "scroll-margin-block-end": "<length>",
      "scroll-margin-bottom": "<length>",
      "scroll-margin-inline": "<length>{1,2}",
      "scroll-margin-inline-start": "<length>",
      "scroll-margin-inline-end": "<length>",
      "scroll-margin-left": "<length>",
      "scroll-margin-right": "<length>",
      "scroll-margin-top": "<length>",
      "scroll-padding": "[auto|<length-percentage>]{1,4}",
      "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
      "scroll-padding-block-start": "auto|<length-percentage>",
      "scroll-padding-block-end": "auto|<length-percentage>",
      "scroll-padding-bottom": "auto|<length-percentage>",
      "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
      "scroll-padding-inline-start": "auto|<length-percentage>",
      "scroll-padding-inline-end": "auto|<length-percentage>",
      "scroll-padding-left": "auto|<length-percentage>",
      "scroll-padding-right": "auto|<length-percentage>",
      "scroll-padding-top": "auto|<length-percentage>",
      "scroll-snap-align": "[none|start|end|center]{1,2}",
      "scroll-snap-coordinate": "none|<position>#",
      "scroll-snap-destination": "<position>",
      "scroll-snap-points-x": "none|repeat( <length-percentage> )",
      "scroll-snap-points-y": "none|repeat( <length-percentage> )",
      "scroll-snap-stop": "normal|always",
      "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
      "scroll-snap-type-x": "none|mandatory|proximity",
      "scroll-snap-type-y": "none|mandatory|proximity",
      "scroll-timeline": "[<'scroll-timeline-name'>||<'scroll-timeline-axis'>]#",
      "scroll-timeline-axis": "[block|inline|x|y]#",
      "scroll-timeline-name": "[none|<dashed-ident>]#",
      "shape-image-threshold": "<alpha-value>",
      "shape-margin": "<length-percentage>",
      "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
      "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
      "stroke": "<paint>",
      "stroke-dasharray": "none|[<svg-length>+]#",
      "stroke-dashoffset": "<svg-length>",
      "stroke-linecap": "butt|round|square",
      "stroke-linejoin": "miter|round|bevel",
      "stroke-miterlimit": "<number-one-or-greater>",
      "stroke-opacity": "<'opacity'>",
      "stroke-width": "<svg-length>",
      "tab-size": "<integer>|<length>",
      "table-layout": "auto|fixed",
      "text-align": "start|end|left|right|center|justify|match-parent",
      "text-align-last": "auto|start|end|left|right|center|justify",
      "text-anchor": "start|middle|end",
      "text-combine-upright": "none|all|[digits <integer>?]",
      "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
      "text-decoration-color": "<color>",
      "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
      "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
      "text-decoration-skip-ink": "auto|all|none",
      "text-decoration-style": "solid|double|dotted|dashed|wavy",
      "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
      "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
      "text-emphasis-color": "<color>",
      "text-emphasis-position": "auto|[over|under]&&[right|left]?",
      "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
      "text-indent": "<length-percentage>&&hanging?&&each-line?",
      "text-justify": "auto|inter-character|inter-word|none",
      "text-orientation": "mixed|upright|sideways",
      "text-overflow": "[clip|ellipsis|<string>]{1,2}",
      "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
      "text-shadow": "none|<shadow-t>#",
      "text-size-adjust": "none|auto|<percentage>",
      "text-spacing-trim": "space-all|normal|space-first|trim-start|trim-both|trim-all|auto",
      "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
      "text-underline-offset": "auto|<length>|<percentage>",
      "text-underline-position": "auto|from-font|[under||[left|right]]",
      "text-wrap": "<'text-wrap-mode'>||<'text-wrap-style'>",
      "text-wrap-mode": "auto|wrap|nowrap",
      "text-wrap-style": "auto|balance|stable|pretty",
      "timeline-scope": "none|<dashed-ident>#",
      "top": "<length>|<percentage>|auto",
      "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
      "transform": "none|<transform-list>",
      "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
      "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
      "transform-style": "flat|preserve-3d",
      "transition": "<single-transition>#",
      "transition-behavior": "<transition-behavior-value>#",
      "transition-delay": "<time>#",
      "transition-duration": "<time>#",
      "transition-property": "none|<single-transition-property>#",
      "transition-timing-function": "<easing-function>#",
      "translate": "none|<length-percentage> [<length-percentage> <length>?]?",
      "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
      "user-select": "auto|text|none|contain|all",
      "vector-effect": "none|non-scaling-stroke|non-scaling-size|non-rotation|fixed-position",
      "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
      "view-timeline": "[<'view-timeline-name'> <'view-timeline-axis'>?]#",
      "view-timeline-axis": "[block|inline|x|y]#",
      "view-timeline-inset": "[[auto|<length-percentage>]{1,2}]#",
      "view-timeline-name": "none|<dashed-ident>#",
      "view-transition-name": "none|<custom-ident>",
      "visibility": "visible|hidden|collapse",
      "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces|[<'white-space-collapse'>||<'text-wrap'>||<'white-space-trim'>]",
      "white-space-collapse": "collapse|discard|preserve|preserve-breaks|preserve-spaces|break-spaces",
      "widows": "<integer>",
      "width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
      "will-change": "auto|<animateable-feature>#",
      "word-break": "normal|break-all|keep-all|break-word|auto-phrase",
      "word-spacing": "normal|<length>",
      "word-wrap": "normal|break-word",
      "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
      "x": "<length>|<percentage>",
      "y": "<length>|<percentage>",
      "z-index": "auto|<integer>",
      "zoom": "normal|reset|<number>|<percentage>",
      "-moz-background-clip": "padding|border",
      "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
      "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
      "-moz-border-radius-topleft": "<'border-top-left-radius'>",
      "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
      "-moz-control-character-visibility": "visible|hidden",
      "-moz-osx-font-smoothing": "auto|grayscale",
      "-moz-user-select": "none|text|all|-moz-none",
      "-ms-flex-align": "start|end|center|baseline|stretch",
      "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
      "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
      "-ms-flex-negative": "<'flex-shrink'>",
      "-ms-flex-pack": "start|end|center|justify|distribute",
      "-ms-flex-order": "<integer>",
      "-ms-flex-positive": "<'flex-grow'>",
      "-ms-flex-preferred-size": "<'flex-basis'>",
      "-ms-interpolation-mode": "nearest-neighbor|bicubic",
      "-ms-grid-column-align": "start|end|center|stretch",
      "-ms-grid-row-align": "start|end|center|stretch",
      "-ms-hyphenate-limit-last": "none|always|column|page|spread",
      "-webkit-background-clip": "[<box>|border|padding|content|text]#",
      "-webkit-column-break-after": "always|auto|avoid",
      "-webkit-column-break-before": "always|auto|avoid",
      "-webkit-column-break-inside": "always|auto|avoid",
      "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
      "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
      "-webkit-print-color-adjust": "economy|exact",
      "-webkit-text-security": "none|circle|disc|square",
      "-webkit-user-drag": "none|element|auto",
      "-webkit-user-select": "auto|none|text|all",
      "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
      "baseline-shift": "baseline|sub|super|<svg-length>",
      "behavior": "<url>+",
      "cue": "<'cue-before'> <'cue-after'>?",
      "cue-after": "<url> <decibel>?|none",
      "cue-before": "<url> <decibel>?|none",
      "glyph-orientation-horizontal": "<angle>",
      "glyph-orientation-vertical": "<angle>",
      "kerning": "auto|<svg-length>",
      "pause": "<'pause-before'> <'pause-after'>?",
      "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "rest": "<'rest-before'> <'rest-after'>?",
      "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
      "speak": "auto|never|always",
      "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
      "unicode-range": "<urange>#",
      "voice-balance": "<number>|left|center|right|leftwards|rightwards",
      "voice-duration": "auto|<time>",
      "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
      "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
      "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
      "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
      "voice-stress": "normal|strong|moderate|none|reduced",
      "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]",
      "white-space-trim": "none|discard-before||discard-after||discard-inner"
    },
    "atrules": {
      "charset": {
        "prelude": "<string>",
        "descriptors": null
      },
      "counter-style": {
        "prelude": "<counter-style-name>",
        "descriptors": {
          "additive-symbols": "[<integer>&&<symbol>]#",
          "fallback": "<counter-style-name>",
          "negative": "<symbol> <symbol>?",
          "pad": "<integer>&&<symbol>",
          "prefix": "<symbol>",
          "range": "[[<integer>|infinite]{2}]#|auto",
          "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
          "suffix": "<symbol>",
          "symbols": "<symbol>+",
          "system": "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
        }
      },
      "document": {
        "prelude": "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
        "descriptors": null
      },
      "font-palette-values": {
        "prelude": "<dashed-ident>",
        "descriptors": {
          "base-palette": "light|dark|<integer [0,\u221E]>",
          "font-family": "<family-name>#",
          "override-colors": "[<integer [0,\u221E]> <absolute-color-base>]#"
        }
      },
      "font-face": {
        "prelude": null,
        "descriptors": {
          "ascent-override": "normal|<percentage>",
          "descent-override": "normal|<percentage>",
          "font-display": "[auto|block|swap|fallback|optional]",
          "font-family": "<family-name>",
          "font-feature-settings": "normal|<feature-tag-value>#",
          "font-variation-settings": "normal|[<string> <number>]#",
          "font-stretch": "<font-stretch-absolute>{1,2}",
          "font-style": "normal|italic|oblique <angle>{0,2}",
          "font-weight": "<font-weight-absolute>{1,2}",
          "line-gap-override": "normal|<percentage>",
          "size-adjust": "<percentage>",
          "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
          "unicode-range": "<urange>#"
        }
      },
      "font-feature-values": {
        "prelude": "<family-name>#",
        "descriptors": null
      },
      "import": {
        "prelude": "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?",
        "descriptors": null
      },
      "keyframes": {
        "prelude": "<keyframes-name>",
        "descriptors": null
      },
      "layer": {
        "prelude": "[<layer-name>#|<layer-name>?]",
        "descriptors": null
      },
      "media": {
        "prelude": "<media-query-list>",
        "descriptors": null
      },
      "namespace": {
        "prelude": "<namespace-prefix>? [<string>|<url>]",
        "descriptors": null
      },
      "page": {
        "prelude": "<page-selector-list>",
        "descriptors": {
          "bleed": "auto|<length>",
          "marks": "none|[crop||cross]",
          "page-orientation": "upright|rotate-left|rotate-right",
          "size": "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
        }
      },
      "position-try": {
        "prelude": "<dashed-ident>",
        "descriptors": {
          "top": "<'top'>",
          "left": "<'left'>",
          "bottom": "<'bottom'>",
          "right": "<'right'>",
          "inset-block-start": "<'inset-block-start'>",
          "inset-block-end": "<'inset-block-end'>",
          "inset-inline-start": "<'inset-inline-start'>",
          "inset-inline-end": "<'inset-inline-end'>",
          "inset-block": "<'inset-block'>",
          "inset-inline": "<'inset-inline'>",
          "inset": "<'inset'>",
          "margin-top": "<'margin-top'>",
          "margin-left": "<'margin-left'>",
          "margin-bottom": "<'margin-bottom'>",
          "margin-right": "<'margin-right'>",
          "margin-block-start": "<'margin-block-start'>",
          "margin-block-end": "<'margin-block-end'>",
          "margin-inline-start": "<'margin-inline-start'>",
          "margin-inline-end": "<'margin-inline-end'>",
          "margin": "<'margin'>",
          "margin-block": "<'margin-block'>",
          "margin-inline": "<'margin-inline'>",
          "width": "<'width'>",
          "height": "<'height'>",
          "min-width": "<'min-width'>",
          "min-height": "<'min-height'>",
          "max-width": "<'max-width'>",
          "max-height": "<'max-height'>",
          "block-size": "<'block-size'>",
          "inline-size": "<'inline-size'>",
          "min-block-size": "<'min-block-size'>",
          "min-inline-size": "<'min-inline-size'>",
          "max-block-size": "<'max-block-size'>",
          "max-inline-size": "<'max-inline-size'>",
          "align-self": "<'align-self'>|anchor-center",
          "justify-self": "<'justify-self'>|anchor-center"
        }
      },
      "property": {
        "prelude": "<custom-property-name>",
        "descriptors": {
          "syntax": "<string>",
          "inherits": "true|false",
          "initial-value": "<declaration-value>?"
        }
      },
      "scope": {
        "prelude": "[( <scope-start> )]? [to ( <scope-end> )]?",
        "descriptors": null
      },
      "starting-style": {
        "prelude": null,
        "descriptors": null
      },
      "supports": {
        "prelude": "<supports-condition>",
        "descriptors": null
      },
      "container": {
        "prelude": "[<container-name>]? <container-condition>",
        "descriptors": null
      },
      "nest": {
        "prelude": "<complex-selector-list>",
        "descriptors": null
      }
    }
  };
  const PLUSSIGN$5 = 43;
  const HYPHENMINUS$2 = 45;
  const N = 110;
  const DISALLOW_SIGN = true;
  const ALLOW_SIGN = false;
  function checkInteger(offset, disallowSign) {
    let pos = this.tokenStart + offset;
    const code2 = this.charCodeAt(pos);
    if (code2 === PLUSSIGN$5 || code2 === HYPHENMINUS$2) {
      if (disallowSign) {
        this.error("Number sign is not allowed");
      }
      pos++;
    }
    for (; pos < this.tokenEnd; pos++) {
      if (!isDigit(this.charCodeAt(pos))) {
        this.error("Integer is expected", pos);
      }
    }
  }
  function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
  }
  function expectCharCode(offset, code2) {
    if (!this.cmpChar(this.tokenStart + offset, code2)) {
      let msg = "";
      switch (code2) {
        case N:
          msg = "N is expected";
          break;
        case HYPHENMINUS$2:
          msg = "HyphenMinus is expected";
          break;
      }
      this.error(msg, this.tokenStart + offset);
    }
  }
  function consumeB() {
    let offset = 0;
    let sign2 = 0;
    let type2 = this.tokenType;
    while (type2 === WhiteSpace$1 || type2 === Comment$1) {
      type2 = this.lookupType(++offset);
    }
    if (type2 !== Number$2) {
      if (this.isDelim(PLUSSIGN$5, offset) || this.isDelim(HYPHENMINUS$2, offset)) {
        sign2 = this.isDelim(PLUSSIGN$5, offset) ? PLUSSIGN$5 : HYPHENMINUS$2;
        do {
          type2 = this.lookupType(++offset);
        } while (type2 === WhiteSpace$1 || type2 === Comment$1);
        if (type2 !== Number$2) {
          this.skip(offset);
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
        }
      } else {
        return null;
      }
    }
    if (offset > 0) {
      this.skip(offset);
    }
    if (sign2 === 0) {
      type2 = this.charCodeAt(this.tokenStart);
      if (type2 !== PLUSSIGN$5 && type2 !== HYPHENMINUS$2) {
        this.error("Number sign is expected");
      }
    }
    checkTokenIsInteger.call(this, sign2 !== 0);
    return sign2 === HYPHENMINUS$2 ? "-" + this.consume(Number$2) : this.consume(Number$2);
  }
  const name$M = "AnPlusB";
  const structure$M = {
    a: [
      String,
      null
    ],
    b: [
      String,
      null
    ]
  };
  function parse$N() {
    const start = this.tokenStart;
    let a = null;
    let b = null;
    if (this.tokenType === Number$2) {
      checkTokenIsInteger.call(this, ALLOW_SIGN);
      b = this.consume(Number$2);
    } else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS$2)) {
      a = "-1";
      expectCharCode.call(this, 1, N);
      switch (this.tokenEnd - this.tokenStart) {
        case 2:
          this.next();
          b = consumeB.call(this);
          break;
        case 3:
          expectCharCode.call(this, 2, HYPHENMINUS$2);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(Number$2);
          break;
        default:
          expectCharCode.call(this, 2, HYPHENMINUS$2);
          checkInteger.call(this, 3, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(start + 2);
      }
    } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN$5) && this.lookupType(1) === Ident) {
      let sign2 = 0;
      a = "1";
      if (this.isDelim(PLUSSIGN$5)) {
        sign2 = 1;
        this.next();
      }
      expectCharCode.call(this, 0, N);
      switch (this.tokenEnd - this.tokenStart) {
        case 1:
          this.next();
          b = consumeB.call(this);
          break;
        case 2:
          expectCharCode.call(this, 1, HYPHENMINUS$2);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(Number$2);
          break;
        default:
          expectCharCode.call(this, 1, HYPHENMINUS$2);
          checkInteger.call(this, 2, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(start + sign2 + 1);
      }
    } else if (this.tokenType === Dimension$1) {
      const code2 = this.charCodeAt(this.tokenStart);
      const sign2 = code2 === PLUSSIGN$5 || code2 === HYPHENMINUS$2;
      let i2 = this.tokenStart + sign2;
      for (; i2 < this.tokenEnd; i2++) {
        if (!isDigit(this.charCodeAt(i2))) {
          break;
        }
      }
      if (i2 === this.tokenStart + sign2) {
        this.error("Integer is expected", this.tokenStart + sign2);
      }
      expectCharCode.call(this, i2 - this.tokenStart, N);
      a = this.substring(start, i2);
      if (i2 + 1 === this.tokenEnd) {
        this.next();
        b = consumeB.call(this);
      } else {
        expectCharCode.call(this, i2 - this.tokenStart + 1, HYPHENMINUS$2);
        if (i2 + 2 === this.tokenEnd) {
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(Number$2);
        } else {
          checkInteger.call(this, i2 - this.tokenStart + 2, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(i2 + 1);
        }
      }
    } else {
      this.error();
    }
    if (a !== null && a.charCodeAt(0) === PLUSSIGN$5) {
      a = a.substr(1);
    }
    if (b !== null && b.charCodeAt(0) === PLUSSIGN$5) {
      b = b.substr(1);
    }
    return {
      type: "AnPlusB",
      loc: this.getLocation(start, this.tokenStart),
      a,
      b
    };
  }
  function generate$N(node2) {
    if (node2.a) {
      const a = node2.a === "+1" && "n" || node2.a === "1" && "n" || node2.a === "-1" && "-n" || node2.a + "n";
      if (node2.b) {
        const b = node2.b[0] === "-" || node2.b[0] === "+" ? node2.b : "+" + node2.b;
        this.tokenize(a + b);
      } else {
        this.tokenize(a);
      }
    } else {
      this.tokenize(node2.b);
    }
  }
  const AnPlusB = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$N,
    name: name$M,
    parse: parse$N,
    structure: structure$M
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function consumeRaw$4() {
    return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, true);
  }
  function isDeclarationBlockAtrule() {
    for (let offset = 1, type2; type2 = this.lookupType(offset); offset++) {
      if (type2 === RightCurlyBracket) {
        return true;
      }
      if (type2 === LeftCurlyBracket || type2 === AtKeyword) {
        return false;
      }
    }
    return false;
  }
  const name$L = "Atrule";
  const walkContext$9 = "atrule";
  const structure$L = {
    name: String,
    prelude: [
      "AtrulePrelude",
      "Raw",
      null
    ],
    block: [
      "Block",
      null
    ]
  };
  function parse$M(isDeclaration = false) {
    const start = this.tokenStart;
    let name2;
    let nameLowerCase;
    let prelude = null;
    let block = null;
    this.eat(AtKeyword);
    name2 = this.substrToCursor(start + 1);
    nameLowerCase = name2.toLowerCase();
    this.skipSC();
    if (this.eof === false && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
      if (this.parseAtrulePrelude) {
        prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name2, isDeclaration), consumeRaw$4);
      } else {
        prelude = consumeRaw$4.call(this, this.tokenIndex);
      }
      this.skipSC();
    }
    switch (this.tokenType) {
      case Semicolon:
        this.next();
        break;
      case LeftCurlyBracket:
        if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
          block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
        } else {
          block = this.Block(isDeclarationBlockAtrule.call(this));
        }
        break;
    }
    return {
      type: "Atrule",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      prelude,
      block
    };
  }
  function generate$M(node2) {
    this.token(AtKeyword, "@" + node2.name);
    if (node2.prelude !== null) {
      this.node(node2.prelude);
    }
    if (node2.block) {
      this.node(node2.block);
    } else {
      this.token(Semicolon, ";");
    }
  }
  const Atrule = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$M,
    name: name$L,
    parse: parse$M,
    structure: structure$L,
    walkContext: walkContext$9
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$K = "AtrulePrelude";
  const walkContext$8 = "atrulePrelude";
  const structure$K = {
    children: [
      []
    ]
  };
  function parse$L(name2) {
    let children = null;
    if (name2 !== null) {
      name2 = name2.toLowerCase();
    }
    this.skipSC();
    if (hasOwnProperty.call(this.atrule, name2) && typeof this.atrule[name2].prelude === "function") {
      children = this.atrule[name2].prelude.call(this);
    } else {
      children = this.readSequence(this.scope.AtrulePrelude);
    }
    this.skipSC();
    if (this.eof !== true && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
      this.error("Semicolon or block is expected");
    }
    return {
      type: "AtrulePrelude",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$L(node2) {
    this.children(node2);
  }
  const AtrulePrelude = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$L,
    name: name$K,
    parse: parse$L,
    structure: structure$K,
    walkContext: walkContext$8
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const DOLLARSIGN$1 = 36;
  const ASTERISK$5 = 42;
  const EQUALSSIGN$1 = 61;
  const CIRCUMFLEXACCENT = 94;
  const VERTICALLINE$2 = 124;
  const TILDE$2 = 126;
  function getAttributeName() {
    if (this.eof) {
      this.error("Unexpected end of input");
    }
    const start = this.tokenStart;
    let expectIdent = false;
    if (this.isDelim(ASTERISK$5)) {
      expectIdent = true;
      this.next();
    } else if (!this.isDelim(VERTICALLINE$2)) {
      this.eat(Ident);
    }
    if (this.isDelim(VERTICALLINE$2)) {
      if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN$1) {
        this.next();
        this.eat(Ident);
      } else if (expectIdent) {
        this.error("Identifier is expected", this.tokenEnd);
      }
    } else if (expectIdent) {
      this.error("Vertical line is expected");
    }
    return {
      type: "Identifier",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  function getOperator() {
    const start = this.tokenStart;
    const code2 = this.charCodeAt(start);
    if (code2 !== EQUALSSIGN$1 && code2 !== TILDE$2 && code2 !== CIRCUMFLEXACCENT && code2 !== DOLLARSIGN$1 && code2 !== ASTERISK$5 && code2 !== VERTICALLINE$2) {
      this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
    }
    this.next();
    if (code2 !== EQUALSSIGN$1) {
      if (!this.isDelim(EQUALSSIGN$1)) {
        this.error("Equal sign is expected");
      }
      this.next();
    }
    return this.substrToCursor(start);
  }
  const name$J = "AttributeSelector";
  const structure$J = {
    name: "Identifier",
    matcher: [
      String,
      null
    ],
    value: [
      "String",
      "Identifier",
      null
    ],
    flags: [
      String,
      null
    ]
  };
  function parse$K() {
    const start = this.tokenStart;
    let name2;
    let matcher = null;
    let value2 = null;
    let flags = null;
    this.eat(LeftSquareBracket);
    this.skipSC();
    name2 = getAttributeName.call(this);
    this.skipSC();
    if (this.tokenType !== RightSquareBracket) {
      if (this.tokenType !== Ident) {
        matcher = getOperator.call(this);
        this.skipSC();
        value2 = this.tokenType === String$2 ? this.String() : this.Identifier();
        this.skipSC();
      }
      if (this.tokenType === Ident) {
        flags = this.consume(Ident);
        this.skipSC();
      }
    }
    this.eat(RightSquareBracket);
    return {
      type: "AttributeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      matcher,
      value: value2,
      flags
    };
  }
  function generate$K(node2) {
    this.token(Delim, "[");
    this.node(node2.name);
    if (node2.matcher !== null) {
      this.tokenize(node2.matcher);
      this.node(node2.value);
    }
    if (node2.flags !== null) {
      this.token(Ident, node2.flags);
    }
    this.token(Delim, "]");
  }
  const AttributeSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$K,
    name: name$J,
    parse: parse$K,
    structure: structure$J
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const AMPERSAND$4 = 38;
  function consumeRaw$3() {
    return this.Raw(null, true);
  }
  function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw$3);
  }
  function consumeRawDeclaration() {
    return this.Raw(this.consumeUntilSemicolonIncluded, true);
  }
  function consumeDeclaration() {
    if (this.tokenType === Semicolon) {
      return consumeRawDeclaration.call(this, this.tokenIndex);
    }
    const node2 = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
    if (this.tokenType === Semicolon) {
      this.next();
    }
    return node2;
  }
  const name$I = "Block";
  const walkContext$7 = "block";
  const structure$I = {
    children: [
      [
        "Atrule",
        "Rule",
        "Declaration"
      ]
    ]
  };
  function parse$J(isStyleBlock) {
    const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
    const start = this.tokenStart;
    let children = this.createList();
    this.eat(LeftCurlyBracket);
    scan: while (!this.eof) {
      switch (this.tokenType) {
        case RightCurlyBracket:
          break scan;
        case WhiteSpace$1:
        case Comment$1:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw$3));
          break;
        default:
          if (isStyleBlock && this.isDelim(AMPERSAND$4)) {
            children.push(consumeRule.call(this));
          } else {
            children.push(consumer.call(this));
          }
      }
    }
    if (!this.eof) {
      this.eat(RightCurlyBracket);
    }
    return {
      type: "Block",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate$J(node2) {
    this.token(LeftCurlyBracket, "{");
    this.children(node2, (prev) => {
      if (prev.type === "Declaration") {
        this.token(Semicolon, ";");
      }
    });
    this.token(RightCurlyBracket, "}");
  }
  const Block = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$J,
    name: name$I,
    parse: parse$J,
    structure: structure$I,
    walkContext: walkContext$7
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$H = "Brackets";
  const structure$H = {
    children: [
      []
    ]
  };
  function parse$I(readSequence2, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(LeftSquareBracket);
    children = readSequence2.call(this, recognizer);
    if (!this.eof) {
      this.eat(RightSquareBracket);
    }
    return {
      type: "Brackets",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate$I(node2) {
    this.token(Delim, "[");
    this.children(node2);
    this.token(Delim, "]");
  }
  const Brackets = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$I,
    name: name$H,
    parse: parse$I,
    structure: structure$H
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$G = "CDC";
  const structure$G = [];
  function parse$H() {
    const start = this.tokenStart;
    this.eat(CDC$1);
    return {
      type: "CDC",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate$H() {
    this.token(CDC$1, "-->");
  }
  const CDC = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$H,
    name: name$G,
    parse: parse$H,
    structure: structure$G
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$F = "CDO";
  const structure$F = [];
  function parse$G() {
    const start = this.tokenStart;
    this.eat(CDO$1);
    return {
      type: "CDO",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate$G() {
    this.token(CDO$1, "<!--");
  }
  const CDO = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$G,
    name: name$F,
    parse: parse$G,
    structure: structure$F
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const FULLSTOP$2 = 46;
  const name$E = "ClassSelector";
  const structure$E = {
    name: String
  };
  function parse$F() {
    this.eatDelim(FULLSTOP$2);
    return {
      type: "ClassSelector",
      loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
      name: this.consume(Ident)
    };
  }
  function generate$F(node2) {
    this.token(Delim, ".");
    this.token(Ident, node2.name);
  }
  const ClassSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$F,
    name: name$E,
    parse: parse$F,
    structure: structure$E
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const PLUSSIGN$4 = 43;
  const SOLIDUS$7 = 47;
  const GREATERTHANSIGN$2 = 62;
  const TILDE$1 = 126;
  const name$D = "Combinator";
  const structure$D = {
    name: String
  };
  function parse$E() {
    const start = this.tokenStart;
    let name2;
    switch (this.tokenType) {
      case WhiteSpace$1:
        name2 = " ";
        break;
      case Delim:
        switch (this.charCodeAt(this.tokenStart)) {
          case GREATERTHANSIGN$2:
          case PLUSSIGN$4:
          case TILDE$1:
            this.next();
            break;
          case SOLIDUS$7:
            this.next();
            this.eatIdent("deep");
            this.eatDelim(SOLIDUS$7);
            break;
          default:
            this.error("Combinator is expected");
        }
        name2 = this.substrToCursor(start);
        break;
    }
    return {
      type: "Combinator",
      loc: this.getLocation(start, this.tokenStart),
      name: name2
    };
  }
  function generate$E(node2) {
    this.tokenize(node2.name);
  }
  const Combinator = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$E,
    name: name$D,
    parse: parse$E,
    structure: structure$D
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const ASTERISK$4 = 42;
  const SOLIDUS$6 = 47;
  const name$C = "Comment";
  const structure$C = {
    value: String
  };
  function parse$D() {
    const start = this.tokenStart;
    let end = this.tokenEnd;
    this.eat(Comment$1);
    if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK$4 && this.charCodeAt(end - 1) === SOLIDUS$6) {
      end -= 2;
    }
    return {
      type: "Comment",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substring(start + 2, end)
    };
  }
  function generate$D(node2) {
    this.token(Comment$1, "/*" + node2.value + "*/");
  }
  const Comment = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$D,
    name: name$C,
    parse: parse$D,
    structure: structure$C
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const likelyFeatureToken = /* @__PURE__ */ new Set([
    Colon,
    RightParenthesis,
    EOF$1
  ]);
  const name$B = "Condition";
  const structure$B = {
    kind: String,
    children: [
      [
        "Identifier",
        "Feature",
        "FeatureFunction",
        "FeatureRange",
        "SupportsDeclaration"
      ]
    ]
  };
  function featureOrRange(kind) {
    if (this.lookupTypeNonSC(1) === Ident && likelyFeatureToken.has(this.lookupTypeNonSC(2))) {
      return this.Feature(kind);
    }
    return this.FeatureRange(kind);
  }
  const parentheses = {
    media: featureOrRange,
    container: featureOrRange,
    supports() {
      return this.SupportsDeclaration();
    }
  };
  function parse$C(kind = "media") {
    const children = this.createList();
    scan: while (!this.eof) {
      switch (this.tokenType) {
        case Comment$1:
        case WhiteSpace$1:
          this.next();
          continue;
        case Ident:
          children.push(this.Identifier());
          break;
        case LeftParenthesis: {
          let term = this.parseWithFallback(() => parentheses[kind].call(this, kind), () => null);
          if (!term) {
            term = this.parseWithFallback(() => {
              this.eat(LeftParenthesis);
              const res = this.Condition(kind);
              this.eat(RightParenthesis);
              return res;
            }, () => {
              return this.GeneralEnclosed(kind);
            });
          }
          children.push(term);
          break;
        }
        case Function$2: {
          let term = this.parseWithFallback(() => this.FeatureFunction(kind), () => null);
          if (!term) {
            term = this.GeneralEnclosed(kind);
          }
          children.push(term);
          break;
        }
        default:
          break scan;
      }
    }
    if (children.isEmpty) {
      this.error("Condition is expected");
    }
    return {
      type: "Condition",
      loc: this.getLocationFromList(children),
      kind,
      children
    };
  }
  function generate$C(node2) {
    node2.children.forEach((child) => {
      if (child.type === "Condition") {
        this.token(LeftParenthesis, "(");
        this.node(child);
        this.token(RightParenthesis, ")");
      } else {
        this.node(child);
      }
    });
  }
  const Condition = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$C,
    name: name$B,
    parse: parse$C,
    structure: structure$B
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const EXCLAMATIONMARK$1 = 33;
  const NUMBERSIGN$2 = 35;
  const DOLLARSIGN = 36;
  const AMPERSAND$3 = 38;
  const ASTERISK$3 = 42;
  const PLUSSIGN$3 = 43;
  const SOLIDUS$5 = 47;
  function consumeValueRaw() {
    return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, true);
  }
  function consumeCustomPropertyRaw() {
    return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
  }
  function consumeValue() {
    const startValueToken = this.tokenIndex;
    const value2 = this.Value();
    if (value2.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon && this.isDelim(EXCLAMATIONMARK$1) === false && this.isBalanceEdge(startValueToken) === false) {
      this.error();
    }
    return value2;
  }
  const name$A = "Declaration";
  const walkContext$6 = "declaration";
  const structure$A = {
    important: [
      Boolean,
      String
    ],
    property: String,
    value: [
      "Value",
      "Raw"
    ]
  };
  function parse$B() {
    const start = this.tokenStart;
    const startToken = this.tokenIndex;
    const property2 = readProperty.call(this);
    const customProperty = isCustomProperty(property2);
    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    const consumeRaw2 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    let important = false;
    let value2;
    this.skipSC();
    this.eat(Colon);
    const valueStart = this.tokenIndex;
    if (!customProperty) {
      this.skipSC();
    }
    if (parseValue) {
      value2 = this.parseWithFallback(consumeValue, consumeRaw2);
    } else {
      value2 = consumeRaw2.call(this, this.tokenIndex);
    }
    if (customProperty && value2.type === "Value" && value2.children.isEmpty) {
      for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
        if (this.lookupType(offset) === WhiteSpace$1) {
          value2.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    if (this.isDelim(EXCLAMATIONMARK$1)) {
      important = getImportant.call(this);
      this.skipSC();
    }
    if (this.eof === false && this.tokenType !== Semicolon && this.isBalanceEdge(startToken) === false) {
      this.error();
    }
    return {
      type: "Declaration",
      loc: this.getLocation(start, this.tokenStart),
      important,
      property: property2,
      value: value2
    };
  }
  function generate$B(node2) {
    this.token(Ident, node2.property);
    this.token(Colon, ":");
    this.node(node2.value);
    if (node2.important) {
      this.token(Delim, "!");
      this.token(Ident, node2.important === true ? "important" : node2.important);
    }
  }
  function readProperty() {
    const start = this.tokenStart;
    if (this.tokenType === Delim) {
      switch (this.charCodeAt(this.tokenStart)) {
        case ASTERISK$3:
        case DOLLARSIGN:
        case PLUSSIGN$3:
        case NUMBERSIGN$2:
        case AMPERSAND$3:
          this.next();
          break;
        case SOLIDUS$5:
          this.next();
          if (this.isDelim(SOLIDUS$5)) {
            this.next();
          }
          break;
      }
    }
    if (this.tokenType === Hash$1) {
      this.eat(Hash$1);
    } else {
      this.eat(Ident);
    }
    return this.substrToCursor(start);
  }
  function getImportant() {
    this.eat(Delim);
    this.skipSC();
    const important = this.consume(Ident);
    return important === "important" ? true : important;
  }
  const Declaration = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$B,
    name: name$A,
    parse: parse$B,
    structure: structure$A,
    walkContext: walkContext$6
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const AMPERSAND$2 = 38;
  function consumeRaw$2() {
    return this.Raw(this.consumeUntilSemicolonIncluded, true);
  }
  const name$z = "DeclarationList";
  const structure$z = {
    children: [
      [
        "Declaration",
        "Atrule",
        "Rule"
      ]
    ]
  };
  function parse$A() {
    const children = this.createList();
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace$1:
        case Comment$1:
        case Semicolon:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw$2));
          break;
        default:
          if (this.isDelim(AMPERSAND$2)) {
            children.push(this.parseWithFallback(this.Rule, consumeRaw$2));
          } else {
            children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
          }
      }
    }
    return {
      type: "DeclarationList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$A(node2) {
    this.children(node2, (prev) => {
      if (prev.type === "Declaration") {
        this.token(Semicolon, ";");
      }
    });
  }
  const DeclarationList = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$A,
    name: name$z,
    parse: parse$A,
    structure: structure$z
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$y = "Dimension";
  const structure$y = {
    value: String,
    unit: String
  };
  function parse$z() {
    const start = this.tokenStart;
    const value2 = this.consumeNumber(Dimension$1);
    return {
      type: "Dimension",
      loc: this.getLocation(start, this.tokenStart),
      value: value2,
      unit: this.substring(start + value2.length, this.tokenStart)
    };
  }
  function generate$z(node2) {
    this.token(Dimension$1, node2.value + node2.unit);
  }
  const Dimension = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$z,
    name: name$y,
    parse: parse$z,
    structure: structure$y
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const SOLIDUS$4 = 47;
  const name$x = "Feature";
  const structure$x = {
    kind: String,
    name: String,
    value: [
      "Identifier",
      "Number",
      "Dimension",
      "Ratio",
      "Function",
      null
    ]
  };
  function parse$y(kind) {
    const start = this.tokenStart;
    let name2;
    let value2 = null;
    this.eat(LeftParenthesis);
    this.skipSC();
    name2 = this.consume(Ident);
    this.skipSC();
    if (this.tokenType !== RightParenthesis) {
      this.eat(Colon);
      this.skipSC();
      switch (this.tokenType) {
        case Number$2:
          if (this.lookupNonWSType(1) === Delim) {
            value2 = this.Ratio();
          } else {
            value2 = this.Number();
          }
          break;
        case Dimension$1:
          value2 = this.Dimension();
          break;
        case Ident:
          value2 = this.Identifier();
          break;
        case Function$2:
          value2 = this.parseWithFallback(() => {
            const res = this.Function(this.readSequence, this.scope.Value);
            this.skipSC();
            if (this.isDelim(SOLIDUS$4)) {
              this.error();
            }
            return res;
          }, () => {
            return this.Ratio();
          });
          break;
        default:
          this.error("Number, dimension, ratio or identifier is expected");
      }
      this.skipSC();
    }
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "Feature",
      loc: this.getLocation(start, this.tokenStart),
      kind,
      name: name2,
      value: value2
    };
  }
  function generate$y(node2) {
    this.token(LeftParenthesis, "(");
    this.token(Ident, node2.name);
    if (node2.value !== null) {
      this.token(Colon, ":");
      this.node(node2.value);
    }
    this.token(RightParenthesis, ")");
  }
  const Feature = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$y,
    name: name$x,
    parse: parse$y,
    structure: structure$x
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$w = "FeatureFunction";
  const structure$w = {
    kind: String,
    feature: String,
    value: [
      "Declaration",
      "Selector"
    ]
  };
  function getFeatureParser(kind, name2) {
    const featuresOfKind = this.features[kind] || {};
    const parser = featuresOfKind[name2];
    if (typeof parser !== "function") {
      this.error(`Unknown feature ${name2}()`);
    }
    return parser;
  }
  function parse$x(kind = "unknown") {
    const start = this.tokenStart;
    const functionName = this.consumeFunctionName();
    const valueParser = getFeatureParser.call(this, kind, functionName.toLowerCase());
    this.skipSC();
    const value2 = this.parseWithFallback(() => {
      const startValueToken = this.tokenIndex;
      const value3 = valueParser.call(this);
      if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return value3;
    }, () => this.Raw(null, false));
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "FeatureFunction",
      loc: this.getLocation(start, this.tokenStart),
      kind,
      feature: functionName,
      value: value2
    };
  }
  function generate$x(node2) {
    this.token(Function$2, node2.feature + "(");
    this.node(node2.value);
    this.token(RightParenthesis, ")");
  }
  const FeatureFunction = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$x,
    name: name$w,
    parse: parse$x,
    structure: structure$w
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const SOLIDUS$3 = 47;
  const LESSTHANSIGN = 60;
  const EQUALSSIGN = 61;
  const GREATERTHANSIGN$1 = 62;
  const name$v = "FeatureRange";
  const structure$v = {
    kind: String,
    left: [
      "Identifier",
      "Number",
      "Dimension",
      "Ratio",
      "Function"
    ],
    leftComparison: String,
    middle: [
      "Identifier",
      "Number",
      "Dimension",
      "Ratio",
      "Function"
    ],
    rightComparison: [
      String,
      null
    ],
    right: [
      "Identifier",
      "Number",
      "Dimension",
      "Ratio",
      "Function",
      null
    ]
  };
  function readTerm() {
    this.skipSC();
    switch (this.tokenType) {
      case Number$2:
        if (this.isDelim(SOLIDUS$3, this.lookupOffsetNonSC(1))) {
          return this.Ratio();
        } else {
          return this.Number();
        }
      case Dimension$1:
        return this.Dimension();
      case Ident:
        return this.Identifier();
      case Function$2:
        return this.parseWithFallback(() => {
          const res = this.Function(this.readSequence, this.scope.Value);
          this.skipSC();
          if (this.isDelim(SOLIDUS$3)) {
            this.error();
          }
          return res;
        }, () => {
          return this.Ratio();
        });
      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }
  }
  function readComparison(expectColon) {
    this.skipSC();
    if (this.isDelim(LESSTHANSIGN) || this.isDelim(GREATERTHANSIGN$1)) {
      const value2 = this.source[this.tokenStart];
      this.next();
      if (this.isDelim(EQUALSSIGN)) {
        this.next();
        return value2 + "=";
      }
      return value2;
    }
    if (this.isDelim(EQUALSSIGN)) {
      return "=";
    }
    this.error(`Expected ${expectColon ? '":", ' : ""}"<", ">", "=" or ")"`);
  }
  function parse$w(kind = "unknown") {
    const start = this.tokenStart;
    this.skipSC();
    this.eat(LeftParenthesis);
    const left = readTerm.call(this);
    const leftComparison = readComparison.call(this, left.type === "Identifier");
    const middle = readTerm.call(this);
    let rightComparison = null;
    let right = null;
    if (this.lookupNonWSType(0) !== RightParenthesis) {
      rightComparison = readComparison.call(this);
      right = readTerm.call(this);
    }
    this.skipSC();
    this.eat(RightParenthesis);
    return {
      type: "FeatureRange",
      loc: this.getLocation(start, this.tokenStart),
      kind,
      left,
      leftComparison,
      middle,
      rightComparison,
      right
    };
  }
  function generate$w(node2) {
    this.token(LeftParenthesis, "(");
    this.node(node2.left);
    this.tokenize(node2.leftComparison);
    this.node(node2.middle);
    if (node2.right) {
      this.tokenize(node2.rightComparison);
      this.node(node2.right);
    }
    this.token(RightParenthesis, ")");
  }
  const FeatureRange = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$w,
    name: name$v,
    parse: parse$w,
    structure: structure$v
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$u = "Function";
  const walkContext$5 = "function";
  const structure$u = {
    name: String,
    children: [
      []
    ]
  };
  function parse$v(readSequence2, recognizer) {
    const start = this.tokenStart;
    const name2 = this.consumeFunctionName();
    const nameLowerCase = name2.toLowerCase();
    let children;
    children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence2.call(this, recognizer);
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "Function",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate$v(node2) {
    this.token(Function$2, node2.name + "(");
    this.children(node2);
    this.token(RightParenthesis, ")");
  }
  const Function$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$v,
    name: name$u,
    parse: parse$v,
    structure: structure$u,
    walkContext: walkContext$5
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$t = "GeneralEnclosed";
  const structure$t = {
    kind: String,
    function: [
      String,
      null
    ],
    children: [
      []
    ]
  };
  function parse$u(kind) {
    const start = this.tokenStart;
    let functionName = null;
    if (this.tokenType === Function$2) {
      functionName = this.consumeFunctionName();
    } else {
      this.eat(LeftParenthesis);
    }
    const children = this.parseWithFallback(() => {
      const startValueToken = this.tokenIndex;
      const children2 = this.readSequence(this.scope.Value);
      if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return children2;
    }, () => this.createSingleNodeList(this.Raw(null, false)));
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "GeneralEnclosed",
      loc: this.getLocation(start, this.tokenStart),
      kind,
      function: functionName,
      children
    };
  }
  function generate$u(node2) {
    if (node2.function) {
      this.token(Function$2, node2.function + "(");
    } else {
      this.token(LeftParenthesis, "(");
    }
    this.children(node2);
    this.token(RightParenthesis, ")");
  }
  const GeneralEnclosed = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$u,
    name: name$t,
    parse: parse$u,
    structure: structure$t
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const xxx = "XXX";
  const name$s = "Hash";
  const structure$s = {
    value: String
  };
  function parse$t() {
    const start = this.tokenStart;
    this.eat(Hash$1);
    return {
      type: "Hash",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start + 1)
    };
  }
  function generate$t(node2) {
    this.token(Hash$1, "#" + node2.value);
  }
  const Hash = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$t,
    name: name$s,
    parse: parse$t,
    structure: structure$s,
    xxx
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$r = "Identifier";
  const structure$r = {
    name: String
  };
  function parse$s() {
    return {
      type: "Identifier",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      name: this.consume(Ident)
    };
  }
  function generate$s(node2) {
    this.token(Ident, node2.name);
  }
  const Identifier = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$s,
    name: name$r,
    parse: parse$s,
    structure: structure$r
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$q = "IdSelector";
  const structure$q = {
    name: String
  };
  function parse$r() {
    const start = this.tokenStart;
    this.eat(Hash$1);
    return {
      type: "IdSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start + 1)
    };
  }
  function generate$r(node2) {
    this.token(Delim, "#" + node2.name);
  }
  const IdSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$r,
    name: name$q,
    parse: parse$r,
    structure: structure$q
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const FULLSTOP$1 = 46;
  const name$p = "Layer";
  const structure$p = {
    name: String
  };
  function parse$q() {
    let tokenStart = this.tokenStart;
    let name2 = this.consume(Ident);
    while (this.isDelim(FULLSTOP$1)) {
      this.eat(Delim);
      name2 += "." + this.consume(Ident);
    }
    return {
      type: "Layer",
      loc: this.getLocation(tokenStart, this.tokenStart),
      name: name2
    };
  }
  function generate$q(node2) {
    this.tokenize(node2.name);
  }
  const Layer = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$q,
    name: name$p,
    parse: parse$q,
    structure: structure$p
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$o = "LayerList";
  const structure$o = {
    children: [
      [
        "Layer"
      ]
    ]
  };
  function parse$p() {
    const children = this.createList();
    this.skipSC();
    while (!this.eof) {
      children.push(this.Layer());
      if (this.lookupTypeNonSC(0) !== Comma) {
        break;
      }
      this.skipSC();
      this.next();
      this.skipSC();
    }
    return {
      type: "LayerList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$p(node2) {
    this.children(node2, () => this.token(Comma, ","));
  }
  const LayerList = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$p,
    name: name$o,
    parse: parse$p,
    structure: structure$o
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$n = "MediaQuery";
  const structure$n = {
    modifier: [
      String,
      null
    ],
    mediaType: [
      String,
      null
    ],
    condition: [
      "Condition",
      null
    ]
  };
  function parse$o() {
    const start = this.tokenStart;
    let modifier = null;
    let mediaType = null;
    let condition = null;
    this.skipSC();
    if (this.tokenType === Ident && this.lookupTypeNonSC(1) !== LeftParenthesis) {
      const ident = this.consume(Ident);
      const identLowerCase = ident.toLowerCase();
      if (identLowerCase === "not" || identLowerCase === "only") {
        this.skipSC();
        modifier = identLowerCase;
        mediaType = this.consume(Ident);
      } else {
        mediaType = ident;
      }
      switch (this.lookupTypeNonSC(0)) {
        case Ident: {
          this.skipSC();
          this.eatIdent("and");
          condition = this.Condition("media");
          break;
        }
        case LeftCurlyBracket:
        case Semicolon:
        case Comma:
        case EOF$1:
          break;
        default:
          this.error("Identifier or parenthesis is expected");
      }
    } else {
      switch (this.tokenType) {
        case Ident:
        case LeftParenthesis:
        case Function$2: {
          condition = this.Condition("media");
          break;
        }
        case LeftCurlyBracket:
        case Semicolon:
        case EOF$1:
          break;
        default:
          this.error("Identifier or parenthesis is expected");
      }
    }
    return {
      type: "MediaQuery",
      loc: this.getLocation(start, this.tokenStart),
      modifier,
      mediaType,
      condition
    };
  }
  function generate$o(node2) {
    if (node2.mediaType) {
      if (node2.modifier) {
        this.token(Ident, node2.modifier);
      }
      this.token(Ident, node2.mediaType);
      if (node2.condition) {
        this.token(Ident, "and");
        this.node(node2.condition);
      }
    } else if (node2.condition) {
      this.node(node2.condition);
    }
  }
  const MediaQuery = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$o,
    name: name$n,
    parse: parse$o,
    structure: structure$n
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$m = "MediaQueryList";
  const structure$m = {
    children: [
      [
        "MediaQuery"
      ]
    ]
  };
  function parse$n() {
    const children = this.createList();
    this.skipSC();
    while (!this.eof) {
      children.push(this.MediaQuery());
      if (this.tokenType !== Comma) {
        break;
      }
      this.next();
    }
    return {
      type: "MediaQueryList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$n(node2) {
    this.children(node2, () => this.token(Comma, ","));
  }
  const MediaQueryList = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$n,
    name: name$m,
    parse: parse$n,
    structure: structure$m
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const AMPERSAND$1 = 38;
  const name$l = "NestingSelector";
  const structure$l = {};
  function parse$m() {
    const start = this.tokenStart;
    this.eatDelim(AMPERSAND$1);
    return {
      type: "NestingSelector",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate$m() {
    this.token(Delim, "&");
  }
  const NestingSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$m,
    name: name$l,
    parse: parse$m,
    structure: structure$l
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$k = "Nth";
  const structure$k = {
    nth: [
      "AnPlusB",
      "Identifier"
    ],
    selector: [
      "SelectorList",
      null
    ]
  };
  function parse$l() {
    this.skipSC();
    const start = this.tokenStart;
    let end = start;
    let selector2 = null;
    let nth2;
    if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
      nth2 = this.Identifier();
    } else {
      nth2 = this.AnPlusB();
    }
    end = this.tokenStart;
    this.skipSC();
    if (this.lookupValue(0, "of")) {
      this.next();
      selector2 = this.SelectorList();
      end = this.tokenStart;
    }
    return {
      type: "Nth",
      loc: this.getLocation(start, end),
      nth: nth2,
      selector: selector2
    };
  }
  function generate$l(node2) {
    this.node(node2.nth);
    if (node2.selector !== null) {
      this.token(Ident, "of");
      this.node(node2.selector);
    }
  }
  const Nth = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$l,
    name: name$k,
    parse: parse$l,
    structure: structure$k
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$j = "Number";
  const structure$j = {
    value: String
  };
  function parse$k() {
    return {
      type: "Number",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consume(Number$2)
    };
  }
  function generate$k(node2) {
    this.token(Number$2, node2.value);
  }
  const Number$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$k,
    name: name$j,
    parse: parse$k,
    structure: structure$j
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$i = "Operator";
  const structure$i = {
    value: String
  };
  function parse$j() {
    const start = this.tokenStart;
    this.next();
    return {
      type: "Operator",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  function generate$j(node2) {
    this.tokenize(node2.value);
  }
  const Operator = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$j,
    name: name$i,
    parse: parse$j,
    structure: structure$i
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$h = "Parentheses";
  const structure$h = {
    children: [
      []
    ]
  };
  function parse$i(readSequence2, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(LeftParenthesis);
    children = readSequence2.call(this, recognizer);
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "Parentheses",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate$i(node2) {
    this.token(LeftParenthesis, "(");
    this.children(node2);
    this.token(RightParenthesis, ")");
  }
  const Parentheses = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$i,
    name: name$h,
    parse: parse$i,
    structure: structure$h
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$g = "Percentage";
  const structure$g = {
    value: String
  };
  function parse$h() {
    return {
      type: "Percentage",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consumeNumber(Percentage$1)
    };
  }
  function generate$h(node2) {
    this.token(Percentage$1, node2.value + "%");
  }
  const Percentage = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$h,
    name: name$g,
    parse: parse$h,
    structure: structure$g
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$f = "PseudoClassSelector";
  const walkContext$4 = "function";
  const structure$f = {
    name: String,
    children: [
      [
        "Raw"
      ],
      null
    ]
  };
  function parse$g() {
    const start = this.tokenStart;
    let children = null;
    let name2;
    let nameLowerCase;
    this.eat(Colon);
    if (this.tokenType === Function$2) {
      name2 = this.consumeFunctionName();
      nameLowerCase = name2.toLowerCase();
      if (this.lookupNonWSType(0) == RightParenthesis) {
        children = this.createList();
      } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(null, false));
      }
      this.eat(RightParenthesis);
    } else {
      name2 = this.consume(Ident);
    }
    return {
      type: "PseudoClassSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate$g(node2) {
    this.token(Colon, ":");
    if (node2.children === null) {
      this.token(Ident, node2.name);
    } else {
      this.token(Function$2, node2.name + "(");
      this.children(node2);
      this.token(RightParenthesis, ")");
    }
  }
  const PseudoClassSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$g,
    name: name$f,
    parse: parse$g,
    structure: structure$f,
    walkContext: walkContext$4
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$e = "PseudoElementSelector";
  const walkContext$3 = "function";
  const structure$e = {
    name: String,
    children: [
      [
        "Raw"
      ],
      null
    ]
  };
  function parse$f() {
    const start = this.tokenStart;
    let children = null;
    let name2;
    let nameLowerCase;
    this.eat(Colon);
    this.eat(Colon);
    if (this.tokenType === Function$2) {
      name2 = this.consumeFunctionName();
      nameLowerCase = name2.toLowerCase();
      if (this.lookupNonWSType(0) == RightParenthesis) {
        children = this.createList();
      } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(null, false));
      }
      this.eat(RightParenthesis);
    } else {
      name2 = this.consume(Ident);
    }
    return {
      type: "PseudoElementSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate$f(node2) {
    this.token(Colon, ":");
    this.token(Colon, ":");
    if (node2.children === null) {
      this.token(Ident, node2.name);
    } else {
      this.token(Function$2, node2.name + "(");
      this.children(node2);
      this.token(RightParenthesis, ")");
    }
  }
  const PseudoElementSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$f,
    name: name$e,
    parse: parse$f,
    structure: structure$e,
    walkContext: walkContext$3
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const SOLIDUS$2 = 47;
  function consumeTerm() {
    this.skipSC();
    switch (this.tokenType) {
      case Number$2:
        return this.Number();
      case Function$2:
        return this.Function(this.readSequence, this.scope.Value);
      default:
        this.error("Number of function is expected");
    }
  }
  const name$d = "Ratio";
  const structure$d = {
    left: [
      "Number",
      "Function"
    ],
    right: [
      "Number",
      "Function",
      null
    ]
  };
  function parse$e() {
    const start = this.tokenStart;
    const left = consumeTerm.call(this);
    let right = null;
    this.skipSC();
    if (this.isDelim(SOLIDUS$2)) {
      this.eatDelim(SOLIDUS$2);
      right = consumeTerm.call(this);
    }
    return {
      type: "Ratio",
      loc: this.getLocation(start, this.tokenStart),
      left,
      right
    };
  }
  function generate$e(node2) {
    this.node(node2.left);
    this.token(Delim, "/");
    if (node2.right) {
      this.node(node2.right);
    } else {
      this.node(Number$2, 1);
    }
  }
  const Ratio = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$e,
    name: name$d,
    parse: parse$e,
    structure: structure$d
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function getOffsetExcludeWS() {
    if (this.tokenIndex > 0) {
      if (this.lookupType(-1) === WhiteSpace$1) {
        return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
      }
    }
    return this.tokenStart;
  }
  const name$c = "Raw";
  const structure$c = {
    value: String
  };
  function parse$d(consumeUntil, excludeWhiteSpace) {
    const startOffset = this.getTokenStart(this.tokenIndex);
    let endOffset;
    this.skipUntilBalanced(this.tokenIndex, consumeUntil || this.consumeUntilBalanceEnd);
    if (excludeWhiteSpace && this.tokenStart > startOffset) {
      endOffset = getOffsetExcludeWS.call(this);
    } else {
      endOffset = this.tokenStart;
    }
    return {
      type: "Raw",
      loc: this.getLocation(startOffset, endOffset),
      value: this.substring(startOffset, endOffset)
    };
  }
  function generate$d(node2) {
    this.tokenize(node2.value);
  }
  const Raw = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$d,
    name: name$c,
    parse: parse$d,
    structure: structure$c
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function consumeRaw$1() {
    return this.Raw(this.consumeUntilLeftCurlyBracket, true);
  }
  function consumePrelude() {
    const prelude = this.SelectorList();
    if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket) {
      this.error();
    }
    return prelude;
  }
  const name$b = "Rule";
  const walkContext$2 = "rule";
  const structure$b = {
    prelude: [
      "SelectorList",
      "Raw"
    ],
    block: [
      "Block"
    ]
  };
  function parse$c() {
    const startToken = this.tokenIndex;
    const startOffset = this.tokenStart;
    let prelude;
    let block;
    if (this.parseRulePrelude) {
      prelude = this.parseWithFallback(consumePrelude, consumeRaw$1);
    } else {
      prelude = consumeRaw$1.call(this, startToken);
    }
    block = this.Block(true);
    return {
      type: "Rule",
      loc: this.getLocation(startOffset, this.tokenStart),
      prelude,
      block
    };
  }
  function generate$c(node2) {
    this.node(node2.prelude);
    this.node(node2.block);
  }
  const Rule = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$c,
    name: name$b,
    parse: parse$c,
    structure: structure$b,
    walkContext: walkContext$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$a = "Scope";
  const structure$a = {
    root: [
      "SelectorList",
      "Raw",
      null
    ],
    limit: [
      "SelectorList",
      "Raw",
      null
    ]
  };
  function parse$b() {
    let root = null;
    let limit = null;
    this.skipSC();
    const startOffset = this.tokenStart;
    if (this.tokenType === LeftParenthesis) {
      this.next();
      this.skipSC();
      root = this.parseWithFallback(this.SelectorList, () => this.Raw(false, true));
      this.skipSC();
      this.eat(RightParenthesis);
    }
    if (this.lookupNonWSType(0) === Ident) {
      this.skipSC();
      this.eatIdent("to");
      this.skipSC();
      this.eat(LeftParenthesis);
      this.skipSC();
      limit = this.parseWithFallback(this.SelectorList, () => this.Raw(false, true));
      this.skipSC();
      this.eat(RightParenthesis);
    }
    return {
      type: "Scope",
      loc: this.getLocation(startOffset, this.tokenStart),
      root,
      limit
    };
  }
  function generate$b(node2) {
    if (node2.root) {
      this.token(LeftParenthesis, "(");
      this.node(node2.root);
      this.token(RightParenthesis, ")");
    }
    if (node2.limit) {
      this.token(Ident, "to");
      this.token(LeftParenthesis, "(");
      this.node(node2.limit);
      this.token(RightParenthesis, ")");
    }
  }
  const Scope = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$b,
    name: name$a,
    parse: parse$b,
    structure: structure$a
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$9 = "Selector";
  const structure$9 = {
    children: [
      [
        "TypeSelector",
        "IdSelector",
        "ClassSelector",
        "AttributeSelector",
        "PseudoClassSelector",
        "PseudoElementSelector",
        "Combinator"
      ]
    ]
  };
  function parse$a() {
    const children = this.readSequence(this.scope.Selector);
    if (this.getFirstListNode(children) === null) {
      this.error("Selector is expected");
    }
    return {
      type: "Selector",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$a(node2) {
    this.children(node2);
  }
  const Selector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$a,
    name: name$9,
    parse: parse$a,
    structure: structure$9
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$8 = "SelectorList";
  const walkContext$1 = "selector";
  const structure$8 = {
    children: [
      [
        "Selector",
        "Raw"
      ]
    ]
  };
  function parse$9() {
    const children = this.createList();
    while (!this.eof) {
      children.push(this.Selector());
      if (this.tokenType === Comma) {
        this.next();
        continue;
      }
      break;
    }
    return {
      type: "SelectorList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate$9(node2) {
    this.children(node2, () => this.token(Comma, ","));
  }
  const SelectorList = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$9,
    name: name$8,
    parse: parse$9,
    structure: structure$8,
    walkContext: walkContext$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const REVERSE_SOLIDUS$1 = 92;
  const QUOTATION_MARK$1 = 34;
  const APOSTROPHE$1 = 39;
  function decode$1(str) {
    const len = str.length;
    const firstChar = str.charCodeAt(0);
    const start = firstChar === QUOTATION_MARK$1 || firstChar === APOSTROPHE$1 ? 1 : 0;
    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
    let decoded = "";
    for (let i2 = start; i2 <= end; i2++) {
      let code2 = str.charCodeAt(i2);
      if (code2 === REVERSE_SOLIDUS$1) {
        if (i2 === end) {
          if (i2 !== len - 1) {
            decoded = str.substr(i2 + 1);
          }
          break;
        }
        code2 = str.charCodeAt(++i2);
        if (isValidEscape(REVERSE_SOLIDUS$1, code2)) {
          const escapeStart = i2 - 1;
          const escapeEnd = consumeEscaped(str, escapeStart);
          i2 = escapeEnd - 1;
          decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code2 === 13 && str.charCodeAt(i2 + 1) === 10) {
            i2++;
          }
        }
      } else {
        decoded += str[i2];
      }
    }
    return decoded;
  }
  function encode$1(str, apostrophe) {
    const quote = '"';
    const quoteCode = QUOTATION_MARK$1;
    let encoded = "";
    let wsBeforeHexIsNeeded = false;
    for (let i2 = 0; i2 < str.length; i2++) {
      const code2 = str.charCodeAt(i2);
      if (code2 === 0) {
        encoded += "\uFFFD";
        continue;
      }
      if (code2 <= 31 || code2 === 127) {
        encoded += "\\" + code2.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      }
      if (code2 === quoteCode || code2 === REVERSE_SOLIDUS$1) {
        encoded += "\\" + str.charAt(i2);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && (isHexDigit(code2) || isWhiteSpace(code2))) {
          encoded += " ";
        }
        encoded += str.charAt(i2);
        wsBeforeHexIsNeeded = false;
      }
    }
    return quote + encoded + quote;
  }
  const name$7 = "String";
  const structure$7 = {
    value: String
  };
  function parse$8() {
    return {
      type: "String",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: decode$1(this.consume(String$2))
    };
  }
  function generate$8(node2) {
    this.token(String$2, encode$1(node2.value));
  }
  const String$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$8,
    name: name$7,
    parse: parse$8,
    structure: structure$7
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const EXCLAMATIONMARK = 33;
  function consumeRaw() {
    return this.Raw(null, false);
  }
  const name$6 = "StyleSheet";
  const walkContext = "stylesheet";
  const structure$6 = {
    children: [
      [
        "Comment",
        "CDO",
        "CDC",
        "Atrule",
        "Rule",
        "Raw"
      ]
    ]
  };
  function parse$7() {
    const start = this.tokenStart;
    const children = this.createList();
    let child;
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace$1:
          this.next();
          continue;
        case Comment$1:
          if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
            this.next();
            continue;
          }
          child = this.Comment();
          break;
        case CDO$1:
          child = this.CDO();
          break;
        case CDC$1:
          child = this.CDC();
          break;
        case AtKeyword:
          child = this.parseWithFallback(this.Atrule, consumeRaw);
          break;
        default:
          child = this.parseWithFallback(this.Rule, consumeRaw);
      }
      children.push(child);
    }
    return {
      type: "StyleSheet",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate$7(node2) {
    this.children(node2);
  }
  const StyleSheet = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$7,
    name: name$6,
    parse: parse$7,
    structure: structure$6,
    walkContext
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$5 = "SupportsDeclaration";
  const structure$5 = {
    declaration: "Declaration"
  };
  function parse$6() {
    const start = this.tokenStart;
    this.eat(LeftParenthesis);
    this.skipSC();
    const declaration = this.Declaration();
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "SupportsDeclaration",
      loc: this.getLocation(start, this.tokenStart),
      declaration
    };
  }
  function generate$6(node2) {
    this.token(LeftParenthesis, "(");
    this.node(node2.declaration);
    this.token(RightParenthesis, ")");
  }
  const SupportsDeclaration = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$6,
    name: name$5,
    parse: parse$6,
    structure: structure$5
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const ASTERISK$2 = 42;
  const VERTICALLINE$1 = 124;
  function eatIdentifierOrAsterisk() {
    if (this.tokenType !== Ident && this.isDelim(ASTERISK$2) === false) {
      this.error("Identifier or asterisk is expected");
    }
    this.next();
  }
  const name$4 = "TypeSelector";
  const structure$4 = {
    name: String
  };
  function parse$5() {
    const start = this.tokenStart;
    if (this.isDelim(VERTICALLINE$1)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    } else {
      eatIdentifierOrAsterisk.call(this);
      if (this.isDelim(VERTICALLINE$1)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
      }
    }
    return {
      type: "TypeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  function generate$5(node2) {
    this.tokenize(node2.name);
  }
  const TypeSelector = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$5,
    name: name$4,
    parse: parse$5,
    structure: structure$4
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const PLUSSIGN$2 = 43;
  const HYPHENMINUS$1 = 45;
  const QUESTIONMARK = 63;
  function eatHexSequence(offset, allowDash) {
    let len = 0;
    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
      const code2 = this.charCodeAt(pos);
      if (code2 === HYPHENMINUS$1 && allowDash && len !== 0) {
        eatHexSequence.call(this, offset + len + 1, false);
        return -1;
      }
      if (!isHexDigit(code2)) {
        this.error(allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input", pos);
      }
      if (++len > 6) {
        this.error("Too many hex digits", pos);
      }
    }
    this.next();
    return len;
  }
  function eatQuestionMarkSequence(max) {
    let count = 0;
    while (this.isDelim(QUESTIONMARK)) {
      if (++count > max) {
        this.error("Too many question marks");
      }
      this.next();
    }
  }
  function startsWith(code2) {
    if (this.charCodeAt(this.tokenStart) !== code2) {
      this.error((code2 === PLUSSIGN$2 ? "Plus sign" : "Hyphen minus") + " is expected");
    }
  }
  function scanUnicodeRange() {
    let hexLength = 0;
    switch (this.tokenType) {
      case Number$2:
        hexLength = eatHexSequence.call(this, 1, true);
        if (this.isDelim(QUESTIONMARK)) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
          break;
        }
        if (this.tokenType === Dimension$1 || this.tokenType === Number$2) {
          startsWith.call(this, HYPHENMINUS$1);
          eatHexSequence.call(this, 1, false);
          break;
        }
        break;
      case Dimension$1:
        hexLength = eatHexSequence.call(this, 1, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      default:
        this.eatDelim(PLUSSIGN$2);
        if (this.tokenType === Ident) {
          hexLength = eatHexSequence.call(this, 0, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          break;
        }
        if (this.isDelim(QUESTIONMARK)) {
          this.next();
          eatQuestionMarkSequence.call(this, 5);
          break;
        }
        this.error("Hex digit or question mark is expected");
    }
  }
  const name$3 = "UnicodeRange";
  const structure$3 = {
    value: String
  };
  function parse$4() {
    const start = this.tokenStart;
    this.eatIdent("u");
    scanUnicodeRange.call(this);
    return {
      type: "UnicodeRange",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  function generate$4(node2) {
    this.tokenize(node2.value);
  }
  const UnicodeRange = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$4,
    name: name$3,
    parse: parse$4,
    structure: structure$3
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const SPACE$1 = 32;
  const REVERSE_SOLIDUS = 92;
  const QUOTATION_MARK = 34;
  const APOSTROPHE = 39;
  const LEFTPARENTHESIS = 40;
  const RIGHTPARENTHESIS = 41;
  function decode(str) {
    const len = str.length;
    let start = 4;
    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
    let decoded = "";
    while (start < end && isWhiteSpace(str.charCodeAt(start))) {
      start++;
    }
    while (start < end && isWhiteSpace(str.charCodeAt(end))) {
      end--;
    }
    for (let i2 = start; i2 <= end; i2++) {
      let code2 = str.charCodeAt(i2);
      if (code2 === REVERSE_SOLIDUS) {
        if (i2 === end) {
          if (i2 !== len - 1) {
            decoded = str.substr(i2 + 1);
          }
          break;
        }
        code2 = str.charCodeAt(++i2);
        if (isValidEscape(REVERSE_SOLIDUS, code2)) {
          const escapeStart = i2 - 1;
          const escapeEnd = consumeEscaped(str, escapeStart);
          i2 = escapeEnd - 1;
          decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code2 === 13 && str.charCodeAt(i2 + 1) === 10) {
            i2++;
          }
        }
      } else {
        decoded += str[i2];
      }
    }
    return decoded;
  }
  function encode(str) {
    let encoded = "";
    let wsBeforeHexIsNeeded = false;
    for (let i2 = 0; i2 < str.length; i2++) {
      const code2 = str.charCodeAt(i2);
      if (code2 === 0) {
        encoded += "\uFFFD";
        continue;
      }
      if (code2 <= 31 || code2 === 127) {
        encoded += "\\" + code2.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      }
      if (code2 === SPACE$1 || code2 === REVERSE_SOLIDUS || code2 === QUOTATION_MARK || code2 === APOSTROPHE || code2 === LEFTPARENTHESIS || code2 === RIGHTPARENTHESIS) {
        encoded += "\\" + str.charAt(i2);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && isHexDigit(code2)) {
          encoded += " ";
        }
        encoded += str.charAt(i2);
        wsBeforeHexIsNeeded = false;
      }
    }
    return "url(" + encoded + ")";
  }
  const name$2 = "Url";
  const structure$2 = {
    value: String
  };
  function parse$3() {
    const start = this.tokenStart;
    let value2;
    switch (this.tokenType) {
      case Url$1:
        value2 = decode(this.consume(Url$1));
        break;
      case Function$2:
        if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
          this.error("Function name must be `url`");
        }
        this.eat(Function$2);
        this.skipSC();
        value2 = decode$1(this.consume(String$2));
        this.skipSC();
        if (!this.eof) {
          this.eat(RightParenthesis);
        }
        break;
      default:
        this.error("Url or Function is expected");
    }
    return {
      type: "Url",
      loc: this.getLocation(start, this.tokenStart),
      value: value2
    };
  }
  function generate$3(node2) {
    this.token(Url$1, encode(node2.value));
  }
  const Url = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$3,
    name: name$2,
    parse: parse$3,
    structure: structure$2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const name$1 = "Value";
  const structure$1 = {
    children: [
      []
    ]
  };
  function parse$2() {
    const start = this.tokenStart;
    const children = this.readSequence(this.scope.Value);
    return {
      type: "Value",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate$2(node2) {
    this.children(node2);
  }
  const Value = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$2,
    name: name$1,
    parse: parse$2,
    structure: structure$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const SPACE = Object.freeze({
    type: "WhiteSpace",
    loc: null,
    value: " "
  });
  const name = "WhiteSpace";
  const structure = {
    value: String
  };
  function parse$1() {
    this.eat(WhiteSpace$1);
    return SPACE;
  }
  function generate$1(node2) {
    this.token(WhiteSpace$1, node2.value);
  }
  const WhiteSpace = Object.freeze(Object.defineProperty({
    __proto__: null,
    generate: generate$1,
    name,
    parse: parse$1,
    structure
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const node$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    AnPlusB,
    Atrule,
    AtrulePrelude,
    AttributeSelector,
    Block,
    Brackets,
    CDC,
    CDO,
    ClassSelector,
    Combinator,
    Comment,
    Condition,
    Declaration,
    DeclarationList,
    Dimension,
    Feature,
    FeatureFunction,
    FeatureRange,
    Function: Function$1,
    GeneralEnclosed,
    Hash,
    IdSelector,
    Identifier,
    Layer,
    LayerList,
    MediaQuery,
    MediaQueryList,
    NestingSelector,
    Nth,
    Number: Number$1,
    Operator,
    Parentheses,
    Percentage,
    PseudoClassSelector,
    PseudoElementSelector,
    Ratio,
    Raw,
    Rule,
    Scope,
    Selector,
    SelectorList,
    String: String$1,
    StyleSheet,
    SupportsDeclaration,
    TypeSelector,
    UnicodeRange,
    Url,
    Value,
    WhiteSpace
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const lexerConfig = {
    generic: true,
    cssWideKeywords,
    ...definitions,
    node: node$1
  };
  const NUMBERSIGN$1 = 35;
  const ASTERISK$1 = 42;
  const PLUSSIGN$1 = 43;
  const HYPHENMINUS = 45;
  const SOLIDUS$1 = 47;
  const U = 117;
  function defaultRecognizer(context2) {
    switch (this.tokenType) {
      case Hash$1:
        return this.Hash();
      case Comma:
        return this.Operator();
      case LeftParenthesis:
        return this.Parentheses(this.readSequence, context2.recognizer);
      case LeftSquareBracket:
        return this.Brackets(this.readSequence, context2.recognizer);
      case String$2:
        return this.String();
      case Dimension$1:
        return this.Dimension();
      case Percentage$1:
        return this.Percentage();
      case Number$2:
        return this.Number();
      case Function$2:
        return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context2.recognizer);
      case Url$1:
        return this.Url();
      case Ident:
        if (this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, PLUSSIGN$1)) {
          return this.UnicodeRange();
        } else {
          return this.Identifier();
        }
      case Delim: {
        const code2 = this.charCodeAt(this.tokenStart);
        if (code2 === SOLIDUS$1 || code2 === ASTERISK$1 || code2 === PLUSSIGN$1 || code2 === HYPHENMINUS) {
          return this.Operator();
        }
        if (code2 === NUMBERSIGN$1) {
          this.error("Hex or identifier is expected", this.tokenStart + 1);
        }
        break;
      }
    }
  }
  const atrulePrelude = {
    getNode: defaultRecognizer
  };
  const NUMBERSIGN = 35;
  const AMPERSAND = 38;
  const ASTERISK = 42;
  const PLUSSIGN = 43;
  const SOLIDUS = 47;
  const FULLSTOP = 46;
  const GREATERTHANSIGN = 62;
  const VERTICALLINE = 124;
  const TILDE = 126;
  function onWhiteSpace(next, children) {
    if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
      children.push({
        type: "Combinator",
        loc: null,
        name: " "
      });
    }
  }
  function getNode() {
    switch (this.tokenType) {
      case LeftSquareBracket:
        return this.AttributeSelector();
      case Hash$1:
        return this.IdSelector();
      case Colon:
        if (this.lookupType(1) === Colon) {
          return this.PseudoElementSelector();
        } else {
          return this.PseudoClassSelector();
        }
      case Ident:
        return this.TypeSelector();
      case Number$2:
      case Percentage$1:
        return this.Percentage();
      case Dimension$1:
        if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
          this.error("Identifier is expected", this.tokenStart + 1);
        }
        break;
      case Delim: {
        const code2 = this.charCodeAt(this.tokenStart);
        switch (code2) {
          case PLUSSIGN:
          case GREATERTHANSIGN:
          case TILDE:
          case SOLIDUS:
            return this.Combinator();
          case FULLSTOP:
            return this.ClassSelector();
          case ASTERISK:
          case VERTICALLINE:
            return this.TypeSelector();
          case NUMBERSIGN:
            return this.IdSelector();
          case AMPERSAND:
            return this.NestingSelector();
        }
        break;
      }
    }
  }
  const selector$1 = {
    onWhiteSpace,
    getNode
  };
  function expressionFn() {
    return this.createSingleNodeList(this.Raw(null, false));
  }
  function varFn() {
    const children = this.createList();
    this.skipSC();
    children.push(this.Identifier());
    this.skipSC();
    if (this.tokenType === Comma) {
      children.push(this.Operator());
      const startIndex = this.tokenIndex;
      const value2 = this.parseCustomProperty ? this.Value(null) : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
      if (value2.type === "Value" && value2.children.isEmpty) {
        for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
          if (this.lookupType(offset) === WhiteSpace$1) {
            value2.children.appendData({
              type: "WhiteSpace",
              loc: null,
              value: " "
            });
            break;
          }
        }
      }
      children.push(value2);
    }
    return children;
  }
  function isPlusMinusOperator(node2) {
    return node2 !== null && node2.type === "Operator" && (node2.value[node2.value.length - 1] === "-" || node2.value[node2.value.length - 1] === "+");
  }
  const value = {
    getNode: defaultRecognizer,
    onWhiteSpace(next, children) {
      if (isPlusMinusOperator(next)) {
        next.value = " " + next.value;
      }
      if (isPlusMinusOperator(children.last)) {
        children.last.value += " ";
      }
    },
    "expression": expressionFn,
    "var": varFn
  };
  const scope$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    AtrulePrelude: atrulePrelude,
    Selector: selector$1,
    Value: value
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const nonContainerNameKeywords = /* @__PURE__ */ new Set([
    "none",
    "and",
    "not",
    "or"
  ]);
  const container = {
    parse: {
      prelude() {
        const children = this.createList();
        if (this.tokenType === Ident) {
          const name2 = this.substring(this.tokenStart, this.tokenEnd);
          if (!nonContainerNameKeywords.has(name2.toLowerCase())) {
            children.push(this.Identifier());
          }
        }
        children.push(this.Condition("container"));
        return children;
      },
      block(nested = false) {
        return this.Block(nested);
      }
    }
  };
  const fontFace = {
    parse: {
      prelude: null,
      block() {
        return this.Block(true);
      }
    }
  };
  function parseWithFallback(parse2, fallback) {
    return this.parseWithFallback(() => {
      try {
        return parse2.call(this);
      } finally {
        this.skipSC();
        if (this.lookupNonWSType(0) !== RightParenthesis) {
          this.error();
        }
      }
    }, fallback || (() => this.Raw(null, true)));
  }
  const parseFunctions = {
    layer() {
      this.skipSC();
      const children = this.createList();
      const node2 = parseWithFallback.call(this, this.Layer);
      if (node2.type !== "Raw" || node2.value !== "") {
        children.push(node2);
      }
      return children;
    },
    supports() {
      this.skipSC();
      const children = this.createList();
      const node2 = parseWithFallback.call(this, this.Declaration, () => parseWithFallback.call(this, () => this.Condition("supports")));
      if (node2.type !== "Raw" || node2.value !== "") {
        children.push(node2);
      }
      return children;
    }
  };
  const importAtrule = {
    parse: {
      prelude() {
        const children = this.createList();
        switch (this.tokenType) {
          case String$2:
            children.push(this.String());
            break;
          case Url$1:
          case Function$2:
            children.push(this.Url());
            break;
          default:
            this.error("String or url() is expected");
        }
        this.skipSC();
        if (this.tokenType === Ident && this.cmpStr(this.tokenStart, this.tokenEnd, "layer")) {
          children.push(this.Identifier());
        } else if (this.tokenType === Function$2 && this.cmpStr(this.tokenStart, this.tokenEnd, "layer(")) {
          children.push(this.Function(null, parseFunctions));
        }
        this.skipSC();
        if (this.tokenType === Function$2 && this.cmpStr(this.tokenStart, this.tokenEnd, "supports(")) {
          children.push(this.Function(null, parseFunctions));
        }
        if (this.lookupNonWSType(0) === Ident || this.lookupNonWSType(0) === LeftParenthesis) {
          children.push(this.MediaQueryList());
        }
        return children;
      },
      block: null
    }
  };
  const layer = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.LayerList());
      },
      block() {
        return this.Block(false);
      }
    }
  };
  const media = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.MediaQueryList());
      },
      block(nested = false) {
        return this.Block(nested);
      }
    }
  };
  const nest = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.SelectorList());
      },
      block() {
        return this.Block(true);
      }
    }
  };
  const page = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.SelectorList());
      },
      block() {
        return this.Block(true);
      }
    }
  };
  const scope = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.Scope());
      },
      block(nested = false) {
        return this.Block(nested);
      }
    }
  };
  const startingStyle = {
    parse: {
      prelude: null,
      block(nested = false) {
        return this.Block(nested);
      }
    }
  };
  const supports = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.Condition("supports"));
      },
      block(nested = false) {
        return this.Block(nested);
      }
    }
  };
  const atrule = {
    container,
    "font-face": fontFace,
    import: importAtrule,
    layer,
    media,
    nest,
    page,
    scope,
    "starting-style": startingStyle,
    supports
  };
  function parseLanguageRangeList() {
    const children = this.createList();
    this.skipSC();
    loop: while (!this.eof) {
      switch (this.tokenType) {
        case Ident:
          children.push(this.Identifier());
          break;
        case String$2:
          children.push(this.String());
          break;
        case Comma:
          children.push(this.Operator());
          break;
        case RightParenthesis:
          break loop;
        default:
          this.error("Identifier, string or comma is expected");
      }
      this.skipSC();
    }
    return children;
  }
  const selectorList = {
    parse() {
      return this.createSingleNodeList(this.SelectorList());
    }
  };
  const selector = {
    parse() {
      return this.createSingleNodeList(this.Selector());
    }
  };
  const identList = {
    parse() {
      return this.createSingleNodeList(this.Identifier());
    }
  };
  const langList = {
    parse: parseLanguageRangeList
  };
  const nth = {
    parse() {
      return this.createSingleNodeList(this.Nth());
    }
  };
  const pseudo = {
    "dir": identList,
    "has": selectorList,
    "lang": langList,
    "matches": selectorList,
    "is": selectorList,
    "-moz-any": selectorList,
    "-webkit-any": selectorList,
    "where": selectorList,
    "not": selectorList,
    "nth-child": nth,
    "nth-last-child": nth,
    "nth-last-of-type": nth,
    "nth-of-type": nth,
    "slotted": selector,
    "host": selector,
    "host-context": selector
  };
  const node = Object.freeze(Object.defineProperty({
    __proto__: null,
    AnPlusB: parse$N,
    Atrule: parse$M,
    AtrulePrelude: parse$L,
    AttributeSelector: parse$K,
    Block: parse$J,
    Brackets: parse$I,
    CDC: parse$H,
    CDO: parse$G,
    ClassSelector: parse$F,
    Combinator: parse$E,
    Comment: parse$D,
    Condition: parse$C,
    Declaration: parse$B,
    DeclarationList: parse$A,
    Dimension: parse$z,
    Feature: parse$y,
    FeatureFunction: parse$x,
    FeatureRange: parse$w,
    Function: parse$v,
    GeneralEnclosed: parse$u,
    Hash: parse$t,
    IdSelector: parse$r,
    Identifier: parse$s,
    Layer: parse$q,
    LayerList: parse$p,
    MediaQuery: parse$o,
    MediaQueryList: parse$n,
    NestingSelector: parse$m,
    Nth: parse$l,
    Number: parse$k,
    Operator: parse$j,
    Parentheses: parse$i,
    Percentage: parse$h,
    PseudoClassSelector: parse$g,
    PseudoElementSelector: parse$f,
    Ratio: parse$e,
    Raw: parse$d,
    Rule: parse$c,
    Scope: parse$b,
    Selector: parse$a,
    SelectorList: parse$9,
    String: parse$8,
    StyleSheet: parse$7,
    SupportsDeclaration: parse$6,
    TypeSelector: parse$5,
    UnicodeRange: parse$4,
    Url: parse$3,
    Value: parse$2,
    WhiteSpace: parse$1
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const parserConfig = {
    parseContext: {
      default: "StyleSheet",
      stylesheet: "StyleSheet",
      atrule: "Atrule",
      atrulePrelude(options2) {
        return this.AtrulePrelude(options2.atrule ? String(options2.atrule) : null);
      },
      mediaQueryList: "MediaQueryList",
      mediaQuery: "MediaQuery",
      condition(options2) {
        return this.Condition(options2.kind);
      },
      rule: "Rule",
      selectorList: "SelectorList",
      selector: "Selector",
      block() {
        return this.Block(true);
      },
      declarationList: "DeclarationList",
      declaration: "Declaration",
      value: "Value"
    },
    features: {
      supports: {
        selector() {
          return this.Selector();
        }
      },
      container: {
        style() {
          return this.Declaration();
        }
      }
    },
    scope: scope$1,
    atrule,
    pseudo,
    node
  };
  const walkerConfig = {
    node: node$1
  };
  const syntax = createSyntax$1({
    ...lexerConfig,
    ...parserConfig,
    ...walkerConfig
  });
  const { tokenize, parse, generate, lexer, createLexer, walk, find, findLast, findAll, toPlainObject, fromPlainObject, fork } = syntax;
  function resolveRelativePath(dir, relativePath) {
    const parts = dir.split("/").filter(Boolean);
    const relParts = relativePath.split("/");
    for (const part of relParts) {
      if (part === "..") {
        parts.pop();
      } else if (part !== "." && part !== "") {
        parts.push(part);
      }
    }
    return "/" + parts.join("/");
  }
  function resolveCssModulePath(cssPath, currentFile, ctx) {
    if (currentFile && (cssPath.startsWith("./") || cssPath.startsWith("../"))) {
      const dir = currentFile.replace(/\/[^/]+$/, "");
      const resolved = resolveRelativePath(dir, cssPath);
      if (ctx.exists(resolved)) return resolved;
    }
    if (ctx.exists(cssPath)) return cssPath;
    const withSlash = "/" + cssPath.replace(/^\.\//, "");
    if (ctx.exists(withSlash)) return withSlash;
    return null;
  }
  function generateCssModuleReplacement(varName, cssPath, currentFile, ctx) {
    try {
      const resolvedPath2 = resolveCssModulePath(cssPath, currentFile, ctx);
      if (!resolvedPath2) {
        return `const ${varName} = {};`;
      }
      const cssContent = ctx.readFile(resolvedPath2);
      const fileHash = simpleHash(resolvedPath2 + cssContent).slice(0, 6);
      const classMap = {};
      const ast = parse(cssContent);
      walk(ast, {
        visit: "ClassSelector",
        enter(node2) {
          if (!classMap[node2.name]) {
            classMap[node2.name] = `${node2.name}_${fileHash}`;
          }
        }
      });
      walk(ast, {
        visit: "ClassSelector",
        enter(node2) {
          if (classMap[node2.name]) {
            node2.name = classMap[node2.name];
          }
        }
      });
      const scopedCss = generate(ast);
      const escapedCss = scopedCss.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
      const mapEntries = Object.entries(classMap).map(([k, v]) => `${JSON.stringify(k)}: ${JSON.stringify(v)}`).join(", ");
      return `const ${varName} = {${mapEntries}};
(function() {
  if (typeof document !== 'undefined') {
    var id = ${JSON.stringify("cssmod-" + fileHash)};
    if (!document.getElementById(id)) {
      var s = document.createElement('style');
      s.id = id;
      s.textContent = \`${escapedCss}\`;
      document.head.appendChild(s);
    }
  }
})();`;
    } catch {
      return `const ${varName} = {};`;
    }
  }
  function stripCssImports(code2, currentFile, ctx) {
    code2 = code2.replace(/import\s+(\w+)\s+from\s+['"]([^'"]+\.module\.css)['"]\s*;?/g, (_match, varName, cssPath) => {
      return generateCssModuleReplacement(varName, cssPath, currentFile, ctx);
    });
    code2 = code2.replace(/import\s+\{([^}]+)\}\s+from\s+['"]([^'"]+\.module\.css)['"]\s*;?/g, (_match, names, cssPath) => {
      const varName = "__cssModule_" + simpleHash(cssPath);
      const replacement = generateCssModuleReplacement(varName, cssPath, currentFile, ctx);
      const namedExports = names.split(",").map((n) => {
        var _a2;
        const trimmed = n.trim();
        const parts = trimmed.split(/\s+as\s+/);
        const key = parts[0].trim();
        const alias = ((_a2 = parts[1]) == null ? void 0 : _a2.trim()) || key;
        return `const ${alias} = ${varName}[${JSON.stringify(key)}];`;
      }).join("\n");
      return `${replacement}
${namedExports}`;
    });
    return code2.replace(/import\s+['"][^'"]+\.css['"]\s*;?/g, "");
  }
  const EXPLICIT_MAPPINGS = {
    "react": "https://esm.sh/react@18.2.0?dev",
    "react/jsx-runtime": "https://esm.sh/react@18.2.0&dev/jsx-runtime",
    "react/jsx-dev-runtime": "https://esm.sh/react@18.2.0&dev/jsx-dev-runtime",
    "react-dom": "https://esm.sh/react-dom@18.2.0?dev",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev"
  };
  const LOCAL_PACKAGES = /* @__PURE__ */ new Set([
    "next/link",
    "next/router",
    "next/head",
    "next/navigation",
    "next/dynamic",
    "next/image",
    "next/script",
    "next/font/google",
    "next/font/local",
    "convex/_generated/api",
    "convex/react",
    "convex/server",
    "convex/values"
  ]);
  function resolveNpmPackage(packageName) {
    if (packageName.startsWith(".") || packageName.startsWith("/") || packageName.startsWith("http://") || packageName.startsWith("https://") || packageName.startsWith("/__virtual__")) {
      return null;
    }
    if (EXPLICIT_MAPPINGS[packageName]) return EXPLICIT_MAPPINGS[packageName];
    if (LOCAL_PACKAGES.has(packageName)) return null;
    const basePkg = packageName.includes("/") ? packageName.split("/")[0] : packageName;
    const isScoped = basePkg.startsWith("@");
    const scopedBasePkg = isScoped && packageName.includes("/") ? packageName.split("/").slice(0, 2).join("/") : basePkg;
    if (LOCAL_PACKAGES.has(scopedBasePkg)) return null;
    return `https://esm.sh/${packageName}?external=react`;
  }
  function redirectNpmImports(code2) {
    try {
      return redirectNpmImportsAst(code2);
    } catch {
      return redirectNpmImportsRegex(code2);
    }
  }
  function redirectNpmImportsAst(code2) {
    const ast = parse3(code2, {
      ecmaVersion: "latest",
      sourceType: "module"
    });
    const replacements = [];
    function processSource(sourceNode) {
      if (!sourceNode || sourceNode.type !== "Literal") return;
      const resolved = resolveNpmPackage(sourceNode.value);
      if (resolved) {
        replacements.push([
          sourceNode.start,
          sourceNode.end,
          JSON.stringify(resolved)
        ]);
      }
    }
    for (const node2 of ast.body) {
      if (node2.type === "ImportDeclaration") {
        processSource(node2.source);
      } else if (node2.type === "ExportNamedDeclaration" && node2.source) {
        processSource(node2.source);
      } else if (node2.type === "ExportAllDeclaration") {
        processSource(node2.source);
      }
    }
    if (replacements.length === 0) return code2;
    let result = code2;
    replacements.sort((a, b) => b[0] - a[0]);
    for (const [start, end, replacement] of replacements) {
      result = result.slice(0, start) + replacement + result.slice(end);
    }
    return result;
  }
  function redirectNpmImportsRegex(code2) {
    const importPattern = /(from\s*['"])([^'"./][^'"]*?)(['"])/g;
    return code2.replace(importPattern, (match, prefix, packageName, suffix) => {
      const resolved = resolveNpmPackage(packageName);
      if (!resolved) return match;
      return `${prefix}${resolved}${suffix}`;
    });
  }
  function transformEsmToCjsSimple(code2) {
    try {
      return transformEsmToCjsAst(code2);
    } catch {
      return transformEsmToCjsRegex(code2);
    }
  }
  function transformEsmToCjsAst(code2) {
    const ast = parse3(code2, {
      ecmaVersion: "latest",
      sourceType: "module"
    });
    const replacements = [];
    for (const node2 of ast.body) {
      if (node2.type === "ImportDeclaration") {
        const source = node2.source.value;
        const specs = node2.specifiers;
        if (specs.length === 0) {
          replacements.push([
            node2.start,
            node2.end,
            `require(${JSON.stringify(source)})`
          ]);
        } else {
          const defaultSpec = specs.find((s) => s.type === "ImportDefaultSpecifier");
          const nsSpec = specs.find((s) => s.type === "ImportNamespaceSpecifier");
          const namedSpecs = specs.filter((s) => s.type === "ImportSpecifier");
          const parts = [];
          if (defaultSpec) {
            parts.push(`const ${defaultSpec.local.name} = require(${JSON.stringify(source)})`);
          }
          if (nsSpec) {
            parts.push(`const ${nsSpec.local.name} = require(${JSON.stringify(source)})`);
          }
          if (namedSpecs.length > 0) {
            const bindings = namedSpecs.map((s) => {
              if (s.imported.name === s.local.name) return s.local.name;
              return `${s.imported.name}: ${s.local.name}`;
            }).join(", ");
            if (defaultSpec) {
              parts.push(`const { ${bindings} } = require(${JSON.stringify(source)})`);
            } else {
              parts.push(`const { ${bindings} } = require(${JSON.stringify(source)})`);
            }
          }
          replacements.push([
            node2.start,
            node2.end,
            parts.join(";\n")
          ]);
        }
      } else if (node2.type === "ExportDefaultDeclaration") {
        const decl = node2.declaration;
        if (decl.type === "FunctionDeclaration") {
          const funcCode = code2.slice(decl.start, node2.end);
          replacements.push([
            node2.start,
            node2.end,
            `module.exports = ${funcCode}`
          ]);
        } else if (decl.type === "ClassDeclaration") {
          const classCode = code2.slice(decl.start, node2.end);
          replacements.push([
            node2.start,
            node2.end,
            `module.exports = ${classCode}`
          ]);
        } else {
          const exprCode = code2.slice(decl.start, node2.end);
          replacements.push([
            node2.start,
            node2.end,
            `module.exports = ${exprCode}`
          ]);
        }
      } else if (node2.type === "ExportNamedDeclaration") {
        if (node2.declaration) {
          const decl = node2.declaration;
          if (decl.type === "FunctionDeclaration") {
            const name2 = decl.id.name;
            const funcCode = code2.slice(decl.start, node2.end);
            replacements.push([
              node2.start,
              node2.end,
              `exports.${name2} = ${funcCode}`
            ]);
          } else if (decl.type === "ClassDeclaration") {
            const name2 = decl.id.name;
            const classCode = code2.slice(decl.start, node2.end);
            replacements.push([
              node2.start,
              node2.end,
              `exports.${name2} = ${classCode}`
            ]);
          } else if (decl.type === "VariableDeclaration") {
            const parts = [];
            for (const declarator of decl.declarations) {
              const name2 = declarator.id.name;
              const initCode = declarator.init ? code2.slice(declarator.init.start, declarator.init.end) : "undefined";
              parts.push(`exports.${name2} = ${initCode}`);
            }
            replacements.push([
              node2.start,
              node2.end,
              parts.join(";\n")
            ]);
          }
        } else if (node2.source) {
          const source = node2.source.value;
          const parts = [];
          const tmpVar = `__reexport_${node2.start}`;
          parts.push(`const ${tmpVar} = require(${JSON.stringify(source)})`);
          for (const spec2 of node2.specifiers) {
            parts.push(`exports.${spec2.exported.name} = ${tmpVar}.${spec2.local.name}`);
          }
          replacements.push([
            node2.start,
            node2.end,
            parts.join(";\n")
          ]);
        } else {
          const parts = [];
          for (const spec2 of node2.specifiers) {
            parts.push(`exports.${spec2.exported.name} = ${spec2.local.name}`);
          }
          replacements.push([
            node2.start,
            node2.end,
            parts.join(";\n")
          ]);
        }
      } else if (node2.type === "ExportAllDeclaration") {
        const source = node2.source.value;
        replacements.push([
          node2.start,
          node2.end,
          `Object.assign(exports, require(${JSON.stringify(source)}))`
        ]);
      }
    }
    let result = code2;
    replacements.sort((a, b) => b[0] - a[0]);
    for (const [start, end, replacement] of replacements) {
      result = result.slice(0, start) + replacement + result.slice(end);
    }
    return result;
  }
  function transformEsmToCjsRegex(code2) {
    let transformed = code2;
    transformed = transformed.replace(/import\s+(\w+)\s+from\s+['"]([^'"]+)['"]/g, 'const $1 = require("$2")');
    transformed = transformed.replace(/import\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"]/g, 'const {$1} = require("$2")');
    transformed = transformed.replace(/export\s+default\s+function\s+(\w+)/g, "module.exports = function $1");
    transformed = transformed.replace(/export\s+default\s+function\s*\(/g, "module.exports = function(");
    transformed = transformed.replace(/export\s+default\s+/g, "module.exports = ");
    transformed = transformed.replace(/export\s+async\s+function\s+(\w+)/g, "exports.$1 = async function $1");
    transformed = transformed.replace(/export\s+function\s+(\w+)/g, "exports.$1 = function $1");
    transformed = transformed.replace(/export\s+const\s+(\w+)\s*=/g, "exports.$1 =");
    return transformed;
  }
  function addReactRefresh(code2, filename2) {
    const components = detectReactComponents(code2);
    if (components.length === 0) {
      return `// HMR Setup
import.meta.hot = window.__vite_hot_context__("${filename2}");

${code2}

// HMR Accept
if (import.meta.hot) {
  import.meta.hot.accept();
}
`;
    }
    const registrations = components.map((name2) => `  $RefreshReg$(${name2}, "${filename2} ${name2}");`).join("\n");
    return `// HMR Setup
import.meta.hot = window.__vite_hot_context__("${filename2}");

${code2}

// React Refresh Registration
if (import.meta.hot) {
${registrations}
  import.meta.hot.accept(() => {
    if (window.$RefreshRuntime$) {
      window.$RefreshRuntime$.performReactRefresh();
    }
  });
}
`;
  }
  function isUppercaseStart(name2) {
    return name2.length > 0 && name2[0] >= "A" && name2[0] <= "Z";
  }
  function detectReactComponents(code2) {
    try {
      return detectReactComponentsAst(code2);
    } catch {
      return detectReactComponentsRegex(code2);
    }
  }
  function detectReactComponentsAst(code2) {
    var _a2, _b2, _c2, _d;
    const ast = parse3(code2, {
      ecmaVersion: "latest",
      sourceType: "module"
    });
    const components = [];
    for (const node2 of ast.body) {
      if (node2.type === "FunctionDeclaration" && node2.id && isUppercaseStart(node2.id.name)) {
        if (!components.includes(node2.id.name)) {
          components.push(node2.id.name);
        }
      }
      if (node2.type === "ExportDefaultDeclaration" && ((_a2 = node2.declaration) == null ? void 0 : _a2.type) === "FunctionDeclaration" && node2.declaration.id && isUppercaseStart(node2.declaration.id.name)) {
        if (!components.includes(node2.declaration.id.name)) {
          components.push(node2.declaration.id.name);
        }
      }
      if (node2.type === "ExportNamedDeclaration" && ((_b2 = node2.declaration) == null ? void 0 : _b2.type) === "FunctionDeclaration" && node2.declaration.id && isUppercaseStart(node2.declaration.id.name)) {
        if (!components.includes(node2.declaration.id.name)) {
          components.push(node2.declaration.id.name);
        }
      }
      const varDecl = node2.type === "VariableDeclaration" ? node2 : node2.type === "ExportNamedDeclaration" && ((_c2 = node2.declaration) == null ? void 0 : _c2.type) === "VariableDeclaration" ? node2.declaration : null;
      if (varDecl) {
        for (const declarator of varDecl.declarations) {
          if (((_d = declarator.id) == null ? void 0 : _d.name) && isUppercaseStart(declarator.id.name) && declarator.init) {
            const initType = declarator.init.type;
            if (initType === "ArrowFunctionExpression" || initType === "FunctionExpression" || initType === "CallExpression") {
              if (!components.includes(declarator.id.name)) {
                components.push(declarator.id.name);
              }
            }
          }
        }
      }
    }
    return components;
  }
  function detectReactComponentsRegex(code2) {
    const components = [];
    const funcDeclRegex = /(?:^|\n)(?:export\s+)?(?:async\s+)?function\s+([A-Z][a-zA-Z0-9]*)\s*\(/g;
    let match;
    while ((match = funcDeclRegex.exec(code2)) !== null) {
      if (!components.includes(match[1])) {
        components.push(match[1]);
      }
    }
    const arrowRegex = /(?:^|\n)(?:export\s+)?(?:const|let|var)\s+([A-Z][a-zA-Z0-9]*)\s*=/g;
    while ((match = arrowRegex.exec(code2)) !== null) {
      if (!components.includes(match[1])) {
        components.push(match[1]);
      }
    }
    return components;
  }
  const isBrowser$1 = typeof window !== "undefined" && typeof window.navigator !== "undefined" && "serviceWorker" in window.navigator;
  async function initEsbuild$1() {
    if (!isBrowser$1) return;
    if (window.__esbuild) {
      return;
    }
    if (window.__esbuildInitPromise) {
      return window.__esbuildInitPromise;
    }
    window.__esbuildInitPromise = (async () => {
      try {
        const mod = await import("https://esm.sh/esbuild-wasm@0.20.0").then(async (m) => {
          await m.__tla;
          return m;
        });
        const esbuildMod = mod.default || mod;
        try {
          await esbuildMod.initialize({
            wasmURL: "https://unpkg.com/esbuild-wasm@0.20.0/esbuild.wasm"
          });
          console.log("[ViteDevServer] esbuild-wasm initialized");
        } catch (initError) {
          if (initError instanceof Error && initError.message.includes('Cannot call "initialize" more than once')) {
            console.log("[ViteDevServer] esbuild-wasm already initialized, reusing");
          } else {
            throw initError;
          }
        }
        window.__esbuild = esbuildMod;
      } catch (error) {
        console.error("[ViteDevServer] Failed to initialize esbuild:", error);
        window.__esbuildInitPromise = void 0;
        throw error;
      }
    })();
    return window.__esbuildInitPromise;
  }
  function getEsbuild$1() {
    return isBrowser$1 ? window.__esbuild : void 0;
  }
  const REACT_REFRESH_PREAMBLE$1 = `
<script type="module">
// Block until React Refresh is loaded and initialized
// This MUST happen before React is imported
const RefreshRuntime = await import('https://esm.sh/react-refresh@0.14.0/runtime').then(m => m.default || m);

// Hook into React BEFORE it's loaded
RefreshRuntime.injectIntoGlobalHook(window);
window.$RefreshRuntime$ = RefreshRuntime;

// Track registrations for debugging
window.$RefreshRegCount$ = 0;

// Register function called by transformed modules
window.$RefreshReg$ = (type, id) => {
  window.$RefreshRegCount$++;
  RefreshRuntime.register(type, id);
};

// Signature function (simplified - always returns identity)
window.$RefreshSig$ = () => (type) => type;

console.log('[HMR] React Refresh initialized');
<\/script>
`;
  const HMR_CLIENT_SCRIPT$1 = `
<script type="module">
(function() {
  // Track hot modules and their callbacks
  const hotModules = new Map();
  const pendingUpdates = new Map();

  // Implement import.meta.hot API (Vite-compatible)
  window.__vite_hot_context__ = function createHotContext(ownerPath) {
    // Return existing context if already created
    if (hotModules.has(ownerPath)) {
      return hotModules.get(ownerPath);
    }

    const hot = {
      // Persisted data between updates
      data: {},

      // Accept self-updates
      accept(callback) {
        hot._acceptCallback = callback;
      },

      // Cleanup before update
      dispose(callback) {
        hot._disposeCallback = callback;
      },

      // Force full reload
      invalidate() {
        location.reload();
      },

      // Prune callback (called when module is no longer imported)
      prune(callback) {
        hot._pruneCallback = callback;
      },

      // Event handlers (not implemented)
      on(event, cb) {},
      off(event, cb) {},
      send(event, data) {},

      // Internal callbacks
      _acceptCallback: null,
      _disposeCallback: null,
      _pruneCallback: null,
    };

    hotModules.set(ownerPath, hot);
    return hot;
  };

  // Listen for HMR updates via postMessage (works with sandboxed iframes)
  window.addEventListener('message', async (event) => {
    // Filter for HMR messages only
    if (!event.data || event.data.channel !== 'vite-hmr') return;
    const { type, path, timestamp } = event.data;

    if (type === 'update') {
      console.log('[HMR] Update:', path);

      if (path.endsWith('.css')) {
        // CSS hot reload - update stylesheet href
        const links = document.querySelectorAll('link[rel="stylesheet"]');
        links.forEach(link => {
          const href = link.getAttribute('href');
          if (href && href.includes(path.replace(/^\\//, ''))) {
            link.href = href.split('?')[0] + '?t=' + timestamp;
          }
        });

        // Also update any injected style tags
        const styles = document.querySelectorAll('style[data-vite-dev-id]');
        styles.forEach(style => {
          const id = style.getAttribute('data-vite-dev-id');
          if (id && id.includes(path.replace(/^\\//, ''))) {
            // Re-import the CSS module to get updated styles
            import(path + '?t=' + timestamp).catch(() => {});
          }
        });
      } else if (path.match(/\\.(jsx?|tsx?)$/)) {
        // JS/JSX hot reload with React Refresh
        await handleJSUpdate(path, timestamp);
      }
    } else if (type === 'full-reload') {
      console.log('[HMR] Full reload');
      location.reload();
    }
  });

  // Handle JS/JSX module updates
  async function handleJSUpdate(path, timestamp) {
    // Normalize path to match module keys
    const normalizedPath = path.startsWith('/') ? path : '/' + path;
    const hot = hotModules.get(normalizedPath);

    try {
      // Call dispose callback if registered
      if (hot && hot._disposeCallback) {
        hot._disposeCallback(hot.data);
      }

      // Enqueue React Refresh (batches multiple updates)
      if (window.$RefreshRuntime$) {
        pendingUpdates.set(normalizedPath, timestamp);

        // Schedule refresh after a short delay to batch updates
        if (pendingUpdates.size === 1) {
          setTimeout(async () => {
            try {
              // Re-import all pending modules
              for (const [modulePath, ts] of pendingUpdates) {
                const moduleUrl = '.' + modulePath + '?t=' + ts;
                await import(moduleUrl);
              }

              // Perform React Refresh
              window.$RefreshRuntime$.performReactRefresh();
              console.log('[HMR] Updated', pendingUpdates.size, 'module(s)');

              pendingUpdates.clear();
            } catch (error) {
              console.error('[HMR] Failed to apply update:', error);
              pendingUpdates.clear();
              location.reload();
            }
          }, 30);
        }
      } else {
        // No React Refresh available, fall back to page reload
        console.log('[HMR] React Refresh not available, reloading page');
        location.reload();
      }
    } catch (error) {
      console.error('[HMR] Update failed:', error);
      location.reload();
    }
  }

  console.log('[HMR] Client ready with React Refresh support');
})();
<\/script>
`;
  ViteDevServer = class extends DevServer {
    constructor(vfs2, options2) {
      super(vfs2, options2);
      __publicField(this, "watcherCleanup", null);
      __publicField(this, "options");
      __publicField(this, "hmrTargetWindow", null);
      __publicField(this, "transformCache", /* @__PURE__ */ new Map());
      this.options = {
        jsx: true,
        jsxFactory: "React.createElement",
        jsxFragment: "React.Fragment",
        jsxAutoImport: true,
        ...options2
      };
    }
    setHMRTarget(targetWindow) {
      this.hmrTargetWindow = targetWindow;
    }
    async handleRequest(method, url2, headers, body) {
      const urlObj = new URL(url2, "http://localhost");
      let pathname = urlObj.pathname;
      if (pathname === "/") {
        pathname = "/index.html";
      }
      const filePath = this.resolvePath(pathname);
      if (!this.exists(filePath)) {
        if (this.exists(filePath + ".html")) {
          return this.serveFile(filePath + ".html");
        }
        if (this.isDirectory(filePath) && this.exists(filePath + "/index.html")) {
          return this.serveFile(filePath + "/index.html");
        }
        return this.notFound(pathname);
      }
      if (this.isDirectory(filePath)) {
        if (this.exists(filePath + "/index.html")) {
          return this.serveFile(filePath + "/index.html");
        }
        return this.notFound(pathname);
      }
      if (this.needsTransform(pathname)) {
        return this.transformAndServe(filePath, pathname);
      }
      if (pathname.endsWith(".css")) {
        const secFetchDest = headers["sec-fetch-dest"] || headers["Sec-Fetch-Dest"] || headers["SEC-FETCH-DEST"] || "";
        const isModuleImport = secFetchDest === "script" || secFetchDest === "empty" || isBrowser$1 && secFetchDest === "";
        if (isModuleImport) {
          return this.serveCssAsModule(filePath);
        }
        return this.serveFile(filePath);
      }
      if (pathname.endsWith(".html")) {
        return this.serveHtmlWithHMR(filePath);
      }
      return this.serveFile(filePath);
    }
    startWatching() {
      const srcPath = this.root === "/" ? "/src" : `${this.root}/src`;
      try {
        const watcher = this.vfs.watch(srcPath, {
          recursive: true
        }, (eventType, filename2) => {
          if (eventType === "change" && filename2) {
            const fullPath = filename2.startsWith("/") ? filename2 : `${srcPath}/${filename2}`;
            this.handleFileChange(fullPath);
          }
        });
        this.watcherCleanup = () => {
          watcher.close();
        };
      } catch (error) {
        console.warn("[ViteDevServer] Could not watch /src directory:", error);
      }
      try {
        const rootWatcher = this.vfs.watch(this.root, {
          recursive: false
        }, (eventType, filename2) => {
          if (eventType === "change" && filename2 && filename2.endsWith(".css")) {
            this.handleFileChange(`${this.root}/${filename2}`);
          }
        });
        const originalCleanup = this.watcherCleanup;
        this.watcherCleanup = () => {
          originalCleanup == null ? void 0 : originalCleanup();
          rootWatcher.close();
        };
      } catch {
      }
    }
    handleFileChange(path2) {
      const isCSS = path2.endsWith(".css");
      const isJS = /\.(jsx?|tsx?)$/.test(path2);
      const updateType = isCSS || isJS ? "update" : "full-reload";
      const update = {
        type: updateType,
        path: path2,
        timestamp: Date.now()
      };
      this.emitHMRUpdate(update);
      if (this.hmrTargetWindow) {
        try {
          this.hmrTargetWindow.postMessage({
            ...update,
            channel: "vite-hmr"
          }, "*");
        } catch (e) {
        }
      }
    }
    stop() {
      if (this.watcherCleanup) {
        this.watcherCleanup();
        this.watcherCleanup = null;
      }
      this.hmrTargetWindow = null;
      super.stop();
    }
    needsTransform(path2) {
      return /\.(jsx|tsx|ts)$/.test(path2);
    }
    async transformAndServe(filePath, urlPath) {
      try {
        const content = this.vfs.readFileSync(filePath, "utf8");
        const hash = simpleHash(content);
        const cached = this.transformCache.get(filePath);
        if (cached && cached.hash === hash) {
          const buffer22 = BufferPolyfill.from(cached.code);
          return {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
              "Content-Type": "application/javascript; charset=utf-8",
              "Content-Length": String(buffer22.length),
              "Cache-Control": "no-cache",
              "X-Transformed": "true",
              "X-Cache": "hit"
            },
            body: buffer22
          };
        }
        const transformed = await this.transformCode(content, urlPath);
        this.transformCache.set(filePath, {
          code: transformed,
          hash
        });
        const buffer2 = BufferPolyfill.from(transformed);
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "application/javascript; charset=utf-8",
            "Content-Length": String(buffer2.length),
            "Cache-Control": "no-cache",
            "X-Transformed": "true"
          },
          body: buffer2
        };
      } catch (error) {
        console.error("[ViteDevServer] Transform error:", error);
        const message = error instanceof Error ? error.message : "Transform failed";
        const body = `// Transform Error: ${message}
console.error(${JSON.stringify(message)});`;
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "application/javascript; charset=utf-8",
            "X-Transform-Error": "true"
          },
          body: BufferPolyfill.from(body)
        };
      }
    }
    async transformCode(code2, filename2) {
      if (!isBrowser$1) {
        return code2;
      }
      await initEsbuild$1();
      const esbuild2 = getEsbuild$1();
      if (!esbuild2) {
        throw new Error("esbuild not available");
      }
      let loader = "js";
      if (filename2.endsWith(".jsx")) loader = "jsx";
      else if (filename2.endsWith(".tsx")) loader = "tsx";
      else if (filename2.endsWith(".ts")) loader = "ts";
      const result = await esbuild2.transform(code2, {
        loader,
        format: "esm",
        target: "esnext",
        jsx: "automatic",
        jsxImportSource: "react",
        sourcemap: "inline",
        sourcefile: filename2
      });
      if (/\.(jsx|tsx)$/.test(filename2)) {
        return this.addReactRefresh(result.code, filename2);
      }
      return result.code;
    }
    addReactRefresh(code2, filename2) {
      return addReactRefresh(code2, filename2);
    }
    serveCssAsModule(filePath) {
      try {
        const css = this.vfs.readFileSync(filePath, "utf8");
        const js = `
// CSS Module: ${filePath}
const css = ${JSON.stringify(css)};
const style = document.createElement('style');
style.setAttribute('data-vite-dev-id', ${JSON.stringify(filePath)});
style.textContent = css;
document.head.appendChild(style);
export default css;
`;
        const buffer2 = BufferPolyfill.from(js);
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "application/javascript; charset=utf-8",
            "Content-Length": String(buffer2.length),
            "Cache-Control": "no-cache"
          },
          body: buffer2
        };
      } catch (error) {
        return this.serverError(error);
      }
    }
    serveHtmlWithHMR(filePath) {
      try {
        let content = this.vfs.readFileSync(filePath, "utf8");
        if (content.includes("<head>")) {
          content = content.replace("<head>", `<head>${REACT_REFRESH_PREAMBLE$1}`);
        } else if (content.includes("<html")) {
          content = content.replace(/<html[^>]*>/, `$&${REACT_REFRESH_PREAMBLE$1}`);
        } else {
          content = REACT_REFRESH_PREAMBLE$1 + content;
        }
        if (content.includes("</head>")) {
          content = content.replace("</head>", `${HMR_CLIENT_SCRIPT$1}</head>`);
        } else if (content.includes("</body>")) {
          content = content.replace("</body>", `${HMR_CLIENT_SCRIPT$1}</body>`);
        } else {
          content += HMR_CLIENT_SCRIPT$1;
        }
        const buffer2 = BufferPolyfill.from(content);
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "text/html; charset=utf-8",
            "Content-Length": String(buffer2.length),
            "Cache-Control": "no-cache"
          },
          body: buffer2
        };
      } catch (error) {
        return this.serverError(error);
      }
    }
  };
  const CONFIG_FILE_NAMES = [
    "/tailwind.config.ts",
    "/tailwind.config.js",
    "/tailwind.config.mjs"
  ];
  async function loadTailwindConfig(vfs2, root = "/") {
    let configPath = null;
    let configContent = null;
    for (const fileName of CONFIG_FILE_NAMES) {
      const fullPath = root === "/" ? fileName : `${root}${fileName}`;
      try {
        const content = vfs2.readFileSync(fullPath);
        configContent = typeof content === "string" ? content : content instanceof Uint8Array ? new TextDecoder("utf-8").decode(content) : Buffer.from(content).toString("utf-8");
        configPath = fullPath;
        break;
      } catch {
        continue;
      }
    }
    if (!configPath || configContent === null) {
      return {
        configScript: "",
        success: true
      };
    }
    try {
      const jsConfig = stripTypescriptSyntax(configContent);
      const configObject = extractConfigObject(jsConfig);
      if (!configObject) {
        return {
          configScript: "",
          success: false,
          error: "Could not extract config object from tailwind.config"
        };
      }
      const configScript = generateConfigScript(configObject);
      return {
        configScript,
        success: true
      };
    } catch (error) {
      return {
        configScript: "",
        success: false,
        error: `Failed to parse tailwind.config: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  function stripTypescriptSyntax(content) {
    let result = content;
    result = result.replace(/import\s+type\s+\{[^}]*\}\s+from\s+['"][^'"]*['"]\s*;?\s*/g, "");
    result = result.replace(/import\s+\{[^}]*\}\s+from\s+['"][^'"]*['"]\s*;?\s*/g, "");
    result = result.replace(/\s+satisfies\s+\w+\s*$/gm, "");
    result = result.replace(/\s+satisfies\s+\w+\s*;?\s*$/gm, "");
    result = result.replace(/:\s*[A-Z]\w*\s*=/g, " =");
    result = result.replace(/\s+as\s+const\s*/g, " ");
    return result;
  }
  function extractConfigObject(content) {
    const exportDefaultMatch = content.match(/export\s+default\s*/);
    if (!exportDefaultMatch || exportDefaultMatch.index === void 0) {
      return null;
    }
    const startIndex = exportDefaultMatch.index + exportDefaultMatch[0].length;
    const remaining = content.substring(startIndex);
    const trimmedRemaining = remaining.trimStart();
    if (!trimmedRemaining.startsWith("{")) {
      return null;
    }
    const objectStart = startIndex + (remaining.length - trimmedRemaining.length);
    const objectContent = content.substring(objectStart);
    let braceCount = 0;
    let inString = false;
    let stringChar = "";
    let escaped = false;
    let endIndex = -1;
    for (let i2 = 0; i2 < objectContent.length; i2++) {
      const char = objectContent[i2];
      if (escaped) {
        escaped = false;
        continue;
      }
      if (char === "\\") {
        escaped = true;
        continue;
      }
      if (inString) {
        if (char === stringChar) {
          inString = false;
        }
        continue;
      }
      if (char === '"' || char === "'" || char === "`") {
        inString = true;
        stringChar = char;
        continue;
      }
      if (char === "{") {
        braceCount++;
      } else if (char === "}") {
        braceCount--;
        if (braceCount === 0) {
          endIndex = i2 + 1;
          break;
        }
      }
    }
    if (endIndex === -1) {
      return null;
    }
    return objectContent.substring(0, endIndex);
  }
  function generateConfigScript(configObject) {
    return `<script>
  tailwind.config = ${configObject};
<\/script>`;
  }
  function parseNextConfigValue(content, key, isTypeScript = false) {
    const processed = isTypeScript ? stripTypescriptSyntax(content) : content;
    try {
      return parseNextConfigValueAst(processed, key);
    } catch {
      return parseNextConfigValueRegex(processed, key);
    }
  }
  function parseNextConfigValueAst(content, key) {
    var _a2, _b2, _c2;
    const ast = parse3(content, {
      ecmaVersion: "latest",
      sourceType: "module"
    });
    const variables = /* @__PURE__ */ new Map();
    for (const node2 of ast.body) {
      if (node2.type === "VariableDeclaration") {
        for (const decl of node2.declarations) {
          if (((_a2 = decl.id) == null ? void 0 : _a2.name) && decl.init) {
            variables.set(decl.id.name, decl.init);
          }
        }
      }
    }
    let configObject = null;
    for (const node2 of ast.body) {
      if (node2.type === "ExportDefaultDeclaration") {
        configObject = resolveToObject(node2.declaration, variables);
        if (configObject) break;
      }
      if (node2.type === "ExpressionStatement" && node2.expression.type === "AssignmentExpression" && node2.expression.left.type === "MemberExpression" && ((_b2 = node2.expression.left.object) == null ? void 0 : _b2.name) === "module" && ((_c2 = node2.expression.left.property) == null ? void 0 : _c2.name) === "exports") {
        configObject = resolveToObject(node2.expression.right, variables);
        if (configObject) break;
      }
    }
    if (!configObject || configObject.type !== "ObjectExpression") {
      return null;
    }
    for (const prop of configObject.properties) {
      if (prop.type !== "Property") continue;
      const propName = prop.key.type === "Identifier" ? prop.key.name : prop.key.type === "Literal" ? String(prop.key.value) : null;
      if (propName !== key) continue;
      return resolveToString(prop.value, variables);
    }
    return null;
  }
  function resolveToObject(node2, variables) {
    if (!node2) return null;
    if (node2.type === "ObjectExpression") return node2;
    if (node2.type === "Identifier") {
      const init2 = variables.get(node2.name);
      return init2 ? resolveToObject(init2, variables) : null;
    }
    if (node2.type === "CallExpression" && node2.arguments.length > 0) {
      return resolveToObject(node2.arguments[0], variables);
    }
    return null;
  }
  function resolveToString(node2, variables) {
    var _a2, _b2;
    if (!node2) return null;
    if (node2.type === "Literal" && typeof node2.value === "string") {
      return node2.value;
    }
    if (node2.type === "TemplateLiteral" && node2.expressions.length === 0) {
      return ((_b2 = (_a2 = node2.quasis[0]) == null ? void 0 : _a2.value) == null ? void 0 : _b2.cooked) ?? null;
    }
    if (node2.type === "Identifier") {
      const init2 = variables.get(node2.name);
      return init2 ? resolveToString(init2, variables) : null;
    }
    return null;
  }
  function parseNextConfigValueRegex(content, key) {
    const regex = new RegExp(`${key}\\s*:\\s*["'\`]([^"'\`]+)["'\`]`);
    const match = content.match(regex);
    return match ? match[1] : null;
  }
  const TAILWIND_CDN_SCRIPT = `<script src="https://cdn.tailwindcss.com"><\/script>`;
  const CORS_PROXY_SCRIPT = `
<script>
  // CORS Proxy support for external API calls
  window.__getCorsProxy = function() {
    return localStorage.getItem('__corsProxyUrl') || null;
  };

  window.__setCorsProxy = function(url) {
    if (url) {
      localStorage.setItem('__corsProxyUrl', url);
    } else {
      localStorage.removeItem('__corsProxyUrl');
    }
  };

  window.__proxyFetch = async function(url, options) {
    const proxyUrl = window.__getCorsProxy();
    if (proxyUrl) {
      const proxiedUrl = proxyUrl + encodeURIComponent(url);
      return fetch(proxiedUrl, options);
    }
    return fetch(url, options);
  };
<\/script>
`;
  const REACT_REFRESH_PREAMBLE = `
<script type="module">
// Block until React Refresh is loaded and initialized
const RefreshRuntime = await import('https://esm.sh/react-refresh@0.14.0/runtime').then(m => m.default || m);

RefreshRuntime.injectIntoGlobalHook(window);
window.$RefreshRuntime$ = RefreshRuntime;
window.$RefreshRegCount$ = 0;

window.$RefreshReg$ = (type, id) => {
  window.$RefreshRegCount$++;
  RefreshRuntime.register(type, id);
};

window.$RefreshSig$ = () => (type) => type;

console.log('[HMR] React Refresh initialized');
<\/script>
`;
  const HMR_CLIENT_SCRIPT = `
<script type="module">
(function() {
  const hotModules = new Map();
  const pendingUpdates = new Map();

  window.__vite_hot_context__ = function createHotContext(ownerPath) {
    if (hotModules.has(ownerPath)) {
      return hotModules.get(ownerPath);
    }

    const hot = {
      data: {},
      accept(callback) {
        hot._acceptCallback = callback;
      },
      dispose(callback) {
        hot._disposeCallback = callback;
      },
      invalidate() {
        location.reload();
      },
      prune(callback) {
        hot._pruneCallback = callback;
      },
      on(event, cb) {},
      off(event, cb) {},
      send(event, data) {},
      _acceptCallback: null,
      _disposeCallback: null,
      _pruneCallback: null,
    };

    hotModules.set(ownerPath, hot);
    return hot;
  };

  // Listen for HMR updates via postMessage (works with sandboxed iframes)
  window.addEventListener('message', async (event) => {
    // Filter for HMR messages only
    if (!event.data || event.data.channel !== 'next-hmr') return;
    const { type, path, timestamp } = event.data;

    if (type === 'update') {
      console.log('[HMR] Update:', path);

      if (path.endsWith('.css')) {
        const links = document.querySelectorAll('link[rel="stylesheet"]');
        links.forEach(link => {
          const href = link.getAttribute('href');
          if (href && href.includes(path.replace(/^\\//, ''))) {
            link.href = href.split('?')[0] + '?t=' + timestamp;
          }
        });

        const styles = document.querySelectorAll('style[data-next-dev-id]');
        styles.forEach(style => {
          const id = style.getAttribute('data-next-dev-id');
          if (id && id.includes(path.replace(/^\\//, ''))) {
            import(path + '?t=' + timestamp).catch(() => {});
          }
        });
      } else if (path.match(/\\.(jsx?|tsx?)$/)) {
        await handleJSUpdate(path, timestamp);
      }
    } else if (type === 'full-reload') {
      console.log('[HMR] Full reload');
      location.reload();
    }
  });

  async function handleJSUpdate(path, timestamp) {
    const normalizedPath = path.startsWith('/') ? path : '/' + path;
    const hot = hotModules.get(normalizedPath);

    try {
      if (hot && hot._disposeCallback) {
        hot._disposeCallback(hot.data);
      }

      if (window.$RefreshRuntime$) {
        pendingUpdates.set(normalizedPath, timestamp);

        if (pendingUpdates.size === 1) {
          setTimeout(async () => {
            try {
              for (const [modulePath, ts] of pendingUpdates) {
                const moduleUrl = '.' + modulePath + '?t=' + ts;
                await import(moduleUrl);
              }

              window.$RefreshRuntime$.performReactRefresh();
              console.log('[HMR] Updated', pendingUpdates.size, 'module(s)');

              pendingUpdates.clear();
            } catch (error) {
              console.error('[HMR] Failed to apply update:', error);
              pendingUpdates.clear();
              location.reload();
            }
          }, 30);
        }
      } else {
        console.log('[HMR] React Refresh not available, reloading page');
        location.reload();
      }
    } catch (error) {
      console.error('[HMR] Update failed:', error);
      location.reload();
    }
  }

  console.log('[HMR] Next.js client ready');
})();
<\/script>
`;
  const NEXT_LINK_SHIM = `
import React from 'react';

const getVirtualBasePath = () => {
  const match = window.location.pathname.match(/^\\/__virtual__\\/\\d+(?:\\/|$)/);
  if (!match) return '';
  return match[0].endsWith('/') ? match[0] : match[0] + '/';
};

const getBasePath = () => window.__NEXT_BASE_PATH__ || '';

const applyVirtualBase = (url) => {
  if (typeof url !== 'string') return url;
  if (!url || url.startsWith('#') || url.startsWith('?')) return url;
  if (/^(https?:)?\\/\\//.test(url)) return url;

  // Apply basePath first
  const bp = getBasePath();
  if (bp && url.startsWith('/') && !url.startsWith(bp + '/') && url !== bp) {
    url = bp + url;
  }

  const base = getVirtualBasePath();
  if (!base) return url;
  if (url.startsWith(base)) return url;
  if (url.startsWith('/')) return base + url.slice(1);
  return base + url;
};

export default function Link({ href, children, ...props }) {
  const handleClick = (e) => {
    console.log('[Link] Click handler called, href:', href);

    if (props.onClick) {
      props.onClick(e);
    }

    // Allow cmd/ctrl click to open in new tab
    if (e.metaKey || e.ctrlKey) {
      console.log('[Link] Meta/Ctrl key pressed, allowing default behavior');
      return;
    }

    if (typeof href !== 'string' || !href || href.startsWith('#') || href.startsWith('?')) {
      console.log('[Link] Skipping navigation for href:', href);
      return;
    }

    if (/^(https?:)?\\/\\//.test(href)) {
      console.log('[Link] External URL, allowing default behavior:', href);
      return;
    }

    e.preventDefault();
    const resolvedHref = applyVirtualBase(href);
    console.log('[Link] Navigating to:', resolvedHref);
    window.history.pushState({}, '', resolvedHref);
    window.dispatchEvent(new PopStateEvent('popstate'));
  };

  return React.createElement('a', { href, onClick: handleClick, ...props }, children);
}

export { Link };
`;
  const NEXT_ROUTER_SHIM = `
import React, { useState, useEffect, createContext, useContext } from 'react';

const RouterContext = createContext(null);

const getVirtualBasePath = () => {
  const match = window.location.pathname.match(/^\\/__virtual__\\/\\d+(?:\\/|$)/);
  if (!match) return '';
  return match[0].endsWith('/') ? match[0] : match[0] + '/';
};

const applyVirtualBase = (url) => {
  if (typeof url !== 'string') return url;
  if (!url || url.startsWith('#') || url.startsWith('?')) return url;
  if (/^(https?:)?\\/\\//.test(url)) return url;

  const base = getVirtualBasePath();
  if (!base) return url;
  if (url.startsWith(base)) return url;
  if (url.startsWith('/')) return base + url.slice(1);
  return base + url;
};

const stripVirtualBase = (pathname) => {
  const match = pathname.match(/^\\/__virtual__\\/\\d+(?:\\/|$)/);
  if (!match) return pathname;
  return '/' + pathname.slice(match[0].length);
};

export function useRouter() {
  const [pathname, setPathname] = useState(
    typeof window !== 'undefined' ? stripVirtualBase(window.location.pathname) : '/'
  );
  const [query, setQuery] = useState({});

  useEffect(() => {
    const updateRoute = () => {
      setPathname(stripVirtualBase(window.location.pathname));
      setQuery(Object.fromEntries(new URLSearchParams(window.location.search)));
    };

    window.addEventListener('popstate', updateRoute);
    updateRoute();

    return () => window.removeEventListener('popstate', updateRoute);
  }, []);

  return {
    pathname,
    query,
    asPath: pathname + window.location.search,
    push: (url, as, options) => {
      if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
        window.location.href = url;
        return Promise.resolve(true);
      }
      const resolvedUrl = applyVirtualBase(url);
      window.history.pushState({}, '', resolvedUrl);
      window.dispatchEvent(new PopStateEvent('popstate'));
      return Promise.resolve(true);
    },
    replace: (url, as, options) => {
      if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
        window.location.href = url;
        return Promise.resolve(true);
      }
      const resolvedUrl = applyVirtualBase(url);
      window.history.replaceState({}, '', resolvedUrl);
      window.dispatchEvent(new PopStateEvent('popstate'));
      return Promise.resolve(true);
    },
    prefetch: () => Promise.resolve(),
    back: () => window.history.back(),
    forward: () => window.history.forward(),
    reload: () => window.location.reload(),
    events: {
      on: () => {},
      off: () => {},
      emit: () => {},
    },
    isFallback: false,
    isReady: true,
    isPreview: false,
  };
}

export const Router = {
  events: {
    on: () => {},
    off: () => {},
    emit: () => {},
  },
  push: (url) => {
    if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
      window.location.href = url;
      return Promise.resolve(true);
    }
    const resolvedUrl = applyVirtualBase(url);
    window.history.pushState({}, '', resolvedUrl);
    window.dispatchEvent(new PopStateEvent('popstate'));
    return Promise.resolve(true);
  },
  replace: (url) => {
    if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
      window.location.href = url;
      return Promise.resolve(true);
    }
    const resolvedUrl = applyVirtualBase(url);
    window.history.replaceState({}, '', resolvedUrl);
    window.dispatchEvent(new PopStateEvent('popstate'));
    return Promise.resolve(true);
  },
};

export default { useRouter, Router };
`;
  const NEXT_NAVIGATION_SHIM = `
import React, { useState, useEffect, useCallback, useMemo } from 'react';

const getVirtualBasePath = () => {
  const match = window.location.pathname.match(/^\\/__virtual__\\/\\d+(?:\\/|$)/);
  if (!match) return '';
  return match[0].endsWith('/') ? match[0] : match[0] + '/';
};

const applyVirtualBase = (url) => {
  if (typeof url !== 'string') return url;
  if (!url || url.startsWith('#') || url.startsWith('?')) return url;
  if (/^(https?:)?\\/\\//.test(url)) return url;

  const base = getVirtualBasePath();
  if (!base) return url;
  if (url.startsWith(base)) return url;
  if (url.startsWith('/')) return base + url.slice(1);
  return base + url;
};

const stripVirtualBase = (pathname) => {
  const match = pathname.match(/^\\/__virtual__\\/\\d+(?:\\/|$)/);
  if (!match) return pathname;
  return '/' + pathname.slice(match[0].length);
};

/**
 * App Router's useRouter hook
 * Returns navigation methods only (no pathname, no query)
 * Use usePathname() and useSearchParams() for URL info
 */
export function useRouter() {
  const push = useCallback((url, options) => {
    if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
      window.location.href = url;
      return;
    }
    const resolvedUrl = applyVirtualBase(url);
    window.history.pushState({}, '', resolvedUrl);
    window.dispatchEvent(new PopStateEvent('popstate'));
  }, []);

  const replace = useCallback((url, options) => {
    if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
      window.location.href = url;
      return;
    }
    const resolvedUrl = applyVirtualBase(url);
    window.history.replaceState({}, '', resolvedUrl);
    window.dispatchEvent(new PopStateEvent('popstate'));
  }, []);

  const back = useCallback(() => window.history.back(), []);
  const forward = useCallback(() => window.history.forward(), []);
  const refresh = useCallback(() => window.location.reload(), []);
  const prefetch = useCallback(() => Promise.resolve(), []);

  return useMemo(() => ({
    push,
    replace,
    back,
    forward,
    refresh,
    prefetch,
  }), [push, replace, back, forward, refresh, prefetch]);
}

/**
 * usePathname - Returns the current URL pathname
 * Reactively updates when navigation occurs
 * @example const pathname = usePathname(); // '/dashboard/settings'
 */
export function usePathname() {
  const [pathname, setPathname] = useState(
    typeof window !== 'undefined' ? stripVirtualBase(window.location.pathname) : '/'
  );

  useEffect(() => {
    const handler = () => setPathname(stripVirtualBase(window.location.pathname));
    window.addEventListener('popstate', handler);
    return () => window.removeEventListener('popstate', handler);
  }, []);

  return pathname;
}

/**
 * useSearchParams - Returns the current URL search parameters
 * @example const searchParams = useSearchParams();
 *          const query = searchParams.get('q'); // '?q=hello' -> 'hello'
 */
export function useSearchParams() {
  const [searchParams, setSearchParams] = useState(() => {
    if (typeof window === 'undefined') return new URLSearchParams();
    return new URLSearchParams(window.location.search);
  });

  useEffect(() => {
    const handler = () => {
      setSearchParams(new URLSearchParams(window.location.search));
    };
    window.addEventListener('popstate', handler);
    return () => window.removeEventListener('popstate', handler);
  }, []);

  return searchParams;
}

/**
 * useParams - Returns dynamic route parameters
 * For route /users/[id]/page.jsx with URL /users/123:
 * @example const { id } = useParams(); // { id: '123' }
 *
 * Fetches params from the server's route-info endpoint for dynamic routes.
 */
export function useParams() {
  const [params, setParams] = useState(() => {
    // Check if initial params were embedded by the server
    if (typeof window !== 'undefined' && window.__NEXT_ROUTE_PARAMS__) {
      return window.__NEXT_ROUTE_PARAMS__;
    }
    return {};
  });

  useEffect(() => {
    let cancelled = false;

    const fetchParams = async () => {
      const pathname = stripVirtualBase(window.location.pathname);
      const base = getVirtualBasePath();
      const baseUrl = base ? base.replace(/\\/$/, '') : '';

      try {
        const response = await fetch(baseUrl + '/_next/route-info?pathname=' + encodeURIComponent(pathname));
        const info = await response.json();
        if (!cancelled && info.params) {
          setParams(info.params);
        }
      } catch (e) {
        // Silently fail - static routes won't have params
      }
    };

    fetchParams();

    const handler = () => fetchParams();
    window.addEventListener('popstate', handler);
    return () => {
      cancelled = true;
      window.removeEventListener('popstate', handler);
    };
  }, []);

  return params;
}

/**
 * useSelectedLayoutSegment - Returns the active child segment one level below
 * Useful for styling active nav items in layouts
 * @example For /dashboard/settings, returns 'settings' in dashboard layout
 */
export function useSelectedLayoutSegment() {
  const pathname = usePathname();
  const segments = pathname.split('/').filter(Boolean);
  return segments[0] || null;
}

/**
 * useSelectedLayoutSegments - Returns all active child segments
 * @example For /dashboard/settings/profile, returns ['dashboard', 'settings', 'profile']
 */
export function useSelectedLayoutSegments() {
  const pathname = usePathname();
  return pathname.split('/').filter(Boolean);
}

/**
 * redirect - Programmatic redirect (typically used in Server Components)
 * In this browser implementation, performs immediate navigation
 */
export function redirect(url) {
  if (typeof url === 'string' && /^(https?:)?\\/\\//.test(url)) {
    window.location.href = url;
    return;
  }
  window.location.href = applyVirtualBase(url);
}

/**
 * notFound - Trigger the not-found UI
 * In this browser implementation, throws an error
 */
export function notFound() {
  throw new Error('NEXT_NOT_FOUND');
}

// Re-export Link for convenience (can import from next/navigation or next/link)
export { default as Link } from 'next/link';
`;
  const NEXT_HEAD_SHIM = `
import React, { useEffect } from 'react';

export default function Head({ children }) {
  useEffect(() => {
    // Process children and update document.head
    React.Children.forEach(children, (child) => {
      if (!React.isValidElement(child)) return;

      const { type, props } = child;

      if (type === 'title' && props.children) {
        document.title = Array.isArray(props.children)
          ? props.children.join('')
          : props.children;
      } else if (type === 'meta') {
        const existingMeta = props.name
          ? document.querySelector(\`meta[name="\${props.name}"]\`)
          : props.property
            ? document.querySelector(\`meta[property="\${props.property}"]\`)
            : null;

        if (existingMeta) {
          Object.keys(props).forEach(key => {
            existingMeta.setAttribute(key, props[key]);
          });
        } else {
          const meta = document.createElement('meta');
          Object.keys(props).forEach(key => {
            meta.setAttribute(key, props[key]);
          });
          document.head.appendChild(meta);
        }
      } else if (type === 'link') {
        const link = document.createElement('link');
        Object.keys(props).forEach(key => {
          link.setAttribute(key, props[key]);
        });
        document.head.appendChild(link);
      }
    });
  }, [children]);

  return null;
}
`;
  const NEXT_IMAGE_SHIM = `
import React from 'react';

function Image({
  src,
  alt = '',
  width,
  height,
  fill,
  loader,
  quality = 75,
  priority,
  loading,
  placeholder,
  blurDataURL,
  unoptimized,
  onLoad,
  onError,
  style,
  className,
  sizes,
  ...rest
}) {
  // Handle src - could be string or StaticImageData object
  const imageSrc = typeof src === 'object' ? src.src : src;

  // Build style object
  const imgStyle = { ...style };
  if (fill) {
    imgStyle.position = 'absolute';
    imgStyle.width = '100%';
    imgStyle.height = '100%';
    imgStyle.objectFit = imgStyle.objectFit || 'cover';
    imgStyle.inset = '0';
  }

  return React.createElement('img', {
    src: imageSrc,
    alt,
    width: fill ? undefined : width,
    height: fill ? undefined : height,
    loading: priority ? 'eager' : (loading || 'lazy'),
    decoding: 'async',
    style: imgStyle,
    className,
    onLoad,
    onError,
    ...rest
  });
}

export default Image;
export { Image };
`;
  const NEXT_DYNAMIC_SHIM = `
import React from 'react';

function dynamic(importFn, options = {}) {
  const {
    loading: LoadingComponent,
    ssr = true,
  } = options;

  // Create a lazy component
  const LazyComponent = React.lazy(importFn);

  // Wrapper component that handles loading state
  function DynamicComponent(props) {
    const fallback = LoadingComponent
      ? React.createElement(LoadingComponent, { isLoading: true })
      : null;

    return React.createElement(
      React.Suspense,
      { fallback },
      React.createElement(LazyComponent, props)
    );
  }

  return DynamicComponent;
}

export default dynamic;
export { dynamic };
`;
  const NEXT_SCRIPT_SHIM = `
import React from 'react';

function Script({
  src,
  strategy = 'afterInteractive',
  onLoad,
  onReady,
  onError,
  children,
  dangerouslySetInnerHTML,
  ...rest
}) {
  React.useEffect(function() {
    if (!src && !children && !dangerouslySetInnerHTML) return;

    var script = document.createElement('script');

    if (src) {
      script.src = src;
      script.async = strategy !== 'beforeInteractive';
    }

    Object.keys(rest).forEach(function(key) {
      script.setAttribute(key, rest[key]);
    });

    if (children) {
      script.textContent = children;
    } else if (dangerouslySetInnerHTML && dangerouslySetInnerHTML.__html) {
      script.textContent = dangerouslySetInnerHTML.__html;
    }

    script.onload = function() {
      if (onLoad) onLoad();
      if (onReady) onReady();
    };
    script.onerror = onError;

    document.head.appendChild(script);

    return function() {
      if (script.parentNode) {
        script.parentNode.removeChild(script);
      }
    };
  }, [src]);

  return null;
}

export default Script;
export { Script };
`;
  const NEXT_FONT_GOOGLE_SHIM = `
// Track loaded fonts to avoid duplicate style injections
const loadedFonts = new Set();

/**
 * Convert font function name to Google Fonts family name
 * Examples:
 *   DM_Sans -> DM Sans
 *   Open_Sans -> Open Sans
 *   Fraunces -> Fraunces
 */
function toFontFamily(fontName) {
  return fontName.replace(/_/g, ' ');
}

/**
 * Inject font CSS into document
 * - Adds preconnect links for faster font loading
 * - Loads the font from Google Fonts CDN
 * - Creates a CSS class that sets the CSS variable
 */
function injectFontCSS(fontFamily, variableName, weight, style) {
  const fontKey = fontFamily + '-' + (variableName || 'default');
  if (loadedFonts.has(fontKey)) {
    return;
  }
  loadedFonts.add(fontKey);

  if (typeof document === 'undefined') {
    return;
  }

  // Add preconnect links for faster loading (only once)
  if (!document.querySelector('link[href="https://fonts.googleapis.com"]')) {
    const preconnect1 = document.createElement('link');
    preconnect1.rel = 'preconnect';
    preconnect1.href = 'https://fonts.googleapis.com';
    document.head.appendChild(preconnect1);

    const preconnect2 = document.createElement('link');
    preconnect2.rel = 'preconnect';
    preconnect2.href = 'https://fonts.gstatic.com';
    preconnect2.crossOrigin = 'anonymous';
    document.head.appendChild(preconnect2);
  }

  // Build Google Fonts URL
  const escapedFamily = fontFamily.replace(/ /g, '+');

  // Build axis list based on options
  let axisList = '';
  const axes = [];

  // Handle italic style
  if (style === 'italic') {
    axes.push('ital');
  }

  // Handle weight - use specific weight or variable range
  if (weight && weight !== '400' && !Array.isArray(weight)) {
    // Specific weight requested
    axes.push('wght');
    if (style === 'italic') {
      axisList = ':ital,wght@1,' + weight;
    } else {
      axisList = ':wght@' + weight;
    }
  } else if (Array.isArray(weight)) {
    // Multiple weights
    axes.push('wght');
    axisList = ':wght@' + weight.join(';');
  } else {
    // Default: request common weights for flexibility
    axisList = ':wght@400;500;600;700';
  }

  const fontUrl = 'https://fonts.googleapis.com/css2?family=' +
    escapedFamily + axisList + '&display=swap';

  // Add link element for Google Fonts (if not already present)
  if (!document.querySelector('link[href*="family=' + escapedFamily + '"]')) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = fontUrl;
    document.head.appendChild(link);
  }

  // Create style element for CSS variable at :root level (globally available)
  // This makes the variable work without needing to apply the class to body
  if (variableName) {
    const styleEl = document.createElement('style');
    styleEl.setAttribute('data-font-var', variableName);
    styleEl.textContent = ':root { ' + variableName + ': "' + fontFamily + '", ' + (fontFamily.includes('Serif') ? 'serif' : 'sans-serif') + '; }';
    document.head.appendChild(styleEl);
  }
}

/**
 * Create a font loader function for a specific font
 */
function createFontLoader(fontName) {
  const fontFamily = toFontFamily(fontName);

  return function(options = {}) {
    const {
      weight,
      style = 'normal',
      subsets = ['latin'],
      variable,
      display = 'swap',
      preload = true,
      fallback = ['sans-serif'],
      adjustFontFallback = true
    } = options;

    // Inject the font CSS
    injectFontCSS(fontFamily, variable, weight, style);

    // Generate class name from variable (--font-inter -> __font-inter)
    const className = variable
      ? variable.replace('--', '__')
      : '__font-' + fontName.toLowerCase().replace(/_/g, '-');

    return {
      className,
      variable: className,
      style: {
        fontFamily: '"' + fontFamily + '", ' + fallback.join(', ')
      }
    };
  };
}

/**
 * Use a Proxy to dynamically create font loaders for ANY font name
 * This allows: import { AnyGoogleFont } from "next/font/google"
 */
const fontProxy = new Proxy({}, {
  get(target, prop) {
    // Handle special properties
    if (prop === '__esModule') return true;
    if (prop === 'default') return fontProxy;
    if (typeof prop !== 'string') return undefined;

    // Create a font loader for this font name
    return createFontLoader(prop);
  }
});

// Export the proxy as both default and named exports
export default fontProxy;

// Re-export through proxy for named imports
export const {
  Fraunces, Inter, DM_Sans, DM_Serif_Text, Roboto, Open_Sans, Lato,
  Montserrat, Poppins, Playfair_Display, Merriweather, Raleway, Nunito,
  Ubuntu, Oswald, Quicksand, Work_Sans, Fira_Sans, Barlow, Mulish, Rubik,
  Noto_Sans, Manrope, Space_Grotesk, Geist, Geist_Mono
} = fontProxy;
`;
  const NEXT_FONT_LOCAL_SHIM = `
const loadedLocalFonts = new Set();

function localFont(options = {}) {
  const {
    src,
    weight,
    style = 'normal',
    variable,
    display = 'swap',
    fallback = ['sans-serif'],
    declarations = [],
    adjustFontFallback = true
  } = options;

  // Determine font family name from variable or src
  const familyName = variable
    ? variable.replace('--', '').replace(/-/g, ' ')
    : 'local-font-' + Math.random().toString(36).slice(2, 8);

  const fontKey = familyName + '-' + (variable || 'default');
  if (typeof document !== 'undefined' && !loadedLocalFonts.has(fontKey)) {
    loadedLocalFonts.add(fontKey);

    // Build @font-face declarations
    let fontFaces = '';

    if (typeof src === 'string') {
      // Single source
      fontFaces = '@font-face {\\n' +
        '  font-family: "' + familyName + '";\\n' +
        '  src: url("' + src + '");\\n' +
        '  font-weight: ' + (weight || '400') + ';\\n' +
        '  font-style: ' + style + ';\\n' +
        '  font-display: ' + display + ';\\n' +
        '}';
    } else if (Array.isArray(src)) {
      // Multiple sources (different weights/styles)
      fontFaces = src.map(function(s) {
        const path = typeof s === 'string' ? s : s.path;
        const w = (typeof s === 'object' && s.weight) || weight || '400';
        const st = (typeof s === 'object' && s.style) || style;
        return '@font-face {\\n' +
          '  font-family: "' + familyName + '";\\n' +
          '  src: url("' + path + '");\\n' +
          '  font-weight: ' + w + ';\\n' +
          '  font-style: ' + st + ';\\n' +
          '  font-display: ' + display + ';\\n' +
          '}';
      }).join('\\n');
    }

    // Inject font-face CSS
    if (fontFaces) {
      var styleEl = document.createElement('style');
      styleEl.setAttribute('data-local-font', fontKey);
      styleEl.textContent = fontFaces;
      document.head.appendChild(styleEl);
    }

    // Inject CSS variable at :root level
    if (variable) {
      var varStyle = document.createElement('style');
      varStyle.setAttribute('data-font-var', variable);
      varStyle.textContent = ':root { ' + variable + ': "' + familyName + '", ' + fallback.join(', ') + '; }';
      document.head.appendChild(varStyle);
    }
  }

  const className = variable
    ? variable.replace('--', '__')
    : '__font-' + familyName.toLowerCase().replace(/\\s+/g, '-');

  return {
    className,
    variable: className,
    style: {
      fontFamily: '"' + familyName + '", ' + fallback.join(', ')
    }
  };
}

export default localFont;
export { localFont };
`;
  async function generateAppRouterHtml(ctx, route, pathname) {
    const virtualPrefix = `/__virtual__/${ctx.port}`;
    const globalCssLinks = [];
    const cssLocations = [
      "/app/globals.css",
      "/styles/globals.css",
      "/styles/global.css"
    ];
    for (const cssPath of cssLocations) {
      if (ctx.exists(cssPath)) {
        globalCssLinks.push(`<link rel="stylesheet" href="${virtualPrefix}${cssPath}">`);
      }
    }
    virtualPrefix + route.page;
    route.layouts.map((layout, i2) => `import Layout${i2} from '${virtualPrefix}${layout}';`).join("\n    ");
    const loadingModulePath = route.loading ? `${virtualPrefix}${route.loading}` : "";
    const errorModulePath = route.error ? `${virtualPrefix}${route.error}` : "";
    const notFoundModulePath = route.notFound ? `${virtualPrefix}${route.notFound}` : "";
    for (let i2 = route.layouts.length - 1; i2 >= 0; i2--) {
    }
    const envScript = ctx.generateEnvScript();
    const tailwindConfigScript = await ctx.loadTailwindConfigIfNeeded();
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <base href="${virtualPrefix}/">
  <title>Next.js App</title>
  ${envScript}
  ${TAILWIND_CDN_SCRIPT}
  ${tailwindConfigScript}
  ${CORS_PROXY_SCRIPT}
  ${globalCssLinks.join("\n  ")}
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0?dev",
      "react/": "https://esm.sh/react@18.2.0&dev/",
      "react-dom": "https://esm.sh/react-dom@18.2.0?dev",
      "react-dom/": "https://esm.sh/react-dom@18.2.0&dev/",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev",
      "convex/react": "https://esm.sh/convex@1.21.0/react?external=react",
      "convex/server": "https://esm.sh/convex@1.21.0/server",
      "convex/values": "https://esm.sh/convex@1.21.0/values",
      "convex/_generated/api": "${virtualPrefix}/convex/_generated/api.ts",
      "ai": "https://esm.sh/ai@4?external=react",
      "ai/react": "https://esm.sh/ai@4/react?external=react",
      "@ai-sdk/openai": "https://esm.sh/@ai-sdk/openai@1",
      "next/link": "${virtualPrefix}/_next/shims/link.js",
      "next/router": "${virtualPrefix}/_next/shims/router.js",
      "next/head": "${virtualPrefix}/_next/shims/head.js",
      "next/navigation": "${virtualPrefix}/_next/shims/navigation.js",
      "next/image": "${virtualPrefix}/_next/shims/image.js",
      "next/dynamic": "${virtualPrefix}/_next/shims/dynamic.js",
      "next/script": "${virtualPrefix}/_next/shims/script.js",
      "next/font/google": "${virtualPrefix}/_next/shims/font/google.js",
      "next/font/local": "${virtualPrefix}/_next/shims/font/local.js"
    }
  }
  <\/script>
  ${REACT_REFRESH_PREAMBLE}
  ${HMR_CLIENT_SCRIPT}
</head>
<body>
  <div id="__next"></div>
  <script type="module">
    import React from 'react';
    import ReactDOM from 'react-dom/client';

    const virtualBase = '${virtualPrefix}';

    // Initial route params (embedded by server for initial page load)
    const initialRouteParams = ${JSON.stringify(route.params)};
    const initialPathname = '${pathname}';

    // Expose initial params for useParams() hook
    window.__NEXT_ROUTE_PARAMS__ = initialRouteParams;

    // Convention file paths (loading.tsx, error.tsx, not-found.tsx)
    const loadingModulePath = '${loadingModulePath}';
    const errorModulePath = '${errorModulePath}';
    const notFoundModulePath = '${notFoundModulePath}';

    // Route params cache for client-side navigation
    const routeParamsCache = new Map();
    routeParamsCache.set(initialPathname, initialRouteParams);

    // Extract route params from server for client-side navigation
    async function extractRouteParams(pathname) {
      // Strip virtual base if present
      let route = pathname;
      if (route.startsWith(virtualBase)) {
        route = route.slice(virtualBase.length);
      }
      route = route.replace(/^\\/+/, '/') || '/';

      // Check cache first
      if (routeParamsCache.has(route)) {
        return routeParamsCache.get(route);
      }

      try {
        const response = await fetch(virtualBase + '/_next/route-info?pathname=' + encodeURIComponent(route));
        const info = await response.json();
        routeParamsCache.set(route, info.params || {});
        return info.params || {};
      } catch (e) {
        console.error('[Router] Failed to extract route params:', e);
        return {};
      }
    }

    // Convert URL path to app router page module path
    function getAppPageModulePath(pathname) {
      let route = pathname;
      if (route.startsWith(virtualBase)) {
        route = route.slice(virtualBase.length);
      }
      route = route.replace(/^\\/+/, '/') || '/';
      // App Router: / -> /app/page, /about -> /app/about/page
      const pagePath = route === '/' ? '/app/page' : '/app' + route + '/page';
      return virtualBase + '/_next/app' + pagePath + '.js';
    }

    // Get layout paths for a route
    function getLayoutPaths(pathname) {
      let route = pathname;
      if (route.startsWith(virtualBase)) {
        route = route.slice(virtualBase.length);
      }
      route = route.replace(/^\\/+/, '/') || '/';

      // Build layout paths from root to current route
      const layouts = [virtualBase + '/_next/app/app/layout.js'];
      if (route !== '/') {
        const segments = route.split('/').filter(Boolean);
        let currentPath = '/app';
        for (const segment of segments) {
          currentPath += '/' + segment;
          layouts.push(virtualBase + '/_next/app' + currentPath + '/layout.js');
        }
      }
      return layouts;
    }

    // Dynamic page loader with retry (SW may need time to recover after idle termination)
    async function loadPage(pathname) {
      const modulePath = getAppPageModulePath(pathname);
      for (let attempt = 0; attempt < 3; attempt++) {
        try {
          const module = await import(/* @vite-ignore */ modulePath + (attempt > 0 ? '?retry=' + attempt : ''));
          return module.default;
        } catch (e) {
          console.warn('[Navigation] Load attempt ' + (attempt + 1) + ' failed:', modulePath, e.message);
          if (attempt < 2) await new Promise(r => setTimeout(r, 1000));
        }
      }
      console.error('[Navigation] Failed to load page after 3 attempts:', modulePath);
      return null;
    }

    // Load layouts (with caching)
    const layoutCache = new Map();
    async function loadLayouts(pathname) {
      const layoutPaths = getLayoutPaths(pathname);
      const layouts = [];
      for (const path of layoutPaths) {
        if (layoutCache.has(path)) {
          layouts.push(layoutCache.get(path));
        } else {
          try {
            const module = await import(/* @vite-ignore */ path);
            layoutCache.set(path, module.default);
            layouts.push(module.default);
          } catch (e) {
            // Layout might not exist for this segment, skip
          }
        }
      }
      return layouts;
    }

    // Load convention components (loading.tsx, error.tsx)
    let LoadingComponent = null;
    let ErrorComponent = null;
    let NotFoundComponent = null;

    async function loadConventionComponents() {
      if (loadingModulePath) {
        try {
          const mod = await import(/* @vite-ignore */ loadingModulePath);
          LoadingComponent = mod.default;
        } catch (e) { /* loading.tsx not available */ }
      }
      if (errorModulePath) {
        try {
          const mod = await import(/* @vite-ignore */ errorModulePath);
          ErrorComponent = mod.default;
        } catch (e) { /* error.tsx not available */ }
      }
      if (notFoundModulePath) {
        try {
          const mod = await import(/* @vite-ignore */ notFoundModulePath);
          NotFoundComponent = mod.default;
        } catch (e) { /* not-found.tsx not available */ }
      }
    }
    await loadConventionComponents();

    // Error boundary class component
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { error: null };
      }
      static getDerivedStateFromError(error) {
        return { error };
      }
      componentDidCatch(error, info) {
        console.error('[ErrorBoundary]', error, info);
      }
      render() {
        if (this.state.error) {
          if (this.props.fallback) {
            return React.createElement(this.props.fallback, {
              error: this.state.error,
              reset: () => this.setState({ error: null })
            });
          }
          return React.createElement('div', { style: { color: 'red', padding: '20px' } },
            'Error: ' + this.state.error.message
          );
        }
        return this.props.children;
      }
    }

    // Wrapper that provides searchParams/params props and handles errors
    function PageWrapper({ component: Component, pathname, search }) {
      const [searchParams, setSearchParams] = React.useState(() => {
        const url = new URL(window.location.href);
        return Promise.resolve(Object.fromEntries(url.searchParams));
      });
      const [params, setParams] = React.useState(() => Promise.resolve(initialRouteParams));
      const [isNotFound, setIsNotFound] = React.useState(false);

      React.useEffect(() => {
        // Update searchParams when search changes
        const url = new URL(window.location.href);
        setSearchParams(Promise.resolve(Object.fromEntries(url.searchParams)));
      }, [search]);

      React.useEffect(() => {
        // Update route params when pathname changes
        let cancelled = false;
        extractRouteParams(pathname).then(routeParams => {
          if (!cancelled) setParams(Promise.resolve(routeParams));
        });
        return () => { cancelled = true; };
      }, [pathname]);

      if (isNotFound && NotFoundComponent) {
        return React.createElement(NotFoundComponent);
      }
      if (isNotFound) {
        return React.createElement('div', { style: { padding: '20px', textAlign: 'center' } },
          React.createElement('h2', null, '404'),
          React.createElement('p', null, 'This page could not be found.')
        );
      }

      // Render the component via createElement so hooks work correctly
      try {
        return React.createElement(Component, { searchParams, params });
      } catch (e) {
        if (e && e.message === 'NEXT_NOT_FOUND') {
          // Will re-render with notFound on next tick
          if (!isNotFound) setIsNotFound(true);
          return null;
        }
        throw e; // Let ErrorBoundary handle it
      }
    }

    // Router component
    function Router() {
      const [Page, setPage] = React.useState(null);
      const [layouts, setLayouts] = React.useState([]);
      const [path, setPath] = React.useState(window.location.pathname);
      const [search, setSearch] = React.useState(window.location.search);

      React.useEffect(() => {
        Promise.all([loadPage(path), loadLayouts(path)]).then(([P, L]) => {
          if (P) setPage(() => P);
          setLayouts(L);
        });
      }, []);

      React.useEffect(() => {
        const handleNavigation = async () => {
          const newPath = window.location.pathname;
          const newSearch = window.location.search;
          console.log('[Router] handleNavigation called, newPath:', newPath, 'current path:', path);

          // Always update search params
          if (newSearch !== search) {
            setSearch(newSearch);
          }

          if (newPath !== path) {
            console.log('[Router] Path changed, loading new page...');
            setPath(newPath);
            const [P, L, routeParams] = await Promise.all([loadPage(newPath), loadLayouts(newPath), extractRouteParams(newPath)]);
            window.__NEXT_ROUTE_PARAMS__ = routeParams;
            console.log('[Router] Page loaded:', !!P, 'Layouts:', L.length);
            if (P) setPage(() => P);
            setLayouts(L);
          } else {
            console.log('[Router] Path unchanged, skipping navigation');
          }
        };
        window.addEventListener('popstate', handleNavigation);
        console.log('[Router] Added popstate listener for path:', path);
        return () => window.removeEventListener('popstate', handleNavigation);
      }, [path, search]);

      if (!Page) return null;

      // Render page via PageWrapper so hooks work correctly
      // Pass search to force re-render when query params change
      let content = React.createElement(PageWrapper, { component: Page, pathname: path, search: search });

      // Wrap with loading.tsx Suspense fallback if it exists
      if (LoadingComponent) {
        content = React.createElement(React.Suspense,
          { fallback: React.createElement(LoadingComponent) },
          content
        );
      }

      // Wrap with error boundary if error.tsx exists
      if (ErrorComponent) {
        content = React.createElement(ErrorBoundary, { fallback: ErrorComponent }, content);
      }

      for (let i = layouts.length - 1; i >= 0; i--) {
        content = React.createElement(layouts[i], null, content);
      }
      return content;
    }

    // Mark that we've initialized (for testing no-reload)
    window.__NEXT_INITIALIZED__ = Date.now();

    ReactDOM.createRoot(document.getElementById('__next')).render(
      React.createElement(React.StrictMode, null, React.createElement(Router))
    );
  <\/script>
</body>
</html>`;
  }
  async function generatePageHtml(ctx, pageFile, pathname) {
    const virtualPrefix = `/__virtual__/${ctx.port}`;
    const globalCssLinks = [];
    const cssLocations = [
      "/styles/globals.css",
      "/styles/global.css",
      "/app/globals.css"
    ];
    for (const cssPath of cssLocations) {
      if (ctx.exists(cssPath)) {
        globalCssLinks.push(`<link rel="stylesheet" href="${virtualPrefix}${cssPath}">`);
      }
    }
    const envScript = ctx.generateEnvScript();
    const tailwindConfigScript = await ctx.loadTailwindConfigIfNeeded();
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <base href="${virtualPrefix}/">
  <title>Next.js App</title>
  ${envScript}
  ${TAILWIND_CDN_SCRIPT}
  ${tailwindConfigScript}
  ${CORS_PROXY_SCRIPT}
  ${globalCssLinks.join("\n  ")}
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0?dev",
      "react/": "https://esm.sh/react@18.2.0&dev/",
      "react-dom": "https://esm.sh/react-dom@18.2.0?dev",
      "react-dom/": "https://esm.sh/react-dom@18.2.0&dev/",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev",
      "next/link": "${virtualPrefix}/_next/shims/link.js",
      "next/router": "${virtualPrefix}/_next/shims/router.js",
      "next/head": "${virtualPrefix}/_next/shims/head.js",
      "next/navigation": "${virtualPrefix}/_next/shims/navigation.js",
      "next/image": "${virtualPrefix}/_next/shims/image.js",
      "next/dynamic": "${virtualPrefix}/_next/shims/dynamic.js",
      "next/script": "${virtualPrefix}/_next/shims/script.js",
      "next/font/google": "${virtualPrefix}/_next/shims/font/google.js",
      "next/font/local": "${virtualPrefix}/_next/shims/font/local.js"
    }
  }
  <\/script>
  ${REACT_REFRESH_PREAMBLE}
  ${HMR_CLIENT_SCRIPT}
</head>
<body>
  <div id="__next"></div>
  <script type="module">
    import React from 'react';
    import ReactDOM from 'react-dom/client';

    const virtualBase = '${virtualPrefix}';

    // Convert URL path to page module path
    function getPageModulePath(pathname) {
      let route = pathname;
      if (route.startsWith(virtualBase)) {
        route = route.slice(virtualBase.length);
      }
      route = route.replace(/^\\/+/, '/') || '/';
      const modulePath = route === '/' ? '/index' : route;
      return virtualBase + '/_next/pages' + modulePath + '.js';
    }

    // Dynamic page loader
    async function loadPage(pathname) {
      const modulePath = getPageModulePath(pathname);
      try {
        const module = await import(/* @vite-ignore */ modulePath);
        return module.default;
      } catch (e) {
        console.error('[Navigation] Failed to load:', modulePath, e);
        return null;
      }
    }

    // Router component
    function Router() {
      const [Page, setPage] = React.useState(null);
      const [path, setPath] = React.useState(window.location.pathname);

      React.useEffect(() => {
        loadPage(path).then(C => C && setPage(() => C));
      }, []);

      React.useEffect(() => {
        const handleNavigation = async () => {
          const newPath = window.location.pathname;
          if (newPath !== path) {
            setPath(newPath);
            const C = await loadPage(newPath);
            if (C) setPage(() => C);
          }
        };
        window.addEventListener('popstate', handleNavigation);
        return () => window.removeEventListener('popstate', handleNavigation);
      }, [path]);

      if (!Page) return null;
      return React.createElement(Page);
    }

    // Mark that we've initialized (for testing no-reload)
    window.__NEXT_INITIALIZED__ = Date.now();

    ReactDOM.createRoot(document.getElementById('__next')).render(
      React.createElement(React.StrictMode, null, React.createElement(Router))
    );
  <\/script>
</body>
</html>`;
  }
  function serve404Page(port) {
    const virtualPrefix = `/__virtual__/${port}`;
    const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <base href="${virtualPrefix}/">
  <title>404 - Page Not Found</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      background: #fafafa;
    }
    h1 { font-size: 48px; margin: 0; }
    p { color: #666; margin-top: 10px; }
    a { color: #0070f3; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <h1>404</h1>
  <p>This page could not be found.</p>
  <p><a href="/">Go back home</a></p>
</body>
</html>`;
    const buffer2 = BufferPolyfill.from(html);
    return {
      statusCode: 404,
      statusMessage: "Not Found",
      headers: {
        "Content-Type": "text/html; charset=utf-8",
        "Content-Length": String(buffer2.length)
      },
      body: buffer2
    };
  }
  const PAGE_EXTENSIONS = [
    ".jsx",
    ".tsx",
    ".js",
    ".ts"
  ];
  const API_EXTENSIONS = [
    ".js",
    ".ts",
    ".jsx",
    ".tsx"
  ];
  function hasAppRouter(appDir, ctx) {
    try {
      if (!ctx.exists(appDir)) return false;
      for (const ext of PAGE_EXTENSIONS) {
        if (ctx.exists(`${appDir}/page${ext}`)) return true;
      }
      try {
        const entries = ctx.readdir(appDir);
        for (const entry of entries) {
          if (/^\([^)]+\)$/.test(entry) && ctx.isDirectory(`${appDir}/${entry}`)) {
            for (const ext of PAGE_EXTENSIONS) {
              if (ctx.exists(`${appDir}/${entry}/page${ext}`)) return true;
            }
          }
        }
      } catch {
      }
      for (const ext of PAGE_EXTENSIONS) {
        if (ctx.exists(`${appDir}/layout${ext}`)) return true;
      }
      return false;
    } catch {
      return false;
    }
  }
  function resolveAppRoute(appDir, pathname, ctx) {
    const segments = pathname === "/" ? [] : pathname.split("/").filter(Boolean);
    return resolveAppDynamicRoute(appDir, segments, ctx);
  }
  function resolveAppDynamicRoute(appDir, segments, ctx) {
    const collectLayout = (dirPath, layouts2) => {
      for (const ext of PAGE_EXTENSIONS) {
        const layoutPath = `${dirPath}/layout${ext}`;
        if (ctx.exists(layoutPath) && !layouts2.includes(layoutPath)) {
          return [
            ...layouts2,
            layoutPath
          ];
        }
      }
      return layouts2;
    };
    const findPage = (dirPath) => {
      for (const ext of PAGE_EXTENSIONS) {
        const pagePath = `${dirPath}/page${ext}`;
        if (ctx.exists(pagePath)) {
          return pagePath;
        }
      }
      return null;
    };
    const findConventionFile = (dirPath, name2) => {
      for (const ext of PAGE_EXTENSIONS) {
        const filePath = `${dirPath}/${name2}${ext}`;
        if (ctx.exists(filePath)) {
          return filePath;
        }
      }
      return null;
    };
    const findNearestConventionFile = (dirPath, name2) => {
      let current = dirPath;
      while (current.startsWith(appDir)) {
        const file = findConventionFile(current, name2);
        if (file) return file;
        const parent = current.replace(/\/[^/]+$/, "");
        if (parent === current) break;
        current = parent;
      }
      return null;
    };
    const getRouteGroups = (dirPath) => {
      try {
        const entries = ctx.readdir(dirPath);
        return entries.filter((e) => /^\([^)]+\)$/.test(e) && ctx.isDirectory(`${dirPath}/${e}`));
      } catch {
        return [];
      }
    };
    const tryPath = (dirPath, remainingSegments, layouts2, params) => {
      layouts2 = collectLayout(dirPath, layouts2);
      if (remainingSegments.length === 0) {
        const page2 = findPage(dirPath);
        if (page2) {
          return {
            page: page2,
            layouts: layouts2,
            params,
            loading: findNearestConventionFile(dirPath, "loading") || void 0,
            error: findNearestConventionFile(dirPath, "error") || void 0,
            notFound: findNearestConventionFile(dirPath, "not-found") || void 0
          };
        }
        const groups2 = getRouteGroups(dirPath);
        for (const group of groups2) {
          const groupPath = `${dirPath}/${group}`;
          const groupLayouts = collectLayout(groupPath, layouts2);
          const page22 = findPage(groupPath);
          if (page22) {
            return {
              page: page22,
              layouts: groupLayouts,
              params,
              loading: findNearestConventionFile(groupPath, "loading") || void 0,
              error: findNearestConventionFile(groupPath, "error") || void 0,
              notFound: findNearestConventionFile(groupPath, "not-found") || void 0
            };
          }
        }
        return null;
      }
      const [current, ...rest] = remainingSegments;
      const exactPath = `${dirPath}/${current}`;
      if (ctx.isDirectory(exactPath)) {
        const result = tryPath(exactPath, rest, layouts2, params);
        if (result) return result;
      }
      const groups = getRouteGroups(dirPath);
      for (const group of groups) {
        const groupPath = `${dirPath}/${group}`;
        const groupLayouts = collectLayout(groupPath, layouts2);
        const groupExactPath = `${groupPath}/${current}`;
        if (ctx.isDirectory(groupExactPath)) {
          const result = tryPath(groupExactPath, rest, groupLayouts, params);
          if (result) return result;
        }
        try {
          const groupEntries = ctx.readdir(groupPath);
          for (const entry of groupEntries) {
            if (entry.startsWith("[...") && entry.endsWith("]")) {
              const dynamicPath = `${groupPath}/${entry}`;
              if (ctx.isDirectory(dynamicPath)) {
                const paramName = entry.slice(4, -1);
                const newParams = {
                  ...params,
                  [paramName]: [
                    current,
                    ...rest
                  ]
                };
                const result = tryPath(dynamicPath, [], groupLayouts, newParams);
                if (result) return result;
              }
            } else if (entry.startsWith("[[...") && entry.endsWith("]]")) {
              const dynamicPath = `${groupPath}/${entry}`;
              if (ctx.isDirectory(dynamicPath)) {
                const paramName = entry.slice(5, -2);
                const newParams = {
                  ...params,
                  [paramName]: [
                    current,
                    ...rest
                  ]
                };
                const result = tryPath(dynamicPath, [], groupLayouts, newParams);
                if (result) return result;
              }
            } else if (entry.startsWith("[") && entry.endsWith("]") && !entry.includes(".")) {
              const dynamicPath = `${groupPath}/${entry}`;
              if (ctx.isDirectory(dynamicPath)) {
                const paramName = entry.slice(1, -1);
                const newParams = {
                  ...params,
                  [paramName]: current
                };
                const result = tryPath(dynamicPath, rest, groupLayouts, newParams);
                if (result) return result;
              }
            }
          }
        } catch {
        }
      }
      try {
        const entries = ctx.readdir(dirPath);
        for (const entry of entries) {
          if (entry.startsWith("[...") && entry.endsWith("]")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const paramName = entry.slice(4, -1);
              const newParams = {
                ...params,
                [paramName]: [
                  current,
                  ...rest
                ]
              };
              const result = tryPath(dynamicPath, [], layouts2, newParams);
              if (result) return result;
            }
          } else if (entry.startsWith("[[...") && entry.endsWith("]]")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const paramName = entry.slice(5, -2);
              const newParams = {
                ...params,
                [paramName]: [
                  current,
                  ...rest
                ]
              };
              const result = tryPath(dynamicPath, [], layouts2, newParams);
              if (result) return result;
            }
          } else if (entry.startsWith("[") && entry.endsWith("]") && !entry.includes(".")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const paramName = entry.slice(1, -1);
              const newParams = {
                ...params,
                [paramName]: current
              };
              const result = tryPath(dynamicPath, rest, layouts2, newParams);
              if (result) return result;
            }
          }
        }
      } catch {
      }
      return null;
    };
    const layouts = [];
    for (const ext of PAGE_EXTENSIONS) {
      const rootLayout = `${appDir}/layout${ext}`;
      if (ctx.exists(rootLayout)) {
        layouts.push(rootLayout);
        break;
      }
    }
    return tryPath(appDir, segments, layouts, {});
  }
  function resolveAppRouteHandler(appDir, pathname, ctx) {
    const extensions = API_EXTENSIONS;
    const segments = pathname === "/" ? [] : pathname.split("/").filter(Boolean);
    let dirPath = appDir;
    for (const segment of segments) {
      dirPath = `${dirPath}/${segment}`;
    }
    for (const ext of extensions) {
      const routePath = `${dirPath}/route${ext}`;
      if (ctx.exists(routePath)) {
        return routePath;
      }
    }
    return resolveAppRouteHandlerDynamic(appDir, segments, ctx);
  }
  function resolveAppRouteHandlerDynamic(appDir, segments, ctx) {
    const extensions = API_EXTENSIONS;
    const tryPath = (dirPath, remainingSegments) => {
      if (remainingSegments.length === 0) {
        for (const ext of extensions) {
          const routePath = `${dirPath}/route${ext}`;
          if (ctx.exists(routePath)) {
            return routePath;
          }
        }
        try {
          const entries = ctx.readdir(dirPath);
          for (const entry of entries) {
            if (/^\([^)]+\)$/.test(entry) && ctx.isDirectory(`${dirPath}/${entry}`)) {
              for (const ext of extensions) {
                const routePath = `${dirPath}/${entry}/route${ext}`;
                if (ctx.exists(routePath)) {
                  return routePath;
                }
              }
            }
          }
        } catch {
        }
        return null;
      }
      const [current, ...rest] = remainingSegments;
      const exactPath = `${dirPath}/${current}`;
      if (ctx.isDirectory(exactPath)) {
        const result = tryPath(exactPath, rest);
        if (result) return result;
      }
      try {
        const entries = ctx.readdir(dirPath);
        for (const entry of entries) {
          if (/^\([^)]+\)$/.test(entry) && ctx.isDirectory(`${dirPath}/${entry}`)) {
            const groupExact = `${dirPath}/${entry}/${current}`;
            if (ctx.isDirectory(groupExact)) {
              const result = tryPath(groupExact, rest);
              if (result) return result;
            }
          }
          if (entry.startsWith("[") && entry.endsWith("]") && !entry.includes(".")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const result = tryPath(dynamicPath, rest);
              if (result) return result;
            }
          }
          if (entry.startsWith("[...") && entry.endsWith("]")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const result = tryPath(dynamicPath, []);
              if (result) return result;
            }
          }
        }
      } catch {
      }
      return null;
    };
    return tryPath(appDir, segments);
  }
  function resolvePageFile(pagesDir, pathname, ctx) {
    if (pathname === "/") {
      pathname = "/index";
    }
    for (const ext of PAGE_EXTENSIONS) {
      const filePath = `${pagesDir}${pathname}${ext}`;
      if (ctx.exists(filePath)) {
        return filePath;
      }
    }
    for (const ext of PAGE_EXTENSIONS) {
      const filePath = `${pagesDir}${pathname}/index${ext}`;
      if (ctx.exists(filePath)) {
        return filePath;
      }
    }
    return resolveDynamicRoute(pagesDir, pathname, ctx);
  }
  function resolveDynamicRoute(pagesDir, pathname, ctx) {
    const segments = pathname.split("/").filter(Boolean);
    if (segments.length === 0) return null;
    const tryPath = (dirPath, remainingSegments) => {
      if (remainingSegments.length === 0) {
        for (const ext of PAGE_EXTENSIONS) {
          const indexPath = `${dirPath}/index${ext}`;
          if (ctx.exists(indexPath)) {
            return indexPath;
          }
        }
        return null;
      }
      const [current, ...rest] = remainingSegments;
      const exactPath = `${dirPath}/${current}`;
      for (const ext of PAGE_EXTENSIONS) {
        if (rest.length === 0 && ctx.exists(exactPath + ext)) {
          return exactPath + ext;
        }
      }
      if (ctx.isDirectory(exactPath)) {
        const exactResult = tryPath(exactPath, rest);
        if (exactResult) return exactResult;
      }
      try {
        const entries = ctx.readdir(dirPath);
        for (const entry of entries) {
          for (const ext of PAGE_EXTENSIONS) {
            const dynamicFilePattern = /^\[([^\]]+)\]$/;
            const nameWithoutExt = entry.replace(ext, "");
            if (entry.endsWith(ext) && dynamicFilePattern.test(nameWithoutExt)) {
              if (rest.length === 0) {
                const filePath = `${dirPath}/${entry}`;
                if (ctx.exists(filePath)) {
                  return filePath;
                }
              }
            }
          }
          if (entry.startsWith("[") && entry.endsWith("]") && !entry.includes(".")) {
            const dynamicPath = `${dirPath}/${entry}`;
            if (ctx.isDirectory(dynamicPath)) {
              const dynamicResult = tryPath(dynamicPath, rest);
              if (dynamicResult) return dynamicResult;
            }
          }
          for (const ext of PAGE_EXTENSIONS) {
            if (entry.startsWith("[...") && entry.endsWith("]" + ext)) {
              const filePath = `${dirPath}/${entry}`;
              if (ctx.exists(filePath)) {
                return filePath;
              }
            }
          }
        }
      } catch {
      }
      return null;
    };
    return tryPath(pagesDir, segments);
  }
  function resolveApiFile(pagesDir, pathname, ctx) {
    const apiPath = pathname.replace(/^\/api/, `${pagesDir}/api`);
    for (const ext of API_EXTENSIONS) {
      const filePath = apiPath + ext;
      if (ctx.exists(filePath)) {
        return filePath;
      }
    }
    for (const ext of API_EXTENSIONS) {
      const filePath = `${apiPath}/index${ext}`;
      if (ctx.exists(filePath)) {
        return filePath;
      }
    }
    return null;
  }
  function resolveFileWithExtension(pathname, ctx) {
    if (/\.\w+$/.test(pathname) && ctx.exists(pathname)) {
      return pathname;
    }
    const extensions = [
      ".tsx",
      ".ts",
      ".jsx",
      ".js"
    ];
    for (const ext of extensions) {
      const withExt = pathname + ext;
      if (ctx.exists(withExt)) {
        return withExt;
      }
    }
    for (const ext of extensions) {
      const indexPath = pathname + "/index" + ext;
      if (ctx.exists(indexPath)) {
        return indexPath;
      }
    }
    return null;
  }
  function needsTransform(path2) {
    return /\.(jsx|tsx|ts)$/.test(path2);
  }
  function parseCookies(cookieHeader) {
    const cookies = {};
    if (!cookieHeader) return cookies;
    cookieHeader.split(";").forEach((cookie) => {
      const [name2, value2] = cookie.trim().split("=");
      if (name2 && value2) {
        cookies[name2] = decodeURIComponent(value2);
      }
    });
    return cookies;
  }
  function createMockRequest(method, pathname, headers, body) {
    const url2 = new URL(pathname, "http://localhost");
    return {
      method,
      url: pathname,
      headers,
      query: Object.fromEntries(url2.searchParams),
      body: body ? JSON.parse(body.toString()) : void 0,
      cookies: parseCookies(headers.cookie || "")
    };
  }
  function createMockResponse() {
    let statusCode = 200;
    let statusMessage = "OK";
    const headers = {};
    let responseBody = "";
    let ended = false;
    let resolveEnded = null;
    let headersSent = false;
    const endedPromise = new Promise((resolve2) => {
      resolveEnded = resolve2;
    });
    const markEnded = () => {
      if (!ended) {
        ended = true;
        if (resolveEnded) resolveEnded();
      }
    };
    return {
      headersSent: false,
      status(code2) {
        statusCode = code2;
        return this;
      },
      setHeader(name2, value2) {
        headers[name2] = value2;
        return this;
      },
      getHeader(name2) {
        return headers[name2];
      },
      write(chunk) {
        if (!headersSent) {
          headersSent = true;
          this.headersSent = true;
        }
        responseBody += typeof chunk === "string" ? chunk : chunk.toString();
        return true;
      },
      get writable() {
        return true;
      },
      json(data2) {
        headers["Content-Type"] = "application/json; charset=utf-8";
        responseBody = JSON.stringify(data2);
        markEnded();
        return this;
      },
      send(data2) {
        if (typeof data2 === "object") {
          return this.json(data2);
        }
        responseBody = data2;
        markEnded();
        return this;
      },
      end(data2) {
        if (data2) responseBody += data2;
        markEnded();
        return this;
      },
      redirect(statusOrUrl, url2) {
        if (typeof statusOrUrl === "number") {
          statusCode = statusOrUrl;
          headers["Location"] = url2 || "/";
        } else {
          statusCode = 307;
          headers["Location"] = statusOrUrl;
        }
        markEnded();
        return this;
      },
      isEnded() {
        return ended;
      },
      waitForEnd() {
        return endedPromise;
      },
      toResponse() {
        const buffer2 = BufferPolyfill.from(responseBody);
        headers["Content-Length"] = String(buffer2.length);
        return {
          statusCode,
          statusMessage,
          headers,
          body: buffer2
        };
      }
    };
  }
  function createStreamingMockResponse(onStart, onChunk, onEnd) {
    let statusCode = 200;
    let statusMessage = "OK";
    const headers = {};
    let ended = false;
    let headersSent = false;
    let resolveEnded = null;
    const endedPromise = new Promise((resolve2) => {
      resolveEnded = resolve2;
    });
    const sendHeaders = () => {
      if (!headersSent) {
        headersSent = true;
        onStart(statusCode, statusMessage, headers);
      }
    };
    const markEnded = () => {
      if (!ended) {
        sendHeaders();
        ended = true;
        onEnd();
        if (resolveEnded) resolveEnded();
      }
    };
    return {
      headersSent: false,
      status(code2) {
        statusCode = code2;
        return this;
      },
      setHeader(name2, value2) {
        headers[name2] = value2;
        return this;
      },
      getHeader(name2) {
        return headers[name2];
      },
      write(chunk) {
        sendHeaders();
        const data2 = typeof chunk === "string" ? chunk : chunk.toString();
        onChunk(data2);
        return true;
      },
      get writable() {
        return true;
      },
      json(data2) {
        headers["Content-Type"] = "application/json; charset=utf-8";
        sendHeaders();
        onChunk(JSON.stringify(data2));
        markEnded();
        return this;
      },
      send(data2) {
        if (typeof data2 === "object") {
          return this.json(data2);
        }
        sendHeaders();
        onChunk(data2);
        markEnded();
        return this;
      },
      end(data2) {
        if (data2) {
          sendHeaders();
          onChunk(data2);
        }
        markEnded();
        return this;
      },
      redirect(statusOrUrl, url2) {
        if (typeof statusOrUrl === "number") {
          statusCode = statusOrUrl;
          headers["Location"] = url2 || "/";
        } else {
          statusCode = 307;
          headers["Location"] = statusOrUrl;
        }
        markEnded();
        return this;
      },
      isEnded() {
        return ended;
      },
      waitForEnd() {
        return endedPromise;
      },
      toResponse() {
        return {
          statusCode,
          statusMessage,
          headers,
          body: BufferPolyfill.from("")
        };
      }
    };
  }
  async function createBuiltinModules(createFsShim2) {
    const modules = {
      https: await Promise.resolve().then(() => httpsShim),
      http: await Promise.resolve().then(() => httpShim),
      path: await Promise.resolve().then(() => pathShim),
      url: await Promise.resolve().then(() => urlShim),
      querystring: await Promise.resolve().then(() => querystringShim),
      util: await Promise.resolve().then(() => utilShim),
      events: await Promise.resolve().then(() => events$1),
      stream: await Promise.resolve().then(() => stream),
      buffer: await Promise.resolve().then(() => buffer),
      crypto: await Promise.resolve().then(() => cryptoShim)
    };
    if (createFsShim2) {
      modules.fs = await createFsShim2();
    }
    return modules;
  }
  async function executeApiHandler(code2, req, res, env, builtinModules2) {
    try {
      const require2 = (id) => {
        const modId = id.startsWith("node:") ? id.slice(5) : id;
        if (builtinModules2[modId]) {
          return builtinModules2[modId];
        }
        throw new Error(`Module not found: ${id}`);
      };
      const module2 = {
        exports: {}
      };
      const exports$1 = module2.exports;
      const process2 = {
        env: {
          ...env
        },
        cwd: () => "/",
        platform: "browser",
        version: "v18.0.0",
        versions: {
          node: "18.0.0"
        }
      };
      const fn2 = new Function("exports", "require", "module", "process", code2);
      fn2(exports$1, require2, module2, process2);
      let handler = module2.exports.default || module2.exports;
      if (typeof handler === "object" && handler !== null && "default" in handler) {
        handler = handler.default;
      }
      if (typeof handler !== "function") {
        throw new Error("No default export handler found");
      }
      const result = handler(req, res);
      if (result instanceof Promise) {
        await result;
      }
    } catch (error) {
      console.error("[NextDevServer] API handler error:", error);
      throw error;
    }
  }
  const isBrowser = typeof window !== "undefined" && typeof window.navigator !== "undefined" && "serviceWorker" in window.navigator;
  async function initEsbuild() {
    if (!isBrowser) return;
    if (window.__esbuild) {
      return;
    }
    if (window.__esbuildInitPromise) {
      return window.__esbuildInitPromise;
    }
    window.__esbuildInitPromise = (async () => {
      try {
        const mod = await import("https://esm.sh/esbuild-wasm@0.20.0").then(async (m) => {
          await m.__tla;
          return m;
        });
        const esbuildMod = mod.default || mod;
        try {
          await esbuildMod.initialize({
            wasmURL: "https://unpkg.com/esbuild-wasm@0.20.0/esbuild.wasm"
          });
          console.log("[NextDevServer] esbuild-wasm initialized");
        } catch (initError) {
          if (initError instanceof Error && initError.message.includes('Cannot call "initialize" more than once')) {
            console.log("[NextDevServer] esbuild-wasm already initialized, reusing");
          } else {
            throw initError;
          }
        }
        window.__esbuild = esbuildMod;
      } catch (error) {
        console.error("[NextDevServer] Failed to initialize esbuild:", error);
        window.__esbuildInitPromise = void 0;
        throw error;
      }
    })();
    return window.__esbuildInitPromise;
  }
  function getEsbuild() {
    return isBrowser ? window.__esbuild : void 0;
  }
  NextDevServer = class extends DevServer {
    constructor(vfs2, options2) {
      super(vfs2, options2);
      __publicField(this, "pagesDir");
      __publicField(this, "appDir");
      __publicField(this, "publicDir");
      __publicField(this, "useAppRouter");
      __publicField(this, "watcherCleanup", null);
      __publicField(this, "hmrTargetWindow", null);
      __publicField(this, "options");
      __publicField(this, "transformCache", /* @__PURE__ */ new Map());
      __publicField(this, "pathAliases", /* @__PURE__ */ new Map());
      __publicField(this, "tailwindConfigScript", "");
      __publicField(this, "tailwindConfigLoaded", false);
      __publicField(this, "assetPrefix", "");
      __publicField(this, "basePath", "");
      this.options = options2;
      this.pagesDir = options2.pagesDir || "/pages";
      this.appDir = options2.appDir || "/app";
      this.publicDir = options2.publicDir || "/public";
      if (options2.preferAppRouter !== void 0) {
        this.useAppRouter = options2.preferAppRouter;
      } else {
        this.useAppRouter = hasAppRouter(this.appDir, this.routeCtx);
      }
      this.loadPathAliases();
      this.loadAssetPrefix(options2.assetPrefix);
      this.loadBasePath(options2.basePath);
    }
    get routeCtx() {
      return {
        exists: (path2) => this.exists(path2),
        isDirectory: (path2) => this.isDirectory(path2),
        readdir: (path2) => this.vfs.readdirSync(path2)
      };
    }
    loadPathAliases() {
      var _a2;
      try {
        const tsconfigPath = "/tsconfig.json";
        if (!this.vfs.existsSync(tsconfigPath)) {
          return;
        }
        const content = this.vfs.readFileSync(tsconfigPath, "utf-8");
        const tsconfig = JSON.parse(content);
        const paths = (_a2 = tsconfig == null ? void 0 : tsconfig.compilerOptions) == null ? void 0 : _a2.paths;
        if (!paths) {
          return;
        }
        for (const [alias, targets] of Object.entries(paths)) {
          if (Array.isArray(targets) && targets.length > 0) {
            const aliasPrefix = alias.replace(/\*$/, "");
            const targetPrefix = targets[0].replace(/\*$/, "").replace(/^\./, "");
            this.pathAliases.set(aliasPrefix, targetPrefix);
          }
        }
      } catch (e) {
      }
    }
    loadConfigStringValue(key, optionValue) {
      if (optionValue !== void 0) {
        let val = optionValue.startsWith("/") ? optionValue : `/${optionValue}`;
        if (val.endsWith("/")) val = val.slice(0, -1);
        return val;
      }
      try {
        const configFiles = [
          {
            path: "/next.config.ts",
            isTs: true
          },
          {
            path: "/next.config.js",
            isTs: false
          },
          {
            path: "/next.config.mjs",
            isTs: false
          }
        ];
        for (const { path: path2, isTs } of configFiles) {
          if (!this.vfs.existsSync(path2)) continue;
          const content = this.vfs.readFileSync(path2, "utf-8");
          const value2 = parseNextConfigValue(content, key, isTs);
          if (value2) {
            let normalized = value2.startsWith("/") ? value2 : `/${value2}`;
            if (normalized.endsWith("/")) normalized = normalized.slice(0, -1);
            return normalized;
          }
        }
      } catch {
      }
      return "";
    }
    loadAssetPrefix(optionValue) {
      this.assetPrefix = this.loadConfigStringValue("assetPrefix", optionValue);
    }
    loadBasePath(optionValue) {
      this.basePath = this.loadConfigStringValue("basePath", optionValue);
    }
    resolvePathAliases(code2, currentFile) {
      if (this.pathAliases.size === 0) {
        return code2;
      }
      const virtualBase = `/__virtual__/${this.port}`;
      let result = code2;
      for (const [alias, target] of this.pathAliases) {
        const aliasEscaped = alias.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const pattern = new RegExp(`(from\\s*['"]|import\\s*\\(\\s*['"])${aliasEscaped}([^'"]+)(['"])`, "g");
        result = result.replace(pattern, (match, prefix, path2, quote) => {
          const resolvedPath2 = `${virtualBase}${target}${path2}`;
          return `${prefix}${resolvedPath2}${quote}`;
        });
      }
      return result;
    }
    setEnv(key, value2) {
      this.options.env = this.options.env || {};
      this.options.env[key] = value2;
    }
    getEnv() {
      return {
        ...this.options.env
      };
    }
    setHMRTarget(targetWindow) {
      this.hmrTargetWindow = targetWindow;
    }
    generateEnvScript() {
      const env = this.options.env || {};
      const publicEnvVars = {};
      for (const [key, value2] of Object.entries(env)) {
        if (key.startsWith("NEXT_PUBLIC_")) {
          publicEnvVars[key] = value2;
        }
      }
      return `<script>
  // Environment variables (injected by NextDevServer)
  window.process = window.process || {};
  window.process.env = window.process.env || {};
  Object.assign(window.process.env, ${JSON.stringify(publicEnvVars)});
  // Next.js config values
  window.__NEXT_BASE_PATH__ = ${JSON.stringify(this.basePath)};
<\/script>`;
    }
    async loadTailwindConfigIfNeeded() {
      if (this.tailwindConfigLoaded) {
        return this.tailwindConfigScript;
      }
      try {
        const result = await loadTailwindConfig(this.vfs, this.root);
        if (result.success) {
          this.tailwindConfigScript = result.configScript;
        } else if (result.error) {
          console.warn("[NextDevServer] Tailwind config warning:", result.error);
          this.tailwindConfigScript = "";
        }
      } catch (error) {
        console.warn("[NextDevServer] Failed to load tailwind.config:", error);
        this.tailwindConfigScript = "";
      }
      this.tailwindConfigLoaded = true;
      return this.tailwindConfigScript;
    }
    async handleRequest(method, url2, headers, body) {
      const urlObj = new URL(url2, "http://localhost");
      let pathname = urlObj.pathname;
      const virtualPrefixMatch = pathname.match(/^\/__virtual__\/\d+/);
      if (virtualPrefixMatch) {
        pathname = pathname.slice(virtualPrefixMatch[0].length) || "/";
      }
      if (this.assetPrefix && pathname.startsWith(this.assetPrefix)) {
        const rest = pathname.slice(this.assetPrefix.length);
        if (rest === "" || rest.startsWith("/")) {
          pathname = rest || "/";
          if (pathname.startsWith("//")) {
            pathname = pathname.slice(1);
          }
        }
      }
      if (this.basePath && pathname.startsWith(this.basePath)) {
        const rest = pathname.slice(this.basePath.length);
        if (rest === "" || rest.startsWith("/")) {
          pathname = rest || "/";
        }
      }
      if (pathname.startsWith("/_next/shims/")) {
        return this.serveNextShim(pathname);
      }
      if (pathname === "/_next/route-info") {
        return this.serveRouteInfo(urlObj.searchParams.get("pathname") || "/");
      }
      if (pathname.startsWith("/_next/pages/")) {
        return this.servePageComponent(pathname);
      }
      if (pathname.startsWith("/_next/app/")) {
        return this.serveAppComponent(pathname);
      }
      if (pathname.startsWith("/_next/static/")) {
        return this.serveStaticAsset(pathname);
      }
      if (this.useAppRouter) {
        const appRouteFile = resolveAppRouteHandler(this.appDir, pathname, this.routeCtx);
        if (appRouteFile) {
          return this.handleAppRouteHandler(method, pathname, headers, body, appRouteFile, urlObj.search);
        }
      }
      if (pathname.startsWith("/api/")) {
        return this.handleApiRoute(method, pathname, headers, body);
      }
      const publicPath = this.publicDir + pathname;
      if (this.exists(publicPath) && !this.isDirectory(publicPath)) {
        return this.serveFile(publicPath);
      }
      if (needsTransform(pathname) && this.exists(pathname)) {
        return this.transformAndServe(pathname, pathname);
      }
      const resolvedFile = resolveFileWithExtension(pathname, this.routeCtx);
      if (resolvedFile) {
        if (needsTransform(resolvedFile)) {
          return this.transformAndServe(resolvedFile, pathname);
        }
        return this.serveFile(resolvedFile);
      }
      if (this.exists(pathname) && !this.isDirectory(pathname)) {
        return this.serveFile(pathname);
      }
      return this.handlePageRoute(pathname, urlObj.search);
    }
    serveNextShim(pathname) {
      const shimName = pathname.replace("/_next/shims/", "").replace(".js", "");
      let code2;
      switch (shimName) {
        case "link":
          code2 = NEXT_LINK_SHIM;
          break;
        case "router":
          code2 = NEXT_ROUTER_SHIM;
          break;
        case "head":
          code2 = NEXT_HEAD_SHIM;
          break;
        case "navigation":
          code2 = NEXT_NAVIGATION_SHIM;
          break;
        case "image":
          code2 = NEXT_IMAGE_SHIM;
          break;
        case "dynamic":
          code2 = NEXT_DYNAMIC_SHIM;
          break;
        case "script":
          code2 = NEXT_SCRIPT_SHIM;
          break;
        case "font/google":
          code2 = NEXT_FONT_GOOGLE_SHIM;
          break;
        case "font/local":
          code2 = NEXT_FONT_LOCAL_SHIM;
          break;
        default:
          return this.notFound(pathname);
      }
      const buffer2 = BufferPolyfill.from(code2);
      return {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "Content-Type": "application/javascript; charset=utf-8",
          "Content-Length": String(buffer2.length),
          "Cache-Control": "no-cache"
        },
        body: buffer2
      };
    }
    serveRouteInfo(pathname) {
      const route = resolveAppRoute(this.appDir, pathname, this.routeCtx);
      const info = route ? {
        params: route.params,
        found: true
      } : {
        params: {},
        found: false
      };
      const json = JSON.stringify(info);
      const buffer2 = BufferPolyfill.from(json);
      return {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "Content-Type": "application/json; charset=utf-8",
          "Content-Length": String(buffer2.length),
          "Cache-Control": "no-cache"
        },
        body: buffer2
      };
    }
    serveStaticAsset(pathname) {
      const filePath = pathname.replace("/_next/static/", "/");
      if (this.exists(filePath)) {
        return this.serveFile(filePath);
      }
      return this.notFound(pathname);
    }
    async servePageComponent(pathname) {
      const route = pathname.replace("/_next/pages", "").replace(/\.js$/, "");
      const pageFile = resolvePageFile(this.pagesDir, route, this.routeCtx);
      if (!pageFile) {
        return this.notFound(pathname);
      }
      return this.transformAndServe(pageFile, pageFile);
    }
    async serveAppComponent(pathname) {
      const rawFilePath = pathname.replace("/_next/app", "");
      if (this.exists(rawFilePath) && !this.isDirectory(rawFilePath)) {
        return this.transformAndServe(rawFilePath, rawFilePath);
      }
      const filePath = rawFilePath.replace(/\.js$/, "");
      const extensions = [
        ".tsx",
        ".jsx",
        ".ts",
        ".js"
      ];
      for (const ext of extensions) {
        const fullPath = filePath + ext;
        if (this.exists(fullPath)) {
          return this.transformAndServe(fullPath, fullPath);
        }
      }
      return this.notFound(pathname);
    }
    async handleApiRoute(method, pathname, headers, body) {
      const apiFile = resolveApiFile(this.pagesDir, pathname, this.routeCtx);
      if (!apiFile) {
        return {
          statusCode: 404,
          statusMessage: "Not Found",
          headers: {
            "Content-Type": "application/json; charset=utf-8"
          },
          body: BufferPolyfill.from(JSON.stringify({
            error: "API route not found"
          }))
        };
      }
      try {
        const code2 = this.vfs.readFileSync(apiFile, "utf8");
        const transformed = await this.transformApiHandler(code2, apiFile);
        const req = createMockRequest(method, pathname, headers, body);
        const res = createMockResponse();
        const builtins = await createBuiltinModules(() => Promise.resolve().then(() => fs).then((m) => m.createFsShim(this.vfs)));
        await executeApiHandler(transformed, req, res, this.options.env, builtins);
        if (!res.isEnded()) {
          const timeout = new Promise((_, reject) => {
            setTimeout(() => reject(new Error("API handler timeout")), 3e4);
          });
          await Promise.race([
            res.waitForEnd(),
            timeout
          ]);
        }
        return res.toResponse();
      } catch (error) {
        console.error("[NextDevServer] API error:", error);
        return {
          statusCode: 500,
          statusMessage: "Internal Server Error",
          headers: {
            "Content-Type": "application/json; charset=utf-8"
          },
          body: BufferPolyfill.from(JSON.stringify({
            error: error instanceof Error ? error.message : "Internal Server Error"
          }))
        };
      }
    }
    async handleAppRouteHandler(method, pathname, headers, body, routeFile, search) {
      try {
        const code2 = this.vfs.readFileSync(routeFile, "utf8");
        const transformed = await this.transformApiHandler(code2, routeFile);
        const builtinModules2 = await createBuiltinModules();
        const require2 = (id) => {
          const modId = id.startsWith("node:") ? id.slice(5) : id;
          if (builtinModules2[modId]) return builtinModules2[modId];
          throw new Error(`Module not found: ${id}`);
        };
        const moduleObj = {
          exports: {}
        };
        const exports$1 = moduleObj.exports;
        const process2 = {
          env: {
            ...this.options.env
          },
          cwd: () => "/",
          platform: "browser",
          version: "v18.0.0",
          versions: {
            node: "18.0.0"
          }
        };
        const fn2 = new Function("exports", "require", "module", "process", transformed);
        fn2(exports$1, require2, moduleObj, process2);
        const methodUpper = method.toUpperCase();
        const handler = moduleObj.exports[methodUpper] || moduleObj.exports[methodUpper.toLowerCase()];
        if (typeof handler !== "function") {
          return {
            statusCode: 405,
            statusMessage: "Method Not Allowed",
            headers: {
              "Content-Type": "application/json; charset=utf-8"
            },
            body: BufferPolyfill.from(JSON.stringify({
              error: `Method ${method} not allowed`
            }))
          };
        }
        const requestUrl = new URL(pathname + (search || ""), "http://localhost");
        const requestInit = {
          method: methodUpper,
          headers: new Headers(headers)
        };
        if (body && methodUpper !== "GET" && methodUpper !== "HEAD") {
          requestInit.body = body;
        }
        const request2 = new Request(requestUrl.toString(), requestInit);
        const route = resolveAppRoute(this.appDir, pathname, this.routeCtx);
        const params = (route == null ? void 0 : route.params) || {};
        const response = await handler(request2, {
          params: Promise.resolve(params)
        });
        if (response instanceof Response) {
          const respHeaders = {};
          response.headers.forEach((value2, key) => {
            respHeaders[key] = value2;
          });
          const respBody = await response.text();
          return {
            statusCode: response.status,
            statusMessage: response.statusText || "OK",
            headers: respHeaders,
            body: BufferPolyfill.from(respBody)
          };
        }
        if (response && typeof response === "object") {
          const json = JSON.stringify(response);
          return {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
              "Content-Type": "application/json; charset=utf-8"
            },
            body: BufferPolyfill.from(json)
          };
        }
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "text/plain; charset=utf-8"
          },
          body: BufferPolyfill.from(String(response || ""))
        };
      } catch (error) {
        console.error("[NextDevServer] App Route handler error:", error);
        return {
          statusCode: 500,
          statusMessage: "Internal Server Error",
          headers: {
            "Content-Type": "application/json; charset=utf-8"
          },
          body: BufferPolyfill.from(JSON.stringify({
            error: error instanceof Error ? error.message : "Internal Server Error"
          }))
        };
      }
    }
    async handleStreamingRequest(method, url2, headers, body, onStart, onChunk, onEnd) {
      const urlObj = new URL(url2, "http://localhost");
      const pathname = urlObj.pathname;
      if (!pathname.startsWith("/api/")) {
        onStart(404, "Not Found", {
          "Content-Type": "application/json"
        });
        onChunk(JSON.stringify({
          error: "Not found"
        }));
        onEnd();
        return;
      }
      const apiFile = resolveApiFile(this.pagesDir, pathname, this.routeCtx);
      if (!apiFile) {
        onStart(404, "Not Found", {
          "Content-Type": "application/json"
        });
        onChunk(JSON.stringify({
          error: "API route not found"
        }));
        onEnd();
        return;
      }
      try {
        const code2 = this.vfs.readFileSync(apiFile, "utf8");
        const transformed = await this.transformApiHandler(code2, apiFile);
        const req = createMockRequest(method, pathname, headers, body);
        const res = createStreamingMockResponse(onStart, onChunk, onEnd);
        const builtins = await createBuiltinModules(() => Promise.resolve().then(() => fs).then((m) => m.createFsShim(this.vfs)));
        await executeApiHandler(transformed, req, res, this.options.env, builtins);
        if (!res.isEnded()) {
          const timeout = new Promise((_, reject) => {
            setTimeout(() => reject(new Error("API handler timeout")), 3e4);
          });
          await Promise.race([
            res.waitForEnd(),
            timeout
          ]);
        }
      } catch (error) {
        console.error("[NextDevServer] Streaming API error:", error);
        onStart(500, "Internal Server Error", {
          "Content-Type": "application/json"
        });
        onChunk(JSON.stringify({
          error: error instanceof Error ? error.message : "Internal Server Error"
        }));
        onEnd();
      }
    }
    async handlePageRoute(pathname, search) {
      if (this.useAppRouter) {
        return this.handleAppRouterPage(pathname, search);
      }
      const pageFile = resolvePageFile(this.pagesDir, pathname, this.routeCtx);
      if (!pageFile) {
        const notFoundPage = resolvePageFile(this.pagesDir, "/404", this.routeCtx);
        if (notFoundPage) {
          const html2 = await this.generatePageHtml(notFoundPage, "/404");
          return {
            statusCode: 404,
            statusMessage: "Not Found",
            headers: {
              "Content-Type": "text/html; charset=utf-8"
            },
            body: BufferPolyfill.from(html2)
          };
        }
        return this.serve404Page();
      }
      if (needsTransform(pathname)) {
        return this.transformAndServe(pageFile, pathname);
      }
      const html = await this.generatePageHtml(pageFile, pathname);
      const buffer2 = BufferPolyfill.from(html);
      return {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "Content-Type": "text/html; charset=utf-8",
          "Content-Length": String(buffer2.length),
          "Cache-Control": "no-cache"
        },
        body: buffer2
      };
    }
    async handleAppRouterPage(pathname, search) {
      const route = resolveAppRoute(this.appDir, pathname, this.routeCtx);
      if (!route) {
        const notFoundRoute = resolveAppRoute(this.appDir, "/not-found", this.routeCtx);
        if (notFoundRoute) {
          const html2 = await this.generateAppRouterHtml(notFoundRoute, "/not-found");
          return {
            statusCode: 404,
            statusMessage: "Not Found",
            headers: {
              "Content-Type": "text/html; charset=utf-8"
            },
            body: BufferPolyfill.from(html2)
          };
        }
        return this.serve404Page();
      }
      const html = await this.generateAppRouterHtml(route, pathname);
      const buffer2 = BufferPolyfill.from(html);
      return {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "Content-Type": "text/html; charset=utf-8",
          "Content-Length": String(buffer2.length),
          "Cache-Control": "no-cache"
        },
        body: buffer2
      };
    }
    htmlContext() {
      return {
        port: this.port,
        exists: (path2) => this.exists(path2),
        generateEnvScript: () => this.generateEnvScript(),
        loadTailwindConfigIfNeeded: () => this.loadTailwindConfigIfNeeded()
      };
    }
    async generateAppRouterHtml(route, pathname) {
      return generateAppRouterHtml(this.htmlContext(), route, pathname);
    }
    async generatePageHtml(pageFile, pathname) {
      return generatePageHtml(this.htmlContext());
    }
    serve404Page() {
      return serve404Page(this.port);
    }
    async transformAndServe(filePath, urlPath) {
      try {
        const content = this.vfs.readFileSync(filePath, "utf8");
        const hash = simpleHash(content);
        const cached = this.transformCache.get(filePath);
        if (cached && cached.hash === hash) {
          const buffer22 = BufferPolyfill.from(cached.code);
          return {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
              "Content-Type": "application/javascript; charset=utf-8",
              "Content-Length": String(buffer22.length),
              "Cache-Control": "no-cache",
              "X-Transformed": "true",
              "X-Cache": "hit"
            },
            body: buffer22
          };
        }
        const transformed = await this.transformCode(content, filePath);
        this.transformCache.set(filePath, {
          code: transformed,
          hash
        });
        if (this.transformCache.size > 500) {
          const firstKey = this.transformCache.keys().next().value;
          if (firstKey) this.transformCache.delete(firstKey);
        }
        const buffer2 = BufferPolyfill.from(transformed);
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "application/javascript; charset=utf-8",
            "Content-Length": String(buffer2.length),
            "Cache-Control": "no-cache",
            "X-Transformed": "true"
          },
          body: buffer2
        };
      } catch (error) {
        console.error("[NextDevServer] Transform error:", error);
        const message = error instanceof Error ? error.message : "Transform failed";
        const body = `// Transform Error: ${message}
console.error(${JSON.stringify(message)});`;
        return {
          statusCode: 200,
          statusMessage: "OK",
          headers: {
            "Content-Type": "application/javascript; charset=utf-8",
            "X-Transform-Error": "true"
          },
          body: BufferPolyfill.from(body)
        };
      }
    }
    async transformCode(code2, filename2) {
      if (!isBrowser) {
        return this.stripCssImports(code2, filename2);
      }
      await initEsbuild();
      const esbuild2 = getEsbuild();
      if (!esbuild2) {
        throw new Error("esbuild not available");
      }
      const codeWithoutCssImports = this.stripCssImports(code2, filename2);
      const codeWithResolvedAliases = this.resolvePathAliases(codeWithoutCssImports, filename2);
      let loader = "js";
      if (filename2.endsWith(".jsx")) loader = "jsx";
      else if (filename2.endsWith(".tsx")) loader = "tsx";
      else if (filename2.endsWith(".ts")) loader = "ts";
      const result = await esbuild2.transform(codeWithResolvedAliases, {
        loader,
        format: "esm",
        target: "esnext",
        jsx: "automatic",
        jsxImportSource: "react",
        sourcemap: "inline",
        sourcefile: filename2
      });
      const codeWithCdnImports = this.redirectNpmImports(result.code);
      if (/\.(jsx|tsx)$/.test(filename2)) {
        return this.addReactRefresh(codeWithCdnImports, filename2);
      }
      return codeWithCdnImports;
    }
    redirectNpmImports(code2) {
      return redirectNpmImports(code2);
    }
    stripCssImports(code2, currentFile) {
      return stripCssImports(code2, currentFile, this.getCssModuleContext());
    }
    getCssModuleContext() {
      return {
        readFile: (path2) => this.vfs.readFileSync(path2, "utf-8"),
        exists: (path2) => this.exists(path2)
      };
    }
    async transformApiHandler(code2, filename2) {
      const codeWithResolvedAliases = this.resolvePathAliases(code2, filename2);
      if (isBrowser) {
        await initEsbuild();
        const esbuild2 = getEsbuild();
        if (!esbuild2) {
          throw new Error("esbuild not available");
        }
        let loader = "js";
        if (filename2.endsWith(".jsx")) loader = "jsx";
        else if (filename2.endsWith(".tsx")) loader = "tsx";
        else if (filename2.endsWith(".ts")) loader = "ts";
        const result = await esbuild2.transform(codeWithResolvedAliases, {
          loader,
          format: "cjs",
          target: "esnext",
          platform: "neutral",
          sourcefile: filename2
        });
        return result.code;
      }
      return transformEsmToCjsSimple(codeWithResolvedAliases);
    }
    addReactRefresh(code2, filename2) {
      return addReactRefresh(code2, filename2);
    }
    startWatching() {
      const watchers = [];
      try {
        const pagesWatcher = this.vfs.watch(this.pagesDir, {
          recursive: true
        }, (eventType, filename2) => {
          if (eventType === "change" && filename2) {
            const fullPath = filename2.startsWith("/") ? filename2 : `${this.pagesDir}/${filename2}`;
            this.handleFileChange(fullPath);
          }
        });
        watchers.push(pagesWatcher);
      } catch (error) {
        console.warn("[NextDevServer] Could not watch pages directory:", error);
      }
      if (this.useAppRouter) {
        try {
          const appWatcher = this.vfs.watch(this.appDir, {
            recursive: true
          }, (eventType, filename2) => {
            if (eventType === "change" && filename2) {
              const fullPath = filename2.startsWith("/") ? filename2 : `${this.appDir}/${filename2}`;
              this.handleFileChange(fullPath);
            }
          });
          watchers.push(appWatcher);
        } catch (error) {
          console.warn("[NextDevServer] Could not watch app directory:", error);
        }
      }
      try {
        const publicWatcher = this.vfs.watch(this.publicDir, {
          recursive: true
        }, (eventType, filename2) => {
          if (eventType === "change" && filename2) {
            this.handleFileChange(`${this.publicDir}/${filename2}`);
          }
        });
        watchers.push(publicWatcher);
      } catch {
      }
      this.watcherCleanup = () => {
        watchers.forEach((w) => w.close());
      };
    }
    handleFileChange(path2) {
      const isCSS = path2.endsWith(".css");
      const isJS = /\.(jsx?|tsx?)$/.test(path2);
      const updateType = isCSS || isJS ? "update" : "full-reload";
      const update = {
        type: updateType,
        path: path2,
        timestamp: Date.now()
      };
      this.emitHMRUpdate(update);
      if (this.hmrTargetWindow) {
        try {
          this.hmrTargetWindow.postMessage({
            ...update,
            channel: "next-hmr"
          }, "*");
        } catch (e) {
        }
      }
    }
    serveFile(filePath) {
      if (filePath.endsWith(".json")) {
        try {
          const normalizedPath = this.resolvePath(filePath);
          const content = this.vfs.readFileSync(normalizedPath);
          let jsonContent;
          if (typeof content === "string") {
            jsonContent = content;
          } else if (content instanceof Uint8Array) {
            jsonContent = new TextDecoder("utf-8").decode(content);
          } else {
            jsonContent = BufferPolyfill.from(content).toString("utf-8");
          }
          const esModuleContent = `export default ${jsonContent};`;
          const buffer2 = BufferPolyfill.from(esModuleContent);
          return {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
              "Content-Type": "application/javascript; charset=utf-8",
              "Content-Length": String(buffer2.length),
              "Cache-Control": "no-cache"
            },
            body: buffer2
          };
        } catch (error) {
          if (error.code === "ENOENT") {
            return this.notFound(filePath);
          }
          return this.serverError(error);
        }
      }
      return super.serveFile(filePath);
    }
    resolvePath(urlPath) {
      let path2 = urlPath.split("?")[0].split("#")[0];
      if (!path2.startsWith("/")) {
        path2 = "/" + path2;
      }
      if (this.root !== "/") {
        path2 = this.root + path2;
      }
      return path2;
    }
    stop() {
      if (this.watcherCleanup) {
        this.watcherCleanup();
        this.watcherCleanup = null;
      }
      this.hmrTargetWindow = null;
      super.stop();
    }
  };
  PACKAGE_JSON = {
    name: "convex-app-demo",
    version: "0.1.0",
    private: true,
    scripts: {
      dev: "next dev",
      build: "next build",
      start: "next start"
    },
    dependencies: {
      "next": "^14.0.0",
      "react": "^18.2.0",
      "react-dom": "^18.2.0",
      "clsx": "^2.1.1",
      "tailwind-merge": "^3.1.0",
      "lucide-react": "^0.400.0",
      "zod": "^3.24.2",
      "date-fns": "^3.6.0"
    },
    devDependencies: {
      "@types/node": "^20",
      "@types/react": "^19",
      "@types/react-dom": "^19",
      "typescript": "^5.9.3"
    }
  };
  DEMO_PACKAGES = [
    "clsx",
    "tailwind-merge",
    "zod",
    "date-fns"
  ];
  createConvexAppProject = function(vfs2) {
    vfs2.writeFileSync("/package.json", JSON.stringify(PACKAGE_JSON, null, 2));
    vfs2.mkdirSync("/app", {
      recursive: true
    });
    vfs2.mkdirSync("/app/api", {
      recursive: true
    });
    vfs2.mkdirSync("/app/tasks", {
      recursive: true
    });
    vfs2.mkdirSync("/components", {
      recursive: true
    });
    vfs2.mkdirSync("/components/ui", {
      recursive: true
    });
    vfs2.mkdirSync("/lib", {
      recursive: true
    });
    vfs2.mkdirSync("/convex", {
      recursive: true
    });
    vfs2.mkdirSync("/public", {
      recursive: true
    });
    vfs2.writeFileSync("/convex.json", JSON.stringify({
      functions: "convex/"
    }, null, 2));
    vfs2.writeFileSync("/tsconfig.json", JSON.stringify({
      compilerOptions: {
        target: "es5",
        lib: [
          "dom",
          "dom.iterable",
          "esnext"
        ],
        allowJs: true,
        skipLibCheck: true,
        strict: true,
        noEmit: true,
        esModuleInterop: true,
        module: "esnext",
        moduleResolution: "bundler",
        resolveJsonModule: true,
        isolatedModules: true,
        jsx: "preserve",
        incremental: true,
        paths: {
          "@/*": [
            "./*"
          ]
        }
      },
      include: [
        "**/*.ts",
        "**/*.tsx"
      ],
      exclude: [
        "node_modules"
      ]
    }, null, 2));
    vfs2.writeFileSync("/tailwind.config.js", `/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [],
}
`);
    vfs2.writeFileSync("/app/globals.css", `@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
`);
    vfs2.writeFileSync("/lib/utils.ts", `// Utility functions
// Note: In production, use clsx and tailwind-merge packages

export function cn(...inputs: (string | undefined | null | false)[]) {
  return inputs.filter(Boolean).join(' ');
}
`);
    vfs2.writeFileSync("/convex/convex.config.ts", `import { defineApp } from "convex/server";

const app = defineApp();
export default app;
`);
    vfs2.writeFileSync("/convex/convex.config.js", `import { defineApp } from "convex/server";

const app = defineApp();
export default app;
`);
    vfs2.writeFileSync("/convex/schema.ts", `import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  todos: defineTable({
    title: v.string(),
    completed: v.boolean(),
    priority: v.union(v.literal("low"), v.literal("medium"), v.literal("high")),
  }),
});
`);
    vfs2.writeFileSync("/convex/todos.ts", `import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

export const list = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("todos").order("desc").collect();
  },
});

export const create = mutation({
  args: {
    title: v.string(),
    priority: v.union(v.literal("low"), v.literal("medium"), v.literal("high")),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("todos", {
      title: args.title,
      completed: false,
      priority: args.priority,
    });
  },
});

export const toggle = mutation({
  args: { id: v.id("todos") },
  handler: async (ctx, args) => {
    const todo = await ctx.db.get(args.id);
    if (!todo) throw new Error("Todo not found");
    await ctx.db.patch(args.id, { completed: !todo.completed });
  },
});

export const remove = mutation({
  args: { id: v.id("todos") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
  },
});
`);
    vfs2.writeFileSync("/convex/_generated/api.ts", `// Convex API - manually created for browser demo
// In a real project, this is auto-generated by 'npx convex dev'

// Function references for the Convex client
// These are string identifiers that map to server functions
export const api = {
  todos: {
    list: "todos:list",
    create: "todos:create",
    toggle: "todos:toggle",
    remove: "todos:remove",
  },
} as const;
`);
    vfs2.writeFileSync("/convex/_generated/server.ts", `// Server stubs for browser demo
// In a real project, this is auto-generated by Convex

export function query<Args, Output>(config: {
  args: Args;
  handler: (ctx: any, args: any) => Promise<Output>;
}) {
  return config;
}

export function mutation<Args, Output>(config: {
  args: Args;
  handler: (ctx: any, args: any) => Promise<Output>;
}) {
  return config;
}
`);
    vfs2.writeFileSync("/lib/convex.tsx", `"use client";

import React, { useState, useEffect } from 'react';
import { ConvexProvider as BaseConvexProvider, ConvexReactClient, useQuery as useConvexQuery, useMutation as useConvexMutation } from 'convex/react';

// Re-export the API
export { api } from '../convex/_generated/api.ts';

// Get Convex URL using standard Next.js env var pattern
// Falls back to window.__CONVEX_URL__ for backwards compatibility
const getConvexUrl = () => {
  // Standard Next.js pattern: process.env.NEXT_PUBLIC_*
  if (typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_CONVEX_URL) {
    return process.env.NEXT_PUBLIC_CONVEX_URL;
  }
  // Fallback for backwards compatibility
  if (typeof window !== 'undefined' && (window as any).__CONVEX_URL__) {
    return (window as any).__CONVEX_URL__;
  }
  return null;
};

// Create client lazily
let client: ConvexReactClient | null = null;

function getClient() {
  const url = getConvexUrl();
  if (!url) return null;
  if (!client || (client as any)._address !== url) {
    client = new ConvexReactClient(url);
  }
  return client;
}

// Wrapper hooks that handle the case when Convex is not connected
export function useQuery(query: any, ...args: any[]) {
  const url = getConvexUrl();
  // When not connected, return undefined
  if (!url) return undefined;
  return useConvexQuery(query, ...args);
}

export function useMutation(mutation: any) {
  const url = getConvexUrl();
  const convexMutation = url ? useConvexMutation(mutation) : null;

  return async (args: any) => {
    if (!convexMutation) {
      console.warn('Convex not connected - mutation ignored');
      return;
    }
    return convexMutation(args);
  };
}

export function ConvexProvider({ children }: { children: React.ReactNode }) {
  const [convexUrl, setConvexUrl] = useState(getConvexUrl());

  // Check for URL changes (after deploy)
  useEffect(() => {
    const checkUrl = () => {
      const url = getConvexUrl();
      if (url !== convexUrl) {
        setConvexUrl(url);
      }
    };

    // Check periodically for URL changes
    const interval = setInterval(checkUrl, 1000);
    return () => clearInterval(interval);
  }, [convexUrl]);

  const convexClient = getClient();

  if (!convexClient) {
    // Show a message when Convex is not configured
    return (
      <div className="min-h-screen bg-background font-sans antialiased">
        <div className="flex flex-col items-center justify-center min-h-screen p-8 text-center">
          <div className="max-w-md space-y-4">
            <h2 className="text-2xl font-bold">Connect to Convex</h2>
            <p className="text-muted-foreground">
              Enter your Convex deploy key in the console panel and click "Deploy Schema" to connect.
            </p>
            <div className="p-4 bg-muted rounded-lg text-left text-sm">
              <p className="font-medium mb-2">Files ready in /convex/:</p>
              <ul className="space-y-1 text-muted-foreground">
                <li>schema.ts - Database schema (todos table)</li>
                <li>todos.ts - Query and mutation functions</li>
              </ul>
            </div>
            <p className="text-xs text-muted-foreground">
              Get a deploy key from your Convex dashboard at convex.dev
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <BaseConvexProvider client={convexClient}>
      {children}
    </BaseConvexProvider>
  );
}
`);
    vfs2.writeFileSync("/components/ui/button.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

const buttonVariants = {
  default: "bg-primary text-primary-foreground hover:bg-primary/90",
  destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
  outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
  secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
  ghost: "hover:bg-accent hover:text-accent-foreground",
  link: "text-primary underline-offset-4 hover:underline",
};

const buttonSizes = {
  default: "h-10 px-4 py-2",
  sm: "h-9 rounded-md px-3",
  lg: "h-11 rounded-md px-8",
  icon: "h-10 w-10",
};

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: keyof typeof buttonVariants;
  size?: keyof typeof buttonSizes;
}

export function Button({
  className,
  variant = "default",
  size = "default",
  ...props
}: ButtonProps) {
  return (
    <button
      className={cn(
        "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
        buttonVariants[variant],
        buttonSizes[size],
        className
      )}
      {...props}
    />
  );
}
`);
    vfs2.writeFileSync("/components/ui/card.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

export function Card({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn(
        "rounded-lg border bg-card text-card-foreground shadow-sm",
        className
      )}
      {...props}
    />
  );
}

export function CardHeader({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("flex flex-col space-y-1.5 p-6", className)}
      {...props}
    />
  );
}

export function CardTitle({
  className,
  ...props
}: React.HTMLAttributes<HTMLHeadingElement>) {
  return (
    <h3
      className={cn("text-2xl font-semibold leading-none tracking-tight", className)}
      {...props}
    />
  );
}

export function CardDescription({
  className,
  ...props
}: React.HTMLAttributes<HTMLParagraphElement>) {
  return (
    <p
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  );
}

export function CardContent({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return <div className={cn("p-6 pt-0", className)} {...props} />;
}

export function CardFooter({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("flex items-center p-6 pt-0", className)}
      {...props}
    />
  );
}
`);
    vfs2.writeFileSync("/components/ui/input.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}

export function Input({ className, type, ...props }: InputProps) {
  return (
    <input
      type={type}
      className={cn(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  );
}
`);
    vfs2.writeFileSync("/components/ui/badge.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

const badgeVariants = {
  default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
  secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
  destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
  outline: "text-foreground",
  success: "border-transparent bg-green-500 text-white",
  warning: "border-transparent bg-yellow-500 text-white",
};

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: keyof typeof badgeVariants;
}

export function Badge({ className, variant = "default", ...props }: BadgeProps) {
  return (
    <div
      className={cn(
        "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
        badgeVariants[variant],
        className
      )}
      {...props}
    />
  );
}
`);
    vfs2.writeFileSync("/components/ui/checkbox.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

export interface CheckboxProps extends React.InputHTMLAttributes<HTMLInputElement> {
  onCheckedChange?: (checked: boolean) => void;
}

export function Checkbox({ className, checked, onCheckedChange, ...props }: CheckboxProps) {
  return (
    <input
      type="checkbox"
      checked={checked}
      onChange={(e) => onCheckedChange?.(e.target.checked)}
      className={cn(
        "h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        className
      )}
      {...props}
    />
  );
}
`);
    vfs2.writeFileSync("/components/ui/select.tsx", `import React from 'react';
import { cn } from '../../lib/utils.ts';

export interface SelectProps extends React.SelectHTMLAttributes<HTMLSelectElement> {}

export function Select({ className, children, ...props }: SelectProps) {
  return (
    <select
      className={cn(
        "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      {children}
    </select>
  );
}
`);
    vfs2.writeFileSync("/components/task-list.tsx", `"use client";

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from './ui/card.tsx';
import { Button } from './ui/button.tsx';
import { Input } from './ui/input.tsx';
import { Badge } from './ui/badge.tsx';
import { Checkbox } from './ui/checkbox.tsx';
import { Select } from './ui/select.tsx';
import { useQuery, useMutation, api } from '../lib/convex.tsx';
import { cn } from '../lib/utils.ts';

type Todo = {
  _id: string;
  _creationTime: number;
  title: string;
  completed: boolean;
  priority: "low" | "medium" | "high";
};

const priorityColors = {
  low: "success" as const,
  medium: "warning" as const,
  high: "destructive" as const,
};

function TaskItem({
  task,
  onToggle,
  onDelete
}: {
  task: Todo;
  onToggle: () => void;
  onDelete: () => void;
}) {
  return (
    <div className={cn(
      "flex items-center gap-4 p-4 border rounded-lg transition-all",
      task.completed && "opacity-50 bg-muted"
    )}>
      <Checkbox
        checked={task.completed}
        onCheckedChange={onToggle}
      />
      <div className="flex-1 min-w-0">
        <p className={cn(
          "font-medium truncate",
          task.completed && "line-through text-muted-foreground"
        )}>
          {task.title}
        </p>
        <p className="text-xs text-muted-foreground">
          Created {new Date(task._creationTime).toLocaleDateString()}
        </p>
      </div>
      <Badge variant={priorityColors[task.priority]}>
        {task.priority}
      </Badge>
      <Button
        variant="ghost"
        size="sm"
        onClick={onDelete}
        className="text-destructive hover:text-destructive"
      >
        Delete
      </Button>
    </div>
  );
}

export function TaskList() {
  const todos = useQuery(api.todos.list) as Todo[] | undefined;
  const createTodo = useMutation(api.todos.create);
  const toggleTodo = useMutation(api.todos.toggle);
  const removeTodo = useMutation(api.todos.remove);

  const [newTitle, setNewTitle] = React.useState("");
  const [priority, setPriority] = React.useState<Todo["priority"]>("medium");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newTitle.trim()) return;

    await createTodo({ title: newTitle.trim(), priority });
    setNewTitle("");
  };

  const completedCount = todos?.filter(t => t.completed).length ?? 0;
  const totalCount = todos?.length ?? 0;

  return (
    <Card className="w-full max-w-2xl mx-auto">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          Task Manager
          <Badge variant="secondary">
            {completedCount}/{totalCount} done
          </Badge>
        </CardTitle>
        <CardDescription>
          Real-time sync powered by Convex - running from the browser!
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <form onSubmit={handleSubmit} className="flex gap-2">
          <Input
            placeholder="Add a new task..."
            value={newTitle}
            onChange={(e) => setNewTitle(e.target.value)}
            className="flex-1"
          />
          <Select
            value={priority}
            onChange={(e) => setPriority(e.target.value as Todo["priority"])}
            className="w-32"
          >
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
          </Select>
          <Button type="submit">Add Task</Button>
        </form>

        <div className="space-y-2">
          {todos === undefined ? (
            <div className="text-center py-8 text-muted-foreground">
              Loading tasks...
            </div>
          ) : todos.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              No tasks yet. Add one above!
            </div>
          ) : (
            todos.map((task) => (
              <TaskItem
                key={task._id}
                task={task}
                onToggle={() => toggleTodo({ id: task._id })}
                onDelete={() => removeTodo({ id: task._id })}
              />
            ))
          )}
        </div>
      </CardContent>
    </Card>
  );
}
`);
    vfs2.writeFileSync("/app/layout.tsx", `import React from 'react';
import './globals.css';
import { ConvexProvider } from '../lib/convex.tsx';

export const metadata = {
  title: 'Convex App Demo',
  description: 'A realistic Next.js + Convex app running in the browser',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <ConvexProvider>
      <div className="min-h-screen bg-background font-sans antialiased">
        <div className="relative flex min-h-screen flex-col">
          <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
            <div className="container flex h-14 items-center">
              <div className="mr-4 flex">
                <a href="/" className="mr-6 flex items-center space-x-2">
                  <span className="font-bold text-xl">TaskApp</span>
                </a>
                <nav className="flex items-center space-x-6 text-sm font-medium">
                  <a href="/" className="transition-colors hover:text-foreground/80 text-foreground">
                    Home
                  </a>
                  <a href="/tasks" className="transition-colors hover:text-foreground/80 text-muted-foreground">
                    Tasks
                  </a>
                  <a href="/about" className="transition-colors hover:text-foreground/80 text-muted-foreground">
                    About
                  </a>
                </nav>
              </div>
            </div>
          </header>
          <main className="flex-1">
            {children}
          </main>
          <footer className="border-t py-6 md:py-0">
            <div className="container flex flex-col items-center justify-between gap-4 md:h-14 md:flex-row">
              <p className="text-center text-sm leading-loose text-muted-foreground">
                Running in browser with virtual Node.js
              </p>
            </div>
          </footer>
        </div>
      </div>
    </ConvexProvider>
  );
}
`);
    vfs2.writeFileSync("/app/page.tsx", `"use client";

import React from 'react';
import { TaskList } from '../components/task-list.tsx';

export default function HomePage() {
  return (
    <div className="container py-10">
      <div className="mb-8 text-center">
        <h1 className="text-3xl font-bold tracking-tight">Task Manager</h1>
        <p className="text-muted-foreground mt-2">
          Real-time sync powered by Convex - running in the browser!
        </p>
      </div>
      <TaskList />
    </div>
  );
}
`);
    vfs2.writeFileSync("/app/features/page.tsx", `import React from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../../components/ui/card.tsx';
import { Button } from '../../components/ui/button.tsx';
import { Badge } from '../../components/ui/badge.tsx';

export default function FeaturesPage() {
  return (
    <div className="container py-10">
      {/* Feature Cards */}
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u26A1 React 18
            </CardTitle>
            <CardDescription>
              Latest React with Concurrent features
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Using React 18 with automatic batching, Suspense,
              and concurrent rendering for optimal performance.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u{1F3A8} shadcn/ui
            </CardTitle>
            <CardDescription>
              Beautiful, accessible components
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Beautifully designed components built with Radix UI
              primitives and Tailwind CSS.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u{1F504} Convex (Mock)
            </CardTitle>
            <CardDescription>
              Real-time data sync simulation
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Demonstrates the Convex pattern with useQuery and
              useMutation hooks using mock data.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u{1F3AF} TypeScript
            </CardTitle>
            <CardDescription>
              Full type safety
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Written in TypeScript with strict mode enabled
              for maximum type safety and developer experience.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u{1F4F1} Responsive
            </CardTitle>
            <CardDescription>
              Mobile-first design
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Fully responsive design that works great on any device,
              from mobile phones to desktop monitors.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              \u{1F310} Browser Runtime
            </CardTitle>
            <CardDescription>
              No server required
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Running entirely in the browser using virtual Node.js
              shims and Service Workers.
            </p>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
`);
    vfs2.mkdirSync("/app/features", {
      recursive: true
    });
    vfs2.writeFileSync("/app/tasks/page.tsx", `"use client";

import React from 'react';
import { TaskList } from '../../components/task-list.tsx';

export default function TasksPage() {
  return (
    <div className="container py-10">
      <div className="mb-8 text-center">
        <h1 className="text-3xl font-bold tracking-tight">Task Manager</h1>
        <p className="text-muted-foreground mt-2">
          Add, complete, and manage your tasks
        </p>
      </div>
      <TaskList />
    </div>
  );
}
`);
    vfs2.writeFileSync("/app/about/page.tsx", `import React from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../../components/ui/card.tsx';
import { Badge } from '../../components/ui/badge.tsx';

export default function AboutPage() {
  return (
    <div className="container py-10 max-w-3xl">
      <div className="mb-8">
        <Badge variant="outline" className="mb-4">About</Badge>
        <h1 className="text-3xl font-bold tracking-tight">How It Works</h1>
        <p className="text-muted-foreground mt-2">
          This demo showcases running a complex Next.js application entirely in the browser.
        </p>
      </div>

      <div className="space-y-6">
        <Card>
          <CardHeader>
            <CardTitle>Virtual File System</CardTitle>
            <CardDescription>In-memory file system simulation</CardDescription>
          </CardHeader>
          <CardContent className="prose prose-sm">
            <p>
              All project files exist in a virtual file system (VFS) in memory.
              This includes React components, configuration files, and even
              npm package contents.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Node.js Shims</CardTitle>
            <CardDescription>Browser-compatible Node.js APIs</CardDescription>
          </CardHeader>
          <CardContent className="prose prose-sm">
            <p>
              Core Node.js modules like <code>fs</code>, <code>path</code>, <code>crypto</code>,
              <code>stream</code>, and <code>http</code> are shimmed to work in the browser
              using Web APIs.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>esbuild-wasm</CardTitle>
            <CardDescription>Fast JSX/TypeScript compilation</CardDescription>
          </CardHeader>
          <CardContent className="prose prose-sm">
            <p>
              JSX and TypeScript files are transformed to JavaScript in real-time
              using esbuild-wasm, which runs WebAssembly in the browser.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Service Worker</CardTitle>
            <CardDescription>Request interception and routing</CardDescription>
          </CardHeader>
          <CardContent className="prose prose-sm">
            <p>
              A Service Worker intercepts HTTP requests and routes them to the
              virtual dev server, enabling file-based routing without a real backend.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Convex Mock</CardTitle>
            <CardDescription>Simulated real-time database</CardDescription>
          </CardHeader>
          <CardContent className="prose prose-sm">
            <p>
              The Convex client is mocked to demonstrate the pattern of using
              <code>useQuery</code> and <code>useMutation</code> hooks. In production,
              this would connect to a real Convex backend.
            </p>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
`);
    vfs2.writeFileSync("/pages/api/health.js", `export default function handler(req, res) {
  res.status(200).json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    runtime: 'browser-node-shim'
  });
}
`);
    vfs2.writeFileSync("/public/favicon.ico", "favicon placeholder");
    vfs2.writeFileSync("/public/robots.txt", "User-agent: *\nAllow: /");
  };
  initConvexAppDemo = async function(outputElement, options2 = {}) {
    const log = (message) => {
      const line = document.createElement("div");
      line.textContent = `[${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`;
      outputElement.appendChild(line);
      outputElement.scrollTop = outputElement.scrollHeight;
    };
    log("Creating virtual file system...");
    const vfs2 = new VirtualFS();
    log("Creating Convex App project structure...");
    createConvexAppProject(vfs2);
    if (options2.installPackages) {
      log("Installing npm packages (this may take a while)...");
      const npm = new PackageManager(vfs2);
      for (const pkg of DEMO_PACKAGES) {
        try {
          log(`Installing ${pkg}...`);
          await npm.install(pkg, {
            onProgress: (msg) => log(`  ${msg}`)
          });
        } catch (error) {
          log(`Warning: Failed to install ${pkg}: ${error}`);
        }
      }
    }
    log("Initializing runtime...");
    const runtime = new Runtime(vfs2, {
      cwd: "/",
      env: {
        NODE_ENV: "development"
      },
      onConsole: (method, args) => {
        const prefix = method === "error" ? "[ERROR]" : method === "warn" ? "[WARN]" : "";
        log(`${prefix} ${args.map((a) => String(a)).join(" ")}`);
      }
    });
    log("Setting up file watcher...");
    vfs2.watch("/app", {
      recursive: true
    }, (eventType, filename2) => {
      log(`File ${eventType}: ${filename2}`);
    });
    log("Convex App demo initialized!");
    log("");
    log("Project structure:");
    listFiles(vfs2, "/", log, "  ");
    return {
      vfs: vfs2,
      runtime
    };
  };
  startConvexAppDevServer = async function(vfs2, options2 = {}) {
    const port = options2.port || 3002;
    const log = options2.log || console.log;
    log("Starting Convex App dev server...");
    const server = new NextDevServer(vfs2, {
      port,
      root: "/",
      preferAppRouter: true
    });
    const bridge = getServerBridge();
    try {
      log("Initializing Service Worker...");
      await bridge.initServiceWorker();
      log("Service Worker ready");
    } catch (error) {
      log(`Warning: Service Worker failed to initialize: ${error}`);
      log("Falling back to direct request handling...");
    }
    bridge.on("server-ready", (p, u) => {
      log(`Server ready at ${u}`);
    });
    const httpServer = createHttpServerWrapper(server);
    bridge.registerServer(httpServer, port);
    server.start();
    log("File watcher started");
    server.on("hmr-update", (update) => {
      log(`HMR update: ${JSON.stringify(update)}`);
    });
    const url2 = bridge.getServerUrl(port);
    log(`Convex App dev server running at: ${url2}/`);
    return {
      server,
      url: url2 + "/",
      stop: () => {
        server.stop();
        bridge.unregisterServer(port);
      }
    };
  };
  function createHttpServerWrapper(devServer) {
    return {
      listening: true,
      address: () => ({
        port: devServer.getPort(),
        address: "0.0.0.0",
        family: "IPv4"
      }),
      async handleRequest(method, url2, headers, body) {
        const bodyBuffer = body ? typeof body === "string" ? BufferPolyfill.from(body) : body : void 0;
        return devServer.handleRequest(method, url2, headers, bodyBuffer);
      }
    };
  }
  function listFiles(vfs2, path2, log, indent) {
    try {
      const entries = vfs2.readdirSync(path2);
      for (const entry of entries) {
        if (entry === "node_modules") {
          log(`${indent}${entry}/ (skipped)`);
          continue;
        }
        const fullPath = path2 === "/" ? `/${entry}` : `${path2}/${entry}`;
        try {
          const stat = vfs2.statSync(fullPath);
          if (stat.isDirectory()) {
            log(`${indent}${entry}/`);
            listFiles(vfs2, fullPath, log, indent + "  ");
          } else {
            log(`${indent}${entry}`);
          }
        } catch {
          log(`${indent}${entry}`);
        }
      }
    } catch {
    }
  }
  createContainer = function(options2) {
    const vfs2 = new VirtualFS();
    const runtime = new Runtime(vfs2, options2);
    const npmManager = new PackageManager(vfs2);
    const serverBridge = getServerBridge({
      baseUrl: options2 == null ? void 0 : options2.baseUrl,
      onServerReady: options2 == null ? void 0 : options2.onServerReady
    });
    return {
      vfs: vfs2,
      runtime,
      npm: npmManager,
      serverBridge,
      execute: (code2, filename2) => runtime.execute(code2, filename2),
      runFile: (filename2) => runtime.runFile(filename2),
      createREPL: () => runtime.createREPL(),
      on: (event, listener) => {
        serverBridge.on(event, listener);
      }
    };
  };
})();
export {
  DEMO_PACKAGES as CONVEX_APP_DEMO_PACKAGES,
  PACKAGE_JSON as CONVEX_APP_PACKAGE_JSON,
  DevServer,
  NextDevServer,
  PackageManager,
  Runtime,
  SANDBOX_SETUP_INSTRUCTIONS,
  SandboxRuntime,
  ServerBridge,
  VirtualFS,
  ViteDevServer,
  WorkerRuntime,
  __tla,
  assert$1 as assert,
  chokidarShim as chokidar,
  createContainer,
  createConvexAppProject,
  createFsShim,
  createProcess,
  createRuntime,
  createContainer as default,
  esbuildShim as esbuild,
  events$1 as events,
  execute,
  fseventsShim as fsevents,
  generateSandboxFiles,
  getSandboxHtml,
  getSandboxVercelConfig,
  getServerBridge,
  httpShim as http,
  initConvexAppDemo,
  install,
  moduleShim as module,
  netShim as net,
  index as npm,
  pathShim as path,
  perfHooksShim as perf_hooks,
  querystringShim as querystring,
  readdirpShim as readdirp,
  resetServerBridge,
  rollupShim as rollup,
  startConvexAppDevServer,
  stream,
  urlShim as url,
  utilShim as util,
  workerThreadsShim as worker_threads,
  wsShim as ws
};
